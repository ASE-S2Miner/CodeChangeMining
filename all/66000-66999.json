[{"original_method":"private boolean checkMultiple(\n        ResolveSession session,\n        UsedBlames usedBlames,\n        Blame usedBlame,\n        Candidates permutation)\n    {\n        // Check the root requirement to see if it is a multiple cardinality\n        // requirement.\n        List<Capability> candidates = null;\n        Requirement req = usedBlame.m_reqs.get(0);\n        if (Util.isMultiple(req))\n        {\n            // Create a copy of the current permutation so we can remove the\n            // candidates causing the blame.\n            if (session.getMultipleCardCandidates() == null)\n            {\n                session.setMultipleCardCandidates(permutation.copy());\n            }\n            // Get the current candidate list and remove all the offending root\n            // cause candidates from a copy of the current permutation.\n            candidates = session.getMultipleCardCandidates().clearCandidates(req, usedBlames.getRootCauses(req));\n        }\n        // We only are successful if there is at least one candidate left\n        // for the requirement\n        return (candidates != null) && !candidates.isEmpty();\n    }","id":66000,"modified_method":"private boolean checkMultiple(\n        ResolveSession session,\n        UsedBlames usedBlames,\n        Blame usedBlame,\n        Candidates permutation)\n    {\n        // Check the root requirement to see if it is a multiple cardinality\n        // requirement.\n        List<Capability> candidates = null;\n        Requirement req = usedBlame.m_reqs.get(0);\n        if (Util.isMultiple(req))\n        {\n            // Create a copy of the current permutation so we can remove the\n            // candidates causing the blame.\n            if (session.getMultipleCardCandidates() == null)\n            {\n                session.setMultipleCardCandidates(permutation.copy());\n            }\n            // Get the current candidate list and remove all the offending root\n            // cause candidates from a copy of the current permutation.\n            candidates = session.getMultipleCardCandidates().getCandidates(req);\n            candidates.removeAll(usedBlames.getRootCauses(req));\n        }\n        // We only are successful if there is at least one candidate left\n        // for the requirement\n        return (candidates != null) && !candidates.isEmpty();\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private void checkDynamicPackageSpaceConsistency(\n        ResolveSession session,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, Object> resultCache) throws ResolutionException\n    {\n        if (resultCache.containsKey(resource))\n        {\n            return;\n        }\n\n        Packages pkgs = resourcePkgMap.get(resource);\n\n        ResolutionException rethrow = null;\n        Candidates permutation = null;\n        Set<Requirement> mutated = null;\n\n        List<Candidates> importPermutations = session.getImportPermutations();\n        List<Candidates> usesPermutations = session.getUsesPermutations();\n\n        // Check for conflicting imports from fragments.\n        // TODO: Is this only needed for imports or are generic and bundle requirements also needed?\n        //       I think this is only a special case for fragment imports because they can overlap\n        //       host imports, which is not allowed in normal metadata.\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            if (entry.getValue().size() > 1)\n            {\n                Blame sourceBlame = null;\n                for (Blame blame : entry.getValue())\n                {\n                    if (sourceBlame == null)\n                    {\n                        sourceBlame = blame;\n                    }\n                    else if (!sourceBlame.m_cap.getResource().equals(blame.m_cap.getResource()))\n                    {\n                        // Try to permutate the conflicting requirement.\n                        allCandidates.permutate(blame.m_reqs.get(0), importPermutations);\n                        // Try to permutate the source requirement.\n                        allCandidates.permutate(sourceBlame.m_reqs.get(0), importPermutations);\n                        // Report conflict.\n                        ResolutionException ex = new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it is exposed to package '\"\n                            + entry.getKey()\n                            + \"' from resources \"\n                            + Util.getSymbolicName(sourceBlame.m_cap.getResource())\n                            + \" [\" + sourceBlame.m_cap.getResource()\n                            + \"] and \"\n                            + Util.getSymbolicName(blame.m_cap.getResource())\n                            + \" [\" + blame.m_cap.getResource()\n                            + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                            + toStringBlame(session.getContext(), allCandidates, sourceBlame)\n                            + \"\\n\\nChain 2:\\n\"\n                            + toStringBlame(session.getContext(), allCandidates, blame),\n                            null,\n                            Collections.singleton(blame.m_reqs.get(0)));\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Candidate permutation failed due to a conflict with a \"\n                            + \"fragment import; will try another if possible.\",\n                            ex);\n                        throw ex;\n                    }\n                }\n            }\n        }\n\n        // Check if there are any uses conflicts with exported packages.\n        for (Entry<String, Blame> entry : pkgs.m_exportedPkgs.entrySet())\n        {\n            String pkgName = entry.getKey();\n            Blame exportBlame = entry.getValue();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n            for (UsedBlames usedBlames : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(session, Collections.singletonList(exportBlame), usedBlames.m_cap, resourcePkgMap))\n                {\n                    for (Blame usedBlame : usedBlames.m_blames)\n                    {\n                        if (checkMultiple(session, usedBlames, usedBlame, allCandidates))\n                        {\n                            // Continue to the next usedBlame, if possible we\n                            // removed the conflicting candidates.\n                            continue;\n                        }\n                        // Create a candidate permutation that eliminates all candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it exports package '\"\n                                + pkgName\n                                + \"' and is also exposed to it from resource \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via the following dependency chain:\\n\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet<Requirement>();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n                            // Sanity check for multiple.\n                            if (Util.isMultiple(req))\n                            {\n                                continue;\n                            }\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            if (permutation.canRemoveCandidate(req)) {\n                                permutation.removeFirstCandidate(req);\n                                mutated.add(req);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (rethrow != null)\n            {\n                if (!mutated.isEmpty())\n                {\n                    usesPermutations.add(permutation);\n                }\n                m_logger.log(\n                    Logger.LOG_DEBUG,\n                    \"Candidate permutation failed due to a conflict between \"\n                    + \"an export and import; will try another if possible.\",\n                    rethrow);\n                throw rethrow;\n            }\n        }\n\n        // Check if there are any uses conflicts with imported and required packages.\n        // We combine the imported and required packages here into one map.\n        // Imported packages are added after required packages because they shadow or override\n        // the packages from required bundles.\n        Map<String, List<Blame>> allImportRequirePkgs =\n            new HashMap<String, List<Blame>>(pkgs.m_requiredPkgs);\n        allImportRequirePkgs.putAll(pkgs.m_importedPkgs);\n\n        for (Entry<String, List<Blame>> requirementBlames : allImportRequirePkgs.entrySet())\n        {\n            String pkgName = requirementBlames.getKey();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n\n            for (UsedBlames usedBlames : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(session, requirementBlames.getValue(), usedBlames.m_cap, resourcePkgMap))\n                {\n                    // Split packages, need to think how to get a good message for split packages (sigh)\n                    // For now we just use the first requirement that brings in the package that conflicts\n                    Blame requirementBlame = requirementBlames.getValue().get(0);\n                    for (Blame usedBlame : usedBlames.m_blames)\n                    {\n                        if (checkMultiple(session, usedBlames, usedBlame, allCandidates))\n                        {\n                            // Continue to the next usedBlame, if possible we\n                            // removed the conflicting candidates.\n                            continue;\n                        }\n                        // Create a candidate permutation that eliminates all candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it is exposed to package '\"\n                                + pkgName\n                                + \"' from resources \"\n                                + Util.getSymbolicName(requirementBlame.m_cap.getResource())\n                                + \" [\" + requirementBlame.m_cap.getResource()\n                                + \"] and \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, requirementBlame)\n                                + \"\\n\\nChain 2:\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet<Requirement>();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n                            // Sanity check for multiple.\n                            if (Util.isMultiple(req))\n                            {\n                                continue;\n                            }\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            if (permutation.canRemoveCandidate(req)) {\n                                permutation.removeFirstCandidate(req);\n                                mutated.add(req);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // If there was a uses conflict, then we should add a uses\n                // permutation if we were able to permutate any candidates.\n                // Additionally, we should try to push an import permutation\n                // for the original import to force a backtracking on the\n                // original candidate decision if no viable candidate is found\n                // for the conflicting uses constraint.\n                if (rethrow != null)\n                {\n                    // Add uses permutation if we mutated any candidates.\n                    if (!mutated.isEmpty())\n                    {\n                        usesPermutations.add(permutation);\n                    }\n\n                    // Try to permutate the candidate for the original\n                    // import requirement; only permutate it if we haven't\n                    // done so already.\n                    for (Blame requirementBlame : requirementBlames.getValue())\n                    {\n                        Requirement req = requirementBlame.m_reqs.get(0);\n                        if (!mutated.contains(req))\n                        {\n                            // Since there may be lots of uses constraint violations\n                            // with existing import decisions, we may end up trying\n                            // to permutate the same import a lot of times, so we should\n                            // try to check if that the case and only permutate it once.\n                            allCandidates.permutateIfNeeded(req, importPermutations);\n                        }\n                    }\n\n                    m_logger.log(\n                        Logger.LOG_DEBUG,\n                        \"Candidate permutation failed due to a conflict between \"\n                        + \"imports; will try another if possible.\",\n                        rethrow);\n                    throw rethrow;\n                }\n            }\n        }\n\n        resultCache.put(resource, Boolean.TRUE);\n\n        // Now check the consistency of all resources on which the\n        // current resource depends. Keep track of the current number\n        // of permutations so we know if the lower level check was\n        // able to create a permutation or not in the case of failure.\n        int permCount = usesPermutations.size() + importPermutations.size();\n        for (Requirement req : resource.getRequirements(null))\n        {\n            Capability cap = allCandidates.getFirstCandidate(req);\n            if (cap != null)\n            {\n                if (!resource.equals(cap.getResource()))\n                {\n                    try\n                    {\n                        checkPackageSpaceConsistency(\n                            session, cap.getResource(),\n                            allCandidates, resourcePkgMap, resultCache);\n                    }\n                    catch (ResolutionException ex)\n                    {\n                        // If the lower level check didn't create any permutations,\n                        // then we should create an import permutation for the\n                        // requirement with the dependency on the failing resource\n                        // to backtrack on our current candidate selection.\n                        if (permCount == (usesPermutations.size() + importPermutations.size()))\n                        {\n                            allCandidates.permutate(req, importPermutations);\n                        }\n                        throw ex;\n                    }\n                }\n            }\n        }\n    }","id":66001,"modified_method":"private void checkDynamicPackageSpaceConsistency(\n        ResolveSession session,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, Object> resultCache) throws ResolutionException\n    {\n        if (resultCache.containsKey(resource))\n        {\n            return;\n        }\n\n        Packages pkgs = resourcePkgMap.get(resource);\n\n        ResolutionException rethrow = null;\n        Candidates permutation = null;\n        Set<Requirement> mutated = null;\n\n        List<Candidates> importPermutations = session.getImportPermutations();\n        List<Candidates> usesPermutations = session.getUsesPermutations();\n\n        // Check for conflicting imports from fragments.\n        // TODO: Is this only needed for imports or are generic and bundle requirements also needed?\n        //       I think this is only a special case for fragment imports because they can overlap\n        //       host imports, which is not allowed in normal metadata.\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            if (entry.getValue().size() > 1)\n            {\n                Blame sourceBlame = null;\n                for (Blame blame : entry.getValue())\n                {\n                    if (sourceBlame == null)\n                    {\n                        sourceBlame = blame;\n                    }\n                    else if (!sourceBlame.m_cap.getResource().equals(blame.m_cap.getResource()))\n                    {\n                        // Try to permutate the conflicting requirement.\n                        permutate(allCandidates, blame.m_reqs.get(0), importPermutations);\n                        // Try to permutate the source requirement.\n                        permutate(allCandidates, sourceBlame.m_reqs.get(0), importPermutations);\n                        // Report conflict.\n                        ResolutionException ex = new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it is exposed to package '\"\n                            + entry.getKey()\n                            + \"' from resources \"\n                            + Util.getSymbolicName(sourceBlame.m_cap.getResource())\n                            + \" [\" + sourceBlame.m_cap.getResource()\n                            + \"] and \"\n                            + Util.getSymbolicName(blame.m_cap.getResource())\n                            + \" [\" + blame.m_cap.getResource()\n                            + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                            + toStringBlame(session.getContext(), allCandidates, sourceBlame)\n                            + \"\\n\\nChain 2:\\n\"\n                            + toStringBlame(session.getContext(), allCandidates, blame),\n                            null,\n                            Collections.singleton(blame.m_reqs.get(0)));\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Candidate permutation failed due to a conflict with a \"\n                            + \"fragment import; will try another if possible.\",\n                            ex);\n                        throw ex;\n                    }\n                }\n            }\n        }\n\n        // Check if there are any uses conflicts with exported packages.\n        for (Entry<String, Blame> entry : pkgs.m_exportedPkgs.entrySet())\n        {\n            String pkgName = entry.getKey();\n            Blame exportBlame = entry.getValue();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n            for (UsedBlames usedBlames : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(session, Collections.singletonList(exportBlame), usedBlames.m_cap, resourcePkgMap))\n                {\n                    for (Blame usedBlame : usedBlames.m_blames)\n                    {\n                        if (checkMultiple(session, usedBlames, usedBlame, allCandidates))\n                        {\n                            // Continue to the next usedBlame, if possible we\n                            // removed the conflicting candidates.\n                            continue;\n                        }\n                        // Create a candidate permutation that eliminates all candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it exports package '\"\n                                + pkgName\n                                + \"' and is also exposed to it from resource \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via the following dependency chain:\\n\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet<Requirement>();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n                            // Sanity check for multiple.\n                            if (Util.isMultiple(req))\n                            {\n                                continue;\n                            }\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            List<Capability> candidates = permutation.getCandidates(req);\n                            if ((candidates != null) && (candidates.size() > 1 || Util.isOptional(req)))\n                            {\n                                mutated.add(req);\n                                // Remove the conflicting candidate.\n                                candidates.remove(0);\n                                if (candidates.isEmpty())\n                                {\n                                    permutation.clearCandidates(req);\n                                }\n                                // Continue with the next uses constraint.\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (rethrow != null)\n            {\n                if (!mutated.isEmpty())\n                {\n                    usesPermutations.add(permutation);\n                }\n                m_logger.log(\n                    Logger.LOG_DEBUG,\n                    \"Candidate permutation failed due to a conflict between \"\n                    + \"an export and import; will try another if possible.\",\n                    rethrow);\n                throw rethrow;\n            }\n        }\n\n        // Check if there are any uses conflicts with imported and required packages.\n        // We combine the imported and required packages here into one map.\n        // Imported packages are added after required packages because they shadow or override\n        // the packages from required bundles.\n        Map<String, List<Blame>> allImportRequirePkgs =\n            new HashMap<String, List<Blame>>(pkgs.m_requiredPkgs);\n        allImportRequirePkgs.putAll(pkgs.m_importedPkgs);\n\n        for (Entry<String, List<Blame>> requirementBlames : allImportRequirePkgs.entrySet())\n        {\n            String pkgName = requirementBlames.getKey();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n\n            for (UsedBlames usedBlames : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(session, requirementBlames.getValue(), usedBlames.m_cap, resourcePkgMap))\n                {\n                    // Split packages, need to think how to get a good message for split packages (sigh)\n                    // For now we just use the first requirement that brings in the package that conflicts\n                    Blame requirementBlame = requirementBlames.getValue().get(0);\n                    for (Blame usedBlame : usedBlames.m_blames)\n                    {\n                        if (checkMultiple(session, usedBlames, usedBlame, allCandidates))\n                        {\n                            // Continue to the next usedBlame, if possible we\n                            // removed the conflicting candidates.\n                            continue;\n                        }\n                        // Create a candidate permutation that eliminates all candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it is exposed to package '\"\n                                + pkgName\n                                + \"' from resources \"\n                                + Util.getSymbolicName(requirementBlame.m_cap.getResource())\n                                + \" [\" + requirementBlame.m_cap.getResource()\n                                + \"] and \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, requirementBlame)\n                                + \"\\n\\nChain 2:\\n\"\n                                + toStringBlame(session.getContext(), allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet<Requirement>();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n                            // Sanity check for multiple.\n                            if (Util.isMultiple(req))\n                            {\n                                continue;\n                            }\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            List<Capability> candidates = permutation.getCandidates(req);\n                            if ((candidates != null) && (candidates.size() > 1 || Util.isOptional(req)))\n                            {\n                                mutated.add(req);\n                                // Remove the conflicting candidate.\n                                candidates.remove(0);\n                                if (candidates.isEmpty())\n                                {\n                                    permutation.clearCandidates(req);\n                                }\n                                // Continue with the next uses constraint.\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // If there was a uses conflict, then we should add a uses\n                // permutation if we were able to permutate any candidates.\n                // Additionally, we should try to push an import permutation\n                // for the original import to force a backtracking on the\n                // original candidate decision if no viable candidate is found\n                // for the conflicting uses constraint.\n                if (rethrow != null)\n                {\n                    // Add uses permutation if we mutated any candidates.\n                    if (!mutated.isEmpty())\n                    {\n                        usesPermutations.add(permutation);\n                    }\n\n                    // Try to permutate the candidate for the original\n                    // import requirement; only permutate it if we haven't\n                    // done so already.\n                    for (Blame requirementBlame : requirementBlames.getValue())\n                    {\n                        Requirement req = requirementBlame.m_reqs.get(0);\n                        if (!mutated.contains(req))\n                        {\n                            // Since there may be lots of uses constraint violations\n                            // with existing import decisions, we may end up trying\n                            // to permutate the same import a lot of times, so we should\n                            // try to check if that the case and only permutate it once.\n                            permutateIfNeeded(allCandidates, req, importPermutations);\n                        }\n                    }\n\n                    m_logger.log(\n                        Logger.LOG_DEBUG,\n                        \"Candidate permutation failed due to a conflict between \"\n                        + \"imports; will try another if possible.\",\n                        rethrow);\n                    throw rethrow;\n                }\n            }\n        }\n\n        resultCache.put(resource, Boolean.TRUE);\n\n        // Now check the consistency of all resources on which the\n        // current resource depends. Keep track of the current number\n        // of permutations so we know if the lower level check was\n        // able to create a permutation or not in the case of failure.\n        int permCount = usesPermutations.size() + importPermutations.size();\n        for (Requirement req : resource.getRequirements(null))\n        {\n            List<Capability> cands = allCandidates.getCandidates(req);\n            if (cands != null && !cands.isEmpty())\n            {\n                Capability cap = cands.get(0);\n                if (!resource.equals(cap.getResource()))\n                {\n                    try\n                    {\n                        checkPackageSpaceConsistency(\n                            session, cap.getResource(),\n                            allCandidates, resourcePkgMap, resultCache);\n                    }\n                    catch (ResolutionException ex)\n                    {\n                        // If the lower level check didn't create any permutations,\n                        // then we should create an import permutation for the\n                        // requirement with the dependency on the failing resource\n                        // to backtrack on our current candidate selection.\n                        if (permCount == (usesPermutations.size() + importPermutations.size()))\n                        {\n                            permutate(allCandidates, req, importPermutations);\n                        }\n                        throw ex;\n                    }\n                }\n            }\n        }\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private static Map<Resource, List<Wire>> populateWireMap(\n        ResolveContext rc, Resource resource, Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, List<Wire>> wireMap, Candidates allCandidates)\n    {\n        Resource unwrappedResource = getDeclaredResource(resource);\n        if (!rc.getWirings().containsKey(unwrappedResource)\n            && !wireMap.containsKey(unwrappedResource))\n        {\n            wireMap.put(unwrappedResource, (List<Wire>) Collections.EMPTY_LIST);\n\n            List<Wire> packageWires = new ArrayList<Wire>();\n            List<Wire> bundleWires = new ArrayList<Wire>();\n            List<Wire> capabilityWires = new ArrayList<Wire>();\n\n            for (Requirement req : resource.getRequirements(null))\n            {\n                List<Capability> cands = allCandidates.getCandidates(req);\n                if ((cands != null) && (cands.size() > 0))\n                {\n                    for (Capability cand : cands)\n                    {\n                        // Do not create wires for the osgi.wiring.* namespaces\n                        // if the provider and requirer are the same resource;\n                        // allow such wires for non-OSGi wiring namespaces.\n                        if (!cand.getNamespace().startsWith(\"osgi.wiring.\")\n                            || !resource.equals(cand.getResource()))\n                        {\n                            // If we don't already have wires for the candidate,\n                            // then recursively populate them.\n                            if (!rc.getWirings().containsKey(cand.getResource()))\n                            {\n                                // Need to special case the candidate for identity\n                                // capabilities since it may be from a fragment and\n                                // we don't want to populate wires for the fragment,\n                                // but rather the host to which it is attached.\n                                Resource targetCand = cand.getResource();\n                                if (IdentityNamespace.IDENTITY_NAMESPACE.equals(cand.getNamespace())\n                                    && Util.isFragment(targetCand))\n                                {\n                                    targetCand = allCandidates.getFirstCandidate(\n                                            targetCand.getRequirements(HostNamespace.HOST_NAMESPACE).get(0))\n                                        .getResource();\n                                    targetCand = allCandidates.getWrappedHost(targetCand);\n                                }\n\n                                populateWireMap(rc, targetCand,\n                                    resourcePkgMap, wireMap, allCandidates);\n                            }\n\n                            Wire wire = new WireImpl(\n                                unwrappedResource,\n                                getDeclaredRequirement(req),\n                                getDeclaredResource(cand.getResource()),\n                                getDeclaredCapability(cand));\n                            if (req.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n                            {\n                                packageWires.add(wire);\n                            }\n                            else if (req.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n                            {\n                                bundleWires.add(wire);\n                            }\n                            else\n                            {\n                                capabilityWires.add(wire);\n                            }\n                        }\n                        if (!Util.isMultiple(req))\n                        {\n                            // If not multiple just create a wire for the first candidate.\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Combine package wires with require wires last.\n            packageWires.addAll(bundleWires);\n            packageWires.addAll(capabilityWires);\n            wireMap.put(unwrappedResource, packageWires);\n\n            // Add host wire for any fragments.\n            if (resource instanceof WrappedResource)\n            {\n                List<Resource> fragments = ((WrappedResource) resource).getFragments();\n                for (Resource fragment : fragments)\n                {\n                    // Get wire list for the fragment from the wire map.\n                    // If there isn't one, then create one. Note that we won't\n                    // add the wire list to the wire map until the end, so\n                    // we can determine below if this is the first time we've\n                    // seen the fragment while populating wires to avoid\n                    // creating duplicate non-payload wires if the fragment\n                    // is attached to more than one host.\n                    List<Wire> fragmentWires = wireMap.get(fragment);\n                    fragmentWires = (fragmentWires == null)\n                        ? new ArrayList<Wire>() : fragmentWires;\n\n                    // Loop through all of the fragment's requirements and create\n                    // any necessary wires for non-payload requirements.\n                    for (Requirement req : fragment.getRequirements(null))\n                    {\n                        // Only look at non-payload requirements.\n                        if (!isPayload(req))\n                        {\n                            // If this is the host requirement, then always create\n                            // a wire for it to the current resource.\n                            if (req.getNamespace().equals(HostNamespace.HOST_NAMESPACE))\n                            {\n                                fragmentWires.add(\n                                    new WireImpl(\n                                        getDeclaredResource(fragment),\n                                        req,\n                                        unwrappedResource,\n                                        unwrappedResource.getCapabilities(\n                                            HostNamespace.HOST_NAMESPACE).get(0)));\n                            }\n                            // Otherwise, if the fragment isn't already resolved and\n                            // this is the first time we are seeing it, then create\n                            // a wire for the non-payload requirement.\n                            else if (!rc.getWirings().containsKey(fragment)\n                                && !wireMap.containsKey(fragment))\n                            {\n                                Wire wire = createWire(req, allCandidates);\n                                if (wire != null)\n                                {\n                                    fragmentWires.add(wire);\n                                }\n                            }\n                        }\n                    }\n\n                    // Finally, add the fragment's wire list to the wire map.\n                    wireMap.put(fragment, fragmentWires);\n                }\n            }\n        }\n\n        return wireMap;\n    }","id":66002,"modified_method":"private static Map<Resource, List<Wire>> populateWireMap(\n        ResolveContext rc, Resource resource, Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, List<Wire>> wireMap, Candidates allCandidates)\n    {\n        Resource unwrappedResource = getDeclaredResource(resource);\n        if (!rc.getWirings().containsKey(unwrappedResource)\n            && !wireMap.containsKey(unwrappedResource))\n        {\n            wireMap.put(unwrappedResource, (List<Wire>) Collections.EMPTY_LIST);\n\n            List<Wire> packageWires = new ArrayList<Wire>();\n            List<Wire> bundleWires = new ArrayList<Wire>();\n            List<Wire> capabilityWires = new ArrayList<Wire>();\n\n            for (Requirement req : resource.getRequirements(null))\n            {\n                List<Capability> cands = allCandidates.getCandidates(req);\n                if ((cands != null) && (cands.size() > 0))\n                {\n                    for (Capability cand : cands)\n                    {\n                        // Do not create wires for the osgi.wiring.* namespaces\n                        // if the provider and requirer are the same resource;\n                        // allow such wires for non-OSGi wiring namespaces.\n                        if (!cand.getNamespace().startsWith(\"osgi.wiring.\")\n                            || !resource.equals(cand.getResource()))\n                        {\n                            // If we don't already have wires for the candidate,\n                            // then recursively populate them.\n                            if (!rc.getWirings().containsKey(cand.getResource()))\n                            {\n                                // Need to special case the candidate for identity\n                                // capabilities since it may be from a fragment and\n                                // we don't want to populate wires for the fragment,\n                                // but rather the host to which it is attached.\n                                Resource targetCand = cand.getResource();\n                                if (IdentityNamespace.IDENTITY_NAMESPACE.equals(cand.getNamespace())\n                                    && Util.isFragment(targetCand))\n                                {\n                                    targetCand = allCandidates.getCandidates(\n                                        targetCand.getRequirements(HostNamespace.HOST_NAMESPACE).get(0))\n                                        .iterator().next().getResource();\n                                    targetCand = allCandidates.getWrappedHost(targetCand);\n                                }\n\n                                populateWireMap(rc, targetCand,\n                                    resourcePkgMap, wireMap, allCandidates);\n                            }\n\n                            Wire wire = new WireImpl(\n                                unwrappedResource,\n                                getDeclaredRequirement(req),\n                                getDeclaredResource(cand.getResource()),\n                                getDeclaredCapability(cand));\n                            if (req.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n                            {\n                                packageWires.add(wire);\n                            }\n                            else if (req.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n                            {\n                                bundleWires.add(wire);\n                            }\n                            else\n                            {\n                                capabilityWires.add(wire);\n                            }\n                        }\n                        if (!Util.isMultiple(req))\n                        {\n                            // If not multiple just create a wire for the first candidate.\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Combine package wires with require wires last.\n            packageWires.addAll(bundleWires);\n            packageWires.addAll(capabilityWires);\n            wireMap.put(unwrappedResource, packageWires);\n\n            // Add host wire for any fragments.\n            if (resource instanceof WrappedResource)\n            {\n                List<Resource> fragments = ((WrappedResource) resource).getFragments();\n                for (Resource fragment : fragments)\n                {\n                    // Get wire list for the fragment from the wire map.\n                    // If there isn't one, then create one. Note that we won't\n                    // add the wire list to the wire map until the end, so\n                    // we can determine below if this is the first time we've\n                    // seen the fragment while populating wires to avoid\n                    // creating duplicate non-payload wires if the fragment\n                    // is attached to more than one host.\n                    List<Wire> fragmentWires = wireMap.get(fragment);\n                    fragmentWires = (fragmentWires == null)\n                        ? new ArrayList<Wire>() : fragmentWires;\n\n                    // Loop through all of the fragment's requirements and create\n                    // any necessary wires for non-payload requirements.\n                    for (Requirement req : fragment.getRequirements(null))\n                    {\n                        // Only look at non-payload requirements.\n                        if (!isPayload(req))\n                        {\n                            // If this is the host requirement, then always create\n                            // a wire for it to the current resource.\n                            if (req.getNamespace().equals(HostNamespace.HOST_NAMESPACE))\n                            {\n                                fragmentWires.add(\n                                    new WireImpl(\n                                        getDeclaredResource(fragment),\n                                        req,\n                                        unwrappedResource,\n                                        unwrappedResource.getCapabilities(\n                                            HostNamespace.HOST_NAMESPACE).get(0)));\n                            }\n                            // Otherwise, if the fragment isn't already resolved and\n                            // this is the first time we are seeing it, then create\n                            // a wire for the non-payload requirement.\n                            else if (!rc.getWirings().containsKey(fragment)\n                                && !wireMap.containsKey(fragment))\n                            {\n                                Wire wire = createWire(req, allCandidates);\n                                if (wire != null)\n                                {\n                                    fragmentWires.add(wire);\n                                }\n                            }\n                        }\n                    }\n\n                    // Finally, add the fragment's wire list to the wire map.\n                    wireMap.put(fragment, fragmentWires);\n                }\n            }\n        }\n\n        return wireMap;\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private void mergeCandidatePackages(\n        ResolveContext rc, Resource current, Requirement currentReq,\n        Capability candCap, Map<Resource, Packages> resourcePkgMap,\n        Candidates allCandidates, Map<Resource, List<Capability>> cycles)\n    {\n        List<Capability> cycleCaps = cycles.get(current);\n        if (cycleCaps == null)\n        {\n            cycleCaps = new ArrayList<Capability>();\n            cycles.put(current, cycleCaps);\n        }\n        if (cycleCaps.contains(candCap))\n        {\n            return;\n        }\n        cycleCaps.add(candCap);\n\n        if (candCap.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n        {\n            mergeCandidatePackage(\n                current, false, currentReq, candCap, resourcePkgMap);\n        }\n        else if (candCap.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n        {\n// TODO: FELIX3 - THIS NEXT LINE IS A HACK. IMPROVE HOW/WHEN WE CALCULATE EXPORTS.\n            calculateExportedPackages(\n                rc, candCap.getResource(), allCandidates, resourcePkgMap);\n\n            // Get the candidate's package space to determine which packages\n            // will be visible to the current resource.\n            Packages candPkgs = resourcePkgMap.get(candCap.getResource());\n\n            // We have to merge all exported packages from the candidate,\n            // since the current resource requires it.\n            for (Entry<String, Blame> entry : candPkgs.m_exportedPkgs.entrySet())\n            {\n                mergeCandidatePackage(\n                    current,\n                    true,\n                    currentReq,\n                    entry.getValue().m_cap,\n                    resourcePkgMap);\n            }\n\n            // If the candidate requires any other bundles with reexport visibility,\n            // then we also need to merge their packages too.\n            Wiring candWiring = rc.getWirings().get(candCap.getResource());\n            if (candWiring != null)\n            {\n                for (Wire w : candWiring.getRequiredResourceWires(null))\n                {\n                    if (w.getRequirement().getNamespace()\n                        .equals(BundleNamespace.BUNDLE_NAMESPACE))\n                    {\n                        String value = w.getRequirement()\n                            .getDirectives()\n                            .get(BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE);\n                        if ((value != null)\n                            && value.equals(BundleNamespace.VISIBILITY_REEXPORT))\n                        {\n                            mergeCandidatePackages(\n                                rc,\n                                current,\n                                currentReq,\n                                w.getCapability(),\n                                resourcePkgMap,\n                                allCandidates,\n                                cycles);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for (Requirement req : candCap.getResource().getRequirements(null))\n                {\n                    if (req.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n                    {\n                        String value =\n                            req.getDirectives()\n                            .get(BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE);\n                        if ((value != null)\n                            && value.equals(BundleNamespace.VISIBILITY_REEXPORT))\n                        {\n                            Capability cap = allCandidates.getFirstCandidate(req);\n                            if (cap != null) {\n                                mergeCandidatePackages(\n                                        rc,\n                                        current,\n                                        currentReq,\n                                        cap,\n                                        resourcePkgMap,\n                                        allCandidates,\n                                        cycles);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        cycles.remove(current);\n    }","id":66003,"modified_method":"private void mergeCandidatePackages(\n        ResolveContext rc, Resource current, Requirement currentReq,\n        Capability candCap, Map<Resource, Packages> resourcePkgMap,\n        Candidates allCandidates, Map<Resource, List<Capability>> cycles)\n    {\n        List<Capability> cycleCaps = cycles.get(current);\n        if (cycleCaps == null)\n        {\n            cycleCaps = new ArrayList<Capability>();\n            cycles.put(current, cycleCaps);\n        }\n        if (cycleCaps.contains(candCap))\n        {\n            return;\n        }\n        cycleCaps.add(candCap);\n\n        if (candCap.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n        {\n            mergeCandidatePackage(\n                current, false, currentReq, candCap, resourcePkgMap);\n        }\n        else if (candCap.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n        {\n// TODO: FELIX3 - THIS NEXT LINE IS A HACK. IMPROVE HOW/WHEN WE CALCULATE EXPORTS.\n            calculateExportedPackages(\n                rc, candCap.getResource(), allCandidates, resourcePkgMap);\n\n            // Get the candidate's package space to determine which packages\n            // will be visible to the current resource.\n            Packages candPkgs = resourcePkgMap.get(candCap.getResource());\n\n            // We have to merge all exported packages from the candidate,\n            // since the current resource requires it.\n            for (Entry<String, Blame> entry : candPkgs.m_exportedPkgs.entrySet())\n            {\n                mergeCandidatePackage(\n                    current,\n                    true,\n                    currentReq,\n                    entry.getValue().m_cap,\n                    resourcePkgMap);\n            }\n\n            // If the candidate requires any other bundles with reexport visibility,\n            // then we also need to merge their packages too.\n            Wiring candWiring = rc.getWirings().get(candCap.getResource());\n            if (candWiring != null)\n            {\n                for (Wire w : candWiring.getRequiredResourceWires(null))\n                {\n                    if (w.getRequirement().getNamespace()\n                        .equals(BundleNamespace.BUNDLE_NAMESPACE))\n                    {\n                        String value = w.getRequirement()\n                            .getDirectives()\n                            .get(BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE);\n                        if ((value != null)\n                            && value.equals(BundleNamespace.VISIBILITY_REEXPORT))\n                        {\n                            mergeCandidatePackages(\n                                rc,\n                                current,\n                                currentReq,\n                                w.getCapability(),\n                                resourcePkgMap,\n                                allCandidates,\n                                cycles);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for (Requirement req : candCap.getResource().getRequirements(null))\n                {\n                    if (req.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))\n                    {\n                        String value =\n                            req.getDirectives()\n                            .get(BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE);\n                        if ((value != null)\n                            && value.equals(BundleNamespace.VISIBILITY_REEXPORT)\n                            && (allCandidates.getCandidates(req) != null))\n                        {\n                            mergeCandidatePackages(\n                                rc,\n                                current,\n                                currentReq,\n                                allCandidates.getCandidates(req).iterator().next(),\n                                resourcePkgMap,\n                                allCandidates,\n                                cycles);\n                        }\n                    }\n                }\n            }\n        }\n\n        cycles.remove(current);\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private static void calculateExportedPackages(\n        ResolveContext rc,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap)\n    {\n        Packages packages = resourcePkgMap.get(resource);\n        if (packages != null)\n        {\n            return;\n        }\n        packages = new Packages(resource);\n\n        // Get all exported packages.\n        Wiring wiring = rc.getWirings().get(resource);\n        List<Capability> caps = (wiring != null)\n            ? wiring.getResourceCapabilities(null)\n            : resource.getCapabilities(null);\n        Map<String, Capability> exports = new HashMap<String, Capability>(caps.size());\n        for (Capability cap : caps)\n        {\n            if (cap.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n            {\n                if (!cap.getResource().equals(resource))\n                {\n                    cap = new WrappedCapability(resource, cap);\n                }\n                exports.put(\n                    (String) cap.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE),\n                    cap);\n            }\n        }\n        // Remove substitutable exports that were imported.\n        // For resolved resources Wiring.getCapabilities()\n        // already excludes imported substitutable exports, but\n        // for resolving resources we must look in the candidate\n        // map to determine which exports are substitutable.\n        if (!exports.isEmpty())\n        {\n            if (wiring == null)\n            {\n                for (Requirement req : resource.getRequirements(null))\n                {\n                    if (req.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n                    {\n                        Capability cand = allCandidates.getFirstCandidate(req);\n                        if (cand != null)\n                        {\n                            String pkgName = (String) cand.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE);\n                            exports.remove(pkgName);\n                        }\n                    }\n                }\n            }\n\n            // Add all non-substituted exports to the resources's package space.\n            for (Entry<String, Capability> entry : exports.entrySet())\n            {\n                packages.m_exportedPkgs.put(\n                    entry.getKey(), new Blame(entry.getValue(), null));\n            }\n        }\n\n        resourcePkgMap.put(resource, packages);\n    }","id":66004,"modified_method":"private static void calculateExportedPackages(\n        ResolveContext rc,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap)\n    {\n        Packages packages = resourcePkgMap.get(resource);\n        if (packages != null)\n        {\n            return;\n        }\n        packages = new Packages(resource);\n\n        // Get all exported packages.\n        Wiring wiring = rc.getWirings().get(resource);\n        List<Capability> caps = (wiring != null)\n            ? wiring.getResourceCapabilities(null)\n            : resource.getCapabilities(null);\n        Map<String, Capability> exports = new HashMap<String, Capability>(caps.size());\n        for (Capability cap : caps)\n        {\n            if (cap.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n            {\n                if (!cap.getResource().equals(resource))\n                {\n                    cap = new WrappedCapability(resource, cap);\n                }\n                exports.put(\n                    (String) cap.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE),\n                    cap);\n            }\n        }\n        // Remove substitutable exports that were imported.\n        // For resolved resources Wiring.getCapabilities()\n        // already excludes imported substitutable exports, but\n        // for resolving resources we must look in the candidate\n        // map to determine which exports are substitutable.\n        if (!exports.isEmpty())\n        {\n            if (wiring == null)\n            {\n                for (Requirement req : resource.getRequirements(null))\n                {\n                    if (req.getNamespace().equals(PackageNamespace.PACKAGE_NAMESPACE))\n                    {\n                        List<Capability> cands = allCandidates.getCandidates(req);\n                        if ((cands != null) && !cands.isEmpty())\n                        {\n                            String pkgName = (String) cands.get(0)\n                                .getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE);\n                            exports.remove(pkgName);\n                        }\n                    }\n                }\n            }\n\n            // Add all non-substituted exports to the resources's package space.\n            for (Entry<String, Capability> entry : exports.entrySet())\n            {\n                packages.m_exportedPkgs.put(\n                    entry.getKey(), new Blame(entry.getValue(), null));\n            }\n        }\n\n        resourcePkgMap.put(resource, packages);\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"public void destroy() {\n        close();\n        if (!isDestroyed.compareAndSet(false, true)) {\n            return;\n        }\n        isClosed.set(true);\n        final Operation op = new CacheDestroyOperation(getDistributedObjectName());\n        int partitionId = getNodeEngine().getPartitionService().getPartitionId(getDistributedObjectName());\n        final InternalCompletableFuture f = getNodeEngine().getOperationService()\n                                                           .invokeOnPartition(CacheService.SERVICE_NAME, op, partitionId);\n        f.getSafely();\n        cacheService.destroyCache(getDistributedObjectName(), true, null);\n    }","id":66005,"modified_method":"public void destroy() {\n        close();\n        if (!isDestroyed.compareAndSet(false, true)) {\n            return;\n        }\n        isClosed.set(true);\n        Operation operation = operationProvider.createDestroyOperation();\n        int partitionId = getNodeEngine().getPartitionService().getPartitionId(getDistributedObjectName());\n        OperationService operationService = getNodeEngine().getOperationService();\n        InternalCompletableFuture f = operationService .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionId);\n        f.getSafely();\n        cacheService.destroyCache(getDistributedObjectName(), true, null);\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int size() {\n        ensureOpen();\n        try {\n            final SerializationService serializationService = getNodeEngine().getSerializationService();\n            final CacheSizeOperationFactory operationFactory = new CacheSizeOperationFactory(getDistributedObjectName());\n            final Map<Integer, Object> results = getNodeEngine().getOperationService()\n                                                                .invokeOnAllPartitions(getServiceName(), operationFactory);\n            int total = 0;\n            for (Object result : results.values()) {\n                Integer size;\n                if (result instanceof Data) {\n                    size = serializationService.toObject((Data) result);\n                } else {\n                    size = (Integer) result;\n                }\n                total += size;\n            }\n            return total;\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrowAllowedTypeFirst(t, CacheException.class);\n        }\n    }","id":66006,"modified_method":"@Override\n    public int size() {\n        ensureOpen();\n        try {\n            final SerializationService serializationService = getNodeEngine().getSerializationService();\n            OperationFactory operationFactory = operationProvider.createSizeOperationFactory();\n            final Map<Integer, Object> results = getNodeEngine().getOperationService()\n                                                                .invokeOnAllPartitions(getServiceName(), operationFactory);\n            int total = 0;\n            for (Object result : results.values()) {\n                total += (Integer)serializationService.toObject(result);\n            }\n            return total;\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrowAllowedTypeFirst(t, CacheException.class);\n        }\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Map<K, V> getAll(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {\n        ensureOpen();\n        validateNotNull(keys);\n        if (keys.isEmpty()) {\n            return Collections.EMPTY_MAP;\n        }\n        final Set<Data> ks = new HashSet(keys.size());\n        for (K key : keys) {\n            final Data k = serializationService.toData(key);\n            ks.add(k);\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        final Collection<Integer> partitions = getPartitionsForKeys(ks);\n        try {\n            final CacheGetAllOperationFactory factory = new CacheGetAllOperationFactory(getDistributedObjectName(), ks,\n                    expiryPolicy);\n            final Map<Integer, Object> responses = getNodeEngine().getOperationService()\n                                                                  .invokeOnPartitions(getServiceName(), factory, partitions);\n            for (Object response : responses.values()) {\n                final Object responseObject = serializationService.toObject(response);\n                final Set<Map.Entry<Data, Data>> entries = ((MapEntrySet) responseObject).getEntrySet();\n                for (Map.Entry<Data, Data> entry : entries) {\n                    final V value = serializationService.toObject(entry.getValue());\n                    final K key = serializationService.toObject(entry.getKey());\n                    result.put(key, value);\n                }\n            }\n        } catch (Throwable e) {\n            throw ExceptionUtil.rethrowAllowedTypeFirst(e, CacheException.class);\n        }\n        return result;\n    }","id":66007,"modified_method":"@Override\n    public Map<K, V> getAll(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {\n        ensureOpen();\n        validateNotNull(keys);\n        if (keys.isEmpty()) {\n            return Collections.EMPTY_MAP;\n        }\n        final Set<Data> ks = new HashSet(keys.size());\n        for (K key : keys) {\n            final Data k = serializationService.toData(key);\n            ks.add(k);\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        final Collection<Integer> partitions = getPartitionsForKeys(ks);\n        try {\n            OperationFactory factory = operationProvider.createGetAllOperationFactory(ks, expiryPolicy);\n            OperationService operationService = getNodeEngine().getOperationService();\n            Map<Integer, Object> responses = operationService.invokeOnPartitions(getServiceName(), factory, partitions);\n            for (Object response : responses.values()) {\n                final Object responseObject = serializationService.toObject(response);\n                final Set<Map.Entry<Data, Data>> entries = ((MapEntrySet) responseObject).getEntrySet();\n                for (Map.Entry<Data, Data> entry : entries) {\n                    final V value = serializationService.toObject(entry.getValue());\n                    final K key = serializationService.toObject(entry.getKey());\n                    result.put(key, value);\n                }\n            }\n        } catch (Throwable e) {\n            throw ExceptionUtil.rethrowAllowedTypeFirst(e, CacheException.class);\n        }\n        return result;\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected InternalCompletableFuture<Boolean> putIfAbsentAsyncInternal(K key, V value, ExpiryPolicy expiryPolicy,\n                                                                          boolean withCompletionEvent) {\n        ensureOpen();\n        validateNotNull(key, value);\n        CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, value);\n        final Data keyData = serializationService.toData(key);\n        final Data valueData = serializationService.toData(value);\n        final Operation op = new CachePutIfAbsentOperation(getDistributedObjectName(), keyData, valueData, expiryPolicy);\n        return invoke(op, keyData, withCompletionEvent);\n    }","id":66008,"modified_method":"protected InternalCompletableFuture<Boolean> putIfAbsentAsyncInternal(K key, V value, ExpiryPolicy expiryPolicy,\n                                                                          boolean withCompletionEvent) {\n        ensureOpen();\n        validateNotNull(key, value);\n        CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, value);\n        final Data keyData = serializationService.toData(key);\n        final Data valueData = serializationService.toData(value);\n//        final Operation op = new CachePutIfAbsentOperation(getDistributedObjectName(), keyData, valueData, expiryPolicy);\n        Operation operation = operationProvider.createPutIfAbsentOperation(keyData, valueData, expiryPolicy);\n        return invoke(operation, keyData, withCompletionEvent);\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void removeAllInternal(Set<? extends K> keys, boolean isRemoveAll) {\n        final Set<Data> keysData;\n        if (keys != null) {\n            keysData = new HashSet<Data>();\n            for (K key : keys) {\n                keysData.add(serializationService.toData(key));\n            }\n        } else {\n            keysData = null;\n        }\n        final int partitionCount = getNodeEngine().getPartitionService().getPartitionCount();\n        final Integer completionId = registerCompletionLatch(partitionCount);\n        final OperationService operationService = getNodeEngine().getOperationService();\n        final CacheClearOperationFactory operationFactory = new CacheClearOperationFactory(getDistributedObjectName(), keysData,\n                isRemoveAll, completionId);\n        try {\n            final Map<Integer, Object> results = operationService.invokeOnAllPartitions(getServiceName(), operationFactory);\n            int completionCount = 0;\n            for (Object result : results.values()) {\n                if (result != null && result instanceof CacheClearResponse) {\n                    final Object response = ((CacheClearResponse) result).getResponse();\n                    if (response instanceof Boolean) {\n                        completionCount++;\n                    }\n                    if (response instanceof Throwable) {\n                        throw (Throwable) response;\n                    }\n                }\n            }\n            waitCompletionLatch(completionId, partitionCount - completionCount);\n        } catch (Throwable t) {\n            deregisterCompletionLatch(completionId);\n            throw ExceptionUtil.rethrowAllowedTypeFirst(t, CacheException.class);\n        }\n    }","id":66009,"modified_method":"protected void removeAllInternal(Set<? extends K> keys, boolean isRemoveAll) {\n        final Set<Data> keysData;\n        if (keys != null) {\n            keysData = new HashSet<Data>();\n            for (K key : keys) {\n                keysData.add(serializationService.toData(key));\n            }\n        } else {\n            keysData = null;\n        }\n        final int partitionCount = getNodeEngine().getPartitionService().getPartitionCount();\n        final Integer completionId = registerCompletionLatch(partitionCount);\n        final OperationService operationService = getNodeEngine().getOperationService();\n        OperationFactory operationFactory = operationProvider.createClearOperationFactory(keysData, isRemoveAll, completionId);\n        try {\n            final Map<Integer, Object> results = operationService.invokeOnAllPartitions(getServiceName(), operationFactory);\n            int completionCount = 0;\n            for (Object result : results.values()) {\n                if (result != null && result instanceof CacheClearResponse) {\n                    final Object response = ((CacheClearResponse) result).getResponse();\n                    if (response instanceof Boolean) {\n                        completionCount++;\n                    }\n                    if (response instanceof Throwable) {\n                        throw (Throwable) response;\n                    }\n                }\n            }\n            waitCompletionLatch(completionId, partitionCount - completionCount);\n        } catch (Throwable t) {\n            deregisterCompletionLatch(completionId);\n            throw ExceptionUtil.rethrowAllowedTypeFirst(t, CacheException.class);\n        }\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected <T> InternalCompletableFuture<T> replaceAsyncInternal(K key, V oldValue, V newValue, ExpiryPolicy expiryPolicy,\n                                                                    boolean hasOldValue, boolean isGet,\n                                                                    boolean withCompletionEvent) {\n        ensureOpen();\n        if (hasOldValue) {\n            validateNotNull(key, oldValue, newValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, oldValue, newValue);\n        } else {\n            validateNotNull(key, newValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, newValue);\n        }\n        final Data keyData = serializationService.toData(key);\n        final Data oldValueData = oldValue != null ? serializationService.toData(oldValue) : null;\n        final Data newValueData = serializationService.toData(newValue);\n        final Operation operation;\n        if (isGet) {\n            operation = new CacheGetAndReplaceOperation(getDistributedObjectName(), keyData, newValueData, expiryPolicy);\n        } else {\n            operation = new CacheReplaceOperation(getDistributedObjectName(), keyData, oldValueData, newValueData, expiryPolicy);\n        }\n        return invoke(operation, keyData, withCompletionEvent);\n    }","id":66010,"modified_method":"protected <T> InternalCompletableFuture<T> replaceAsyncInternal(K key, V oldValue, V newValue, ExpiryPolicy expiryPolicy,\n                                                                    boolean hasOldValue, boolean isGet,\n                                                                    boolean withCompletionEvent) {\n        ensureOpen();\n        if (hasOldValue) {\n            validateNotNull(key, oldValue, newValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, oldValue, newValue);\n        } else {\n            validateNotNull(key, newValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, newValue);\n        }\n        final Data keyData = serializationService.toData(key);\n        final Data oldValueData = serializationService.toData(oldValue);\n        final Data newValueData = serializationService.toData(newValue);\n        final Operation operation;\n        if (isGet) {\n            operation = operationProvider.createGetAndReplaceOperation(keyData, newValueData, expiryPolicy);\n        } else {\n            operation = operationProvider.createReplaceOperation(keyData, oldValueData, newValueData, expiryPolicy);\n        }\n        return invoke(operation, keyData, withCompletionEvent);\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected <T> InternalCompletableFuture<T> removeAsyncInternal(K key, V oldValue, boolean hasOldValue, boolean isGet,\n                                                                   boolean withCompletionEvent) {\n        ensureOpen();\n        if (hasOldValue) {\n            validateNotNull(key, oldValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, oldValue);\n        } else {\n            validateNotNull(key);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key);\n        }\n        final Data keyData = serializationService.toData(key);\n        final Data valueData = oldValue != null ? serializationService.toData(oldValue) : null;\n        final Operation operation;\n        if (isGet) {\n            operation = new CacheGetAndRemoveOperation(getDistributedObjectName(), keyData);\n        } else {\n            operation = new CacheRemoveOperation(getDistributedObjectName(), keyData, valueData);\n        }\n        return invoke(operation, keyData, withCompletionEvent);\n    }","id":66011,"modified_method":"protected <T> InternalCompletableFuture<T> removeAsyncInternal(K key, V oldValue, boolean hasOldValue, boolean isGet,\n                                                                   boolean withCompletionEvent) {\n        ensureOpen();\n        if (hasOldValue) {\n            validateNotNull(key, oldValue);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key, oldValue);\n        } else {\n            validateNotNull(key);\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key);\n        }\n        final Data keyData = serializationService.toData(key);\n        final Data valueData = serializationService.toData(oldValue);\n        final Operation operation;\n        if (isGet) {\n            operation = operationProvider.createGetAndRemoveOperation(keyData);\n        } else {\n            operation = operationProvider.createRemoveOperation(keyData, valueData);\n        }\n        return invoke(operation, keyData, withCompletionEvent);\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public <T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)\n            throws EntryProcessorException {\n        ensureOpen();\n        validateNotNull(key);\n        if (entryProcessor == null) {\n            throw new NullPointerException(\"Entry Processor is null\");\n        }\n        final Data k = serializationService.toData(key);\n        final Integer completionId = registerCompletionLatch(1);\n        final Operation op = new CacheEntryProcessorOperation(getDistributedObjectName(), k, completionId, entryProcessor,\n                arguments);\n        try {\n            final InternalCompletableFuture<T> f = getNodeEngine().getOperationService().invokeOnPartition(getServiceName(), op,\n                    getPartitionId(getNodeEngine(), k));\n            final T safely = f.getSafely();\n            waitCompletionLatch(completionId);\n            return safely;\n        } catch (CacheException ce) {\n            deregisterCompletionLatch(completionId);\n            throw ce;\n        } catch (Exception e) {\n            deregisterCompletionLatch(completionId);\n            throw new EntryProcessorException(e);\n        }\n    }","id":66012,"modified_method":"@Override\n    public <T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)\n            throws EntryProcessorException {\n        ensureOpen();\n        validateNotNull(key);\n        if (entryProcessor == null) {\n            throw new NullPointerException(\"Entry Processor is null\");\n        }\n        final Data keyData = serializationService.toData(key);\n        final Integer completionId = registerCompletionLatch(1);\n        Operation op = operationProvider.createEntryProcessorOperation(keyData, completionId, entryProcessor, arguments);\n        try {\n            OperationService operationService = getNodeEngine().getOperationService();\n            int partitionId = getPartitionId(getNodeEngine(), keyData);\n            final InternalCompletableFuture<T> f = operationService.invokeOnPartition(getServiceName(), op, partitionId);\n            final T safely = f.getSafely();\n            waitCompletionLatch(completionId);\n            return safely;\n        } catch (CacheException ce) {\n            deregisterCompletionLatch(completionId);\n            throw ce;\n        } catch (Exception e) {\n            deregisterCompletionLatch(completionId);\n            throw new EntryProcessorException(e);\n        }\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener completionListener) {\n        ensureOpen();\n        validateNotNull(keys);\n        for (K key : keys) {\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key);\n        }\n        validateCacheLoader(completionListener);\n        HashSet<Data> keysData = new HashSet<Data>();\n        for (K key : keys) {\n            keysData.add(serializationService.toData(key));\n        }\n        final OperationFactory operationFactory = new CacheLoadAllOperationFactory(getDistributedObjectName(), keysData,\n                replaceExistingValues);\n        try {\n            submitLoadAllTask(operationFactory, completionListener);\n        } catch (Exception e) {\n            if (completionListener != null) {\n                completionListener.onException(e);\n            }\n            throw new CacheException(e);\n        }\n    }","id":66013,"modified_method":"@Override\n    public void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener completionListener) {\n        ensureOpen();\n        validateNotNull(keys);\n        for (K key : keys) {\n            CacheProxyUtil.validateConfiguredTypes(cacheConfig, key);\n        }\n        validateCacheLoader(completionListener);\n        HashSet<Data> keysData = new HashSet<Data>();\n        for (K key : keys) {\n            keysData.add(serializationService.toData(key));\n        }\n        OperationFactory operationFactory = operationProvider.createLoadAllOperationFactory(keysData, replaceExistingValues);\n        try {\n            submitLoadAllTask(operationFactory, completionListener);\n        } catch (Exception e) {\n            if (completionListener != null) {\n                completionListener.onException(e);\n            }\n            throw new CacheException(e);\n        }\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean containsKey(K key) {\n        ensureOpen();\n        validateNotNull(key);\n        final Data k = serializationService.toData(key);\n        final Operation op = new CacheContainsKeyOperation(getDistributedObjectName(), k);\n        final InternalCompletableFuture<Boolean> f = getNodeEngine().getOperationService().invokeOnPartition(getServiceName(), op,\n                getPartitionId(getNodeEngine(), k));\n        return f.getSafely();\n    }","id":66014,"modified_method":"@Override\n    public boolean containsKey(K key) {\n        ensureOpen();\n        validateNotNull(key);\n        final Data k = serializationService.toData(key);\n//        final Operation op = new CacheContainsKeyOperation(getDistributedObjectName(), k);\n        Operation operation = operationProvider.createContainsKeyOperation(k);\n        OperationService operationService = getNodeEngine().getOperationService();\n        int partitionId = getPartitionId(getNodeEngine(), k);\n        InternalCompletableFuture<Boolean> f = operationService.invokeOnPartition(getServiceName(), operation, partitionId);\n        return f.getSafely();\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected CacheKeyIteratorResult fetch() {\n        final Operation op = new CacheKeyIteratorOperation(cacheProxy.nameWithPrefix, lastTableIndex, fetchSize);\n        final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n        final InternalCompletableFuture<CacheKeyIteratorResult> f = operationService\n                .invokeOnPartition(CacheService.SERVICE_NAME, op, partitionIndex);\n        return f.getSafely();\n    }","id":66015,"modified_method":"protected CacheKeyIteratorResult fetch() {\n        Operation operation = cacheProxy.operationProvider.createKeyIteratorOperation(lastTableIndex, fetchSize);\n        final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n        final InternalCompletableFuture<CacheKeyIteratorResult> f = operationService\n                .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n        return f.getSafely();\n    }","commit_id":"e76779b52d20b50318a66d23a326649f0bea0c1f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void putAllInternal(final Map<? extends Object, ? extends Object> entries) {\n        final NodeEngine nodeEngine = getNodeEngine();\n        final MapService mapService = getService();\n        int factor = 3;\n        InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        OperationService operationService = nodeEngine.getOperationService();\n        int partitionCount = partitionService.getPartitionCount();\n        boolean tooManyEntries = entries.size() > (partitionCount * factor);\n        try {\n            if (tooManyEntries) {\n                List<Future> futures = new LinkedList<Future>();\n                Map<Integer, MapEntrySet> entryMap\n                        = new HashMap<Integer, MapEntrySet>(nodeEngine.getPartitionService().getPartitionCount());\n                for (Entry entry : entries.entrySet()) {\n                    checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n                    checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n\n                    int partitionId = partitionService.getPartitionId(entry.getKey());\n                    if (!entryMap.containsKey(partitionId)) {\n                        entryMap.put(partitionId, new MapEntrySet());\n                    }\n                    entryMap.get(partitionId).add(\n                            new AbstractMap.SimpleImmutableEntry<Data, Data>(mapService.getMapServiceContext().toData(\n                                    entry.getKey(),\n                                    partitionStrategy),\n                                    mapService.getMapServiceContext()\n                                            .toData(entry.getValue())\n                            ));\n                }\n\n                for (final Map.Entry<Integer, MapEntrySet> entry : entryMap.entrySet()) {\n                    final Integer partitionId = entry.getKey();\n                    final PutAllOperation op = new PutAllOperation(name, entry.getValue());\n                    op.setPartitionId(partitionId);\n                    futures.add(operationService.invokeOnPartition(SERVICE_NAME, op, partitionId));\n                }\n\n                for (Future future : futures) {\n                    future.get();\n                }\n\n            } else {\n                for (Entry entry : entries.entrySet()) {\n                    checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n                    checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n\n                    putInternal(mapService.getMapServiceContext().toData(entry.getKey(), partitionStrategy),\n                            mapService.getMapServiceContext().toData(entry.getValue()),\n                            -1,\n                            TimeUnit.MILLISECONDS);\n                }\n            }\n        } catch (Exception e) {\n            throw ExceptionUtil.rethrow(e);\n        }\n    }","id":66016,"modified_method":"/**\n     * This Operation will first group all puts per partition and then send a PutAllOperation per partition. So if there are e.g.\n     * 5 keys for a single partition, then instead of having 5 remote invocations, there will be only 1 remote invocation.\n     *\n     * If there are multiple puts for different partitions on the same member, they are executed as different remote operations.\n     * Probably this can be optimized in the future by making use of an PartitionIterating operation.\n     *\n     * @param entries\n     */\n    protected void putAllInternal(Map<? extends Object, ? extends Object> entries) {\n        NodeEngine nodeEngine = getNodeEngine();\n        InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        OperationService operationService = nodeEngine.getOperationService();\n        int partitionCount = partitionService.getPartitionCount();\n        MapServiceContext mapServiceContext = getService().getMapServiceContext();\n\n        try {\n            List<Future> futures = new ArrayList<Future>(partitionCount);\n            MapEntrySet[] entrySetPerPartition = new MapEntrySet[partitionCount];\n\n            // first we fill entrySetPerPartition\n            for (Entry entry : entries.entrySet()) {\n                checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n                checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n\n                int partitionId = partitionService.getPartitionId(entry.getKey());\n                MapEntrySet entrySet = entrySetPerPartition[partitionId];\n                if (entrySet == null) {\n                    entrySet = new MapEntrySet();\n                    entrySetPerPartition[partitionId] = entrySet;\n                }\n\n                Data keyData = mapServiceContext.toData(entry.getKey(), partitionStrategy);\n                Data valueData = mapServiceContext.toData(entry.getValue());\n                entrySet.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(keyData, valueData));\n            }\n\n            // then we invoke the operations\n            for (int partitionId = 0; partitionId < entrySetPerPartition.length; partitionId++) {\n                MapEntrySet entrySet = entrySetPerPartition[partitionId];\n                if (entrySet != null) {\n                    // If there is a single entry, we could make use of a PutOperation since that is a bit cheaper\n                    Operation op = new PutAllOperation(name, entrySet).setPartitionId(partitionId);\n                    InternalCompletableFuture<Object> f = operationService.invokeOnPartition(SERVICE_NAME, op, partitionId);\n                    futures.add(f);\n                }\n            }\n\n            // then we sync on completion of these operations\n            for (Future future : futures) {\n                future.get();\n            }\n        } catch (Exception e) {\n            throw ExceptionUtil.rethrow(e);\n        }\n    }","commit_id":"aa201a89ef4748ad69bb46c4a03aed42f6e5530c","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public abstract Object transform(Object src, UMOEventContext context) throws TransformerException;","id":66017,"modified_method":"public abstract Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException;","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public final Object doTransform(Object src, String encoding) throws TransformerException\n    {\n        UMOEventContext event = RequestContext.getEventContext();\n        if (event == null) {\n            throw new TransformerException(new Message(Messages.NO_CURRENT_EVENT_FOR_TRANSFORMER), this);\n        }\n        return transform(src, event);\n    }","id":66018,"modified_method":"public final Object doTransform(Object src, String encoding) throws TransformerException\n    {\n        UMOEventContext event = RequestContext.getEventContext();\n        if (event == null) {\n            throw new TransformerException(new Message(Messages.NO_CURRENT_EVENT_FOR_TRANSFORMER), this);\n        }\n        return transform(src, encoding, event);\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"protected synchronized void initFromServiceDescriptor() throws InitialisationException\n    {\n        try {\n            serviceDescriptor = ConnectorFactory.getServiceDescriptor(getProtocol().toLowerCase(), serviceOverrides);\n\n            if (serviceDescriptor.getDispatcherFactory() != null) {\n                logger.info(\"Loading DispatcherFactory: \" + serviceDescriptor.getDispatcherFactory());\n                dispatcherFactory = serviceDescriptor.createDispatcherFactory();\n            }\n\n            defaultInboundTransformer = serviceDescriptor.createInboundTransformer();\n            defaultOutboundTransformer = serviceDescriptor.createOutboundTransformer();\n            defaultResponseTransformer = serviceDescriptor.createResponseTransformer();\n\n            sessionHandler = serviceDescriptor.createSessionHandler();\n            // set any manager default properties for the connector\n            // these are set on the Manager with a protocol i.e.\n            // jms.specification=1.1\n            //This provides a really convenient way to set properties on object form unit\n            //tests\n            Map props = PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(), getProtocol().toLowerCase());\n            if (props.size() > 0) {\n                props = PropertiesHelper.removeNamspaces(props);\n                org.mule.util.BeanUtils.populateWithoutFail(this, props, true);\n            }\n        } catch (Exception e) {\n            throw new InitialisationException(e, this);\n        }\n    }","id":66019,"modified_method":"protected synchronized void initFromServiceDescriptor() throws InitialisationException\n    {\n        try {\n            serviceDescriptor = ConnectorFactory.getServiceDescriptor(getProtocol().toLowerCase(), serviceOverrides);\n\n            if (serviceDescriptor.getDispatcherFactory() != null) {\n                logger.info(\"Loading DispatcherFactory: \" + serviceDescriptor.getDispatcherFactory());\n                dispatcherFactory = serviceDescriptor.createDispatcherFactory();\n            }\n\n            defaultInboundTransformer = serviceDescriptor.createInboundTransformer();\n            defaultOutboundTransformer = serviceDescriptor.createOutboundTransformer();\n            defaultResponseTransformer = serviceDescriptor.createResponseTransformer();\n\n            sessionHandler = serviceDescriptor.createSessionHandler();\n            // set any manager default properties for the connector\n            // these are set on the Manager with a protocol i.e.\n            // jms.specification=1.1\n            //This provides a really convenient way to set properties on object form unit\n            //tests\n            Map props = new HashMap();\n            PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(), getProtocol().toLowerCase(), props);\n            if (props.size() > 0) {\n                props = PropertiesHelper.removeNamspaces(props);\n                org.mule.util.BeanUtils.populateWithoutFail(this, props, true);\n            }\n        } catch (Exception e) {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates an uninitialied connector from the provided MuleEndpointURI. The\n     * scheme is used to determine what kind of connector to create. Any params\n     * set on the uri can be used to initialise bean properties on the created\n     * connector. <p/> Note that the initalise method will need to be called on\n     * the connector returned. This is so that developers can control when the\n     * connector initialisation takes place as this is likely to initialse all\n     * connecotr resources.\n     * \n     * @param url the MuleEndpointURI url to create the connector with\n     * @return a new Connector\n     * @throws ConnectorFactoryException\n     */\n    public static UMOConnector createConnector(UMOEndpointURI url) throws ConnectorFactoryException\n    {\n        String scheme = url.getSchemeMetaInfo();\n\n        UMOConnector connector = null;\n        ConnectorServiceDescriptor csd = getServiceDescriptor(scheme);\n        // Make sure we can create the endpoint/connector using this service\n        // method\n        if (csd.getServiceError() != null) {\n            throw new ConnectorServiceException(Message.createStaticMessage(csd.getServiceError()));\n        }\n\n        //If this is a fineder service, lets find it before trying to create it\n        if (csd.getServiceFinder() != null) {\n            csd = csd.createServiceFinder().findService(scheme, csd);\n        }\n        // if there is a factory, use it\n        try {\n            if (csd.getConnectorFactory() != null) {\n                ObjectFactory factory = (ObjectFactory) ClassHelper.loadClass(csd.getConnectorFactory(),\n                                                                              ConnectorFactory.class).newInstance();\n                connector = (UMOConnector) factory.create();\n            } else {\n                if (csd.getConnector() != null) {\n                    connector = (UMOConnector) ClassHelper.loadClass(csd.getConnector(), ConnectorFactory.class)\n                                                          .newInstance();\n                    if (connector instanceof AbstractServiceEnabledConnector) {\n                        ((AbstractServiceEnabledConnector) connector).initialiseFromUrl(url);\n                    }\n                } else {\n                    throw new ConnectorFactoryException(new Message(Messages.X_NOT_SET_IN_SERVICE_X,\n                                                                    \"Connector\",\n                                                                    scheme));\n                }\n            }\n        } catch (ConnectorFactoryException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ConnectorFactoryException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Endpoint\", url), e);\n        }\n\n        if (connector.getName() == null) {\n            connector.setName(\"_\" + scheme + \"Connector#\" + connector.hashCode());\n        }\n        // set any manager default properties for the connector\n        // these are set on the Manager with a protocol i.e.\n        // jms.specification=1.1\n        Map props = PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(),\n                                                             connector.getProtocol().toLowerCase());\n        if (props.size() > 0) {\n            props = PropertiesHelper.removeNamspaces(props);\n            org.mule.util.BeanUtils.populateWithoutFail(connector, props, true);\n        }\n\n        return connector;\n    }","id":66020,"modified_method":"/**\n     * Creates an uninitialied connector from the provided MuleEndpointURI. The\n     * scheme is used to determine what kind of connector to create. Any params\n     * set on the uri can be used to initialise bean properties on the created\n     * connector. <p/> Note that the initalise method will need to be called on\n     * the connector returned. This is so that developers can control when the\n     * connector initialisation takes place as this is likely to initialse all\n     * connecotr resources.\n     * \n     * @param url the MuleEndpointURI url to create the connector with\n     * @return a new Connector\n     * @throws ConnectorFactoryException\n     */\n    public static UMOConnector createConnector(UMOEndpointURI url) throws ConnectorFactoryException\n    {\n        String scheme = url.getSchemeMetaInfo();\n\n        UMOConnector connector = null;\n        ConnectorServiceDescriptor csd = getServiceDescriptor(scheme);\n        // Make sure we can create the endpoint/connector using this service\n        // method\n        if (csd.getServiceError() != null) {\n            throw new ConnectorServiceException(Message.createStaticMessage(csd.getServiceError()));\n        }\n\n        //If this is a fineder service, lets find it before trying to create it\n        if (csd.getServiceFinder() != null) {\n            csd = csd.createServiceFinder().findService(scheme, csd);\n        }\n        // if there is a factory, use it\n        try {\n            if (csd.getConnectorFactory() != null) {\n                ObjectFactory factory = (ObjectFactory) ClassHelper.loadClass(csd.getConnectorFactory(),\n                                                                              ConnectorFactory.class).newInstance();\n                connector = (UMOConnector) factory.create();\n            } else {\n                if (csd.getConnector() != null) {\n                    connector = (UMOConnector) ClassHelper.loadClass(csd.getConnector(), ConnectorFactory.class)\n                                                          .newInstance();\n                    if (connector instanceof AbstractServiceEnabledConnector) {\n                        ((AbstractServiceEnabledConnector) connector).initialiseFromUrl(url);\n                    }\n                } else {\n                    throw new ConnectorFactoryException(new Message(Messages.X_NOT_SET_IN_SERVICE_X,\n                                                                    \"Connector\",\n                                                                    scheme));\n                }\n            }\n        } catch (ConnectorFactoryException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ConnectorFactoryException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Endpoint\", url), e);\n        }\n\n        if (connector.getName() == null) {\n            connector.setName(\"_\" + scheme + \"Connector#\" + connector.hashCode());\n        }\n        // set any manager default properties for the connector\n        // these are set on the Manager with a protocol i.e.\n        // jms.specification=1.1\n        Map props = new HashMap();\n        PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(),\n                                                             connector.getProtocol().toLowerCase(), props);\n        if (props.size() > 0) {\n            props = PropertiesHelper.removeNamspaces(props);\n            org.mule.util.BeanUtils.populateWithoutFail(connector, props, true);\n        }\n\n        return connector;\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n         System.out.println(\"org.mule.test.usecases.props.DummyTransformer\");\n         PropsComponent.assertEquals(\"param1\",\n                                     context.getProperty(\"stringParam\"));\n         PropsComponent.assertEquals(PropsComponent.testObjectProperty,\n                                     context.getProperty(\"objectParam\"));\n\n         System.out.println(\"org.mule.test.usecases.props.DummyTransformer done.\");\n         return src;\n     }","id":66021,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n         System.out.println(\"org.mule.test.usecases.props.DummyTransformer\");\n         PropsComponent.assertEquals(\"param1\",\n                                     context.getProperty(\"stringParam\"));\n         PropsComponent.assertEquals(PropsComponent.testObjectProperty,\n                                     context.getProperty(\"objectParam\"));\n\n         System.out.println(\"org.mule.test.usecases.props.DummyTransformer done.\");\n         return src;\n     }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException\n        {\n            assertEquals(\"param1\", context.getProperty(\"stringParam\"));\n            assertEquals(testObjectProperty, context.getProperty(\"objectParam\"));\n            assertEquals(12345.6, 12345.6, context.getDoubleProperty(\"doubleParam\", 0));\n            assertEquals(12345, context.getIntProperty(\"integerParam\", 0));\n            assertEquals(123456789, context.getLongProperty(\"longParam\", 0));\n            assertEquals(true, context.getBooleanProperty(\"booleanParam\", false));\n            return src;\n        }","id":66022,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException\n        {\n            assertEquals(\"param1\", context.getProperty(\"stringParam\"));\n            assertEquals(testObjectProperty, context.getProperty(\"objectParam\"));\n            assertEquals(12345.6, 12345.6, context.getDoubleProperty(\"doubleParam\", 0));\n            assertEquals(12345, context.getIntProperty(\"integerParam\", 0));\n            assertEquals(123456789, context.getLongProperty(\"longParam\", 0));\n            assertEquals(true, context.getBooleanProperty(\"booleanParam\", false));\n            return src;\n        }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException\n    {\n    \tString encoding = (String) context.getProperty(MuleProperties.MULE_ENCODING_SYSTEM_PROPERTY, null);\n        String endpoint = (String) context.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                                                       MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n        String method = (String) context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = (String) context.getProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                                                                HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if(!(src instanceof NullPayload) && !Utility.EMPTY_STRING.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    } else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            } else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = (String) context.getProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n                //postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    //Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    //Dont set a POST payload if the body is a Null Payload.  This way client calls\n                    //can control if a POST body is posted explicitly\n                    if(!(context.getMessage().getPayload() instanceof NullPayload)) {\n                        if (src instanceof String) {\n                        \tif (encoding != null){\n                              postMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString().getBytes(encoding)));\n                        \t} else {\n                        \t\tpostMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString().getBytes()));\n                        \t}\n                        } else if (src instanceof InputStream) {\n\t                        postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream) src));\n                        } else {\n                            byte[] buffer = Utility.objectToByteArray(src);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer));\n                        }\n                    }\n                } else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":66023,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException\n    {\n        String endpoint = (String) context.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                                                       MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n        String method = (String) context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = (String) context.getProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                                                                HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if(!(src instanceof NullPayload) && !Utility.EMPTY_STRING.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    } else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            } else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = (String) context.getProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n                //postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    //Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    //Dont set a POST payload if the body is a Null Payload.  This way client calls\n                    //can control if a POST body is posted explicitly\n                    if(!(context.getMessage().getPayload() instanceof NullPayload)) {\n                        if (src instanceof String) {\n                        \tif (encoding != null){\n                              postMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString().getBytes(encoding)));\n                        \t} else {\n                        \t\tpostMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString().getBytes()));\n                        \t}\n                        } else if (src instanceof InputStream) {\n\t                        postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream) src));\n                        } else {\n                            byte[] buffer = Utility.objectToByteArray(src);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer));\n                        }\n                    }\n                } else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            return getXStream().toXML(context.getMessage());\n        } else {\n            return getXStream().toXML(src);\n        }\n    }","id":66024,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            return getXStream().toXML(context.getMessage());\n        } else {\n            return getXStream().toXML(src);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n        Message result = null;\n        try {\n            result = new Message(context.getMessageAsString());\n        } catch (UMOException e) {\n            throw new TransformerException(this, e);\n        }\n        if (context.getMessage().getExceptionPayload() != null) {\n            result.setError(new XMPPError(503, context.getMessage().getExceptionPayload().getMessage()));\n        }\n        for (Iterator iterator = context.getProperties().keySet().iterator(); iterator.hasNext();) {\n            String name = (String) iterator.next();\n            if (name.equals(XmppConnector.XMPP_THREAD)) {\n                result.setThread((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_SUBJECT)) {\n                result.setSubject((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_FROM)) {\n                result.setFrom((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_TO)) {\n                result.setTo((String) context.getProperty(name));\n            } else {\n                result.setProperty(name, context.getProperty(name));\n            }\n        }\n        return result;\n    }","id":66025,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n        Message result = null;\n        try {\n            result = new Message(context.getMessageAsString(encoding));\n        } catch (UMOException e) {\n            throw new TransformerException(this, e);\n        }\n        if (context.getMessage().getExceptionPayload() != null) {\n            result.setError(new XMPPError(503, context.getMessage().getExceptionPayload().getMessage()));\n        }\n        for (Iterator iterator = context.getProperties().keySet().iterator(); iterator.hasNext();) {\n            String name = (String) iterator.next();\n            if (name.equals(XmppConnector.XMPP_THREAD)) {\n                result.setThread((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_SUBJECT)) {\n                result.setSubject((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_FROM)) {\n                result.setFrom((String) context.getProperty(name));\n            } else if (name.equals(XmppConnector.XMPP_TO)) {\n                result.setTo((String) context.getProperty(name));\n            } else {\n                result.setProperty(name, context.getProperty(name));\n            }\n        }\n        return result;\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"private void loadStrategies() throws Exception\n    {\n        String path = System.getProperty(MULE_ENCRYPTION_PROPERTIES, MuleManager.getConfiguration().getWorkingDirectory()\n                + File.separator + DEFAULT_ENCRYPTION_PROPERTIES_FILE);\n\n        logger.info(\"Attempting to load encryption properties from: \" + path);\n        Properties props = PropertiesHelper.loadProperties(path);\n\n        Map names = PropertiesHelper.getPropertiesWithPrefix(props, \"name\");\n        String name;\n        for (Iterator iterator = names.values().iterator(); iterator.hasNext();) {\n            name = (String) iterator.next();\n            Map schemeConfig = PropertiesHelper.getPropertiesWithPrefix(props, name + \".\");\n            schemeConfig = PropertiesHelper.removeNamspaces(schemeConfig);\n\n            String type = (String)schemeConfig.get(\"type\");\n            String clazz = (String)types.get(type);\n            if(clazz==null) {\n                throw new IllegalArgumentException(\"Unknown encryption type: \" + type);\n            }\n            logger.debug(\"Found Class: \" + clazz + \" for type: \" + type);\n            UMOEncryptionStrategy strat = (UMOEncryptionStrategy)ClassHelper.instanciateClass(clazz, ClassHelper.NO_ARGS, PlaceholderProcessor.class);\n            BeanUtils.populateWithoutFail(strat, schemeConfig, true);\n            schemes.put(name, strat);\n        }\n    }","id":66026,"modified_method":"private void loadStrategies() throws Exception\n    {\n        String path = System.getProperty(MULE_ENCRYPTION_PROPERTIES, MuleManager.getConfiguration().getWorkingDirectory()\n                + File.separator + DEFAULT_ENCRYPTION_PROPERTIES_FILE);\n\n        logger.info(\"Attempting to load encryption properties from: \" + path);\n        Properties props = PropertiesHelper.loadProperties(path);\n\n        Map names = new HashMap();\n        PropertiesHelper.getPropertiesWithPrefix(props, \"name\", names);\n        String name;\n        for (Iterator iterator = names.values().iterator(); iterator.hasNext();) {\n            name = (String) iterator.next();\n            Map schemeConfig = new HashMap();\n            PropertiesHelper.getPropertiesWithPrefix(props, name + \".\", schemeConfig);\n            schemeConfig = PropertiesHelper.removeNamspaces(schemeConfig);\n\n            String type = (String)schemeConfig.get(\"type\");\n            String clazz = (String)types.get(type);\n            if(clazz==null) {\n                throw new IllegalArgumentException(\"Unknown encryption type: \" + type);\n            }\n            logger.debug(\"Found Class: \" + clazz + \" for type: \" + type);\n            UMOEncryptionStrategy strat = (UMOEncryptionStrategy)ClassHelper.instanciateClass(clazz, ClassHelper.NO_ARGS, PlaceholderProcessor.class);\n            BeanUtils.populateWithoutFail(strat, schemeConfig, true);\n            schemes.put(name, strat);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        String name = null;\n        int ssn = 0;\n        double amount = 0;\n        int duration = 0;\n        try {\n            name = getParam(context, \"customerName\");\n            ssn = Integer.valueOf(getParam(context, \"ssn\")).intValue();\n            amount = Double.valueOf(getParam(context, \"loanAmount\")).doubleValue();\n            duration = Integer.valueOf(getParam(context, \"loanDuration\")).intValue();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n\n        Customer c = new Customer(name, ssn);\n        CustomerQuoteRequest request = new CustomerQuoteRequest(c, amount, duration);\n        return request;\n    }","id":66027,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        String name = null;\n        int ssn = 0;\n        double amount = 0;\n        int duration = 0;\n        try {\n            name = getParam(context, \"customerName\");\n            ssn = Integer.valueOf(getParam(context, \"ssn\")).intValue();\n            amount = Double.valueOf(getParam(context, \"loanAmount\")).doubleValue();\n            duration = Integer.valueOf(getParam(context, \"loanDuration\")).intValue();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n\n        Customer c = new Customer(name, ssn);\n        CustomerQuoteRequest request = new CustomerQuoteRequest(c, amount, duration);\n        return request;\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void loadConnectors() throws Exception {\n        List protocols = new ArrayList();\n        if(config.getConnectorConfig()!=null) {\n            Properties props = PropertiesHelper.loadProperties(config.getConnectorConfig());\n            for (Iterator iterator = protocols.iterator(); iterator.hasNext();) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                String key = entry.getKey().toString();\n                String protocol = key.substring(0, key.indexOf(\".\"));\n                if(!protocols.contains(protocol)) {\n                    protocols.add(protocol);\n                    Map pp = PropertiesHelper.getPropertiesWithPrefix(props, protocol);\n                    UMOConnector cnn = ConnectorFactory.getServiceDescriptor(protocol).createConnector(protocol);\n                    cnn.setName(cnn.toString());\n                    pp = PropertiesHelper.removeNamspaces(pp);\n                    org.mule.util.BeanUtils.populateWithoutFail(cnn, pp, true);\n                    MuleManager.getInstance().registerConnector(cnn);\n                }\n            }\n        }\n    }","id":66028,"modified_method":"protected void loadConnectors() throws Exception {\n        List protocols = new ArrayList();\n        if(config.getConnectorConfig()!=null) {\n            Properties props = PropertiesHelper.loadProperties(config.getConnectorConfig());\n            for (Iterator iterator = protocols.iterator(); iterator.hasNext();) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                String key = entry.getKey().toString();\n                String protocol = key.substring(0, key.indexOf(\".\"));\n                if(!protocols.contains(protocol)) {\n                    protocols.add(protocol);\n                    Map pp = new HashMap();\n                    PropertiesHelper.getPropertiesWithPrefix(props, protocol, pp);\n                    UMOConnector cnn = ConnectorFactory.getServiceDescriptor(protocol).createConnector(protocol);\n                    cnn.setName(cnn.toString());\n                    pp = PropertiesHelper.removeNamspaces(pp);\n                    org.mule.util.BeanUtils.populateWithoutFail(cnn, pp, true);\n                    MuleManager.getInstance().registerConnector(cnn);\n                }\n            }\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        Namespace ns = getScriptEngine().createNamespace();\n        populateNamespace(ns, context, src);\n        try {\n            return scriptable.runScript(ns);\n        } catch (ScriptException e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":66029,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        Namespace ns = getScriptEngine().createNamespace();\n        populateNamespace(ns, context, src);\n        try {\n            return scriptable.runScript(ns);\n        } catch (ScriptException e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        Object obj = null;\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            obj = context.getMessage();\n        } else {\n            obj = src;\n            if (obj instanceof byte[]) {\n                return (byte[]) obj;\n            }\n        }\n\n        byte[] dest = null;\n        ByteArrayOutputStream bs = null;\n        ObjectOutputStream os = null;\n        try {\n            bs = new ByteArrayOutputStream();\n            os = new ObjectOutputStream(bs);\n            os.writeObject(obj);\n            os.flush();\n            dest = bs.toByteArray();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return dest;\n    }","id":66030,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        Object obj = null;\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            obj = context.getMessage();\n        } else {\n            obj = src;\n            if (obj instanceof byte[]) {\n                return (byte[]) obj;\n            }\n        }\n\n        byte[] dest = null;\n        ByteArrayOutputStream bs = null;\n        ObjectOutputStream os = null;\n        try {\n            bs = new ByteArrayOutputStream();\n            os = new ObjectOutputStream(bs);\n            os.writeObject(obj);\n            os.flush();\n            dest = bs.toByteArray();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return dest;\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n            assertNotNull(context);\n            latch.countDown();\n            return src;\n        }","id":66031,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n            assertNotNull(context);\n            latch.countDown();\n            return src;\n        }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector)endpoint.getConnector();\n        String to = context.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = context.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY, connector.getCcAddresses());\n        String bcc = context.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY, connector.getBccAddresses());\n        String from = context.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY, connector.getFromAddress());\n        String replyTo = context.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY, connector.getReplyToAddresses());\n        String subject = context.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n\n        String contentType = context.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY, connector.getContentType());\n\n        Properties headers = new Properties();\n        if(connector.getCustomHeaders()!=null) headers.putAll(connector.getCustomHeaders());\n        Properties otherHeaders = (Properties)context.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if(otherHeaders!=null) {\n            Map props = new HashMap(MuleManager.getInstance().getProperties());\n            props.putAll(context.getProperties());\n            headers.putAll(templateParser.parse(props, otherHeaders));\n        }\n\n        if(logger.isDebugEnabled()) {\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"Constucting email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\"From: \").append(from);\n            buf.append(\"CC: \").append(cc);\n            buf.append(\"BCC: \").append(bcc);\n            buf.append(\"Subject: \").append(subject);\n            buf.append(\"ReplyTo: \").append(replyTo);\n            buf.append(\"Content type: \").append(contentType);\n            buf.append(\"Payload type: \").append(src.getClass().getName());\n            buf.append(\"Custom Headers: \").append(PropertiesHelper.propertiesToString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try {\n            Message msg = new MimeMessage((Session) endpoint.getConnector().getDispatcher(endpointAddress).getDelegateSession());\n\n            msg.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            msg.setSentDate(Calendar.getInstance().getTime());\n\n            if (from != null && !Utility.EMPTY_STRING.equals(from)) {\n                msg.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (cc != null && !Utility.EMPTY_STRING.equals(cc)) {\n                msg.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (bcc != null && !Utility.EMPTY_STRING.equals(bcc)) {\n                msg.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (replyTo != null && !Utility.EMPTY_STRING.equals(replyTo)) {\n                msg.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            msg.setSubject(subject);\n\n            Map.Entry entry;\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                msg.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(src, msg, contentType, context);\n\n            return msg;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":66032,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector)endpoint.getConnector();\n        String to = context.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = context.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY, connector.getCcAddresses());\n        String bcc = context.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY, connector.getBccAddresses());\n        String from = context.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY, connector.getFromAddress());\n        String replyTo = context.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY, connector.getReplyToAddresses());\n        String subject = context.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n\n        String contentType = context.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY, connector.getContentType());\n\n        Properties headers = new Properties();\n        if(connector.getCustomHeaders()!=null) headers.putAll(connector.getCustomHeaders());\n        Properties otherHeaders = (Properties)context.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if(otherHeaders!=null) {\n            Map props = new HashMap(MuleManager.getInstance().getProperties());\n            props.putAll(context.getProperties());\n            headers.putAll(templateParser.parse(props, otherHeaders));\n        }\n\n        if(logger.isDebugEnabled()) {\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"Constucting email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\"From: \").append(from);\n            buf.append(\"CC: \").append(cc);\n            buf.append(\"BCC: \").append(bcc);\n            buf.append(\"Subject: \").append(subject);\n            buf.append(\"ReplyTo: \").append(replyTo);\n            buf.append(\"Content type: \").append(contentType);\n            buf.append(\"Payload type: \").append(src.getClass().getName());\n            buf.append(\"Custom Headers: \").append(PropertiesHelper.propertiesToString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try {\n            Message msg = new MimeMessage((Session) endpoint.getConnector().getDispatcher(endpointAddress).getDelegateSession());\n\n            msg.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            msg.setSentDate(Calendar.getInstance().getTime());\n\n            if (from != null && !Utility.EMPTY_STRING.equals(from)) {\n                msg.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (cc != null && !Utility.EMPTY_STRING.equals(cc)) {\n                msg.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (bcc != null && !Utility.EMPTY_STRING.equals(bcc)) {\n                msg.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (replyTo != null && !Utility.EMPTY_STRING.equals(replyTo)) {\n                msg.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            msg.setSubject(subject);\n\n            Map.Entry entry;\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                msg.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(src, msg, contentType, context);\n\n            return msg;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n        //Note this transformer excepts Null as we must always return a result from the Http\n        //connector if a response transformer is present\n        if (src instanceof NullPayload) src = Utility.EMPTY_STRING;\n\n        try {\n            HttpResponse response = null;\n            if(src instanceof HttpResponse) {\n                response = (HttpResponse)src;\n            } else {\n                response = createResponse(src, context);\n            }\n\n            // Ensure there's a content type header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_TYPE)) {\n                response.addHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, HttpConstants.DEFAULT_CONTENT_TYPE));\n            }\n\n            // Ensure there's a content length or transfer encoding header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_LENGTH) && !response.containsHeader(HttpConstants.HEADER_TRANSFER_ENCODING)) {\n                InputStream content = response.getBody();\n                if (content != null) {\n                    long len = response.getContentLength();\n                    if (len < 0) {\n                        if (response.getHttpVersion().lessEquals(HttpVersion.HTTP_1_0)) {\n                            throw new IOException(\"Chunked encoding not supported for HTTP version \"\n                                    + response.getHttpVersion());\n                        }\n                        Header header = new Header(HttpConstants.HEADER_TRANSFER_ENCODING, \"chunked\");\n                        response.addHeader(header);\n                    } else {\n                        Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, Long.toString(len));\n                        response.setHeader(header);\n                    }\n                } else {\n                    Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, \"0\");\n                    response.addHeader(header);\n                }\n            }\n\n            if (!response.containsHeader(HttpConstants.HEADER_CONNECTION)) {\n                // See if the the client explicitly handles connection persistence\n                String connHeader = context.getStringProperty(HttpConstants.HEADER_CONNECTION);\n                if (connHeader != null) {\n                    if (connHeader.equalsIgnoreCase(\"keep-alive\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"keep-alive\");\n                        response.addHeader(header);\n                        response.setKeepAlive(true);\n                    }\n                    if (connHeader.equalsIgnoreCase(\"close\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"close\");\n                        response.addHeader(header);\n                        response.setKeepAlive(false);\n                    }\n                } else {\n                    // Use protocol default connection policy\n                    if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {\n                        response.setKeepAlive(true);\n                    } else {\n                        response.setKeepAlive(false);\n                    }\n                }\n            }\n            if (\"HEAD\".equalsIgnoreCase(context.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY))) {\n                // this is a head request, we don't want to send the actualy content\n                response.setBody(null);\n            }\n            return response;\n        } catch (IOException e) {\n            throw new TransformerException(this, e);\n        }\n\n    }","id":66033,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n        //Note this transformer excepts Null as we must always return a result from the Http\n        //connector if a response transformer is present\n        if (src instanceof NullPayload) src = Utility.EMPTY_STRING;\n\n        try {\n            HttpResponse response = null;\n            if(src instanceof HttpResponse) {\n                response = (HttpResponse)src;\n            } else {\n                response = createResponse(src, context);\n            }\n\n            // Ensure there's a content type header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_TYPE)) {\n                response.addHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, HttpConstants.DEFAULT_CONTENT_TYPE));\n            }\n\n            // Ensure there's a content length or transfer encoding header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_LENGTH) && !response.containsHeader(HttpConstants.HEADER_TRANSFER_ENCODING)) {\n                InputStream content = response.getBody();\n                if (content != null) {\n                    long len = response.getContentLength();\n                    if (len < 0) {\n                        if (response.getHttpVersion().lessEquals(HttpVersion.HTTP_1_0)) {\n                            throw new IOException(\"Chunked encoding not supported for HTTP version \"\n                                    + response.getHttpVersion());\n                        }\n                        Header header = new Header(HttpConstants.HEADER_TRANSFER_ENCODING, \"chunked\");\n                        response.addHeader(header);\n                    } else {\n                        Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, Long.toString(len));\n                        response.setHeader(header);\n                    }\n                } else {\n                    Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, \"0\");\n                    response.addHeader(header);\n                }\n            }\n\n            if (!response.containsHeader(HttpConstants.HEADER_CONNECTION)) {\n                // See if the the client explicitly handles connection persistence\n                String connHeader = context.getStringProperty(HttpConstants.HEADER_CONNECTION);\n                if (connHeader != null) {\n                    if (connHeader.equalsIgnoreCase(\"keep-alive\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"keep-alive\");\n                        response.addHeader(header);\n                        response.setKeepAlive(true);\n                    }\n                    if (connHeader.equalsIgnoreCase(\"close\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"close\");\n                        response.addHeader(header);\n                        response.setKeepAlive(false);\n                    }\n                } else {\n                    // Use protocol default connection policy\n                    if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {\n                        response.setKeepAlive(true);\n                    } else {\n                        response.setKeepAlive(false);\n                    }\n                }\n            }\n            if (\"HEAD\".equalsIgnoreCase(context.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY))) {\n                // this is a head request, we don't want to send the actualy content\n                response.setBody(null);\n            }\n            return response;\n        } catch (IOException e) {\n            throw new TransformerException(this, e);\n        }\n\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n        if(src instanceof Entry) {\n            return src;\n        } else {\n            String destination = context.getEndpointURI().toString();\n            return new JiniMessage(destination, src);\n        }\n    }","id":66034,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n        if(src instanceof Entry) {\n            return src;\n        } else {\n            String destination = context.getEndpointURI().toString();\n            return new JiniMessage(destination, src);\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        if(src instanceof byte[]) {\n            return getXStream().fromXML(new String((byte[])src));\n        } else if(src instanceof String) {\n            return getXStream().fromXML(src.toString());\n        } else {\n            return getXStream().fromXML((String)domTransformer.transform(src));\n        }\n    }","id":66035,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        if(src instanceof byte[]) {\n            return getXStream().fromXML(new String((byte[])src));\n        } else if(src instanceof String) {\n            return getXStream().fromXML(src.toString());\n        } else {\n            return getXStream().fromXML((String)domTransformer.transform(src));\n        }\n    }","commit_id":"14452e5412977648ad90cbd8d5fac79b0862005e","url":"https://github.com/mulesoft/mule"},{"original_method":"public abstract Object transform(Object src, UMOEventContext context) throws TransformerException;","id":66036,"modified_method":"public abstract Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException;","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public final Object doTransform(Object src, String encoding) throws TransformerException\n    {\n        UMOEventContext event = RequestContext.getEventContext();\n        if (event == null) {\n            throw new TransformerException(new Message(Messages.NO_CURRENT_EVENT_FOR_TRANSFORMER), this);\n        }\n        return transform(src, event);\n    }","id":66037,"modified_method":"public final Object doTransform(Object src, String encoding) throws TransformerException\n    {\n        UMOEventContext event = RequestContext.getEventContext();\n        if (event == null) {\n            throw new TransformerException(new Message(Messages.NO_CURRENT_EVENT_FOR_TRANSFORMER), this);\n        }\n        return transform(src, encoding, event);\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected synchronized void initFromServiceDescriptor() throws InitialisationException\n    {\n        try {\n            serviceDescriptor = ConnectorFactory.getServiceDescriptor(getProtocol().toLowerCase(), serviceOverrides);\n\n            if (serviceDescriptor.getDispatcherFactory() != null) {\n                logger.info(\"Loading DispatcherFactory: \" + serviceDescriptor.getDispatcherFactory());\n                dispatcherFactory = serviceDescriptor.createDispatcherFactory();\n            }\n\n            defaultInboundTransformer = serviceDescriptor.createInboundTransformer();\n            defaultOutboundTransformer = serviceDescriptor.createOutboundTransformer();\n            defaultResponseTransformer = serviceDescriptor.createResponseTransformer();\n\n            sessionHandler = serviceDescriptor.createSessionHandler();\n            // set any manager default properties for the connector\n            // these are set on the Manager with a protocol i.e.\n            // jms.specification=1.1\n            //This provides a really convenient way to set properties on object form unit\n            //tests\n            Map props = PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(), getProtocol().toLowerCase());\n            if (props.size() > 0) {\n                props = PropertiesHelper.removeNamspaces(props);\n                org.mule.util.BeanUtils.populateWithoutFail(this, props, true);\n            }\n        } catch (Exception e) {\n            throw new InitialisationException(e, this);\n        }\n    }","id":66038,"modified_method":"protected synchronized void initFromServiceDescriptor() throws InitialisationException\n    {\n        try {\n            serviceDescriptor = ConnectorFactory.getServiceDescriptor(getProtocol().toLowerCase(), serviceOverrides);\n\n            if (serviceDescriptor.getDispatcherFactory() != null) {\n                logger.info(\"Loading DispatcherFactory: \" + serviceDescriptor.getDispatcherFactory());\n                dispatcherFactory = serviceDescriptor.createDispatcherFactory();\n            }\n\n            defaultInboundTransformer = serviceDescriptor.createInboundTransformer();\n            defaultOutboundTransformer = serviceDescriptor.createOutboundTransformer();\n            defaultResponseTransformer = serviceDescriptor.createResponseTransformer();\n\n            sessionHandler = serviceDescriptor.createSessionHandler();\n            // set any manager default properties for the connector\n            // these are set on the Manager with a protocol i.e.\n            // jms.specification=1.1\n            //This provides a really convenient way to set properties on object form unit\n            //tests\n            Map props = new HashMap();\n            PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(), getProtocol().toLowerCase(), props);\n            if (props.size() > 0) {\n                props = PropertiesHelper.removeNamspaces(props);\n                org.mule.util.BeanUtils.populateWithoutFail(this, props, true);\n            }\n        } catch (Exception e) {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates an uninitialied connector from the provided MuleEndpointURI. The\n     * scheme is used to determine what kind of connector to create. Any params\n     * set on the uri can be used to initialise bean properties on the created\n     * connector. <p/> Note that the initalise method will need to be called on\n     * the connector returned. This is so that developers can control when the\n     * connector initialisation takes place as this is likely to initialse all\n     * connecotr resources.\n     * \n     * @param url the MuleEndpointURI url to create the connector with\n     * @return a new Connector\n     * @throws ConnectorFactoryException\n     */\n    public static UMOConnector createConnector(UMOEndpointURI url) throws ConnectorFactoryException\n    {\n        String scheme = url.getSchemeMetaInfo();\n\n        UMOConnector connector = null;\n        ConnectorServiceDescriptor csd = getServiceDescriptor(scheme);\n        // Make sure we can create the endpoint/connector using this service\n        // method\n        if (csd.getServiceError() != null) {\n            throw new ConnectorServiceException(Message.createStaticMessage(csd.getServiceError()));\n        }\n\n        //If this is a fineder service, lets find it before trying to create it\n        if (csd.getServiceFinder() != null) {\n            csd = csd.createServiceFinder().findService(scheme, csd);\n        }\n        // if there is a factory, use it\n        try {\n            if (csd.getConnectorFactory() != null) {\n                ObjectFactory factory = (ObjectFactory) ClassHelper.loadClass(csd.getConnectorFactory(),\n                                                                              ConnectorFactory.class).newInstance();\n                connector = (UMOConnector) factory.create();\n            } else {\n                if (csd.getConnector() != null) {\n                    connector = (UMOConnector) ClassHelper.loadClass(csd.getConnector(), ConnectorFactory.class)\n                                                          .newInstance();\n                    if (connector instanceof AbstractServiceEnabledConnector) {\n                        ((AbstractServiceEnabledConnector) connector).initialiseFromUrl(url);\n                    }\n                } else {\n                    throw new ConnectorFactoryException(new Message(Messages.X_NOT_SET_IN_SERVICE_X,\n                                                                    \"Connector\",\n                                                                    scheme));\n                }\n            }\n        } catch (ConnectorFactoryException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ConnectorFactoryException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Endpoint\", url), e);\n        }\n\n        if (connector.getName() == null) {\n            connector.setName(\"_\" + scheme + \"Connector#\" + connector.hashCode());\n        }\n        // set any manager default properties for the connector\n        // these are set on the Manager with a protocol i.e.\n        // jms.specification=1.1\n        Map props = PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(),\n                                                             connector.getProtocol().toLowerCase());\n        if (props.size() > 0) {\n            props = PropertiesHelper.removeNamspaces(props);\n            org.mule.util.BeanUtils.populateWithoutFail(connector, props, true);\n        }\n\n        return connector;\n    }","id":66039,"modified_method":"/**\n     * Creates an uninitialied connector from the provided MuleEndpointURI. The\n     * scheme is used to determine what kind of connector to create. Any params\n     * set on the uri can be used to initialise bean properties on the created\n     * connector. <p/> Note that the initalise method will need to be called on\n     * the connector returned. This is so that developers can control when the\n     * connector initialisation takes place as this is likely to initialse all\n     * connecotr resources.\n     * \n     * @param url the MuleEndpointURI url to create the connector with\n     * @return a new Connector\n     * @throws ConnectorFactoryException\n     */\n    public static UMOConnector createConnector(UMOEndpointURI url) throws ConnectorFactoryException\n    {\n        String scheme = url.getSchemeMetaInfo();\n\n        UMOConnector connector = null;\n        ConnectorServiceDescriptor csd = getServiceDescriptor(scheme);\n        // Make sure we can create the endpoint/connector using this service\n        // method\n        if (csd.getServiceError() != null) {\n            throw new ConnectorServiceException(Message.createStaticMessage(csd.getServiceError()));\n        }\n\n        //If this is a fineder service, lets find it before trying to create it\n        if (csd.getServiceFinder() != null) {\n            csd = csd.createServiceFinder().findService(scheme, csd);\n        }\n        // if there is a factory, use it\n        try {\n            if (csd.getConnectorFactory() != null) {\n                ObjectFactory factory = (ObjectFactory) ClassHelper.loadClass(csd.getConnectorFactory(),\n                                                                              ConnectorFactory.class).newInstance();\n                connector = (UMOConnector) factory.create();\n            } else {\n                if (csd.getConnector() != null) {\n                    connector = (UMOConnector) ClassHelper.loadClass(csd.getConnector(), ConnectorFactory.class)\n                                                          .newInstance();\n                    if (connector instanceof AbstractServiceEnabledConnector) {\n                        ((AbstractServiceEnabledConnector) connector).initialiseFromUrl(url);\n                    }\n                } else {\n                    throw new ConnectorFactoryException(new Message(Messages.X_NOT_SET_IN_SERVICE_X,\n                                                                    \"Connector\",\n                                                                    scheme));\n                }\n            }\n        } catch (ConnectorFactoryException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ConnectorFactoryException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Endpoint\", url), e);\n        }\n\n        if (connector.getName() == null) {\n            connector.setName(\"_\" + scheme + \"Connector#\" + connector.hashCode());\n        }\n        // set any manager default properties for the connector\n        // these are set on the Manager with a protocol i.e.\n        // jms.specification=1.1\n        Map props = new HashMap();\n        PropertiesHelper.getPropertiesWithPrefix(MuleManager.getInstance().getProperties(),\n                                                             connector.getProtocol().toLowerCase(), props);\n        if (props.size() > 0) {\n            props = PropertiesHelper.removeNamspaces(props);\n            org.mule.util.BeanUtils.populateWithoutFail(connector, props, true);\n        }\n\n        return connector;\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            return getXStream().toXML(context.getMessage());\n        } else {\n            return getXStream().toXML(src);\n        }\n    }","id":66040,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            return getXStream().toXML(context.getMessage());\n        } else {\n            return getXStream().toXML(src);\n        }\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"private void loadStrategies() throws Exception\n    {\n        String path = System.getProperty(MULE_ENCRYPTION_PROPERTIES, MuleManager.getConfiguration().getWorkingDirectory()\n                + File.separator + DEFAULT_ENCRYPTION_PROPERTIES_FILE);\n\n        logger.info(\"Attempting to load encryption properties from: \" + path);\n        Properties props = PropertiesHelper.loadProperties(path);\n\n        Map names = PropertiesHelper.getPropertiesWithPrefix(props, \"name\");\n        String name;\n        for (Iterator iterator = names.values().iterator(); iterator.hasNext();) {\n            name = (String) iterator.next();\n            Map schemeConfig = PropertiesHelper.getPropertiesWithPrefix(props, name + \".\");\n            schemeConfig = PropertiesHelper.removeNamspaces(schemeConfig);\n\n            String type = (String)schemeConfig.get(\"type\");\n            String clazz = (String)types.get(type);\n            if(clazz==null) {\n                throw new IllegalArgumentException(\"Unknown encryption type: \" + type);\n            }\n            logger.debug(\"Found Class: \" + clazz + \" for type: \" + type);\n            UMOEncryptionStrategy strat = (UMOEncryptionStrategy)ClassHelper.instanciateClass(clazz, ClassHelper.NO_ARGS, PlaceholderProcessor.class);\n            BeanUtils.populateWithoutFail(strat, schemeConfig, true);\n            schemes.put(name, strat);\n        }\n    }","id":66041,"modified_method":"private void loadStrategies() throws Exception\n    {\n        String path = System.getProperty(MULE_ENCRYPTION_PROPERTIES, MuleManager.getConfiguration().getWorkingDirectory()\n                + File.separator + DEFAULT_ENCRYPTION_PROPERTIES_FILE);\n\n        logger.info(\"Attempting to load encryption properties from: \" + path);\n        Properties props = PropertiesHelper.loadProperties(path);\n\n        Map names = new HashMap();\n        PropertiesHelper.getPropertiesWithPrefix(props, \"name\", names);\n        String name;\n        for (Iterator iterator = names.values().iterator(); iterator.hasNext();) {\n            name = (String) iterator.next();\n            Map schemeConfig = new HashMap();\n            PropertiesHelper.getPropertiesWithPrefix(props, name + \".\", schemeConfig);\n            schemeConfig = PropertiesHelper.removeNamspaces(schemeConfig);\n\n            String type = (String)schemeConfig.get(\"type\");\n            String clazz = (String)types.get(type);\n            if(clazz==null) {\n                throw new IllegalArgumentException(\"Unknown encryption type: \" + type);\n            }\n            logger.debug(\"Found Class: \" + clazz + \" for type: \" + type);\n            UMOEncryptionStrategy strat = (UMOEncryptionStrategy)ClassHelper.instanciateClass(clazz, ClassHelper.NO_ARGS, PlaceholderProcessor.class);\n            BeanUtils.populateWithoutFail(strat, schemeConfig, true);\n            schemes.put(name, strat);\n        }\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        Namespace ns = getScriptEngine().createNamespace();\n        populateNamespace(ns, context, src);\n        try {\n            return scriptable.runScript(ns);\n        } catch (ScriptException e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":66042,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        Namespace ns = getScriptEngine().createNamespace();\n        populateNamespace(ns, context, src);\n        try {\n            return scriptable.runScript(ns);\n        } catch (ScriptException e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        Object obj = null;\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            obj = context.getMessage();\n        } else {\n            obj = src;\n            if (obj instanceof byte[]) {\n                return (byte[]) obj;\n            }\n        }\n\n        byte[] dest = null;\n        ByteArrayOutputStream bs = null;\n        ObjectOutputStream os = null;\n        try {\n            bs = new ByteArrayOutputStream();\n            os = new ObjectOutputStream(bs);\n            os.writeObject(obj);\n            os.flush();\n            dest = bs.toByteArray();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return dest;\n    }","id":66043,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        Object obj = null;\n        //If the UMOMessage source type has been registered that we can assume that the\n        //whole message is to be serialised to Xml, nit just the payload.  This can be useful\n        //for protocols such as tcp where the protocol does not support headers, thus the whole messgae\n        //needs to be serialized\n        if(isSourceTypeSupported(UMOMessage.class, true)) {\n            obj = context.getMessage();\n        } else {\n            obj = src;\n            if (obj instanceof byte[]) {\n                return (byte[]) obj;\n            }\n        }\n\n        byte[] dest = null;\n        ByteArrayOutputStream bs = null;\n        ObjectOutputStream os = null;\n        try {\n            bs = new ByteArrayOutputStream();\n            os = new ObjectOutputStream(bs);\n            os.writeObject(obj);\n            os.flush();\n            dest = bs.toByteArray();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return dest;\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, UMOEventContext context) throws TransformerException {\n\n        if(src instanceof byte[]) {\n            return getXStream().fromXML(new String((byte[])src));\n        } else if(src instanceof String) {\n            return getXStream().fromXML(src.toString());\n        } else {\n            return getXStream().fromXML((String)domTransformer.transform(src));\n        }\n    }","id":66044,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        if(src instanceof byte[]) {\n            return getXStream().fromXML(new String((byte[])src));\n        } else if(src instanceof String) {\n            return getXStream().fromXML(src.toString());\n        } else {\n            return getXStream().fromXML((String)domTransformer.transform(src));\n        }\n    }","commit_id":"2d4c6663a471c923b035b73084773e94c2ac641c","url":"https://github.com/mulesoft/mule"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"1m\").singles();\n        int CHILD_COUNT = 5;\n        int BATCH = 100;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 50;\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n            client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(\"test\").type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(Integer.toString(counter), \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(\"test\").type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(Integer.toString(counter), \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.timedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().count());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.took());\n            }\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.tookInMillis();\n        }\n        System.out.println(\"--> Just Child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running has_child query\");\n        // run parent child constant query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            if (searchResponse.failedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n            }\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            if (searchResponse.failedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n            }\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n            totalQueryTime += searchResponse.tookInMillis();\n        }\n        System.out.println(\"--> has_child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        String[] executionTypes = new String[]{\"uid\", \"indirect\"}; // either uid (faster, in general a bit more memory) or indirect (slower, but in general a bit less memory)\n        for (String executionType : executionTypes) {\n            System.out.println(\"--> Running has_parent filter with \" + executionType + \" execution type\");\n            // run parent child constant query\n            for (int j = 0; j < QUERY_WARMUP; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", termQuery(\"name\", \"test1\")).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != CHILD_COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n                }\n            }\n\n            totalQueryTime = 0;\n            for (int j = 1; j <= QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", termQuery(\"name\", \"test1\")).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != CHILD_COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_parent[\" + executionType + \"] Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n            System.out.println(\"--> Running has_parent[\" + executionType + \"] filter with match_all query as parent query\");\n            totalQueryTime = 0;\n            for (int j = 1; j <= QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", matchAllQuery()).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != 5000000) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + 5000000 + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_parent[\" + executionType + \"] with match_all query as parent query Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n        System.out.println(\"--> Running top_children query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.tookInMillis();\n        }\n        System.out.println(\"--> top_children Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        client.close();\n        node1.close();\n    }","id":66045,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"1m\").singles();\n        int CHILD_COUNT = 5;\n        int BATCH = 100;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 50;\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n            client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(\"test\").type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(Integer.toString(counter), \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(\"test\").type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(Integer.toString(counter), \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.timedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().count());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.took());\n            }\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (searchResponse.hits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.tookInMillis();\n        }\n        System.out.println(\"--> Just Child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        String[] executionTypes = new String[]{\"uid\", \"bitset\"};// either uid (faster, in general a bit more memory) or bitset (slower, but in general a bit less memory)\n        for (String executionType : executionTypes) {\n            System.out.println(\"--> Running has_child query with execution type \" + executionType);\n            // run parent child constant query\n            for (int j = 0; j < QUERY_WARMUP; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(\n                                hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).executionType(executionType)\n                        )\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + COUNT + \"]\");\n                }\n            }\n\n            totalQueryTime = 0;\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(\n                                hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).executionType(executionType)\n                        )\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + COUNT + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_child[\" + executionType + \"] Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n            System.out.println(\"--> Running has_child[\" + executionType + \"] filter with match_all child query\");\n            totalQueryTime = 0;\n            for (int j = 1; j <= QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(\n                                hasChildQuery(\"child\", matchAllQuery()).executionType(executionType)\n                        )\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                long expected = (COUNT / BATCH) * BATCH;\n                if (searchResponse.hits().totalHits() != expected) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + expected + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_child[\" + executionType + \"] with match_all child query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        for (String executionType : executionTypes) {\n            System.out.println(\"--> Running has_parent filter with \" + executionType + \" execution type\");\n            // run parent child constant query\n            for (int j = 0; j < QUERY_WARMUP; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", termQuery(\"name\", \"test1\")).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != CHILD_COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n                }\n            }\n\n            totalQueryTime = 0;\n            for (int j = 1; j <= QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", termQuery(\"name\", \"test1\")).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != CHILD_COUNT) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_parent[\" + executionType + \"] Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n            System.out.println(\"--> Running has_parent[\" + executionType + \"] filter with match_all parent query \");\n            totalQueryTime = 0;\n            for (int j = 1; j <= QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(constantScoreQuery(\n                                hasParentFilter(\"parent\", matchAllQuery()).executionType(executionType)\n                        ))\n                        .execute().actionGet();\n                if (searchResponse.failedShards() > 0) {\n                    System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.shardFailures()));\n                }\n                if (searchResponse.hits().totalHits() != 5000000) {\n                    System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.hits().totalHits() + \"], expected [\" + 5000000 + \"]\");\n                }\n                totalQueryTime += searchResponse.tookInMillis();\n            }\n            System.out.println(\"--> has_parent[\" + executionType + \"] with match_all parent query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n        System.out.println(\"--> Running top_children query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch().setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.tookInMillis();\n        }\n        System.out.println(\"--> top_children Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        client.close();\n        node1.close();\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query query() {\n        return query;\n    }","id":66046,"modified_method":"public Query query() {\n        return childQuery;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public HasChildFilter(Query query, String scope, String childType, String parentType, SearchContext searchContext) {\n        this.query = query;\n        this.scope = scope;\n        this.parentType = parentType;\n        this.childType = childType;\n        this.searchContext = searchContext;\n    }","id":66047,"modified_method":"protected HasChildFilter(Query childQuery, String scope, String parentType, String childType, SearchContext searchContext) {\n        this.searchContext = searchContext;\n        this.parentType = parentType;\n        this.childType = childType;\n        this.scope = scope;\n        this.childQuery = childQuery;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"child_filter[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(query).append(')');\n        return sb.toString();\n    }","id":66048,"modified_method":"@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"child_filter[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(childQuery).append(')');\n        return sb.toString();\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String scope() {\n        return this.scope;\n    }","id":66049,"modified_method":"public String scope() {\n        return scope;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildFilterParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        builder.endObject();\n    }","id":66050,"modified_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildFilterParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"child_type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String childType = null;\n        String scope = null;\n\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`...\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        // wrap the query with type query\n        query = new FilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasChildFilter childFilter = new HasChildFilter(query, scope, childType, parentType, searchContext);\n        searchContext.addScopePhase(childFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, childFilter);\n        }\n        return childFilter;\n    }","id":66051,"modified_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String childType = null;\n        String scope = null;\n\n        String executionType = \"uid\";\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`...\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"child_type\".equals(currentFieldName) || \"childType\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) {// This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        // wrap the query with type query\n        query = new FilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasChildFilter childFilter = HasChildFilter.create(query, scope, parentType, childType, searchContext, executionType);\n        searchContext.addScopePhase(childFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, childFilter);\n        }\n        return childFilter;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildQueryParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (boost != 1.0f) {\n            builder.field(\"boost\", boost);\n        }\n        builder.endObject();\n    }","id":66052,"modified_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildQueryParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"child_type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (boost != 1.0f) {\n            builder.field(\"boost\", boost);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        float boost = 1.0f;\n        String childType = null;\n        String scope = null;\n\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`... (see HasChildFilterParser)\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] query does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child]  Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        query.setBoost(boost);\n        // wrap the query with type query\n        query = new FilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n        HasChildFilter childFilter = new HasChildFilter(query, scope, childType, parentType, searchContext);\n        // we don't need DeletionAwareConstantScore, since we filter deleted parent docs in the filter\n        ConstantScoreQuery childQuery = new ConstantScoreQuery(childFilter);\n        childQuery.setBoost(boost);\n        searchContext.addScopePhase(childFilter);\n        return childQuery;\n    }","id":66053,"modified_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        float boost = 1.0f;\n        String childType = null;\n        String scope = null;\n\n        String executionType = \"uid\";\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`... (see HasChildFilterParser)\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] query does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"child_type\".equals(currentFieldName) || \"childType\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) {// This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child] No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"[has_child]  Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        query.setBoost(boost);\n        // wrap the query with type query\n        query = new FilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n        HasChildFilter childFilter = HasChildFilter.create(query, scope, parentType, childType, searchContext, executionType);\n        // we don't need DeletionAwareConstantScore, since we filter deleted parent docs in the filter\n        ConstantScoreQuery childQuery = new ConstantScoreQuery(childFilter);\n        childQuery.setBoost(boost);\n        searchContext.addScopePhase(childFilter);\n        return childQuery;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Query query() {\n        return query;\n    }","id":66054,"modified_method":"public Query query() {\n        return parentQuery;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"HasParentFilter(Query query, String scope, String parentType, SearchContext context) {\n        this.query = query;\n        this.scope = scope;\n        this.parentType = parentType;\n        this.context = context;\n    }","id":66055,"modified_method":"HasParentFilter(Query parentQuery, String scope, String parentType, SearchContext context) {\n        this.parentQuery = parentQuery;\n        this.scope = scope;\n        this.parentType = parentType;\n        this.context = context;\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static HasParentFilter create(String executionType, Query query, String scope, String parentType, SearchContext context) {\n        // This mechanism is experimental and will most likely be removed.\n        if (\"indirect\".equals(executionType)) {\n            return new InDirect(query, scope, parentType, context);\n        } else if (\"uid\".equals(executionType)) {\n            return new UidParentFilter(query, scope, parentType, context);\n        }\n        throw new ElasticSearchIllegalStateException(\"Illegal has_parent execution type: \" + executionType);\n    }","id":66056,"modified_method":"public static HasParentFilter create(String executionType, Query query, String scope, String parentType, SearchContext context) {\n        // This mechanism is experimental and will most likely be removed.\n        if (\"bitset\".equals(executionType)) {\n            return new Bitset(query, scope, parentType, context);\n        } else if (\"uid\".equals(executionType)) {\n            return new Uid(query, scope, parentType, context);\n        }\n        throw new ElasticSearchIllegalStateException(\"Illegal has_parent execution type: \" + executionType);\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDfsSearchType() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 2)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setSearchType(SearchType.DFS_QUERY_THEN_FETCH)\n                .setQuery(boolQuery().mustNot(hasChildQuery(\"child\", boolQuery().should(queryString(\"c_field:*\")))))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n    }","id":66057,"modified_method":"@Test\n    public void testDfsSearchType() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 2)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setSearchType(SearchType.DFS_QUERY_THEN_FETCH)\n                .setQuery(boolQuery().mustNot(hasChildQuery(\"child\", boolQuery().should(queryString(\"c_field:*\"))).executionType(getExecutionMethod())))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDeletedParent() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1\\\"\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1\\\"\"));\n\n        // update p1 and see what that we get updated values...\n\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1_updated\").execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1_updated\\\"\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1_updated\\\"\"));\n    }","id":66058,"modified_method":"@Test\n    public void testDeletedParent() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1\\\"\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1\\\"\"));\n\n        // update p1 and see what that we get updated values...\n\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1_updated\").execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1_updated\\\"\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(0).sourceAsString(), containsString(\"\\\"p_value1_updated\\\"\"));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void multiLevelChild() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"grandchild\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"child\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"c_value1\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"grandchild\", \"gc1\").setSource(\"gc_field\", \"gc_value1\").setParent(\"c1\").setRouting(\"gc1\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", filteredQuery(termQuery(\"c_field\", \"c_value1\"), hasChildFilter(\"grandchild\", termQuery(\"gc_field\", \"gc_value1\"))))))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n    }","id":66059,"modified_method":"@Test\n    public void multiLevelChild() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"grandchild\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"child\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"c_value1\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"grandchild\", \"gc1\").setSource(\"gc_field\", \"gc_value1\").setParent(\"c1\").setRouting(\"gc1\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(\n                        filteredQuery(\n                                matchAllQuery(),\n                                hasChildFilter(\n                                        \"child\",\n                                        filteredQuery(termQuery(\"c_field\", \"c_value1\"), hasChildFilter(\"grandchild\", termQuery(\"gc_field\", \"gc_value1\")).executionType(getExecutionMethod()))\n                                ).executionType(getExecutionMethod())\n                        )\n                )\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleChildQueryWithFlushAnd3Shards() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 3)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data with flushes, so we have many segments\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n    }","id":66060,"modified_method":"@Test\n    public void simpleChildQueryWithFlushAnd3Shards() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 3)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data with flushes, so we have many segments\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleChildQuery() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TEST FETCHING _parent from child\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(idsQuery(\"child\").ids(\"c1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c1\"));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        // TEST matching on parent\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(termQuery(\"child._parent\", \"p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(termQuery(\"_parent\", \"p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(queryString(\"_parent:p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n\n        // TOP CHILDREN QUERY\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\")))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS PARENT FILTER\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", \"p_value2\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c3\"));\n        assertThat(searchResponse.hits().getAt(1).id(), equalTo(\"c4\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", \"p_value1\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), equalTo(\"c2\"));\n    }","id":66061,"modified_method":"@Test\n    public void simpleChildQuery() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TEST FETCHING _parent from child\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(idsQuery(\"child\").ids(\"c1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c1\"));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        // TEST matching on parent\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(termQuery(\"child._parent\", \"p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(termQuery(\"_parent\", \"p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(queryString(\"_parent:p1\"))\n                .addFields(\"_parent\")\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(0).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"c1\"), equalTo(\"c2\")));\n        assertThat(searchResponse.hits().getAt(1).field(\"_parent\").value().toString(), equalTo(\"p1\"));\n\n\n        // TOP CHILDREN QUERY\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\")))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod())).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod()))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS PARENT FILTER\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", \"p_value2\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c3\"));\n        assertThat(searchResponse.hits().getAt(1).id(), equalTo(\"c4\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", \"p_value1\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"c1\"));\n        assertThat(searchResponse.hits().getAt(1).id(), equalTo(\"c2\"));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testHasParentFilter() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        Map<String, List<String>> parentToChildren = newHashMap();\n        // Childless parent\n        client.prepareIndex(\"test\", \"parent\", \"p0\").setSource(\"p_field\", \"p0\").execute().actionGet();\n        parentToChildren.put(\"p0\", new ArrayList<String>());\n\n        String previousParentId = null;\n        int numChildDocs = 32;\n        int numChildDocsPerParent = 0;\n        for (int i = 1; i <= numChildDocs; i++) {\n            if (previousParentId == null || i % numChildDocsPerParent == 0) {\n                previousParentId = \"p\" + i;\n                client.prepareIndex(\"test\", \"parent\", previousParentId).setSource(\"p_field\", previousParentId).execute().actionGet();\n                client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n                numChildDocsPerParent++;\n            }\n\n            String childId = \"c\" + i;\n            client.prepareIndex(\"test\", \"child\", childId)\n                    .setSource(\"c_field\", childId)\n                    .setParent(previousParentId)\n                    .execute().actionGet();\n\n            if (!parentToChildren.containsKey(previousParentId)) {\n                parentToChildren.put(previousParentId, new ArrayList<String>());\n            }\n            parentToChildren.get(previousParentId).add(childId);\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        assertThat(parentToChildren.isEmpty(), equalTo(false));\n        for (Map.Entry<String, List<String>> parentToChildrenEntry : parentToChildren.entrySet()) {\n            SearchResponse searchResponse = client.prepareSearch(\"test\")\n                    .setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", parentToChildrenEntry.getKey()))))\n                    .setSize(numChildDocsPerParent)\n                    .execute().actionGet();\n\n            assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n            assertThat(searchResponse.failedShards(), equalTo(0));\n            List<String> childIds = parentToChildrenEntry.getValue();\n            assertThat(searchResponse.hits().totalHits(), equalTo((long) childIds.size()));\n            int counter = 0;\n            for (String childId : childIds) {\n                assertThat(searchResponse.hits().getAt(counter++).id(), equalTo(childId));\n            }\n        }\n    }","id":66062,"modified_method":"@Test\n    public void testHasParentFilter() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        Map<String, List<String>> parentToChildren = newHashMap();\n        // Childless parent\n        client.prepareIndex(\"test\", \"parent\", \"p0\").setSource(\"p_field\", \"p0\").execute().actionGet();\n        parentToChildren.put(\"p0\", new ArrayList<String>());\n\n        String previousParentId = null;\n        int numChildDocs = 32;\n        int numChildDocsPerParent = 0;\n        for (int i = 1; i <= numChildDocs; i++) {\n            if (previousParentId == null || i % numChildDocsPerParent == 0) {\n                previousParentId = \"p\" + i;\n                client.prepareIndex(\"test\", \"parent\", previousParentId).setSource(\"p_field\", previousParentId).execute().actionGet();\n                client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n                numChildDocsPerParent++;\n            }\n\n            String childId = \"c\" + i;\n            client.prepareIndex(\"test\", \"child\", childId)\n                    .setSource(\"c_field\", childId)\n                    .setParent(previousParentId)\n                    .execute().actionGet();\n\n            if (!parentToChildren.containsKey(previousParentId)) {\n                parentToChildren.put(previousParentId, new ArrayList<String>());\n            }\n            parentToChildren.get(previousParentId).add(childId);\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        assertThat(parentToChildren.isEmpty(), equalTo(false));\n        for (Map.Entry<String, List<String>> parentToChildrenEntry : parentToChildren.entrySet()) {\n            SearchResponse searchResponse = client.prepareSearch(\"test\")\n                    .setQuery(constantScoreQuery(hasParentFilter(\"parent\", termQuery(\"p_field\", parentToChildrenEntry.getKey())).executionType(getExecutionMethod())))\n                    .setSize(numChildDocsPerParent)\n                    .execute().actionGet();\n\n            assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n            assertThat(searchResponse.failedShards(), equalTo(0));\n            List<String> childIds = parentToChildrenEntry.getValue();\n            assertThat(searchResponse.hits().totalHits(), equalTo((long) childIds.size()));\n            int counter = 0;\n            for (String childId : childIds) {\n                assertThat(searchResponse.hits().getAt(counter++).id(), equalTo(childId));\n            }\n        }\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleChildQueryWithFlush() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data with flushes, so we have many segments\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n    }","id":66063,"modified_method":"@Test\n    public void simpleChildQueryWithFlush() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(ImmutableSettings.settingsBuilder().put(\"index.number_of_shards\", 1)).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                .endObject().endObject()).execute().actionGet();\n\n        // index simple data with flushes, so we have many segments\n        client.prepareIndex(\"test\", \"parent\", \"p1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c1\").setSource(\"c_field\", \"red\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c2\").setSource(\"c_field\", \"yellow\").setParent(\"p1\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"parent\", \"p2\").setSource(\"p_field\", \"p_value2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c3\").setSource(\"c_field\", \"blue\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"c4\").setSource(\"c_field\", \"red\").setParent(\"p2\").execute().actionGet();\n        client.admin().indices().prepareFlush().execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        // TOP CHILDREN QUERY\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"yellow\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"blue\"))).execute().actionGet();\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(topChildrenQuery(\"child\", termQuery(\"c_field\", \"red\"))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD QUERY\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(hasChildQuery(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod())).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n\n        // HAS CHILD FILTER\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"yellow\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p1\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"blue\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().getAt(0).id(), equalTo(\"p2\"));\n\n        searchResponse = client.prepareSearch(\"test\").setQuery(constantScoreQuery(hasChildFilter(\"child\", termQuery(\"c_field\", \"red\")).executionType(getExecutionMethod()))).execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(2l));\n        assertThat(searchResponse.hits().getAt(0).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n        assertThat(searchResponse.hits().getAt(1).id(), anyOf(equalTo(\"p2\"), equalTo(\"p1\")));\n    }","commit_id":"3cd54fc4ee70a395e26dc5220e8245a55e2723aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * validates a specific certificate inside of the keystore being passed in\n     * \n     * @param keyStore\n     * @param cert\n     * @throws CertificateException\n     */\n    public void validate(KeyStore keyStore, Certificate cert) throws CertificateException\n    {\n        if (cert != null && cert instanceof X509Certificate)\n        {\n            ((X509Certificate)cert).checkValidity();\n            \n            String certAlias = \"[none]\";\n            try\n            {\n                certAlias = keyStore.getCertificateAlias((X509Certificate)cert);\n                Certificate[] certChain = keyStore.getCertificateChain(certAlias);\n                   \n                ArrayList<X509Certificate> certList = new ArrayList<X509Certificate>();\n                for (Certificate item : certChain)\n                {\n                    if (!(item instanceof X509Certificate))\n                    {\n                        throw new CertificateException(\"Invalid certificate type in chain\");\n                    }\n                    certList.add((X509Certificate)item);\n                }\n\n                if (certList.isEmpty())\n                {\n                    throw new CertificateException(\"Invalid certificate chain\");\n                    \n                }\n\n                X509CertSelector certSelect = new X509CertSelector();\n                certSelect.setCertificate(certList.get(0));\n                \n                // Configure certification path builder parameters\n                PKIXBuilderParameters pbParams = new PKIXBuilderParameters(_trustStore, certSelect);\n                pbParams.addCertStore(CertStore.getInstance(\"Collection\", new CollectionCertStoreParameters(certList)));\n\n                // Set static Certificate Revocation List\n                if (_crls != null && !_crls.isEmpty())\n                {\n                    pbParams.addCertStore(CertStore.getInstance(\"Collection\", new CollectionCertStoreParameters(_crls)));\n                }\n\n                // Enable revocation checking\n                pbParams.setRevocationEnabled(true);\n\n                // Set maximum certification path length\n                pbParams.setMaxPathLength(_maxCertPathLength);\n \n                // Build certification path\n                CertPathBuilderResult buildResult = CertPathBuilder.getInstance(\"PKIX\").build(pbParams);               \n                \n                // Validate certification path\n                CertPathValidator.getInstance(\"PKIX\").validate(buildResult.getCertPath(),pbParams);\n            }\n            catch (Exception ex)\n            {\n                Log.debug(ex);\n                throw new CertificateException(\"Unable to validate certificate for alias [\" +\n                                               certAlias + \"]: \" + ex.getMessage());\n            }\n        } \n    }","id":66064,"modified_method":"/**\n     * validates a specific certificate inside of the keystore being passed in\n     * \n     * @param keyStore\n     * @param cert\n     * @throws CertificateException\n     */\n    public void validate(KeyStore keyStore, Certificate cert) throws CertificateException\n    {\n        Certificate[] certChain = null;\n        \n        if (cert != null && cert instanceof X509Certificate)\n        {\n            ((X509Certificate)cert).checkValidity();\n            \n            String certAlias = null;\n            try\n            {\n                if (keyStore == null)\n                {\n                    throw new InvalidParameterException(\"Keystore cannot be null\");\n                }\n\n                certAlias = keyStore.getCertificateAlias((X509Certificate)cert);\n                if (certAlias == null)\n                {\n                    certAlias = \"JETTY\" + String.format(\"%016X\",__aliasCount.incrementAndGet());\n                    keyStore.setCertificateEntry(certAlias, cert);\n                }\n                \n                certChain = keyStore.getCertificateChain(certAlias);\n                if (certChain == null || certChain.length == 0)\n                {\n                    throw new IllegalStateException(\"Unable to retrieve certificate chain\");\n                }\n            }\n            catch (KeyStoreException kse)\n            {\n                Log.debug(kse);\n                throw new CertificateException(\"Unable to validate certificate\" +\n                        (certAlias == null ? \"\":\" for alias [\" +certAlias + \"]\") + \": \" + kse.getMessage(), kse);\n            }\n            \n            validate(certChain);\n        } \n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * creates an instance of the certificate validator \n     *\n     * @param trustStore \n     * @param crls\n     */\n    public CertificateValidator(KeyStore trustStore, Collection<? extends CRL> crls)\n    {\n        _trustStore = trustStore;\n        _crls = crls;\n    }","id":66065,"modified_method":"/**\n     * creates an instance of the certificate validator \n     *\n     * @param trustStore \n     * @param crls\n     */\n    public CertificateValidator(KeyStore trustStore, Collection<? extends CRL> crls)\n    {\n        if (trustStore == null)\n        {\n            throw new InvalidParameterException(\"TrustStore must be specified for CertificateValidator.\");\n        }\n        \n        _trustStore = trustStore;\n        _crls = crls;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * validates all aliases inside of a given keystore\n     * \n     * @param keyStore\n     * @throws CertificateException\n     */\n    public void validate( KeyStore keyStore ) throws CertificateException\n    {\n        try\n        {\n            Enumeration<String> aliases = keyStore.aliases();\n            \n            for ( ; aliases.hasMoreElements(); )\n            {\n                String alias = aliases.nextElement();\n                \n                validate(keyStore,alias);\n            }\n            \n        }\n        catch ( KeyStoreException kse )\n        {\n            throw new CertificateException(\"error obtaining aliases\", kse);\n        }\n    }","id":66066,"modified_method":"/**\n     * validates all aliases inside of a given keystore\n     * \n     * @param keyStore\n     * @throws CertificateException\n     */\n    public void validate( KeyStore keyStore ) throws CertificateException\n    {\n        try\n        {\n            Enumeration<String> aliases = keyStore.aliases();\n            \n            for ( ; aliases.hasMoreElements(); )\n            {\n                String alias = aliases.nextElement();\n                \n                validate(keyStore,alias);\n            }\n            \n        }\n        catch ( KeyStoreException kse )\n        {\n            throw new CertificateException(\"Unable to retrieve aliases from keystore\", kse);\n        }\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void setMaxCertPathLength(int maxCertPathLength)\n    {\n        _maxCertPathLength = maxCertPathLength;\n    }","id":66067,"modified_method":"/**\n     * @param maxCertPathLength\n     *            maximum number of intermediate certificates in\n     *            the certification path (-1 for unlimited)\n     */\n    public void setMaxCertPathLength(int maxCertPathLength)\n    {\n        _maxCertPathLength = maxCertPathLength;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * validates a specific alias inside of the keystore being passed in\n     * \n     * @param keyStore\n     * @param keyAlias\n     * @return the keyAlias if valid\n     * @throws CertificateException\n     */\n    public String validate(KeyStore keyStore, String keyAlias) throws CertificateException\n    {\n        String result = null;\n\n        if (keyAlias != null)\n        {\n            try\n            {\n                validate(keyStore, keyStore.getCertificate(keyAlias));\n            }\n            catch (KeyStoreException ex)\n            {\n                Log.debug(ex);\n                throw new CertificateException(\"Unable to validate certificate for alias [\" +\n                                               keyAlias + \"]: \" + ex.getMessage());\n            }\n            result = keyAlias;            \n        }\n        \n        return result;\n    }","id":66068,"modified_method":"/**\n     * validates a specific alias inside of the keystore being passed in\n     * \n     * @param keyStore\n     * @param keyAlias\n     * @return the keyAlias if valid\n     * @throws CertificateException\n     */\n    public String validate(KeyStore keyStore, String keyAlias) throws CertificateException\n    {\n        String result = null;\n\n        if (keyAlias != null)\n        {\n            try\n            {\n                validate(keyStore, keyStore.getCertificate(keyAlias));\n            }\n            catch (KeyStoreException kse)\n            {\n                Log.debug(kse);\n                throw new CertificateException(\"Unable to validate certificate\" +\n                        \" for alias [\" + keyAlias + \"]: \" + kse.getMessage(), kse);\n            }\n            result = keyAlias;            \n        }\n        \n        return result;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int getMaxCertPathLength()\n    {\n        return _maxCertPathLength;\n    }","id":66069,"modified_method":"/**\n     * @return Maximum number of intermediate certificates in\n     * the certification path (-1 for unlimited)\n     */\n    public int getMaxCertPathLength()\n    {\n        return _maxCertPathLength;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @return Authentication for request\n     * @throws ServerAuthException\n     */\n    public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {\n        if (!mandatory)\n            return _deferred;\n        \n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        X509Certificate[] certs = (X509Certificate[]) request.getAttribute(\"javax.servlet.request.X509Certificate\");\n\n        try\n        {\n            // Need certificates.\n            if (certs != null && certs.length > 0)\n            {\n                for (X509Certificate cert: certs)\n                {\n                    if (cert==null)\n                        continue;\n                    Principal principal = cert.getSubjectDN();\n                    if (principal == null) principal = cert.getIssuerDN();\n                    final String username = principal == null ? \"clientcert\" : principal.getName();\n\n                    final char[] credential = B64Code.encode(cert.getSignature());\n\n                    UserIdentity user = _loginService.login(username,credential);\n                    if (user!=null)\n                    {\n                        renewSessionOnAuthentication(request,response);\n                        return new UserAuthentication(getAuthMethod(),user);\n                    }\n                }\n            }\n                \n            if (!_deferred.isDeferred(response))\n            {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                return Authentication.SEND_FAILURE;\n            }\n            \n            return Authentication.UNAUTHENTICATED;\n        }\n        catch (IOException e)\n        {\n            throw new ServerAuthException(e.getMessage());\n        }\n    }","id":66070,"modified_method":"/**\n     * @return Authentication for request\n     * @throws ServerAuthException\n     */\n    public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {\n        if (!mandatory)\n            return _deferred;\n        \n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        X509Certificate[] certs = (X509Certificate[]) request.getAttribute(\"javax.servlet.request.X509Certificate\");\n\n        try\n        {\n            // Need certificates.\n            if (certs != null && certs.length > 0)\n            {\n                \n                if (_validateCerts)\n                {\n                    KeyStore trustStore = CertificateUtils.getKeyStore(null,\n                            _trustStorePath, _trustStoreType, _trustStoreProvider,\n                            _trustStorePassword == null ? null :_trustStorePassword.toString());\n                    Collection<? extends CRL> crls = CertificateUtils.loadCRL(_crlPath);\n                    CertificateValidator validator = new CertificateValidator(trustStore, crls);\n                    validator.validate(certs);\n                }\n                \n                for (X509Certificate cert: certs)\n                {\n                    if (cert==null)\n                        continue;\n\n                    Principal principal = cert.getSubjectDN();\n                    if (principal == null) principal = cert.getIssuerDN();\n                    final String username = principal == null ? \"clientcert\" : principal.getName();\n\n                    final char[] credential = B64Code.encode(cert.getSignature());\n\n                    UserIdentity user = _loginService.login(username,credential);\n                    if (user!=null)\n                    {\n                        renewSessionOnAuthentication(request,response);\n                        return new UserAuthentication(getAuthMethod(),user);\n                    }\n                }\n            }\n                \n            if (!_deferred.isDeferred(response))\n            {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                return Authentication.SEND_FAILURE;\n            }\n            \n            return Authentication.UNAUTHENTICATED;\n        }\n        catch (Exception e)\n        {\n            throw new ServerAuthException(e.getMessage());\n        }\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected TrustManager[] getTrustManagers(KeyStore trustStore, Collection<? extends CRL> crls) throws Exception\n    {\n        TrustManager[] managers = null;\n        if (trustStore != null)\n        {\n            // Revocation checking is only supported for PKIX algorithm\n            if (_validateCerts && _trustManagerFactoryAlgorithm.equalsIgnoreCase(\"PKIX\"))\n            {\n                PKIXBuilderParameters pbParams = new PKIXBuilderParameters(trustStore,new X509CertSelector());\n\n                // Enable revocation checking\n                pbParams.setRevocationEnabled(true);\n\n                // Set maximum certification path length\n                pbParams.setMaxPathLength(_maxCertPathLength);\n\n                if (crls != null && !crls.isEmpty())\n                {\n                    pbParams.addCertStore(CertStore.getInstance(\"Collection\",new CollectionCertStoreParameters(crls)));\n                }\n\n                // Enable On-Line Certificate Status Protocol (OCSP) support\n                Security.setProperty(\"ocsp.enable\",\"true\");\n\n                // Enable Certificate Revocation List Distribution Points (CRLDP) support\n                System.setProperty(\"com.sun.security.enableCRLDP\",\"true\");\n\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_trustManagerFactoryAlgorithm);\n                trustManagerFactory.init(new CertPathTrustManagerParameters(pbParams));\n\n                managers = trustManagerFactory.getTrustManagers();\n            }\n            else\n            {\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_trustManagerFactoryAlgorithm);\n                trustManagerFactory.init(trustStore);\n\n                managers = trustManagerFactory.getTrustManagers();\n            }\n        }\n\n        return managers;\n    }","id":66071,"modified_method":"protected TrustManager[] getTrustManagers(KeyStore trustStore, Collection<? extends CRL> crls) throws Exception\n    {\n        TrustManager[] managers = null;\n        if (trustStore != null)\n        {\n            // Revocation checking is only supported for PKIX algorithm\n            if (_validateCerts && _trustManagerFactoryAlgorithm.equalsIgnoreCase(\"PKIX\"))\n            {\n                PKIXBuilderParameters pbParams = new PKIXBuilderParameters(trustStore,new X509CertSelector());\n\n                // Set maximum certification path length\n                pbParams.setMaxPathLength(_maxCertPathLength);\n\n                // Make sure revocation checking is enabled\n                pbParams.setRevocationEnabled(true);\n\n                if (crls != null && !crls.isEmpty())\n                {\n                    pbParams.addCertStore(CertStore.getInstance(\"Collection\",new CollectionCertStoreParameters(crls)));\n                }\n\n                if (_enableCRLDP)\n                {\n                    // Enable Certificate Revocation List Distribution Points (CRLDP) support\n                    System.setProperty(\"com.sun.security.enableCRLDP\",\"true\");\n                }\n\n                if (_enableOCSP)\n                {\n                    // Enable On-Line Certificate Status Protocol (OCSP) support\n                    Security.setProperty(\"ocsp.enable\",\"true\");\n                    \n                    if (_ocspResponderURL != null)\n                    {\n                        // Override location of OCSP Responder\n                        Security.setProperty(\"ocsp.responderURL\", _ocspResponderURL);\n                    }\n                }\n\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_trustManagerFactoryAlgorithm);\n                trustManagerFactory.init(new CertPathTrustManagerParameters(pbParams));\n\n                managers = trustManagerFactory.getTrustManagers();\n            }\n            else\n            {\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_trustManagerFactoryAlgorithm);\n                trustManagerFactory.init(trustStore);\n\n                managers = trustManagerFactory.getTrustManagers();\n            }\n        }\n\n        return managers;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param keystoreProvider\n     *            The provider of the key store\n     */\n    public void setKeyStoreProvider(String keystoreProvider)\n    {\n        checkStarted();\n        \n        _keyStoreProvider = keystoreProvider;\n    }","id":66072,"modified_method":"/**\n     * @param keyStoreProvider\n     *            The provider of the key store\n     */\n    public void setKeyStoreProvider(String keyStoreProvider)\n    {\n        checkStarted();\n        \n        _keyStoreProvider = keyStoreProvider;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Set the keyStoreInputStream.\n     * @param keystoreInputStream the InputStream to the KeyStore \n     */\n    public void setKeyStoreInputStream(InputStream keystoreInputStream)\n    {\n        checkStarted();\n        \n        _keyStoreInputStream = keystoreInputStream;\n    }","id":66073,"modified_method":"/** Set the keyStoreInputStream.\n     * @param keyStoreInputStream the InputStream to the KeyStore \n     */\n    public void setKeyStoreInputStream(InputStream keyStoreInputStream)\n    {\n        checkStarted();\n        \n        _keyStoreInputStream = keyStoreInputStream;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Construct an instance of SslContextFactory\n     * @param keystorePath default keystore location\n     */\n    public SslContextFactory(String keystorePath)\n    {\n        _keyStorePath = keystorePath;\n    }","id":66074,"modified_method":"/**\n     * Construct an instance of SslContextFactory\n     * @param keyStorePath default keystore location\n     */\n    public SslContextFactory(String keyStorePath)\n    {\n        _keyStorePath = keyStorePath;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param truststoreProvider\n     *            The provider of the trust store\n     */\n    public void setTrustStoreProvider(String truststoreProvider)\n    {\n        checkStarted();\n        \n        _trustStoreProvider = truststoreProvider;\n    }","id":66075,"modified_method":"/**\n     * @param trustStoreProvider\n     *            The provider of the trust store\n     */\n    public void setTrustStoreProvider(String trustStoreProvider)\n    {\n        checkStarted();\n        \n        _trustStoreProvider = trustStoreProvider;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param keystoreType\n     *            The type of the key store (default \"JKS\")\n     */\n    public void setKeyStoreType(String keystoreType)\n    {\n        checkStarted();\n        \n        _keyStoreType = keystoreType;\n    }","id":66076,"modified_method":"/**\n     * @param keyStoreType\n     *            The type of the key store (default \"JKS\")\n     */\n    public void setKeyStoreType(String keyStoreType)\n    {\n        checkStarted();\n        \n        _keyStoreType = keyStoreType;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param truststore\n     *            The file name or URL of the trust store location\n     */\n    public void setTrustStore(String truststore)\n    {\n        checkStarted();\n        \n        _trustStorePath = truststore;\n    }","id":66077,"modified_method":"/**\n     * @param trustStorePath\n     *            The file name or URL of the trust store location\n     */\n    public void setTrustStore(String trustStorePath)\n    {\n        checkStarted();\n        \n        _trustStorePath = trustStorePath;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param truststoreType\n     *            The type of the trust store (default \"JKS\")\n     */\n    public void setTrustStoreType(String truststoreType)\n    {\n        checkStarted();\n        \n        _trustStoreType = truststoreType;\n    }","id":66078,"modified_method":"/**\n     * @param trustStoreType\n     *            The type of the trust store (default \"JKS\")\n     */\n    public void setTrustStoreType(String trustStoreType)\n    {\n        checkStarted();\n        \n        _trustStoreType = trustStoreType;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Set the _trustStoreInputStream.\n     * @param truststoreInputStream the InputStream to the TrustStore\n     */\n    public void setTrustStoreInputStream(InputStream truststoreInputStream)\n    {\n        checkStarted();\n        \n        _trustStoreInputStream = truststoreInputStream;\n    }","id":66079,"modified_method":"/** Set the _trustStoreInputStream.\n     * @param trustStoreInputStream the InputStream to the TrustStore\n     */\n    public void setTrustStoreInputStream(InputStream trustStoreInputStream)\n    {\n        checkStarted();\n        \n        _trustStoreInputStream = trustStoreInputStream;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @throws Exception\n     */\n    protected void createSSLContext() throws Exception\n    {\n        // verify that keystore and truststore \n        // parameters are set up correctly  \n        checkConfig();\n        \n        KeyStore keyStore = getKeyStore(_keyStoreInputStream, _keyStorePath, _keyStoreType, \n                _keyStoreProvider, _keyStorePassword==null? null: _keyStorePassword.toString());\n        KeyStore trustStore = getKeyStore(_trustStoreInputStream, _trustStorePath, _trustStoreType, \n                _trustStoreProvider, _trustStorePassword==null? null: _trustStorePassword.toString());\n        Collection<? extends CRL> crls = loadCRL(_crlPath);\n\n        if (_validateCerts && keyStore != null)\n        {\n            if (_certAlias == null)\n            {\n                List<String> aliases = Collections.list(keyStore.aliases());\n                _certAlias = aliases.size() == 1 ? aliases.get(0) : null;\n            }\n    \n            Certificate cert = _certAlias == null?null:keyStore.getCertificate(_certAlias);\n            if (cert == null)\n            {\n                throw new Exception(\"No certificate found in the keystore\" + (_certAlias==null ? \"\":\" for alias \" + _certAlias));\n            }\n\n            CertificateValidator validator = new CertificateValidator(trustStore,crls);\n            validator.validate(keyStore, cert);\n        }\n\n        KeyManager[] keyManagers = getKeyManagers(keyStore);\n        TrustManager[] trustManagers = getTrustManagers(trustStore,crls);\n\n        SecureRandom secureRandom = _secureRandomAlgorithm == null?null:SecureRandom.getInstance(_secureRandomAlgorithm);\n        _context = _sslProvider == null?SSLContext.getInstance(_sslProtocol):SSLContext.getInstance(_sslProtocol,_sslProvider);\n        _context.init(keyManagers,trustManagers,secureRandom);\n    }","id":66080,"modified_method":"/**\n     * @throws Exception\n     */\n    protected void createSSLContext() throws Exception\n    {\n        // verify that keystore and truststore \n        // parameters are set up correctly  \n        checkConfig();\n        \n        KeyStore keyStore = CertificateUtils.getKeyStore(_keyStoreInputStream, _keyStorePath, _keyStoreType, \n                _keyStoreProvider, _keyStorePassword==null? null: _keyStorePassword.toString());\n        KeyStore trustStore = CertificateUtils.getKeyStore(_trustStoreInputStream, _trustStorePath, _trustStoreType, \n                _trustStoreProvider, _trustStorePassword==null? null: _trustStorePassword.toString());\n        Collection<? extends CRL> crls = CertificateUtils.loadCRL(_crlPath);\n\n        if (_validateCerts && keyStore != null)\n        {\n            if (_certAlias == null)\n            {\n                List<String> aliases = Collections.list(keyStore.aliases());\n                _certAlias = aliases.size() == 1 ? aliases.get(0) : null;\n            }\n    \n            Certificate cert = _certAlias == null?null:keyStore.getCertificate(_certAlias);\n            if (cert == null)\n            {\n                throw new Exception(\"No certificate found in the keystore\" + (_certAlias==null ? \"\":\" for alias \" + _certAlias));\n            }\n\n            CertificateValidator validator = new CertificateValidator(trustStore, crls);\n            validator.setMaxCertPathLength(_maxCertPathLength);\n            validator.setEnableCRLDP(_enableCRLDP);\n            validator.setEnableOCSP(_enableOCSP);\n            validator.setOcspResponderURL(_ocspResponderURL);\n            validator.validate(keyStore, cert);\n        }\n\n        KeyManager[] keyManagers = getKeyManagers(keyStore);\n        TrustManager[] trustManagers = getTrustManagers(trustStore,crls);\n\n        SecureRandom secureRandom = _secureRandomAlgorithm == null?null:SecureRandom.getInstance(_secureRandomAlgorithm);\n        _context = _sslProvider == null?SSLContext.getInstance(_sslProtocol):SSLContext.getInstance(_sslProtocol,_sslProvider);\n        _context.init(keyManagers,trustManagers,secureRandom);\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @return true if SSL certificate has to be validated\n     */\n    public boolean getValidateCerts()\n    {\n        return _validateCerts;\n    }","id":66081,"modified_method":"/**\n     * @return true if SSL certificate has to be validated\n     * @deprecated\n     */\n    @Deprecated\n    public boolean getValidateCerts()\n    {\n        return _validateCerts;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param keystore\n     *            The file or URL of the SSL Key store.\n     */\n    public void setKeyStore(String keystore)\n    {\n        checkStarted();\n        \n        _keyStorePath = keystore;\n    }","id":66082,"modified_method":"/**\n     * @param keyStorePath\n     *            The file or URL of the SSL Key store.\n     */\n    public void setKeyStore(String keyStorePath)\n    {\n        checkStarted();\n        \n        _keyStorePath = keyStorePath;\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void configureServer(Server server)\n        throws Exception\n    {\n        setProtocol(\"https\");\n\n        SslContextFactory srvFactory = new SslContextFactory();\n        srvFactory.setValidateCerts(true);\n        srvFactory.setKeyStore(_keypath);\n        srvFactory.setKeyStorePassword(_password);\n        srvFactory.setKeyManagerPassword(_password);\n        srvFactory.setTrustStore(_trustpath);\n        srvFactory.setTrustStorePassword(_password);\n        srvFactory.setCrlPath(_crlpath);\n\n        Constructor<? extends SslConnector> constructor = __klass.getConstructor(SslContextFactory.class);\n        SslConnector connector = constructor.newInstance(srvFactory);\n        connector.setMaxIdleTime(5000);\n        server.addConnector(connector);\n\n        Handler handler = new TestHandler(getBasePath());\n\n        ServletContextHandler root = new ServletContextHandler();\n        root.setContextPath(\"/\");\n        root.setResourceBase(getBasePath());\n        ServletHolder servletHolder = new ServletHolder( new DefaultServlet() );\n        servletHolder.setInitParameter( \"gzip\", \"true\" );\n        root.addServlet( servletHolder, \"/*\" );\n\n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{handler, root});\n        server.setHandler( handlers );\n    }","id":66083,"modified_method":"@Override\n    protected void configureServer(Server server)\n        throws Exception\n    {\n        setProtocol(\"https\");\n\n        SslContextFactory srvFactory = new SslContextFactory();\n        srvFactory.setValidateCerts(true);\n        srvFactory.setCrlPath(_crlpath);\n        srvFactory.setNeedClientAuth(true);\n\n        srvFactory.setKeyStore(_keypath);\n        srvFactory.setKeyStorePassword(_password);\n        srvFactory.setKeyManagerPassword(_password);\n        \n        srvFactory.setTrustStore(_trustpath);\n        srvFactory.setTrustStorePassword(_password);\n\n        Constructor<? extends SslConnector> constructor = __klass.getConstructor(SslContextFactory.class);\n        SslConnector connector = constructor.newInstance(srvFactory);\n        connector.setMaxIdleTime(5000);\n        server.addConnector(connector);\n\n        Handler handler = new TestHandler(getBasePath());\n\n        ServletContextHandler root = new ServletContextHandler();\n        root.setContextPath(\"/\");\n        root.setResourceBase(getBasePath());\n        ServletHolder servletHolder = new ServletHolder( new DefaultServlet() );\n        servletHolder.setInitParameter( \"gzip\", \"true\" );\n        root.addServlet( servletHolder, \"/*\" );\n\n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{handler, root});\n        server.setHandler( handlers );\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void configureClient(HttpClient client)\n        throws Exception\n    {\n        client.setConnectorType(__konnector);\n\n        SslContextFactory cf = client.getSslContextFactory();\n        cf.setTrustStore(_trustpath);\n        cf.setTrustStorePassword(_password);\n    }","id":66084,"modified_method":"@Override\n    protected void configureClient(HttpClient client)\n        throws Exception\n    {\n        client.setConnectorType(__konnector);\n\n        SslContextFactory cf = client.getSslContextFactory();\n        cf.setValidateCerts(true);\n        cf.setCrlPath(_crlpath);\n        \n        cf.setKeyStore(_clientpath);\n        cf.setKeyStorePassword(_password);\n        cf.setKeyManagerPassword(_password);\n        \n        cf.setTrustStore(_trustpath);\n        cf.setTrustStorePassword(_password);\n    }","commit_id":"626ef8271b89d8222f0b1b11b9b7c32db4d40f59","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Setup the SSL_CTX.\n     *\n     * @param kms Must contain a KeyManager of the type\n     *            {@code OpenSSLKeyManager}\n     * @param tms Must contain a TrustManager of the type\n     *            {@code X509TrustManager}\n     * @param sr Is not used for this implementation.\n     */\n    @Override\n    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {\n        if (initialized) {\n            log.warn(sm.getString(\"openssl.doubleInit\"));\n            return;\n        }\n        try {\n            boolean legacyRenegSupported = false;\n            try {\n                legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                if (legacyRenegSupported)\n                    if (sslHostConfig.getInsecureRenegotiation()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!legacyRenegSupported) {\n                // OpenSSL does not support unsafe legacy renegotiation.\n                log.warn(netSm.getString(\"endpoint.warn.noInsecureReneg\",\n                                      SSL.versionString()));\n            }\n            // Use server's preference order for ciphers (rather than\n            // client's)\n            boolean orderCiphersSupported = false;\n            try {\n                orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                if (orderCiphersSupported) {\n                    if (sslHostConfig.getHonorCipherOrder()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!orderCiphersSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noHonorCipherOrder\",\n                                      SSL.versionString()));\n            }\n\n            // Disable compression if requested\n            boolean disableCompressionSupported = false;\n            try {\n                disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);\n                if (disableCompressionSupported) {\n                    if (sslHostConfig.getDisableCompression()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableCompressionSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableCompression\",\n                                      SSL.versionString()));\n            }\n\n            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy\n            boolean disableSessionTicketsSupported = false;\n            try {\n                disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);\n                if (disableSessionTicketsSupported) {\n                    if (sslHostConfig.getDisableSessionTickets()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableSessionTicketsSupported) {\n                // OpenSSL is too old to support TLS Session Tickets.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableSessionTickets\",\n                                      SSL.versionString()));\n            }\n\n            // Set session cache size, if specified\n            if (sslHostConfig.getSessionCacheSize() > 0) {\n                SSLContext.setSessionCacheSize(ctx, sslHostConfig.getSessionCacheSize());\n            } else {\n                // Get the default session cache size using SSLContext.setSessionCacheSize()\n                long sessionCacheSize = SSLContext.setSessionCacheSize(ctx, 20480);\n                // Revert the session cache size to the default value.\n                SSLContext.setSessionCacheSize(ctx, sessionCacheSize);\n            }\n\n            // Set session timeout, if specified\n            if (sslHostConfig.getSessionTimeout() > 0) {\n                SSLContext.setSessionCacheTimeout(ctx, sslHostConfig.getSessionTimeout());\n            } else {\n                // Get the default session timeout using SSLContext.setSessionCacheTimeout()\n                long sessionTimeout = SSLContext.setSessionCacheTimeout(ctx, 300);\n                // Revert the session timeout to the default value.\n                SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);\n            }\n\n            // List the ciphers that the client is permitted to negotiate\n            String opensslCipherConfig = sslHostConfig.getCiphers();\n            this.jsseCipherNames = OpenSSLCipherConfigurationParser.parseExpression(opensslCipherConfig);\n            SSLContext.setCipherSuite(ctx, opensslCipherConfig);\n            // Load Server key and certificate\n            if (certificate.getCertificateFile() != null) {\n                // Set certificate\n                SSLContext.setCertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),\n                        certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);\n                // Set certificate chain file\n                SSLContext.setCertificateChainFile(ctx,\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()), false);\n                // Support Client Certificates\n                SSLContext.setCACertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));\n                // Set revocation\n                SSLContext.setCARevocation(ctx,\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListFile()),\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListPath()));\n            } else {\n                X509KeyManager keyManager = chooseKeyManager(kms);\n                String alias = certificate.getCertificateKeyAlias();\n                X509Certificate certificate = keyManager.getCertificateChain(alias)[0];\n                PrivateKey key = keyManager.getPrivateKey(alias);\n                StringBuilder sb = new StringBuilder(BEGIN_KEY);\n                sb.append(Base64.getMimeEncoder(64, new byte[] {'\\n'}).encodeToString(key.getEncoded()));\n                sb.append(END_KEY);\n                SSLContext.setCertificateRaw(ctx, certificate.getEncoded(), sb.toString().getBytes(StandardCharsets.US_ASCII), SSL.SSL_AIDX_RSA);\n            }\n            // Client certificate verification\n            int value = 0;\n            switch (sslHostConfig.getCertificateVerification()) {\n            case NONE:\n                value = SSL.SSL_CVERIFY_NONE;\n                break;\n            case OPTIONAL:\n                value = SSL.SSL_CVERIFY_OPTIONAL;\n                break;\n            case OPTIONAL_NO_CA:\n                value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;\n                break;\n            case REQUIRED:\n                value = SSL.SSL_CVERIFY_REQUIRE;\n                break;\n            }\n            SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());\n\n            if (tms != null) {\n                final X509TrustManager manager = chooseTrustManager(tms);\n                SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {\n                    @Override\n                    public boolean verify(long ssl, byte[][] chain, String auth) {\n                        X509Certificate[] peerCerts = certificates(chain);\n                        try {\n                            manager.checkClientTrusted(peerCerts, auth);\n                            return true;\n                        } catch (Exception e) {\n                            log.debug(sm.getString(\"openssl.certificateVerificationFailed\"), e);\n                        }\n                        return false;\n                    }\n                });\n            }\n\n            if (negotiableProtocols != null && negotiableProtocols.size() > 0) {\n                ArrayList<String> protocols = new ArrayList<>();\n                protocols.addAll(negotiableProtocols);\n                protocols.add(\"http/1.1\");\n                String[] protocolsArray = protocols.toArray(new String[0]);\n                SSLContext.setAlpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n                SSLContext.setNpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n            }\n\n            sessionContext = new OpenSSLSessionContext(ctx);\n            sslHostConfig.setOpenSslContext(Long.valueOf(ctx));\n            initialized = true;\n        } catch (Exception e) {\n            log.warn(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n            destroy();\n        }\n    }","id":66085,"modified_method":"/**\n     * Setup the SSL_CTX.\n     *\n     * @param kms Must contain a KeyManager of the type\n     *            {@code OpenSSLKeyManager}\n     * @param tms Must contain a TrustManager of the type\n     *            {@code X509TrustManager}\n     * @param sr Is not used for this implementation.\n     */\n    @Override\n    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {\n        if (initialized) {\n            log.warn(sm.getString(\"openssl.doubleInit\"));\n            return;\n        }\n        try {\n            boolean legacyRenegSupported = false;\n            try {\n                legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                if (legacyRenegSupported)\n                    if (sslHostConfig.getInsecureRenegotiation()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!legacyRenegSupported) {\n                // OpenSSL does not support unsafe legacy renegotiation.\n                log.warn(netSm.getString(\"endpoint.warn.noInsecureReneg\",\n                                      SSL.versionString()));\n            }\n            // Use server's preference order for ciphers (rather than\n            // client's)\n            boolean orderCiphersSupported = false;\n            try {\n                orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                if (orderCiphersSupported) {\n                    if (sslHostConfig.getHonorCipherOrder()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!orderCiphersSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noHonorCipherOrder\",\n                                      SSL.versionString()));\n            }\n\n            // Disable compression if requested\n            boolean disableCompressionSupported = false;\n            try {\n                disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);\n                if (disableCompressionSupported) {\n                    if (sslHostConfig.getDisableCompression()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableCompressionSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableCompression\",\n                                      SSL.versionString()));\n            }\n\n            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy\n            boolean disableSessionTicketsSupported = false;\n            try {\n                disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);\n                if (disableSessionTicketsSupported) {\n                    if (sslHostConfig.getDisableSessionTickets()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableSessionTicketsSupported) {\n                // OpenSSL is too old to support TLS Session Tickets.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableSessionTickets\",\n                                      SSL.versionString()));\n            }\n\n            // Set session cache size, if specified\n            if (sslHostConfig.getSessionCacheSize() > 0) {\n                SSLContext.setSessionCacheSize(ctx, sslHostConfig.getSessionCacheSize());\n            } else {\n                // Get the default session cache size using SSLContext.setSessionCacheSize()\n                long sessionCacheSize = SSLContext.setSessionCacheSize(ctx, 20480);\n                // Revert the session cache size to the default value.\n                SSLContext.setSessionCacheSize(ctx, sessionCacheSize);\n            }\n\n            // Set session timeout, if specified\n            if (sslHostConfig.getSessionTimeout() > 0) {\n                SSLContext.setSessionCacheTimeout(ctx, sslHostConfig.getSessionTimeout());\n            } else {\n                // Get the default session timeout using SSLContext.setSessionCacheTimeout()\n                long sessionTimeout = SSLContext.setSessionCacheTimeout(ctx, 300);\n                // Revert the session timeout to the default value.\n                SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);\n            }\n\n            // List the ciphers that the client is permitted to negotiate\n            String opensslCipherConfig = sslHostConfig.getCiphers();\n            this.jsseCipherNames = OpenSSLCipherConfigurationParser.parseExpression(opensslCipherConfig);\n            SSLContext.setCipherSuite(ctx, opensslCipherConfig);\n            // Load Server key and certificate\n            if (certificate.getCertificateFile() != null) {\n                // Set certificate\n                SSLContext.setCertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),\n                        certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);\n                // Set certificate chain file\n                SSLContext.setCertificateChainFile(ctx,\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()), false);\n                // Support Client Certificates\n                SSLContext.setCACertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));\n                // Set revocation\n                SSLContext.setCARevocation(ctx,\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListFile()),\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListPath()));\n            } else {\n                X509KeyManager keyManager = chooseKeyManager(kms);\n                String alias = certificate.getCertificateKeyAlias();\n                X509Certificate[] chain = keyManager.getCertificateChain(alias);\n                PrivateKey key = keyManager.getPrivateKey(alias);\n                StringBuilder sb = new StringBuilder(BEGIN_KEY);\n                sb.append(Base64.getMimeEncoder(64, new byte[] {'\\n'}).encodeToString(key.getEncoded()));\n                sb.append(END_KEY);\n                SSLContext.setCertificateRaw(ctx, chain[0].getEncoded(), sb.toString().getBytes(StandardCharsets.US_ASCII), SSL.SSL_AIDX_RSA);\n                /*\n                 * Uncomment the code block below once there has been a tc-native\n                 * release with this method and the minimum tc-native version\n                 * has been incremented.\n                for (int i = 1; i < chain.length; i++) {\n                    SSLContext.addChainCertificateRaw(ctx, chain[i].getEncoded());\n                }\n                */\n            }\n            // Client certificate verification\n            int value = 0;\n            switch (sslHostConfig.getCertificateVerification()) {\n            case NONE:\n                value = SSL.SSL_CVERIFY_NONE;\n                break;\n            case OPTIONAL:\n                value = SSL.SSL_CVERIFY_OPTIONAL;\n                break;\n            case OPTIONAL_NO_CA:\n                value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;\n                break;\n            case REQUIRED:\n                value = SSL.SSL_CVERIFY_REQUIRE;\n                break;\n            }\n            SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());\n\n            if (tms != null) {\n                final X509TrustManager manager = chooseTrustManager(tms);\n                SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {\n                    @Override\n                    public boolean verify(long ssl, byte[][] chain, String auth) {\n                        X509Certificate[] peerCerts = certificates(chain);\n                        try {\n                            manager.checkClientTrusted(peerCerts, auth);\n                            return true;\n                        } catch (Exception e) {\n                            log.debug(sm.getString(\"openssl.certificateVerificationFailed\"), e);\n                        }\n                        return false;\n                    }\n                });\n            }\n\n            if (negotiableProtocols != null && negotiableProtocols.size() > 0) {\n                ArrayList<String> protocols = new ArrayList<>();\n                protocols.addAll(negotiableProtocols);\n                protocols.add(\"http/1.1\");\n                String[] protocolsArray = protocols.toArray(new String[0]);\n                SSLContext.setAlpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n                SSLContext.setNpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n            }\n\n            sessionContext = new OpenSSLSessionContext(ctx);\n            sslHostConfig.setOpenSslContext(Long.valueOf(ctx));\n            initialized = true;\n        } catch (Exception e) {\n            log.warn(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n            destroy();\n        }\n    }","commit_id":"c76ddd7dfcfd83e4f32236399e677307903f099a","url":"https://github.com/apache/tomcat"},{"original_method":"public X509Certificate[] getCertificateChain(String alias) {\n      return keyManager.getCertificateChain(alias);\n    }","id":66086,"modified_method":"public X509Certificate[] getCertificateChain(String alias) {\n        X509Certificate[] certArray = keyManager.getCertificateChain(alias);\n        if (Debug.verboseOn()) Debug.logVerbose(\"getCertificateChain for alias [\" + alias + \"] got \" + certArray.length + \" results\", module);\n        return certArray;\n    }","commit_id":"142916131249fe34326e5d2b9e441a1144741cab","url":"https://github.com/apache/ofbiz"},{"original_method":"public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n      for (int i = 0; i < keyType.length; i++) {\n          String[] aliases = keyManager.getClientAliases(keyType[i], null); // ignoring the issuers \n          if (aliases != null && aliases.length > 0) {\n              for (int x = 0; x < aliases.length; x++) {\n                  if (alias.equals(aliases[i])) {\n                      return alias;\n                  }\n              }\n          }\n      }\n      return null;\n    }","id":66087,"modified_method":"public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n        for (int i = 0; i < keyType.length; i++) {\n            String[] aliases = keyManager.getClientAliases(keyType[i], null); // ignoring the issuers \n            if (aliases != null && aliases.length > 0) {\n                for (int x = 0; x < aliases.length; x++) {\n                    if (this.alias.equals(aliases[i])) {\n                        if (Debug.verboseOn()) Debug.logVerbose(\"chooseClientAlias for keyType [\" + keyType[i] + \"] got alias \" + this.alias, module);\n                        //Debug.logInfo(new Exception(), \"Location where chooseClientAlias is called\", module);\n                        return this.alias;\n                    }\n                }\n            }\n        }\n        return null;\n    }","commit_id":"142916131249fe34326e5d2b9e441a1144741cab","url":"https://github.com/apache/ofbiz"},{"original_method":"public PrivateKey getPrivateKey(String alias) {\n      return keyManager.getPrivateKey(alias);\n    }","id":66088,"modified_method":"public PrivateKey getPrivateKey(String alias) {\n        PrivateKey pk = keyManager.getPrivateKey(alias);\n        if (Debug.verboseOn()) Debug.logVerbose(\"getPrivateKey for alias [\" + alias + \"] got \" + (pk == null ? \"[Not Found!]\" : \"[alg:\" + pk.getAlgorithm() + \";format:\" + pk.getFormat() + \"]\"), module);\n        //Debug.logInfo(new Exception(), \"Location where getPrivateKey is called\", module);\n        return pk;\n    }","commit_id":"142916131249fe34326e5d2b9e441a1144741cab","url":"https://github.com/apache/ofbiz"},{"original_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection\", module);\n            }\n\n            // set the content type\n            if (contentType != null) {\n                con.setRequestProperty(\"Content-type\", contentType);\n            }\n\n            // connection settings\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (keepAlive) {\n                con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                if (contentType == null) {\n                    con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                }\n                con.setDoInput(true);\n            }\n            \n            // if there is basicAuth info set the request property for it\n            if (basicAuthUsername != null) {\n            \tString basicAuthString = \"Basic \" + Base64.base64Encode(basicAuthUsername + \":\" + (basicAuthPassword == null ? \"\" : basicAuthPassword));\n                con.setRequestProperty(\"Authorization\", basicAuthString);\n                if (Debug.verboseOn() || debug) Debug.log(\"Header - Authorization: \" + basicAuthString, module);\n            }\n            \n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header - \" + headerName + \": \" + headerValue, module);\n                }\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                if (arguments != null) {\n                    out.writeBytes(arguments);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n                }\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","id":66089,"modified_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection, more specifically: \" + con.getClass().getName(), module);\n            }\n\n            // set the content type\n            if (contentType != null) {\n                con.setRequestProperty(\"Content-type\", contentType);\n            }\n\n            // connection settings\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (keepAlive) {\n                con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                if (contentType == null) {\n                    con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                }\n                con.setDoInput(true);\n            }\n            \n            // if there is basicAuth info set the request property for it\n            if (basicAuthUsername != null) {\n            \tString basicAuthString = \"Basic \" + Base64.base64Encode(basicAuthUsername + \":\" + (basicAuthPassword == null ? \"\" : basicAuthPassword));\n                con.setRequestProperty(\"Authorization\", basicAuthString);\n                if (Debug.verboseOn() || debug) Debug.log(\"Header - Authorization: \" + basicAuthString, module);\n            }\n            \n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header - \" + headerName + \": \" + headerValue, module);\n                }\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                if (arguments != null) {\n                    out.writeBytes(arguments);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n                }\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","commit_id":"142916131249fe34326e5d2b9e441a1144741cab","url":"https://github.com/apache/ofbiz"},{"original_method":"public static KeyManager[] getKeyManagers(String alias) throws IOException, GeneralSecurityException, GenericConfigException {\n        Iterator i = ComponentConfig.getAllKeystoreInfos().iterator();\n        List keyMgrs = FastList.newInstance();\n        \n        while (i.hasNext()) {\n            ComponentConfig.KeystoreInfo ksi = (ComponentConfig.KeystoreInfo) i.next();\n            if (ksi.isCertStore()) {\n                KeyStore ks = ksi.getKeyStore();\n                if (ks != null) {\n                    keyMgrs.addAll(Arrays.asList(getKeyManagers(ks, ksi.getPassword(), alias)));\n                } else {\n                    throw new IOException(\"Unable to load keystore: \" + ksi.createResourceHandler().getFullLocation());\n                }\n            }\n        }\n\n        return (KeyManager[]) keyMgrs.toArray(new KeyManager[keyMgrs.size()]);\n    }","id":66090,"modified_method":"public static KeyManager[] getKeyManagers(String alias) throws IOException, GeneralSecurityException, GenericConfigException {\n        Iterator i = ComponentConfig.getAllKeystoreInfos().iterator();\n        List keyMgrs = FastList.newInstance();\n        \n        while (i.hasNext()) {\n            ComponentConfig.KeystoreInfo ksi = (ComponentConfig.KeystoreInfo) i.next();\n            if (ksi.isCertStore()) {\n                KeyStore ks = ksi.getKeyStore();\n                if (ks != null) {\n                    List newKeyManagers = Arrays.asList(getKeyManagers(ks, ksi.getPassword(), alias));\n                    keyMgrs.addAll(newKeyManagers);\n                    if (Debug.verboseOn()) Debug.logVerbose(\"Loaded another cert store, adding [\" + (newKeyManagers == null ? \"0\" : newKeyManagers.size()) + \"] KeyManagers for alias [\" + alias + \"] and keystore: \" + ksi.createResourceHandler().getFullLocation(), module);\n                } else {\n                    throw new IOException(\"Unable to load keystore: \" + ksi.createResourceHandler().getFullLocation());\n                }\n            }\n        }\n\n        return (KeyManager[]) keyMgrs.toArray(new KeyManager[keyMgrs.size()]);\n    }","commit_id":"142916131249fe34326e5d2b9e441a1144741cab","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n\t * Calculate route between start.segmentEnd and end.segmentStart (using A* algorithm)\n\t * return list of segments\n\t */\n\tpublic List<RouteSegmentResult> searchRoute(final RoutingContext ctx, RouteSegment start, RouteSegment end) throws IOException {\n\t\t\n\t\t// measure time\n\t\tctx.timeToLoad = 0;\n\t\tctx.visitedSegments = 0;\n\t\tboolean reverseWaySearch = false;\n\t\tlong startNanoTime = System.nanoTime();\n\n\t\t// Initializing priority queue to visit way segments \n\t\tComparator<RouteSegment> segmentsComparator = new Comparator<RouteSegment>(){\n\t\t\t@Override\n\t\t\tpublic int compare(RouteSegment o1, RouteSegment o2) {\n\t\t\t\treturn ctx.roadPriorityComparator(o1.distanceFromStart, o1.distanceToEnd, o2.distanceFromStart, o2.distanceToEnd);\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<RouteSegment> graphDirectSegments = new PriorityQueue<RouteSegment>(50, segmentsComparator);\n\t\tPriorityQueue<RouteSegment> graphReverseSegments = new PriorityQueue<RouteSegment>(50, segmentsComparator);\n\t\t\n\t\t// Set to not visit one segment twice (stores road.id << X + segmentStart)\n\t\tTLongHashSet visitedDirectSegments = new TLongHashSet();\n\t\tTLongHashSet visitedOppositeSegments = new TLongHashSet();\n\t\t\n\t\t\n//\t\tif(reverseWaySearch){\n//\t\t\tRouteSegment t = start;\n//\t\t\tstart = end;\n//\t\t\tend = t;\n//\t\t}\n\t\t\n\t\tint targetEndX = end.road.getPoint31XTile(end.segmentStart);\n\t\tint targetEndY = end.road.getPoint31YTile(end.segmentStart);\n\t\tint startX = start.road.getPoint31XTile(start.segmentStart);\n\t\tint startY = start.road.getPoint31YTile(start.segmentStart);\n\t\t// for start : f(start) = g(start) + h(start) = 0 + h(start) = h(start)\n\t\tstart.distanceToEnd = squareRootDist(startX, startY, targetEndX, targetEndY) / ctx.router.getMaxDefaultSpeed();\n\t\tend.distanceToEnd = start.distanceToEnd;\n\t\t\n\t\t// because first point of the start is not visited do the same as in cycle but only for one point\n\t\t// it matters when start point is intersection of different roads\n\t\t// add start segment to priority queue\n\t\tvisitAllStartSegments(ctx, start, graphDirectSegments, visitedDirectSegments, startX, startY);\n\t\tvisitAllStartSegments(ctx, end, graphReverseSegments, visitedOppositeSegments, targetEndX, targetEndY);\n\t\t\n\t\t// final segment before end\n\t\tRouteSegment finalRoute = null;\n\t\t\n\t\t// Extract & analyze segment with min(f(x)) from queue while final segment is not found \n\t\twhile(!graphDirectSegments.isEmpty() && finalRoute == null){\n\t\t\tRouteSegment segment = graphDirectSegments.poll();\n\t\t\t\n\t\t\t\n\t\t\tctx.visitedSegments ++;\n\t\t\t// for debug purposes\n\t\t\tif (ctx.visitor != null) {\n\t\t\t\tctx.visitor.visitSegment(segment);\n\t\t\t}\n\t\t\t\n\t\t\tfinalRoute = processRouteSegment(ctx, end, reverseWaySearch, graphDirectSegments, visitedDirectSegments, targetEndX, targetEndY,\n\t\t\t\t\tsegment, visitedOppositeSegments);\n\t\t}\n\t\t\n\t\t\n\t\t// 4. Route is found : collect all segments and prepare result\n\t\treturn prepareResult(ctx, start, end, startNanoTime, finalRoute, !reverseWaySearch);\n\t\t\n\t}","id":66091,"modified_method":"/**\n\t * Calculate route between start.segmentEnd and end.segmentStart (using A* algorithm)\n\t * return list of segments\n\t */\n\tpublic List<RouteSegmentResult> searchRoute(final RoutingContext ctx, RouteSegment start, RouteSegment end) throws IOException {\n\t\t\n\t\t// measure time\n\t\tctx.timeToLoad = 0;\n\t\tctx.visitedSegments = 0;\n\n\t\tlong startNanoTime = System.nanoTime();\n\n\t\t// Initializing priority queue to visit way segments \n\t\tComparator<RouteSegment> segmentsComparator = new Comparator<RouteSegment>(){\n\t\t\t@Override\n\t\t\tpublic int compare(RouteSegment o1, RouteSegment o2) {\n\t\t\t\treturn ctx.roadPriorityComparator(o1.distanceFromStart, o1.distanceToEnd, o2.distanceFromStart, o2.distanceToEnd);\n\t\t\t}\n\t\t};\n\t\t\n\t\tComparator<RouteSegment> nonHeuristicSegmentsComparator = new Comparator<RouteSegment>(){\n\t\t\t@Override\n\t\t\tpublic int compare(RouteSegment o1, RouteSegment o2) {\n\t\t\t\treturn roadPriorityComparator(o1.distanceFromStart, o1.distanceToEnd, o2.distanceFromStart, o2.distanceToEnd, 1);\n\t\t\t}\n\t\t};\n\t\t\n\t\tPriorityQueue<RouteSegment> graphDirectSegments = new PriorityQueue<RouteSegment>(50, segmentsComparator);\n\t\tPriorityQueue<RouteSegment> graphReverseSegments = new PriorityQueue<RouteSegment>(50, segmentsComparator);\n\t\t\n\t\t// Set to not visit one segment twice (stores road.id << X + segmentStart)\n\t\tTLongObjectHashMap<RouteSegment> visitedDirectSegments = new TLongObjectHashMap<RouteSegment>();\n\t\tTLongObjectHashMap<RouteSegment> visitedOppositeSegments = new TLongObjectHashMap<RouteSegment>();\n\t\t\n\t\t\n//\t\tif(reverseWaySearch){\n//\t\t\tRouteSegment t = start;\n//\t\t\tstart = end;\n//\t\t\tend = t;\n//\t\t}\n\t\t\n\t\tint targetEndX = end.road.getPoint31XTile(end.segmentStart);\n\t\tint targetEndY = end.road.getPoint31YTile(end.segmentStart);\n\t\tint startX = start.road.getPoint31XTile(start.segmentStart);\n\t\tint startY = start.road.getPoint31YTile(start.segmentStart);\n\t\t// for start : f(start) = g(start) + h(start) = 0 + h(start) = h(start)\n\t\tstart.distanceToEnd = squareRootDist(startX, startY, targetEndX, targetEndY) / ctx.router.getMaxDefaultSpeed();\n\t\tend.distanceToEnd = start.distanceToEnd;\n\t\t\n\t\t// because first point of the start is not visited do the same as in cycle but only for one point\n\t\t// it matters when start point is intersection of different roads\n\t\t// add start segment to priority queue\n\t\tvisitAllStartSegments(ctx, start, graphDirectSegments, visitedDirectSegments, startX, startY);\n\t\tvisitAllStartSegments(ctx, end, graphReverseSegments, visitedOppositeSegments, targetEndX, targetEndY);\n\t\t\n\t\t// final segment before end\n\t\tRouteSegment finalDirectRoute = null;\n\t\tRouteSegment finalReverseRoute = null;\n\t\t\n\t\t// Extract & analyze segment with min(f(x)) from queue while final segment is not found\n\t\tboolean inverse = false;\n\t\tPriorityQueue<RouteSegment>  graphSegments = inverse ? graphReverseSegments : graphDirectSegments;\n\t\twhile(!graphSegments.isEmpty()){\n\t\t\tRouteSegment segment = graphSegments.poll();\n\t\t\t\n\t\t\t\n\t\t\tctx.visitedSegments ++;\n\t\t\t// for debug purposes\n\t\t\tif (ctx.visitor != null) {\n\t\t\t\tctx.visitor.visitSegment(segment);\n\t\t\t}\n\t\t\tif (!inverse) {\n\t\t\t\tfinalDirectRoute = processRouteSegment(ctx, end, false, graphDirectSegments, visitedDirectSegments, targetEndX,\n\t\t\t\t\t\ttargetEndY, segment, visitedOppositeSegments);\n\t\t\t\tif (finalDirectRoute != null) {\n\t\t\t\t\tlong nt = (finalDirectRoute.road.getId() << 8l) + finalDirectRoute.segmentEnd;\n\t\t\t\t\tfinalReverseRoute = visitedOppositeSegments.get(nt);\n\t\t\t\t\tif(finalReverseRoute != null){\n\t\t\t\t\t\tfinalReverseRoute.segmentEnd = finalDirectRoute.segmentEnd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfinalReverseRoute = processRouteSegment(ctx, start, true, graphReverseSegments, visitedOppositeSegments, startX,\n\t\t\t\t\t\tstartY, segment, visitedDirectSegments);\n\t\t\t\tif (finalReverseRoute != null) {\n\t\t\t\t\tlong nt = (finalReverseRoute.road.getId() << 8l) + finalReverseRoute.segmentEnd;\n\t\t\t\t\tfinalDirectRoute = visitedDirectSegments.get(nt);\n\t\t\t\t\tif(finalDirectRoute != null){\n\t\t\t\t\t\tfinalDirectRoute.segmentEnd = finalReverseRoute.segmentEnd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(graphReverseSegments.isEmpty() || graphDirectSegments.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinverse = nonHeuristicSegmentsComparator.compare(graphDirectSegments.peek(), graphReverseSegments.peek()) > 0;\n//\t\t\tinverse = !inverse;\n\t\t\tgraphSegments = inverse ? graphReverseSegments : graphDirectSegments;\n\t\t}\n\t\t\n\t\t\n\t\t// 4. Route is found : collect all segments and prepare result\n\t\treturn prepareResult(ctx, start, end, startNanoTime, finalDirectRoute, finalReverseRoute);\n\t\t\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private List<RouteSegmentResult> prepareResult(RoutingContext ctx, RouteSegment start, RouteSegment end, long startNanoTime,\n\t\t\tRouteSegment finalRoute, boolean reverseResult) {\n\t\tList<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();\n\t\t// Try to define direction of last movement and reverse start and end point for end if needed\n\t\tint parentSegmentEnd = 0;\n\t\tRouteSegment segment = finalRoute;\n\t\tif(finalRoute != null){\n\t\t\tif(finalRoute.getRoad().getId() == end.getRoad().getId()){\n\t\t\t\tparentSegmentEnd = finalRoute.segmentStart <= end.segmentStart ? end.segmentEnd : end.segmentStart;\n\t\t\t} else {\n\t\t\t\tend.parentRoute = finalRoute;\n\t\t\t\tend.parentSegmentEnd = finalRoute.segmentEnd;\n\t\t\t\tparentSegmentEnd = end.segmentEnd;\n\t\t\t\tsegment = end;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tSystem.out.println(\"ROUTE : \");\n\t\t\tSystem.out.println(\"Start lat=\" + MapUtils.get31LatitudeY(start.road.getPoint31YTile(start.segmentEnd)) + \" lon=\"\n\t\t\t\t\t+ MapUtils.get31LongitudeX(start.road.getPoint31XTile(start.segmentEnd)));\n\t\t\tSystem.out.println(\"END lat=\" + MapUtils.get31LatitudeY(end.road.getPoint31YTile(end.segmentStart)) + \" lon=\"\n\t\t\t\t\t+ MapUtils.get31LongitudeX(end.road.getPoint31XTile(end.segmentStart)));\n\t\t}\n\t\t\n\t\twhile(segment != null){\n\t\t\tRouteSegmentResult res = new RouteSegmentResult();\n\t\t\tres.object = segment.road;\n\t\t\tres.endPointIndex = parentSegmentEnd;\n\t\t\tres.startPointIndex = segment.segmentStart;\n\t\t\tparentSegmentEnd = segment.parentSegmentEnd;\n\t\t\t\n\t\t\tsegment = segment.parentRoute;\n\t\t\t// reverse start and end point for start if needed\n\t\t\tif(segment == null && res.startPointIndex >= res.endPointIndex){\n\t\t\t\tres.startPointIndex = start.segmentEnd;\n\t\t\t}\n\t\t\t// do not add segments consists from 1 point\n\t\t\tif(res.startPointIndex != res.endPointIndex) {\n\t\t\t\tresult.add(res);\n\t\t\t}\n\t\t\tres.startPoint = convertPoint(res.object, res.startPointIndex);\n\t\t\tres.endPoint = convertPoint(res.object, res.endPointIndex);\n\t\t}\n\t\t\n\t\t\n\t\tif(reverseResult){\n\t\t\tCollections.reverse(result);\n\t\t}\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tfor (RouteSegmentResult res : result) {\n\t\t\t\tSystem.out.println(\"id=\" + (res.object.getId() >> 1) + \" start=\" + res.startPointIndex + \" end=\" + res.endPointIndex);\n\t\t\t\tSystem.out.println(\"Name :\" + res.object.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.timeToCalculate = (System.nanoTime() - startNanoTime);\n\t\tlog.info(\"Time to calculate : \" + ctx.timeToCalculate / 1e6 +\", time to load : \" + ctx.timeToLoad / 1e6\t + \", loaded tiles : \" + ctx.loadedTiles.size() + \n\t\t\t\t\", visited segments \" + ctx.visitedSegments );\n\t\treturn result;\n\t}","id":66092,"modified_method":"private List<RouteSegmentResult> prepareResult(RoutingContext ctx, RouteSegment start, RouteSegment end, long startNanoTime,\n\t\t\tRouteSegment finalDirectRoute, RouteSegment finalReverseRoute) {\n\t\tList<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();\n\t\t\t\t\n\t\t\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tSystem.out.println(\"ROUTE : \");\n\t\t\tSystem.out.println(\"Start lat=\" + MapUtils.get31LatitudeY(start.road.getPoint31YTile(start.segmentEnd)) + \" lon=\"\n\t\t\t\t\t+ MapUtils.get31LongitudeX(start.road.getPoint31XTile(start.segmentEnd)));\n\t\t\tSystem.out.println(\"END lat=\" + MapUtils.get31LatitudeY(end.road.getPoint31YTile(end.segmentStart)) + \" lon=\"\n\t\t\t\t\t+ MapUtils.get31LongitudeX(end.road.getPoint31XTile(end.segmentStart)));\n\t\t}\n\t\t\n\t\t\n\t\tRouteSegment segment = finalReverseRoute;\n\t\tint parentSegmentStart = segment == null ? 0 : segment.segmentEnd; \n\t\twhile(segment != null){\n\t\t\tRouteSegmentResult res = new RouteSegmentResult();\n\t\t\tres.object = segment.road;\n\t\t\tres.endPointIndex = segment.segmentStart;\n\t\t\tres.startPointIndex = parentSegmentStart;\n\t\t\tparentSegmentStart = segment.parentSegmentEnd;\n\t\t\tsegment = segment.parentRoute;\n\t\t\t// reverse start and end point for start if needed\n\t\t\t// rely that point.segmentStart <= point.segmentEnd for end, start\n\t\t\tif(segment == null && res.startPointIndex <= res.endPointIndex){\n\t\t\t\tres.endPointIndex = end.segmentEnd;\n\t\t\t}\n\t\t\t// do not add segments consists from 1 point\n\t\t\tif(res.startPointIndex != res.endPointIndex) {\n\t\t\t\tresult.add(res);\n\t\t\t}\n\t\t\tres.startPoint = convertPoint(res.object, res.startPointIndex);\n\t\t\tres.endPoint = convertPoint(res.object, res.endPointIndex);\n\t\t}\n\t\tCollections.reverse(result);\n\t\t\n\t\tsegment = finalDirectRoute;\n\t\tint parentSegmentEnd = segment == null ? 0 : segment.segmentEnd;\n\t\twhile(segment != null){\n\t\t\tRouteSegmentResult res = new RouteSegmentResult();\n\t\t\tres.object = segment.road;\n\t\t\tres.endPointIndex = parentSegmentEnd;\n\t\t\tres.startPointIndex = segment.segmentStart;\n\t\t\tparentSegmentEnd = segment.parentSegmentEnd;\n\t\t\t\n\t\t\tsegment = segment.parentRoute;\n\t\t\t// reverse start and end point for start if needed\n\t\t\t// rely that point.segmentStart <= point.segmentEnd for end, start\n\t\t\tif(segment == null && res.startPointIndex >= res.endPointIndex){\n\t\t\t\tres.startPointIndex = start.segmentEnd;\n\t\t\t}\n\t\t\t// do not add segments consists from 1 point\n\t\t\tif(res.startPointIndex != res.endPointIndex) {\n\t\t\t\tresult.add(res);\n\t\t\t}\n\t\t\tres.startPoint = convertPoint(res.object, res.startPointIndex);\n\t\t\tres.endPoint = convertPoint(res.object, res.endPointIndex);\n\t\t}\n\t\tCollections.reverse(result);\n\t\t\n\t\t\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tfor (RouteSegmentResult res : result) {\n\t\t\t\t// (res.object.getId() >> 1)\n\t\t\t\tSystem.out.println(\"id=\" + (res.object.getId() >> 3) + \" start=\" + res.startPointIndex + \" end=\" + res.endPointIndex);\n\t\t\t\tSystem.out.println(\"Name :\" + res.object.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.timeToCalculate = (System.nanoTime() - startNanoTime);\n\t\tlog.info(\"Time to calculate : \" + ctx.timeToCalculate / 1e6 +\", time to load : \" + ctx.timeToLoad / 1e6\t + \", loaded tiles : \" + ctx.loadedTiles.size() + \n\t\t\t\t\", visited segments \" + ctx.visitedSegments );\n\t\treturn result;\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private RouteSegment processRouteSegment(final RoutingContext ctx, RouteSegment end, boolean reverseWaySearch,\n\t\t\tPriorityQueue<RouteSegment> graphSegments, TLongHashSet visitedSegments, int targetEndX, int targetEndY,\n\t\t\tRouteSegment segment, TLongHashSet oppositeSegments) throws IOException {\n\t\t// Always start from segmentStart (!), not from segmentEnd\n\t\t// It makes difference only for the first start segment\n\t\t// Middle point will always be skipped from observation considering already visited\n\t\tfinal BinaryMapDataObject road = segment.road;\n\t\tfinal int middle = segment.segmentStart;\n\t\tint middlex = road.getPoint31XTile(middle);\n\t\tint middley = road.getPoint31YTile(middle);\n\t\t\n\t\t// 0. mark route segment as visited\n\t\tlong nt = (road.getId() << 8l) + middle;\n\t\tvisitedSegments.add(nt);\n\t\tif(oppositeSegments.contains(nt)){\n//\t\tif(end.road.getId() == road.getId() && end.segmentStart == middle){\n\t\t\tsegment.segmentEnd = middle;\n\t\t\treturn segment;\n\t\t}\n\t\t\n\t\t\n\t\tboolean oneway = ctx.router.isOneWay(road.getHighwayAttributes());\n\t\tboolean minusAllowed =  !oneway || reverseWaySearch;\n\t\tboolean plusAllowed =  !oneway || !reverseWaySearch;\n\t\t\n\t\t// +/- diff from middle point\n\t\tint d = plusAllowed ? 1 : -1;\n\t\t// Go through all point of the way and find ways to continue\n\t\t// ! Actually there is small bug when there is restriction to move forward on way (it doesn't take into account) \n\t\twhile(minusAllowed || plusAllowed) {\n\t\t\t// 1. calculate point not equal to middle\n\t\t\t//\t  (algorithm should visit all point on way if it is not oneway)\n\t\t\tint segmentEnd = middle + d;\n\t\t\tif (!minusAllowed && d > 0) {\n\t\t\t\td++;\n\t\t\t} else if (!plusAllowed && d < 0) {\n\t\t\t\td--;\n\t\t\t} else {\n\t\t\t\tif (d <= 0){\n\t\t\t\t\td = -d + 1;\n\t\t\t\t} else {\n\t\t\t\t\td = -d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(segmentEnd < 0){\n\t\t\t\tminusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(segmentEnd >= road.getPointsLength()){\n\t\t\t\tplusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if we found end point break cycle\n\t\t\tlong nts = (road.getId() << 8l) + segmentEnd;\n\t\t\tif(oppositeSegments.contains(nts)){\n//\t\t\tif(end.road.getId() == road.getId() && end.segmentStart == segmentEnd){\n\t\t\t\tsegment.segmentEnd = segmentEnd;\n\t\t\t\treturn segment;\n\t\t\t}\n\t\t\tvisitedSegments.add(nts);\n\t\t\t\n\t\t\t// 2. calculate point and try to load neighbor ways if they are not loaded\n\t\t\tint x = road.getPoint31XTile(segmentEnd);\n\t\t\tint y = road.getPoint31YTile(segmentEnd);\n\t\t\tloadRoutes(ctx, (x >> (31 - ZOOM_LOAD_TILES)), (y >> (31 - ZOOM_LOAD_TILES)));\n\t\t\tlong l = (((long) x) << 31) + (long) y;\n\t\t\tRouteSegment next = ctx.routes.get(l);\n\t\t\t\n\t\t\t// 3. get intersected ways\n\t\t\tif (next != null) {\n\t\t\t\tdouble distOnRoadToPass = squareRootDist(x, y, middlex, middley);\n\t\t\t\tdouble distToFinalPoint = squareRootDist(x, y, targetEndX, targetEndY);\n\t\t\t\tprocessIntersectionsWithWays(ctx, graphSegments, visitedSegments, distOnRoadToPass, distToFinalPoint,\n\t\t\t\t\tsegment, road, d == 0, segmentEnd, next);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":66093,"modified_method":"private RouteSegment processRouteSegment(final RoutingContext ctx, RouteSegment end, boolean reverseWaySearch,\n\t\t\tPriorityQueue<RouteSegment> graphSegments, TLongObjectHashMap<RouteSegment> visitedSegments, int targetEndX, int targetEndY,\n            RouteSegment segment, TLongObjectHashMap<RouteSegment> oppositeSegments) throws IOException {\n\t\t// Always start from segmentStart (!), not from segmentEnd\n\t\t// It makes difference only for the first start segment\n\t\t// Middle point will always be skipped from observation considering already visited\n\t\tfinal BinaryMapDataObject road = segment.road;\n\t\tfinal int middle = segment.segmentStart;\n\t\tint middlex = road.getPoint31XTile(middle);\n\t\tint middley = road.getPoint31YTile(middle);\n\n\t\t// 0. mark route segment as visited\n\t\tlong nt = (road.getId() << 8l) + middle;\n\t\tvisitedSegments.put(nt, segment);\n\t\tif (oppositeSegments.contains(nt)) {\n\t\t\t// if(end.road.getId() == road.getId() && end.segmentStart == middle){\n\t\t\tsegment.segmentEnd = middle;\n\t\t\treturn segment;\n\t\t}\n\n\t\tboolean oneway = ctx.router.isOneWay(road.getHighwayAttributes());\n\t\tboolean minusAllowed = !oneway || reverseWaySearch;\n\t\tboolean plusAllowed = !oneway || !reverseWaySearch;\n\n\t\t// +/- diff from middle point\n\t\tint d = plusAllowed ? 1 : -1;\n\t\t// Go through all point of the way and find ways to continue\n\t\t// ! Actually there is small bug when there is restriction to move forward on way (it doesn't take into account)\n\t\twhile (minusAllowed || plusAllowed) {\n\t\t\t// 1. calculate point not equal to middle\n\t\t\t// (algorithm should visit all point on way if it is not oneway)\n\t\t\tint segmentEnd = middle + d;\n\t\t\tif (!minusAllowed && d > 0) {\n\t\t\t\td++;\n\t\t\t} else if (!plusAllowed && d < 0) {\n\t\t\t\td--;\n\t\t\t} else {\n\t\t\t\tif (d <= 0) {\n\t\t\t\t\td = -d + 1;\n\t\t\t\t} else {\n\t\t\t\t\td = -d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (segmentEnd < 0) {\n\t\t\t\tminusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (segmentEnd >= road.getPointsLength()) {\n\t\t\t\tplusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if we found end point break cycle\n\t\t\tlong nts = (road.getId() << 8l) + segmentEnd;\n\t\t\tif (oppositeSegments.contains(nts)) {\n\t\t\t\t// if(end.road.getId() == road.getId() && end.segmentStart == segmentEnd){\n\t\t\t\tsegment.segmentEnd = segmentEnd;\n\t\t\t\treturn segment;\n\t\t\t}\n\t\t\tvisitedSegments.put(nts, segment);\n\n\t\t\t// 2. calculate point and try to load neighbor ways if they are not loaded\n\t\t\tint x = road.getPoint31XTile(segmentEnd);\n\t\t\tint y = road.getPoint31YTile(segmentEnd);\n\t\t\tloadRoutes(ctx, (x >> (31 - ZOOM_LOAD_TILES)), (y >> (31 - ZOOM_LOAD_TILES)));\n\t\t\tlong l = (((long) x) << 31) + (long) y;\n\t\t\tRouteSegment next = ctx.routes.get(l);\n\n\t\t\t// 3. get intersected ways\n\t\t\tif (next != null) {\n\t\t\t\tdouble distOnRoadToPass = squareRootDist(x, y, middlex, middley);\n\t\t\t\tdouble distToFinalPoint = squareRootDist(x, y, targetEndX, targetEndY);\n\t\t\t\tprocessIntersectionsWithWays(ctx, graphSegments, visitedSegments, distOnRoadToPass, distToFinalPoint, segment, road,\n\t\t\t\t\t\td == 0, segmentEnd, next);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void visitAllStartSegments(final RoutingContext ctx, RouteSegment start, PriorityQueue<RouteSegment> graphDirectSegments,\n\t\t\tTLongHashSet visitedSegments, int startX, int startY) throws IOException {\n\t\t// mark as visited code seems to be duplicated\n\t\tlong nt = (start.road.getId() << 8l) + start.segmentStart;\n\t\tvisitedSegments.add(nt);\n\t\tgraphDirectSegments.add(start);\n\t\t\n\t\tloadRoutes(ctx, (startX >> (31 - ZOOM_LOAD_TILES)), (startY >> (31 - ZOOM_LOAD_TILES)));\n\t\tlong ls = (((long) startX) << 31) + (long) startY;\n\t\tRouteSegment startNbs = ctx.routes.get(ls);\n\t\twhile(startNbs != null) { // startNbs.road.id >> 1, start.road.id >> 1\n\t\t\tif(startNbs.road.getId() != start.road.getId()){\n\t\t\t\tstartNbs.parentRoute = start;\n\t\t\t\tstartNbs.parentSegmentEnd = start.segmentStart;\n\t\t\t\tstartNbs.distanceToEnd = start.distanceToEnd;\n\n\t\t\t\t// duplicated to be sure start is added\n\t\t\t\tnt = (startNbs.road.getId() << 8l) + startNbs.segmentStart;\n\t\t\t\tvisitedSegments.add(nt);\n\t\t\t\tgraphDirectSegments.add(startNbs);\n\t\t\t}\n\t\t\tstartNbs = startNbs.next;\n\t\t}\n\t}","id":66094,"modified_method":"private void visitAllStartSegments(final RoutingContext ctx, RouteSegment start, PriorityQueue<RouteSegment> graphDirectSegments,\n\t\t\tTLongObjectHashMap<RouteSegment> visitedSegments, int startX, int startY) throws IOException {\n\t\t// mark as visited code seems to be duplicated\n\t\tlong nt = (start.road.getId() << 8l) + start.segmentStart;\n\t\tvisitedSegments.put(nt, start);\n\t\tgraphDirectSegments.add(start);\n\t\t\n\t\tloadRoutes(ctx, (startX >> (31 - ZOOM_LOAD_TILES)), (startY >> (31 - ZOOM_LOAD_TILES)));\n\t\tlong ls = (((long) startX) << 31) + (long) startY;\n\t\tRouteSegment startNbs = ctx.routes.get(ls);\n\t\twhile(startNbs != null) { // startNbs.road.id >> 1, start.road.id >> 1\n\t\t\tif(startNbs.road.getId() != start.road.getId()){\n\t\t\t\tstartNbs.parentRoute = start;\n\t\t\t\tstartNbs.parentSegmentEnd = start.segmentStart;\n\t\t\t\tstartNbs.distanceToEnd = start.distanceToEnd;\n\n\t\t\t\t// duplicated to be sure start is added\n\t\t\t\tnt = (startNbs.road.getId() << 8l) + startNbs.segmentStart;\n\t\t\t\tvisitedSegments.put(nt, startNbs);\n\t\t\t\tgraphDirectSegments.add(startNbs);\n\t\t\t}\n\t\t\tstartNbs = startNbs.next;\n\t\t}\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void processIntersectionsWithWays(RoutingContext ctx, PriorityQueue<RouteSegment> graphSegments,\n\t\t\tTLongHashSet visitedSegments, double distOnRoadToPass, double distToFinalPoint, \n\t\t\tRouteSegment segment, BinaryMapDataObject road, boolean firstOfSegment, int segmentEnd, RouteSegment next) {\n\n\t\t// This variables can be in routing context\n\t\t// initialize temporary lists to calculate not forbidden ways at way intersections\n\t\tArrayList<RouteSegment> segmentsToVisitPrescripted = new ArrayList<RouteSegment>(5);\n\t\tArrayList<RouteSegment> segmentsToVisitNotForbidden = new ArrayList<RouteSegment>(5);\n\t\t// collect time for obstacles\n\t\tdouble obstaclesTime = 0;\n\t\tboolean exclusiveRestriction = false;\n\n\t\t// 3.1 calculate time for obstacles (bumps, traffic_signals, level_crossing)\n\t\tif (firstOfSegment) {\n\t\t\tRouteSegment possibleObstacle = next;\n\t\t\twhile (possibleObstacle != null) {\n\t\t\t\tobstaclesTime += ctx.router.defineObstacle(possibleObstacle.road, possibleObstacle.segmentStart);\n\t\t\t\tpossibleObstacle = possibleObstacle.next;\n\t\t\t}\n\t\t}\n\n\t\t// 3.2 calculate possible ways to put into priority queue\n\t\twhile (next != null) {\n\t\t\tlong nts = (next.road.getId() << 8l) + next.segmentStart;\n\t\t\t/* next.road.getId() >> 3 (1) != road.getId() >> 3 (1) - used that line for debug with osm map */\n\t\t\t// road.id could be equal on roundabout, but we should accept them\n\t\t\tif (!visitedSegments.contains(nts)) {\n\t\t\t\tint type = -1;\n\t\t\t\tfor (int i = 0; i < road.getRestrictionCount(); i++) {\n\t\t\t\t\tif (road.getRestriction(i) == next.road.getId()) {\n\t\t\t\t\t\ttype = road.getRestrictionType(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (type == -1 && exclusiveRestriction) {\n\t\t\t\t\t// next = next.next; continue;\n\t\t\t\t} else if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN\n\t\t\t\t\t\t|| type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {\n\t\t\t\t\t// next = next.next; continue;\n\t\t\t\t} else {\n\t\t\t\t\tdouble distanceToEnd = distToFinalPoint / ctx.router.getMaxDefaultSpeed();\n\n\t\t\t\t\t// Using A* routing algorithm\n\t\t\t\t\t// g(x) - calculate distance to that point and calculate time\n\t\t\t\t\tdouble speed = ctx.router.defineSpeed(road);\n\t\t\t\t\tif (speed == 0) {\n\t\t\t\t\t\tspeed = ctx.router.getMinDefaultSpeed();\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble distanceFromStart = segment.distanceFromStart + distOnRoadToPass / speed;\n\t\t\t\t\t// calculate turn time\n\t\t\t\t\tdistanceFromStart += ctx.router.calculateTurnTime(segment, next, segmentEnd);\n\t\t\t\t\t// add obstacles time\n\t\t\t\t\tdistanceFromStart += obstaclesTime;\n\n\t\t\t\t\tif (next.parentRoute == null\n\t\t\t\t\t\t\t|| ctx.roadPriorityComparator(next.distanceFromStart, next.distanceToEnd, distanceFromStart, distanceToEnd) > 0) {\n\t\t\t\t\t\tnext.distanceFromStart = distanceFromStart;\n\t\t\t\t\t\tnext.distanceToEnd = distanceToEnd;\n\t\t\t\t\t\tif (next.parentRoute != null) {\n\t\t\t\t\t\t\t// already in queue remove it\n\t\t\t\t\t\t\tgraphSegments.remove(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// put additional information to recover whole route after\n\t\t\t\t\t\tnext.parentRoute = segment;\n\t\t\t\t\t\tnext.parentSegmentEnd = segmentEnd;\n\t\t\t\t\t\tif (type == -1) {\n\t\t\t\t\t\t\t// case no restriction\n\t\t\t\t\t\t\tsegmentsToVisitNotForbidden.add(next);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// case exclusive restriction (only_right, only_straight, ...)\n\t\t\t\t\t\t\texclusiveRestriction = true;\n\t\t\t\t\t\t\tsegmentsToVisitNotForbidden.clear();\n\t\t\t\t\t\t\tsegmentsToVisitPrescripted.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext = next.next;\n\t\t}\n\n\t\t// add all allowed route segments to priority queue\n\t\tfor (RouteSegment s : segmentsToVisitNotForbidden) {\n\t\t\tgraphSegments.add(s);\n\t\t}\n\t\tfor (RouteSegment s : segmentsToVisitPrescripted) {\n\t\t\tgraphSegments.add(s);\n\t\t}\n\t}","id":66095,"modified_method":"private void processIntersectionsWithWays(RoutingContext ctx, PriorityQueue<RouteSegment> graphSegments,\n\t\t\tTLongObjectHashMap<RouteSegment> visitedSegments, double distOnRoadToPass, double distToFinalPoint, \n\t\t\tRouteSegment segment, BinaryMapDataObject road, boolean firstOfSegment, int segmentEnd, RouteSegment next) {\n\n\t\t// This variables can be in routing context\n\t\t// initialize temporary lists to calculate not forbidden ways at way intersections\n\t\tArrayList<RouteSegment> segmentsToVisitPrescripted = new ArrayList<RouteSegment>(5);\n\t\tArrayList<RouteSegment> segmentsToVisitNotForbidden = new ArrayList<RouteSegment>(5);\n\t\t// collect time for obstacles\n\t\tdouble obstaclesTime = 0;\n\t\tboolean exclusiveRestriction = false;\n\n\t\t// 3.1 calculate time for obstacles (bumps, traffic_signals, level_crossing)\n\t\tif (firstOfSegment) {\n\t\t\tRouteSegment possibleObstacle = next;\n\t\t\twhile (possibleObstacle != null) {\n\t\t\t\tobstaclesTime += ctx.router.defineObstacle(possibleObstacle.road, possibleObstacle.segmentStart);\n\t\t\t\tpossibleObstacle = possibleObstacle.next;\n\t\t\t}\n\t\t}\n\n\t\t// 3.2 calculate possible ways to put into priority queue\n\t\twhile (next != null) {\n\t\t\tlong nts = (next.road.getId() << 8l) + next.segmentStart;\n\t\t\t/* next.road.getId() >> 3 (1) != road.getId() >> 3 (1) - used that line for debug with osm map */\n\t\t\t// road.id could be equal on roundabout, but we should accept them\n\t\t\tif (!visitedSegments.contains(nts)) {\n\t\t\t\tint type = -1;\n\t\t\t\tfor (int i = 0; i < road.getRestrictionCount(); i++) {\n\t\t\t\t\tif (road.getRestriction(i) == next.road.getId()) {\n\t\t\t\t\t\ttype = road.getRestrictionType(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (type == -1 && exclusiveRestriction) {\n\t\t\t\t\t// next = next.next; continue;\n\t\t\t\t} else if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN\n\t\t\t\t\t\t|| type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {\n\t\t\t\t\t// next = next.next; continue;\n\t\t\t\t} else {\n\t\t\t\t\tdouble distanceToEnd = distToFinalPoint / ctx.router.getMaxDefaultSpeed();\n\n\t\t\t\t\t// Using A* routing algorithm\n\t\t\t\t\t// g(x) - calculate distance to that point and calculate time\n\t\t\t\t\tdouble speed = ctx.router.defineSpeed(road);\n\t\t\t\t\tif (speed == 0) {\n\t\t\t\t\t\tspeed = ctx.router.getMinDefaultSpeed();\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble distanceFromStart = segment.distanceFromStart + distOnRoadToPass / speed;\n\t\t\t\t\t// calculate turn time\n\t\t\t\t\tdistanceFromStart += ctx.router.calculateTurnTime(segment, next, segmentEnd);\n\t\t\t\t\t// add obstacles time\n\t\t\t\t\tdistanceFromStart += obstaclesTime;\n\n\t\t\t\t\tif (next.parentRoute == null\n\t\t\t\t\t\t\t|| ctx.roadPriorityComparator(next.distanceFromStart, next.distanceToEnd, distanceFromStart, distanceToEnd) > 0) {\n\t\t\t\t\t\tnext.distanceFromStart = distanceFromStart;\n\t\t\t\t\t\tnext.distanceToEnd = distanceToEnd;\n\t\t\t\t\t\tif (next.parentRoute != null) {\n\t\t\t\t\t\t\t// already in queue remove it\n\t\t\t\t\t\t\tgraphSegments.remove(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// put additional information to recover whole route after\n\t\t\t\t\t\tnext.parentRoute = segment;\n\t\t\t\t\t\tnext.parentSegmentEnd = segmentEnd;\n\t\t\t\t\t\tif (type == -1) {\n\t\t\t\t\t\t\t// case no restriction\n\t\t\t\t\t\t\tsegmentsToVisitNotForbidden.add(next);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// case exclusive restriction (only_right, only_straight, ...)\n\t\t\t\t\t\t\texclusiveRestriction = true;\n\t\t\t\t\t\t\tsegmentsToVisitNotForbidden.clear();\n\t\t\t\t\t\t\tsegmentsToVisitPrescripted.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext = next.next;\n\t\t}\n\n\t\t// add all allowed route segments to priority queue\n\t\tfor (RouteSegment s : segmentsToVisitNotForbidden) {\n\t\t\tgraphSegments.add(s);\n\t\t}\n\t\tfor (RouteSegment s : segmentsToVisitPrescripted) {\n\t\t\tgraphSegments.add(s);\n\t\t}\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int roadPriorityComparator(double o1DistanceFromStart, double o1DistanceToEnd, \n\t\t\t\tdouble o2DistanceFromStart, double o2DistanceToEnd) {\n\t\t\t// f(x) = g(x) + h(x)  --- g(x) - distanceFromStart, h(x) - distanceToEnd (not exact)\n\t\t\treturn Double.compare(o1DistanceFromStart + heuristicCoefficient * o1DistanceToEnd, \n\t\t\t\t\to2DistanceFromStart + heuristicCoefficient *  o2DistanceToEnd);\n\t\t}","id":66096,"modified_method":"public int roadPriorityComparator(double o1DistanceFromStart, double o1DistanceToEnd, double o2DistanceFromStart,\n\t\t\t\tdouble o2DistanceToEnd) {\n\t\t\treturn BinaryRoutePlanner.roadPriorityComparator(o1DistanceFromStart, o1DistanceToEnd, o2DistanceFromStart, o2DistanceToEnd, heuristicCoefficient);\n\t\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static JMenu getMenuToChooseSource(final MapPanel panel){\n\t\tfinal JMenu tiles = new JMenu(Messages.getString(\"MapPanel.SOURCE.OF.TILES\")); //$NON-NLS-1$\n\t\tfinal JMenu downloadedMenu = new JMenu(\"Additional\"); //$NON-NLS-1$\n\t\tfinal File tilesDirectory = DataExtractionSettings.getSettings().getTilesDirectory();\n\t\tMap<String, TileSourceTemplate> udf = getCommonTemplates(tilesDirectory);\n\t\tfinal List<TileSourceTemplate> downloaded = TileSourceManager.downloadTileSourceTemplates();\n\t\tfinal Map<TileSourceTemplate, JCheckBoxMenuItem> items = new IdentityHashMap<TileSourceTemplate, JCheckBoxMenuItem>();\n\t\t\n\t\ttiles.add(downloadedMenu);\n\t\tfor(final TileSourceTemplate l : udf.values()){\n\t\t\tif(l == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tJCheckBoxMenuItem menuItem = new JCheckBoxMenuItem(l.getName());\n\t\t\ttiles.add(menuItem);\n\t\t\titems.put(l, menuItem);\n\t\t\tmenuItem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> es : items.entrySet()) {\n\t\t\t\t\t\tes.getValue().setSelected(l.equals(es.getKey()));\n\t\t\t\t\t}\n\t\t\t\t\tFile dir = new File(tilesDirectory, l.getName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdir.mkdirs();\n\t\t\t\t\t\tTileSourceManager.createMetaInfoFile(dir, l, false);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t}\n\t\t\t\t\tpanel.setMapName(l);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor(final TileSourceTemplate l : downloaded){\n\t\t\tif(l == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tJCheckBoxMenuItem menuItem = new JCheckBoxMenuItem(l.getName());\n\t\t\tdownloadedMenu.add(menuItem);\n\t\t\titems.put(l, menuItem);\n\t\t\tmenuItem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> es : items.entrySet()) {\n\t\t\t\t\t\tes.getValue().setSelected(l.equals(es.getKey()));\n\t\t\t\t\t}\n\t\t\t\t\tFile dir = new File(tilesDirectory, l.getName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdir.mkdirs();\n\t\t\t\t\t\tTileSourceManager.createMetaInfoFile(dir, l, true);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t}\n\t\t\t\t\tpanel.setMapName(l);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> em : items.entrySet()) {\n\t\t\tif(Algoritms.objectEquals(panel.getMap(), em.getKey())){\n\t\t\t\tem.getValue().setSelected(true);\n\t\t\t}\n\t\t}\n\n\t\ttiles.addSeparator();\n\t\ttiles.add(createNewTileSourceAction(panel, tiles, items));\n\t\treturn tiles;\n\t}","id":66097,"modified_method":"public static JMenu getMenuToChooseSource(final MapPanel panel){\n\t\tfinal JMenu tiles = new JMenu(Messages.getString(\"MapPanel.SOURCE.OF.TILES\")); //$NON-NLS-1$\n\t\tfinal JMenu downloadedMenu = new JMenu(\"Additional\"); //$NON-NLS-1$\n\t\tfinal File tilesDirectory = DataExtractionSettings.getSettings().getTilesDirectory();\n\t\tMap<String, TileSourceTemplate> udf = getCommonTemplates(tilesDirectory);\n\t\tfinal List<TileSourceTemplate> downloaded = TileSourceManager.downloadTileSourceTemplates();\n\t\tfinal Map<TileSourceTemplate, JCheckBoxMenuItem> items = new IdentityHashMap<TileSourceTemplate, JCheckBoxMenuItem>();\n\t\t\n\t\ttiles.add(downloadedMenu);\n\t\tfor(final TileSourceTemplate l : udf.values()){\n\t\t\tif(l == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tJCheckBoxMenuItem menuItem = new JCheckBoxMenuItem(l.getName());\n\t\t\ttiles.add(menuItem);\n\t\t\titems.put(l, menuItem);\n\t\t\tmenuItem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> es : items.entrySet()) {\n\t\t\t\t\t\tes.getValue().setSelected(l.equals(es.getKey()));\n\t\t\t\t\t}\n\t\t\t\t\tFile dir = new File(tilesDirectory, l.getName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdir.mkdirs();\n\t\t\t\t\t\tTileSourceManager.createMetaInfoFile(dir, l, false);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t}\n\t\t\t\t\tpanel.setMapName(l);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (downloaded != null) {\n\t\t\tfor (final TileSourceTemplate l : downloaded) {\n\t\t\t\tif (l == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tJCheckBoxMenuItem menuItem = new JCheckBoxMenuItem(l.getName());\n\t\t\t\tdownloadedMenu.add(menuItem);\n\t\t\t\titems.put(l, menuItem);\n\t\t\t\tmenuItem.addActionListener(new ActionListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> es : items.entrySet()) {\n\t\t\t\t\t\t\tes.getValue().setSelected(l.equals(es.getKey()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFile dir = new File(tilesDirectory, l.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdir.mkdirs();\n\t\t\t\t\t\t\tTileSourceManager.createMetaInfoFile(dir, l, true);\n\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanel.setMapName(l);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (final Map.Entry<TileSourceTemplate, JCheckBoxMenuItem> em : items.entrySet()) {\n\t\t\tif(Algoritms.objectEquals(panel.getMap(), em.getKey())){\n\t\t\t\tem.getValue().setSelected(true);\n\t\t\t}\n\t\t}\n\n\t\ttiles.addSeparator();\n\t\ttiles.add(createNewTileSourceAction(panel, tiles, items));\n\t\treturn tiles;\n\t}","commit_id":"968ff424d9fa41ae57b16515bf95d900abbd8b09","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\r\n     * Helper method to generate an ascending list of floats below a given number.<p>\r\n     * \r\n     * @param max the upper bound \r\n     * @param steps the number of floats to generate \r\n     * \r\n     * @return the generated floats \r\n     */\r\n    private List<Float> interpolateDownwards(float max, int steps) {\r\n\r\n        List<Float> result = new ArrayList<Float>();\r\n        for (int i = 0; i < steps; i++) {\r\n            result.add(new Float(max - 1 - i));\r\n        }\r\n        Collections.reverse(result);\r\n        return result;\r\n    }","id":66098,"modified_method":"/**\r\n     * Helper method to generate an ascending list of floats below a given number.<p>\r\n     * \r\n     * @param max the upper bound \r\n     * @param steps the number of floats to generate \r\n     * \r\n     * @return the generated floats \r\n     */\r\n    private List<Float> interpolateDownwards(float max, int steps) {\r\n\r\n        List<Float> result = new ArrayList<Float>();\r\n        if (max > 0) {\r\n            // We try to generate a \"nice\" descending list of non-negative floats\r\n            // where the step size is bigger for bigger \"max\" values. \r\n            float base = (max > 1) ? (float)Math.floor(max) : max;\r\n            float stepSize = 1000f;\r\n\r\n            // reduce step size until the smallest element is greater than max/10.\r\n            while ((base - (steps * stepSize)) < (max / 10.0f)) {\r\n                stepSize = reduceStepSize(stepSize);\r\n            }\r\n            // we have determined the step size, now we generate the actual numbers \r\n            for (int i = 0; i < steps; i++) {\r\n                result.add(new Float(base - ((i + 1) * stepSize)));\r\n            }\r\n            Collections.reverse(result);\r\n        } else {\r\n            LOG.warn(\"Invalid navpos value: \" + max);\r\n            for (int i = 0; i < steps; i++) {\r\n                result.add(new Float(max - (i + 1)));\r\n            }\r\n            Collections.reverse(result);\r\n        }\r\n        return result;\r\n    }","commit_id":"b534cf15ac5278f248880ffae4c9099af67e4e7c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Performs a sanity check after a navigation entry insertion.<p>\r\n     * \r\n     * This checks whether the list of entries have non-decreasing navigation positions and \r\n     * whether the sequence (left neighbor of inserted entry, inserted entry, right neighbor of inserted entry)\r\n     * have increasing navigation positions.\r\n     * \r\n     * @param navs the list of navigation entries \r\n     * @param insertPosition the insertion position \r\n     */\r\n    private void checkIntegrity(List<CmsJspNavElement> navs, int insertPosition) {\r\n\r\n        float navPos = navs.get(insertPosition).getNavPosition();\r\n        if (insertPosition > 0) {\r\n            assertTrue(navs.get(insertPosition - 1).getNavPosition() < navPos);\r\n        }\r\n        if (insertPosition < (navs.size() - 1)) {\r\n            assertTrue(navs.get(insertPosition + 1).getNavPosition() > navPos);\r\n        }\r\n        assertTrue(checkNonDecreasing(navs));\r\n    }","id":66099,"modified_method":"/**\r\n     * Performs a sanity check after a navigation entry insertion.<p>\r\n     * \r\n     * This checks whether the list of entries have non-decreasing navigation positions and \r\n     * whether the sequence (left neighbor of inserted entry, inserted entry, right neighbor of inserted entry)\r\n     * have increasing navigation positions.\r\n     * \r\n     * @param navs the list of navigation entries \r\n     * @param insertPosition the insertion position \r\n     */\r\n    private void checkIntegrity(List<CmsJspNavElement> navs, int insertPosition) {\r\n\r\n        float navPos = navs.get(insertPosition).getNavPosition();\r\n        if (insertPosition > 0) {\r\n            assertTrue(navs.get(insertPosition - 1).getNavPosition() < navPos);\r\n        }\r\n        if (insertPosition < (navs.size() - 1)) {\r\n            assertTrue(navs.get(insertPosition + 1).getNavPosition() > navPos);\r\n        }\r\n        assertTrue(checkNonDecreasing(navs));\r\n        for (int i = 0; i < navs.size(); i++) {\r\n            assertTrue(navs.get(i).getNavPosition() > 0);\r\n        }\r\n    }","commit_id":"b534cf15ac5278f248880ffae4c9099af67e4e7c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void updatePlugins(Set<SModule> toUnload, Set<SModule> toLoad) {\n    assert SwingUtilities.isEventDispatchThread() : \"should be called from EDT only\";\n\n    if (isDisposed()) return;\n\n    // calc contributors to unload\n    // calc contributors to load\n    // unload\n    // load\n\n    if (myContributors != null) {\n      // dispose\n      Collections.reverse(myContributors);\n      unloadPlugins(myContributors);\n      myContributors = null;\n    }\n\n    // load\n    myContributors = PluginUtil.getPluginContributors();\n    loadPlugins(myContributors);\n  }","id":66100,"modified_method":"private void updatePlugins(Set<SModule> toUnload, Set<SModule> toLoad) {\n    assert SwingUtilities.isEventDispatchThread() : \"should be called from EDT only\";\n\n    if (isDisposed()) return;\n\n    // calc contributors to unload\n    List<PluginContributor> toUnloadContributors = new ArrayList<PluginContributor>();\n    for (PluginContributor contributor : myContributors) {\n      if (contributor instanceof ModulePluginContributor) {\n        if (toUnload.contains(((ModulePluginContributor) contributor).module)) {\n          toUnloadContributors.add(contributor);\n        }\n      }\n    }\n    Collections.reverse(toUnloadContributors);\n\n    // calc contributors to load\n    List<PluginContributor> toLoadContributors = new ArrayList<PluginContributor>();\n    toLoadContributors.addAll(PluginUtil.createPluginContributors(toLoad));\n    for (PluginContributor contributor : PluginUtil.getPluginFactoriesRegistryContributors()) {\n      if (!myContributors.contains(contributor)) {\n        toLoadContributors.add(contributor);\n      }\n    }\n\n    // unload\n    unloadPlugins(toUnloadContributors);\n    myContributors.removeAll(toUnloadContributors);\n\n    // load\n    myContributors.addAll(toLoadContributors);\n    loadPlugins(toLoadContributors);\n  }","commit_id":"c68d3f9f1b814fee13842bd0a80c20c82a972e1b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<PluginContributor> createPluginContributors(Collection<SModule> modules) {\n    List<SModule> sortedModules = PluginSorter.sortByDependencies(modules);\n\n    final ArrayList<PluginContributor> contributors = new ArrayList<PluginContributor>();\n    for (SModule module : sortedModules) {\n      PluginContributor contributor = createPluginContributor(module);\n      if (contributor != null) {\n        contributors.add(contributor);\n      }\n    }\n\n    return contributors;\n  }","id":66101,"modified_method":"public static List<PluginContributor> createPluginContributors(Collection<SModule> modules) {\n    List<SModule> sortedModules = PluginSorter.sortByDependencies(modules);\n\n    final ArrayList<PluginContributor> contributors = new ArrayList<PluginContributor>();\n    for (SModule module : sortedModules) {\n      PluginContributor contributor = createPluginContributor(module);\n      if (contributor != null) {\n        contributors.add(contributor);\n      }\n    }\n\n    return contributors;\n  }","commit_id":"c68d3f9f1b814fee13842bd0a80c20c82a972e1b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<PluginContributor> getPluginContributors() {\n    List<PluginContributor> pluginContributors = new ArrayList<PluginContributor>();\n\n    for (PluginContributor contributor : createPluginContributors(collectPluginModules())) {\n      pluginContributors.add(contributor);\n    }\n    for (AbstractPluginFactory factory : PluginFactoriesRegistry.getPluginFactories()) {\n      pluginContributors.add(PluginContributor.adapt(factory));\n    }\n\n    return pluginContributors;\n  }","id":66102,"modified_method":"public static List<PluginContributor> getPluginContributors() {\n    List<PluginContributor> pluginContributors = new ArrayList<PluginContributor>();\n\n    for (PluginContributor contributor : createPluginContributors(collectPluginModules())) {\n      pluginContributors.add(contributor);\n    }\n    for (PluginContributor contributor : getPluginFactoriesRegistryContributors()) {\n      pluginContributors.add(contributor);\n    }\n\n    return pluginContributors;\n  }","commit_id":"c68d3f9f1b814fee13842bd0a80c20c82a972e1b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void stop(Container container) {\n        assertValid();\n        String id = getDockerContainerId(container);\n        if (!Strings.isEmpty(id)) {\n            LOG.info(\"stopping container \" + id);\n            Integer timeToWait = null;\n            docker.containerStop(id, timeToWait);\n        }\n    }","id":66103,"modified_method":"@Override\n    public void stop(Container container) {\n        assertValid();\n        String id = getDockerContainerId(container);\n        if (!Strings.isNullOrBlank(id)) {\n            LOG.info(\"stopping container \" + id);\n            Integer timeToWait = null;\n            docker.containerStop(id, timeToWait);\n        }\n    }","commit_id":"7123b3af60e0340c79dd18e3218730471d3d8d15","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void startDockerContainer(String id, CreateDockerContainerOptions options) {\n        if (!Strings.isEmpty(id)) {\n            HostConfig hostConfig = new HostConfig();\n\n            Map<String, Integer> externalPorts = options.getExternalPorts();\n            Map<String, Integer> internalPorts = options.getInternalPorts();\n\n            SortedMap<Integer, List<Map<String, String>>> sortedPortsToBinding = new TreeMap<Integer, List<Map<String, String>>>();\n            for (Map.Entry<String, Integer> entry : internalPorts.entrySet()) {\n                String portName = entry.getKey();\n                Integer internalPort = entry.getValue();\n                Integer externalPort = externalPorts.get(portName);\n                if (internalPort != null && externalPort != null) {\n                    sortedPortsToBinding.put(internalPort, createNewPortConfig(externalPort));\n                }\n            }\n\n            // now lets add the bindings in port order\n            Map<String, List<Map<String,String>>> portBindings = new LinkedHashMap<String, List<Map<String, String>>>();\n            for (Map.Entry<Integer, List<Map<String, String>>> entry : sortedPortsToBinding.entrySet()) {\n                Integer internalPort = entry.getKey();\n                List<Map<String, String>> value = entry.getValue();\n                portBindings.put(\"\" + internalPort + \"/tcp\", value);\n            }\n\n            hostConfig.setPortBindings(portBindings);\n            LOG.info(\"starting container \" + id +  \" with \" + hostConfig);\n            docker.containerStart(id, hostConfig);\n        }\n    }","id":66104,"modified_method":"protected void startDockerContainer(String id, CreateDockerContainerOptions options) {\n        if (!Strings.isNullOrBlank(id)) {\n            HostConfig hostConfig = new HostConfig();\n\n            Map<String, Integer> externalPorts = options.getExternalPorts();\n            Map<String, Integer> internalPorts = options.getInternalPorts();\n\n            SortedMap<Integer, List<Map<String, String>>> sortedPortsToBinding = new TreeMap<Integer, List<Map<String, String>>>();\n            for (Map.Entry<String, Integer> entry : internalPorts.entrySet()) {\n                String portName = entry.getKey();\n                Integer internalPort = entry.getValue();\n                Integer externalPort = externalPorts.get(portName);\n                if (internalPort != null && externalPort != null) {\n                    sortedPortsToBinding.put(internalPort, createNewPortConfig(externalPort));\n                }\n            }\n\n            // now lets add the bindings in port order\n            Map<String, List<Map<String,String>>> portBindings = new LinkedHashMap<String, List<Map<String, String>>>();\n            for (Map.Entry<Integer, List<Map<String, String>>> entry : sortedPortsToBinding.entrySet()) {\n                Integer internalPort = entry.getKey();\n                List<Map<String, String>> value = entry.getValue();\n                portBindings.put(\"\" + internalPort + \"/tcp\", value);\n            }\n\n            hostConfig.setPortBindings(portBindings);\n            LOG.info(\"starting container \" + id +  \" with \" + hostConfig);\n            docker.containerStart(id, hostConfig);\n        }\n    }","commit_id":"7123b3af60e0340c79dd18e3218730471d3d8d15","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public CreateDockerContainerMetadata create(CreateDockerContainerOptions options, CreationStateListener listener) throws Exception {\n        assertValid();\n\n        String containerId = options.getName();\n        ContainerConfig containerConfig = createContainerConfig(options);\n\n        // allow values to be extracted from the profile configuration\n        // such as the image\n        Set<String> profiles = options.getProfiles();\n        String versionId = options.getVersion();\n        FabricService service = fabricService.get();\n        Map<String, String> configOverlay = new HashMap<String, String>();\n        Map<String, String> envVarsOverlay = new HashMap<String, String>();\n        Map<String, String> ports = null;\n        Map<String, String> dockerProviderConfig = new HashMap<String, String>();\n\n        Version version = null;\n        if (profiles != null && versionId != null) {\n            version = service.getVersion(versionId);\n            if (version != null) {\n                for (String profileId : profiles) {\n                    Profile profile = version.getProfile(profileId);\n                    if (profile != null) {\n                        Profile overlay = profile.getOverlay();\n                        Map<String, String> dockerConfig = overlay.getConfiguration(DockerConstants.DOCKER_PROVIDER_PID);\n                        if (dockerConfig != null)  {\n                            configOverlay.putAll(dockerConfig);\n                        }\n                        Map<String, String> envVars = overlay.getConfiguration(DockerConstants.ENVIRONMENT_VARIABLES_PID);\n                        if (envVars != null)  {\n                            envVarsOverlay.putAll(envVars);\n                        }\n                        if (ports == null || ports.size() == 0) {\n                            ports = overlay.getConfiguration(DockerConstants.PORTS_PID);\n                        }\n                    }\n                }\n                if (version.hasProfile(DockerConstants.DOCKER_PROVIDER_PROFILE_ID)) {\n                    Profile profile = version.getProfile(DockerConstants.DOCKER_PROVIDER_PROFILE_ID);\n                    if (profile != null) {\n                        Map<String, String> dockerConfig = profile.getOverlay().getConfiguration(DockerConstants.DOCKER_PROVIDER_PID);\n                        if (dockerConfig != null)  {\n                            dockerProviderConfig.putAll(dockerConfig);\n                        }\n                    }\n                }\n            }\n        }\n        if (ports == null || ports.size() == 0) {\n            // lets find the defaults from the docker profile\n            if (version == null) {\n                version = service.getDefaultVersion();\n            }\n            Profile dockerProfile = version.getProfile(\"docker\");\n            ports = dockerProfile.getConfiguration(DockerConstants.PORTS_PID);\n            if (ports == null || ports.size() == 0) {\n                LOG.warn(\"Could not a docker ports configuration for: \" + DockerConstants.PORTS_PID);\n                ports = new HashMap<String, String>();\n            }\n        }\n        LOG.info(\"Got port configuration: \" + ports);\n        String image = containerConfig.getImage();\n        if (Strings.isEmpty(image)) {\n            image = configOverlay.get(DockerConstants.PROPERTIES.IMAGE);\n            if (Strings.isEmpty(image)) {\n                image = System.getenv(DockerConstants.ENV_VARS.FABRIC8_DOCKER_DEFAULT_IMAGE);\n            }\n            if (Strings.isEmpty(image)) {\n                image = dockerProviderConfig.get(DockerConstants.PROPERTIES.IMAGE);\n            }\n            if (Strings.isEmpty(image)) {\n                image = DockerConstants.DEFAULT_IMAGE;\n            }\n            containerConfig.setImage(image);\n        }\n        String[] cmd = containerConfig.getCmd();\n        if (cmd == null || cmd.length == 0) {\n            String value = configOverlay.get(DockerConstants.PROPERTIES.CMD);\n            if (Strings.isEmpty(value)) {\n                cmd = null;\n            } else {\n                cmd = new String[]{value};\n            }\n            containerConfig.setCmd(cmd);\n        }\n\n        String zookeeperUrl = service.getZookeeperUrl();\n        String zookeeperPassword = service.getZookeeperPassword();\n        if (zookeeperPassword != null) {\n            zookeeperPassword = PasswordEncoder.encode(zookeeperPassword);\n        }\n\n\n        String localIp = service.getCurrentContainer().getLocalIp();\n        if (!Strings.isEmpty(localIp)) {\n            int idx = zookeeperUrl.lastIndexOf(':');\n            if (idx > 0) {\n                localIp += zookeeperUrl.substring(idx);\n            }\n            zookeeperUrl = localIp;\n        }\n\n        envVarsOverlay.put(DockerConstants.ENV_VARS.KARAF_NAME, options.getName());\n        if (!options.isEnsembleServer()) {\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_URL) == null) {\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_URL, zookeeperUrl);\n            }\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD) == null) {\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD, zookeeperPassword);\n            }\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD_ENCODE) == null) {\n                String zkPasswordEncode = System.getProperty(\"zookeeper.password.encode\", \"true\");\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD_ENCODE, zkPasswordEncode);\n            }\n        }\n        List<String> env = containerConfig.getEnv();\n        if (env == null) {\n            env = new ArrayList<String>();\n        }\n        Set<Map.Entry<String, String>> entries = envVarsOverlay.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key != null && value != null) {\n                env.add(key + \"=\" + value);\n            }\n        }\n\n        Map<String, Object> exposedPorts = new HashMap<String, Object>();\n        Set<Integer> usedPortByHost = findUsedPortByHostAndDocker();\n        Map<String, Integer> internalPorts = options.getInternalPorts();\n        Map<String, Integer> externalPorts = options.getExternalPorts();\n        Map<String,String> emptyMap = new HashMap<String, String>();\n\n        SortedMap<Integer, String> sortedInternalPorts = new TreeMap<Integer, String>();\n        for (Map.Entry<String, String> portEntry : ports.entrySet()) {\n            String portName = portEntry.getKey();\n            String portText = portEntry.getValue();\n            if (portText != null && !Strings.isEmpty(portText)) {\n                Integer port = null;\n                try {\n                    port = Integer.parseInt(portText);\n                } catch (NumberFormatException e) {\n                    LOG.warn(\"Ignoring bad port number for \" + portName + \" value '\" + portText + \"' in PID: \" + DockerConstants.PORTS_PID);\n                }\n                if (port != null) {\n                    sortedInternalPorts.put(port, portName);\n                    internalPorts.put(portName, port);\n                    exposedPorts.put(portText + \"/tcp\", emptyMap);\n                } else {\n                    LOG.info(\"No port for \" + portName);\n                }\n            }\n        }\n        // lets create the ports in sorted order\n        for (Map.Entry<Integer, String> entry : sortedInternalPorts.entrySet()) {\n            Integer port = entry.getKey();\n            String portName = entry.getValue();\n            int externalPort = createExternalPort(containerId, portName, usedPortByHost, options);\n            externalPorts.put(portName, externalPort);\n            env.add(\"FABRIC8_\" + portName + \"_PORT=\" + port);\n            env.add(\"FABRIC8_\" + portName + \"_PROXY_PORT=\" + externalPort);\n        }\n\n        String dockerHost = dockerFactory.getDockerHost();\n        LOG.info(\"Passing in manual ip: \" + dockerHost);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_MANUALIP + \"=\" + dockerHost);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_GLOBAL_RESOLVER + \"=\" + ZkDefs.MANUAL_IP);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_FABRIC_ENVIRONMENT + \"=\" + DockerConstants.SCHEME);\n        containerConfig.setExposedPorts(exposedPorts);\n        containerConfig.setEnv(env);\n\n        String name = options.getName();\n\n        LOG.info(\"Creating container on docker: \" + getDockerAddress() + \" name: \" + name + \" env vars: \" + env);\n        LOG.info(\"Creating container with config: \" + containerConfig);\n\n        ContainerCreateStatus status = docker.containerCreate(containerConfig, name);\n        LOG.info(\"Got status: \" + status);\n        options = options.updateManualIp(dockerHost);\n\n        CreateDockerContainerMetadata metadata = newInstance(containerConfig, status);\n        metadata.setContainerName(containerId);\n        metadata.setOverridenResolver(ZkDefs.MANUAL_IP);\n        metadata.setCreateOptions(options);\n        startDockerContainer(status.getId(), options);\n        return metadata;\n    }","id":66105,"modified_method":"@Override\n    public CreateDockerContainerMetadata create(CreateDockerContainerOptions options, CreationStateListener listener) throws Exception {\n        assertValid();\n\n        String containerId = options.getName();\n        ContainerConfig containerConfig = createContainerConfig(options);\n\n        // allow values to be extracted from the profile configuration\n        // such as the image\n        Set<String> profiles = options.getProfiles();\n        String versionId = options.getVersion();\n        FabricService service = fabricService.get();\n        Map<String, String> configOverlay = new HashMap<String, String>();\n        Map<String, String> envVarsOverlay = new HashMap<String, String>();\n        Map<String, String> ports = null;\n        Map<String, String> dockerProviderConfig = new HashMap<String, String>();\n\n\n        List<Profile> profileOverlays = new ArrayList<Profile>();\n        Version version = null;\n        if (profiles != null && versionId != null) {\n            version = service.getVersion(versionId);\n            if (version != null) {\n                for (String profileId : profiles) {\n                    Profile profile = version.getProfile(profileId);\n                    if (profile != null) {\n                        Profile overlay = profile.getOverlay();\n                        profileOverlays.add(overlay);\n                        Map<String, String> dockerConfig = overlay.getConfiguration(DockerConstants.DOCKER_PROVIDER_PID);\n                        if (dockerConfig != null)  {\n                            configOverlay.putAll(dockerConfig);\n                        }\n                        Map<String, String> envVars = overlay.getConfiguration(DockerConstants.ENVIRONMENT_VARIABLES_PID);\n                        if (envVars != null)  {\n                            envVarsOverlay.putAll(envVars);\n                        }\n                        if (ports == null || ports.size() == 0) {\n                            ports = overlay.getConfiguration(DockerConstants.PORTS_PID);\n                        }\n                    }\n                }\n                if (version.hasProfile(DockerConstants.DOCKER_PROVIDER_PROFILE_ID)) {\n                    Profile profile = version.getProfile(DockerConstants.DOCKER_PROVIDER_PROFILE_ID);\n                    if (profile != null) {\n                        Map<String, String> dockerConfig = profile.getOverlay().getConfiguration(DockerConstants.DOCKER_PROVIDER_PID);\n                        if (dockerConfig != null)  {\n                            dockerProviderConfig.putAll(dockerConfig);\n                        }\n                    }\n                }\n            }\n        }\n        if (ports == null || ports.size() == 0) {\n            // lets find the defaults from the docker profile\n            if (version == null) {\n                version = service.getDefaultVersion();\n            }\n            Profile dockerProfile = version.getProfile(\"docker\");\n            ports = dockerProfile.getConfiguration(DockerConstants.PORTS_PID);\n            if (ports == null || ports.size() == 0) {\n                LOG.warn(\"Could not a docker ports configuration for: \" + DockerConstants.PORTS_PID);\n                ports = new HashMap<String, String>();\n            }\n        }\n        LOG.info(\"Got port configuration: \" + ports);\n        String image = containerConfig.getImage();\n        if (Strings.isNullOrBlank(image)) {\n            image = configOverlay.get(DockerConstants.PROPERTIES.IMAGE);\n            if (Strings.isNullOrBlank(image)) {\n                image = System.getenv(DockerConstants.ENV_VARS.FABRIC8_DOCKER_DEFAULT_IMAGE);\n            }\n            if (Strings.isNullOrBlank(image)) {\n                image = dockerProviderConfig.get(DockerConstants.PROPERTIES.IMAGE);\n            }\n            if (Strings.isNullOrBlank(image)) {\n                image = DockerConstants.DEFAULT_IMAGE;\n            }\n            containerConfig.setImage(image);\n        }\n\n        String libDir = configOverlay.get(DockerConstants.PROPERTIES.JAVA_LIBRARY_PATH);\n        if (!Strings.isNullOrBlank(libDir)) {\n            String imageRepository = configOverlay.get(DockerConstants.PROPERTIES.IMAGE_REPOSITORY);\n            List<String> names = new ArrayList<String>(profiles);\n            names.add(versionId);\n            String tag = \"fabric8-\" + Strings.join(names, \"-\");\n\n            javaContainerImageBuilder builder = new javaContainerImageBuilder();\n            JavaContainerOptions javaContainerOptions = new JavaContainerOptions(image, imageRepository, tag, libDir);\n            Profile overlayProfile = service.getCurrentContainer().getOverlayProfile();\n\n            String actualImage = builder.generateContainerImage(service, profileOverlays, docker, javaContainerOptions, downloadExecutor);\n            containerConfig.setImage(actualImage);\n        }\n\n        String[] cmd = containerConfig.getCmd();\n        if (cmd == null || cmd.length == 0) {\n            String value = configOverlay.get(DockerConstants.PROPERTIES.CMD);\n            if (Strings.isNullOrBlank(value)) {\n                cmd = null;\n            } else {\n                cmd = new String[]{value};\n            }\n            containerConfig.setCmd(cmd);\n        }\n\n        String zookeeperUrl = service.getZookeeperUrl();\n        String zookeeperPassword = service.getZookeeperPassword();\n        if (zookeeperPassword != null) {\n            zookeeperPassword = PasswordEncoder.encode(zookeeperPassword);\n        }\n\n\n        String localIp = service.getCurrentContainer().getLocalIp();\n        if (!Strings.isNullOrBlank(localIp)) {\n            int idx = zookeeperUrl.lastIndexOf(':');\n            if (idx > 0) {\n                localIp += zookeeperUrl.substring(idx);\n            }\n            zookeeperUrl = localIp;\n        }\n\n        envVarsOverlay.put(DockerConstants.ENV_VARS.KARAF_NAME, options.getName());\n        if (!options.isEnsembleServer()) {\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_URL) == null) {\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_URL, zookeeperUrl);\n            }\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD) == null) {\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD, zookeeperPassword);\n            }\n            if (envVarsOverlay.get(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD_ENCODE) == null) {\n                String zkPasswordEncode = System.getProperty(\"zookeeper.password.encode\", \"true\");\n                envVarsOverlay.put(DockerConstants.ENV_VARS.ZOOKEEPER_PASSWORD_ENCODE, zkPasswordEncode);\n            }\n        }\n        List<String> env = containerConfig.getEnv();\n        if (env == null) {\n            env = new ArrayList<String>();\n        }\n        Set<Map.Entry<String, String>> entries = envVarsOverlay.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key != null && value != null) {\n                env.add(key + \"=\" + value);\n            }\n        }\n\n        Map<String, Object> exposedPorts = new HashMap<String, Object>();\n        Set<Integer> usedPortByHost = findUsedPortByHostAndDocker();\n        Map<String, Integer> internalPorts = options.getInternalPorts();\n        Map<String, Integer> externalPorts = options.getExternalPorts();\n        Map<String,String> emptyMap = new HashMap<String, String>();\n\n        SortedMap<Integer, String> sortedInternalPorts = new TreeMap<Integer, String>();\n        for (Map.Entry<String, String> portEntry : ports.entrySet()) {\n            String portName = portEntry.getKey();\n            String portText = portEntry.getValue();\n            if (portText != null && !Strings.isNullOrBlank(portText)) {\n                Integer port = null;\n                try {\n                    port = Integer.parseInt(portText);\n                } catch (NumberFormatException e) {\n                    LOG.warn(\"Ignoring bad port number for \" + portName + \" value '\" + portText + \"' in PID: \" + DockerConstants.PORTS_PID);\n                }\n                if (port != null) {\n                    sortedInternalPorts.put(port, portName);\n                    internalPorts.put(portName, port);\n                    exposedPorts.put(portText + \"/tcp\", emptyMap);\n                } else {\n                    LOG.info(\"No port for \" + portName);\n                }\n            }\n        }\n        // lets create the ports in sorted order\n        for (Map.Entry<Integer, String> entry : sortedInternalPorts.entrySet()) {\n            Integer port = entry.getKey();\n            String portName = entry.getValue();\n            int externalPort = createExternalPort(containerId, portName, usedPortByHost, options);\n            externalPorts.put(portName, externalPort);\n            env.add(\"FABRIC8_\" + portName + \"_PORT=\" + port);\n            env.add(\"FABRIC8_\" + portName + \"_PROXY_PORT=\" + externalPort);\n        }\n\n        String dockerHost = dockerFactory.getDockerHost();\n        LOG.info(\"Passing in manual ip: \" + dockerHost);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_MANUALIP + \"=\" + dockerHost);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_GLOBAL_RESOLVER + \"=\" + ZkDefs.MANUAL_IP);\n        env.add(DockerConstants.ENV_VARS.FABRIC8_FABRIC_ENVIRONMENT + \"=\" + DockerConstants.SCHEME);\n        containerConfig.setExposedPorts(exposedPorts);\n        containerConfig.setEnv(env);\n\n        String name = options.getName();\n\n        LOG.info(\"Creating container on docker: \" + getDockerAddress() + \" name: \" + name + \" env vars: \" + env);\n        LOG.info(\"Creating container with config: \" + containerConfig);\n\n        ContainerCreateStatus status = docker.containerCreate(containerConfig, name);\n        LOG.info(\"Got status: \" + status);\n        options = options.updateManualIp(dockerHost);\n\n        CreateDockerContainerMetadata metadata = newInstance(containerConfig, status);\n        metadata.setContainerName(containerId);\n        metadata.setOverridenResolver(ZkDefs.MANUAL_IP);\n        metadata.setCreateOptions(options);\n        startDockerContainer(status.getId(), options);\n        return metadata;\n    }","commit_id":"7123b3af60e0340c79dd18e3218730471d3d8d15","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void destroy(Container container) {\n        assertValid();\n        String id = getDockerContainerId(container);\n        if (!Strings.isEmpty(id)) {\n            LOG.info(\"destroying container \" + id);\n            Integer removeVolumes = 1;\n            docker.containerRemove(id, removeVolumes);\n        }\n    }","id":66106,"modified_method":"@Override\n    public void destroy(Container container) {\n        assertValid();\n        String id = getDockerContainerId(container);\n        if (!Strings.isNullOrBlank(id)) {\n            LOG.info(\"destroying container \" + id);\n            Integer removeVolumes = 1;\n            docker.containerRemove(id, removeVolumes);\n        }\n    }","commit_id":"7123b3af60e0340c79dd18e3218730471d3d8d15","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static SNode call_unmeet_1237318764946(SNode thisNode, SNode possiblyMeet) {\n    SNode tmp = possiblyMeet;\nwith_meet:\n    while (SNodeOperations.isInstanceOf(tmp, \"jetbrains.mps.lang.typesystem.structure.MeetType\")) {\n      for(SNode arg : SLinkOperations.getTargets(SNodeOperations.cast(tmp, \"jetbrains.mps.lang.typesystem.structure.MeetType\"), \"argument\", true)) {\n        if (!(SNodeOperations.isInstanceOf(arg, \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n          tmp = arg;\n          continue with_meet;\n        }\n      }\n      return new _Quotations.QuotationClass_2().createNode();\n    }\n    if (SNodeOperations.isInstanceOf(tmp, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")) {\n      List<SNode> params = SLinkOperations.getTargets(SNodeOperations.cast(tmp, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"parameter\", true);\n      for(SNode p : params) {\n        SNode up = FunctionType_Behavior.call_unmeet_1237318764946(thisNode, p);\n        if (up != p) {\n          SNodeOperations.replaceWithAnother(p, up);\n        }\n      }\n    }\n    return tmp;\n  }","id":66107,"modified_method":"public static SNode call_unmeet_1237318764946(SNode thisNode, SNode possiblyMeet) {\n    SNode tmp = possiblyMeet;\nwith_meet:\n    while (SNodeOperations.isInstanceOf(tmp, \"jetbrains.mps.lang.typesystem.structure.MeetType\")) {\n      for(SNode arg : SLinkOperations.getTargets(SNodeOperations.cast(tmp, \"jetbrains.mps.lang.typesystem.structure.MeetType\"), \"argument\", true)) {\n        if (!(SNodeOperations.isInstanceOf(arg, \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n          tmp = arg;\n          continue with_meet;\n        }\n      }\n      return new _Quotations.QuotationClass_3().createNode();\n    }\n    if (SNodeOperations.isInstanceOf(tmp, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")) {\n      List<SNode> params = SLinkOperations.getTargets(SNodeOperations.cast(tmp, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"parameter\", true);\n      for(SNode p : params) {\n        SNode up = FunctionType_Behavior.call_unmeet_1237318764946(thisNode, p);\n        if (up != p) {\n          SNodeOperations.replaceWithAnother(p, up);\n        }\n      }\n    }\n    return tmp;\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getNormalizedTerminateType_1232036646585(SNode thisNode) {\n    return ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null) ?\n      ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode)) :\n      new _Quotations.QuotationClass_7().createNode()\n    );\n  }","id":66108,"modified_method":"public static SNode call_getNormalizedTerminateType_1232036646585(SNode thisNode) {\n    return ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null) ?\n      ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode)) :\n      new _Quotations.QuotationClass_8().createNode()\n    );\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getDeclarationRuntimeType_1230319610063(SNode thisNode) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = MapSequence.fromMap(RuntimeUtils.getRuntimeClassifiersMap()).get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_3().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode)), true));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode)), true));\n    }\n    for(SNode pt : SLinkOperations.getTargets(thisNode, \"parameterType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt), false));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt, true));\n    }\n    return ct;\n  }","id":66109,"modified_method":"public static SNode call_getDeclarationRuntimeType_1230319610063(SNode thisNode) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = RuntimeUtils.getRuntimeClassifiersMap().get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_4().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode)), true));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode)), true));\n    }\n    for(SNode pt : SLinkOperations.getTargets(thisNode, \"parameterType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt), false));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt, true));\n    }\n    return ct;\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_getClassExpression_1213877337357(SNode thisNode) {\n    return new _Quotations.QuotationClass_1().createNode();\n  }","id":66110,"modified_method":"public static SNode virtual_getClassExpression_1213877337357(SNode thisNode) {\n    return new _Quotations.QuotationClass_2().createNode();\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getRuntimeType_1230320203983(SNode thisNode, List<SNode> parameterType) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = MapSequence.fromMap(RuntimeUtils.getRuntimeClassifiersMap()).get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_5().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode))));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode))));\n    }\n    for(SNode pt : parameterType) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt)));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt));\n    }\n    return ct;\n  }","id":66111,"modified_method":"public static SNode call_getRuntimeType_1230320203983(SNode thisNode, List<SNode> parameterType) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = RuntimeUtils.getRuntimeClassifiersMap().get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_6().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode))));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode))));\n    }\n    for(SNode pt : parameterType) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt)));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt));\n    }\n    return ct;\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getNormalizedReturnType_1213877405252(SNode thisNode) {\n    return ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null) ?\n      ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode)) :\n      new _Quotations.QuotationClass_6().createNode()\n    );\n  }","id":66112,"modified_method":"public static SNode call_getNormalizedReturnType_1213877405252(SNode thisNode) {\n    return ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null) ?\n      ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode)) :\n      new _Quotations.QuotationClass_7().createNode()\n    );\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getRuntimeType_1230319150573(SNode thisNode) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = MapSequence.fromMap(RuntimeUtils.getRuntimeClassifiersMap()).get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_4().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode))));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode))));\n    }\n    for(SNode pt : SLinkOperations.getTargets(thisNode, \"parameterType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt)));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt));\n    }\n    return ct;\n  }","id":66113,"modified_method":"public static SNode call_getRuntimeType_1230319150573(SNode thisNode) {\n    String rtCls = FunctionType_Behavior.call_getRuntimeClassName_1230472987259(thisNode) + \".\" + FunctionType_Behavior.call_getRuntimeSignature_1213877404927(thisNode);\n    SNode ice = RuntimeUtils.getRuntimeClassifiersMap().get(rtCls);\n    if (ice == null) {\n      return null;\n    }\n    SNode ct = new _Quotations.QuotationClass_5().createNode(ice);\n    if ((FunctionType_Behavior.call_getResultType_1230475757059(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getResultType_1230475757059(thisNode))));\n    }\n    if ((FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode) != null)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(FunctionType_Behavior.call_getTerminateType_1232032188607(thisNode))));\n    }\n    for(SNode pt : SLinkOperations.getTargets(thisNode, \"parameterType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(ClassifierTypeUtil.getTypeCoercedToClassifierType(pt)));\n    }\n    for(SNode tt : SLinkOperations.getTargets(thisNode, \"throwsType\", true)) {\n      SLinkOperations.addChild(ct, \"parameter\", ClassifierTypeUtil.copyTypeRecursively(tt));\n    }\n    return ct;\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SModel getRuntimeModel() {\n    return SNodeOperations.getModel(SLinkOperations.getTarget(new _Quotations.QuotationClass_9().createNode(), \"classifier\", false));\n  }","id":66114,"modified_method":"public static SModel getRuntimeModel() {\n    return SNodeOperations.getModel(SLinkOperations.getTarget(new _Quotations.QuotationClass_10().createNode(), \"classifier\", false));\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_getType_1229718192182(SNode thisNode, List<SNode> paramTypes, SNode resultType, SNode returnType, SNode termType, List<SNode> throwsTypes) {\n    return new _Quotations.QuotationClass_8().createNode(paramTypes, termType, returnType, throwsTypes);\n  }","id":66115,"modified_method":"public static SNode virtual_getType_1229718192182(SNode thisNode, List<SNode> paramTypes, SNode resultType, SNode returnType, SNode termType, List<SNode> throwsTypes) {\n    return new _Quotations.QuotationClass_9().createNode(paramTypes, termType, returnType, throwsTypes);\n  }","commit_id":"a16600bcd3fcedf67cc91045b4b8fb2f403b61a7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * @param metaBlockName\n   * @param cacheBlock Add block to cache, if found\n   * @return Block wrapped in a ByteBuffer\n   * @throws IOException\n   */\n  @Override\n  public ByteBuffer getMetaBlock(String metaBlockName, boolean cacheBlock)\n      throws IOException {\n    if (trailer.getMetaIndexCount() == 0) {\n      return null; // there are no meta blocks\n    }\n    if (metaBlockIndexReader == null) {\n      throw new IOException(\"Meta index not loaded\");\n    }\n\n    byte[] nameBytes = Bytes.toBytes(metaBlockName);\n    int block = metaBlockIndexReader.rootBlockContainingKey(nameBytes, 0,\n        nameBytes.length);\n    if (block == -1)\n      return null;\n    long offset = metaBlockIndexReader.getRootBlockOffset(block);\n    long nextOffset;\n    if (block == metaBlockIndexReader.getRootBlockCount() - 1) {\n      nextOffset = trailer.getFileInfoOffset();\n    } else {\n      nextOffset = metaBlockIndexReader.getRootBlockOffset(block + 1);\n    }\n\n    long startTimeNs = System.nanoTime();\n\n    String cacheKey = HFile.getBlockCacheKey(name, offset);\n\n    // Per meta key from any given file, synchronize reads for said block\n    synchronized (metaBlockIndexReader.getRootBlockKey(block)) {\n      metaLoads.incrementAndGet();\n\n      // Check cache for block.  If found return.\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey,\n              cacheConf.shouldCacheDataOnRead());\n        if (cachedBlock != null) {\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.META, false);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Cache Miss, please load.\n      }\n\n      HFileBlock hfileBlock = fsBlockReader.readBlockData(offset,\n          nextOffset - offset, metaBlockIndexReader.getRootBlockDataSize(block),\n          true);\n      passSchemaMetricsTo(hfileBlock);\n      hfileBlock.expectType(BlockType.META);\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.readTimeNano.addAndGet(delta);\n      HFile.readOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.META, false, delta);\n\n      // Cache the block\n      if (cacheConf.shouldCacheDataOnRead() && cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, hfileBlock,\n            cacheConf.isInMemory());\n      }\n\n      return hfileBlock.getBufferWithoutHeader();\n    }\n  }","id":66116,"modified_method":"/**\n   * @param metaBlockName\n   * @param cacheBlock Add block to cache, if found\n   * @return Block wrapped in a ByteBuffer\n   * @throws IOException\n   */\n  @Override\n  public ByteBuffer getMetaBlock(String metaBlockName, boolean cacheBlock)\n      throws IOException {\n    if (trailer.getMetaIndexCount() == 0) {\n      return null; // there are no meta blocks\n    }\n    if (metaBlockIndexReader == null) {\n      throw new IOException(\"Meta index not loaded\");\n    }\n\n    byte[] nameBytes = Bytes.toBytes(metaBlockName);\n    int block = metaBlockIndexReader.rootBlockContainingKey(nameBytes, 0,\n        nameBytes.length);\n    if (block == -1)\n      return null;\n    long offset = metaBlockIndexReader.getRootBlockOffset(block);\n    long nextOffset;\n    if (block == metaBlockIndexReader.getRootBlockCount() - 1) {\n      nextOffset = trailer.getFileInfoOffset();\n    } else {\n      nextOffset = metaBlockIndexReader.getRootBlockOffset(block + 1);\n    }\n\n    long startTimeNs = System.nanoTime();\n\n    String cacheKey = HFile.getBlockCacheKey(name, offset);\n\n    // Per meta key from any given file, synchronize reads for said block\n    synchronized (metaBlockIndexReader.getRootBlockKey(block)) {\n      metaLoads.incrementAndGet();\n\n      // Check cache for block.  If found return.\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey,\n              cacheConf.shouldCacheDataOnRead());\n        if (cachedBlock != null) {\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.META, false);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Cache Miss, please load.\n      }\n\n      HFileBlock hfileBlock = fsBlockReader.readBlockData(offset,\n          nextOffset - offset, metaBlockIndexReader.getRootBlockDataSize(block),\n          true);\n      passSchemaMetricsTo(hfileBlock);\n      hfileBlock.expectType(BlockType.META);\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.preadTimeNano.addAndGet(delta);\n      HFile.preadOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.META, false, delta);\n\n      // Cache the block\n      if (cacheConf.shouldCacheDataOnRead() && cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, hfileBlock,\n            cacheConf.isInMemory());\n      }\n\n      return hfileBlock.getBufferWithoutHeader();\n    }\n  }","commit_id":"28ee3bf9ba0162d35b880fe5d9ed6f1c03b217f3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Read in a file block.\n   * @param block Index of block to read.\n   * @param pread Use positional read instead of seek+read (positional is\n   * better doing random reads whereas seek+read is better scanning).\n   * @param isCompaction is this block being read as part of a compaction\n   * @return Block wrapped in a ByteBuffer.\n   * @throws IOException\n   */\n  ByteBuffer readBlockBuffer(int block, boolean cacheBlock,\n      final boolean pread, final boolean isCompaction) throws IOException {\n    if (dataBlockIndexReader == null) {\n      throw new IOException(\"Block index not loaded\");\n    }\n    if (block < 0 || block >= dataBlockIndexReader.getRootBlockCount()) {\n      throw new IOException(\"Requested block is out of range: \" + block +\n        \", max: \" + dataBlockIndexReader.getRootBlockCount());\n    }\n\n    long offset = dataBlockIndexReader.getRootBlockOffset(block);\n    String cacheKey = HFile.getBlockCacheKey(name, offset);\n\n    // For any given block from any given file, synchronize reads for said\n    // block.\n    // Without a cache, this synchronizing is needless overhead, but really\n    // the other choice is to duplicate work (which the cache would prevent you\n    // from doing).\n    synchronized (dataBlockIndexReader.getRootBlockKey(block)) {\n      blockLoads.incrementAndGet();\n\n      // Check cache for block.  If found return.\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey,\n              cacheConf.shouldCacheDataOnRead());\n        if (cachedBlock != null) {\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.DATA,\n              isCompaction);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Carry on, please load.\n      }\n\n      // Load block from filesystem.\n      long startTimeNs = System.nanoTime();\n      long nextOffset;\n\n      if (block == dataBlockIndexReader.getRootBlockCount() - 1) {\n        // last block!  The end of data block is first meta block if there is\n        // one or if there isn't, the fileinfo offset.\n        nextOffset = (metaBlockIndexReader.getRootBlockCount() == 0) ?\n            this.trailer.getFileInfoOffset() :\n            metaBlockIndexReader.getRootBlockOffset(0);\n      } else {\n        nextOffset = dataBlockIndexReader.getRootBlockOffset(block + 1);\n      }\n\n      HFileBlock hfileBlock = fsBlockReader.readBlockData(offset, nextOffset\n          - offset, dataBlockIndexReader.getRootBlockDataSize(block), pread);\n      passSchemaMetricsTo(hfileBlock);\n      hfileBlock.expectType(BlockType.DATA);\n      ByteBuffer buf = hfileBlock.getBufferWithoutHeader();\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.readTimeNano.addAndGet(delta);\n      HFile.readOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.DATA, isCompaction,\n          delta);\n\n      // Cache the block\n      if (cacheConf.shouldCacheDataOnRead() && cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, hfileBlock,\n            cacheConf.isInMemory());\n      }\n\n      return buf;\n    }\n  }","id":66117,"modified_method":"/**\n   * Read in a file block.\n   * @param block Index of block to read.\n   * @param pread Use positional read instead of seek+read (positional is\n   * better doing random reads whereas seek+read is better scanning).\n   * @param isCompaction is this block being read as part of a compaction\n   * @return Block wrapped in a ByteBuffer.\n   * @throws IOException\n   */\n  ByteBuffer readBlockBuffer(int block, boolean cacheBlock,\n      final boolean pread, final boolean isCompaction) throws IOException {\n    if (dataBlockIndexReader == null) {\n      throw new IOException(\"Block index not loaded\");\n    }\n    if (block < 0 || block >= dataBlockIndexReader.getRootBlockCount()) {\n      throw new IOException(\"Requested block is out of range: \" + block +\n        \", max: \" + dataBlockIndexReader.getRootBlockCount());\n    }\n\n    long offset = dataBlockIndexReader.getRootBlockOffset(block);\n    String cacheKey = HFile.getBlockCacheKey(name, offset);\n\n    // For any given block from any given file, synchronize reads for said\n    // block.\n    // Without a cache, this synchronizing is needless overhead, but really\n    // the other choice is to duplicate work (which the cache would prevent you\n    // from doing).\n    synchronized (dataBlockIndexReader.getRootBlockKey(block)) {\n      blockLoads.incrementAndGet();\n\n      // Check cache for block.  If found return.\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey,\n              cacheConf.shouldCacheDataOnRead());\n        if (cachedBlock != null) {\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.DATA,\n              isCompaction);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Carry on, please load.\n      }\n\n      // Load block from filesystem.\n      long startTimeNs = System.nanoTime();\n      long nextOffset;\n\n      if (block == dataBlockIndexReader.getRootBlockCount() - 1) {\n        // last block!  The end of data block is first meta block if there is\n        // one or if there isn't, the fileinfo offset.\n        nextOffset = (metaBlockIndexReader.getRootBlockCount() == 0) ?\n            this.trailer.getFileInfoOffset() :\n            metaBlockIndexReader.getRootBlockOffset(0);\n      } else {\n        nextOffset = dataBlockIndexReader.getRootBlockOffset(block + 1);\n      }\n\n      HFileBlock hfileBlock = fsBlockReader.readBlockData(offset, nextOffset\n          - offset, dataBlockIndexReader.getRootBlockDataSize(block), pread);\n      passSchemaMetricsTo(hfileBlock);\n      hfileBlock.expectType(BlockType.DATA);\n      ByteBuffer buf = hfileBlock.getBufferWithoutHeader();\n\n      long delta = System.nanoTime() - startTimeNs;\n      if (pread) {\n        HFile.preadTimeNano.addAndGet(delta);\n        HFile.preadOps.incrementAndGet();\n      } else {\n        HFile.readTimeNano.addAndGet(delta);\n        HFile.readOps.incrementAndGet();\n      }\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.DATA, isCompaction,\n          delta);\n\n      // Cache the block\n      if (cacheConf.shouldCacheDataOnRead() && cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, hfileBlock,\n            cacheConf.isInMemory());\n      }\n\n      return buf;\n    }\n  }","commit_id":"28ee3bf9ba0162d35b880fe5d9ed6f1c03b217f3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Read in a file block.\n   *\n   * @param dataBlockOffset offset to read.\n   * @param onDiskBlockSize size of the block\n   * @param cacheBlock\n   * @param pread Use positional read instead of seek+read (positional is better\n   *          doing random reads whereas seek+read is better scanning).\n   * @param isCompaction is this block being read as part of a compaction\n   * @return Block wrapped in a ByteBuffer.\n   * @throws IOException\n   */\n  @Override\n  public HFileBlock readBlock(long dataBlockOffset, long onDiskBlockSize,\n      boolean cacheBlock, boolean pread, final boolean isCompaction)\n      throws IOException {\n    if (dataBlockIndexReader == null) {\n      throw new IOException(\"Block index not loaded\");\n    }\n    if (dataBlockOffset < 0\n        || dataBlockOffset >= trailer.getLoadOnOpenDataOffset()) {\n      throw new IOException(\"Requested block is out of range: \"\n          + dataBlockOffset + \", lastDataBlockOffset: \"\n          + trailer.getLastDataBlockOffset());\n    }\n    // For any given block from any given file, synchronize reads for said\n    // block.\n    // Without a cache, this synchronizing is needless overhead, but really\n    // the other choice is to duplicate work (which the cache would prevent you\n    // from doing).\n\n    String cacheKey = HFile.getBlockCacheKey(name, dataBlockOffset);\n    IdLock.Entry lockEntry = offsetLock.getLockEntry(dataBlockOffset);\n    try {\n      blockLoads.incrementAndGet();\n\n      // Check cache for block. If found return.\n      cacheBlock &= cacheConf.shouldCacheDataOnRead();\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey, cacheBlock);\n        if (cachedBlock != null) {\n          BlockCategory blockCategory =\n              cachedBlock.getBlockType().getCategory();\n          cacheHits.incrementAndGet();\n\n          getSchemaMetrics().updateOnCacheHit(blockCategory, isCompaction);\n\n          if (cachedBlock.getBlockType() == BlockType.DATA)\n            HFile.dataBlockReadCnt.incrementAndGet();\n          return cachedBlock;\n        }\n        // Carry on, please load.\n      }\n\n      // Load block from filesystem.\n      long startTimeNs = System.nanoTime();\n      HFileBlock dataBlock = fsBlockReader.readBlockData(dataBlockOffset,\n          onDiskBlockSize, -1, pread);\n      passSchemaMetricsTo(dataBlock);\n      BlockCategory blockCategory = dataBlock.getBlockType().getCategory();\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.readTimeNano.addAndGet(delta);\n      HFile.readOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(blockCategory, isCompaction, delta);\n\n      // Cache the block\n      if (cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, dataBlock,\n            cacheConf.isInMemory());\n      }\n\n      if (dataBlock.getBlockType() == BlockType.DATA)\n        HFile.dataBlockReadCnt.incrementAndGet();\n\n      return dataBlock;\n    } finally {\n      offsetLock.releaseLockEntry(lockEntry);\n    }\n  }","id":66118,"modified_method":"/**\n   * Read in a file block.\n   *\n   * @param dataBlockOffset offset to read.\n   * @param onDiskBlockSize size of the block\n   * @param cacheBlock\n   * @param pread Use positional read instead of seek+read (positional is better\n   *          doing random reads whereas seek+read is better scanning).\n   * @param isCompaction is this block being read as part of a compaction\n   * @return Block wrapped in a ByteBuffer.\n   * @throws IOException\n   */\n  @Override\n  public HFileBlock readBlock(long dataBlockOffset, long onDiskBlockSize,\n      boolean cacheBlock, boolean pread, final boolean isCompaction)\n      throws IOException {\n    if (dataBlockIndexReader == null) {\n      throw new IOException(\"Block index not loaded\");\n    }\n    if (dataBlockOffset < 0\n        || dataBlockOffset >= trailer.getLoadOnOpenDataOffset()) {\n      throw new IOException(\"Requested block is out of range: \"\n          + dataBlockOffset + \", lastDataBlockOffset: \"\n          + trailer.getLastDataBlockOffset());\n    }\n    // For any given block from any given file, synchronize reads for said\n    // block.\n    // Without a cache, this synchronizing is needless overhead, but really\n    // the other choice is to duplicate work (which the cache would prevent you\n    // from doing).\n\n    String cacheKey = HFile.getBlockCacheKey(name, dataBlockOffset);\n    IdLock.Entry lockEntry = offsetLock.getLockEntry(dataBlockOffset);\n    try {\n      blockLoads.incrementAndGet();\n\n      // Check cache for block. If found return.\n      cacheBlock &= cacheConf.shouldCacheDataOnRead();\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey, cacheBlock);\n        if (cachedBlock != null) {\n          BlockCategory blockCategory =\n              cachedBlock.getBlockType().getCategory();\n          cacheHits.incrementAndGet();\n\n          getSchemaMetrics().updateOnCacheHit(blockCategory, isCompaction);\n\n          if (cachedBlock.getBlockType() == BlockType.DATA)\n            HFile.dataBlockReadCnt.incrementAndGet();\n          return cachedBlock;\n        }\n        // Carry on, please load.\n      }\n\n      // Load block from filesystem.\n      long startTimeNs = System.nanoTime();\n      HFileBlock dataBlock = fsBlockReader.readBlockData(dataBlockOffset,\n          onDiskBlockSize, -1, pread);\n      passSchemaMetricsTo(dataBlock);\n      BlockCategory blockCategory = dataBlock.getBlockType().getCategory();\n\n      long delta = System.nanoTime() - startTimeNs;\n      if (pread) {\n        HFile.preadTimeNano.addAndGet(delta);\n        HFile.preadOps.incrementAndGet();\n      } else {\n        HFile.readTimeNano.addAndGet(delta);\n        HFile.readOps.incrementAndGet();\n      }\n      getSchemaMetrics().updateOnCacheMiss(blockCategory, isCompaction, delta);\n\n      // Cache the block\n      if (cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, dataBlock,\n            cacheConf.isInMemory());\n      }\n\n      if (dataBlock.getBlockType() == BlockType.DATA)\n        HFile.dataBlockReadCnt.incrementAndGet();\n\n      return dataBlock;\n    } finally {\n      offsetLock.releaseLockEntry(lockEntry);\n    }\n  }","commit_id":"28ee3bf9ba0162d35b880fe5d9ed6f1c03b217f3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @param metaBlockName\n   * @param cacheBlock Add block to cache, if found\n   * @return block wrapped in a ByteBuffer, with header skipped\n   * @throws IOException\n   */\n  @Override\n  public ByteBuffer getMetaBlock(String metaBlockName, boolean cacheBlock)\n      throws IOException {\n    if (trailer.getMetaIndexCount() == 0) {\n      return null; // there are no meta blocks\n    }\n    if (metaBlockIndexReader == null) {\n      throw new IOException(\"Meta index not loaded\");\n    }\n\n    byte[] mbname = Bytes.toBytes(metaBlockName);\n    int block = metaBlockIndexReader.rootBlockContainingKey(mbname, 0,\n        mbname.length);\n    if (block == -1)\n      return null;\n    long blockSize = metaBlockIndexReader.getRootBlockDataSize(block);\n    long startTimeNs = System.nanoTime();\n\n    // Per meta key from any given file, synchronize reads for said block. This\n    // is OK to do for meta blocks because the meta block index is always\n    // single-level.\n    synchronized (metaBlockIndexReader.getRootBlockKey(block)) {\n      metaLoads.incrementAndGet();\n\n      // Check cache for block. If found return.\n      long metaBlockOffset = metaBlockIndexReader.getRootBlockOffset(block);\n      String cacheKey = HFile.getBlockCacheKey(name, metaBlockOffset);\n\n      cacheBlock &= cacheConf.shouldCacheDataOnRead();\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey, cacheBlock);\n        if (cachedBlock != null) {\n          // Return a distinct 'shallow copy' of the block,\n          // so pos does not get messed by the scanner\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.META, false);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Cache Miss, please load.\n      }\n\n      HFileBlock metaBlock = fsBlockReader.readBlockData(metaBlockOffset,\n          blockSize, -1, true);\n      passSchemaMetricsTo(metaBlock);\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.readTimeNano.addAndGet(delta);\n      HFile.readOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.META, false, delta);\n\n      // Cache the block\n      if (cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, metaBlock,\n            cacheConf.isInMemory());\n      }\n\n      return metaBlock.getBufferWithoutHeader();\n    }\n  }","id":66119,"modified_method":"/**\n   * @param metaBlockName\n   * @param cacheBlock Add block to cache, if found\n   * @return block wrapped in a ByteBuffer, with header skipped\n   * @throws IOException\n   */\n  @Override\n  public ByteBuffer getMetaBlock(String metaBlockName, boolean cacheBlock)\n      throws IOException {\n    if (trailer.getMetaIndexCount() == 0) {\n      return null; // there are no meta blocks\n    }\n    if (metaBlockIndexReader == null) {\n      throw new IOException(\"Meta index not loaded\");\n    }\n\n    byte[] mbname = Bytes.toBytes(metaBlockName);\n    int block = metaBlockIndexReader.rootBlockContainingKey(mbname, 0,\n        mbname.length);\n    if (block == -1)\n      return null;\n    long blockSize = metaBlockIndexReader.getRootBlockDataSize(block);\n    long startTimeNs = System.nanoTime();\n\n    // Per meta key from any given file, synchronize reads for said block. This\n    // is OK to do for meta blocks because the meta block index is always\n    // single-level.\n    synchronized (metaBlockIndexReader.getRootBlockKey(block)) {\n      metaLoads.incrementAndGet();\n\n      // Check cache for block. If found return.\n      long metaBlockOffset = metaBlockIndexReader.getRootBlockOffset(block);\n      String cacheKey = HFile.getBlockCacheKey(name, metaBlockOffset);\n\n      cacheBlock &= cacheConf.shouldCacheDataOnRead();\n      if (cacheConf.isBlockCacheEnabled()) {\n        HFileBlock cachedBlock =\n          (HFileBlock) cacheConf.getBlockCache().getBlock(cacheKey, cacheBlock);\n        if (cachedBlock != null) {\n          // Return a distinct 'shallow copy' of the block,\n          // so pos does not get messed by the scanner\n          cacheHits.incrementAndGet();\n          getSchemaMetrics().updateOnCacheHit(BlockCategory.META, false);\n          return cachedBlock.getBufferWithoutHeader();\n        }\n        // Cache Miss, please load.\n      }\n\n      HFileBlock metaBlock = fsBlockReader.readBlockData(metaBlockOffset,\n          blockSize, -1, true);\n      passSchemaMetricsTo(metaBlock);\n\n      long delta = System.nanoTime() - startTimeNs;\n      HFile.preadTimeNano.addAndGet(delta);\n      HFile.preadOps.incrementAndGet();\n      getSchemaMetrics().updateOnCacheMiss(BlockCategory.META, false, delta);\n\n      // Cache the block\n      if (cacheBlock) {\n        cacheConf.getBlockCache().cacheBlock(cacheKey, metaBlock,\n            cacheConf.isInMemory());\n      }\n\n      return metaBlock.getBufferWithoutHeader();\n    }\n  }","commit_id":"28ee3bf9ba0162d35b880fe5d9ed6f1c03b217f3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Since this object is a registered updater, this method will be called\n   * periodically, e.g. every 5 seconds.\n   * @param caller the metrics context that this responsible for calling us\n   */\n  public void doUpdates(MetricsContext caller) {\n    synchronized (this) {\n      this.lastUpdate = System.currentTimeMillis();\n\n      // has the extended period for long-living stats elapsed?\n      if (this.extendedPeriod > 0 &&\n          this.lastUpdate - this.lastExtUpdate >= this.extendedPeriod) {\n        this.lastExtUpdate = this.lastUpdate;\n        this.compactionTime.resetMinMaxAvg();\n        this.compactionSize.resetMinMaxAvg();\n        this.flushTime.resetMinMaxAvg();\n        this.flushSize.resetMinMaxAvg();\n        this.resetAllMinMax();\n      }\n\n      this.stores.pushMetric(this.metricsRecord);\n      this.storefiles.pushMetric(this.metricsRecord);\n      this.storefileIndexSizeMB.pushMetric(this.metricsRecord);\n      this.rootIndexSizeKB.pushMetric(this.metricsRecord);\n      this.totalStaticIndexSizeKB.pushMetric(this.metricsRecord);\n      this.totalStaticBloomSizeKB.pushMetric(this.metricsRecord);\n      this.memstoreSizeMB.pushMetric(this.metricsRecord);\n      this.readRequestsCount.pushMetric(this.metricsRecord);\n      this.writeRequestsCount.pushMetric(this.metricsRecord);\n      this.regions.pushMetric(this.metricsRecord);\n      this.requests.pushMetric(this.metricsRecord);\n      this.compactionQueueSize.pushMetric(this.metricsRecord);\n      this.flushQueueSize.pushMetric(this.metricsRecord);\n      this.blockCacheSize.pushMetric(this.metricsRecord);\n      this.blockCacheFree.pushMetric(this.metricsRecord);\n      this.blockCacheCount.pushMetric(this.metricsRecord);\n      this.blockCacheHitCount.pushMetric(this.metricsRecord);\n      this.blockCacheMissCount.pushMetric(this.metricsRecord);\n      this.blockCacheEvictedCount.pushMetric(this.metricsRecord);\n      this.blockCacheHitRatio.pushMetric(this.metricsRecord);\n      this.blockCacheHitCachingRatio.pushMetric(this.metricsRecord);\n      this.hdfsBlocksLocalityIndex.pushMetric(this.metricsRecord);\n      this.blockCacheHitRatioPastNPeriods.pushMetric(this.metricsRecord);\n      this.blockCacheHitCachingRatioPastNPeriods.pushMetric(this.metricsRecord);\n\n      // Mix in HFile and HLog metrics\n      // Be careful. Here is code for MTVR from up in hadoop:\n      // public synchronized void inc(final int numOps, final long time) {\n      //   currentData.numOperations += numOps;\n      //   currentData.time += time;\n      //   long timePerOps = time/numOps;\n      //    minMax.update(timePerOps);\n      // }\n      // Means you can't pass a numOps of zero or get a ArithmeticException / by zero.\n      // HLog metrics\n      addHLogMetric(HLog.getWriteTime(), this.fsWriteLatency);\n      addHLogMetric(HLog.getWriteSize(), this.fsWriteSize);\n      addHLogMetric(HLog.getSyncTime(), this.fsSyncLatency);\n      // HFile metrics\n      int ops = HFile.getReadOps();\n      if (ops != 0) this.fsReadLatency.inc(ops, HFile.getReadTimeMs());\n      /* NOTE: removed HFile write latency.  2 reasons:\n       * 1) Mixing HLog latencies are far higher priority since they're \n       *      on-demand and HFile is used in background (compact/flush)\n       * 2) HFile metrics are being handled at a higher level \n       *      by compaction & flush metrics.\n       */\n\n      // push the result\n      this.fsReadLatency.pushMetric(this.metricsRecord);\n      this.fsWriteLatency.pushMetric(this.metricsRecord);\n      this.fsWriteSize.pushMetric(this.metricsRecord);\n      this.fsSyncLatency.pushMetric(this.metricsRecord);\n      this.compactionTime.pushMetric(this.metricsRecord);\n      this.compactionSize.pushMetric(this.metricsRecord);\n      this.flushTime.pushMetric(this.metricsRecord);\n      this.flushSize.pushMetric(this.metricsRecord);\n    }\n    this.metricsRecord.update();\n  }","id":66120,"modified_method":"/**\n   * Since this object is a registered updater, this method will be called\n   * periodically, e.g. every 5 seconds.\n   * @param caller the metrics context that this responsible for calling us\n   */\n  public void doUpdates(MetricsContext caller) {\n    synchronized (this) {\n      this.lastUpdate = System.currentTimeMillis();\n\n      // has the extended period for long-living stats elapsed?\n      if (this.extendedPeriod > 0 &&\n          this.lastUpdate - this.lastExtUpdate >= this.extendedPeriod) {\n        this.lastExtUpdate = this.lastUpdate;\n        this.compactionTime.resetMinMaxAvg();\n        this.compactionSize.resetMinMaxAvg();\n        this.flushTime.resetMinMaxAvg();\n        this.flushSize.resetMinMaxAvg();\n        this.resetAllMinMax();\n      }\n\n      this.stores.pushMetric(this.metricsRecord);\n      this.storefiles.pushMetric(this.metricsRecord);\n      this.storefileIndexSizeMB.pushMetric(this.metricsRecord);\n      this.rootIndexSizeKB.pushMetric(this.metricsRecord);\n      this.totalStaticIndexSizeKB.pushMetric(this.metricsRecord);\n      this.totalStaticBloomSizeKB.pushMetric(this.metricsRecord);\n      this.memstoreSizeMB.pushMetric(this.metricsRecord);\n      this.readRequestsCount.pushMetric(this.metricsRecord);\n      this.writeRequestsCount.pushMetric(this.metricsRecord);\n      this.regions.pushMetric(this.metricsRecord);\n      this.requests.pushMetric(this.metricsRecord);\n      this.compactionQueueSize.pushMetric(this.metricsRecord);\n      this.flushQueueSize.pushMetric(this.metricsRecord);\n      this.blockCacheSize.pushMetric(this.metricsRecord);\n      this.blockCacheFree.pushMetric(this.metricsRecord);\n      this.blockCacheCount.pushMetric(this.metricsRecord);\n      this.blockCacheHitCount.pushMetric(this.metricsRecord);\n      this.blockCacheMissCount.pushMetric(this.metricsRecord);\n      this.blockCacheEvictedCount.pushMetric(this.metricsRecord);\n      this.blockCacheHitRatio.pushMetric(this.metricsRecord);\n      this.blockCacheHitCachingRatio.pushMetric(this.metricsRecord);\n      this.hdfsBlocksLocalityIndex.pushMetric(this.metricsRecord);\n      this.blockCacheHitRatioPastNPeriods.pushMetric(this.metricsRecord);\n      this.blockCacheHitCachingRatioPastNPeriods.pushMetric(this.metricsRecord);\n\n      // Mix in HFile and HLog metrics\n      // Be careful. Here is code for MTVR from up in hadoop:\n      // public synchronized void inc(final int numOps, final long time) {\n      //   currentData.numOperations += numOps;\n      //   currentData.time += time;\n      //   long timePerOps = time/numOps;\n      //    minMax.update(timePerOps);\n      // }\n      // Means you can't pass a numOps of zero or get a ArithmeticException / by zero.\n      // HLog metrics\n      addHLogMetric(HLog.getWriteTime(), this.fsWriteLatency);\n      addHLogMetric(HLog.getWriteSize(), this.fsWriteSize);\n      addHLogMetric(HLog.getSyncTime(), this.fsSyncLatency);\n      // HFile metrics, sequential reads\n      int ops = HFile.getReadOps(); \n      if (ops != 0) this.fsReadLatency.inc(ops, HFile.getReadTimeMs());\n      // HFile metrics, positional reads\n      ops = HFile.getPreadOps(); \n      if (ops != 0) this.fsPreadLatency.inc(ops, HFile.getPreadTimeMs());\n      /* NOTE: removed HFile write latency.  2 reasons:\n       * 1) Mixing HLog latencies are far higher priority since they're \n       *      on-demand and HFile is used in background (compact/flush)\n       * 2) HFile metrics are being handled at a higher level \n       *      by compaction & flush metrics.\n       */\n\n      // push the result\n      this.fsReadLatency.pushMetric(this.metricsRecord);\n      this.fsWriteLatency.pushMetric(this.metricsRecord);\n      this.fsWriteSize.pushMetric(this.metricsRecord);\n      this.fsSyncLatency.pushMetric(this.metricsRecord);\n      this.compactionTime.pushMetric(this.metricsRecord);\n      this.compactionSize.pushMetric(this.metricsRecord);\n      this.flushTime.pushMetric(this.metricsRecord);\n      this.flushSize.pushMetric(this.metricsRecord);\n    }\n    this.metricsRecord.update();\n  }","commit_id":"28ee3bf9ba0162d35b880fe5d9ed6f1c03b217f3","url":"https://github.com/apache/hbase"},{"original_method":"public void handleFragmentTaskMessage(FragmentTaskMessage message,\n                                          Map<Integer, List<VoltTable>> inputDeps)\n    {\n        // If we have input dependencies, it's borrow work, there's no way we\n        // can actually distribute it\n        if (m_replicaHSIds.length > 0 && inputDeps == null) {\n            try {\n                FragmentTaskMessage replmsg =\n                    new FragmentTaskMessage(m_mailbox.getHSId(),\n                            m_mailbox.getHSId(), message);\n                m_mailbox.send(m_replicaHSIds, replmsg);\n            } catch (MessagingException e) {\n                hostLog.error(\"Failed to deliver response from execution site.\", e);\n            }\n        }\n\n        TransactionState txn = m_outstandingTxns.get(message.getTxnId());\n        // bit of a hack...we will probably not want to create and\n        // offer FragmentTasks for txn ids that don't match if we have\n        // something in progress already\n        if (txn == null) {\n            long localTxnId = m_txnId.incrementAndGet();\n            txn = new ParticipantTransactionState(localTxnId, message);\n            m_outstandingTxns.put(message.getTxnId(), txn);\n        }\n        if (message.isSysProcTask()) {\n            final SysprocFragmentTask task =\n                new SysprocFragmentTask(m_mailbox, (ParticipantTransactionState)txn,\n                                        m_pendingTasks, message, inputDeps);\n            m_pendingTasks.offer(task);\n        }\n        else {\n            final FragmentTask task =\n                new FragmentTask(m_mailbox, (ParticipantTransactionState)txn,\n                                 m_pendingTasks, message, inputDeps);\n            m_pendingTasks.offer(task);\n        }\n    }","id":66121,"modified_method":"public void handleFragmentTaskMessage(FragmentTaskMessage message,\n                                          Map<Integer, List<VoltTable>> inputDeps)\n    {\n        long newSpHandle;\n        if (m_isLeader) {\n            newSpHandle = m_txnId.incrementAndGet();\n            message.setSpHandle(newSpHandle);\n            // If we have input dependencies, it's borrow work, there's no way we\n            // can actually distribute it\n            if (m_replicaHSIds.length > 0 && inputDeps == null) {\n                try {\n                    FragmentTaskMessage replmsg =\n                        new FragmentTaskMessage(m_mailbox.getHSId(),\n                                m_mailbox.getHSId(), message);\n                    m_mailbox.send(m_replicaHSIds, replmsg);\n                } catch (MessagingException e) {\n                    hostLog.error(\"Failed to deliver response from execution site.\", e);\n                }\n                DuplicateCounter counter = new DuplicateCounter(\n                        message.getCoordinatorHSId(), m_replicaHSIds.length + 1,\n                        message.getTxnId());\n                m_duplicateCounters.put(newSpHandle, counter);\n            }\n        }\n        else {\n            newSpHandle = message.getSpHandle();\n        }\n\n        TransactionState txn = m_outstandingTxns.get(message.getTxnId());\n        // bit of a hack...we will probably not want to create and\n        // offer FragmentTasks for txn ids that don't match if we have\n        // something in progress already\n        if (txn == null) {\n            txn = new ParticipantTransactionState(newSpHandle, message);\n            m_outstandingTxns.put(message.getTxnId(), txn);\n        }\n\n        if (message.isSysProcTask()) {\n            final SysprocFragmentTask task =\n                new SysprocFragmentTask(m_mailbox, (ParticipantTransactionState)txn,\n                                        m_pendingTasks, message, inputDeps);\n            m_pendingTasks.offer(task);\n        }\n        else {\n            final FragmentTask task =\n                new FragmentTask(m_mailbox, (ParticipantTransactionState)txn,\n                                 m_pendingTasks, message, inputDeps);\n            m_pendingTasks.offer(task);\n        }\n    }","commit_id":"a78ad4015e3bf5d2c30ce89b6ebe239dfa1c93b9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void handleFragmentResponseMessage(FragmentResponseMessage message)\n    {\n        // Add duplicate counter code here\n        // ADD CODE HERE\n\n        if (message.getDestinationSiteId() != m_mailbox.getHSId()) {\n            try {\n                m_mailbox.send(message.getDestinationSiteId(), message);\n            }\n            catch (MessagingException e) {\n                hostLog.error(\"Failed to deliver response from execution site.\", e);\n            }\n        }\n    }","id":66122,"modified_method":"public void handleFragmentResponseMessage(FragmentResponseMessage message)\n    {\n        // Send the message to the duplicate counter, if any\n        DuplicateCounter counter = m_duplicateCounters.get(message.getSpHandle());\n        if (counter != null) {\n            int result = counter.offer(message);\n            if (result == DuplicateCounter.DONE) {\n                m_duplicateCounters.remove(message.getSpHandle());\n                // MPI is tracking deps per partition HSID.  We need to make\n                // sure we write ours into the message getting sent to the MPI\n                message.setExecutorSiteId(m_mailbox.getHSId());\n                try {\n                    m_mailbox.send(counter.m_destinationId, message);\n                } catch (MessagingException e) {\n                    VoltDB.crashLocalVoltDB(\"Failed to send every-site response.\", true, e);\n                }\n            }\n            else if (result == DuplicateCounter.MISMATCH) {\n                VoltDB.crashLocalVoltDB(\"HASH MISMATCH running every-site system procedure.\", true, null);\n            }\n            // doing duplicate suppresion: all done.\n            return;\n        }\n\n        try {\n            m_mailbox.send(message.getDestinationSiteId(), message);\n        }\n        catch (MessagingException e) {\n            hostLog.error(\"Failed to deliver response from execution site.\", e);\n        }\n    }","commit_id":"a78ad4015e3bf5d2c30ce89b6ebe239dfa1c93b9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void handleIv2InitiateTaskMessage(Iv2InitiateTaskMessage message)\n    {\n        final String procedureName = message.getStoredProcedureName();\n        final ProcedureRunner runner = m_loadedProcs.getProcByName(procedureName);\n        if (message.isSinglePartition()) {\n            long newSpHandle;\n            if (m_isLeader) {\n                // Need to set the SP handle on the received message\n                newSpHandle = m_txnId.incrementAndGet();\n                message.setSpHandle(newSpHandle);\n                // Also, if this is a vanilla single-part procedure, make the TXNID\n                // be the SpHandle (for now)\n                if (!runner.isEverySite()) {\n                    message.setTxnId(newSpHandle);\n                }\n                if (m_replicaHSIds.length > 0) {\n                    try {\n                        Iv2InitiateTaskMessage replmsg =\n                            new Iv2InitiateTaskMessage(m_mailbox.getHSId(),\n                                    m_mailbox.getHSId(),\n                                    message.getTxnId(),\n                                    message.isReadOnly(),\n                                    message.isSinglePartition(),\n                                    message.getStoredProcedureInvocation(),\n                                    message.getClientInterfaceHandle());\n                        // Update the handle in the copy\n                        message.setSpHandle(newSpHandle);\n                        m_mailbox.send(m_replicaHSIds, replmsg);\n                    } catch (MessagingException e) {\n                        hostLog.error(\"Failed to deliver response from execution site.\", e);\n                    }\n                    DuplicateCounter counter = new DuplicateCounter(\n                            message.getInitiatorHSId(), m_replicaHSIds.length + 1,\n                            message.getTxnId());\n                    m_duplicateCounters.put(newSpHandle, counter);\n                }\n            }\n            else {\n                newSpHandle = message.getSpHandle();\n                // FUTURE: update SP handle state on replicas based on value from primary\n            }\n            final SpProcedureTask task =\n                new SpProcedureTask(m_mailbox, runner,\n                        newSpHandle, m_pendingTasks, message);\n            m_pendingTasks.offer(task);\n            return;\n        }\n        else {\n            throw new RuntimeException(\"SpScheduler.handleIv2InitiateTaskMessage \" +\n                    \"should never receive multi-partition initiations.\");\n        }\n    }","id":66123,"modified_method":"public void handleIv2InitiateTaskMessage(Iv2InitiateTaskMessage message)\n    {\n        final String procedureName = message.getStoredProcedureName();\n        final ProcedureRunner runner = m_loadedProcs.getProcByName(procedureName);\n        if (message.isSinglePartition()) {\n            long newSpHandle;\n            if (m_isLeader) {\n                // Need to set the SP handle on the received message\n                newSpHandle = m_txnId.incrementAndGet();\n                message.setSpHandle(newSpHandle);\n                // Also, if this is a vanilla single-part procedure, make the TXNID\n                // be the SpHandle (for now)\n                if (!runner.isEverySite()) {\n                    message.setTxnId(newSpHandle);\n                }\n                if (m_replicaHSIds.length > 0) {\n                    try {\n                        Iv2InitiateTaskMessage replmsg =\n                            new Iv2InitiateTaskMessage(m_mailbox.getHSId(),\n                                    m_mailbox.getHSId(),\n                                    message.getTxnId(),\n                                    message.isReadOnly(),\n                                    message.isSinglePartition(),\n                                    message.getStoredProcedureInvocation(),\n                                    message.getClientInterfaceHandle());\n                        // Update the handle in the copy\n                        replmsg.setSpHandle(newSpHandle);\n                        m_mailbox.send(m_replicaHSIds, replmsg);\n                    } catch (MessagingException e) {\n                        hostLog.error(\"Failed to deliver response from execution site.\", e);\n                    }\n                    DuplicateCounter counter = new DuplicateCounter(\n                            message.getInitiatorHSId(), m_replicaHSIds.length + 1,\n                            message.getTxnId());\n                    m_duplicateCounters.put(newSpHandle, counter);\n                }\n            }\n            else {\n                newSpHandle = message.getSpHandle();\n                // FUTURE: update SP handle state on replicas based on value from primary\n            }\n            final SpProcedureTask task =\n                new SpProcedureTask(m_mailbox, runner,\n                        newSpHandle, m_pendingTasks, message);\n            m_pendingTasks.offer(task);\n            return;\n        }\n        else {\n            throw new RuntimeException(\"SpScheduler.handleIv2InitiateTaskMessage \" +\n                    \"should never receive multi-partition initiations.\");\n        }\n    }","commit_id":"a78ad4015e3bf5d2c30ce89b6ebe239dfa1c93b9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void handleInitiateResponseMessage(InitiateResponseMessage message)\n    {\n        // Send the message to the duplicate counter, if any\n        // ADD CODE HERE\n\n        if (message.getInitiatorHSId() != m_mailbox.getHSId()) {\n            try {\n                // the initiatorHSId is the ClientInterface mailbox. Yeah. I know.\n                m_mailbox.send(message.getInitiatorHSId(), message);\n            }\n            catch (MessagingException e) {\n                // hostLog.error(\"Failed to deliver response from execution site.\", e);\n            }\n        }\n    }","id":66124,"modified_method":"public void handleInitiateResponseMessage(InitiateResponseMessage message)\n    {\n        // Send the message to the duplicate counter, if any\n        DuplicateCounter counter = m_duplicateCounters.get(message.getSpHandle());\n        if (counter != null) {\n            int result = counter.offer(message);\n            if (result == DuplicateCounter.DONE) {\n                m_duplicateCounters.remove(message.getSpHandle());\n                try {\n                    m_mailbox.send(counter.m_destinationId, message);\n                } catch (MessagingException e) {\n                    VoltDB.crashLocalVoltDB(\"Failed to send every-site response.\", true, e);\n                }\n            }\n            else if (result == DuplicateCounter.MISMATCH) {\n                VoltDB.crashLocalVoltDB(\"HASH MISMATCH running every-site system procedure.\", true, null);\n            }\n            // doing duplicate suppresion: all done.\n            return;\n        }\n\n        try {\n            // the initiatorHSId is the ClientInterface mailbox. Yeah. I know.\n            m_mailbox.send(message.getInitiatorHSId(), message);\n        }\n        catch (MessagingException e) {\n            // hostLog.error(\"Failed to deliver response from execution site.\", e);\n        }\n    }","commit_id":"f4f8db2a1db186081b28283490c62e2619b0a08b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void handleIv2InitiateTaskMessage(Iv2InitiateTaskMessage message)\n    {\n        final String procedureName = message.getStoredProcedureName();\n        final ProcedureRunner runner = m_loadedProcs.getProcByName(procedureName);\n        if (message.isSinglePartition()) {\n            long new_txnId = m_txnId.incrementAndGet();\n            if (m_replicaHSIds.length > 0) {\n                try {\n                    Iv2InitiateTaskMessage replmsg =\n                        new Iv2InitiateTaskMessage(m_mailbox.getHSId(),\n                                m_mailbox.getHSId(),\n                                message.getTxnId(),\n                                message.isReadOnly(),\n                                message.isSinglePartition(),\n                                message.getStoredProcedureInvocation(),\n                                message.getClientInterfaceHandle()) ;\n                    m_mailbox.send(m_replicaHSIds, replmsg);\n                } catch (MessagingException e) {\n                    hostLog.error(\"Failed to deliver response from execution site.\", e);\n                }\n                DuplicateCounter counter = new DuplicateCounter(\n                        message.getInitiatorHSId(), m_replicaHSIds.length + 1,\n                        new_txnId);\n            }\n            final SpProcedureTask task =\n                new SpProcedureTask(m_mailbox, runner,\n                        new_txnId, m_pendingTasks, message);\n            m_pendingTasks.offer(task);\n            return;\n        }\n        else {\n            throw new RuntimeException(\"SpScheduler.handleIv2InitiateTaskMessage \" +\n                    \"should never receive multi-partition initiations.\");\n        }\n    }","id":66125,"modified_method":"public void handleIv2InitiateTaskMessage(Iv2InitiateTaskMessage message)\n    {\n        final String procedureName = message.getStoredProcedureName();\n        final ProcedureRunner runner = m_loadedProcs.getProcByName(procedureName);\n        if (message.isSinglePartition()) {\n            long newSpHandle;\n            if (m_isLeader) {\n                // Need to set the SP handle on the received message\n                newSpHandle = m_txnId.incrementAndGet();\n                message.setSpHandle(newSpHandle);\n                // Also, if this is a vanilla single-part procedure, make the TXNID\n                // be the SpHandle (for now)\n                if (!runner.isEverySite()) {\n                    message.setTxnId(newSpHandle);\n                }\n                if (m_replicaHSIds.length > 0) {\n                    try {\n                        Iv2InitiateTaskMessage replmsg =\n                            new Iv2InitiateTaskMessage(m_mailbox.getHSId(),\n                                    m_mailbox.getHSId(),\n                                    message.getTxnId(),\n                                    message.isReadOnly(),\n                                    message.isSinglePartition(),\n                                    message.getStoredProcedureInvocation(),\n                                    message.getClientInterfaceHandle());\n                        // Update the handle in the copy\n                        message.setSpHandle(newSpHandle);\n                        m_mailbox.send(m_replicaHSIds, replmsg);\n                    } catch (MessagingException e) {\n                        hostLog.error(\"Failed to deliver response from execution site.\", e);\n                    }\n                    DuplicateCounter counter = new DuplicateCounter(\n                            message.getInitiatorHSId(), m_replicaHSIds.length + 1,\n                            message.getTxnId());\n                    m_duplicateCounters.put(newSpHandle, counter);\n                }\n            }\n            else {\n                newSpHandle = message.getSpHandle();\n                // FUTURE: update SP handle state on replicas based on value from primary\n            }\n            final SpProcedureTask task =\n                new SpProcedureTask(m_mailbox, runner,\n                        newSpHandle, m_pendingTasks, message);\n            m_pendingTasks.offer(task);\n            return;\n        }\n        else {\n            throw new RuntimeException(\"SpScheduler.handleIv2InitiateTaskMessage \" +\n                    \"should never receive multi-partition initiations.\");\n        }\n    }","commit_id":"f4f8db2a1db186081b28283490c62e2619b0a08b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static <T> Set<T> getReferencesByType(BeanManager manager, Class<T> type, Annotation... qualifiers) {\n        Set<T> references = new HashSet<>();\n        for (Bean<?> bean : manager.getBeans(type, qualifiers)) {\n            references.add(getReference(manager, type, bean));\n        }\n        return references;\n    }","id":66126,"modified_method":"static <T> Set<T> getReferencesByType(BeanManager manager, Class<T> type, Annotation... qualifiers) {\n        return manager.getBeans(type, qualifiers).stream()\n            .map(bean -> getReference(manager, type, bean))\n            .collect(Collectors.toSet());\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"static <T> T getReferenceByType(BeanManager manager, Class<T> type, Annotation... qualifiers) {\n        Set<Bean<?>> beans = manager.getBeans(type, qualifiers);\n        if (beans == null || beans.isEmpty()) {\n            return null;\n        }\n        return getReference(manager, type, manager.resolve(beans));\n    }","id":66127,"modified_method":"static <T> Optional<T> getReferenceByType(BeanManager manager, Class<T> type, Annotation... qualifiers) {\n        return Optional.of(manager.getBeans(type, qualifiers))\n            .map(manager::resolve)\n            .map(bean -> getReference(manager, type, bean));\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"static <T> T getReferenceByName(BeanManager manager, String name, Class<T> type) {\n        Set<Bean<?>> beans = manager.getBeans(name);\n        if (beans == null || beans.isEmpty()) {\n            return null;\n        }\n        return getReference(manager, type, manager.resolve(beans));\n    }","id":66128,"modified_method":"static <T> Optional<T> getReferenceByName(BeanManager manager, String name, Class<T> type) {\n        return Optional.of(manager.getBeans(name))\n            .map(manager::resolve)\n            .map(bean -> getReference(manager, type, bean));\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"private CamelContext getOrLookupCamelContext(String contextName) {\r\n        // TODO: proper support for custom context qualifiers\r\n        return BeanManagerHelper.getReferenceByType(manager, CamelContext.class, contextName.isEmpty() ? DefaultLiteral.INSTANCE : ContextName.Literal.of(contextName));\r\n    }","id":66129,"modified_method":"private CamelContext getOrLookupCamelContext(String contextName) {\r\n        // TODO: proper support for custom context qualifiers\r\n        return getReferenceByType(manager, CamelContext.class,\r\n            contextName.isEmpty() ? DefaultLiteral.INSTANCE : ContextName.Literal.of(contextName))\r\n            .orElseThrow(() -> new UnsatisfiedResolutionException(\"No Camel context with name [\" + contextName + \"] is deployed!\"));\r\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"@Override\r\n    public CamelContext getOrLookupCamelContext() {\r\n        return BeanManagerHelper.getReferenceByType(manager, CamelContext.class);\r\n    }","id":66130,"modified_method":"@Override\r\n    public CamelContext getOrLookupCamelContext() {\r\n        return getReferenceByType(manager, CamelContext.class).orElse(null);\r\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public <T> T newInstance(Class<T> type) {\n        T instance = BeanManagerHelper.getReferenceByType(manager, type);\n        if (instance != null) {\n            return instance;\n        } else {\n            return injector.newInstance(type);\n        }\n    }","id":66131,"modified_method":"@Override\n    public <T> T newInstance(Class<T> type) {\n        return BeanManagerHelper.getReferenceByType(manager, type)\n            .orElseGet(() -> injector.newInstance(type));\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Object lookupByName(String name) {\n        ObjectHelper.notEmpty(name, \"name\");\n        logger.trace(\"Looking up bean with name [{}]\", name);\n        // Work-around for WELD-2089\n        if (\"properties\".equals(name) && findByTypeWithName(PropertiesComponent.class).containsKey(\"properties\")) {\n            return BeanManagerHelper.getReferenceByName(manager, name, PropertiesComponent.class);\n        }\n        return BeanManagerHelper.getReferenceByName(manager, name, Object.class);\n    }","id":66132,"modified_method":"@Override\n    public Object lookupByName(String name) {\n        ObjectHelper.notEmpty(name, \"name\");\n        logger.trace(\"Looking up bean with name [{}]\", name);\n        // Work-around for WELD-2089\n        if (\"properties\".equals(name) && findByTypeWithName(PropertiesComponent.class).containsKey(\"properties\")) {\n            return BeanManagerHelper.getReferenceByName(manager, name, PropertiesComponent.class)\n                .orElse(null);\n        }\n        return BeanManagerHelper.getReferenceByName(manager, name, Object.class)\n            .orElse(null);\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public <T> T lookupByNameAndType(String name, Class<T> type) {\n        ObjectHelper.notEmpty(name, \"name\");\n        ObjectHelper.notNull(type, \"type\");\n        logger.trace(\"Looking up bean with name [{}] of type [{}]\", name, type);\n        return BeanManagerHelper.getReferenceByName(manager, name, type);\n    }","id":66133,"modified_method":"@Override\n    public <T> T lookupByNameAndType(String name, Class<T> type) {\n        ObjectHelper.notEmpty(name, \"name\");\n        ObjectHelper.notNull(type, \"type\");\n        logger.trace(\"Looking up bean with name [{}] of type [{}]\", name, type);\n        return BeanManagerHelper.getReferenceByName(manager, name, type).orElse(null);\n    }","commit_id":"7a2a58cb444b55488f2e94b5e29cb553e594aaf4","url":"https://github.com/apache/camel"},{"original_method":"public static int toBuffer(@NotNull final ASTNode element, @Nullable final char[] buffer, int offset, final boolean skipWhitespaceAndComments) {\n    final int[] result = {offset};\n\n    ((TreeElement)element).acceptTree(new RecursiveTreeElementWalkingVisitor(false) {\n      @Override\n      public void visitLeaf(LeafElement element) {\n        ProgressIndicatorProvider.checkCanceled();\n        if (element instanceof ForeignLeafPsiElement ||\n            (skipWhitespaceAndComments && (element instanceof PsiWhiteSpace || element instanceof PsiComment))) {\n          return;\n        }\n\n        result[0] = element.copyTo(buffer, result[0]);\n      }\n\n      @Override\n      public void visitComposite(CompositeElement composite) {\n        if (composite instanceof LazyParseableElement) {\n          LazyParseableElement lpe = (LazyParseableElement)composite;\n          int lpeResult = lpe.copyTo(buffer, result[0]);\n          if (lpeResult >= 0) {\n            result[0] = lpeResult;\n            return;\n          }\n          assert lpe.isParsed();\n        }\n\n        super.visitComposite(composite);\n      }\n    });\n\n    return result[0];\n  }","id":66134,"modified_method":"public static int toBuffer(@NotNull final ASTNode element, @Nullable final char[] buffer, int offset, final boolean skipWhitespaceAndComments) {\n    BufferVisitor visitor = new BufferVisitor(skipWhitespaceAndComments, skipWhitespaceAndComments, offset, buffer);\n    ((TreeElement)element).acceptTree(visitor);\n    return visitor.end;\n  }","commit_id":"9aa80b9a5d7949f147543e0b86a57f55c654dc4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void patchLeafs(final ASTNode parsedNode,\n                                 final List<LiteralTextEscaper<? extends PsiLanguageInjectionHost>> escapers,\n                                 final Place shreds) {\n    final Map<LeafElement, String> newTexts = new THashMap<LeafElement, String>();\n    final StringBuilder catLeafs = new StringBuilder();\n    ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementWalkingVisitor(){\n      private LeafElement prevElement;\n      private String prevElementTail;\n\n      protected boolean visitNode(TreeElement element) {\n        return true;\n      }\n\n      @Override\n      public void visitLeaf(LeafElement leaf) {\n        String leafText = leaf.getText();\n        catLeafs.append(leafText);\n        final TextRange leafRange = leaf.getTextRange();\n\n        StringBuilder leafEncodedText = constructTextFromHostPSI(leafRange.getStartOffset(), leafRange.getEndOffset(), shreds, escapers);\n\n        if (leaf.getElementType() == TokenType.WHITE_SPACE && prevElementTail != null) {\n          // optimization: put all garbage into whitespace\n          leafEncodedText.insert(0, prevElementTail);\n          newTexts.remove(prevElement);\n          storeUnescapedTextFor(prevElement, null);\n        }\n        if (!Comparing.equal(leafText, leafEncodedText)) {\n          newTexts.put(leaf, leafEncodedText.toString());\n          storeUnescapedTextFor(leaf, leafText);\n        }\n        if (StringUtil.startsWith(leafEncodedText, leafText) && leafEncodedText.length() != leafText.length()) {\n          prevElementTail = leafEncodedText.substring(leafText.length());\n        }\n        else {\n          prevElementTail = null;\n        }\n        prevElement = leaf;\n      }\n    });\n\n    String nodeText = parsedNode.getText();\n    assert nodeText.equals(catLeafs.toString()) : \"Malformed PSI structure: leaf texts do not add up to the whole file text.\" +\n                                                  \"\\nFile text (from tree)  :'\"+nodeText+\"'\" +\n                                                  \"\\nFile text (from PSI)   :'\"+parsedNode.getPsi().getText()+\"'\" +\n                                                  \"\\nLeaf texts concatenated:'\"+catLeafs+\"';\" +\n                                                  \"\\nFile root: \"+parsedNode+\n                                                  \"\\nLanguage: \"+parsedNode.getPsi().getLanguage()+\n                                                  \"\\nHost file: \"+shreds.get(0).host.getContainingFile().getVirtualFile()\n        ;\n    for (Map.Entry<LeafElement, String> entry : newTexts.entrySet()) {\n      LeafElement leaf = entry.getKey();\n      String newText = entry.getValue();\n      leaf.setText(newText);\n    }\n    ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementWalkingVisitor(){\n      protected boolean visitNode(TreeElement element) {\n        element.clearCaches();\n        return true;\n      }\n    });\n  }","id":66135,"modified_method":"private static void patchLeafs(final ASTNode parsedNode,\n                                 final List<LiteralTextEscaper<? extends PsiLanguageInjectionHost>> escapers,\n                                 final Place shreds) {\n    LeafPatcher patcher = new LeafPatcher(shreds, escapers);\n    ((TreeElement)parsedNode).acceptTree(patcher);\n\n    String nodeText = parsedNode.getText();\n    assert nodeText.equals(patcher.catLeafs.toString()) : \"Malformed PSI structure: leaf texts do not add up to the whole file text.\" +\n                                                  \"\\nFile text (from tree)  :'\"+nodeText+\"'\" +\n                                                  \"\\nFile text (from PSI)   :'\"+parsedNode.getPsi().getText()+\"'\" +\n                                                  \"\\nLeaf texts concatenated:'\"+ patcher.catLeafs +\"';\" +\n                                                  \"\\nFile root: \"+parsedNode+\n                                                  \"\\nLanguage: \"+parsedNode.getPsi().getLanguage()+\n                                                  \"\\nHost file: \"+shreds.get(0).host.getContainingFile().getVirtualFile()\n        ;\n    for (Map.Entry<LeafElement, String> entry : patcher.newTexts.entrySet()) {\n      LeafElement leaf = entry.getKey();\n      String newText = entry.getValue();\n      leaf.setText(newText);\n    }\n    ((TreeElement)parsedNode).acceptTree(CLEAR_CACHES_VISITOR);\n  }","commit_id":"3784632f688af2849b9d18e3a29e262416f9aaf6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Before\n\tpublic void beforeTest() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\t_actorUser = UserTestUtil.addUser(\"actor\", _group.getGroupId());\n\t\t_creatorUser = UserTestUtil.addUser(\"creator\", _group.getGroupId());\n\n\t\t_assetEntry = SocialActivityTestUtil.addAsset(\n\t\t\t_creatorUser, _group, null);\n\t}","id":66136,"modified_method":"@Before\n\tpublic void beforeTest() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\t_actorUser = UserTestUtil.addUser(\"actor\", _group.getGroupId());\n\t\t_creatorUser = UserTestUtil.addUser(\"creator\", _group.getGroupId());\n\n\t\t_assetEntry = SocialActivityTestUtil.addAsset(\n\t\t\t_creatorUser, _group, null);\n\n\t\tSocialActivityHierarchyThreadLocal.clear();\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@After\n\tpublic void tearDown() throws Exception {\n\t\tif (_actorUser != null) {\n\t\t\tUserLocalServiceUtil.deleteUser(_actorUser);\n\n\t\t\t_actorUser = null;\n\t\t}\n\n\t\tif (_assetEntry != null) {\n\t\t\tAssetEntryLocalServiceUtil.deleteEntry(_assetEntry);\n\n\t\t\t_assetEntry = null;\n\t\t}\n\n\t\tif (_creatorUser != null) {\n\t\t\tUserLocalServiceUtil.deleteUser(_creatorUser);\n\n\t\t\t_creatorUser = null;\n\t\t}\n\n\t\tif (_group != null) {\n\t\t\tGroupLocalServiceUtil.deleteGroup(_group);\n\n\t\t\t_group = null;\n\t\t}\n\t}","id":66137,"modified_method":"@After\n\tpublic void tearDown() throws Exception {\n\t\tSocialActivityHierarchyThreadLocal.clear();\n\n\t\tif (_actorUser != null) {\n\t\t\tUserLocalServiceUtil.deleteUser(_actorUser);\n\n\t\t\t_actorUser = null;\n\t\t}\n\n\t\tif (_assetEntry != null) {\n\t\t\tAssetEntryLocalServiceUtil.deleteEntry(_assetEntry);\n\n\t\t\t_assetEntry = null;\n\t\t}\n\n\t\tif (_creatorUser != null) {\n\t\t\tUserLocalServiceUtil.deleteUser(_creatorUser);\n\n\t\t\t_creatorUser = null;\n\t\t}\n\n\t\tif (_group != null) {\n\t\t\tGroupLocalServiceUtil.deleteGroup(_group);\n\n\t\t\t_group = null;\n\t\t}\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testToggleActivities() throws Exception {\n\t\tSocialActivityCounterLocalServiceUtil.addActivityCounters(\n\t\t\tSocialActivityTestUtil.addActivity(\n\t\t\t\t_creatorUser, _group, _assetEntry, 1));\n\n\t\tSocialActivityCounterLocalServiceUtil.addActivityCounters(\n\t\t\tSocialActivityTestUtil.addActivity(\n\t\t\t\t_actorUser, _group, _assetEntry, 2));\n\n\t\tSocialActivityCounter contribution =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tList<SocialActivityCounter> counters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(1, counters.size());\n\n\t\tSocialActivityCounterLocalServiceUtil.disableActivityCounters(\n\t\t\t_assetEntry.getClassName(), _assetEntry.getClassPK());\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(0, contribution.getCurrentValue());\n\n\t\tSocialActivityCounter counter =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\", _assetEntry);\n\n\t\tAssert.assertNotNull(counter);\n\t\tAssert.assertEquals(false, counter.isActive());\n\n\t\tcounters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(0, counters.size());\n\n\t\tSocialActivityCounterLocalServiceUtil.enableActivityCounters(\n\t\t\t_assetEntry.getClassName(), _assetEntry.getClassPK());\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tcounter = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(), \"asset.test.2\", _assetEntry);\n\n\t\tAssert.assertNotNull(counter);\n\t\tAssert.assertEquals(true, counter.isActive());\n\n\t\tcounters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(1, counters.size());\n\t}","id":66138,"modified_method":"@Test\n\tpublic void testToggleActivities() throws Exception {\n\t\tSocialActivityTestUtil.addActivity(\n\t\t\t_creatorUser, _group, _assetEntry, 1);\n\n\t\tSocialActivityTestUtil.addActivity(_actorUser, _group, _assetEntry, 2);\n\n\t\tSocialActivityCounter contribution =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tList<SocialActivityCounter> counters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(1, counters.size());\n\n\t\tSocialActivityCounterLocalServiceUtil.disableActivityCounters(\n\t\t\t_assetEntry.getClassName(), _assetEntry.getClassPK());\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(0, contribution.getCurrentValue());\n\n\t\tSocialActivityCounter counter =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\", _assetEntry);\n\n\t\tAssert.assertNotNull(counter);\n\t\tAssert.assertEquals(false, counter.isActive());\n\n\t\tcounters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(0, counters.size());\n\n\t\tSocialActivityCounterLocalServiceUtil.enableActivityCounters(\n\t\t\t_assetEntry.getClassName(), _assetEntry.getClassPK());\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tcounter = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(), \"asset.test.2\", _assetEntry);\n\n\t\tAssert.assertNotNull(counter);\n\t\tAssert.assertEquals(true, counter.isActive());\n\n\t\tcounters =\n\t\t\tSocialActivityCounterLocalServiceUtil.getPeriodActivityCounters(\n\t\t\t\t_group.getGroupId(), \"asset.test.2\",\n\t\t\t\tSocialCounterPeriodUtil.getStartPeriod(), -1);\n\n\t\tAssert.assertEquals(1, counters.size());\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddActivity() throws Exception {\n\t\tSocialActivityCounterLocalServiceUtil.addActivityCounters(\n\t\t\tSocialActivityTestUtil.addActivity(\n\t\t\t\t_creatorUser, _group, _assetEntry, 1));\n\n\t\tSocialActivityCounter contribution =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNull(contribution);\n\n\t\tSocialActivityCounter participation =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION,\n\t\t\t\t_creatorUser);\n\n\t\tAssert.assertEquals(2, participation.getCurrentValue());\n\n\t\tSocialActivityCounterLocalServiceUtil.addActivityCounters(\n\t\t\tSocialActivityTestUtil.addActivity(\n\t\t\t\t_actorUser, _group, _assetEntry, 2));\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tparticipation = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION, _actorUser);\n\n\t\tAssert.assertNotNull(participation);\n\t\tAssert.assertEquals(1, participation.getCurrentValue());\n\n\t\tSocialActivityLimit activityLimit =\n\t\t\tSocialActivityTestUtil.getActivityLimit(\n\t\t\t\t_group.getGroupId(), _actorUser, _assetEntry, 2,\n\t\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION);\n\n\t\tAssert.assertNotNull(activityLimit);\n\t\tAssert.assertEquals(1, activityLimit.getCount());\n\n\t\tSocialActivityCounterLocalServiceUtil.addActivityCounters(\n\t\t\tSocialActivityTestUtil.addActivity(\n\t\t\t\t_actorUser, _group, _assetEntry, 2));\n\n\t\tactivityLimit =  SocialActivityTestUtil.getActivityLimit(\n\t\t\t_group.getGroupId(), _actorUser, _assetEntry, 2,\n\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION);\n\n\t\tAssert.assertNotNull(activityLimit);\n\t\tAssert.assertEquals(2, activityLimit.getCount());\n\t}","id":66139,"modified_method":"@Test\n\tpublic void testAddActivity() throws Exception {\n\t\tSocialActivityTestUtil.addActivity(\n\t\t\t_creatorUser, _group, _assetEntry, 1);\n\n\t\tSocialActivityCounter contribution =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNull(contribution);\n\n\t\tSocialActivityCounter participation =\n\t\t\tSocialActivityTestUtil.getActivityCounter(\n\t\t\t\t_group.getGroupId(),\n\t\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION,\n\t\t\t\t_creatorUser);\n\n\t\tAssert.assertEquals(2, participation.getCurrentValue());\n\n\t\tSocialActivityTestUtil.addActivity(_actorUser, _group, _assetEntry, 2);\n\n\t\tcontribution = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_CONTRIBUTION, _creatorUser);\n\n\t\tAssert.assertNotNull(contribution);\n\t\tAssert.assertEquals(1, contribution.getCurrentValue());\n\n\t\tparticipation = SocialActivityTestUtil.getActivityCounter(\n\t\t\t_group.getGroupId(),\n\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION, _actorUser);\n\n\t\tAssert.assertNotNull(participation);\n\t\tAssert.assertEquals(1, participation.getCurrentValue());\n\n\t\tSocialActivityLimit activityLimit =\n\t\t\tSocialActivityTestUtil.getActivityLimit(\n\t\t\t\t_group.getGroupId(), _actorUser, _assetEntry, 2,\n\t\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION);\n\n\t\tAssert.assertNotNull(activityLimit);\n\t\tAssert.assertEquals(1, activityLimit.getCount());\n\n\t\tSocialActivityTestUtil.addActivity(_actorUser, _group, _assetEntry, 2);\n\n\t\tactivityLimit = SocialActivityTestUtil.getActivityLimit(\n\t\t\t_group.getGroupId(), _actorUser, _assetEntry, 2,\n\t\t\tSocialActivityCounterConstants.NAME_PARTICIPATION);\n\n\t\tAssert.assertNotNull(activityLimit);\n\t\tAssert.assertEquals(2, activityLimit.getCount());\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SocialActivityCounter getActivityCounter(\n\t\t\tlong groupId, String name, Object owner)\n\t\tthrows Exception {\n\n\t\tlong classNameId = 0;\n\t\tlong classPk = 0;\n\t\tint ownerType = SocialActivityCounterConstants.TYPE_ACTOR;\n\n\t\tif (owner instanceof User) {\n\t\t\tclassNameId = PortalUtil.getClassNameId(User.class.getName());\n\t\t\tclassPk = ((User)owner).getUserId();\n\t\t}\n\t\telse if (owner instanceof AssetEntry) {\n\t\t\tclassNameId = ((AssetEntry)owner).getClassNameId();\n\t\t\tclassPk = ((AssetEntry)owner).getClassPK();\n\t\t\townerType = SocialActivityCounterConstants.TYPE_ASSET;\n\t\t}\n\n\t\tif (name.equals(SocialActivityCounterConstants.NAME_CONTRIBUTION)) {\n\t\t\townerType = SocialActivityCounterConstants.TYPE_CREATOR;\n\t\t}\n\n\t\treturn\n\t\t\tSocialActivityCounterLocalServiceUtil.fetchLatestActivityCounter(\n\t\t\t\tgroupId, classNameId, classPk, name, ownerType);\n\t}","id":66140,"modified_method":"public static SocialActivityCounter getActivityCounter(\n\t\t\tlong groupId, String name, Object owner)\n\t\tthrows Exception {\n\n\t\tlong classNameId = 0;\n\t\tlong classPK = 0;\n\t\tint ownerType = SocialActivityCounterConstants.TYPE_ACTOR;\n\n\t\tif (owner instanceof User) {\n\t\t\tclassNameId = PortalUtil.getClassNameId(User.class.getName());\n\t\t\tclassPK = ((User)owner).getUserId();\n\t\t}\n\t\telse if (owner instanceof AssetEntry) {\n\t\t\tclassNameId = ((AssetEntry)owner).getClassNameId();\n\t\t\tclassPK = ((AssetEntry)owner).getClassPK();\n\t\t\townerType = SocialActivityCounterConstants.TYPE_ASSET;\n\t\t}\n\n\t\tif (name.equals(SocialActivityCounterConstants.NAME_CONTRIBUTION)) {\n\t\t\townerType = SocialActivityCounterConstants.TYPE_CREATOR;\n\t\t}\n\n\t\treturn\n\t\t\tSocialActivityCounterLocalServiceUtil.fetchLatestActivityCounter(\n\t\t\t\tgroupId, classNameId, classPK, name, ownerType);\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SocialActivity addActivity(\n\t\tUser user, Group group, AssetEntry assetEntry, int type) {\n\n\t\tSocialActivity activity = new SocialActivityImpl();\n\n\t\tactivity.setAssetEntry(assetEntry);\n\t\tactivity.setClassNameId(assetEntry.getClassNameId());\n\t\tactivity.setClassPK(assetEntry.getClassPK());\n\t\tactivity.setCompanyId(group.getCompanyId());\n\t\tactivity.setGroupId(group.getGroupId());\n\t\tactivity.setType(type);\n\t\tactivity.setUserId(user.getUserId());\n\t\tactivity.setUserUuid(user.getUuid());\n\n\t\treturn activity;\n\t}","id":66141,"modified_method":"public static void addActivity(\n\t\t\tUser user, Group group, AssetEntry assetEntry, int type)\n\t\tthrows Exception {\n\n\t\taddActivity(user, group, assetEntry, type, StringPool.BLANK);\n\t}","commit_id":"834dbd1abd843103283e754a0ab2b296694e1f5d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public void paintBorder(Component c, Graphics g2, int x, int y, int width, int height) {\n    if (comboBox == null || arrowButton == null) {\n      return; //NPE on LaF change\n    }\n\n    hasFocus = false;\n    checkFocus();\n    final Graphics2D g = (Graphics2D)g2;\n    final Rectangle arrowButtonBounds = arrowButton.getBounds();\n    final int xxx = arrowButtonBounds.x - JBUI.scale(5);\n    final int H = height - JBUI.scale(2);\n    final int W = width - JBUI.scale(2);\n\n    final GraphicsConfig config = new GraphicsConfig(g);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n    final int R = JBUI.scale(5);\n    if (hasFocus) {\n      g.setClip(JBUI.scale(2), JBUI.scale(2), comboBox.getWidth()- JBUI.scale(4), comboBox.getHeight() - JBUI.scale(4));\n    }\n    if (editor != null && comboBox.isEditable()) {\n      ((JComponent)editor).setBorder(null);\n      g.setColor(editor.getBackground());\n      g.fillRoundRect(x + JBUI.scale(1), y + JBUI.scale(1), W, H, R, R);\n      g.setColor(getArrowButtonFillColor(arrowButton.getBackground()));\n      g.fillRoundRect(xxx, y + JBUI.scale(1), width - xxx, H, R, R);\n      g.setColor(editor.getBackground());\n      g.fillRect(xxx, y + JBUI.scale(1), JBUI.scale(5), H);\n    } else {\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRoundRect(x + JBUI.scale(1), y + JBUI.scale(1), W, H, R, R);\n      g.setColor(getArrowButtonFillColor(arrowButton.getBackground()));\n      g.fillRoundRect(xxx, y + JBUI.scale(1), width - xxx, H, R, R);\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRect(xxx, y + JBUI.scale(1), JBUI.scale(5), H);\n    }\n    final Color borderColor = getBorderColor();//ColorUtil.shift(UIUtil.getBorderColor(), 4);\n    g.setColor(getArrowButtonFillColor(borderColor));\n    int off = hasFocus ? 1 : 0;\n    g.drawLine(xxx + JBUI.scale(5), y + JBUI.scale(1) + off, xxx + JBUI.scale(5), height - JBUI.scale(2));\n\n    Rectangle r = rectangleForCurrentValue();\n    paintCurrentValueBackground(g, r, hasFocus);\n    paintCurrentValue(g, r, false);\n\n    if (hasFocus) {\n      g.setClip(0, 0, comboBox.getWidth(), comboBox.getHeight());\n      DarculaUIUtil.paintFocusRing(g, JBUI.scale(2), JBUI.scale(2), width - JBUI.scale(4), height - JBUI.scale(4));\n    }\n    else {\n      g.setColor(borderColor);\n      g.drawRoundRect(JBUI.scale(1), JBUI.scale(1), width - JBUI.scale(2), height - JBUI.scale(2), R, R);\n      if (!UIUtil.isUnderDarcula() && comboBox.isEnabled()) {\n        g.setColor(getArrowButtonFillColor(getBorderColor()));\n        final Shape clip = g.getClip();\n        final int offX = xxx + JBUI.scale(5);\n        g.clipRect(offX, y, width - offX, height);\n        g.drawRoundRect(JBUI.scale(1), JBUI.scale(1), width - JBUI.scale(2), height - JBUI.scale(2), R, R);\n        g.setClip(clip);\n      }\n    }\n    config.restore();\n  }","id":66142,"modified_method":"@Override\n  public void paintBorder(Component c, Graphics g2, int x, int y, int width, int height) {\n    if (comboBox == null || arrowButton == null) {\n      return; //NPE on LaF change\n    }\n\n    hasFocus = false;\n    checkFocus();\n    final Graphics2D g = (Graphics2D)g2.create();\n    final Rectangle arrowButtonBounds = arrowButton.getBounds();\n    final int xxx = arrowButtonBounds.x - JBUI.scale(5);\n    final int H = height - JBUI.scale(2);\n    final int W = width - JBUI.scale(2);\n\n    final Shape clip = g.getClip();\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n    final int R = JBUI.scale(5);\n    if (hasFocus) {\n      g.clipRect(JBUI.scale(2), JBUI.scale(2), comboBox.getWidth()- JBUI.scale(4), comboBox.getHeight() - JBUI.scale(4));\n    }\n    if (editor != null && comboBox.isEditable()) {\n      ((JComponent)editor).setBorder(null);\n      g.setColor(editor.getBackground());\n      g.fillRoundRect(x + JBUI.scale(1), y + JBUI.scale(1), W, H, R, R);\n      g.setColor(getArrowButtonFillColor(arrowButton.getBackground()));\n      g.fillRoundRect(xxx, y + JBUI.scale(1), width - xxx, H, R, R);\n      g.setColor(editor.getBackground());\n      g.fillRect(xxx, y + JBUI.scale(1), JBUI.scale(5), H);\n    } else {\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRoundRect(x + JBUI.scale(1), y + JBUI.scale(1), W, H, R, R);\n      g.setColor(getArrowButtonFillColor(arrowButton.getBackground()));\n      g.fillRoundRect(xxx, y + JBUI.scale(1), width - xxx, H, R, R);\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRect(xxx, y + JBUI.scale(1), JBUI.scale(5), H);\n    }\n    final Color borderColor = getBorderColor();//ColorUtil.shift(UIUtil.getBorderColor(), 4);\n    g.setColor(getArrowButtonFillColor(borderColor));\n    int off = hasFocus ? 1 : 0;\n    g.drawLine(xxx + JBUI.scale(5), y + JBUI.scale(1) + off, xxx + JBUI.scale(5), height - JBUI.scale(2));\n\n    Rectangle r = rectangleForCurrentValue();\n    paintCurrentValueBackground(g, r, hasFocus);\n    paintCurrentValue(g, r, false);\n\n    if (hasFocus) {\n      g.setClip(clip);\n      DarculaUIUtil.paintFocusRing(g, JBUI.scale(2), JBUI.scale(2), width - JBUI.scale(4), height - JBUI.scale(4));\n    }\n    else {\n      g.setColor(borderColor);\n      g.drawRoundRect(JBUI.scale(1), JBUI.scale(1), width - JBUI.scale(2), height - JBUI.scale(2), R, R);\n      if (!UIUtil.isUnderDarcula() && comboBox.isEnabled()) {\n        g.setColor(getArrowButtonFillColor(getBorderColor()));\n        final int offX = xxx + JBUI.scale(5);\n        g.clipRect(offX, y, width - offX, height);\n        g.drawRoundRect(JBUI.scale(1), JBUI.scale(1), width - JBUI.scale(2), height - JBUI.scale(2), R, R);\n      }\n    }\n    g.dispose();\n  }","commit_id":"2dcecc7f810a91dc19df462df08a3a8d16021605","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String computeImageMapArea(LWContainer container)\n    {\n        String out = new String();\n         \n        java.util.Iterator iter =  container.getNodeIterator();\n        \n        while(iter.hasNext())\n        {\n            LWNode node = (LWNode)iter.next();\n            \n            if (node.hasChildren())\n              out += computeImageMapArea((LWContainer)node);\n            \n            String shape = \"rect\";\n            String label = node.getLabel();\n            String res = \"\";\n            int ox = (int)node.getX();\n            int oy = (int)node.getY();\n            int ow = (int)node.getWidth();\n            int oh = (int)node.getHeight();\n            String href = \"\";\n            \n            if(node.getResource() != null){\n                Resource resource = node.getResource();\n                res = resource.toString();\n                if(!res.startsWith(\"http://\")) res = \"file:///\" + res;\n            } \n            else res = \"null\";\n            \n            if(res.equals(\"null\")) href = \"nohref\";\n            else href = \"href=\\\"\" + res + \"\\\"\";\n            \n            out += \"<area \" + href\n                +\" alt=\\\"\"+label\n                +\"\\\" shape=\\\"\"+shape\n                +\"\\\" coords=\\\"\"+ox\n                +\",\"+oy\n                +\",\"+(ox + ow)\n                +\",\"+(oy + oh)\n                +\"\\\">\\n\\n\";\n        }\n         \n        return out;\n    }","id":66143,"modified_method":"private String computeImageMapArea(LWContainer container)\n    {\n        String out = new String();\n         \n        java.util.Iterator iter =  container.getNodeIterator();\n        \n        while(iter.hasNext())\n        {\n            LWNode node = (LWNode)iter.next();\n            \n            if (node.hasChildren())\n              out += computeImageMapArea((LWContainer)node);\n            \n            String shape = \"rect\";\n            String altLabel = null;\n            \n            if ((altLabel = node.getNotes()) == null)\n              altLabel = \"No Notes\";\n            \n            String res = \"\";\n            int ox = (int)node.getX() -  xOffset;\n            int oy = (int)node.getY() -  yOffset;\n            //int ox = (int)node.getX();\n            //int oy = (int)node.getY();\n            int ow = (int)node.getWidth();\n            int oh = (int)node.getHeight();\n            \n            String href = \"\";\n            \n            if(node.getResource() != null){\n                Resource resource = node.getResource();\n                res = resource.toString();\n                if(!res.startsWith(\"http://\")) res = \"file:///\" + res;\n            } \n            else res = \"null\";\n            \n            if(res.equals(\"null\")) href = \"nohref\";\n            else href = \"href=\\\"\" + res + \"\\\"\";\n            \n            out += \"<area \" + href\n                +\" alt=\\\"\"+ altLabel\n                +\"\\\" shape=\\\"\"+shape\n                +\"\\\" coords=\\\"\"+ox\n                +\",\"+oy\n                +\",\"+(ox + ow)\n                +\",\"+(oy + oh)\n                +\"\\\">\\n\\n\";\n        }\n         \n        return out;\n    }","commit_id":"7c844529c320e4359d5da9f9e206b915ded0c300","url":"https://github.com/VUE/VUE"},{"original_method":"private void createJpeg(String location, String format, MapViewer currentMap, Dimension size)\n    {     \n        BufferedImage mapImage = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n        Graphics g = mapImage.getGraphics();\n        g.setClip(0, 0, size.width, size.height);\n        currentMap.paintComponent(g);\n        \n        g.setColor(Color.black);\n        g.drawRect(0, 0, size.width - 1, size.height - 1);\n            \n        try\n        {\n            System.out.println(location);\n            ImageIO.write(mapImage, format, new File(location));\n        }\n        catch (Exception e)\n        {\n            System.out.println(\"Couldn't write to the file:\" + e);\n        }\n    }","id":66144,"modified_method":"private void createJpeg(String location, String format, MapViewer currentMap, Dimension size)\n    {     \n        BufferedImage mapImage = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n        this.map = currentMap.getMap();\n        Graphics2D g = (Graphics2D) mapImage.getGraphics();\n         g.setColor(Color.WHITE);\n        g.fillRect(0, 0, size.width, size.height);\n        g.setColor(Color.BLACK);\n        g.drawRect(0, 0, size.width-1, size.height-1);\n        //g.drawRect(xOffset, yOffset, size.width+xOffset- 1, size.height+yOffset - 1);\n       \n        \n         g.translate(-xOffset, -yOffset);\n        g.setClip(0, 0, size.width, size.height);\n       //currentMap.paintComponent(g);\n        \n            \n        DrawContext dc = new DrawContext(g, scale);\n             // render the map\n            map.draw(dc);\n           \n        \n        try\n        {\n            System.out.println(location);\n            ImageIO.write(mapImage, format, new File(location));\n        }\n        catch (Exception e)\n        {\n            System.out.println(\"Couldn't write to the file:\" + e);\n        }\n    }","commit_id":"7c844529c320e4359d5da9f9e206b915ded0c300","url":"https://github.com/VUE/VUE"},{"original_method":"public void createImageMap(File file)\n    {\n        \n        MapViewer currentMap = VUE.getActiveViewer();\n        \n        Rectangle2D bounds = currentMap.getAllComponentBounds();\n        int xLocation = (int)bounds.getX() + 5, yLocation = (int)bounds.getY() + 5;\n        Dimension size = new Dimension((int)bounds.getWidth() + xLocation, (int)bounds.getHeight() + yLocation);\n            \n        /**\n            JFileChooser chooser = new JFileChooser();\n            chooser.setDialogTitle(\"Save Image Map File\");\n            if(VueUtil.isCurrentDirectoryPathSet()) \n                chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n                \n            int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n                \n            if (option == JFileChooser.APPROVE_OPTION) {\n                String fileName = chooser.getSelectedFile().getAbsolutePath();\n                String imageLocation = fileName; \n                String imageName = chooser.getSelectedFile().getName();\n                if(imageName.endsWith(\".html\")){\n                    imageName = imageName.substring(0, imageName.length()-5)+\".jpeg\";\n                    imageLocation = imageLocation.substring(0, imageLocation.length()-5)+\".jpeg\";\n                }else{\n                    imageName += \".jpeg\";\n                    imageLocation += \".jpeg\";\n                    fileName += \".html\";\n                }\n                createJpeg(imageLocation, \"jpeg\", currentMap, size);\n                createHtml(imageName, fileName, currentMap, size);\n            }\n           **/\n        \n       String imageLocation = file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-5)+\".jpeg\";\n       String imageName = file.getName().substring(0, file.getName().length()-5)+\".jpeg\";\n       String fileName = file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-5)+\".html\";\n       \n       createJpeg(imageLocation, \"jpeg\", currentMap, size);\n       createHtml(imageName, fileName, currentMap, size);\n    }","id":66145,"modified_method":"public void createImageMap(File file)\n    {\n        \n        MapViewer currentMap = VUE.getActiveViewer();\n        \n        Rectangle2D bounds = currentMap.getAllComponentBounds();\n        xOffset = (int)bounds.getX(); \n        yOffset = (int)bounds.getY();\n        System.out.println(\"bounds are \" + xOffset + \", \" + yOffset);\n        \n        //Dimension size = new Dimension((int)bounds.getWidth() + xOffset, (int)bounds.getHeight() + yOffset);\n        Dimension size = new Dimension((int)bounds.getWidth(), (int)bounds.getHeight());\n            \n        /**\n            JFileChooser chooser = new JFileChooser();\n            chooser.setDialogTitle(\"Save Image Map File\");\n            if(VueUtil.isCurrentDirectoryPathSet()) \n                chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n                \n            int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n                \n            if (option == JFileChooser.APPROVE_OPTION) {\n                String fileName = chooser.getSelectedFile().getAbsolutePath();\n                String imageLocation = fileName; \n                String imageName = chooser.getSelectedFile().getName();\n                if(imageName.endsWith(\".html\")){\n                    imageName = imageName.substring(0, imageName.length()-5)+\".jpeg\";\n                    imageLocation = imageLocation.substring(0, imageLocation.length()-5)+\".jpeg\";\n                }else{\n                    imageName += \".jpeg\";\n                    imageLocation += \".jpeg\";\n                    fileName += \".html\";\n                }\n                createJpeg(imageLocation, \"jpeg\", currentMap, size);\n                createHtml(imageName, fileName, currentMap, size);\n            }\n           **/\n        \n       String imageLocation = file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-5)+\".jpeg\";\n       String imageName = file.getName().substring(0, file.getName().length()-5)+\".jpeg\";\n       String fileName = file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-5)+\".html\";\n       \n       createJpeg(imageLocation, \"jpeg\", currentMap, size);\n       createHtml(imageName, fileName, currentMap, size);\n    }","commit_id":"7c844529c320e4359d5da9f9e206b915ded0c300","url":"https://github.com/VUE/VUE"},{"original_method":"public List<QProfileRule> searchActiveRules(QProfile profile, Paging paging) {\n    SearchHits hits = index.client().prepareSearch(\"rules\").setTypes(\"active_rule\")\n      .setFilter(boolFilter()\n          .must(\n              termFilter(\"profileId\", profile.id())\n          ))\n      .addFields(\"_source\", \"_parent\")\n      .setSize(paging.pageSize())\n      .setFrom(paging.offset())\n      .execute().actionGet().getHits();\n\n    String[] activeRuleSources = new String[hits.getHits().length];\n    String[] parentIds = new String[hits.getHits().length];\n    int hitCounter = 0;\n\n    List<QProfileRule> result = Lists.newArrayList();\n    for (SearchHit hit: hits.getHits()) {\n      activeRuleSources[hitCounter] = hit.sourceAsString();\n      parentIds[hitCounter] = hit.field(\"_parent\").value();\n      hitCounter ++;\n    }\n\n    MultiGetItemResponse[] responses = index.client().prepareMultiGet().add(\"rules\", \"rule\", parentIds)\n      .execute().actionGet().getResponses();\n\n    for (int i = 0; i < hitCounter; i ++) {\n      result.add(new QProfileRule(responses[i].getResponse().getSourceAsString(), activeRuleSources[i]));\n    }\n\n    return result;\n  }","id":66146,"modified_method":"public List<QProfileRule> searchActiveRules(ProfileRuleQuery query, Paging paging) {\n    BoolFilterBuilder filter = boolFilter().must(\n            termFilter(\"profileId\", query.profileId()),\n            hasParentFilter(\"rule\", parentRuleFilter(query))\n        );\n    addMustTermOrTerms(filter, \"severity\", query.severities());\n\n    SearchRequestBuilder builder = index.client().prepareSearch(\"rules\").setTypes(\"active_rule\")\n      .setFilter(filter)\n      .addFields(\"_source\", \"_parent\")\n      .setSize(paging.pageSize())\n      .setFrom(paging.offset());\n    SearchHits hits = index.executeRequest(builder);\n\n    String[] activeRuleSources = new String[hits.getHits().length];\n    String[] parentIds = new String[hits.getHits().length];\n    int hitCounter = 0;\n\n    List<QProfileRule> result = Lists.newArrayList();\n    for (SearchHit hit: hits.getHits()) {\n      activeRuleSources[hitCounter] = hit.sourceAsString();\n      parentIds[hitCounter] = hit.field(\"_parent\").value();\n      hitCounter ++;\n    }\n\n    if (hitCounter > 0) {\n      MultiGetItemResponse[] responses = index.client().prepareMultiGet().add(\"rules\", \"rule\", parentIds)\n        .execute().actionGet().getResponses();\n\n      for (int i = 0; i < hitCounter; i ++) {\n        result.add(new QProfileRule(responses[i].getResponse().getSourceAsString(), activeRuleSources[i]));\n      }\n    }\n\n    return result;\n  }","commit_id":"c0b463e711b16e47e878162ba550c6de9550ef74","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    esSetup = new EsSetup();\n    esSetup.execute(EsSetup.deleteAll());\n\n    SearchNode searchNode = mock(SearchNode.class);\n    when(searchNode.client()).thenReturn(esSetup.client());\n\n    SearchIndex index = new SearchIndex(searchNode, new Profiling(new Settings()));\n    index.start();\n    RuleRegistry registry = new RuleRegistry(index, null, null);\n    registry.start();\n    profileRules = new ProfileRules(index);\n  }","id":66147,"modified_method":"@Before\n  public void setUp() {\n    esSetup = new EsSetup();\n    esSetup.execute(EsSetup.deleteAll());\n\n    SearchNode searchNode = mock(SearchNode.class);\n    when(searchNode.client()).thenReturn(esSetup.client());\n\n    Settings settings = new Settings();\n    settings.setProperty(\"sonar.log.profilingLevel\", \"FULL\");\n    SearchIndex index = new SearchIndex(searchNode, new Profiling(settings));\n    index.start();\n    RuleRegistry registry = new RuleRegistry(index, null, null);\n    registry.start();\n    profileRules = new ProfileRules(index);\n  }","commit_id":"c0b463e711b16e47e878162ba550c6de9550ef74","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_find_active_rules() throws Exception {\n    esSetup.client().prepareBulk()\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule759.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"25\").source(testFileAsString(\"should_find_active_rules/active_rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule391.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule523.json\")))\n      .setRefresh(true).execute().actionGet();\n\n    Paging paging = Paging.create(10, 1, 10);\n\n    QProfile profile1 = mock(QProfile.class);\n    when(profile1.id()).thenReturn(1);\n    List<QProfileRule> result1 = profileRules.searchActiveRules(profile1, paging);\n    assertThat(result1).hasSize(2);\n\n    QProfile profile2 = mock(QProfile.class);\n    when(profile2.id()).thenReturn(2);\n    List<QProfileRule> result2 = profileRules.searchActiveRules(profile2, paging);\n    assertThat(result2).hasSize(1);\n  }","id":66148,"modified_method":"@Test\n  public void should_find_active_rules() throws Exception {\n    esSetup.client().prepareBulk()\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule759.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"25\").source(testFileAsString(\"should_find_active_rules/active_rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule391.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule523.json\")))\n      .setRefresh(true).execute().actionGet();\n\n    Paging paging = Paging.create(10, 1);\n\n    // All rules for profile 1\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1), paging)).hasSize(2);\n\n    // All rules for profile 2\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(2), paging)).hasSize(1);\n\n    // Inexistent profile\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(3), paging)).hasSize(0);\n\n    // Inexistent name/key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"polop\"), paging)).hasSize(0);\n\n    // Match on key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"DM_CONVERT_CASE\"), paging)).hasSize(1);\n\n    // Match on name\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"Unused Check\"), paging)).hasSize(1);\n\n    // Match on repositoryKey\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).addRepositoryKeys(\"findbugs\"), paging)).hasSize(1);\n  }","commit_id":"c0b463e711b16e47e878162ba550c6de9550ef74","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void synchronize(DbSession session, Dao dao, Index index) {\n    Long count = index.getIndexStat().getDocumentCount();\n    Date lastSynch = index.getLastSynchronization();\n    if (count <= 0) {\n      LOG.info(\"Initial indexing of {} records\", index.getIndexType());\n    } else {\n      LOG.info(\"Synchronizing {} records for updates after {}\", index.getIndexType(), lastSynch);\n    }\n    dao.synchronizeAfter(session,\n      index.getLastSynchronization());\n  }","id":66149,"modified_method":"void synchronize(DbSession session, Dao dao, Index index) {\n    Long count = index.getIndexStat().getDocumentCount();\n    Date lastSynch = index.getLastSynchronization();\n    if (count <= 0) {\n      LOG.info(\"Initial indexing of {} records\", index.getIndexType());\n    } else {\n      LOG.info(\"Synchronizing {} records for updates after {}\", index.getIndexType(), lastSynch);\n    }\n    dao.synchronizeAfter(session, lastSynch);\n  }","commit_id":"14f3d9c637640ed06a82a700fdd76ecea2f6330a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @Ignore(\"To be fixed\")\n  public void synchronize_a_lot_of_issues() throws Exception {\n    ComponentDto project = new ComponentDto()\n      .setKey(\"MyProject\")\n      .setProjectId_unit_test_only(1L);\n    db.componentDao().insert(session, project);\n\n    // project can be seen by anyone\n    tester.get(PermissionFacade.class).insertGroupPermission(project.getId(), DefaultGroups.ANYONE, UserRole.USER, session);\n    db.issueAuthorizationDao().synchronizeAfter(session, new Date(0));\n\n    ComponentDto resource = new ComponentDto()\n      .setProjectId_unit_test_only(project.getId())\n      .setKey(\"MyComponent\");\n    db.componentDao().insert(session, resource);\n    db.snapshotDao().insert(session, SnapshotTesting.createForComponent(resource));\n\n    List<String> issueKeys = newArrayList();\n    for (int i = 0; i < 11; i++) {\n      IssueDto issue = IssueTesting.newDto(rule, resource, project);\n      tester.get(IssueDao.class).insert(session, issue);\n      issueKeys.add(issue.getKey());\n    }\n    session.commit();\n\n    // Clear issue index in order to simulate these issues have been inserted without being indexed in E/S (from a previous version of SQ or from batch)\n    tester.get(BackendCleanup.class).clearIndex(IndexDefinition.ISSUES);\n\n    DbSession newSession = db.openSession(false);\n    newSession.setImplicitCommitSize(10);\n    try {\n      db.issueDao().synchronizeAfter(newSession, new Date(0));\n      newSession.commit();\n\n      assertThat(index.search(IssueQuery.builder().build(), new QueryContext().setMaxLimit()).getHits()).hasSize(10);\n    } finally {\n      newSession.close();\n    }\n  }","id":66150,"modified_method":"@Test\n  @Ignore(\"To be fixed\")\n  public void synchronize_a_lot_of_issues() throws Exception {\n    ComponentDto project = new ComponentDto()\n      .setKey(\"MyProject\")\n      .setProjectId_unit_test_only(1L);\n    db.componentDao().insert(session, project);\n\n    // project can be seen by anyone\n    tester.get(PermissionFacade.class).insertGroupPermission(project.getId(), DefaultGroups.ANYONE, UserRole.USER, session);\n    db.issueAuthorizationDao().synchronizeAfter(session, new Date(0));\n\n    ComponentDto resource = new ComponentDto()\n      .setProjectId_unit_test_only(project.getId())\n      .setKey(\"MyComponent\");\n    db.componentDao().insert(session, resource);\n    db.snapshotDao().insert(session, SnapshotTesting.createForComponent(resource));\n\n    List<String> issueKeys = newArrayList();\n    for (int i = 0; i < 11; i++) {\n      IssueDto issue = IssueTesting.newDto(rule, resource, project);\n      tester.get(IssueDao.class).insert(session, issue);\n      issueKeys.add(issue.getKey());\n    }\n    session.commit();\n\n    // Clear issue index in order to simulate these issues have been inserted without being indexed in E/S (from a previous version of SQ or from batch)\n    tester.get(BackendCleanup.class).clearIndex(IndexDefinition.ISSUES);\n    tester.clearIndexes();\n    session.commit();\n    session.clearCache();\n\n    DbSession newSession = db.openSession(true);\n    newSession.setImplicitCommitSize(10);\n    try {\n      db.issueDao().synchronizeAfter(newSession, index.getLastSynchronization());\n      newSession.commit();\n\n    } finally {\n      newSession.close();\n      newSession.clearCache();\n    }\n    session.commit();\n    session.clearCache();\n\n    // This test is working with executeStartupTasks !\n//    tester.get(Platform.class).executeStartupTasks();\n\n    assertThat(index.search(IssueQuery.builder().build(), new QueryContext().setMaxLimit()).getHits()).hasSize(11);\n  }","commit_id":"14f3d9c637640ed06a82a700fdd76ecea2f6330a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    UserSession.get().checkGlobalPermission(GlobalPermissions.SCAN_EXECUTION);\n\n    // Switch Issue search\n    if (settings.getString(\"sonar.issues.use_es_backend\") != null) {\n      DbSession session = dbClient.openSession(false);\n      try {\n        String projectKey = request.mandatoryParam(PARAM_PROJECT);\n        AuthorizedComponentDto project = dbClient.componentDao().getAuthorizedComponentByKey(projectKey, session);\n\n        computationService.create(projectKey);\n\n        // Synchronize project permission indexes if no permission found on it\n        if (index.get(IssueAuthorizationIndex.class).getNullableByKey(project.key()) == null) {\n          permissionService.synchronizePermissions(session, project.key());\n          session.commit();\n        }\n\n        // Index project's issues\n        dbClient.issueDao().synchronizeAfter(session,\n          index.get(IssueIndex.class).getLastSynchronization(),\n          ImmutableMap.of(\"project\", project.key()));\n\n        session.commit();\n      } finally {\n        MyBatis.closeQuietly(session);\n      }\n    }\n  }","id":66151,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    UserSession.get().checkGlobalPermission(GlobalPermissions.SCAN_EXECUTION);\n\n    // Switch Issue search\n    if (settings.getString(\"sonar.issues.use_es_backend\") != null) {\n      String projectKey = request.mandatoryParam(PARAM_PROJECT);\n\n      DbSession session = dbClient.openSession(false);\n      try {\n        dbClient.componentDao().getAuthorizedComponentByKey(projectKey, session);\n        computationService.create(projectKey);\n\n      } finally {\n        MyBatis.closeQuietly(session);\n      }\n\n      // Synchronization of lot of data can only be done with a batch session for the moment\n      session = dbClient.openSession(true);\n      try {\n        // Synchronize project permission indexes if no permission found on it\n        if (index.get(IssueAuthorizationIndex.class).getNullableByKey(projectKey) == null) {\n          permissionService.synchronizePermissions(session, projectKey);\n          session.commit();\n        }\n\n        // Index project's issues\n        dbClient.issueDao().synchronizeAfter(session,\n          index.get(IssueIndex.class).getLastSynchronization(),\n          ImmutableMap.of(\"project\", projectKey));\n        session.commit();\n      } finally {\n        MyBatis.closeQuietly(session);\n      }\n    }\n  }","commit_id":"14f3d9c637640ed06a82a700fdd76ecea2f6330a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QProfileRuleResult searchActiveRules(ProfileRuleQuery query, Paging paging) {\n    BoolFilterBuilder filter = boolFilter().must(\n            termFilter(\"profileId\", query.profileId()),\n            hasParentFilter(\"rule\", parentRuleFilter(query))\n        );\n    addMustTermOrTerms(filter, \"severity\", query.severities());\n\n    SearchRequestBuilder builder = index.client().prepareSearch(\"rules\").setTypes(\"active_rule\")\n      .setFilter(filter)\n      .addFields(\"_source\", \"_parent\")\n      .setSize(paging.pageSize())\n      .setFrom(paging.offset());\n    SearchHits hits = index.executeRequest(builder);\n\n    String[] activeRuleSources = new String[hits.getHits().length];\n    String[] parentIds = new String[hits.getHits().length];\n    int hitCounter = 0;\n\n    List<QProfileRule> result = Lists.newArrayList();\n    for (SearchHit hit: hits.getHits()) {\n      activeRuleSources[hitCounter] = hit.sourceAsString();\n      parentIds[hitCounter] = hit.field(\"_parent\").value();\n      hitCounter ++;\n    }\n\n    if (hitCounter > 0) {\n      MultiGetItemResponse[] responses = index.client().prepareMultiGet().add(\"rules\", \"rule\", parentIds)\n        .execute().actionGet().getResponses();\n\n      for (int i = 0; i < hitCounter; i ++) {\n        result.add(new QProfileRule(responses[i].getResponse().getSourceAsString(), activeRuleSources[i]));\n      }\n    }\n\n    return new QProfileRuleResult(result, PagingResult.create(paging.pageSize(), paging.pageIndex(), hits.getTotalHits()));\n  }","id":66152,"modified_method":"public QProfileRuleResult searchActiveRules(ProfileRuleQuery query, Paging paging) {\n    BoolFilterBuilder filter = boolFilter().must(\n            termFilter(\"profileId\", query.profileId()),\n            hasParentFilter(\"rule\", parentRuleFilter(query))\n        );\n    addMustTermOrTerms(filter, \"severity\", query.severities());\n\n    SearchRequestBuilder builder = index.client().prepareSearch(\"rules\").setTypes(\"active_rule\")\n      .setFilter(filter)\n      .addFields(\"_source\", \"_parent\")\n      .setSize(paging.pageSize())\n      .setFrom(paging.offset());\n    SearchHits hits = index.executeRequest(builder);\n\n    List<Map<String, Object>> activeRuleSources = Lists.newArrayList();\n    String[] parentIds = new String[hits.getHits().length];\n    int hitCounter = 0;\n\n    List<QProfileRule> result = Lists.newArrayList();\n    for (SearchHit hit: hits.getHits()) {\n      activeRuleSources.add(hit.sourceAsMap());\n      parentIds[hitCounter] = hit.field(\"_parent\").value();\n      hitCounter ++;\n    }\n\n    if (hitCounter > 0) {\n      MultiGetItemResponse[] responses = index.client().prepareMultiGet().add(\"rules\", \"rule\", parentIds)\n        .execute().actionGet().getResponses();\n\n      for (int i = 0; i < hitCounter; i ++) {\n        result.add(new QProfileRule(responses[i].getResponse().getSourceAsMap(), activeRuleSources.get(i)));\n      }\n    }\n\n    return new QProfileRuleResult(result, PagingResult.create(paging.pageSize(), paging.pageIndex(), hits.getTotalHits()));\n  }","commit_id":"32687065aa3c0e95b30e3758f1e70d78e0ba65eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_find_active_rules() throws Exception {\n    esSetup.client().prepareBulk()\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule759.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"25\").source(testFileAsString(\"should_find_active_rules/active_rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule391.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule523.json\")))\n      .setRefresh(true).execute().actionGet();\n\n    Paging paging = Paging.create(10, 1);\n\n    // All rules for profile 1\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1), paging).rules()).hasSize(2);\n\n    // All rules for profile 2\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(2), paging).rules()).hasSize(1);\n\n    // Inexistent profile\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(3), paging).rules()).hasSize(0);\n\n    // Inexistent name/key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"polop\"), paging).rules()).hasSize(0);\n\n    // Match on key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"DM_CONVERT_CASE\"), paging).rules()).hasSize(1);\n\n    // Match on name\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"Unused Check\"), paging).rules()).hasSize(1);\n\n    // Match on repositoryKey\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).addRepositoryKeys(\"findbugs\"), paging).rules()).hasSize(1);\n  }","id":66153,"modified_method":"@Test\n  public void should_find_active_rules() throws Exception {\n    esSetup.client().prepareBulk()\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule759.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"rule\").source(testFileAsString(\"should_find_active_rules/rule1482.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"25\").source(testFileAsString(\"should_find_active_rules/active_rule25.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule391.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"759\").source(testFileAsString(\"should_find_active_rules/active_rule523.json\")))\n      .add(Requests.indexRequest().index(\"rules\").type(\"active_rule\").parent(\"1482\").source(testFileAsString(\"should_find_active_rules/active_rule2702.json\")))\n      .setRefresh(true).execute().actionGet();\n\n    Paging paging = Paging.create(10, 1);\n\n    // All rules for profile 1\n    List<QProfileRule> rules1 = profileRules.searchActiveRules(ProfileRuleQuery.create(1), paging).rules();\n    assertThat(rules1).hasSize(3);\n    assertThat(rules1.get(0).key()).isEqualTo(\"DM_CONVERT_CASE\");\n    assertThat(rules1.get(0).severity()).isEqualTo(RulePriority.MINOR);\n\n    // All rules for profile 2\n    List<QProfileRule> rules2 = profileRules.searchActiveRules(ProfileRuleQuery.create(2), paging).rules();\n    assertThat(rules2).hasSize(1);\n    assertThat(rules2.get(0).ruleSource().get(\"id\")).isEqualTo(759);\n    assertThat(rules2.get(0).activeRuleSource().get(\"id\")).isEqualTo(523);\n\n    // Inexistent profile\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(3), paging).rules()).hasSize(0);\n\n    // Inexistent name/key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"polop\"), paging).rules()).hasSize(0);\n\n    // Match on key\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"DM_CONVERT_CASE\"), paging).rules()).hasSize(1);\n\n    // Match on name\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"Unused Check\"), paging).rules()).hasSize(1);\n\n    // Match on repositoryKey\n    assertThat(profileRules.searchActiveRules(ProfileRuleQuery.create(1).addRepositoryKeys(\"findbugs\"), paging).rules()).hasSize(1);\n\n    // Match on key, rule has parameters\n    List<QProfileRule> rulesWParam = profileRules.searchActiveRules(ProfileRuleQuery.create(1).setNameOrKey(\"ArchitecturalConstraint\"), paging).rules();\n    assertThat(rulesWParam).hasSize(1);\n    assertThat(rulesWParam.get(0).params()).hasSize(2);\n  }","commit_id":"32687065aa3c0e95b30e3758f1e70d78e0ba65eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QProfileRule(String ruleSource, String activeRuleSource) {\n    this.ruleSource = ruleSource;\n    this.activeRuleSource = activeRuleSource;\n  }","id":66154,"modified_method":"public QProfileRule(Map<String, Object> ruleSource, Map<String, Object> activeRuleSource) {\n    this.ruleSource = ruleSource;\n    this.activeRuleSource = activeRuleSource;\n\n    key = (String) ruleSource.get(\"key\");\n    name = (String) ruleSource.get(\"name\");\n    description = (String) ruleSource.get(\"description\");\n    status = (String) ruleSource.get(\"status\");\n\n    severity = RulePriority.valueOf((String) activeRuleSource.get(\"severity\"));\n    params = Lists.newArrayList();\n    if (ruleSource.containsKey(\"params\")) {\n      Map<String, Map<String, Object>> ruleParams = Maps.newHashMap();\n      for (Map<String, Object> ruleParam: (List<Map<String, Object>>) ruleSource.get(\"params\")) {\n        ruleParams.put((String) ruleParam.get(\"key\"), ruleParam);\n      }\n      Map<String, Map<String, Object>> activeRuleParams = Maps.newHashMap();\n      for (Map<String, Object> activeRuleParam: (List<Map<String, Object>>) activeRuleSource.get(\"params\")) {\n        activeRuleParams.put((String) activeRuleParam.get(\"key\"), activeRuleParam);\n      }\n      for(Map.Entry<String, Map<String, Object>> ruleParam: ruleParams.entrySet()) {\n        params.add(new Param(\n          (String) ruleParam.getValue().get(\"key\"),\n          activeRuleParams.containsKey(ruleParam.getKey()) ? (String) activeRuleParams.get(ruleParam.getKey())\n            .get(\"value\") : null,\n          (String) ruleParam.getValue().get(\"description\"),\n          (String) ruleParam.getValue().get(\"defaultValue\"),\n          (String) ruleParam.getValue().get(\"type\")\n        ));\n      }\n    }\n  }","commit_id":"32687065aa3c0e95b30e3758f1e70d78e0ba65eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Collection<QProfileRule> rules() {\n    return rules;\n  }","id":66155,"modified_method":"public List<QProfileRule> rules() {\n    return rules;\n  }","commit_id":"32687065aa3c0e95b30e3758f1e70d78e0ba65eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void configureRoot(Props props, LoggerContext loggerContext) {\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(loggerContext, \"ROOT_CONSOLE\", APP_PATTERN, null);\n    Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n    rootLogger.setLevel(Level.toLevel(props.value(\"sonar.app.log.level\", Level.INFO.toString()), Level.INFO));\n    rootLogger.addAppender(consoleAppender);\n  }","id":66156,"modified_method":"private void configureRoot(Props props, LoggerContext loggerContext) {\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(loggerContext, \"ROOT_CONSOLE\", APP_PATTERN);\n    Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n    rootLogger.setLevel(Level.toLevel(props.value(\"sonar.app.log.level\", Level.INFO.toString()), Level.INFO));\n    rootLogger.addAppender(consoleAppender);\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void configureConsole(LoggerContext loggerContext) {\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(loggerContext, CONSOLE_APPENDER, \"%msg%n\", null);\n    Logger consoleLogger = loggerContext.getLogger(CONSOLE_LOGGER);\n    consoleLogger.setAdditive(false);\n    consoleLogger.addAppender(consoleAppender);\n  }","id":66157,"modified_method":"private void configureConsole(LoggerContext loggerContext) {\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(loggerContext, CONSOLE_APPENDER, \"%msg%n\");\n    Logger consoleLogger = loggerContext.getLogger(CONSOLE_LOGGER);\n    consoleLogger.setAdditive(false);\n    consoleLogger.addAppender(consoleAppender);\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static Profiler startProfiler(CeTask task) {\n    Profiler profiler = Profiler.create(LOG);\n    addContext(profiler, task);\n    return profiler.startInfo(\"Execute task\");\n  }","id":66158,"modified_method":"private static Profiler startProfiler(CeTask task) {\n    Profiler profiler = Profiler.create(LOG);\n    addContext(profiler, task);\n    return profiler.startDebug(\"Execute task\");\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void stopProfiler(Profiler profiler, CeTask task, CeActivityDto.Status status) {\n    addContext(profiler, task);\n    if (status == CeActivityDto.Status.FAILED) {\n      profiler.stopError(\"Executed task\");\n    } else {\n      profiler.stopInfo(\"Executed task\");\n    }\n  }","id":66159,"modified_method":"private static void stopProfiler(Profiler profiler, CeTask task, CeActivityDto.Status status) {\n    if (!profiler.isDebugEnabled()) {\n      return;\n    }\n\n    addContext(profiler, task);\n    if (status == CeActivityDto.Status.FAILED) {\n      profiler.stopError(\"Executed task\");\n    } else {\n      profiler.stopDebug(\"Executed task\");\n    }\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_not_display_submitter_param_in_log_when_submitterLogin_is_not_set_in_case_of_error() throws Exception {\n    CeTask ceTask = createCeTask(null);\n    when(queue.peek()).thenReturn(Optional.of(ceTask));\n    taskProcessorRepository.setProcessorForTask(ceTask.getType(), taskProcessor);\n    makeTaskProcessorFail(ceTask);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(2);\n    for (int i = 0; i < 2; i++) {\n      assertThat(logs.get(i)).doesNotContain(\" | submitter=\");\n    }\n    logs = logTester.logs(LoggerLevel.ERROR);\n    assertThat(logs).hasSize(3);\n    for (int i = 0; i < 3; i++) {\n      assertThat(logs.get(i)).doesNotContain(\" | submitter=\");\n    }\n  }","id":66160,"modified_method":"@Test\n  public void do_not_display_submitter_param_in_log_when_submitterLogin_is_not_set_in_case_of_error() throws Exception {\n    CeTask ceTask = createCeTask(null);\n    when(queue.peek()).thenReturn(Optional.of(ceTask));\n    taskProcessorRepository.setProcessorForTask(ceTask.getType(), taskProcessor);\n    makeTaskProcessorFail(ceTask);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(1);\n    assertThat(logs.get(0)).doesNotContain(\" | submitter=\");\n    logs = logTester.logs(LoggerLevel.ERROR);\n    assertThat(logs).hasSize(2);\n    for (int i = 0; i < 2; i++) {\n      assertThat(logs.get(i)).doesNotContain(\" | submitter=\");\n    }\n    assertThat(logTester.logs(LoggerLevel.DEBUG)).isEmpty();\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void display_submitterLogin_in_logs_when_set_in_case_of_success() throws Exception {\n    when(queue.peek()).thenReturn(Optional.of(createCeTask(\"FooBar\")));\n    taskProcessorRepository.setProcessorForTask(CeTaskTypes.REPORT, taskProcessor);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(4);\n    for (int i = 0; i < 2; i++) {\n      assertThat(logs.get(i)).contains(\" | submitter=FooBar\");\n    }\n    for (int i = 2; i < 4; i++) {\n      assertThat(logs.get(i)).contains(\" | submitter=FooBar | time=\");\n    }\n  }","id":66161,"modified_method":"@Test\n  public void display_submitterLogin_in_logs_when_set_in_case_of_success() throws Exception {\n    when(queue.peek()).thenReturn(Optional.of(createCeTask(\"FooBar\")));\n    taskProcessorRepository.setProcessorForTask(CeTaskTypes.REPORT, taskProcessor);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(2);\n    assertThat(logs.get(0)).contains(\" | submitter=FooBar\");\n    assertThat(logs.get(1)).contains(\" | submitter=FooBar | time=\");\n    assertThat(logTester.logs(LoggerLevel.ERROR)).isEmpty();\n    assertThat(logTester.logs(LoggerLevel.DEBUG)).isEmpty();\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void display_submitterLogin_in_logs_when_set_in_case_of_error() throws Exception {\n    CeTask ceTask = createCeTask(\"FooBar\");\n    when(queue.peek()).thenReturn(Optional.of(ceTask));\n    taskProcessorRepository.setProcessorForTask(ceTask.getType(), taskProcessor);\n    makeTaskProcessorFail(ceTask);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(2);\n    for (int i = 0; i < 2; i++) {\n      assertThat(logs.get(i)).contains(\" | submitter=FooBar\");\n    }\n    logs = logTester.logs(LoggerLevel.ERROR);\n    assertThat(logs).hasSize(3);\n    for (int i = 0; i < 3; i++) {\n      String log = logs.get(i);\n      assertThat(log.contains(\" | submitter=FooBar | time=\") || log.equals(\"Failed to execute task \" + ceTask.getUuid()))\n        .isTrue();\n    }\n  }","id":66162,"modified_method":"@Test\n  public void display_submitterLogin_in_logs_when_set_in_case_of_error() throws Exception {\n    CeTask ceTask = createCeTask(\"FooBar\");\n    when(queue.peek()).thenReturn(Optional.of(ceTask));\n    taskProcessorRepository.setProcessorForTask(ceTask.getType(), taskProcessor);\n    makeTaskProcessorFail(ceTask);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(1);\n    assertThat(logs.iterator().next()).contains(\" | submitter=FooBar\");\n    logs = logTester.logs(LoggerLevel.ERROR);\n    assertThat(logs).hasSize(2);\n    assertThat(logs.get(0)).isEqualTo(\"Failed to execute task \" + ceTask.getUuid());\n    assertThat(logs.get(1)).contains(\" | submitter=FooBar | time=\");\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_not_display_submitter_param_in_log_when_submitterLogin_is_not_set_in_case_of_success() throws Exception {\n    when(queue.peek()).thenReturn(Optional.of(createCeTask(null)));\n    taskProcessorRepository.setProcessorForTask(CeTaskTypes.REPORT, taskProcessor);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(4);\n    for (int i = 0; i < 4; i++) {\n      assertThat(logs.get(i)).doesNotContain(\" | submitter=\");\n    }\n  }","id":66163,"modified_method":"@Test\n  public void do_not_display_submitter_param_in_log_when_submitterLogin_is_not_set_in_case_of_success() throws Exception {\n    when(queue.peek()).thenReturn(Optional.of(createCeTask(null)));\n    taskProcessorRepository.setProcessorForTask(CeTaskTypes.REPORT, taskProcessor);\n\n    underTest.call();\n\n    List<String> logs = logTester.logs(LoggerLevel.INFO);\n    assertThat(logs).hasSize(2);\n    for (int i = 0; i < 2; i++) {\n      assertThat(logs.get(i)).doesNotContain(\" | submitter=\");\n    }\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ConsoleAppender newConsoleAppender(Context loggerContext, String name, String pattern, @Nullable Filter filter) {\n    PatternLayoutEncoder consoleEncoder = new PatternLayoutEncoder();\n    consoleEncoder.setContext(loggerContext);\n    consoleEncoder.setPattern(pattern);\n    consoleEncoder.start();\n    ConsoleAppender consoleAppender = new ConsoleAppender();\n    consoleAppender.setContext(loggerContext);\n    consoleAppender.setEncoder(consoleEncoder);\n    consoleAppender.setName(name);\n    consoleAppender.setTarget(\"System.out\");\n    if (filter != null) {\n      consoleAppender.addFilter(filter);\n    }\n    consoleAppender.start();\n    return consoleAppender;\n  }","id":66164,"modified_method":"public ConsoleAppender newConsoleAppender(Context loggerContext, String name, String pattern, Filter... filters) {\n    PatternLayoutEncoder consoleEncoder = new PatternLayoutEncoder();\n    consoleEncoder.setContext(loggerContext);\n    consoleEncoder.setPattern(pattern);\n    consoleEncoder.start();\n    ConsoleAppender consoleAppender = new ConsoleAppender();\n    consoleAppender.setContext(loggerContext);\n    consoleAppender.setEncoder(consoleEncoder);\n    consoleAppender.setName(name);\n    consoleAppender.setTarget(\"System.out\");\n    for (Filter filter : filters) {\n      consoleAppender.addFilter(filter);\n    }\n    consoleAppender.start();\n    return consoleAppender;\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void newConsoleAppender() {\n    LoggerContext ctx = underTest.getRootContext();\n    ConsoleAppender<?> appender = underTest.newConsoleAppender(ctx, \"MY_APPENDER\", \"%msg%n\", null);\n\n    assertThat(appender.getName()).isEqualTo(\"MY_APPENDER\");\n    assertThat(appender.getContext()).isSameAs(ctx);\n    assertThat(appender.isStarted()).isTrue();\n    assertThat(((PatternLayoutEncoder) appender.getEncoder()).getPattern()).isEqualTo(\"%msg%n\");\n    assertThat(appender.getCopyOfAttachedFiltersList()).isEmpty();\n  }","id":66165,"modified_method":"@Test\n  public void newConsoleAppender() {\n    LoggerContext ctx = underTest.getRootContext();\n    ConsoleAppender<?> appender = underTest.newConsoleAppender(ctx, \"MY_APPENDER\", \"%msg%n\");\n\n    assertThat(appender.getName()).isEqualTo(\"MY_APPENDER\");\n    assertThat(appender.getContext()).isSameAs(ctx);\n    assertThat(appender.isStarted()).isTrue();\n    assertThat(((PatternLayoutEncoder) appender.getEncoder()).getPattern()).isEqualTo(\"%msg%n\");\n    assertThat(appender.getCopyOfAttachedFiltersList()).isEmpty();\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void startInternal() throws Exception {\n    ProgrammaticLogbackValve valve = new ProgrammaticLogbackValve();\n    valve.setContainer(mock(Container.class));\n    LogbackHelper helper = new LogbackHelper();\n    ConsoleAppender<IAccessEvent> appender = helper.newConsoleAppender(valve, \"CONSOLE\", \"combined\", null);\n    valve.addAppender(appender);\n\n    valve.start();\n    assertThat(valve.isStarted()).isTrue();\n\n    valve.stop();\n    assertThat(valve.isStarted()).isFalse();\n  }","id":66166,"modified_method":"@Test\n  public void startInternal() throws Exception {\n    ProgrammaticLogbackValve valve = new ProgrammaticLogbackValve();\n    valve.setContainer(mock(Container.class));\n    LogbackHelper helper = new LogbackHelper();\n    ConsoleAppender<IAccessEvent> appender = helper.newConsoleAppender(valve, \"CONSOLE\", \"combined\");\n    valve.addAppender(appender);\n\n    valve.start();\n    assertThat(valve.isStarted()).isTrue();\n\n    valve.stop();\n    assertThat(valve.isStarted()).isFalse();\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public LoggerContext configure() {\n    LoggerContext ctx = helper.getRootContext();\n    ctx.reset();\n\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(ctx, \"CONSOLE\", LOG_FORMAT, null);\n    Logger rootLogger = helper.configureLogger(Logger.ROOT_LOGGER_NAME, Level.INFO);\n    rootLogger.addAppender(consoleAppender);\n    return ctx;\n  }","id":66167,"modified_method":"public LoggerContext configure() {\n    LoggerContext ctx = helper.getRootContext();\n    ctx.reset();\n\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(ctx, \"CONSOLE\", LOG_FORMAT);\n    Logger rootLogger = helper.configureLogger(Logger.ROOT_LOGGER_NAME, Level.INFO);\n    rootLogger.addAppender(consoleAppender);\n    return ctx;\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected abstract void configureExtraAppenders(LoggerContext ctx, LogbackHelper helper, Props props);","id":66168,"modified_method":"protected abstract void configureAppenders(String logFormat, LoggerContext ctx, LogbackHelper helper, Props props);","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"ServerProcessLogging(String processName) {\n    this.processName = processName;\n  }","id":66169,"modified_method":"protected ServerProcessLogging(String processName) {\n    this.processName = processName;\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void configureAppenders(LoggerContext ctx, Props props) {\n    String logFormat = LOG_FORMAT.replace(\"XXXX\", processName);\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(ctx, \"CONSOLE\", logFormat, new CeTaskLogDenyFilter<ILoggingEvent>());\n    ctx.getLogger(Logger.ROOT_LOGGER_NAME).addAppender(consoleAppender);\n    configureExtraAppenders(ctx, helper, props);\n  }","id":66170,"modified_method":"private void configureAppenders(LoggerContext ctx, Props props) {\n    String logFormat = LOG_FORMAT.replace(\"XXXX\", processName);\n    configureAppenders(logFormat, ctx, helper, props);\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configureExtraAppenders(LoggerContext ctx, LogbackHelper helper, Props props) {\n    // nothing to do\n  }","id":66171,"modified_method":"@Override\n  protected void configureAppenders(String logFormat, LoggerContext ctx, LogbackHelper helper, Props props) {\n    ConsoleAppender<ILoggingEvent> consoleAppender = helper.newConsoleAppender(ctx, \"CONSOLE\", logFormat);\n    ctx.getLogger(Logger.ROOT_LOGGER_NAME).addAppender(consoleAppender);\n  }","commit_id":"12ad1060151fb075c685c104bb9bd60999bb0ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public FSDataOutputStream create(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        LOG.debug(\"Creating HDFS file at {}\", path);\n        return FileSystem.create(mFs, new Path(path), PERMISSION);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66172,"modified_method":"@Override\n  public FSDataOutputStream create(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        LOG.debug(\"Creating HDFS file at {}\", path);\n        return FileSystem.create(mFs, new Path(path), PERMISSION);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} : {}\", cnt, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    LOG.debug(\"Renaming from {} to {}\", src, dst);\n    if (!exists(src)) {\n      LOG.error(\"File \" + src + \" does not exist. Therefore rename to \" + dst + \" failed.\");\n      return false;\n    }\n\n    if (exists(dst)) {\n      LOG.error(\"File \" + dst + \" does exist. Therefore rename from \" + src + \" failed.\");\n      return false;\n    }\n\n    int cnt = 0;\n    IOException te = null;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.rename(new Path(src), new Path(dst));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" try to rename \" + src + \" to \" + dst + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66173,"modified_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    LOG.debug(\"Renaming from {} to {}\", src, dst);\n    if (!exists(src)) {\n      LOG.error(\"File {} does not exist. Therefore rename to {} failed.\", src, dst);\n      return false;\n    }\n\n    if (exists(dst)) {\n      LOG.error(\"File {} does exist. Therefore rename from {} failed.\", dst, src);\n      return false;\n    }\n\n    int cnt = 0;\n    IOException te = null;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.rename(new Path(src), new Path(dst));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} try to rename {} to {} : {}\", cnt, src, dst, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public List<String> getFileLocations(String path, long offset) throws IOException {\n    List<String> ret = new ArrayList<String>();\n    try {\n      FileStatus fStatus = mFs.getFileStatus(new Path(path));\n      BlockLocation[] bLocations = mFs.getFileBlockLocations(fStatus, offset, 1);\n      if (bLocations.length > 0) {\n        String[] names = bLocations[0].getNames();\n        Collections.addAll(ret, names);\n      }\n    } catch (IOException e) {\n      LOG.error(\"Unable to get file location for \" + path, e);\n    }\n    return ret;\n  }","id":66174,"modified_method":"@Override\n  public List<String> getFileLocations(String path, long offset) throws IOException {\n    List<String> ret = new ArrayList<String>();\n    try {\n      FileStatus fStatus = mFs.getFileStatus(new Path(path));\n      BlockLocation[] bLocations = mFs.getFileBlockLocations(fStatus, offset, 1);\n      if (bLocations.length > 0) {\n        String[] names = bLocations[0].getNames();\n        Collections.addAll(ret, names);\n      }\n    } catch (IOException e) {\n      LOG.error(\"Unable to get file location for {}\", path, e);\n    }\n    return ret;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean exists(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.exists(new Path(path));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" try to check if \" + path + \" exists \" + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66175,"modified_method":"@Override\n  public boolean exists(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.exists(new Path(path));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} try to check if {} exists : {}\", cnt, path, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FSDataInputStream open(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.open(new Path(path));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" try to open \" + path + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66176,"modified_method":"@Override\n  public FSDataInputStream open(String path) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.open(new Path(path));\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} try to open {} : {}\", cnt, path, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        if (mFs.exists(new Path(path))) {\n          LOG.debug(\"Trying to create existing directory at {}\", path);\n          return false;\n        }\n        return mFs.mkdirs(new Path(path), PERMISSION);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" try to make directory for \" + path + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66177,"modified_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        if (mFs.exists(new Path(path))) {\n          LOG.debug(\"Trying to create existing directory at {}\", path);\n          return false;\n        }\n        return mFs.mkdirs(new Path(path), PERMISSION);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} try to make directory for {} : {}\", cnt, path, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public long getFileSize(String path) throws IOException {\n    int cnt = 0;\n    Path tPath = new Path(path);\n    while (cnt < MAX_TRY) {\n      try {\n        FileStatus fs = mFs.getFileStatus(tPath);\n        return fs.getLen();\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" try to get file size for \" + path + \" : \" + e.getMessage(), e);\n      }\n    }\n    return -1;\n  }","id":66178,"modified_method":"@Override\n  public long getFileSize(String path) throws IOException {\n    int cnt = 0;\n    Path tPath = new Path(path);\n    while (cnt < MAX_TRY) {\n      try {\n        FileStatus fs = mFs.getFileStatus(tPath);\n        return fs.getLen();\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} try to get file size for {} : {}\", cnt, path, e.getMessage(), e);\n      }\n    }\n    return -1;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void setPermission(String path, String posixPerm) throws IOException {\n    try {\n      FileStatus fileStatus = mFs.getFileStatus(new Path(path));\n      LOG.info(\"Changing file '\" + fileStatus.getPath() + \"' permissions from: \"\n          + fileStatus.getPermission() + \" to \" + posixPerm);\n      FsPermission perm = new FsPermission(Short.parseShort(posixPerm));\n      mFs.setPermission(fileStatus.getPath(), perm);\n    } catch (IOException e) {\n      LOG.error(\"Fail to set permission for \" + path + \" with perm \" + posixPerm, e);\n      throw e;\n    }\n  }","id":66179,"modified_method":"@Override\n  public void setPermission(String path, String posixPerm) throws IOException {\n    try {\n      FileStatus fileStatus = mFs.getFileStatus(new Path(path));\n      LOG.info(\"Changing file '{}' permissions from: {} to {}\", fileStatus.getPath(),\n          fileStatus.getPermission(), posixPerm);\n      FsPermission perm = new FsPermission(Short.parseShort(posixPerm));\n      mFs.setPermission(fileStatus.getPath(), perm);\n    } catch (IOException e) {\n      LOG.error(\"Fail to set permission for {} with perm {}\", path, posixPerm, e);\n      throw e;\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    LOG.debug(\"deleting {} {}\", path, recursive);\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.delete(new Path(path), recursive);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(cnt + \" : \" + e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","id":66180,"modified_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    LOG.debug(\"deleting {} {}\", path, recursive);\n    IOException te = null;\n    int cnt = 0;\n    while (cnt < MAX_TRY) {\n      try {\n        return mFs.delete(new Path(path), recursive);\n      } catch (IOException e) {\n        cnt ++;\n        LOG.error(\"{} : {}\", cnt, e.getMessage(), e);\n        te = e;\n      }\n    }\n    throw te;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"public HdfsUnderFileSystem(String fsDefaultName, TachyonConf tachyonConf, Object conf) {\n    super(tachyonConf);\n    mUfsPrefix = fsDefaultName;\n    Configuration tConf;\n    if (conf != null && conf instanceof Configuration) {\n      tConf = (Configuration) conf;\n    } else {\n      tConf = new Configuration();\n    }\n    prepareConfiguration(fsDefaultName, tachyonConf, tConf);\n    tConf.addResource(new Path(tConf.get(Constants.UNDERFS_HDFS_CONFIGURATION)));\n    HdfsUnderFileSystemUtils.addS3Credentials(tConf);\n\n    Path path = new Path(mUfsPrefix);\n    try {\n      mFs = path.getFileSystem(tConf);\n    } catch (IOException e) {\n      LOG.error(\"Exception thrown when trying to get FileSystem for \" + mUfsPrefix, e);\n      throw Throwables.propagate(e);\n    }\n  }","id":66181,"modified_method":"public HdfsUnderFileSystem(String fsDefaultName, TachyonConf tachyonConf, Object conf) {\n    super(tachyonConf);\n    mUfsPrefix = fsDefaultName;\n    Configuration tConf;\n    if (conf != null && conf instanceof Configuration) {\n      tConf = (Configuration) conf;\n    } else {\n      tConf = new Configuration();\n    }\n    prepareConfiguration(fsDefaultName, tachyonConf, tConf);\n    tConf.addResource(new Path(tConf.get(Constants.UNDERFS_HDFS_CONFIGURATION)));\n    HdfsUnderFileSystemUtils.addS3Credentials(tConf);\n\n    Path path = new Path(mUfsPrefix);\n    try {\n      mFs = path.getFileSystem(tConf);\n    } catch (IOException e) {\n      LOG.error(\"Exception thrown when trying to get FileSystem for {}\", mUfsPrefix, e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    mClosed = true;\n    mLocalOutputStream.close();\n    try {\n      S3Object obj = new S3Object(mKey);\n      obj.setBucketName(mBucketName);\n      obj.setDataInputFile(mFile);\n      obj.setContentLength(mFile.length());\n      obj.setContentEncoding(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      if (mHash != null) {\n        obj.setMd5Hash(mHash.digest());\n      } else {\n        LOG.warn(\"MD5 was not computed for: \" + mKey);\n      }\n      mClient.putObject(mBucketName, obj);\n      mFile.delete();\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to upload \" + mKey + \". Temporary file @ \" + mFile.getPath());\n      throw new IOException(se);\n    }\n  }","id":66182,"modified_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    mClosed = true;\n    mLocalOutputStream.close();\n    try {\n      S3Object obj = new S3Object(mKey);\n      obj.setBucketName(mBucketName);\n      obj.setDataInputFile(mFile);\n      obj.setContentLength(mFile.length());\n      obj.setContentEncoding(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      if (mHash != null) {\n        obj.setMd5Hash(mHash.digest());\n      } else {\n        LOG.warn(\"MD5 was not computed for: {}\", mKey);\n      }\n      mClient.putObject(mBucketName, obj);\n      mFile.delete();\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to upload {}. Temporary file @ {}\", mKey, mFile.getPath());\n      throw new IOException(se);\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public InputStream open(String path) throws IOException {\n    try {\n      path = stripPrefixIfPresent(path);\n      return new S3InputStream(mBucketName, path, mClient);\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to open file: \" + path, se);\n      return null;\n    }\n  }","id":66183,"modified_method":"@Override\n  public InputStream open(String path) throws IOException {\n    try {\n      path = stripPrefixIfPresent(path);\n      return new S3InputStream(mBucketName, path, mClient);\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to open file: {}\", path, se);\n      return null;\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Internal function to delete a key in S3\n   * @param key the key to delete\n   * @return true if successful, false if an exception is thrown\n   */\n  private boolean deleteInternal(String key) {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n        mClient.deleteObject(mBucketName, keyAsFolder);\n      } else {\n        mClient.deleteObject(mBucketName, stripPrefixIfPresent(key));\n      }\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to delete \" + key, se);\n      return false;\n    }\n    return true;\n  }","id":66184,"modified_method":"/**\n   * Internal function to delete a key in S3\n   * @param key the key to delete\n   * @return true if successful, false if an exception is thrown\n   */\n  private boolean deleteInternal(String key) {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n        mClient.deleteObject(mBucketName, keyAsFolder);\n      } else {\n        mClient.deleteObject(mBucketName, stripPrefixIfPresent(key));\n      }\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to delete {}\", key, se);\n      return false;\n    }\n    return true;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    if (!recursive) {\n      if (isFolder(path) && listInternal(path, false).length != 0) {\n        LOG.error(\"Unable to delete \" + path + \" because it is a non empty directory. Specify \"\n            + \"recursive as true in order to delete non empty directories.\");\n        return false;\n      }\n      return deleteInternal(path);\n    }\n    // Get all relevant files\n    String[] pathsToDelete = listInternal(path, true);\n    for (String pathToDelete : pathsToDelete) {\n      // If we fail to deleteInternal one file, stop\n      if (!deleteInternal(PathUtils.concatPath(path, pathToDelete))) {\n        LOG.error(\"Failed to delete path \" + pathToDelete + \", aborting delete.\");\n        return false;\n      }\n    }\n    return deleteInternal(path);\n  }","id":66185,"modified_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    if (!recursive) {\n      if (isFolder(path) && listInternal(path, false).length != 0) {\n        LOG.error(\"Unable to delete \" + path + \" because it is a non empty directory. Specify \"\n            + \"recursive as true in order to delete non empty directories.\");\n        return false;\n      }\n      return deleteInternal(path);\n    }\n    // Get all relevant files\n    String[] pathsToDelete = listInternal(path, true);\n    for (String pathToDelete : pathsToDelete) {\n      // If we fail to deleteInternal one file, stop\n      if (!deleteInternal(PathUtils.concatPath(path, pathToDelete))) {\n        LOG.error(\"Failed to delete path {}, aborting delete.\", pathToDelete);\n        return false;\n      }\n    }\n    return deleteInternal(path);\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Copies an object to another key.\n   * @param src the source key to copy\n   * @param dst the destination key to copy to\n   * @return true if the operation was successful, false otherwise\n   */\n  private boolean copy(String src, String dst) {\n    try {\n      src = stripPrefixIfPresent(src);\n      dst = stripPrefixIfPresent(dst);\n      LOG.info(\"Copying \" + src + \" to \" + dst);\n      S3Object obj = new S3Object(dst);\n      mClient.copyObject(mBucketName, src, mBucketName, obj, false);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to rename file \" + src + \" to \" + dst);\n      return false;\n    }\n  }","id":66186,"modified_method":"/**\n   * Copies an object to another key.\n   * @param src the source key to copy\n   * @param dst the destination key to copy to\n   * @return true if the operation was successful, false otherwise\n   */\n  private boolean copy(String src, String dst) {\n    try {\n      src = stripPrefixIfPresent(src);\n      dst = stripPrefixIfPresent(dst);\n      LOG.info(\"Copying {} to {}\", src, dst);\n      S3Object obj = new S3Object(dst);\n      mClient.copyObject(mBucketName, src, mBucketName, obj, false);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to rename file {} to {}\", src, dst);\n      return false;\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    if (path == null) {\n      return false;\n    }\n    if (isFolder(path)) {\n      return true;\n    }\n    if (exists(path)) {\n      LOG.error(\"Cannot create directory \" + path + \" because it is already a file.\");\n      return false;\n    }\n    if (!createParent) {\n      if (parentExists(path)) {\n        // Parent directory exists\n        return mkdirsInternal(path);\n      } else {\n        LOG.error(\"Cannot create directory \" + path + \" because parent does not exist\");\n        return false;\n      }\n    }\n    // Parent directories should be created\n    if (parentExists(path)) {\n      // Parent directory exists\n      return mkdirsInternal(path);\n    } else {\n      String parentKey = getParentKey(path);\n      // Recursively make the parent folders\n      return mkdirs(parentKey, true) && mkdirsInternal(path);\n    }\n  }","id":66187,"modified_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    if (path == null) {\n      return false;\n    }\n    if (isFolder(path)) {\n      return true;\n    }\n    if (exists(path)) {\n      LOG.error(\"Cannot create directory {} because it is already a file.\", path);\n      return false;\n    }\n    if (!createParent) {\n      if (parentExists(path)) {\n        // Parent directory exists\n        return mkdirsInternal(path);\n      } else {\n        LOG.error(\"Cannot create directory {} because parent does not exist\", path);\n        return false;\n      }\n    }\n    // Parent directories should be created\n    if (parentExists(path)) {\n      // Parent directory exists\n      return mkdirsInternal(path);\n    } else {\n      String parentKey = getParentKey(path);\n      // Recursively make the parent folders\n      return mkdirs(parentKey, true) && mkdirsInternal(path);\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Lists the files in the given path, the paths will be their logical names and not contain the\n   * folder suffix\n   * @param path the key to list\n   * @param recursive if true will list children directories as well\n   * @return an array of the file and folder names in this directory\n   * @throws IOException\n   */\n  private String[] listInternal(String path, boolean recursive) throws IOException {\n    try {\n      path = stripPrefixIfPresent(path);\n      path = path.endsWith(PATH_SEPARATOR) ? path : path + PATH_SEPARATOR;\n      path = path.equals(PATH_SEPARATOR) ? \"\" : path;\n      // Gets all the objects under the path, because we have no idea if there are non Tachyon\n      // managed \"directories\"\n      S3Object[] objs = mClient.listObjects(mBucketName, path, \"\");\n      if (recursive) {\n        String[] ret = new String[objs.length];\n        for (int i = 0; i < objs.length; i ++) {\n          // Remove parent portion of the key\n          String child = getChildName(objs[i].getKey(), path);\n          // Prune the special folder suffix\n          child = stripFolderSuffixIfPresent(child);\n          ret[i] = child;\n        }\n        return ret;\n      }\n      // Non recursive list\n      Set<String> children = new HashSet<String>();\n      for (S3Object obj : objs) {\n        // Remove parent portion of the key\n        String child = getChildName(obj.getKey(), path);\n        // Remove any portion after the path delimiter\n        int childNameIndex = child.indexOf(PATH_SEPARATOR);\n        child = childNameIndex != -1 ? child.substring(0, childNameIndex) : child;\n        // Prune the special folder suffix\n        child = stripFolderSuffixIfPresent(child);\n        // Add to the set of children, the set will deduplicate.\n        children.add(child);\n      }\n      return children.toArray(new String[children.size()]);\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to list path \" + path);\n      return null;\n    }\n  }","id":66188,"modified_method":"/**\n   * Lists the files in the given path, the paths will be their logical names and not contain the\n   * folder suffix\n   * @param path the key to list\n   * @param recursive if true will list children directories as well\n   * @return an array of the file and folder names in this directory\n   * @throws IOException\n   */\n  private String[] listInternal(String path, boolean recursive) throws IOException {\n    try {\n      path = stripPrefixIfPresent(path);\n      path = path.endsWith(PATH_SEPARATOR) ? path : path + PATH_SEPARATOR;\n      path = path.equals(PATH_SEPARATOR) ? \"\" : path;\n      // Gets all the objects under the path, because we have no idea if there are non Tachyon\n      // managed \"directories\"\n      S3Object[] objs = mClient.listObjects(mBucketName, path, \"\");\n      if (recursive) {\n        String[] ret = new String[objs.length];\n        for (int i = 0; i < objs.length; i ++) {\n          // Remove parent portion of the key\n          String child = getChildName(objs[i].getKey(), path);\n          // Prune the special folder suffix\n          child = stripFolderSuffixIfPresent(child);\n          ret[i] = child;\n        }\n        return ret;\n      }\n      // Non recursive list\n      Set<String> children = new HashSet<String>();\n      for (S3Object obj : objs) {\n        // Remove parent portion of the key\n        String child = getChildName(obj.getKey(), path);\n        // Remove any portion after the path delimiter\n        int childNameIndex = child.indexOf(PATH_SEPARATOR);\n        child = childNameIndex != -1 ? child.substring(0, childNameIndex) : child;\n        // Prune the special folder suffix\n        child = stripFolderSuffixIfPresent(child);\n        // Add to the set of children, the set will deduplicate.\n        children.add(child);\n      }\n      return children.toArray(new String[children.size()]);\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to list path {}\", path);\n      return null;\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the child name based on the parent name.\n   * @param child the key of the child\n   * @param parent the key of the parent\n   * @return the child key with the parent prefix removed, null if the parent prefix is invalid\n   */\n  private String getChildName(String child, String parent) {\n    if (child.startsWith(parent)) {\n      return child.substring(parent.length());\n    }\n    LOG.error(\"Attempted to get childname with an invalid parent argument. Parent: \" + parent\n        + \" Child: \" + child);\n    return null;\n  }","id":66189,"modified_method":"/**\n   * Gets the child name based on the parent name.\n   * @param child the key of the child\n   * @param parent the key of the parent\n   * @return the child key with the parent prefix removed, null if the parent prefix is invalid\n   */\n  private String getChildName(String child, String parent) {\n    if (child.startsWith(parent)) {\n      return child.substring(parent.length());\n    }\n    LOG.error(\"Attempted to get childname with an invalid parent argument. Parent: {} Child: {}\",\n        parent, child);\n    return null;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    if (!exists(src)) {\n      LOG.error(\"Unable to rename \" + src + \" to \" + dst + \" because source does not exist.\");\n      return false;\n    }\n    if (exists(dst)) {\n      LOG.error(\"Unable to rename \" + src + \" to \" + dst + \" because destination already exists.\");\n      return false;\n    }\n    // Source exists and destination does not exist\n    if (isFolder(src)) {\n      // Rename the source folder first\n      if (!copy(convertToFolderName(src), convertToFolderName(dst))) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/child\n      String [] children = list(src);\n      for (String child: children) {\n        if (!rename(PathUtils.concatPath(src, child), PathUtils.concatPath(dst, child))) {\n          return false;\n        }\n      }\n      // Delete src and everything under src\n      return delete(src, true);\n    }\n    // Source is a file and Destination does not exist\n    return copy(src, dst) && deleteInternal(src);\n  }","id":66190,"modified_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    if (!exists(src)) {\n      LOG.error(\"Unable to rename {} to {} because source does not exist.\", src, dst);\n      return false;\n    }\n    if (exists(dst)) {\n      LOG.error(\"Unable to rename {} to {} because destination already exists.\", src, dst);\n      return false;\n    }\n    // Source exists and destination does not exist\n    if (isFolder(src)) {\n      // Rename the source folder first\n      if (!copy(convertToFolderName(src), convertToFolderName(dst))) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/child\n      String [] children = list(src);\n      for (String child: children) {\n        if (!rename(PathUtils.concatPath(src, child), PathUtils.concatPath(dst, child))) {\n          return false;\n        }\n      }\n      // Delete src and everything under src\n      return delete(src, true);\n    }\n    // Source is a file and Destination does not exist\n    return copy(src, dst) && deleteInternal(src);\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"public S3UnderFileSystem(String bucketName, TachyonConf tachyonConf) throws ServiceException {\n    super(tachyonConf);\n    Preconditions.checkArgument(tachyonConf.containsKey(Constants.S3_ACCESS_KEY),\n        \"Property \" + Constants.S3_ACCESS_KEY + \" is required to connect to S3\");\n    Preconditions.checkArgument(tachyonConf.containsKey(Constants.S3_SECRET_KEY),\n        \"Property \" + Constants.S3_SECRET_KEY + \" is required to connect to S3\");\n    AWSCredentials awsCredentials =\n        new AWSCredentials(tachyonConf.get(Constants.S3_ACCESS_KEY), tachyonConf.get(\n            Constants.S3_SECRET_KEY));\n    mBucketName = bucketName;\n\n    Jets3tProperties props = new Jets3tProperties();\n    if (tachyonConf.containsKey(Constants.UNDERFS_S3_PROXY_HOST)) {\n      props.setProperty(\"httpclient.proxy-autodetect\", \"false\");\n      props.setProperty(\"httpclient.proxy-host\", tachyonConf.get(Constants.UNDERFS_S3_PROXY_HOST));\n      props.setProperty(\"httpclient.proxy-port\", tachyonConf.get(Constants.UNDERFS_S3_PROXY_PORT));\n    }\n    if (tachyonConf.containsKey(Constants.UNDERFS_S3_PROXY_HTTPS_ONLY)) {\n      props.setProperty(\"s3service.https-only\",\n          Boolean.toString(tachyonConf.getBoolean(Constants.UNDERFS_S3_PROXY_HTTPS_ONLY)));\n    }\n    LOG.debug(\"Initializing S3 underFs with properties: \" + props.getProperties());\n    mClient = new RestS3Service(awsCredentials, null, null, props);\n    mBucketPrefix = Constants.HEADER_S3N + mBucketName + PATH_SEPARATOR;\n  }","id":66191,"modified_method":"public S3UnderFileSystem(String bucketName, TachyonConf tachyonConf) throws ServiceException {\n    super(tachyonConf);\n    Preconditions.checkArgument(tachyonConf.containsKey(Constants.S3_ACCESS_KEY),\n        \"Property \" + Constants.S3_ACCESS_KEY + \" is required to connect to S3\");\n    Preconditions.checkArgument(tachyonConf.containsKey(Constants.S3_SECRET_KEY),\n        \"Property \" + Constants.S3_SECRET_KEY + \" is required to connect to S3\");\n    AWSCredentials awsCredentials =\n        new AWSCredentials(tachyonConf.get(Constants.S3_ACCESS_KEY), tachyonConf.get(\n            Constants.S3_SECRET_KEY));\n    mBucketName = bucketName;\n\n    Jets3tProperties props = new Jets3tProperties();\n    if (tachyonConf.containsKey(Constants.UNDERFS_S3_PROXY_HOST)) {\n      props.setProperty(\"httpclient.proxy-autodetect\", \"false\");\n      props.setProperty(\"httpclient.proxy-host\", tachyonConf.get(Constants.UNDERFS_S3_PROXY_HOST));\n      props.setProperty(\"httpclient.proxy-port\", tachyonConf.get(Constants.UNDERFS_S3_PROXY_PORT));\n    }\n    if (tachyonConf.containsKey(Constants.UNDERFS_S3_PROXY_HTTPS_ONLY)) {\n      props.setProperty(\"s3service.https-only\",\n          Boolean.toString(tachyonConf.getBoolean(Constants.UNDERFS_S3_PROXY_HTTPS_ONLY)));\n    }\n    LOG.debug(\"Initializing S3 underFs with properties: {}\", props.getProperties());\n    mClient = new RestS3Service(awsCredentials, null, null, props);\n    mBucketPrefix = Constants.HEADER_S3N + mBucketName + PATH_SEPARATOR;\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a directory flagged file with the key and folder suffix.\n   * @param key the key to create a folder\n   * @return true if the operation was successful, false otherwise\n   */\n  private boolean mkdirsInternal(String key) {\n    try {\n      String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n      S3Object obj = new S3Object(keyAsFolder);\n      obj.setDataInputStream(new ByteArrayInputStream(new byte[0]));\n      obj.setContentLength(0);\n      obj.setMd5Hash(DIR_HASH);\n      obj.setContentType(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      mClient.putObject(mBucketName, obj);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to create directory: \" + key, se);\n      return false;\n    }\n  }","id":66192,"modified_method":"/**\n   * Creates a directory flagged file with the key and folder suffix.\n   * @param key the key to create a folder\n   * @return true if the operation was successful, false otherwise\n   */\n  private boolean mkdirsInternal(String key) {\n    try {\n      String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n      S3Object obj = new S3Object(keyAsFolder);\n      obj.setDataInputStream(new ByteArrayInputStream(new byte[0]));\n      obj.setContentLength(0);\n      obj.setMd5Hash(DIR_HASH);\n      obj.setContentType(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      mClient.putObject(mBucketName, obj);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to create directory: {}\", key, se);\n      return false;\n    }\n  }","commit_id":"8a1aa114f3e72fc0192c453e2cb99d07c695a707","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Initializes the staging directory and returns the path. It also\n   * keeps track of all necessary ownership & permissions\n   * @param cluster\n   * @param conf\n   */\n  public static Path getStagingDir(Cluster cluster, Configuration conf) \n  throws IOException,InterruptedException {\n    Path stagingArea = cluster.getStagingAreaDir();\n    FileSystem fs = stagingArea.getFileSystem(conf);\n    String realUser;\n    String currentUser;\n    UserGroupInformation ugi = UserGroupInformation.getLoginUser();\n    realUser = ugi.getShortUserName();\n    currentUser = UserGroupInformation.getCurrentUser().getShortUserName();\n    if (fs.exists(stagingArea)) {\n      FileStatus fsStatus = fs.getFileStatus(stagingArea);\n      String owner = fsStatus.getOwner();\n      if (!(owner.equals(currentUser) || owner.equals(realUser)) || \n          !fsStatus.getPermission().equals(JOB_DIR_PERMISSION)) {\n         throw new IOException(\"The ownership/permissions on the staging \" +\n                      \"directory \" + stagingArea + \" is not as expected. \" + \n                      \"It is owned by \" + owner + \" and permissions are \"+ \n                      fsStatus.getPermission() + \". The directory must \" +\n                      \"be owned by the submitter \" + currentUser + \" or \" +\n                      \"by \" + realUser + \" and permissions must be rwx------\");\n      }\n    } else {\n      fs.mkdirs(stagingArea, \n          new FsPermission(JOB_DIR_PERMISSION));\n    }\n    return stagingArea;\n  }","id":66193,"modified_method":"/**\n   * Initializes the staging directory and returns the path. It also\n   * keeps track of all necessary ownership & permissions\n   * @param cluster\n   * @param conf\n   */\n  public static Path getStagingDir(Cluster cluster, Configuration conf) \n  throws IOException,InterruptedException {\n    Path stagingArea = cluster.getStagingAreaDir();\n    FileSystem fs = stagingArea.getFileSystem(conf);\n    String realUser;\n    String currentUser;\n    UserGroupInformation ugi = UserGroupInformation.getLoginUser();\n    realUser = ugi.getShortUserName();\n    currentUser = UserGroupInformation.getCurrentUser().getShortUserName();\n    if (fs.exists(stagingArea)) {\n      FileStatus fsStatus = fs.getFileStatus(stagingArea);\n      String owner = fsStatus.getOwner();\n      if (!(owner.equals(currentUser) || owner.equals(realUser))) {\n         throw new IOException(\"The ownership on the staging directory \" +\n                      stagingArea + \" is not as expected. \" +\n                      \"It is owned by \" + owner + \". The directory must \" +\n                      \"be owned by the submitter \" + currentUser + \" or \" +\n                      \"by \" + realUser);\n      }\n      if (!fsStatus.getPermission().equals(JOB_DIR_PERMISSION)) {\n        LOG.info(\"Permissions on staging directory \" + stagingArea + \" are \" +\n          \"incorrect: \" + fsStatus.getPermission() + \". Fixing permissions \" +\n          \"to correct value \" + JOB_DIR_PERMISSION);\n        fs.setPermission(stagingArea, JOB_DIR_PERMISSION);\n      }\n    } else {\n      fs.mkdirs(stagingArea, \n          new FsPermission(JOB_DIR_PERMISSION));\n    }\n    return stagingArea;\n  }","commit_id":"5b3610693454d86909ab37391ea0c07014041e8c","url":"https://github.com/apache/hadoop"},{"original_method":"protected boolean mkOneDirWithMode(Path p, File p2f, FsPermission permission)\n      throws IOException {\n    if (permission == null) {\n      permission = FsPermission.getDirDefault();\n    }\n    permission = permission.applyUMask(umask);\n    if (Shell.WINDOWS && NativeIO.isAvailable()) {\n      try {\n        NativeIO.Windows.createDirectoryWithMode(p2f, permission.toShort());\n        return true;\n      } catch (IOException e) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"NativeIO.createDirectoryWithMode error, path = %s, mode = %o\",\n              p2f, permission.toShort()), e);\n        }\n        return false;\n      }\n    } else {\n      boolean b = p2f.mkdir();\n      if (b) {\n        setPermission(p, permission);\n      }\n      return b;\n    }\n  }","id":66194,"modified_method":"protected boolean mkOneDirWithMode(Path p, File p2f, FsPermission permission)\n      throws IOException {\n    if (permission == null) {\n      permission = FsPermission.getDirDefault();\n    }\n    permission = permission.applyUMask(FsPermission.getUMask(getConf()));\n    if (Shell.WINDOWS && NativeIO.isAvailable()) {\n      try {\n        NativeIO.Windows.createDirectoryWithMode(p2f, permission.toShort());\n        return true;\n      } catch (IOException e) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"NativeIO.createDirectoryWithMode error, path = %s, mode = %o\",\n              p2f, permission.toShort()), e);\n        }\n        return false;\n      }\n    } else {\n      boolean b = p2f.mkdir();\n      if (b) {\n        setPermission(p, permission);\n      }\n      return b;\n    }\n  }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void initialize(URI uri, Configuration conf) throws IOException {\n    super.initialize(uri, conf);\n    setConf(conf);\n    umask = FsPermission.getUMask(conf);\n  }","id":66195,"modified_method":"@Override\n  public void initialize(URI uri, Configuration conf) throws IOException {\n    super.initialize(uri, conf);\n    setConf(conf);\n  }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"private LocalFSFileOutputStream(Path f, boolean append,\n        FsPermission permission) throws IOException {\n      File file = pathToFile(f);\n      if (!append && permission == null) {\n        permission = FsPermission.getFileDefault();\n      }\n      if (permission == null) {\n        this.fos = new FileOutputStream(file, append);\n      } else {\n        permission = permission.applyUMask(umask);\n        if (Shell.WINDOWS && NativeIO.isAvailable()) {\n          this.fos = NativeIO.Windows.createFileOutputStreamWithMode(file,\n              append, permission.toShort());\n        } else {\n          this.fos = new FileOutputStream(file, append);\n          boolean success = false;\n          try {\n            setPermission(f, permission);\n            success = true;\n          } finally {\n            if (!success) {\n              IOUtils.cleanup(LOG, this.fos);\n            }\n          }\n        }\n      }\n    }","id":66196,"modified_method":"private LocalFSFileOutputStream(Path f, boolean append,\n        FsPermission permission) throws IOException {\n      File file = pathToFile(f);\n      if (!append && permission == null) {\n        permission = FsPermission.getFileDefault();\n      }\n      if (permission == null) {\n        this.fos = new FileOutputStream(file, append);\n      } else {\n        permission = permission.applyUMask(FsPermission.getUMask(getConf()));\n        if (Shell.WINDOWS && NativeIO.isAvailable()) {\n          this.fos = NativeIO.Windows.createFileOutputStreamWithMode(file,\n              append, permission.toShort());\n        } else {\n          this.fos = new FileOutputStream(file, append);\n          boolean success = false;\n          try {\n            setPermission(f, permission);\n            success = true;\n          } finally {\n            if (!success) {\n              IOUtils.cleanup(LOG, this.fos);\n            }\n          }\n        }\n      }\n    }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"/** Test LocalFileSystem.setPermission */\n  public void testLocalFSsetPermission() throws IOException {\n    if (Path.WINDOWS) {\n      System.out.println(\"Cannot run test for Windows\");\n      return;\n    }\n    Configuration conf = new Configuration();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    LocalFileSystem localfs = FileSystem.getLocal(conf);\n    String filename = \"foo\";\n    Path f = writeFile(localfs, filename);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f);\n      assertEquals(\n          FsPermission.getFileDefault().applyUMask(FsPermission.getUMask(conf)),\n          initialPermission);\n    } catch(Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n\n    String filename1 = \"foo1\";\n    FsPermission perm = new FsPermission((short)0755);\n    Path f1 = writeFile(localfs, filename1, perm);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f1);\n      assertEquals(\n          perm.applyUMask(FsPermission.getUMask(conf)), initialPermission);\n    } catch(Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n\n    String filename2 = \"foo2\";\n    Path f2 = writeFile(localfs, filename2);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f2);\n      Path copyPath = new Path(TEST_PATH_PREFIX + \"/foo_copy\");\n      localfs.rename(f2, copyPath);\n      FsPermission copyPermission = getPermission(localfs, copyPath);\n      assertEquals(copyPermission, initialPermission);\n      f2 = copyPath;\n    } catch (Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n\n    try {\n      // create files and manipulate them.\n      FsPermission all = new FsPermission((short)0777);\n      FsPermission none = new FsPermission((short)0);\n\n      localfs.setPermission(f, none);\n      assertEquals(none, getPermission(localfs, f));\n\n      localfs.setPermission(f, all);\n      assertEquals(all, getPermission(localfs, f));\n    }\n    finally {\n      cleanup(localfs, f);\n      cleanup(localfs, f1);\n      if (localfs.exists(f2)) {\n        localfs.delete(f2, true);\n      }\n    }\n  }","id":66197,"modified_method":"/** Test LocalFileSystem.setPermission */\n  public void testLocalFSsetPermission() throws IOException {\n    if (Path.WINDOWS) {\n      LOGGER.info(\"Cannot run test for Windows\");\n      return;\n    }\n    Configuration conf = new Configuration();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    LocalFileSystem localfs = FileSystem.getLocal(conf);\n    String filename = \"foo\";\n    Path f = writeFile(localfs, filename);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f);\n      assertEquals(\n          FsPermission.getFileDefault().applyUMask(FsPermission.getUMask(conf)),\n          initialPermission);\n    } catch(Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n\n    String filename1 = \"foo1\";\n    FsPermission perm = new FsPermission((short)0755);\n    Path f1 = writeFile(localfs, filename1, perm);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f1);\n      assertEquals(\n          perm.applyUMask(FsPermission.getUMask(conf)), initialPermission);\n    } catch(Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n\n    String filename2 = \"foo2\";\n    Path f2 = writeFile(localfs, filename2);\n    try {\n      FsPermission initialPermission = getPermission(localfs, f2);\n      Path copyPath = new Path(TEST_PATH_PREFIX + \"/foo_copy\");\n      localfs.rename(f2, copyPath);\n      FsPermission copyPermission = getPermission(localfs, copyPath);\n      assertEquals(copyPermission, initialPermission);\n      f2 = copyPath;\n    } catch (Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n\n    try {\n      // create files and manipulate them.\n      FsPermission all = new FsPermission((short)0777);\n      FsPermission none = new FsPermission((short)0);\n\n      localfs.setPermission(f, none);\n      assertEquals(none, getPermission(localfs, f));\n\n      localfs.setPermission(f, all);\n      assertEquals(all, getPermission(localfs, f));\n    }\n    finally {\n      cleanup(localfs, f);\n      cleanup(localfs, f1);\n      if (localfs.exists(f2)) {\n        localfs.delete(f2, true);\n      }\n    }\n  }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"/** Test LocalFileSystem.setOwner */\n  public void testLocalFSsetOwner() throws IOException {\n    if (Path.WINDOWS) {\n      System.out.println(\"Cannot run test for Windows\");\n      return;\n    }\n\n    Configuration conf = new Configuration();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    LocalFileSystem localfs = FileSystem.getLocal(conf);\n    String filename = \"bar\";\n    Path f = writeFile(localfs, filename);\n    List<String> groups = null;\n    try {\n      groups = getGroups();\n      System.out.println(filename + \": \" + getPermission(localfs, f));\n    }\n    catch(IOException e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n    if (groups == null || groups.size() < 1) {\n      System.out.println(\"Cannot run test: need at least one group.  groups=\"\n                         + groups);\n      return;\n    }\n\n    // create files and manipulate them.\n    try {\n      String g0 = groups.get(0);\n      localfs.setOwner(f, null, g0);\n      assertEquals(g0, getGroup(localfs, f));\n\n      if (groups.size() > 1) {\n        String g1 = groups.get(1);\n        localfs.setOwner(f, null, g1);\n        assertEquals(g1, getGroup(localfs, f));\n      } else {\n        System.out.println(\"Not testing changing the group since user \" +\n                           \"belongs to only one group.\");\n      }\n    } \n    finally {cleanup(localfs, f);}\n  }","id":66198,"modified_method":"/** Test LocalFileSystem.setOwner. */\n  public void testLocalFSsetOwner() throws IOException {\n    if (Path.WINDOWS) {\n      LOGGER.info(\"Cannot run test for Windows\");\n      return;\n    }\n\n    Configuration conf = new Configuration();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    LocalFileSystem localfs = FileSystem.getLocal(conf);\n    String filename = \"bar\";\n    Path f = writeFile(localfs, filename);\n    List<String> groups = null;\n    try {\n      groups = getGroups();\n      LOGGER.info(\"{}: {}\", filename, getPermission(localfs, f));\n    }\n    catch(IOException e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n    if (groups == null || groups.size() < 1) {\n      LOGGER.error(\"Cannot run test: need at least one group. groups={}\",\n          groups);\n      return;\n    }\n\n    // create files and manipulate them.\n    try {\n      String g0 = groups.get(0);\n      localfs.setOwner(f, null, g0);\n      assertEquals(g0, getGroup(localfs, f));\n\n      if (groups.size() > 1) {\n        String g1 = groups.get(1);\n        localfs.setOwner(f, null, g1);\n        assertEquals(g1, getGroup(localfs, f));\n      } else {\n        LOGGER.info(\"Not testing changing the group since user \" +\n            \"belongs to only one group.\");\n      }\n    } \n    finally {cleanup(localfs, f);}\n  }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"public void testLocalFSDirsetPermission() throws IOException {\n    if (Path.WINDOWS) {\n      System.out.println(\"Cannot run test for Windows\");\n      return;\n    }\n    Configuration conf = new Configuration();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    LocalFileSystem localfs = FileSystem.getLocal(conf);\n    Path dir = new Path(TEST_PATH_PREFIX + \"dir\");\n    localfs.mkdirs(dir);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir);\n      assertEquals(\n          FsPermission.getDirDefault().applyUMask(FsPermission.getUMask(conf)),\n          initialPermission);\n    } catch(Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n\n    FsPermission perm = new FsPermission((short)0755);\n    Path dir1 = new Path(TEST_PATH_PREFIX + \"dir1\");\n    localfs.mkdirs(dir1, perm);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir1);\n      assertEquals(perm.applyUMask(FsPermission.getUMask(conf)), initialPermission);\n    } catch(Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    }\n\n    Path dir2 = new Path(TEST_PATH_PREFIX + \"dir2\");\n    localfs.mkdirs(dir2);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir2);\n      Path copyPath = new Path(TEST_PATH_PREFIX + \"dir_copy\");\n      localfs.rename(dir2, copyPath);\n      FsPermission copyPermission = getPermission(localfs, copyPath);\n      assertEquals(copyPermission, initialPermission);\n      dir2 = copyPath;\n    } catch (Exception e) {\n      System.out.println(StringUtils.stringifyException(e));\n      System.out.println(\"Cannot run test\");\n      return;\n    } finally {\n      cleanup(localfs, dir);\n      cleanup(localfs, dir1);\n      if (localfs.exists(dir2)) {\n        localfs.delete(dir2, true);\n      }\n    }\n  }","id":66199,"modified_method":"public void testLocalFSDirsetPermission() throws IOException {\n    if (Path.WINDOWS) {\n      LOGGER.info(\"Cannot run test for Windows\");\n      return;\n    }\n    LocalFileSystem localfs = FileSystem.getLocal(new Configuration());\n    Configuration conf = localfs.getConf();\n    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, \"044\");\n    Path dir = new Path(TEST_PATH_PREFIX + \"dir\");\n    localfs.mkdirs(dir);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir);\n      assertEquals(\n          FsPermission.getDirDefault().applyUMask(FsPermission.getUMask(conf)),\n          initialPermission);\n    } catch(Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n\n    FsPermission perm = new FsPermission((short)0755);\n    Path dir1 = new Path(TEST_PATH_PREFIX + \"dir1\");\n    localfs.mkdirs(dir1, perm);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir1);\n      assertEquals(perm.applyUMask(FsPermission.getUMask(conf)), initialPermission);\n    } catch(Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    }\n\n    Path dir2 = new Path(TEST_PATH_PREFIX + \"dir2\");\n    localfs.mkdirs(dir2);\n    try {\n      FsPermission initialPermission = getPermission(localfs, dir2);\n      Path copyPath = new Path(TEST_PATH_PREFIX + \"dir_copy\");\n      localfs.rename(dir2, copyPath);\n      FsPermission copyPermission = getPermission(localfs, copyPath);\n      assertEquals(copyPermission, initialPermission);\n      dir2 = copyPath;\n    } catch (Exception e) {\n      LOGGER.error(\"Cannot run test\", e);\n      return;\n    } finally {\n      cleanup(localfs, dir);\n      cleanup(localfs, dir1);\n      if (localfs.exists(dir2)) {\n        localfs.delete(dir2, true);\n      }\n    }\n  }","commit_id":"76be82bc0419affbe0103bc4f45c90926f08d0cc","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n\t\tpublic void startDocument(String name, int current, int count) throws TerminatedException {\n            builder.startElement(RESOURCE_ELEMENT, null);\n            builder.characters(name);\n            builder.endElement();\n\t\t}","id":66200,"modified_method":"@Override\n\t\tpublic void startDocument(String name, int current, int count) throws TerminatedException {\n\t\t\tif (builder == null)\n\t\t\t\tSystemExport.LOG.info(\"Document \"+name);\n\t\t\telse {\n\t            builder.startElement(RESOURCE_ELEMENT, null);\n\t            builder.characters(name);\n\t            builder.endElement();\n\t\t\t}\n\t\t}","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\t\tpublic void error(String message, Throwable exception) {\n            builder.startElement(ERROR_ELEMENT, null);\n            builder.characters(message);\n            builder.endElement();\n\t\t}","id":66201,"modified_method":"@Override\n\t\tpublic void error(String message, Throwable exception) {\n\t\t\tif (builder == null)\n\t\t\t\tSystemExport.LOG.error(message, exception);\n\t\t\telse {\n\t            builder.startElement(ERROR_ELEMENT, null);\n\t            builder.characters(message);\n\t            builder.endElement();\n\t\t\t}\n\t\t}","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\tif( !context.getSubject().hasDbaRole() )\n\t\t\tthrow( new XPathException( this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to kill a running xquery\" ) );\n\n    \tString dirOrFile = args[0].getStringValue();\n        boolean incremental  = false;\n        if (args[1].hasOne())\n        \tincremental = args[1].effectiveBooleanValue();\n        boolean zip = false;\n        if (args[2].hasOne())\n        \tzip = args[2].effectiveBooleanValue();\n\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        builder.startDocument();\n        builder.startElement(EXPORT_ELEMENT, null);\n        \n        try {\n        \tSystemExport export = new SystemExport(context.getBroker(), new Callback(builder), null, true);\n            export.export(dirOrFile, incremental, zip, null);\n        } catch (Exception e) {\n            throw new XPathException(this, \"restore failed with exception: \" + e.getMessage(), e);\n        }\n        \n        builder.endElement();\n        builder.endDocument();\n        return (NodeValue) builder.getDocument().getDocumentElement();\n    }","id":66202,"modified_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\tif( !context.getSubject().hasDbaRole() )\n\t\t\tthrow( new XPathException( this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to kill a running xquery\" ) );\n\n    \tString dirOrFile = args[0].getStringValue();\n        boolean incremental  = false;\n        if (args[1].hasOne())\n        \tincremental = args[1].effectiveBooleanValue();\n        boolean zip = false;\n        if (args[2].hasOne())\n        \tzip = args[2].effectiveBooleanValue();\n        \n        MemTreeBuilder builder = null;\n        if (NAME.equals( mySignature.getName() )) {\n\t        builder = context.getDocumentBuilder();\n\t        builder.startDocument();\n\t        builder.startElement(EXPORT_ELEMENT, null);\n        }\n        \n        try {\n        \tSystemExport export = new SystemExport(context.getBroker(), new Callback(builder), null, true);\n            export.export(dirOrFile, incremental, zip, null);\n        } catch (Exception e) {\n            throw new XPathException(this, \"restore failed with exception: \" + e.getMessage(), e);\n        }\n        if (builder == null) {\n        \treturn Sequence.EMPTY_SEQUENCE;\n        } else {\n\t        builder.endElement();\n\t        builder.endDocument();\n\t        return (NodeValue) builder.getDocument().getDocumentElement();\n        }\n    }","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\t\tpublic void startCollection(String path) throws TerminatedException {\n            builder.startElement(COLLECTION_ELEMENT, null);\n            builder.characters(path);\n            builder.endElement();\n\t\t}","id":66203,"modified_method":"@Override\n\t\tpublic void startCollection(String path) throws TerminatedException {\n\t\t\tif (builder == null)\n\t\t\t\tSystemExport.LOG.info(\"Collection \"+path);\n\t\t\telse {\n\t            builder.startElement(COLLECTION_ELEMENT, null);\n\t            builder.characters(path);\n\t            builder.endElement();\n\t\t\t}\n\t\t}","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public FnExport(XQueryContext context) {\n\t\tsuper(context, signature);\n\t}","id":66204,"modified_method":"public FnExport(XQueryContext context, FunctionSignature signature) {\n\t\tsuper(context, signature);\n\t}","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Export a collection. Write out the collection metadata and save the resources stored in the collection.\n     *\n     * @param   current     the collection\n     * @param   output      the output writer\n     * @param   date\n     * @param   prevBackup  DOCUMENT ME!\n     * @param   errorList   a list of {@link org.exist.backup.ErrorReport} objects as returned by methods in {@link org.exist.backup.ConsistencyCheck}\n     * @param   docs        a document set to keep track of all written documents.\n     *\n     * @throws  IOException\n     * @throws  SAXException\n     * @throws  TerminatedException  DOCUMENT ME!\n     */\n    private void export( BackupHandler bh, Collection current, BackupWriter output, Date date, BackupDescriptor prevBackup, List<ErrorReport> errorList, MutableDocumentSet docs ) throws IOException, SAXException, TerminatedException, PermissionDeniedException\n    {\n        if( callback != null ) {\n            callback.startCollection( current.getURI().toString() );\n        }\n\n        if( ( monitor != null ) && !monitor.proceed() ) {\n            throw( new TerminatedException( \"system export terminated by db\" ) );\n        }\n\n//        if( !current.getURI().equalsInternal( XmldbURI.ROOT_COLLECTION_URI ) ) {\n            output.newCollection( Backup.encode( URIUtils.urlDecodeUtf8( current.getURI() ) ) );\n//        }\n\n        try {\n            Writer        contents   = output.newContents();\n\n            // serializer writes to __contents__.xml\n            SAXSerializer serializer = (SAXSerializer)SerializerPool.getInstance().borrowObject( SAXSerializer.class );\n            serializer.setOutput( contents, contentsOutputProps );\n\n            final Permission perm = current.getPermissions();\n            \n            serializer.startDocument();\n            serializer.startPrefixMapping( \"\", Namespaces.EXIST_NS );\n            XmldbURI       uri  = current.getURI();\n            AttributesImpl attr = new AttributesImpl();\n            attr.addAttribute( Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", uri.toString() );\n            attr.addAttribute( Namespaces.EXIST_NS, \"version\", \"version\", \"CDATA\", String.valueOf( currVersion ) );\n            Backup.writeUnixStylePermissionAttributes(attr, perm);\n            try {\n                attr.addAttribute( Namespaces.EXIST_NS, \"created\", \"created\", \"CDATA\", new DateTimeValue( new Date( current.getCreationTime() ) ).getStringValue() );\n            }\n            catch( XPathException e ) {\n                e.printStackTrace();\n            }\n            \n            bh.backup(current, attr);\n            \n            serializer.startElement( Namespaces.EXIST_NS, \"collection\", \"collection\", attr );\n\n            if(perm instanceof ACLPermission) {\n            \tBackup.writeACLPermission(serializer, (ACLPermission)perm);\n            }\n            \n            bh.backup(current, serializer);\n\n            int docsCount = current.getDocumentCountNoLock(broker);\n            int count     = 0;\n\n            for( Iterator<DocumentImpl> i = current.iteratorNoLock( broker ); i.hasNext(); count++ ) {\n                DocumentImpl doc = i.next();\n\n                if( isDamaged( doc, errorList ) ) {\n                    reportError( \"Skipping damaged document \" + doc.getFileURI(), null );\n                    continue;\n                }\n\n                if( doc.getFileURI().equalsInternal( CONTENTS_URI ) || doc.getFileURI().equalsInternal( LOST_URI ) ) {\n                    continue; // skip __contents__.xml documents\n                }\n                exportDocument( bh, output, date, prevBackup, serializer, docsCount, count, doc );\n                docs.add( doc, false );\n            }\n\n            for( Iterator<XmldbURI> i = current.collectionIteratorNoLock(broker); i.hasNext(); ) {\n                XmldbURI childUri = i.next();\n\n                if( childUri.equalsInternal( TEMP_COLLECTION ) ) {\n                    continue;\n                }\n\n                if( isDamagedChild( childUri, errorList ) ) {\n                    reportError( \"Skipping damaged child collection \" + childUri, null );\n                    continue;\n                }\n                attr.clear();\n                attr.addAttribute( Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", childUri.toString() );\n                attr.addAttribute( Namespaces.EXIST_NS, \"filename\", \"filename\", \"CDATA\", Backup.encode( URIUtils.urlDecodeUtf8( childUri.toString() ) ) );\n                serializer.startElement( Namespaces.EXIST_NS, \"subcollection\", \"subcollection\", attr );\n                serializer.endElement( Namespaces.EXIST_NS, \"subcollection\", \"subcollection\" );\n            }\n\n            if( prevBackup != null ) {\n\n                // Check which collections and resources have been deleted since\n                // the\n                // last backup\n                CheckDeletedHandler check = new CheckDeletedHandler( current, serializer );\n\n                try {\n                    prevBackup.parse( check );\n                }\n                catch( Exception e ) {\n                    LOG.error( \"Caught exception while trying to parse previous backup descriptor: \" + prevBackup.getSymbolicPath(), e );\n                }\n            }\n\n            // close <collection>\n            serializer.endElement( Namespaces.EXIST_NS, \"collection\", \"collection\" );\n            serializer.endPrefixMapping( \"\" );\n            serializer.endDocument();\n            output.closeContents();\n        }\n        finally {\n\n//            if( !current.getURI().equalsInternal( XmldbURI.ROOT_COLLECTION_URI ) ) {\n                output.closeCollection();\n//            }\n        }\n    }","id":66205,"modified_method":"/**\n     * Export a collection. Write out the collection metadata and save the resources stored in the collection.\n     *\n     * @param   current     the collection\n     * @param   output      the output writer\n     * @param   date\n     * @param   prevBackup  DOCUMENT ME!\n     * @param   errorList   a list of {@link org.exist.backup.ErrorReport} objects as returned by methods in {@link org.exist.backup.ConsistencyCheck}\n     * @param   docs        a document set to keep track of all written documents.\n     *\n     * @throws  IOException\n     * @throws  SAXException\n     * @throws  TerminatedException  DOCUMENT ME!\n     */\n    private void export( BackupHandler bh, Collection current, BackupWriter output, Date date, BackupDescriptor prevBackup, List<ErrorReport> errorList, MutableDocumentSet docs ) throws IOException, SAXException, TerminatedException, PermissionDeniedException\n    {\n//        if( callback != null ) {\n//            callback.startCollection( current.getURI().toString() );\n//        }\n\n        if( ( monitor != null ) && !monitor.proceed() ) {\n            throw( new TerminatedException( \"system export terminated by db\" ) );\n        }\n\n//        if( !current.getURI().equalsInternal( XmldbURI.ROOT_COLLECTION_URI ) ) {\n            output.newCollection( Backup.encode( URIUtils.urlDecodeUtf8( current.getURI() ) ) );\n//        }\n\n        try {\n            Writer        contents   = output.newContents();\n\n            // serializer writes to __contents__.xml\n            SAXSerializer serializer = (SAXSerializer)SerializerPool.getInstance().borrowObject( SAXSerializer.class );\n            serializer.setOutput( contents, contentsOutputProps );\n\n            final Permission perm = current.getPermissions();\n            \n            serializer.startDocument();\n            serializer.startPrefixMapping( \"\", Namespaces.EXIST_NS );\n            XmldbURI       uri  = current.getURI();\n            AttributesImpl attr = new AttributesImpl();\n            attr.addAttribute( Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", uri.toString() );\n            attr.addAttribute( Namespaces.EXIST_NS, \"version\", \"version\", \"CDATA\", String.valueOf( currVersion ) );\n            Backup.writeUnixStylePermissionAttributes(attr, perm);\n            try {\n                attr.addAttribute( Namespaces.EXIST_NS, \"created\", \"created\", \"CDATA\", new DateTimeValue( new Date( current.getCreationTime() ) ).getStringValue() );\n            }\n            catch( XPathException e ) {\n                e.printStackTrace();\n            }\n            \n            bh.backup(current, attr);\n            \n            serializer.startElement( Namespaces.EXIST_NS, \"collection\", \"collection\", attr );\n\n            if(perm instanceof ACLPermission) {\n            \tBackup.writeACLPermission(serializer, (ACLPermission)perm);\n            }\n            \n            bh.backup(current, serializer);\n\n            int docsCount = current.getDocumentCountNoLock(broker);\n            int count     = 0;\n\n            for( Iterator<DocumentImpl> i = current.iteratorNoLock( broker ); i.hasNext(); count++ ) {\n                DocumentImpl doc = i.next();\n\n                if( isDamaged( doc, errorList ) ) {\n                    reportError( \"Skipping damaged document \" + doc.getFileURI(), null );\n                    continue;\n                }\n\n                if( doc.getFileURI().equalsInternal( CONTENTS_URI ) || doc.getFileURI().equalsInternal( LOST_URI ) ) {\n                    continue; // skip __contents__.xml documents\n                }\n                exportDocument( bh, output, date, prevBackup, serializer, docsCount, count, doc );\n                docs.add( doc, false );\n            }\n\n            for( Iterator<XmldbURI> i = current.collectionIteratorNoLock(broker); i.hasNext(); ) {\n                XmldbURI childUri = i.next();\n\n                if( childUri.equalsInternal( TEMP_COLLECTION ) ) {\n                    continue;\n                }\n\n                if( isDamagedChild( childUri, errorList ) ) {\n                    reportError( \"Skipping damaged child collection \" + childUri, null );\n                    continue;\n                }\n                attr.clear();\n                attr.addAttribute( Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", childUri.toString() );\n                attr.addAttribute( Namespaces.EXIST_NS, \"filename\", \"filename\", \"CDATA\", Backup.encode( URIUtils.urlDecodeUtf8( childUri.toString() ) ) );\n                serializer.startElement( Namespaces.EXIST_NS, \"subcollection\", \"subcollection\", attr );\n                serializer.endElement( Namespaces.EXIST_NS, \"subcollection\", \"subcollection\" );\n            }\n\n            if( prevBackup != null ) {\n\n                // Check which collections and resources have been deleted since\n                // the\n                // last backup\n                CheckDeletedHandler check = new CheckDeletedHandler( current, serializer );\n\n                try {\n                    prevBackup.parse( check );\n                }\n                catch( Exception e ) {\n                    LOG.error( \"Caught exception while trying to parse previous backup descriptor: \" + prevBackup.getSymbolicPath(), e );\n                }\n            }\n\n            // close <collection>\n            serializer.endElement( Namespaces.EXIST_NS, \"collection\", \"collection\" );\n            serializer.endPrefixMapping( \"\" );\n            serializer.endDocument();\n            output.closeContents();\n        }\n        finally {\n\n//            if( !current.getURI().equalsInternal( XmldbURI.ROOT_COLLECTION_URI ) ) {\n                output.closeCollection();\n//            }\n        }\n    }","commit_id":"c431fe5b4fa55ad3dde4a75cf90e068b5d1f3a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void serializeToSAX(NodeSet set, int start, int howmany, long queryTime)\n\t\tthrows SAXException {\n\t\tIterator iter = set.iterator();\n\t\tfor (int i = 0; i < start - 1; i++)\n\t\t\titer.next();\n\n\t\tif (!iter.hasNext())\n\t\t\treturn;\n\t\tcontentHandler.startDocument();\n\t\tcontentHandler.startPrefixMapping(\"exist\", EXIST_NS);\n\t\tAttributesImpl attribs = new AttributesImpl();\n\t\tattribs.addAttribute(\n\t\t\t\"\",\n\t\t\t\"hitCount\",\n\t\t\t\"hitCount\",\n\t\t\t\"CDATA\",\n\t\t\tInteger.toString(set.getLength()));\n\t\tif (queryTime >= 0)\n\t\t\tattribs.addAttribute(\"\", \"queryTime\", \"queryTime\", \"CDATA\", Long.toString(queryTime));\n\n\t\tcontentHandler.startElement(EXIST_NS, \"result\", \"exist:result\", attribs);\n\t\tNodeProxy p;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tIterator domIter;\n\t\tfor (int i = 0; i < howmany && iter.hasNext(); i++) {\n\t\t\tp = (NodeProxy) iter.next();\n\t\t\tif (p == null)\n\t\t\t\tcontinue;\n\t\t\tdomIter = broker.getNodeIterator(p);\n\t\t\tif (domIter == null)\n\t\t\t\tcontinue;\n\t\t\tserializeToSAX(null, domIter, p.doc, p.gid, true, p.match);\n\t\t}\n\t\tcontentHandler.endElement(EXIST_NS, \"result\", \"exist:result\");\n\t\tcontentHandler.endDocument();\n\t}","id":66206,"modified_method":"protected void serializeToSAX(NodeSet set, int start, int howmany, long queryTime)\n\t\tthrows SAXException {\n\t\tboolean generateDocEvents = \n\t\t\toutputProperties.getProperty(Serializer.GENERATE_DOC_EVENTS, \"false\").equals(\"true\");\n\t\tIterator iter = set.iterator();\n\t\tfor (int i = 0; i < start - 1; i++)\n\t\t\titer.next();\n\n\t\tif (!iter.hasNext())\n\t\t\treturn;\n\t\tif(generateDocEvents)\n\t\t\tcontentHandler.startDocument();\n\t\tcontentHandler.startPrefixMapping(\"exist\", EXIST_NS);\n\t\tAttributesImpl attribs = new AttributesImpl();\n\t\tattribs.addAttribute(\n\t\t\t\"\",\n\t\t\t\"hitCount\",\n\t\t\t\"hitCount\",\n\t\t\t\"CDATA\",\n\t\t\tInteger.toString(set.getLength()));\n\t\tif (queryTime >= 0)\n\t\t\tattribs.addAttribute(\"\", \"queryTime\", \"queryTime\", \"CDATA\", Long.toString(queryTime));\n\n\t\tcontentHandler.startElement(EXIST_NS, \"result\", \"exist:result\", attribs);\n\t\tNodeProxy p;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tIterator domIter;\n\t\tfor (int i = 0; i < howmany && iter.hasNext(); i++) {\n\t\t\tp = (NodeProxy) iter.next();\n\t\t\tif (p == null)\n\t\t\t\tcontinue;\n\t\t\tdomIter = broker.getNodeIterator(p);\n\t\t\tif (domIter == null)\n\t\t\t\tcontinue;\n\t\t\tserializeToSAX(null, domIter, p.doc, p.gid, true, p.match);\n\t\t}\n\t\tcontentHandler.endElement(EXIST_NS, \"result\", \"exist:result\");\n\t\tif(generateDocEvents)\n\t\t\tcontentHandler.endDocument();\n\t}","commit_id":"88000084d9c16e8deb07ed801427719139975834","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t *  Description of the Method\n\t *\n\t *@param  n                  Description of the Parameter\n\t *@param  generateDocEvents  Description of the Parameter\n\t *@exception  SAXException   Description of the Exception\n\t */\n\tpublic void toSAX(Node n) throws SAXException {\n\t\tsetXSLHandler();\n\t\tserializeToSAX(n, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"true\").equals(\"true\"));\n\t}","id":66207,"modified_method":"/**\n\t *  Description of the Method\n\t *\n\t *@param  n                  Description of the Parameter\n\t *@param  generateDocEvents  Description of the Parameter\n\t *@exception  SAXException   Description of the Exception\n\t */\n\tpublic void toSAX(Node n) throws SAXException {\n\t\tsetXSLHandler();\n\t\tserializeToSAX(n, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"false\").equals(\"true\"));\n\t}","commit_id":"88000084d9c16e8deb07ed801427719139975834","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t *  Serialize document to SAX stream\n\t *\n\t *@param  doc               Description of the Parameter\n\t *@param  generateDocEvent  call start-document, end-document\n\t *@exception  SAXException  Description of the Exception\n\t */\n\tpublic void toSAX(Document doc) throws SAXException {\n\t\tif (processXSL) {\n\t\t\tString stylesheet = hasXSLPi(doc);\n\t\t\tif (stylesheet != null)\n\t\t\t\tsetStylesheet((DocumentImpl) doc, stylesheet);\n\t\t}\n\t\tsetXSLHandler();\n\t\tserializeToSAX(doc, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"true\").equals(\"true\"));\n\t}","id":66208,"modified_method":"/**\n\t *  Serialize document to SAX stream\n\t *\n\t *@param  doc               Description of the Parameter\n\t *@param  generateDocEvent  call start-document, end-document\n\t *@exception  SAXException  Description of the Exception\n\t */\n\tpublic void toSAX(Document doc) throws SAXException {\n\t\tif (processXSL) {\n\t\t\tString stylesheet = hasXSLPi(doc);\n\t\t\tif (stylesheet != null)\n\t\t\t\tsetStylesheet((DocumentImpl) doc, stylesheet);\n\t\t}\n\t\tsetXSLHandler();\n\t\tserializeToSAX(doc, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"false\").equals(\"true\"));\n\t}","commit_id":"88000084d9c16e8deb07ed801427719139975834","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t *  Description of the Method\n\t *\n\t *@param  p                  Description of the Parameter\n\t *@param  generateDocEvents  Description of the Parameter\n\t *@exception  SAXException   Description of the Exception\n\t */\n\tpublic void toSAX(NodeProxy p) throws SAXException {\n\t\tsetXSLHandler();\n\t\tserializeToSAX(p, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"true\").equals(\"true\"));\n\t}","id":66209,"modified_method":"/**\n\t *  Description of the Method\n\t *\n\t *@param  p                  Description of the Parameter\n\t *@param  generateDocEvents  Description of the Parameter\n\t *@exception  SAXException   Description of the Exception\n\t */\n\tpublic void toSAX(NodeProxy p) throws SAXException {\n\t\tsetXSLHandler();\n\t\tserializeToSAX(p, outputProperties.getProperty(GENERATE_DOC_EVENTS, \"false\").equals(\"true\"));\n\t}","commit_id":"88000084d9c16e8deb07ed801427719139975834","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\tif( !context.getSubject().hasDbaRole() )\n\t\t\tthrow( new XPathException( this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to kill a running xquery\" ) );\n\n    \tString dirOrFile = args[0].getStringValue();\n        String adminPass = null;\n        if (args[1].hasOne())\n                adminPass = args[1].getStringValue();\n        String adminPassAfter = null;\n        if (args[2].hasOne())\n                adminPassAfter = args[2].getStringValue();\n\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        builder.startDocument();\n        builder.startElement(IMPORT_ELEMENT, null);\n        \n        try {\n        \tSystemImport restore = new SystemImport(context.getDatabase());\n            RestoreListener listener = new XMLRestoreListener(builder);\n            restore.restore(listener, org.exist.security.SecurityManager.DBA_USER, adminPass, adminPassAfter, new File(dirOrFile), XmldbURI.EMBEDDED_SERVER_URI.toString());\n        } catch (Exception e) {\n            throw new XPathException(this, \"restore failed with exception: \" + e.getMessage(), e);\n        }\n        \n        builder.endElement();\n        builder.endDocument();\n        return (NodeValue) builder.getDocument().getDocumentElement();\n    }","id":66210,"modified_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\tif( !context.getSubject().hasDbaRole() )\n\t\t\tthrow( new XPathException( this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to kill a running xquery\" ) );\n\n    \tString dirOrFile = args[0].getStringValue();\n        String adminPass = null;\n        if (args[1].hasOne())\n                adminPass = args[1].getStringValue();\n        String adminPassAfter = null;\n        if (args[2].hasOne())\n                adminPassAfter = args[2].getStringValue();\n\n        MemTreeBuilder builder = null;\n        if (NAME.equals( mySignature.getName() )) {\n            builder = context.getDocumentBuilder();\n\t        builder.startDocument();\n\t        builder.startElement(IMPORT_ELEMENT, null);\n        }\n        \n        try {\n        \tSystemImport restore = new SystemImport(context.getDatabase());\n            RestoreListener listener = new XMLRestoreListener(builder);\n            restore.restore(listener, org.exist.security.SecurityManager.DBA_USER, adminPass, adminPassAfter, new File(dirOrFile), XmldbURI.EMBEDDED_SERVER_URI.toString());\n        } catch (Exception e) {\n            throw new XPathException(this, \"restore failed with exception: \" + e.getMessage(), e);\n        }\n        \n        if (builder == null) {\n        \treturn Sequence.EMPTY_SEQUENCE;\n        } else {\n\t        builder.endElement();\n\t        builder.endDocument();\n\t        return (NodeValue) builder.getDocument().getDocumentElement();\n        }\n    }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"public FnImport(XQueryContext context) {\n\t\tsuper(context, signature);\n\t}","id":66211,"modified_method":"public FnImport(XQueryContext context, FunctionSignature signature) {\n\t\tsuper(context, signature);\n\t}","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public void error(String message) {\n            super.error(message);\n            \n            builder.startElement(ERROR_ELEMENT, null);\n            builder.characters(message);\n            builder.endElement();\n        }","id":66212,"modified_method":"@Override\n        public void error(String message) {\n            super.error(message);\n            \n\t\t\tif (builder == null) {\n\t\t\t\tSystemImport.LOG.error(message);\n\t\t\t} else {\n\t            builder.startElement(ERROR_ELEMENT, null);\n\t            builder.characters(message);\n\t            builder.endElement();\n\t\t\t}\n        }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public void info(String message) {\n            builder.startElement(INFO_ELEMENT, null);\n            builder.characters(message);\n            builder.endElement();\n        }","id":66213,"modified_method":"@Override\n        public void info(String message) {\n\t\t\tif (builder == null) {\n\t\t\t\tSystemImport.LOG.info(message);\n\t\t\t} else {\n\t            builder.startElement(INFO_ELEMENT, null);\n\t            builder.characters(message);\n\t            builder.endElement();\n\t\t\t}\n        }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public void createCollection(String collection) {\n            builder.startElement(COLLECTION_ELEMENT, null);\n            builder.characters(collection);\n            builder.endElement();\n        }","id":66214,"modified_method":"@Override\n        public void createCollection(String collection) {\n\t\t\tif (builder == null) {\n\t\t\t\tSystemImport.LOG.info(\"Create collection \"+collection);\n\t\t\t} else {\n\t            builder.startElement(COLLECTION_ELEMENT, null);\n\t            builder.characters(collection);\n\t            builder.endElement();\n\t\t\t}\n        }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public void restored(String resource) {\n            builder.startElement(RESOURCE_ELEMENT, null);\n            builder.characters(resource);\n            builder.endElement();\n        }","id":66215,"modified_method":"@Override\n        public void restored(String resource) {\n\t\t\tif (builder == null) {\n\t\t\t\tSystemImport.LOG.info(\"Restore resource \"+resource);\n\t\t\t} else {\n\t            builder.startElement(RESOURCE_ELEMENT, null);\n\t            builder.characters(resource);\n\t            builder.endElement();\n\t\t\t}\n        }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public void warn(String message) {\n            super.warn(message);\n            \n            builder.startElement(WARN_ELEMENT, null);\n            builder.characters(message);\n            builder.endElement();\n        }","id":66216,"modified_method":"@Override\n        public void warn(String message) {\n            super.warn(message);\n            \n\t\t\tif (builder == null) {\n\t\t\t\tSystemImport.LOG.warn(message);\n\t\t\t} else {\n\t            builder.startElement(WARN_ELEMENT, null);\n\t            builder.characters(message);\n\t            builder.endElement();\n\t\t\t}\n        }","commit_id":"592237b3074d2ce07b46832eda3b6707b9b11a2a","url":"https://github.com/eXist-db/exist"},{"original_method":"@NotNull\n    private JvmClassSignature signature() {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.CLASS);\n\n        typeMapper.writeFormalTypeParameters(descriptor.getTypeConstructor().getParameters(), sw);\n\n        sw.writeSuperclass();\n        if (superClassType == null) {\n            sw.writeClassBegin(superClassAsmType);\n            sw.writeClassEnd();\n        }\n        else {\n            typeMapper.mapSupertype(superClassType, sw);\n        }\n        sw.writeSuperclassEnd();\n\n        List<JetType> interfaceSupertypes = Lists.newArrayList();\n        boolean explicitKObject = false;\n\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n            assert superType != null : \"No supertype for class: \" + myClass.getText();\n            ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n            if (isInterface(superClassDescriptor)) {\n                interfaceSupertypes.add(superType);\n\n                assert superClassDescriptor != null : \"should be already checked by isInterface()\";\n                if (JvmAbi.K_OBJECT.equalsTo(DescriptorUtils.getFqName(superClassDescriptor))) {\n                    explicitKObject = true;\n                }\n            }\n        }\n\n        LinkedHashSet<String> superInterfaces = new LinkedHashSet<String>();\n        if (!explicitKObject) {\n            Type kObject = asmTypeByFqNameWithoutInnerClasses(JvmAbi.K_OBJECT);\n            sw.writeInterface();\n            sw.writeClassBegin(kObject);\n            sw.writeClassEnd();\n            sw.writeInterfaceEnd();\n            superInterfaces.add(kObject.getInternalName());\n        }\n\n        for (JetType supertype : interfaceSupertypes) {\n            sw.writeInterface();\n            Type jvmName = typeMapper.mapSupertype(supertype, sw);\n            sw.writeInterfaceEnd();\n            superInterfaces.add(jvmName.getInternalName());\n        }\n\n        return new JvmClassSignature(classAsmType.getInternalName(), superClassAsmType.getInternalName(),\n                                     new ArrayList<String>(superInterfaces),\n                                     sw.makeJavaGenericSignature());\n    }","id":66217,"modified_method":"@NotNull\n    private JvmClassSignature signature() {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.CLASS);\n\n        typeMapper.writeFormalTypeParameters(descriptor.getTypeConstructor().getParameters(), sw);\n\n        sw.writeSuperclass();\n        if (superClassType == null) {\n            sw.writeClassBegin(superClassAsmType);\n            sw.writeClassEnd();\n        }\n        else {\n            typeMapper.mapSupertype(superClassType, sw);\n        }\n        sw.writeSuperclassEnd();\n\n        List<JetType> interfaceSupertypes = Lists.newArrayList();\n        boolean explicitKObject = false;\n\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n            assert superType != null : \"No supertype for class: \" + myClass.getText();\n            ClassifierDescriptor classifierDescriptor = superType.getConstructor().getDeclarationDescriptor();\n            if (classifierDescriptor instanceof ClassDescriptor) {\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) classifierDescriptor;\n                if (isInterface(superClassDescriptor)) {\n                    interfaceSupertypes.add(superType);\n\n                    if (JvmAbi.K_OBJECT.equalsTo(DescriptorUtils.getFqName(superClassDescriptor))) {\n                        explicitKObject = true;\n                    }\n                }\n            }\n        }\n\n        LinkedHashSet<String> superInterfaces = new LinkedHashSet<String>();\n        if (!explicitKObject) {\n            Type kObject = asmTypeByFqNameWithoutInnerClasses(JvmAbi.K_OBJECT);\n            sw.writeInterface();\n            sw.writeClassBegin(kObject);\n            sw.writeClassEnd();\n            sw.writeInterfaceEnd();\n            superInterfaces.add(kObject.getInternalName());\n        }\n\n        for (JetType supertype : interfaceSupertypes) {\n            sw.writeInterface();\n            Type jvmName = typeMapper.mapSupertype(supertype, sw);\n            sw.writeInterfaceEnd();\n            superInterfaces.add(jvmName.getInternalName());\n        }\n\n        return new JvmClassSignature(classAsmType.getInternalName(), superClassAsmType.getInternalName(),\n                                     new ArrayList<String>(superInterfaces),\n                                     sw.makeJavaGenericSignature());\n    }","commit_id":"db2ad06e9cea85f2dd8725a63dc6457c1040ebce","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void getSuperClass() {\n        superClassAsmType = AsmTypeConstants.OBJECT_TYPE;\n        superClassType = null;\n\n        List<JetDelegationSpecifier> delegationSpecifiers = myClass.getDelegationSpecifiers();\n\n        if (myClass instanceof JetClass && ((JetClass) myClass).isTrait()) {\n            return;\n        }\n\n        if (kind != OwnerKind.IMPLEMENTATION) {\n            throw new IllegalStateException(\"must be impl to reach this code: \" + kind);\n        }\n\n        for (JetDelegationSpecifier specifier : delegationSpecifiers) {\n            if (specifier instanceof JetDelegatorToSuperClass || specifier instanceof JetDelegatorToSuperCall) {\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null :\n                        String.format(\"No type recorded for \\n---\\n%s\\n---\\n\", JetPsiUtil.getElementTextWithContext(specifier));\n\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                assert superClassDescriptor != null;\n                if (!isInterface(superClassDescriptor)) {\n                    superClassType = superType;\n                    superClassAsmType = typeMapper.mapClass(superClassDescriptor);\n                    superCall = specifier;\n                }\n            }\n        }\n\n        if (superClassType == null) {\n            if (descriptor.getKind() == ClassKind.ENUM_CLASS) {\n                superClassType = KotlinBuiltIns.getInstance().getEnumType(descriptor.getDefaultType());\n                superClassAsmType = typeMapper.mapType(superClassType);\n            }\n            if (descriptor.getKind() == ClassKind.ENUM_ENTRY) {\n                superClassType = descriptor.getTypeConstructor().getSupertypes().iterator().next();\n                superClassAsmType = typeMapper.mapType(superClassType);\n            }\n        }\n    }","id":66218,"modified_method":"protected void getSuperClass() {\n        superClassAsmType = AsmTypeConstants.OBJECT_TYPE;\n        superClassType = null;\n\n        List<JetDelegationSpecifier> delegationSpecifiers = myClass.getDelegationSpecifiers();\n\n        if (myClass instanceof JetClass && ((JetClass) myClass).isTrait()) {\n            return;\n        }\n\n        if (kind != OwnerKind.IMPLEMENTATION) {\n            throw new IllegalStateException(\"must be impl to reach this code: \" + kind);\n        }\n\n        for (JetDelegationSpecifier specifier : delegationSpecifiers) {\n            if (specifier instanceof JetDelegatorToSuperClass || specifier instanceof JetDelegatorToSuperCall) {\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null :\n                        String.format(\"No type recorded for \\n---\\n%s\\n---\\n\", JetPsiUtil.getElementTextWithContext(specifier));\n\n                ClassifierDescriptor classifierDescriptor = superType.getConstructor().getDeclarationDescriptor();\n                if (!(classifierDescriptor instanceof ClassDescriptor)) continue;\n\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) classifierDescriptor;\n                if (!isInterface(superClassDescriptor)) {\n                    superClassType = superType;\n                    superClassAsmType = typeMapper.mapClass(superClassDescriptor);\n                    superCall = specifier;\n                }\n            }\n        }\n\n        if (superClassType == null) {\n            if (descriptor.getKind() == ClassKind.ENUM_CLASS) {\n                superClassType = KotlinBuiltIns.getInstance().getEnumType(descriptor.getDefaultType());\n                superClassAsmType = typeMapper.mapType(superClassType);\n            }\n            if (descriptor.getKind() == ClassKind.ENUM_ENTRY) {\n                superClassType = descriptor.getTypeConstructor().getSupertypes().iterator().next();\n                superClassAsmType = typeMapper.mapType(superClassType);\n            }\n        }\n    }","commit_id":"db2ad06e9cea85f2dd8725a63dc6457c1040ebce","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static List<List<TypeProjection>> calculateTypeArgumentsFromSuper(\n            @NotNull JetType autoType,\n            @NotNull Collection<JetType> typesFromSuper\n    ) {\n        ClassDescriptor klass = (ClassDescriptor) autoType.getConstructor().getDeclarationDescriptor();\n\n        // For each superclass of autoType's class and its parameters, hold their mapping to autoType's parameters\n        Multimap<TypeConstructor, TypeProjection> substitution = SubstitutionUtils.buildDeepSubstitutionMultimap(\n                TypeUtils.makeUnsubstitutedType(klass, JetScope.EMPTY));\n\n        // for each parameter of autoType, hold arguments in corresponding supertypes\n        List<List<TypeProjection>> parameterToArgTypesFromSuper = Lists.newArrayList();\n        for (TypeProjection ignored : autoType.getArguments()) {\n            parameterToArgTypesFromSuper.add(new ArrayList<TypeProjection>());\n        }\n\n        // Enumerate all types from super and all its parameters\n        for (JetType typeFromSuper : typesFromSuper) {\n            List<TypeParameterDescriptor> typeFromSuperParameters = typeFromSuper.getConstructor().getParameters();\n            for (int i = 0; i < typeFromSuperParameters.size(); i++) {\n                TypeParameterDescriptor typeFromSuperParam = typeFromSuperParameters.get(i);\n                TypeProjection typeFromSuperArgType = typeFromSuper.getArguments().get(i);\n\n                // if it is mapped to autoType's parameter, then store it into map\n                for (TypeProjection projection : substitution.get(typeFromSuperParam.getTypeConstructor())) {\n                    ClassifierDescriptor classifier = projection.getType().getConstructor().getDeclarationDescriptor();\n\n                    if (classifier instanceof TypeParameterDescriptor && classifier.getContainingDeclaration() == klass) {\n                        parameterToArgTypesFromSuper.get(((TypeParameterDescriptor) classifier).getIndex()).add(typeFromSuperArgType);\n                    }\n                }\n            }\n        }\n        return parameterToArgTypesFromSuper;\n    }","id":66219,"modified_method":"private static List<List<TypeProjection>> calculateTypeArgumentsFromSuper(\n            @NotNull ClassDescriptor klass,\n            @NotNull Collection<JetType> typesFromSuper\n    ) {\n        // For each superclass of klass and its parameters, hold their mapping to klass' parameters\n        // #0 of Bar ->  A\n        // #1 of Bar ->  List<B>\n        // #0 of Baz ->  Boolean\n        // #1 of Baz ->  A\n        // #0 of Foo ->  A (mapped to itself)\n        // #1 of Foo ->  B (mapped to itself)\n        Multimap<TypeConstructor, TypeProjection> substitution = SubstitutionUtils.buildDeepSubstitutionMultimap(\n                TypeUtils.makeUnsubstitutedType(klass, JetScope.EMPTY));\n\n        // for each parameter of klass, hold arguments in corresponding supertypes\n        List<List<TypeProjection>> parameterToArgumentsFromSuper = Lists.newArrayList();\n        for (TypeParameterDescriptor ignored : klass.getTypeConstructor().getParameters()) {\n            parameterToArgumentsFromSuper.add(new ArrayList<TypeProjection>());\n        }\n\n        // Enumerate all types from super and all its parameters\n        for (JetType typeFromSuper : typesFromSuper) {\n            List<TypeParameterDescriptor> typeFromSuperParameters = typeFromSuper.getConstructor().getParameters();\n            for (int i = 0; i < typeFromSuperParameters.size(); i++) {\n                TypeParameterDescriptor parameter = typeFromSuperParameters.get(i);\n                TypeProjection argument = typeFromSuper.getArguments().get(i);\n\n                // for given example, this block is executed four times:\n                // 1. typeFromSuper = Bar<String, List<Int>>,     i = 0,  parameter = \"#0 of Bar\",  argument = String\n                // 2. typeFromSuper = Bar<String, List<Int>>,     i = 1,  parameter = \"#1 of Bar\",  argument = List<Int>\n                // 3. typeFromSuper = Baz<Boolean, CharSequence>, i = 0,  parameter = \"#0 of Baz\",  argument = Boolean\n                // 4. typeFromSuper = Baz<Boolean, CharSequence>, i = 1,  parameter = \"#1 of Baz\",  argument = CharSequence\n\n                // if it is mapped to klass' parameter, then store it into map\n                for (TypeProjection projection : substitution.get(parameter.getTypeConstructor())) {\n                    // 1. projection = A\n                    // 2. projection = List<B>\n                    // 3. projection = Boolean\n                    // 4. projection = A\n                    ClassifierDescriptor classifier = projection.getType().getConstructor().getDeclarationDescriptor();\n\n                    // this condition is true for 1 and 4, false for 2 and 3\n                    if (classifier instanceof TypeParameterDescriptor && classifier.getContainingDeclaration() == klass) {\n                        int parameterIndex = ((TypeParameterDescriptor) classifier).getIndex();\n                        parameterToArgumentsFromSuper.get(parameterIndex).add(argument);\n                    }\n                }\n            }\n        }\n        return parameterToArgumentsFromSuper;\n    }","commit_id":"62b89655b99c4ca7df90f2a61c53170b316a3725","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static List<TypeProjection> getTypeArgsOfReturnType(@NotNull JetType autoType, @NotNull Collection<JetType> typesFromSuper) {\n        TypeConstructor typeConstructor = autoType.getConstructor();\n        List<TypeProjection> autoArguments = autoType.getArguments();\n\n        if (!(typeConstructor.getDeclarationDescriptor() instanceof ClassDescriptor)) {\n            assert autoArguments.isEmpty() :\n                    \"Unexpected type arguments when type constructor is not ClassDescriptor, type = \" + autoType;\n            return autoArguments;\n        }\n\n        List<List<TypeProjection>> typeArgumentsFromSuper = calculateTypeArgumentsFromSuper(autoType, typesFromSuper);\n\n        // Modify type arguments using info from typesFromSuper\n        List<TypeProjection> resultArguments = Lists.newArrayList();\n        for (int i = 0; i < autoArguments.size(); i++) {\n            TypeProjection argument = autoArguments.get(i);\n\n            TypeCheckingProcedure.EnrichedProjectionKind effectiveProjectionKind =\n                    TypeCheckingProcedure.getEffectiveProjectionKind(typeConstructor.getParameters().get(i), argument);\n\n            JetType argumentType = argument.getType();\n            List<TypeProjection> projectionsFromSuper = typeArgumentsFromSuper.get(i);\n            Collection<JetType> argTypesFromSuper = getTypes(projectionsFromSuper);\n            boolean covariantPosition = effectiveProjectionKind == TypeCheckingProcedure.EnrichedProjectionKind.OUT;\n\n            JetType type = modifyReturnTypeAccordingToSuperMethods(argumentType, argTypesFromSuper, covariantPosition);\n            Variance projectionKind = calculateArgumentProjectionKindFromSuper(argument, projectionsFromSuper);\n\n            resultArguments.add(new TypeProjection(projectionKind, type));\n        }\n        return resultArguments;\n    }","id":66220,"modified_method":"@NotNull\n    private static List<TypeProjection> getTypeArgsOfReturnType(@NotNull JetType autoType, @NotNull Collection<JetType> typesFromSuper) {\n        TypeConstructor typeConstructor = autoType.getConstructor();\n        ClassifierDescriptor classifier = typeConstructor.getDeclarationDescriptor();\n        List<TypeProjection> autoArguments = autoType.getArguments();\n\n        if (!(classifier instanceof ClassDescriptor)) {\n            assert autoArguments.isEmpty() :\n                    \"Unexpected type arguments when type constructor is not ClassDescriptor, type = \" + autoType;\n            return autoArguments;\n        }\n\n        List<List<TypeProjection>> typeArgumentsFromSuper = calculateTypeArgumentsFromSuper((ClassDescriptor) classifier, typesFromSuper);\n\n        // Modify type arguments using info from typesFromSuper\n        List<TypeProjection> resultArguments = Lists.newArrayList();\n        for (int i = 0; i < autoArguments.size(); i++) {\n            TypeProjection argument = autoArguments.get(i);\n\n            TypeCheckingProcedure.EnrichedProjectionKind effectiveProjectionKind =\n                    TypeCheckingProcedure.getEffectiveProjectionKind(typeConstructor.getParameters().get(i), argument);\n\n            JetType argumentType = argument.getType();\n            List<TypeProjection> projectionsFromSuper = typeArgumentsFromSuper.get(i);\n            Collection<JetType> argTypesFromSuper = getTypes(projectionsFromSuper);\n            boolean covariantPosition = effectiveProjectionKind == TypeCheckingProcedure.EnrichedProjectionKind.OUT;\n\n            JetType type = modifyReturnTypeAccordingToSuperMethods(argumentType, argTypesFromSuper, covariantPosition);\n            Variance projectionKind = calculateArgumentProjectionKindFromSuper(argument, projectionsFromSuper);\n\n            resultArguments.add(new TypeProjection(projectionKind, type));\n        }\n        return resultArguments;\n    }","commit_id":"62b89655b99c4ca7df90f2a61c53170b316a3725","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @param parameters the Rss macro's parameters needed for getting the data\n     * @throws MacroExecutionException in case the feed cannot be read\n     */\n    public FeedReader(RssMacroParameters parameters) throws MacroExecutionException\n    {\n        if (StringUtils.isEmpty(parameters.getFeed())) {\n            throw new MacroExecutionException(RssMacro.PARAMETER_MISSING_ERROR);\n        }\n\n        SyndFeedInput input = new SyndFeedInput();\n\n        try {\n            URLConnection connection = parameters.getFeedURL().openConnection();\n            connection.setConnectTimeout(TIMEOUT_SECONDS * 1000);\n            feed = input.build(new XmlReader(connection));\n        } catch (SocketTimeoutException ex) {\n            throw new MacroExecutionException(RssMacro.CONNECTION_TIMEOUT_ERROR + OPEN_PARAM + parameters.getFeedURL()\n                + CLOSE_PARAM);\n        } catch (Exception ex) {\n            throw new MacroExecutionException(\"Error processing \" + OPEN_PARAM + parameters.getFeedURL() + CLOSE_PARAM\n                + \" : \" + ex.getMessage(), ex);\n        }\n        if (feed == null) {\n            throw new MacroExecutionException(RssMacro.INVALID_DOCUMENT_ERROR + OPEN_PARAM + parameters.getFeedURL()\n                + CLOSE_PARAM);\n        }\n    }","id":66221,"modified_method":"/**\n     * @param parameters the Rss macro's parameters needed for getting the data\n     * @throws MacroExecutionException in case the feed cannot be read\n     */\n    public FeedReader(RssMacroParameters parameters) throws MacroExecutionException\n    {\n        if (StringUtils.isEmpty(parameters.getFeed())) {\n            throw new MacroExecutionException(\"The required 'feed' parameter is missing\");\n        }\n\n        SyndFeedInput input = new SyndFeedInput();\n\n        try {\n            URLConnection connection = parameters.getFeedURL().openConnection();\n            connection.setConnectTimeout(TIMEOUT_SECONDS * 1000);\n            feed = input.build(new XmlReader(connection));\n        } catch (SocketTimeoutException ex) {\n            throw new MacroExecutionException(MessageFormat.format(\"Connection timeout when trying to reach [{0}]\",\n                parameters.getFeedURL()));\n        } catch (Exception ex) {\n            throw new MacroExecutionException(MessageFormat.format(\"Error processing [{0}] : {1}\", parameters\n                .getFeedURL(), ex.getMessage()), ex);\n        }\n        if (feed == null) {\n            throw new MacroExecutionException(MessageFormat.format(\"No feed found at [{0}]\",\n                parameters.getFeedURL()));\n        }\n    }","commit_id":"15e1a3f61b6a37da783f27b4369db2cb52aae541","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests the macro's behavior when the server hosting the feeds doesn't respond.\n     */\n    public final void testConnectionTimeout() throws MacroParameterException\n    {\n        assertNotNull(macro);\n        assertNotNull(parameters);\n        \n        // We set the feed's URL to an unreachable address.\n        parameters.setFeed(\"http://22.22.22.22\");\n        \n        try {\n            macro.execute(parameters, null, null);\n        } catch (MacroExecutionException ex) {\n            String errorMessage = ex.getMessage();\n            assertTrue(errorMessage.startsWith(RssMacro.CONNECTION_TIMEOUT_ERROR));\n            return;\n        }\n        fail(\"The macro should throw a 'Connection timeout exception'\");\n    }","id":66222,"modified_method":"/**\n     * Tests the macro's behavior when the server hosting the feeds doesn't respond.\n     */\n    public final void testConnectionTimeout() throws MacroParameterException\n    {\n        assertNotNull(macro);\n        assertNotNull(parameters);\n        \n        // We set the feed's URL to an unreachable address.\n        parameters.setFeed(\"http://22.22.22.22\");\n        \n        try {\n            macro.execute(parameters, null, null);\n        } catch (MacroExecutionException ex) {\n            String errorMessage = ex.getMessage();\n            assertTrue(errorMessage.startsWith(\"Connection timeout when trying to reach\"));\n            return;\n        }\n        fail(\"The macro should throw a 'Connection timeout exception'\");\n    }","commit_id":"15e1a3f61b6a37da783f27b4369db2cb52aae541","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests whether the macro throws the appropriate exception \n     * in cases where the required 'feed' parameter is missing.\n     */\n    public final void testRequiredParameterMissing()\n    {\n        assertNotNull(macro);\n        assertNotNull(parameters);\n        if (StringUtils.isNotEmpty(parameters.getFeed())) {\n            parameters = new RssMacroParameters();\n        }\n        try {\n            macro.execute(parameters, null, null);\n        } catch (MacroExecutionException ex) {\n            assertTrue(RssMacro.PARAMETER_MISSING_ERROR.equals(ex.getMessage()));\n            return;\n        }\n        fail(\"No 'feed' parameter specified, the macro should throw an exception\");\n    }","id":66223,"modified_method":"/**\n     * Tests whether the macro throws the appropriate exception \n     * in cases where the required 'feed' parameter is missing.\n     */\n    public final void testRequiredParameterMissing()\n    {\n        assertNotNull(macro);\n        assertNotNull(parameters);\n        if (StringUtils.isNotEmpty(parameters.getFeed())) {\n            parameters = new RssMacroParameters();\n        }\n        try {\n            macro.execute(parameters, null, null);\n        } catch (MacroExecutionException ex) {\n            assertTrue(\"The required 'feed' parameter is missing\".equals(ex.getMessage()));\n            return;\n        }\n        fail(\"No 'feed' parameter specified, the macro should throw an exception\");\n    }","commit_id":"15e1a3f61b6a37da783f27b4369db2cb52aae541","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    @Test\n    public void shouldSubmitToExecutorOnFirstOffer() throws Exception\n    {\n        // GIVEN\n        ExecutorService executor = mock( ExecutorService.class );\n        JobMonitor jobMonitor = new JobMonitor();\n        WriteQueue queue = new WriteQueue( executor, jobMonitor );\n        assertFalse( jobMonitor.hasActiveJobs() );\n\n        // WHEN/THEN\n        WriteJob job1 = mock( WriteJob.class );\n        queue.offer( job1 );\n        verify( executor, times( 1 ) ).submit( any( Callable.class ) );\n        assertTrue( jobMonitor.hasActiveJobs() );\n\n        // WHEN/THEN\n        WriteJob job2 = mock( WriteJob.class );\n        queue.offer( job2 );\n        verifyNoMoreInteractions( executor );\n        assertTrue( jobMonitor.hasActiveJobs() );\n    }","id":66224,"modified_method":"@Test\n    public void shouldSubmitToExecutorOnlyIfTheQueueWasEmpty() throws Exception\n    {\n        // GIVEN\n        assertFalse( jobMonitor.hasActiveJobs() );\n\n        // make queue non-empty\n        queue.offer( JOB1 );\n        reset( executor ); // forget call to execute for job1\n\n        // WHEN\n        queue.offer( JOB2 );\n\n        // THEN\n        assertTrue( jobMonitor.hasActiveJobs() );\n        verify( executor, never() ).submit( queue );\n    }","commit_id":"ee0f0c418dfcc8e65e1ae6783385bd6f399b5346","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    @Test\n    public void shouldDrainAllOfferedAtOnce() throws Exception\n    {\n        // GIVEN\n        ExecutorService executor = mock( ExecutorService.class );\n        JobMonitor jobMonitor = new JobMonitor();\n        WriteQueue queue = new WriteQueue( executor, jobMonitor );\n        assertFalse( jobMonitor.hasActiveJobs() );\n\n        // WHEN/THEN\n        WriteJob job1 = mock( WriteJob.class );\n        WriteJob job2 = mock( WriteJob.class );\n        queue.offer( job1 );\n        queue.offer( job2 );\n        assertArrayEquals( new WriteJob[] {job1, job2}, queue.drain() );\n        verify( executor, times( 1 ) ).submit( any( Callable.class ) );\n        reset( executor );\n        assertTrue( jobMonitor.hasActiveJobs() );\n\n        // WHEN/THEN\n        WriteJob job3 = mock( WriteJob.class );\n        queue.offer( job3 );\n        assertArrayEquals( new WriteJob[] {job3}, queue.drain() );\n        verify( executor, times( 1 ) ).submit( any( Callable.class ) );\n        assertTrue( jobMonitor.hasActiveJobs() );\n    }","id":66225,"modified_method":"@Test\n    public void shouldDrainAllOfferedAtOnce() throws Exception\n    {\n        // GIVEN\n        assertFalse( jobMonitor.hasActiveJobs() );\n\n        // WHEN\n        queue.offer( JOB1 );\n        queue.offer( JOB2 );\n\n        // THEN\n        assertTrue( jobMonitor.hasActiveJobs() );\n        verify( executor, times( 1 ) ).submit( queue );\n        queue.call(); // call it manually after verification\n        verify( JOB1, times( 1 ) ).execute();\n        verify( JOB2, times( 1 ) ).execute();\n        verify( JOB3, never() ).execute();\n\n        assertFalse( jobMonitor.hasActiveJobs() );\n\n        reset( executor, JOB1, JOB2, JOB3 );\n\n        // WHEN\n        queue.offer( JOB3 );\n\n        // THEN\n        assertTrue( jobMonitor.hasActiveJobs() );\n        verify( executor, times( 1 ) ).submit( queue );\n        queue.call(); // call it manually after verification\n        verify( JOB1, never() ).execute();\n        verify( JOB2, never() ).execute();\n        verify( JOB3, times( 1 ) ).execute();\n\n        assertFalse( jobMonitor.hasActiveJobs() );\n    }","commit_id":"ee0f0c418dfcc8e65e1ae6783385bd6f399b5346","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void generateBridgeIfNeeded(@NotNull FunctionDescriptor functionDescriptor) {\n        if (owner.getContextKind() == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        Method method = state.getTypeMapper().mapSignature(functionDescriptor).getAsmMethod();\n\n        Queue<FunctionDescriptor> bfsQueue = new LinkedList<FunctionDescriptor>();\n        Set<FunctionDescriptor> visited = new HashSet<FunctionDescriptor>();\n\n        bfsQueue.offer(functionDescriptor.getOriginal());\n        visited.add(functionDescriptor.getOriginal());\n        for (FunctionDescriptor overriddenDescriptor : functionDescriptor.getOverriddenDescriptors()) {\n            FunctionDescriptor orig = overriddenDescriptor.getOriginal();\n            if (!visited.contains(orig)) {\n                bfsQueue.offer(overriddenDescriptor);\n                visited.add(overriddenDescriptor);\n            }\n        }\n\n        Set<Method> bridgesToGenerate = new HashSet<Method>();\n        while (!bfsQueue.isEmpty()) {\n            FunctionDescriptor descriptor = bfsQueue.poll();\n            if (descriptor.getKind() == CallableMemberDescriptor.Kind.DECLARATION) {\n                Method overridden = state.getTypeMapper().mapSignature(descriptor.getOriginal()).getAsmMethod();\n                if (differentMethods(method, overridden)) {\n                    bridgesToGenerate.add(overridden);\n                }\n                continue;\n            }\n\n            for (FunctionDescriptor overriddenDescriptor : descriptor.getOverriddenDescriptors()) {\n                FunctionDescriptor orig = overriddenDescriptor.getOriginal();\n                if (!visited.contains(orig)) {\n                    bfsQueue.offer(orig);\n                    visited.add(orig);\n                }\n            }\n        }\n\n        for (Method overridden : bridgesToGenerate) {\n            generateBridge(state, v, functionDescriptor, overridden);\n        }\n    }","id":66226,"modified_method":"private void generateBridgeIfNeeded(@NotNull FunctionDescriptor functionDescriptor) {\n        if (functionDescriptor instanceof ConstructorDescriptor) return;\n        if (owner.getContextKind() == OwnerKind.TRAIT_IMPL) return;\n\n        Method method = typeMapper.mapSignature(functionDescriptor).getAsmMethod();\n\n        Queue<FunctionDescriptor> bfsQueue = new LinkedList<FunctionDescriptor>();\n        Set<FunctionDescriptor> visited = new HashSet<FunctionDescriptor>();\n\n        for (FunctionDescriptor overriddenDescriptor : functionDescriptor.getOverriddenDescriptors()) {\n            FunctionDescriptor orig = overriddenDescriptor.getOriginal();\n            if (visited.add(orig)) {\n                bfsQueue.offer(orig);\n            }\n        }\n\n        Set<Method> bridgesToGenerate = new HashSet<Method>();\n        while (!bfsQueue.isEmpty()) {\n            FunctionDescriptor descriptor = bfsQueue.poll();\n            if (descriptor.getKind() == CallableMemberDescriptor.Kind.DECLARATION) {\n                Method overridden = typeMapper.mapSignature(descriptor).getAsmMethod();\n                if (differentMethods(method, overridden)) {\n                    bridgesToGenerate.add(overridden);\n                }\n                continue;\n            }\n\n            for (FunctionDescriptor overriddenDescriptor : descriptor.getOverriddenDescriptors()) {\n                FunctionDescriptor orig = overriddenDescriptor.getOriginal();\n                if (visited.add(orig)) {\n                    bfsQueue.offer(orig);\n                }\n            }\n        }\n\n        if (!bridgesToGenerate.isEmpty()) {\n            PsiElement origin = callableDescriptorToDeclaration(bindingContext, functionDescriptor);\n            for (Method bridge : bridgesToGenerate) {\n                generateBridge(origin, bridge, method);\n            }\n        }\n    }","commit_id":"2c2c918447fc4740af20b57cfd592303cbf98bc8","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void run() {\n\n        gelfChunkManager.start();\n        BlacklistCache.initialize(this);\n\n        // Set up deflector.\n        LOG.info(\"Setting up deflector.\");\n        deflector = new Deflector(this);\n        deflector.setUp();\n\n        scheduler = Executors.newScheduledThreadPool(SCHEDULED_THREADS_POOL_SIZE,\n                new ThreadFactoryBuilder().setNameFormat(\"scheduled-%d\").build()\n        );\n\n        // Load and register plugins.\n        registerPlugins(MessageFilter.class, \"filters\");\n        registerPlugins(MessageOutput.class, \"outputs\");\n        registerPlugins(AlarmCallback.class, \"alarm_callbacks\");\n        registerPlugins(Transport.class, \"transports\");\n        registerPlugins(Initializer.class, \"initializers\");\n        registerPlugins(MessageInput.class, \"inputs\");\n\n        // Ramp it all up. (both plugins and built-in types)\n        initializers().initialize();\n        outputs().initialize();\n\n        // Load persisted inputs.\n        inputs().launchPersisted();\n\n        /*\n        // Initialize all registered transports.\n        for (Transport transport : this.transports) {\n            try {\n                transport.initialize(PluginConfiguration.load(this, transport.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized transport: {}\", transport.getName());\n            } catch (TransportConfigurationException e) {\n                LOG.error(\"Could not initialize transport <\" + transport.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }\n\n        // Initialize all registered alarm callbacks.\n        for (AlarmCallback callback : this.alarmCallbacks) {\n            try {\n                callback.initialize(PluginConfiguration.load(this, callback.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized alarm callback: {}\", callback.getName());\n            } catch(AlarmCallbackConfigurationException e) {\n                LOG.error(\"Could not initialize alarm callback <\" + callback.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }\n\n        // Initialize all registered inputs.\n        for (MessageInput input : this.inputs) {\n            try {\n                // This is a plugin. Initialize with custom config from Mongo.\n                input.initialize(PluginConfiguration.load(this, input.getClass().getCanonicalName()), this);\n                LOG.debug(\"Initialized input: {}\", input.getName());\n            } catch (MessageInputConfigurationException e) {\n                LOG.error(\"Could not initialize input <{}>.\", input.getClass().getCanonicalName(), e);\n            }\n        }\n\n        // Initialize all registered outputs.\n        for (MessageOutput output : this.outputs) {\n            try {\n                output.initialize(PluginConfiguration.load(this, output.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized output: {}\", output.getName());\n            } catch(MessageOutputConfigurationException e) {\n                LOG.error(\"Could not initialize output <\" + output.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }*/\n\n        activityWriter.write(new Activity(\"Started up.\", Core.class));\n        LOG.info(\"Graylog2 up and running.\");\n\n        while (true) {\n            try { Thread.sleep(1000); } catch (InterruptedException e) { /* lol, i don't care */ }\n        }\n\n    }","id":66227,"modified_method":"@Override\n    public void run() {\n\n        gelfChunkManager.start();\n        BlacklistCache.initialize(this);\n\n        // Set up deflector.\n        LOG.info(\"Setting up deflector.\");\n        deflector = new Deflector(this);\n        deflector.setUp();\n\n        scheduler = Executors.newScheduledThreadPool(SCHEDULED_THREADS_POOL_SIZE,\n                new ThreadFactoryBuilder()\n                        .setNameFormat(\"scheduled-%d\")\n                        .setDaemon(true)\n                        .build()\n        );\n\n        // Load and register plugins.\n        registerPlugins(MessageFilter.class, \"filters\");\n        registerPlugins(MessageOutput.class, \"outputs\");\n        registerPlugins(AlarmCallback.class, \"alarm_callbacks\");\n        registerPlugins(Transport.class, \"transports\");\n        registerPlugins(Initializer.class, \"initializers\");\n        registerPlugins(MessageInput.class, \"inputs\");\n\n        // Ramp it all up. (both plugins and built-in types)\n        initializers().initialize();\n        outputs().initialize();\n\n        // Load persisted inputs.\n        inputs().launchPersisted();\n\n        /*\n        // Initialize all registered transports.\n        for (Transport transport : this.transports) {\n            try {\n                transport.initialize(PluginConfiguration.load(this, transport.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized transport: {}\", transport.getName());\n            } catch (TransportConfigurationException e) {\n                LOG.error(\"Could not initialize transport <\" + transport.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }\n\n        // Initialize all registered alarm callbacks.\n        for (AlarmCallback callback : this.alarmCallbacks) {\n            try {\n                callback.initialize(PluginConfiguration.load(this, callback.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized alarm callback: {}\", callback.getName());\n            } catch(AlarmCallbackConfigurationException e) {\n                LOG.error(\"Could not initialize alarm callback <\" + callback.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }\n\n        // Initialize all registered inputs.\n        for (MessageInput input : this.inputs) {\n            try {\n                // This is a plugin. Initialize with custom config from Mongo.\n                input.initialize(PluginConfiguration.load(this, input.getClass().getCanonicalName()), this);\n                LOG.debug(\"Initialized input: {}\", input.getName());\n            } catch (MessageInputConfigurationException e) {\n                LOG.error(\"Could not initialize input <{}>.\", input.getClass().getCanonicalName(), e);\n            }\n        }\n\n        // Initialize all registered outputs.\n        for (MessageOutput output : this.outputs) {\n            try {\n                output.initialize(PluginConfiguration.load(this, output.getClass().getCanonicalName()));\n                LOG.debug(\"Initialized output: {}\", output.getName());\n            } catch(MessageOutputConfigurationException e) {\n                LOG.error(\"Could not initialize output <\" + output.getName() + \">\"\n                        + \" because of missing or invalid configuration.\", e);\n            }\n        }*/\n\n        activityWriter.write(new Activity(\"Started up.\", Core.class));\n        LOG.info(\"Graylog2 up and running.\");\n\n        while (true) {\n            try { Thread.sleep(1000); } catch (InterruptedException e) { /* lol, i don't care */ }\n        }\n\n    }","commit_id":"0feab64b66017cf08d39ffda27485bd77029d769","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Listener() throws IOException {\n      address = new InetSocketAddress(bindAddress, port);\n      // Create a new server socket and set to non blocking mode\n      acceptChannel = ServerSocketChannel.open();\n      acceptChannel.configureBlocking(false);\n\n      // Bind the server socket to the local host and port\n      bind(acceptChannel.socket(), address, backlogLength);\n      port = acceptChannel.socket().getLocalPort(); //Could be an ephemeral port\n      // create a selector;\n      selector= Selector.open();\n\n      readers = new Reader[readThreads];\n      readPool = Executors.newFixedThreadPool(readThreads,\n        new ThreadFactoryBuilder().setNameFormat(\n          \"IPC Reader %d on port \" + port).build());\n      for (int i = 0; i < readThreads; ++i) {\n        Selector readSelector = Selector.open();\n        Reader reader = new Reader(readSelector);\n        readers[i] = reader;\n        readPool.execute(reader);\n      }\n\n      // Register accepts on the server socket with the selector.\n      acceptChannel.register(selector, SelectionKey.OP_ACCEPT);\n      this.setName(\"IPC Server listener on \" + port);\n      this.setDaemon(true);\n    }","id":66228,"modified_method":"public Listener() throws IOException {\n      address = new InetSocketAddress(bindAddress, port);\n      // Create a new server socket and set to non blocking mode\n      acceptChannel = ServerSocketChannel.open();\n      acceptChannel.configureBlocking(false);\n\n      // Bind the server socket to the local host and port\n      bind(acceptChannel.socket(), address, backlogLength);\n      port = acceptChannel.socket().getLocalPort(); //Could be an ephemeral port\n      // create a selector;\n      selector= Selector.open();\n\n      readers = new Reader[readThreads];\n      readPool = Executors.newFixedThreadPool(readThreads,\n        new ThreadFactoryBuilder().setNameFormat(\n          \"IPC Reader %d on port \" + port).setDaemon(true).build());\n      for (int i = 0; i < readThreads; ++i) {\n        Selector readSelector = Selector.open();\n        Reader reader = new Reader(readSelector);\n        readers[i] = reader;\n        readPool.execute(reader);\n      }\n\n      // Register accepts on the server socket with the selector.\n      acceptChannel.register(selector, SelectionKey.OP_ACCEPT);\n      this.setName(\"IPC Server listener on \" + port);\n      this.setDaemon(true);\n    }","commit_id":"143acb2d9dbb0f6b90e0aa1dca00802f8e217549","url":"https://github.com/apache/hbase"},{"original_method":"protected ContainerManager getCMProxy(ContainerId containerID,\n      final String containerManagerBindAddr, ContainerToken containerToken)\n      throws IOException {\n\n    UserGroupInformation user = UserGroupInformation.getCurrentUser();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n\n      Token<ContainerTokenIdentifier> token = new Token<ContainerTokenIdentifier>(\n          containerToken.getIdentifier().array(), containerToken\n              .getPassword().array(), new Text(containerToken.getKind()),\n          new Text(containerToken.getService()));\n      // the user in createRemoteUser in this context is not important\n      UserGroupInformation ugi = UserGroupInformation\n          .createRemoteUser(containerManagerBindAddr);\n      ugi.addToken(token);\n      ugiMap.putIfAbsent(containerManagerBindAddr, ugi);\n\n      user = ugiMap.get(containerManagerBindAddr);    \n    }\n    ContainerManager proxy =\n        user.doAs(new PrivilegedAction<ContainerManager>() {\n          @Override\n          public ContainerManager run() {\n            YarnRPC rpc = YarnRPC.create(getConfig());\n            return (ContainerManager) rpc.getProxy(ContainerManager.class,\n                NetUtils.createSocketAddr(containerManagerBindAddr),\n                getConfig());\n          }\n        });\n    return proxy;\n  }","id":66229,"modified_method":"protected ContainerManager getCMProxy(\n      final String containerManagerBindAddr, ContainerToken containerToken)\n      throws IOException {\n\n    UserGroupInformation user = UserGroupInformation.getCurrentUser();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n\n      Token<ContainerTokenIdentifier> token = new Token<ContainerTokenIdentifier>(\n          containerToken.getIdentifier().array(), containerToken\n              .getPassword().array(), new Text(containerToken.getKind()),\n          new Text(containerToken.getService()));\n      // the user in createRemoteUser in this context is not important\n      UserGroupInformation ugi = UserGroupInformation\n          .createRemoteUser(containerManagerBindAddr);\n      ugi.addToken(token);\n      ugiMap.putIfAbsent(containerManagerBindAddr, ugi);\n\n      user = ugiMap.get(containerManagerBindAddr);    \n    }\n    ContainerManager proxy =\n        user.doAs(new PrivilegedAction<ContainerManager>() {\n          @Override\n          public ContainerManager run() {\n            YarnRPC rpc = YarnRPC.create(getConfig());\n            return (ContainerManager) rpc.getProxy(ContainerManager.class,\n                NetUtils.createSocketAddr(containerManagerBindAddr),\n                getConfig());\n          }\n        });\n    return proxy;\n  }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr = event.getContainerMgrAddress();\n      ContainerId containerID = event.getContainerID();\n      ContainerToken containerToken = event.getContainerToken();\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEv = (ContainerRemoteLaunchEvent) event;\n\n        TaskAttemptId taskAttemptID = launchEv.getTaskAttemptID();\n        try {\n          \n          ContainerManager proxy = \n            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n          \n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext =\n              launchEv.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest = recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response = proxy.startContainer(startRequest);\n          ByteBuffer portInfo = response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port = -1;\n          if(portInfo != null) {\n            port = ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port < 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message = \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          LOG.error(message);\n          context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n          try {\n            ContainerManager proxy = \n              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n            // TODO:check whether container is launched\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest = recordFactory\n                .newRecordInstance(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n          } catch (Throwable t) {\n            //ignore the cleanup failure\n            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                t);\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }","id":66230,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr = event.getContainerMgrAddress();\n      ContainerId containerID = event.getContainerID();\n      ContainerToken containerToken = event.getContainerToken();\n      TaskAttemptId taskAttemptID = event.getTaskAttemptID();\n\n      Timer timer = new Timer(true);\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            = (ContainerRemoteLaunchEvent) event;\n\n        try {\n          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n              nmTimeOut);\n\n          ContainerManager proxy = getCMProxy(containerManagerBindAddr,\n              containerToken);\n\n          // Interruped during getProxy, but that didn't throw exception\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message = \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext =\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest = recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response = proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timer.cancel();\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn't throw exception\n            String message = \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo = response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port = -1;\n          if(portInfo != null) {\n            port = ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port < 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message = \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timer.cancel();\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                nmTimeOut);\n\n            ContainerManager proxy = getCMProxy(containerManagerBindAddr,\n                containerToken);\n\n            if (Thread.currentThread().isInterrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest = recordFactory\n                  .newRecordInstance(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n            // ignore the cleanup failure\n            String message = \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timer.cancel();\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public synchronized void init(Configuration conf) {\n    this.recordFactory = RecordFactoryProvider.getRecordFactory(conf);\n    this.limitOnPoolSize = conf.getInt(\n        MRJobConfig.MR_AM_CONTAINERLAUNCHER_THREAD_COUNT_LIMIT,\n        MRJobConfig.DEFAULT_MR_AM_CONTAINERLAUNCHER_THREAD_COUNT_LIMIT);\n    super.init(conf);\n  }","id":66231,"modified_method":"@Override\n  public synchronized void init(Configuration conf) {\n    this.recordFactory = RecordFactoryProvider.getRecordFactory(conf);\n    this.limitOnPoolSize = conf.getInt(\n        MRJobConfig.MR_AM_CONTAINERLAUNCHER_THREAD_COUNT_LIMIT,\n        MRJobConfig.DEFAULT_MR_AM_CONTAINERLAUNCHER_THREAD_COUNT_LIMIT);\n    this.nmTimeOut = conf.getInt(ContainerLauncher.MR_AM_NM_COMMAND_TIMEOUT,\n        ContainerLauncher.DEFAULT_NM__COMMAND_TIMEOUT);\n    super.init(conf);\n  }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"public void stop() {\n    eventHandlingThread.interrupt();\n    launcherPool.shutdown();\n    super.stop();\n  }","id":66232,"modified_method":"public void stop() {\n    eventHandlingThread.interrupt();\n    launcherPool.shutdownNow();\n    super.stop();\n  }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"public void start() {\n    // Start with a default core-pool size of 10 and change it dynamically.\n    ThreadFactory tf = new ThreadFactoryBuilder()\n      .setNameFormat(\"ContainerLauncher #%d\")\n      .build();\n    launcherPool = new ThreadPoolExecutor(INITIAL_POOL_SIZE,\n        Integer.MAX_VALUE, 1, TimeUnit.HOURS,\n        new LinkedBlockingQueue<Runnable>(),\n        tf);\n    eventHandlingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        ContainerLauncherEvent event = null;\n        while (!Thread.currentThread().isInterrupted()) {\n          try {\n            event = eventQueue.take();\n          } catch (InterruptedException e) {\n            LOG.error(\"Returning, interrupted : \" + e);\n            return;\n          }\n\n          int poolSize = launcherPool.getCorePoolSize();\n\n          // See if we need up the pool size only if haven't reached the\n          // maximum limit yet.\n          if (poolSize != limitOnPoolSize) {\n\n            // nodes where containers will run at *this* point of time. This is\n            // *not* the cluster size and doesn't need to be.\n            int numNodes = ugiMap.size();\n            int idealPoolSize = Math.min(limitOnPoolSize, numNodes);\n\n            if (poolSize <= idealPoolSize) {\n              // Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the\n              // later is just a buffer so we are not always increasing the\n              // pool-size\n              int newPoolSize = idealPoolSize + INITIAL_POOL_SIZE;\n              LOG.debug(\"Setting pool size to \" + newPoolSize);\n              launcherPool.setCorePoolSize(newPoolSize);\n            }\n          }\n\n          // the events from the queue are handled in parallel\n          // using a thread pool\n          launcherPool.execute(new EventProcessor(event));\n\n          // TODO: Group launching of multiple containers to a single\n          // NodeManager into a single connection\n        }\n      }\n    });\n    eventHandlingThread.setName(\"ContainerLauncher Event Handler\");\n    eventHandlingThread.start();\n    super.start();\n  }","id":66233,"modified_method":"public void start() {\n\n    ThreadFactory tf = new ThreadFactoryBuilder().setNameFormat(\n        \"ContainerLauncher #%d\").setDaemon(true).build();\n\n    // Start with a default core-pool size of 10 and change it dynamically.\n    launcherPool = new ThreadPoolExecutor(INITIAL_POOL_SIZE,\n        Integer.MAX_VALUE, 1, TimeUnit.HOURS,\n        new LinkedBlockingQueue<Runnable>(),\n        tf);\n    eventHandlingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        ContainerLauncherEvent event = null;\n        while (!Thread.currentThread().isInterrupted()) {\n          try {\n            event = eventQueue.take();\n          } catch (InterruptedException e) {\n            LOG.error(\"Returning, interrupted : \" + e);\n            return;\n          }\n\n          int poolSize = launcherPool.getCorePoolSize();\n\n          // See if we need up the pool size only if haven't reached the\n          // maximum limit yet.\n          if (poolSize != limitOnPoolSize) {\n\n            // nodes where containers will run at *this* point of time. This is\n            // *not* the cluster size and doesn't need to be.\n            int numNodes = ugiMap.size();\n            int idealPoolSize = Math.min(limitOnPoolSize, numNodes);\n\n            if (poolSize <= idealPoolSize) {\n              // Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the\n              // later is just a buffer so we are not always increasing the\n              // pool-size\n              int newPoolSize = idealPoolSize + INITIAL_POOL_SIZE;\n              LOG.debug(\"Setting pool size to \" + newPoolSize);\n              launcherPool.setCorePoolSize(newPoolSize);\n            }\n          }\n\n          // the events from the queue are handled in parallel\n          // using a thread pool\n          launcherPool.execute(new EventProcessor(event));\n\n          // TODO: Group launching of multiple containers to a single\n          // NodeManager into a single connection\n        }\n      }\n    });\n    eventHandlingThread.setName(\"ContainerLauncher Event Handler\");\n    eventHandlingThread.start();\n    super.start();\n  }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    protected ContainerLauncher createContainerLauncher(AppContext context) {\n      return new ContainerLauncherImpl(context) {\n        @Override\n        public void handle(ContainerLauncherEvent event) {\n\n          switch (event.getType()) {\n          case CONTAINER_REMOTE_LAUNCH:\n            super.handle(event); // Unused event and container.\n            break;\n          case CONTAINER_REMOTE_CLEANUP:\n            getContext().getEventHandler().handle(\n                new TaskAttemptEvent(event.getTaskAttemptID(),\n                    TaskAttemptEventType.TA_CONTAINER_CLEANED));\n            break;\n          }\n        }\n\n        @Override\n        protected ContainerManager getCMProxy(ContainerId containerID,\n            String containerManagerBindAddr, ContainerToken containerToken)\n            throws IOException {\n          try {\n            synchronized (this) {\n              wait(); // Just hang the thread simulating a very slow NM.\n            }\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n          return null;\n        }\n      };\n    }","id":66234,"modified_method":"@Override\n    protected ContainerLauncher createContainerLauncher(AppContext context) {\n      return new ContainerLauncherImpl(context) {\n        @Override\n        public void handle(ContainerLauncherEvent event) {\n\n          switch (event.getType()) {\n          case CONTAINER_REMOTE_LAUNCH:\n            super.handle(event); // Unused event and container.\n            break;\n          case CONTAINER_REMOTE_CLEANUP:\n            getContext().getEventHandler().handle(\n                new TaskAttemptEvent(event.getTaskAttemptID(),\n                    TaskAttemptEventType.TA_CONTAINER_CLEANED));\n            break;\n          }\n        }\n\n        @Override\n        protected ContainerManager getCMProxy(\n            String containerManagerBindAddr, ContainerToken containerToken)\n            throws IOException {\n          try {\n            synchronized (this) {\n              wait(); // Just hang the thread simulating a very slow NM.\n            }\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n          return null;\n        }\n      };\n    }","commit_id":"724f21734316343873386a14059a347067d65a10","url":"https://github.com/apache/hadoop"},{"original_method":"protected static ExecutorService instrumentedExecutor(final String executorName, final String threadNameFormat, final MetricRegistry metricRegistry) {\n        final ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(threadNameFormat).build();\n        return new InstrumentedExecutorService(\n                Executors.newCachedThreadPool(threadFactory),\n                metricRegistry,\n                name(RestApiService.class, executorName));\n    }","id":66235,"modified_method":"protected ExecutorService instrumentedExecutor(final String executorName,\n                                                   final String threadNameFormat,\n                                                   int poolSize) {\n        final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n                .setNameFormat(threadNameFormat)\n                .setDaemon(true)\n                .build();\n\n        return new InstrumentedExecutorService(\n                Executors.newFixedThreadPool(poolSize, threadFactory),\n                metricRegistry,\n                name(RestApiService.class, executorName));\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected ResourceConfig buildResourceConfig(final boolean enableGzip,\n                                               final boolean enableCors,\n                                               final Set<Resource> additionalResources,\n                                               final URI configuredListenUri,\n                                               final String[] controllerPackages) {\n        final URI listenUri;\n        if (isNullOrEmpty(configuredListenUri.getPath())) {\n            listenUri = UriBuilder.fromUri(configuredListenUri).path(\"/\").build();\n        } else {\n            listenUri = configuredListenUri;\n        }\n\n        final ObjectMapper objectMapper = objectMapperProvider.get();\n        ResourceConfig rc = new ResourceConfig()\n                .property(NettyContainer.PROPERTY_BASE_URI, listenUri)\n                .property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true)\n                .property(ServerProperties.WADL_FEATURE_DISABLE, true)\n                .registerClasses(\n                        JacksonJaxbJsonProvider.class,\n                        JsonProcessingExceptionMapper.class,\n                        JacksonPropertyExceptionMapper.class,\n                        AnyExceptionClassMapper.class,\n                        WebApplicationExceptionMapper.class,\n                        BadRequestExceptionMapper.class)\n                .register(new ContextResolver<ObjectMapper>() {\n                    @Override\n                    public ObjectMapper getContext(Class<?> type) {\n                        return objectMapper;\n                    }\n                })\n                .registerFinder(new PackageNamesScanner(controllerPackages, true))\n                .registerResources(additionalResources)\n                .register(NodeIdResponseFilter.class);\n\n        for (Class<? extends ExceptionMapper> exceptionMapper : exceptionMappers) {\n            rc.registerClasses(exceptionMapper);\n        }\n\n        for (Class<? extends DynamicFeature> dynamicFeatureClass : dynamicFeatures) {\n            rc.registerClasses(dynamicFeatureClass);\n        }\n\n        for (Class<? extends ContainerResponseFilter> responseFilter : containerResponseFilters) {\n            rc.registerClasses(responseFilter);\n        }\n\n        for (Class additionalComponent : additionalComponents)\n            rc.registerClasses(additionalComponent);\n\n        if (enableGzip) {\n            EncodingFilter.enableFor(rc, GZipEncoder.class);\n        }\n\n        if (enableCors) {\n            LOG.info(\"Enabling CORS for HTTP endpoint\");\n            rc.register(CORSFilter.class);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            rc.register(PrintModelProcessor.class);\n        }\n\n        return rc;\n    }","id":66236,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected ResourceConfig buildResourceConfig(final boolean enableGzip,\n                                                 final boolean enableCors,\n                                                 final Set<Resource> additionalResources,\n                                                 final String[] controllerPackages) {\n        final ResourceConfig rc = new ResourceConfig()\n                .property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true)\n                .property(ServerProperties.WADL_FEATURE_DISABLE, true)\n                .registerClasses(\n                        JacksonJaxbJsonProvider.class,\n                        JsonProcessingExceptionMapper.class,\n                        JacksonPropertyExceptionMapper.class,\n                        AnyExceptionClassMapper.class,\n                        WebApplicationExceptionMapper.class,\n                        BadRequestExceptionMapper.class)\n                .register(new ContextResolver<ObjectMapper>() {\n                    @Override\n                    public ObjectMapper getContext(Class<?> type) {\n                        return objectMapper;\n                    }\n                })\n                .registerFinder(new PackageNamesScanner(controllerPackages, true))\n                .registerResources(additionalResources)\n                .register(RestAccessLogFilter.class)\n                .register(NodeIdResponseFilter.class);\n\n        exceptionMappers.forEach(rc::registerClasses);\n        dynamicFeatures.forEach(rc::registerClasses);\n        containerResponseFilters.forEach(rc::registerClasses);\n        additionalComponents.forEach(rc::registerClasses);\n\n        if (enableGzip) {\n            EncodingFilter.enableFor(rc, GZipEncoder.class);\n        }\n\n        if (enableCors) {\n            LOG.info(\"Enabling CORS for HTTP endpoint\");\n            rc.register(CORSFilter.class);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            rc.register(PrintModelProcessor.class);\n        }\n\n        return rc;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public AbstractJerseyService(Set<Class<? extends DynamicFeature>> dynamicFeatures,\n                                 Set<Class<? extends ContainerResponseFilter>> containerResponseFilters,\n                                 Set<Class<? extends ExceptionMapper>> exceptionMappers,\n                                 Set<Class> additionalComponents,\n                                 Provider<ObjectMapper> objectMapperProvider) {\n        this.dynamicFeatures = dynamicFeatures;\n        this.containerResponseFilters = containerResponseFilters;\n        this.exceptionMappers = exceptionMappers;\n        this.additionalComponents = additionalComponents;\n        this.objectMapperProvider = objectMapperProvider;\n    }","id":66237,"modified_method":"public AbstractJerseyService(Set<Class<? extends DynamicFeature>> dynamicFeatures,\n                                 Set<Class<? extends ContainerResponseFilter>> containerResponseFilters,\n                                 Set<Class<? extends ExceptionMapper>> exceptionMappers,\n                                 Set<Class> additionalComponents,\n                                 ObjectMapper objectMapper,\n                                 MetricRegistry metricRegistry) {\n        this.dynamicFeatures = dynamicFeatures;\n        this.containerResponseFilters = containerResponseFilters;\n        this.exceptionMappers = exceptionMappers;\n        this.additionalComponents = additionalComponents;\n        this.objectMapper = objectMapper;\n        this.metricRegistry = metricRegistry;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public File getRestTlsKeyFile() {\n        return restTlsKeyFile;\n    }","id":66238,"modified_method":"public Path getRestTlsKeyFile() {\n        return restTlsKeyFile;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public File getWebTlsCertFile() {\n        return webTlsCertFile;\n    }","id":66239,"modified_method":"public Path getWebTlsCertFile() {\n        return webTlsCertFile;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public File getRestTlsCertFile() {\n        return restTlsCertFile;\n    }","id":66240,"modified_method":"public Path getRestTlsCertFile() {\n        return restTlsCertFile;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public File getWebTlsKeyFile() {\n        return webTlsKeyFile;\n    }","id":66241,"modified_method":"public Path getWebTlsKeyFile() {\n        return webTlsKeyFile;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public ContextAwarePermissionAnnotationHandler(ShiroSecurityContext context) {\n        this.context = context;\n    }","id":66242,"modified_method":"public ContextAwarePermissionAnnotationHandler(ShiroSecurityContext context) {\n        this.context = requireNonNull(context);\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {\n        if (!LOG.isDebugEnabled()) return;\n        try {\n            final InetSocketAddress remoteAddr = (InetSocketAddress) requestContext.getProperty(NettyContainer.REQUEST_PROPERTY_REMOTE_ADDR);\n\n            final String rawQuery = requestContext.getUriInfo().getRequestUri().getRawQuery();\n\n            final String remoteUser = ((ShiroSecurityContext)requestContext.getSecurityContext()).getUsername();\n            final Date requestDate = requestContext.getDate();\n            LOG.debug(\"{} {} [{}] \\\"{} {}{}\\\" {} {} {}\", new Object[]{\n                    remoteAddr.getAddress().getHostAddress(),\n                    (remoteUser == null ? \"-\" : remoteUser),\n                    (requestDate == null ? \"-\" : requestDate),\n                    requestContext.getMethod(),\n                    requestContext.getUriInfo().getPath(),\n                    (rawQuery == null ? \"\" : \"?\" + rawQuery),\n                    requestContext.getHeaderString(HttpHeaders.USER_AGENT),\n                    responseContext.getStatus(),\n                    responseContext.getLength()\n            });\n        } catch (Exception ignored) {\n            LOG.error(\":(\", ignored);\n        }\n    }","id":66243,"modified_method":"@Override\n    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {\n        if (LOG.isDebugEnabled()) {\n            try {\n                final String rawQuery = requestContext.getUriInfo().getRequestUri().getRawQuery();\n                final SecurityContext securityContext = requestContext.getSecurityContext();\n                final String remoteUser = securityContext instanceof ShiroSecurityContext ?\n                        ((ShiroSecurityContext) securityContext).getUsername() : null;\n                final Date requestDate = requestContext.getDate();\n\n                LOG.debug(\"{} {} [{}] \\\"{} {}{}\\\" {} {} {}\",\n                        response.getRequest().getRemoteAddr(),\n                        (remoteUser == null ? \"-\" : remoteUser),\n                        (requestDate == null ? \"-\" : requestDate),\n                        requestContext.getMethod(),\n                        requestContext.getUriInfo().getPath(),\n                        (rawQuery == null ? \"\" : \"?\" + rawQuery),\n                        requestContext.getHeaderString(HttpHeaders.USER_AGENT),\n                        responseContext.getStatus(),\n                        responseContext.getLength());\n            } catch (Exception e) {\n                LOG.error(\"Error while processing REST API access log\", e);\n            }\n        }\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindContainerResponseFilters() {\n        Multibinder<Class<? extends ContainerResponseFilter>> setBinder = jerseyContainerResponseFilterBinder();\n        setBinder.addBinding().toInstance(RestAccessLogFilter.class);\n    }","id":66244,"modified_method":"private void bindContainerResponseFilters() {\n        Multibinder<Class<? extends ContainerResponseFilter>> setBinder = jerseyContainerResponseFilterBinder();\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void startUp() throws Exception {\n        final NettyContainer jerseyHandler = ContainerFactory.createContainer(NettyContainer.class,\n                buildResourceConfig(\n                        configuration.isRestEnableGzip(),\n                        configuration.isRestEnableCors(),\n                        prefixPluginResources(\"/plugins\", pluginRestResources),\n                        configuration.getRestListenUri(),\n                        restControllerPackages)\n        );\n\n        if (securityContextFactory != null) {\n            LOG.info(\"Adding security context factory: <{}>\", securityContextFactory);\n            jerseyHandler.setSecurityContextFactory(securityContextFactory);\n        } else {\n            LOG.info(\"Not adding security context factory.\");\n        }\n\n        final int maxInitialLineLength = configuration.getRestMaxInitialLineLength();\n        final int maxHeaderSize = configuration.getRestMaxHeaderSize();\n        final int maxChunkSize = configuration.getRestMaxChunkSize();\n\n        final File tlsCertFile;\n        final File tlsKeyFile;\n        if (configuration.isRestEnableTls() && (configuration.getRestTlsCertFile() == null || configuration.getRestTlsKeyFile() == null)) {\n            final SelfSignedCertificate ssc = new SelfSignedCertificate(configuration.getRestListenUri().getHost());\n            tlsCertFile = ssc.certificate();\n            tlsKeyFile = ssc.privateKey();\n\n            LOG.warn(\"rest_tls_cert_file or rest_tls_key_file is empty. Using self-signed certificates instead.\");\n            LOG.debug(\"rest_tls_cert_file = {}\", tlsCertFile);\n            LOG.debug(\"rest_tls_key_file = {}\", tlsKeyFile);\n        } else {\n            tlsCertFile = configuration.getRestTlsCertFile();\n            tlsKeyFile = configuration.getRestTlsKeyFile();\n        }\n\n        final Executor executor = buildPoolExecutor(\"restapi-execution-handler\", configuration.getRestThreadPoolSize(), metricRegistry);\n\n        bootstrap.setPipelineFactory(buildPipelineFactory(\n                configuration.isRestEnableTls(),\n                maxInitialLineLength,\n                maxHeaderSize,\n                maxChunkSize,\n                executor,\n                jerseyHandler,\n                tlsCertFile,\n                tlsKeyFile,\n                configuration.getRestTlsKeyPassword()\n        ));\n        bootstrap.setOption(\"child.tcpNoDelay\", true);\n        bootstrap.setOption(\"child.keepAlive\", true);\n\n        bootstrap.bind(new InetSocketAddress(\n                configuration.getRestListenUri().getHost(),\n                configuration.getRestListenUri().getPort()\n        ));\n\n        LOG.info(\"Started REST API at <{}>\", configuration.getRestListenUri());\n    }","id":66245,"modified_method":"@Override\n    protected void startUp() throws Exception {\n        httpServer = setUp(\"rest\",\n                configuration.getRestListenUri(),\n                configuration.isRestEnableTls(),\n                configuration.getRestTlsCertFile(),\n                configuration.getRestTlsKeyFile(),\n                configuration.getRestTlsKeyPassword(),\n                configuration.getRestThreadPoolSize(),\n                configuration.getRestMaxInitialLineLength(),\n                configuration.getRestMaxHeaderSize(),\n                configuration.isRestEnableGzip(),\n                configuration.isRestEnableCors(),\n                prefixPluginResources(\"/plugins\", pluginRestResources),\n                restControllerPackages);\n\n        httpServer.start();\n\n        LOG.info(\"Started REST API at <{}>\", configuration.getRestListenUri());\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void shutDown() throws Exception {\n        LOG.info(\"Shutting down REST API at <{}>\", configuration.getRestListenUri());\n        bootstrap.releaseExternalResources();\n        bootstrap.shutdown();\n    }","id":66246,"modified_method":"@Override\n    protected void shutDown() throws Exception {\n        if (httpServer != null && httpServer.isStarted()) {\n            LOG.info(\"Shutting down REST API at <{}>\", configuration.getRestListenUri());\n            httpServer.shutdownNow();\n        }\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected Subject getSubject() {\n        if (securityContext == null) {\n            LOG.error(\"Cannot retrieve current subject, SecurityContext isn't set.\");\n            return null;\n        }\n\n        final Principal p = securityContext.getUserPrincipal();\n        if (!(p instanceof ShiroSecurityContext.ShiroPrincipal)) {\n            LOG.error(\"Unknown SecurityContext class {}, cannot continue.\", securityContext);\n            throw new IllegalStateException();\n        }\n\n        final ShiroSecurityContext.ShiroPrincipal principal = (ShiroSecurityContext.ShiroPrincipal) p;\n        return principal.getSubject();\n    }","id":66247,"modified_method":"protected Subject getSubject() {\n        if (securityContext == null) {\n            LOG.error(\"Cannot retrieve current subject, SecurityContext isn't set.\");\n            return null;\n        }\n\n        final Principal p = securityContext.getUserPrincipal();\n        if (!(p instanceof ShiroPrincipal)) {\n            LOG.error(\"Unknown SecurityContext class {}, cannot continue.\", securityContext);\n            throw new IllegalStateException();\n        }\n\n        final ShiroPrincipal principal = (ShiroPrincipal) p;\n        return principal.getSubject();\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindInterfaces() {\n        bind(SecurityContextFactory.class).to(ShiroSecurityContextFactory.class);\n        bind(AlertSender.class).to(FormattedEmailAlertSender.class);\n        bind(StreamRouter.class);\n        install(new FactoryModuleBuilder().implement(StreamRouterEngine.class, StreamRouterEngine.class).build(\n                StreamRouterEngine.Factory.class));\n        bind(FilterService.class).to(FilterServiceImpl.class).in(Scopes.SINGLETON);\n        bind(ActivityWriter.class).to(SystemMessageActivityWriter.class);\n        bind(PersistedInputs.class).to(PersistedInputsImpl.class);\n\n        bind(ProcessBufferProcessor.class).to(ServerProcessBufferProcessor.class);\n        bind(RoleService.class).to(RoleServiceImpl.class).in(Scopes.SINGLETON);\n    }","id":66248,"modified_method":"private void bindInterfaces() {\n        bind(AlertSender.class).to(FormattedEmailAlertSender.class);\n        bind(StreamRouter.class);\n        install(new FactoryModuleBuilder().implement(StreamRouterEngine.class, StreamRouterEngine.class).build(\n                StreamRouterEngine.Factory.class));\n        bind(FilterService.class).to(FilterServiceImpl.class).in(Scopes.SINGLETON);\n        bind(ActivityWriter.class).to(SystemMessageActivityWriter.class);\n        bind(PersistedInputs.class).to(PersistedInputsImpl.class);\n\n        bind(ProcessBufferProcessor.class).to(ServerProcessBufferProcessor.class);\n        bind(RoleService.class).to(RoleServiceImpl.class).in(Scopes.SINGLETON);\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n        final SecurityContext securityContext = requestContext.getSecurityContext();\n        if (!(securityContext instanceof ShiroSecurityContext)) {\n            return;\n        }\n        final ShiroSecurityContext context = (ShiroSecurityContext) securityContext;\n        LOG.trace(\"Authenticating... {}\", context.getSubject());\n        if (!context.getSubject().isAuthenticated()) {\n            try {\n                LOG.trace(\"Logging in {}\", context.getSubject());\n                context.loginSubject();\n            } catch (LockedAccountException e) {\n                LOG.debug(\"Unable to authenticate user, account is locked.\", e);\n                throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n            } catch (AuthenticationException e) {\n                LOG.debug(\"Unable to authenticate user.\", e);\n                throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n            }\n        }\n    }","id":66249,"modified_method":"@Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n        final SecurityContext securityContext = requestContext.getSecurityContext();\n        if (securityContext instanceof ShiroSecurityContext) {\n            final ShiroSecurityContext context = (ShiroSecurityContext) securityContext;\n            final Subject subject = context.getSubject();\n\n            LOG.trace(\"Authenticating... {}\", subject);\n            if (!subject.isAuthenticated()) {\n                try {\n                    LOG.trace(\"Logging in {}\", subject);\n                    context.loginSubject();\n                } catch (LockedAccountException e) {\n                    LOG.debug(\"Unable to authenticate user, account is locked.\", e);\n                    throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n                } catch (AuthenticationException e) {\n                    LOG.debug(\"Unable to authenticate user.\", e);\n                    throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n                }\n            }\n        } else {\n            throw new NotAuthorizedException(\"Basic realm=\\\"Graylog Server\\\"\");\n        }\n\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n        final SecurityContext securityContext = requestContext.getSecurityContext();\n        if (!(securityContext instanceof ShiroSecurityContext)) {\n            return;\n        }\n        final ShiroSecurityContext context = (ShiroSecurityContext) securityContext;\n        final Subject subject = context.getSubject();\n        try {\n            LOG.debug(\"Checking authorization for user {}, needs permissions {}\", subject, annotation.value());\n            new ContextAwarePermissionAnnotationHandler(context).assertAuthorized(annotation);\n        } catch (AuthorizationException e) {\n            LOG.info(\"User not authorized.\", e);\n            throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n        }\n    }","id":66250,"modified_method":"@Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n        final SecurityContext securityContext = requestContext.getSecurityContext();\n        if (securityContext instanceof ShiroSecurityContext) {\n            final ShiroSecurityContext context = (ShiroSecurityContext) securityContext;\n            final Subject subject = context.getSubject();\n            final ContextAwarePermissionAnnotationHandler annotationHandler = new ContextAwarePermissionAnnotationHandler(context);\n            try {\n                LOG.debug(\"Checking authorization for user {}, needs permissions {}\", subject, annotation.value());\n                annotationHandler.assertAuthorized(annotation);\n            } catch (AuthorizationException e) {\n                LOG.info(\"User \" + subject + \"not authorized.\", e);\n                throw new NotAuthorizedException(e, \"Basic realm=\\\"Graylog Server\\\"\");\n            }\n        } else {\n            throw new NotAuthorizedException(\"Basic realm=\\\"Graylog Server\\\"\");\n        }\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void configure(ResourceInfo resourceInfo, FeatureContext context) {\n        final Class<?> resourceClass = resourceInfo.getResourceClass();\n        final Method resourceMethod = resourceInfo.getResourceMethod();\n\n        if (resourceMethod.isAnnotationPresent(RequiresAuthentication.class) ||\n                resourceClass.isAnnotationPresent(RequiresAuthentication.class)) {\n            if (resourceMethod.isAnnotationPresent(RequiresGuest.class)) {\n                LOG.debug(\"Resource method {}#{} is marked as unauthenticated, skipping setting filter.\");\n            } else {\n                LOG.debug(\"Resource method {}#{} requires an authenticated user.\", resourceClass.getCanonicalName(), resourceMethod.getName());\n                context.register(new ShiroAuthenticationFilter());\n            }\n        }\n        if (resourceMethod.isAnnotationPresent(RequiresPermissions.class) ||\n                resourceClass.isAnnotationPresent(RequiresPermissions.class)) {\n            RequiresPermissions a = resourceClass.getAnnotation(RequiresPermissions.class);\n            if (a == null) {\n                a = resourceMethod.getAnnotation(RequiresPermissions.class);\n            }\n            LOG.debug(\"Resource method {}#{} requires an authorization checks.\", resourceClass.getCanonicalName(), resourceMethod.getName());\n            context.register(new ShiroAuthorizationFilter(a));\n        }\n        // TODO this is the wrong approach, we should have an Environment and proper request wrapping\n        context.register(new ContainerResponseFilter() {\n            @Override\n            public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) {\n                ThreadContext.unbindSubject();\n            }\n        });\n    }","id":66251,"modified_method":"@Override\n    public void configure(ResourceInfo resourceInfo, FeatureContext context) {\n        final Class<?> resourceClass = resourceInfo.getResourceClass();\n        final Method resourceMethod = resourceInfo.getResourceMethod();\n\n        context.register(ShiroSecurityContextFilter.class, 0);\n\n        if (resourceMethod.isAnnotationPresent(RequiresAuthentication.class) || resourceClass.isAnnotationPresent(RequiresAuthentication.class)) {\n            if (resourceMethod.isAnnotationPresent(RequiresGuest.class)) {\n                LOG.debug(\"Resource method {}#{} is marked as unauthenticated, skipping setting filter.\");\n            } else {\n                LOG.debug(\"Resource method {}#{} requires an authenticated user.\", resourceClass.getCanonicalName(), resourceMethod.getName());\n                context.register(new ShiroAuthenticationFilter());\n            }\n        }\n\n        if (resourceMethod.isAnnotationPresent(RequiresPermissions.class) || resourceClass.isAnnotationPresent(RequiresPermissions.class)) {\n            RequiresPermissions requiresPermissions = resourceClass.getAnnotation(RequiresPermissions.class);\n            if (requiresPermissions == null) {\n                requiresPermissions = resourceMethod.getAnnotation(RequiresPermissions.class);\n            }\n\n            LOG.debug(\"Resource method {}#{} requires an authorization checks.\", resourceClass.getCanonicalName(), resourceMethod.getName());\n            context.register(new ShiroAuthorizationFilter(requiresPermissions));\n        }\n\n        // TODO this is the wrong approach, we should have an Environment and proper request wrapping\n        context.register((ContainerResponseFilter) (requestContext, responseContext) -> ThreadContext.unbindSubject());\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Principal getUserPrincipal() {\n        return new ShiroPrincipal();\n    }","id":66252,"modified_method":"@Override\n    public Principal getUserPrincipal() {\n        return new ShiroPrincipal(subject);\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String getUsername() {\n        if (token == null) {\n            return null;\n        }\n        if (token.getPrincipal() == null) {\n            return null;\n        }\n        return token.getPrincipal().toString();\n    }","id":66253,"modified_method":"public String getUsername() {\n        if (token == null || token.getPrincipal() == null) {\n            return null;\n        }\n        return token.getPrincipal().toString();\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public ShiroSecurityContext(Subject subject, AuthenticationToken token, boolean isSecure, String authcScheme) {\n        this.subject = subject;\n        this.token = token;\n        secure = isSecure;\n        this.authcScheme = authcScheme;\n    }","id":66254,"modified_method":"public ShiroSecurityContext(Subject subject, AuthenticationToken token, boolean isSecure, String authcScheme,\n                                MultivaluedMap<String, String> headers) {\n        this.subject = subject;\n        this.token = token;\n        this.secure = isSecure;\n        this.authcScheme = authcScheme;\n        this.headers = new MultivaluedHashMap<String, String>(headers);\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public boolean isUserInRole(String role) {\n        LOG.info(\"Checking role {} for user {}.\", role, subject.getPrincipal());\n        return subject.hasRole(role);\n    }","id":66255,"modified_method":"@Override\n    public boolean isUserInRole(String role) {\n        LOG.debug(\"Checking role {} for user {}.\", role, subject.getPrincipal());\n        return subject.hasRole(role);\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String getPassword() {\n        if (token == null) {\n            return null;\n        }\n        if (token.getCredentials() == null) {\n            return null;\n        }\n        return token.getCredentials().toString();\n    }","id":66256,"modified_method":"public String getPassword() {\n        if (token == null || token.getCredentials() == null) {\n            return null;\n        }\n        return token.getCredentials().toString();\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Inject\n    public WebInterfaceService(Provider<ObjectMapper> objectMapperProvider,\n                               BaseConfiguration configuration,\n                               MetricRegistry metricRegistry) {\n        super(Collections.emptySet(), Collections.emptySet(), Collections.emptySet(), Collections.emptySet(), objectMapperProvider);\n        this.configuration = configuration;\n        this.metricRegistry = metricRegistry;\n        this.bootstrap = buildServerBootStrap(\n                instrumentedExecutor(\"boss-executor-service\", \"web-boss-%d\", metricRegistry),\n                instrumentedExecutor(\"worker-executor-service\", \"web-worker-%d\", metricRegistry),\n                configuration.getWebWorkerThreadsMaxPoolSize()\n        );\n    }","id":66257,"modified_method":"@Inject\n    public WebInterfaceService(ObjectMapper objectMapper,\n                               BaseConfiguration configuration,\n                               MetricRegistry metricRegistry) {\n        super(Collections.emptySet(), Collections.emptySet(), Collections.emptySet(), Collections.emptySet(), objectMapper, metricRegistry);\n        this.configuration = configuration;\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void shutDown() throws Exception {\n        LOG.info(\"Shutting down Web Interface at <{}>\", configuration.getWebListenUri());\n        bootstrap.releaseExternalResources();\n        bootstrap.shutdown();\n    }","id":66258,"modified_method":"@Override\n    protected void shutDown() throws Exception {\n        if (httpServer != null && httpServer.isStarted()) {\n            LOG.info(\"Shutting down Web Interface at <{}>\", configuration.getWebListenUri());\n            httpServer.shutdownNow();\n        }\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void startUp() throws Exception {\n        final String[] resources = new String[] {\"org.graylog2.web.resources\"};\n        final ResourceConfig rc = buildResourceConfig(\n                configuration.isWebEnableGzip(),\n                configuration.isWebEnableCors(),\n                Collections.emptySet(),\n                configuration.getWebListenUri(),\n                resources\n        );\n\n        final NettyContainer jerseyHandler = ContainerFactory.createContainer(NettyContainer.class, rc);\n\n        final int maxInitialLineLength = configuration.getWebMaxInitialLineLength();\n        final int maxHeaderSize = configuration.getWebMaxHeaderSize();\n        final int maxChunkSize = configuration.getWebMaxChunkSize();\n\n        final File tlsCertFile;\n        final File tlsKeyFile;\n        if (configuration.isWebEnableTls() && (configuration.getWebTlsCertFile() == null || configuration.getWebTlsKeyFile() == null)) {\n            final SelfSignedCertificate ssc = new SelfSignedCertificate(configuration.getWebListenUri().getHost());\n            tlsCertFile = ssc.certificate();\n            tlsKeyFile = ssc.privateKey();\n\n            LOG.warn(\"web_tls_cert_file or web_tls_key_file is empty. Using self-signed certificates instead.\");\n            LOG.debug(\"web_tls_cert_file = {}\", tlsCertFile);\n            LOG.debug(\"web_tls_key_file = {}\", tlsKeyFile);\n        } else {\n            tlsCertFile = configuration.getWebTlsCertFile();\n            tlsKeyFile = configuration.getWebTlsKeyFile();\n        }\n\n        final Executor executor = buildPoolExecutor(\"web-execution-handler\", configuration.getWebThreadPoolSize(), metricRegistry);\n\n        bootstrap.setPipelineFactory(buildPipelineFactory(\n                configuration.isWebEnableTls(),\n                maxInitialLineLength,\n                maxHeaderSize,\n                maxChunkSize,\n                executor,\n                jerseyHandler,\n                tlsCertFile,\n                tlsKeyFile,\n                configuration.getWebTlsKeyPassword()\n        ));\n        bootstrap.setOption(\"child.tcpNoDelay\", true);\n        bootstrap.setOption(\"child.keepAlive\", true);\n\n        bootstrap.bind(new InetSocketAddress(\n                configuration.getWebListenUri().getHost(),\n                configuration.getWebListenUri().getPort()\n        ));\n\n        LOG.info(\"Started Web Interface at <{}>\", configuration.getWebListenUri());\n    }","id":66259,"modified_method":"@Override\n    protected void startUp() throws Exception {\n        final String[] resources = new String[]{\"org.graylog2.web.resources\"};\n\n        httpServer = setUp(\"web\",\n                configuration.getWebListenUri(),\n                configuration.isWebEnableTls(),\n                configuration.getWebTlsCertFile(),\n                configuration.getWebTlsKeyFile(),\n                configuration.getWebTlsKeyPassword(),\n                configuration.getWebThreadPoolSize(),\n                configuration.getWebMaxInitialLineLength(),\n                configuration.getWebMaxHeaderSize(),\n                configuration.isWebEnableGzip(),\n                configuration.isWebEnableCors(),\n                Collections.emptySet(),\n                resources);\n\n        httpServer.start();\n\n        LOG.info(\"Started Web Interface at <{}>\", configuration.getWebListenUri());\n    }","commit_id":"fb088fce8c90ab125153a809eef1575749f476c3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n\t * Build the {@link MergedContextConfiguration merged context configuration}\n\t * for the supplied {@link Class testClass}, context configuration attributes,\n\t * and parent context configuration.\n\t * @param testClass the test class for which the {@code MergedContextConfiguration}\n\t * should be built (must not be {@code null})\n\t * @param configAttributesList the list of context configuration attributes for the\n\t * specified test class, ordered <em>bottom-up<\/em> (i.e., as if we were\n\t * traversing up the class hierarchy); never {@code null} or empty\n\t * @param parentConfig the merged context configuration for the parent application\n\t * context in a context hierarchy, or {@code null} if there is no parent\n\t * @param cacheAwareContextLoaderDelegate the cache-aware context loader delegate to\n\t * be passed to the {@code MergedContextConfiguration} constructor\n\t * @return the merged context configuration\n\t * @see #resolveContextLoader\n\t * @see ContextLoaderUtils#resolveContextConfigurationAttributes\n\t * @see SmartContextLoader#processContextConfiguration\n\t * @see ContextLoader#processLocations\n\t * @see ActiveProfilesUtils#resolveActiveProfiles\n\t * @see ApplicationContextInitializerUtils#resolveInitializerClasses\n\t * @see MergedContextConfiguration\n\t */\n\tprivate MergedContextConfiguration buildMergedContextConfiguration(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList, MergedContextConfiguration parentConfig,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate) {\n\n\t\tContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList);\n\t\tList<String> locationsList = new ArrayList<String>();\n\t\tList<Class<?>> classesList = new ArrayList<Class<?>>();\n\n\t\tfor (ContextConfigurationAttributes configAttributes : configAttributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(String.format(\"Processing locations and classes for context configuration attributes %s\",\n\t\t\t\t\tconfigAttributes));\n\t\t\t}\n\t\t\tif (contextLoader instanceof SmartContextLoader) {\n\t\t\t\tSmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader;\n\t\t\t\tsmartContextLoader.processContextConfiguration(configAttributes);\n\t\t\t\tlocationsList.addAll(0, Arrays.asList(configAttributes.getLocations()));\n\t\t\t\tclassesList.addAll(0, Arrays.asList(configAttributes.getClasses()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] processedLocations = contextLoader.processLocations(configAttributes.getDeclaringClass(),\n\t\t\t\t\tconfigAttributes.getLocations());\n\t\t\t\tlocationsList.addAll(0, Arrays.asList(processedLocations));\n\t\t\t\t// Legacy ContextLoaders don't know how to process classes\n\t\t\t}\n\t\t\tif (!configAttributes.isInheritLocations()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tString[] locations = StringUtils.toStringArray(locationsList);\n\t\tClass<?>[] classes = ClassUtils.toClassArray(classesList);\n\t\tSet<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> initializerClasses = //\n\t\tApplicationContextInitializerUtils.resolveInitializerClasses(configAttributesList);\n\t\tString[] activeProfiles = ActiveProfilesUtils.resolveActiveProfiles(testClass);\n\t\tMergedTestPropertySources mergedTestPropertySources = TestPropertySourceUtils.buildMergedTestPropertySources(testClass);\n\n\t\treturn buildMergedContextConfiguration(testClass, locations, classes, initializerClasses, activeProfiles,\n\t\t\tmergedTestPropertySources.getLocations(), mergedTestPropertySources.getProperties(), contextLoader,\n\t\t\tcacheAwareContextLoaderDelegate, parentConfig);\n\t}","id":66260,"modified_method":"/**\n\t * Build the {@link MergedContextConfiguration merged context configuration}\n\t * for the supplied {@link Class testClass}, context configuration attributes,\n\t * and parent context configuration.\n\t * @param testClass the test class for which the {@code MergedContextConfiguration}\n\t * should be built (must not be {@code null})\n\t * @param configAttributesList the list of context configuration attributes for the\n\t * specified test class, ordered <em>bottom-up<\/em> (i.e., as if we were\n\t * traversing up the class hierarchy); never {@code null} or empty\n\t * @param parentConfig the merged context configuration for the parent application\n\t * context in a context hierarchy, or {@code null} if there is no parent\n\t * @param cacheAwareContextLoaderDelegate the cache-aware context loader delegate to\n\t * be passed to the {@code MergedContextConfiguration} constructor\n\t * @return the merged context configuration\n\t * @see #resolveContextLoader\n\t * @see ContextLoaderUtils#resolveContextConfigurationAttributes\n\t * @see SmartContextLoader#processContextConfiguration\n\t * @see ContextLoader#processLocations\n\t * @see ActiveProfilesUtils#resolveActiveProfiles\n\t * @see ApplicationContextInitializerUtils#resolveInitializerClasses\n\t * @see MergedContextConfiguration\n\t */\n\tprivate MergedContextConfiguration buildMergedContextConfiguration(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList, MergedContextConfiguration parentConfig,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate) {\n\n\t\tContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList);\n\t\tList<String> locationsList = new ArrayList<String>();\n\t\tList<Class<?>> classesList = new ArrayList<Class<?>>();\n\n\t\tfor (ContextConfigurationAttributes configAttributes : configAttributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(String.format(\"Processing locations and classes for context configuration attributes %s\",\n\t\t\t\t\tconfigAttributes));\n\t\t\t}\n\t\t\tif (contextLoader instanceof SmartContextLoader) {\n\t\t\t\tSmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader;\n\t\t\t\tsmartContextLoader.processContextConfiguration(configAttributes);\n\t\t\t\tlocationsList.addAll(0, Arrays.asList(configAttributes.getLocations()));\n\t\t\t\tclassesList.addAll(0, Arrays.asList(configAttributes.getClasses()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] processedLocations = contextLoader.processLocations(configAttributes.getDeclaringClass(),\n\t\t\t\t\tconfigAttributes.getLocations());\n\t\t\t\tlocationsList.addAll(0, Arrays.asList(processedLocations));\n\t\t\t\t// Legacy ContextLoaders don't know how to process classes\n\t\t\t}\n\t\t\tif (!configAttributes.isInheritLocations()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tString[] locations = StringUtils.toStringArray(locationsList);\n\t\tClass<?>[] classes = ClassUtils.toClassArray(classesList);\n\t\tSet<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> initializerClasses = //\n\t\tApplicationContextInitializerUtils.resolveInitializerClasses(configAttributesList);\n\t\tString[] activeProfiles = ActiveProfilesUtils.resolveActiveProfiles(testClass);\n\t\tMergedTestPropertySources mergedTestPropertySources = TestPropertySourceUtils.buildMergedTestPropertySources(testClass);\n\n\t\tMergedContextConfiguration mergedConfig = new MergedContextConfiguration(testClass, locations, classes,\n\t\t\tinitializerClasses, activeProfiles, mergedTestPropertySources.getLocations(),\n\t\t\tmergedTestPropertySources.getProperties(), contextLoader, cacheAwareContextLoaderDelegate, parentConfig);\n\n\t\treturn processMergedContextConfiguration(mergedConfig);\n\t}","commit_id":"e6d16148e576fafe094c2bc1ef975c25576eeb7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Get the names of the default {@link TestExecutionListener} classes for\n\t * this bootstrapper.\n\t * <p>This method is invoked by {@link #getDefaultTestExecutionListenerClasses()}.\n\t * @return an <em>unmodifiable<\/em> list of names of default {@code\n\t * TestExecutionListener} classes\n\t */\n\tprotected abstract List<String> getDefaultTestExecutionListenerClassNames();","id":66261,"modified_method":"/**\n\t * Get the names of the default {@link TestExecutionListener} classes for\n\t * this bootstrapper.\n\t * <p>The default implementation looks up all\n\t * {@code org.springframework.test.context.TestExecutionListener} entries\n\t * configured in all {@code META-INF/spring.factories} files on the classpath.\n\t * <p>This method is invoked by {@link #getDefaultTestExecutionListenerClasses()}.\n\t * @return an <em>unmodifiable<\/em> list of names of default {@code TestExecutionListener}\n\t * classes\n\t * @see SpringFactoriesLoader#loadFactoryNames\n\t */\n\tprotected List<String> getDefaultTestExecutionListenerClassNames() {\n\t\tfinal List<String> classNames = SpringFactoriesLoader.loadFactoryNames(TestExecutionListener.class,\n\t\t\tgetClass().getClassLoader());\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(String.format(\"Loaded default TestExecutionListener class names from location [%s]: %s\",\n\t\t\t\tSpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION, classNames));\n\t\t}\n\t\treturn Collections.unmodifiableList(classNames);\n\t}","commit_id":"e6d16148e576fafe094c2bc1ef975c25576eeb7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\tClass<?> clazz = getBootstrapContext().getTestClass();\n\t\tClass<TestExecutionListeners> annotationType = TestExecutionListeners.class;\n\t\tList<Class<? extends TestExecutionListener>> classesList = new ArrayList<Class<? extends TestExecutionListener>>();\n\n\t\tAnnotationDescriptor<TestExecutionListeners> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(clazz,\n\t\t\tannotationType);\n\n\t\t// Use defaults?\n\t\tif (descriptor == null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"@TestExecutionListeners is not present for class [\" + clazz.getName()\n\t\t\t\t\t\t+ \"]: using defaults.\");\n\t\t\t}\n\t\t\tclassesList.addAll(getDefaultTestExecutionListenerClasses());\n\t\t}\n\t\telse {\n\t\t\t// Traverse the class hierarchy...\n\t\t\twhile (descriptor != null) {\n\t\t\t\tClass<?> declaringClass = descriptor.getDeclaringClass();\n\t\t\t\tAnnotationAttributes annAttrs = descriptor.getAnnotationAttributes();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(String.format(\n\t\t\t\t\t\t\"Retrieved @TestExecutionListeners attributes [%s] for declaring class [%s].\", annAttrs,\n\t\t\t\t\t\tdeclaringClass.getName()));\n\t\t\t\t}\n\n\t\t\t\tClass<? extends TestExecutionListener>[] valueListenerClasses = (Class<? extends TestExecutionListener>[]) annAttrs.getClassArray(\"value\");\n\t\t\t\tClass<? extends TestExecutionListener>[] listenerClasses = (Class<? extends TestExecutionListener>[]) annAttrs.getClassArray(\"listeners\");\n\t\t\t\tif (!ObjectUtils.isEmpty(valueListenerClasses) && !ObjectUtils.isEmpty(listenerClasses)) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\"Class [%s] configured with @TestExecutionListeners' \"\n\t\t\t\t\t\t\t\t+ \"'value' [%s] and 'listeners' [%s] attributes. Use one or the other, but not both.\",\n\t\t\t\t\t\tdeclaringClass.getName(), ObjectUtils.nullSafeToString(valueListenerClasses),\n\t\t\t\t\t\tObjectUtils.nullSafeToString(listenerClasses)));\n\t\t\t\t}\n\t\t\t\telse if (!ObjectUtils.isEmpty(valueListenerClasses)) {\n\t\t\t\t\tlistenerClasses = valueListenerClasses;\n\t\t\t\t}\n\n\t\t\t\tif (listenerClasses != null) {\n\t\t\t\t\tclassesList.addAll(0, Arrays.<Class<? extends TestExecutionListener>> asList(listenerClasses));\n\t\t\t\t}\n\t\t\t\tdescriptor = (annAttrs.getBoolean(\"inheritListeners\") ? MetaAnnotationUtils.findAnnotationDescriptor(\n\t\t\t\t\tdescriptor.getRootDeclaringClass().getSuperclass(), annotationType) : null);\n\t\t\t}\n\t\t}\n\n\t\tList<TestExecutionListener> listeners = new ArrayList<TestExecutionListener>(classesList.size());\n\t\tfor (Class<? extends TestExecutionListener> listenerClass : classesList) {\n\t\t\tNoClassDefFoundError ncdfe = null;\n\t\t\ttry {\n\t\t\t\tlisteners.add(BeanUtils.instantiateClass(listenerClass));\n\t\t\t}\n\t\t\tcatch (NoClassDefFoundError err) {\n\t\t\t\tncdfe = err;\n\t\t\t}\n\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\tif (ex.getCause() instanceof NoClassDefFoundError) {\n\t\t\t\t\tncdfe = (NoClassDefFoundError) ex.getCause();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ncdfe != null) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(String.format(\"Could not instantiate TestExecutionListener [%s]. \"\n\t\t\t\t\t\t\t+ \"Specify custom listener classes or make the default listener classes \"\n\t\t\t\t\t\t\t+ \"(and their required dependencies) available. Offending class: [%s]\",\n\t\t\t\t\t\tlistenerClass.getName(), ncdfe.getMessage()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn listeners;\n\t}","id":66262,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\tClass<?> clazz = getBootstrapContext().getTestClass();\n\t\tClass<TestExecutionListeners> annotationType = TestExecutionListeners.class;\n\t\tList<Class<? extends TestExecutionListener>> classesList = new ArrayList<Class<? extends TestExecutionListener>>();\n\t\tboolean usingDefaults = false;\n\n\t\tAnnotationDescriptor<TestExecutionListeners> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(clazz,\n\t\t\tannotationType);\n\n\t\t// Use defaults?\n\t\tif (descriptor == null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(String.format(\"@TestExecutionListeners is not present for class [%s]: using defaults.\",\n\t\t\t\t\tclazz.getName()));\n\t\t\t}\n\t\t\tusingDefaults = true;\n\t\t\tclassesList.addAll(getDefaultTestExecutionListenerClasses());\n\t\t}\n\t\telse {\n\t\t\t// Traverse the class hierarchy...\n\t\t\twhile (descriptor != null) {\n\t\t\t\tClass<?> declaringClass = descriptor.getDeclaringClass();\n\t\t\t\tAnnotationAttributes annAttrs = descriptor.getAnnotationAttributes();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(String.format(\n\t\t\t\t\t\t\"Retrieved @TestExecutionListeners attributes [%s] for declaring class [%s].\", annAttrs,\n\t\t\t\t\t\tdeclaringClass.getName()));\n\t\t\t\t}\n\n\t\t\t\tClass<? extends TestExecutionListener>[] valueListenerClasses = (Class<? extends TestExecutionListener>[]) annAttrs.getClassArray(\"value\");\n\t\t\t\tClass<? extends TestExecutionListener>[] listenerClasses = (Class<? extends TestExecutionListener>[]) annAttrs.getClassArray(\"listeners\");\n\t\t\t\tif (!ObjectUtils.isEmpty(valueListenerClasses) && !ObjectUtils.isEmpty(listenerClasses)) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\"Class [%s] configured with @TestExecutionListeners' \"\n\t\t\t\t\t\t\t\t+ \"'value' [%s] and 'listeners' [%s] attributes. Use one or the other, but not both.\",\n\t\t\t\t\t\tdeclaringClass.getName(), ObjectUtils.nullSafeToString(valueListenerClasses),\n\t\t\t\t\t\tObjectUtils.nullSafeToString(listenerClasses)));\n\t\t\t\t}\n\t\t\t\telse if (!ObjectUtils.isEmpty(valueListenerClasses)) {\n\t\t\t\t\tlistenerClasses = valueListenerClasses;\n\t\t\t\t}\n\n\t\t\t\tif (listenerClasses != null) {\n\t\t\t\t\tclassesList.addAll(0, Arrays.<Class<? extends TestExecutionListener>> asList(listenerClasses));\n\t\t\t\t}\n\t\t\t\tdescriptor = (annAttrs.getBoolean(\"inheritListeners\") ? MetaAnnotationUtils.findAnnotationDescriptor(\n\t\t\t\t\tdescriptor.getRootDeclaringClass().getSuperclass(), annotationType) : null);\n\t\t\t}\n\t\t}\n\n\t\tList<TestExecutionListener> listeners = instantiateListeners(classesList);\n\n\t\t// Sort by Ordered/@Order if we loaded default listeners.\n\t\tif (usingDefaults) {\n\t\t\tAnnotationAwareOrderComparator.sort(listeners);\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(String.format(\"Using TestExecutionListeners: %s\", listeners));\n\t\t}\n\t\treturn listeners;\n\t}","commit_id":"e6d16148e576fafe094c2bc1ef975c25576eeb7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Load the factory implementations of the given type from the default location,\n\t * using the given class loader.\n\t * <p>The returned factories are ordered in accordance with the {@link OrderComparator}.\n\t * @param factoryClass the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null} to use the default)\n\t */\n\tpublic static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n\t\tAssert.notNull(factoryClass, \"'factoryClass' must not be null\");\n\t\tClassLoader classLoaderToUse = classLoader;\n\t\tif (classLoaderToUse == null) {\n\t\t\tclassLoaderToUse = SpringFactoriesLoader.class.getClassLoader();\n\t\t}\n\t\tList<String> factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loaded [\" + factoryClass.getName() + \"] names: \" + factoryNames);\n\t\t}\n\t\tList<T> result = new ArrayList<T>(factoryNames.size());\n\t\tfor (String factoryName : factoryNames) {\n\t\t\tresult.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));\n\t\t}\n\t\tOrderComparator.sort(result);\n\t\treturn result;\n\t}","id":66263,"modified_method":"/**\n\t * Load the factory implementations of the given type from the default location,\n\t * using the given class loader.\n\t * <p>The returned factories are ordered in accordance with the {@link AnnotationAwareOrderComparator}.\n\t * @param factoryClass the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null} to use the default)\n\t */\n\tpublic static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n\t\tAssert.notNull(factoryClass, \"'factoryClass' must not be null\");\n\t\tClassLoader classLoaderToUse = classLoader;\n\t\tif (classLoaderToUse == null) {\n\t\t\tclassLoaderToUse = SpringFactoriesLoader.class.getClassLoader();\n\t\t}\n\t\tList<String> factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loaded [\" + factoryClass.getName() + \"] names: \" + factoryNames);\n\t\t}\n\t\tList<T> result = new ArrayList<T>(factoryNames.size());\n\t\tfor (String factoryName : factoryNames) {\n\t\t\tresult.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(result);\n\t\treturn result;\n\t}","commit_id":"e6d16148e576fafe094c2bc1ef975c25576eeb7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void verifyNumDefaultListenersRegistered() throws Exception {\n\t\tTestContextManager testContextManager = new TestContextManager(DefaultListenersExampleTestCase.class);\n\t\tassertEquals(\"Num registered TELs for DefaultListenersExampleTestCase.\", 4,\n\t\t\ttestContextManager.getTestExecutionListeners().size());\n\t}","id":66264,"modified_method":"@Test\n\tpublic void verifyNumDefaultListenersRegistered() throws Exception {\n\t\tTestContextManager testContextManager = new TestContextManager(DefaultListenersExampleTestCase.class);\n\t\tassertEquals(\"Num registered TELs for DefaultListenersExampleTestCase.\", 5,\n\t\t\ttestContextManager.getTestExecutionListeners().size());\n\t}","commit_id":"e6d16148e576fafe094c2bc1ef975c25576eeb7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        addLocations(locations);\n        setExpectedState(this, STARTING);\n    }","id":66265,"modified_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        addLocations(filterLocations(locations));\n        setExpectedState(this, STARTING);\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private SimpleShellCommand.Result executeShellCommand(MachineLocation machineLocation, String command) {\n\n        SshMachineLocation machine = getSshMachine(ImmutableList.of(machineLocation));\n        SshEffectorTasks.SshEffectorTaskFactory<Integer> etf = SshEffectorTasks.ssh(machine, command);\n\n        LOG.debug(\"{} Creating task to execute '{}' on location {}\", new Object[] {this, command, machine});\n        ProcessTaskWrapper<Integer> job = DynamicTasks.queue(etf);\n        DynamicTasks.waitForLast();\n        return buildResult(job);\n    }","id":66266,"modified_method":"private SimpleShellCommand.Result executeShellCommand(MachineLocation machineLocation, String command) {\n\n        SshMachineLocation machine = getSshMachine(ImmutableList.of(machineLocation));\n\n        List<String> commands = new ArrayList<>();\n        maybeCdToRunDir(commands);\n        commands.add(command);\n\n        return runCommands(machine, commands);\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private SimpleShellCommand.Result executeDownloadedScript(MachineLocation machineLocation, String url, String scriptPath) {\n\n        SshMachineLocation machine = getSshMachine(ImmutableList.<Location>of(machineLocation));\n\n        TaskFactory<?> install = SshTasks.installFromUrl(ImmutableMap.<String, Object>of(), machine, url, scriptPath);\n        DynamicTasks.queue(install);\n        DynamicTasks.waitForLast();\n\n        machine.execCommands(\"make the script executable\", ImmutableList.<String>of(\"chmod u+x \" + scriptPath));\n\n        String runDir = getConfig(RUN_DIR);\n        String cdAndRun = Joiner.on(' ').join(CD, runDir, SHELL_AND, scriptPath);\n\n        return executeShellCommand(machineLocation, cdAndRun);\n    }","id":66267,"modified_method":"private SimpleShellCommand.Result executeDownloadedScript(MachineLocation machineLocation, String url, String scriptPath) {\n\n        SshMachineLocation machine = getSshMachine(ImmutableList.<Location>of(machineLocation));\n\n        TaskFactory<?> install = SshTasks.installFromUrl(ImmutableMap.<String, Object>of(), machine, url, scriptPath);\n        DynamicTasks.queue(install);\n        DynamicTasks.waitForLast();\n\n        List<String> commands = new ArrayList<>();\n        commands.add(\"chmod u+x \" + scriptPath);\n        maybeCdToRunDir(commands);\n        commands.add(scriptPath);\n\n        return runCommands(machine, commands);\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void executeCommand(MachineLocation machineLocation) {\n\n        SimpleShellCommand.Result result = null;\n        String downloadUrl = getConfig(DOWNLOAD_URL);\n        String command = getConfig(COMMAND);\n\n        String downloadName = DOWNLOAD_URL.getName();\n        String commandName = COMMAND.getName();\n\n        if (isNonBlank(downloadUrl) && isNonBlank(command)) {\n            throw illegal(\"Cannot specify both\", downloadName, \"and\", commandName);\n        }\n\n        if (isBlank(downloadUrl) && isBlank(commandName)) {\n            throw illegal(\"No\", downloadName, \"and no\", commandName, \"provided\");\n        }\n\n        if (Strings.isNonBlank(downloadUrl)) {\n            String scriptDir = getConfig(SCRIPT_DIR);\n            String scriptPath = calculateDestPath(downloadUrl, scriptDir);\n            result = executeDownloadedScript(machineLocation, downloadUrl, scriptPath);\n        }\n\n        if (Strings.isNonBlank(command)) {\n            result = executeShellCommand(machineLocation, command);\n        }\n\n        handle(result);\n    }","id":66268,"modified_method":"private void executeCommand(MachineLocation machineLocation) {\n\n        SimpleShellCommand.Result result = null;\n        String downloadUrl = getConfig(DOWNLOAD_URL);\n        String command = getConfig(COMMAND);\n\n        String downloadName = DOWNLOAD_URL.getName();\n        String commandName = COMMAND.getName();\n\n        if (!(isNonBlank(downloadUrl) ^ isNonBlank(command))) {\n            throw illegal(\"Must specify exactly one of\", downloadName, \"and\", commandName);\n        }\n\n        if (isNonBlank(downloadUrl)) {\n            String scriptDir = getConfig(SCRIPT_DIR);\n            String scriptPath = calculateDestPath(downloadUrl, scriptDir);\n            result = executeDownloadedScript(machineLocation, downloadUrl, scriptPath);\n        }\n\n        if (isNonBlank(command)) {\n            result = executeShellCommand(machineLocation, command);\n        }\n\n        handle(result);\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private <T> SimpleShellCommand.Result buildResult(final ProcessTaskWrapper<Integer> job) {\n        return new SimpleShellCommand.Result() {\n\n            @Override\n            public int getExitCode() {\n                return job.get();\n            }\n\n            @Override\n            public String getStdout() {\n                return job.getStdout().trim();\n            }\n\n            @Override\n            public String getStderr() {\n                return job.getStderr().trim();\n            }\n        };\n    }","id":66269,"modified_method":"private <T> SimpleShellCommand.Result buildResult(final ProcessTaskWrapper<Integer> job) {\n        final int exitCode = job.get();\n        final String stdout = job.getStdout().trim();\n        final String stderr = job.getStderr().trim();\n        return new SimpleShellCommand.Result() {\n\n            @Override\n            public int getExitCode() {\n                return exitCode;\n            }\n\n            @Override\n            public String getStdout() {\n                return stdout;\n            }\n\n            @Override\n            public String getStderr() {\n                return stderr;\n            }\n        };\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private IllegalArgumentException illegal(String ...messages) {\n        return new IllegalArgumentException(Joiner.on(' ').join(this.toString() + \":\", messages));\n    }","id":66270,"modified_method":"private IllegalArgumentException illegal(String message, String ...messages) {\n        return new IllegalArgumentException(Joiner.on(' ').join(this.toString() + \":\", message, messages));\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private String createTempScript(String filename, String contents) {\n        try {\n            Path tempDirectory = Files.createTempDirectory(randomName());\n            tempDirectory.toFile().deleteOnExit();\n            Path tempFile = Files.createFile(tempDirectory.resolve(filename));\n            Files.write(tempFile, contents.getBytes());\n            return \"file:\" + tempFile.toString();\n        } catch (IOException e) {\n            throw Exceptions.propagate(e);\n        }\n    }","id":66271,"modified_method":"private Path createTempScript(String filename, String contents) {\n        try {\n            Path tempFile = Files.createTempFile(\"SimpleShellCommandIntegrationTest-\" + filename, \".sh\");\n            Files.write(tempFile, contents.getBytes());\n            return tempFile;\n        } catch (IOException e) {\n            throw Exceptions.propagate(e);\n        }\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void shouldExecuteInTheRightPlace() throws Exception {\n        TestEntity testEntity = app.createAndManageChild(EntitySpec.create(TestEntity.class));\n\n        String remoteTmp = randomName();\n        SimpleShellCommandTest uptime = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n            .configure(TARGET_ENTITY, testEntity)\n            .configure(COMMAND, \"mkdir \" + remoteTmp)\n            .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0)));\n\n        String pwdUrl = createTempScript(\"pwd.sh\", \"pwd\");\n\n        SimpleShellCommandTest pwd = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n            .configure(TARGET_ENTITY, testEntity)\n            .configure(DOWNLOAD_URL, pwdUrl)\n            .configure(RUN_DIR, remoteTmp)\n            .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0))\n            .configure(ASSERT_OUT, ImmutableMap.of(CONTAINS, remoteTmp)));\n\n        app.start(ImmutableList.of(localhost));\n\n        assertThat(uptime.sensors().get(SERVICE_UP)).isTrue()\n            .withFailMessage(\"Service should be up\");\n        assertThat(ServiceStateLogic.getExpectedState(uptime)).isEqualTo(Lifecycle.RUNNING)\n            .withFailMessage(\"Service should be marked running\");\n    }","id":66272,"modified_method":"@Test\n    public void shouldExecuteInTheRunDir() throws Exception {\n        TestEntity testEntity = app.createAndManageChild(EntitySpec.create(TestEntity.class));\n\n        Path pwdPath = createTempScript(\"pwd\", \"pwd\");\n\n        try {\n            SimpleShellCommandTest pwd = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n                .configure(TARGET_ENTITY, testEntity)\n                .configure(DOWNLOAD_URL, \"file:\" + pwdPath)\n                .configure(RUN_DIR, \"/tmp\")\n                .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0))\n                .configure(ASSERT_OUT, ImmutableMap.of(CONTAINS, \"/tmp\")));\n\n\n            SimpleShellCommandTest alsoPwd = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n                .configure(TARGET_ENTITY, testEntity)\n                .configure(COMMAND, \"pwd\")\n                .configure(RUN_DIR, \"/tmp\")\n                .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0))\n                .configure(ASSERT_OUT, ImmutableMap.of(CONTAINS, \"/tmp\")));\n\n            app.start(ImmutableList.of(localhost));\n\n            assertThat(pwd.sensors().get(SERVICE_UP)).isTrue().withFailMessage(\"Service should be up\");\n            assertThat(ServiceStateLogic.getExpectedState(pwd)).isEqualTo(Lifecycle.RUNNING)\n                .withFailMessage(\"Service should be marked running\");\n\n            assertThat(alsoPwd.sensors().get(SERVICE_UP)).isTrue().withFailMessage(\"Service should be up\");\n            assertThat(ServiceStateLogic.getExpectedState(alsoPwd)).isEqualTo(Lifecycle.RUNNING)\n                .withFailMessage(\"Service should be marked running\");\n\n        } finally {\n            Files.delete(pwdPath);\n        }\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void shouldInvokeScript() {\n        TestEntity testEntity = app.createAndManageChild(EntitySpec.create(TestEntity.class));\n\n        String text = \"hello world\";\n        String testUrl = createTempScript(\"script.sh\", \"echo \" + text);\n\n        SimpleShellCommandTest uptime = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n            .configure(TARGET_ENTITY, testEntity)\n            .configure(DOWNLOAD_URL, testUrl)\n            .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0))\n            .configure(ASSERT_OUT, ImmutableMap.of(CONTAINS, text)));\n\n        app.start(ImmutableList.of(localhost));\n\n        assertThat(uptime.sensors().get(SERVICE_UP)).isTrue()\n            .withFailMessage(\"Service should be up\");\n        assertThat(ServiceStateLogic.getExpectedState(uptime)).isEqualTo(Lifecycle.RUNNING)\n            .withFailMessage(\"Service should be marked running\");\n    }","id":66273,"modified_method":"@Test(groups = \"Integration\")\n    public void shouldInvokeScript() throws Exception {\n        TestEntity testEntity = app.createAndManageChild(EntitySpec.create(TestEntity.class));\n\n        String text = \"hello world\";\n        Path testScript = createTempScript(\"script\", \"echo \" + text);\n\n        try {\n            SimpleShellCommandTest uptime = app.createAndManageChild(EntitySpec.create(SimpleShellCommandTest.class)\n                .configure(TARGET_ENTITY, testEntity)\n                .configure(DOWNLOAD_URL, \"file:\" + testScript)\n                .configure(ASSERT_STATUS, ImmutableMap.of(EQUALS, 0))\n                .configure(ASSERT_OUT, ImmutableMap.of(CONTAINS, text)));\n\n            app.start(ImmutableList.of(localhost));\n\n            assertThat(uptime.sensors().get(SERVICE_UP)).isTrue()\n                .withFailMessage(\"Service should be up\");\n            assertThat(ServiceStateLogic.getExpectedState(uptime)).isEqualTo(Lifecycle.RUNNING)\n                .withFailMessage(\"Service should be marked running\");\n\n        } finally {\n            Files.delete(testScript);\n        }\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * The test will choose the location of its target entity.\n     */\n    public Collection<? extends Location> filterLocations(Collection<? extends Location> locations) {\n        Entity target = resolveTarget();\n        return target.getLocations();\n    }","id":66274,"modified_method":"/**\n     * The test will choose the location of its target entity.\n     */\n    public Collection<? extends Location> filterLocations(Collection<? extends Location> locations) {\n        Entity target = resolveTarget();\n        Collection<Location> targetLocations = target.getLocations();\n        return targetLocations;\n    }","commit_id":"60178809b3c51a429e6871bb68404245baa86269","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** @deprecated since 0.7.0 see #create */ @Deprecated \n  protected Response createFromAppSpec(ApplicationSpec applicationSpec) {\n      checkApplicationTypesAreValid(applicationSpec);\n      checkLocationsAreValid(applicationSpec);\n      // TODO duplicate prevention\n      Application app = brooklyn().create(applicationSpec);\n      Task<?> t = brooklyn().start(app, applicationSpec);\n      TaskSummary ts = TaskTransformer.FROM_TASK.apply(t);\n      URI ref = URI.create(app.getApplicationId());\n      return created(ref).entity(ts).build();\n  }","id":66275,"modified_method":"/** @deprecated since 0.7.0 see #create */ @Deprecated \n  protected Response createFromAppSpec(ApplicationSpec applicationSpec) {\n      checkApplicationTypesAreValid(applicationSpec);\n      checkLocationsAreValid(applicationSpec);\n      // TODO duplicate prevention\n      List<Location> locations = brooklyn().getLocations(applicationSpec);\n      Application app = brooklyn().create(applicationSpec);\n      Task<?> t = brooklyn().start(app, locations);\n      TaskSummary ts = TaskTransformer.FROM_TASK.apply(t);\n      URI ref = URI.create(app.getApplicationId());\n      return created(ref).entity(ts).build();\n  }","commit_id":"026cd0732715df5b35588c0e4da492ba36e14393","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public Location resolve(String spec, Map locationFlags) {\n        try {\n            Set<String> seenSoFar = specsSeen.get();\n            if (seenSoFar==null) {\n                seenSoFar = new LinkedHashSet<String>();\n                specsSeen.set(seenSoFar);\n            }\n            if (seenSoFar.contains(spec))\n                throw new IllegalStateException(\"Circular reference in definition of location '\"+spec+\"' (\"+seenSoFar+\")\");\n            seenSoFar.add(spec);\n            \n            LocationResolver resolver = getSpecResolver(spec);\n\n            if (resolver != null) {\n                return resolver.newLocationFromString(locationFlags, spec, this);\n            }\n\n            // problem: but let's ensure that classpath is sane to give better errors in common IDE bogus case\n            throw new NoSuchElementException(\"No resolver found for '\"+spec+\"': \"\n                + \"known resolvers are \"+resolvers.keySet()+\"; if you do not see an expected resolver, \"\n                + \"ensure your classpath is correct and includes META-INF/services\");\n        } finally {\n            specsSeen.remove();\n        }\n    }","id":66276,"modified_method":"@Override\n    public Location resolve(String spec, Map locationFlags) {\n        try {\n            Set<String> seenSoFar = specsSeen.get();\n            if (seenSoFar==null) {\n                seenSoFar = new LinkedHashSet<String>();\n                specsSeen.set(seenSoFar);\n            }\n            if (seenSoFar.contains(spec))\n                throw new IllegalStateException(\"Circular reference in definition of location '\"+spec+\"' (\"+seenSoFar+\")\");\n            seenSoFar.add(spec);\n            \n            LocationResolver resolver = getSpecResolver(spec);\n\n            if (resolver != null) {\n                return resolver.newLocationFromString(locationFlags, spec, this);\n            }\n\n            // problem: but let's ensure that classpath is sane to give better errors in common IDE bogus case\n            if (resolvers.get(\"id\")==null || resolvers.get(\"named\")==null) {\n                log.error(\"Standard location resolvers not installed, location resolution will fail shortly. This usually indicates a classpath problem, \"\n                    + \"such as when running from an IDE which has not properly copied META-INF/services from src/main/resources.\"\n                    + \"Known resolvers are: \"+resolvers.keySet());\n                throw new NoSuchElementException(\"Unresolvable location '\"+spec+\"': \"\n                    + \"Problem detected with location resolver configuration: \"+resolvers.keySet()+\" are the only available location resolvers. \"\n                    + \"More information can be found in the logs.\");\n            } else {\n                log.warn(\"Location resolution failed for '\"+spec+\"' (will fail shortly): known resolvers are: \"+resolvers.keySet());\n                throw new NoSuchElementException(\"Unknown location '\"+spec+\"': \"\n                    + \"either this location is not recognised or there is a problem with location resolver configuration.\");\n            }\n                \n        } finally {\n            specsSeen.remove();\n        }\n    }","commit_id":"026cd0732715df5b35588c0e4da492ba36e14393","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public Task<?> start(Application app, ApplicationSpec spec) {\n        // Start all the managed entities by asking the app instance to start in background\n        Function<String, Location> buildLocationFromId = new Function<String, Location>() {\n            @Override\n            public Location apply(String id) {\n                id = fixLocation(id);\n                return getLocationRegistry().resolve(id);\n            }\n        };\n\n        ArrayList<Location> locations = Lists.newArrayList(transform(spec.getLocations(), buildLocationFromId));\n        return Entities.invokeEffector((EntityLocal)app, app, Startable.START,\n                MutableMap.of(\"locations\", locations));\n    }","id":66277,"modified_method":"public Task<?> start(Application app, ApplicationSpec spec) {\n        return start(app, getLocations(spec));\n    }","commit_id":"026cd0732715df5b35588c0e4da492ba36e14393","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public synchronized List<NetAddress> getLocations() {\n    List<NetAddress> ret = new ArrayList<NetAddress>(mLocations.size());\n    ret.addAll(mLocations.values());\n    return ret;\n  }","id":66278,"modified_method":"public synchronized List<NetAddress> getLocations() {\n    List<NetAddress> ret = new ArrayList<NetAddress>(mLocations.size());\n    ret.addAll(mLocations.values());\n    if (ret.isEmpty() && hasCheckpointed()) {\n      HdfsClient hdfsClient = new HdfsClient(mCheckpointPath);\n      List<String> locs = hdfsClient.getFirstBlockLocations(mCheckpointPath);\n      for (String loc: locs) {\n        ret.add(new NetAddress(loc, -1));\n      }\n    }\n    return ret;\n  }","commit_id":"e7febab357d6355ddf45232427ad1b2f5b60591b","url":"https://github.com/amplab/tachyon"},{"original_method":"public List<NetAddress> getFileLocations(int fileId) throws FileDoesNotExistException {\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n      if (inode == null || inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"FileId \" + fileId + \" does not exist.\");\n      }\n      LOG.debug(\"getFileLocations: \" + fileId + ((InodeFile) inode).getLocations());\n      return ((InodeFile) inode).getLocations();\n    }\n  }","id":66279,"modified_method":"public List<NetAddress> getFileLocations(int fileId) throws FileDoesNotExistException {\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n      if (inode == null || inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"FileId \" + fileId + \" does not exist.\");\n      }\n      List<NetAddress> ret = ((InodeFile) inode).getLocations();\n      LOG.debug(\"getFileLocations: \" + fileId + ret);\n      return ret;\n    }\n  }","commit_id":"e7febab357d6355ddf45232427ad1b2f5b60591b","url":"https://github.com/amplab/tachyon"},{"original_method":"private void runAndSaveSnmpVlanCollection(OnmsVlan vlan) {\n\t\tSnmpVlanCollection snmpvlancollection = new SnmpVlanCollection(m_agentConfig,m_collectStpNode,m_collectStpTable,m_collectBridgeForwardingTable);\n\t\tsnmpvlancollection.run();\n\t\t\n\t\tif (snmpvlancollection.failed()) {\n\t\t    LogUtils.debugf(this, \"SnmpCollection.run: no bridge info found for %s\", m_agentConfig);\n\t\t} else {\n\t\t    LogUtils.debugf(this, \"SnmpCollection.run: adding bridge info to snmpcollection, VLAN = %s, SnmpVlanCollection = %s\", vlan, snmpvlancollection);\n\t\t\tm_snmpVlanCollection.put(vlan,snmpvlancollection);\n\t\t}\n\t}","id":66280,"modified_method":"private void runAndSaveSnmpVlanCollection(OnmsVlan vlan) {\n\t\tSnmpVlanCollection snmpvlancollection = new SnmpVlanCollection(m_agentConfig,m_collectStpNode,m_collectStpTable,m_collectBridgeForwardingTable);\n\t\tsnmpvlancollection.run();\n\t\t\n\t\tif (snmpvlancollection.failed()) {\n\t\t    LogUtils.debugf(this, \"runAndSaveSnmpVlanCollection: no bridge info found for %s\", m_agentConfig);\n\t\t} else {\n\t\t    LogUtils.debugf(this, \"runAndSaveSnmpVlanCollection: adding bridge info to snmpcollection, VLAN = %s, SnmpVlanCollection = %s\", vlan, snmpvlancollection);\n\t\t\tm_snmpVlanCollection.put(vlan,snmpvlancollection);\n\t\t}\n\t}","commit_id":"0ceac1fde87cffb318a646991c87c1358ff340fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>\n\t * Performs the collection for the targeted IP address. The success or\n\t * failure of the collection should be tested via the <code>failed<\/code>\n\t * method.\n\t * <\/p>\n\t *\n\t * <p>\n\t * No synchronization is performed, so if this is used in a separate thread\n\t * context synchronization must be added.\n\t * <\/p>\n\t */\n\t@SuppressWarnings(\"unchecked\")\n    public void run() {\n\t\t\n\n\t\tfinal String hostAddress = str(m_address);\n\t\tif (suspendCollection) {\n\t\t    LogUtils.debugf(this, \"SnmpCollection.run: address: %s Suspended!\", hostAddress);\n\t\t} else {\n\n\t\t\tm_ipNetToMedia = new IpNetToMediaTable(m_address);\n\n\t\t\tm_CdpCache = new CdpCacheTable(m_address);\n\n\t\t\tLogUtils.debugf(this, \"SnmpCollection.run: collecting : %s\", m_agentConfig);\n\n\t\t\tSnmpWalker walker = null;\n\n            boolean collectIpRouteTable = m_collectIpRouteTable;\n            if (collectIpRouteTable) {\n                Class<?> ipRouteGetter = null;\n                try {\n                        ipRouteGetter = Class.forName(m_ipRouteClass);\n                } catch (ClassNotFoundException e) {\n                        LogUtils.errorf(this, e, \"SnmpCollection.run: \" + m_ipRouteClass + \" class not found \");\n                        collectIpRouteTable = false;\n                }\n\n                Class<?>[] classes = { InetAddress.class };\n                Constructor<?> constr = null;\n                try {\n                        constr = ipRouteGetter.getConstructor(classes);\n                } catch (Throwable e) {\n                        LogUtils.errorf(this, e, \"SnmpCollection.run: \" + m_ipRouteClass + \" unable to get constructor.\");\n                        collectIpRouteTable = false;\n                }\n                Object[] argum = { m_address };\n                try {\n                        m_ipRoute = (SnmpTable<SnmpStore>) constr.newInstance(argum);\n                } catch (Throwable e) {\n                        LogUtils.errorf(this, e, \"SnmpCollection.run: \" + m_ipRouteClass + \" unable to invoke class.\");\n                        collectIpRouteTable = false;\n                }\n            }\n\t\t\t    \t\t\t\n\t\t\tboolean collectVlanTable = m_collectVlanTable;\n            if (collectVlanTable) {\n\t\t\t\tClass<?> vlanGetter = null;\n\t\t\t\ttry {\n\t\t\t\t\tvlanGetter = Class.forName(m_vlanClass);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"SnmpCollection.run: %s class not found\", m_vlanClass);\n\t\t\t\t    collectVlanTable = false;\n\t\t\t\t}\n\n\t\t\t\tClass<?>[] classes = { InetAddress.class };\n\t\t\t\tConstructor<?> constr = null;\n\t\t\t\ttry {\n\t\t\t\t\tconstr = vlanGetter.getConstructor(classes);\n\t\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"SnmpCollection.run: %s class has no such method\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t} catch (SecurityException s) {\n                    LogUtils.warnf(this, s, \"SnmpCollection.run: %s class security violation\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t}\n\t\t\t\tObject[] argum = { m_address };\n\t\t\t\ttry {\n\t\t\t\t\tm_vlanTable = (SnmpTable<SnmpStore>) constr.newInstance(argum);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"SnmpCollection.run: unable to instantiate class %s\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n            String name = null;\n            CollectionTracker[] tracker = new CollectionTracker[0];\n\n            if (collectVlanTable && collectIpRouteTable && m_collectCdpTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache, m_vlanTable };\n            } else if (m_collectCdpTable && collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache };\n            } else if (collectVlanTable && collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_vlanTable };\n            } else if (collectVlanTable && m_collectCdpTable) {\n                name = \"ipNetToMediaTable/vlanTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable, m_CdpCache };\n            } else if (collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute };\n            } else if (collectVlanTable) {\n                name = \"ipNetToMediaTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable };\n            } else if (m_collectCdpTable && m_ipNetToMedia != null && m_CdpCache != null) {\n                name = \"ipNetToMediaTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_CdpCache };\n            } else if (m_ipNetToMedia != null) {\n                name = \"ipNetToMediaTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia };\n            }\n            if (name == null) {\n                LogUtils.infof(this, \"SnmpCollection.run: Unable to determine data to collect from %s\", str(m_agentConfig.getAddress()));\n                return;\n            } else {\n                LogUtils.infof(this, \"SnmpCollection.run: Collecting %s from %s\", name, str(m_agentConfig.getAddress()));\n            }\n            walker = SnmpUtils.createWalker(m_agentConfig, name, tracker);\n\n\t\t\twalker.start();\n\n\t\t\ttry {\n\t\t\t\twalker.waitFor();\n\t\t\t} catch (final InterruptedException e) {\n\t\t\t\tm_ipNetToMedia = null;\n\t\t\t\tm_ipRoute = null;\n\t\t\t\tm_CdpCache = null;\n\t\t\t\tm_vlanTable = null;\n\n\t\t\t\tLogUtils.errorf(this, e, \"SnmpCollection.run: collection interrupted, exiting\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Log any failures\n\t\t\t//\n\t\t\tif (!this.hasIpNetToMediaTable())\n\t\t\t    LogUtils.infof(this, \"SnmpCollection.run: failed to collect ipNetToMediaTable for %s\", hostAddress);\n\t\t\tif (!this.hasRouteTable())\n                LogUtils.infof(this, \"SnmpCollection.run: failed to collect ipRouteTable for %s\", hostAddress);\n\t\t\tif (!this.hasCdpCacheTable())\n                LogUtils.infof(this, \"SnmpCollection.run: failed to collect dpCacheTable for %s\", hostAddress);\n\t\t\tif (collectVlanTable && !this.hasVlanTable())\n                LogUtils.infof(this, \"SnmpCollection.run: failed to collect VLAN for %s\", hostAddress);\n\t\t\t// Schedule SNMP VLAN collection only on VLAN.\n\t\t\t// If it has not VLAN collection no data download is done.\n\t\t\t\n\t\t\tOnmsVlan vlan = null;\n\n\t\t\tif (this.hasVlanTable()) {\n\t\t\t\tif (!m_vlanClass.equals(\"org.opennms.netmgt.linkd.snmp.CiscoVlanTable\")\n\t\t\t\t\t\t&& !m_vlanClass.equals(\"org.opennms.netmgt.linkd.snmp.IntelVlanTable\")) {\n\n\t\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(TRUNK_VLAN_INDEX,TRUNK_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));\n\t\t\t\t} else {\n\t\t\t\t    LogUtils.debugf(this, \"SnmpCollection.run: start collection for %d VLAN entries\", getVlanTable().getEntries().size());\n\n\t\t\t\t\tfor (final SnmpStore ent : m_vlanTable.getEntries()) {\n\t\t \t\t\t\tint vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);\n\t\t\t\t\t\tif (vlanindex == -1) {\n\t\t\t\t\t\t    LogUtils.debugf(this, \"SnmpCollection.run: found null value for VLAN.\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);\n\t\t\t\t\t\tif (vlanname == null) vlanname = DEFAULT_VLAN_NAME; \n\t\t\t\t\t\tInteger status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);\n\n\t\t\t\t\t\tif (status == null || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {\n\t\t\t\t\t\t    LogUtils.infof(this, \"SnmpCollection.run: skipping VLAN %s: NOT ACTIVE or null\", vlan);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString community = m_agentConfig.getReadCommunity();\n\t\t\t\t\t\tLogUtils.debugf(this, \"SnmpCollection.run: peer community: %s with VLAN %s\", community, vlan);\n\n\t\t\t\t\t\tInteger type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);\n\t\t\t\t\t\tif (type == null || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {\n\t\t\t\t\t\t    LogUtils.infof(this, \"SnmpCollection.run: skipping VLAN %s NOT ETHERNET TYPE\", vlan);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm_agentConfig.setReadCommunity(community + \"@\" + vlanindex);\n\n\t\t\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(vlanindex,vlanname,status));\n\t\t\t\t\t\tm_agentConfig.setReadCommunity(community);\n\t\t\t\t\t}  \n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(DEFAULT_VLAN_INDEX,DEFAULT_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));\n\t\t\t}\n\t\t\t// update info in linkd used correctly by {@link DiscoveryLink}\n\t\t\tLogUtils.debugf(this, \"SnmpCollection.run: saving collection into database for %s\", str(m_agentConfig.getAddress()));\n\n\t\t\tm_linkd.updateNodeSnmpCollection(this);\n\t\t\t// clean memory\n\t\t\t// first make everything clean\n\t\t\tm_ipNetToMedia = null;\n\t\t\tm_ipRoute = null;\n\t\t\tm_CdpCache = null;\n\t\t\tm_vlanTable = null;\n\t\t\tm_snmpVlanCollection.clear();\n\t\t}\n\n\t\t// reschedule itself\n\t\treschedule();\n\t\trunned = true;\n\t}","id":66281,"modified_method":"/**\n\t * <p>\n\t * Performs the collection for the targeted IP address. The success or\n\t * failure of the collection should be tested via the <code>failed<\/code>\n\t * method.\n\t * <\/p>\n\t *\n\t * <p>\n\t * No synchronization is performed, so if this is used in a separate thread\n\t * context synchronization must be added.\n\t * <\/p>\n\t */\n\t@SuppressWarnings(\"unchecked\")\n    public void run() {\n\t\t\n\n\t\tfinal String hostAddress = str(m_address);\n\t\tif (suspendCollection) {\n\t\t    LogUtils.debugf(this, \"run: address: %s Suspended!\", hostAddress);\n\t\t} else {\n\n\t\t\tm_ipNetToMedia = new IpNetToMediaTable(m_address);\n\n\t\t\tm_CdpCache = new CdpCacheTable(m_address);\n\n\t\t\tLogUtils.debugf(this, \"run: collecting : %s\", m_agentConfig);\n\n\t\t\tSnmpWalker walker = null;\n\n            boolean collectIpRouteTable = m_collectIpRouteTable;\n            if (collectIpRouteTable) {\n                Class<?> ipRouteGetter = null;\n                try {\n                        ipRouteGetter = Class.forName(m_ipRouteClass);\n                } catch (ClassNotFoundException e) {\n                        LogUtils.errorf(this, e, \"run: \" + m_ipRouteClass + \" class not found \");\n                        collectIpRouteTable = false;\n                }\n\n                Class<?>[] classes = { InetAddress.class };\n                Constructor<?> constr = null;\n                try {\n                        constr = ipRouteGetter.getConstructor(classes);\n                } catch (Throwable e) {\n                        LogUtils.errorf(this, e, \"run: \" + m_ipRouteClass + \" unable to get constructor.\");\n                        collectIpRouteTable = false;\n                }\n                Object[] argum = { m_address };\n                try {\n                        m_ipRoute = (SnmpTable<SnmpStore>) constr.newInstance(argum);\n                } catch (Throwable e) {\n                        LogUtils.errorf(this, e, \"run: \" + m_ipRouteClass + \" unable to invoke class.\");\n                        collectIpRouteTable = false;\n                }\n            }\n\t\t\t    \t\t\t\n\t\t\tboolean collectVlanTable = m_collectVlanTable;\n            if (collectVlanTable) {\n\t\t\t\tClass<?> vlanGetter = null;\n\t\t\t\ttry {\n\t\t\t\t\tvlanGetter = Class.forName(m_vlanClass);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"run: %s class not found\", m_vlanClass);\n\t\t\t\t    collectVlanTable = false;\n\t\t\t\t}\n\n\t\t\t\tClass<?>[] classes = { InetAddress.class };\n\t\t\t\tConstructor<?> constr = null;\n\t\t\t\ttry {\n\t\t\t\t\tconstr = vlanGetter.getConstructor(classes);\n\t\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"run: %s class has no such method\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t} catch (SecurityException s) {\n                    LogUtils.warnf(this, s, \"run: %s class security violation\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t}\n\t\t\t\tObject[] argum = { m_address };\n\t\t\t\ttry {\n\t\t\t\t\tm_vlanTable = (SnmpTable<SnmpStore>) constr.newInstance(argum);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t    LogUtils.warnf(this, e, \"run: unable to instantiate class %s\", m_vlanClass);\n                    collectVlanTable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n            String name = null;\n            CollectionTracker[] tracker = new CollectionTracker[0];\n\n            if (collectVlanTable && collectIpRouteTable && m_collectCdpTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache, m_vlanTable };\n            } else if (m_collectCdpTable && collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache };\n            } else if (collectVlanTable && collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_vlanTable };\n            } else if (collectVlanTable && m_collectCdpTable) {\n                name = \"ipNetToMediaTable/vlanTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable, m_CdpCache };\n            } else if (collectIpRouteTable) {\n                name = \"ipNetToMediaTable/ipRouteTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute };\n            } else if (collectVlanTable) {\n                name = \"ipNetToMediaTable/vlanTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable };\n            } else if (m_collectCdpTable && m_ipNetToMedia != null && m_CdpCache != null) {\n                name = \"ipNetToMediaTable/cdpCacheTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia, m_CdpCache };\n            } else if (m_ipNetToMedia != null) {\n                name = \"ipNetToMediaTable\";\n                tracker = new CollectionTracker[] { m_ipNetToMedia };\n            }\n            if (name == null) {\n                LogUtils.infof(this, \"run: Unable to determine data to collect from %s\", str(m_agentConfig.getAddress()));\n                return;\n            } else {\n                LogUtils.infof(this, \"run: Collecting %s from %s\", name, str(m_agentConfig.getAddress()));\n            }\n            walker = SnmpUtils.createWalker(m_agentConfig, name, tracker);\n\n\t\t\twalker.start();\n\n\t\t\ttry {\n\t\t\t\twalker.waitFor();\n\t\t\t} catch (final InterruptedException e) {\n\t\t\t\tm_ipNetToMedia = null;\n\t\t\t\tm_ipRoute = null;\n\t\t\t\tm_CdpCache = null;\n\t\t\t\tm_vlanTable = null;\n\n\t\t\t\tLogUtils.errorf(this, e, \"run: collection interrupted, exiting\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Log any failures\n\t\t\t//\n\t\t\tif (!this.hasIpNetToMediaTable())\n\t\t\t    LogUtils.infof(this, \"run: failed to collect ipNetToMediaTable for %s\", hostAddress);\n\t\t\tif (!this.hasRouteTable())\n                LogUtils.infof(this, \"run: failed to collect ipRouteTable for %s\", hostAddress);\n\t\t\tif (!this.hasCdpCacheTable())\n                LogUtils.infof(this, \"run: failed to collect dpCacheTable for %s\", hostAddress);\n\t\t\tif (collectVlanTable && !this.hasVlanTable())\n                LogUtils.infof(this, \"run: failed to collect VLAN for %s\", hostAddress);\n\t\t\t// Schedule SNMP VLAN collection only on VLAN.\n\t\t\t// If it has not VLAN collection no data download is done.\n\t\t\t\n\t\t\tOnmsVlan vlan = null;\n\n\t\t\tif (this.hasVlanTable()) {\n\t\t\t\tif (!m_vlanClass.equals(CiscoVlanTable.class.getName())\n\t\t\t\t\t\t&& !m_vlanClass.equals(IntelVlanTable.class.getName())) {\n\n\t\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(TRUNK_VLAN_INDEX,TRUNK_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));\n\t\t\t\t} else {\n\t\t\t\t    LogUtils.debugf(this, \"run: start collection for %d VLAN entries\", getVlanTable().getEntries().size());\n\n\t\t\t\t\tfor (final SnmpStore ent : m_vlanTable.getEntries()) {\n\t\t \t\t\t\tint vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);\n\t\t\t\t\t\tif (vlanindex == -1) {\n\t\t\t\t\t\t    LogUtils.debugf(this, \"run: found null value for VLAN.\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);\n\t\t\t\t\t\tif (vlanname == null) vlanname = DEFAULT_VLAN_NAME; \n\t\t\t\t\t\tInteger status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);\n\n\t\t\t\t\t\tif (status == null || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {\n\t\t\t\t\t\t    LogUtils.infof(this, \"run: skipping VLAN %s: NOT ACTIVE or null\", vlan);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString community = m_agentConfig.getReadCommunity();\n\t\t\t\t\t\tLogUtils.debugf(this, \"run: peer community: %s with VLAN %s\", community, vlan);\n\n\t\t\t\t\t\tInteger type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);\n\t\t\t\t\t\tif (type == null || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {\n\t\t\t\t\t\t    LogUtils.infof(this, \"run: skipping VLAN %s NOT ETHERNET TYPE\", vlan);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm_agentConfig.setReadCommunity(community + \"@\" + vlanindex);\n\n\t\t\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(vlanindex,vlanname,status));\n\t\t\t\t\t\tm_agentConfig.setReadCommunity(community);\n\t\t\t\t\t}  \n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\trunAndSaveSnmpVlanCollection(new OnmsVlan(DEFAULT_VLAN_INDEX,DEFAULT_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));\n\t\t\t}\n\t\t\t// update info in linkd used correctly by {@link DiscoveryLink}\n\t\t\tLogUtils.debugf(this, \"run: saving collection into database for %s\", str(m_agentConfig.getAddress()));\n\n\t\t\tm_linkd.updateNodeSnmpCollection(this);\n\t\t\t// clean memory\n\t\t\t// first make everything clean\n\t\t\tm_ipNetToMedia = null;\n\t\t\tm_ipRoute = null;\n\t\t\tm_CdpCache = null;\n\t\t\tm_vlanTable = null;\n\t\t\tm_snmpVlanCollection.clear();\n\t\t}\n\n\t\t// reschedule itself\n\t\treschedule();\n\t\trunned = true;\n\t}","commit_id":"0ceac1fde87cffb318a646991c87c1358ff340fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getIpAddress() {\n            final SnmpResult result = getResult(IP_ADDRESS_IF_INDEX);\n            SnmpInstId instance = result.getInstance();\n            final int[] instanceIds = instance.getIds();\n\n            final int addressType = instanceIds[0];\n            int addressIndex = 2;\n            int addressLength = instanceIds[1];\n            // Begin NMS-4906 Lame Force 10 agent!\n            if (addressType == TYPE_IPV4 && instanceIds.length != 6) {\n                LogUtils.warnf(this, \"BAD AGENT: Does not conform to RFC 4001 Section 4.1 Table Indexing!!! Report them immediately.  Making a best guess!\");\n                addressIndex = instanceIds.length - 4;\n                addressLength = 4;\n            }\n            if (addressType == TYPE_IPV6 && instanceIds.length != 18) {\n                LogUtils.warnf(this, \"BAD AGENT: Does not conform to RFC 4001 Section 4.1 Table Indexing!!! Report them immediately.  Making a best guess!\");\n                addressIndex = instanceIds.length - 16;\n                addressLength = 16;\n            }\n            // End NMS-4906 Lame Force 10 agent!\n\n            if (addressIndex < 0 || addressIndex + addressLength > instanceIds.length) {\n                LogUtils.warnf(this, \"BAD AGENT: Returned instanceId %s does not enough bytes to contain address!. Skipping.\", instance);\n                return null;\n            }\n\n            if (addressType == TYPE_IPV4 || addressType == TYPE_IPV6) {\n                final InetAddress address = getInetAddress(instanceIds, addressIndex, addressLength);\n                return str(address);\n            }\n            return null;\n        }","id":66282,"modified_method":"public String getIpAddress() {\n            final SnmpResult result = getResult(IP_ADDRESS_IF_INDEX);\n            SnmpInstId instance = result.getInstance();\n            final int[] instanceIds = instance.getIds();\n\n            final int addressType = instanceIds[0];\n            int addressIndex = 2;\n            int addressLength = instanceIds[1];\n            // Begin NMS-4906 Lame Force 10 agent!\n            if (addressType == TYPE_IPV4 && instanceIds.length != 6) {\n                LogUtils.warnf(this, \"BAD AGENT: Does not conform to RFC 4001 Section 4.1 Table Indexing!!! Report them immediately.  Making a best guess!\");\n                addressIndex = instanceIds.length - 4;\n                addressLength = 4;\n            }\n            if (addressType == TYPE_IPV6 && instanceIds.length != 18) {\n                LogUtils.warnf(this, \"BAD AGENT: Does not conform to RFC 4001 Section 4.1 Table Indexing!!! Report them immediately.  Making a best guess!\");\n                addressIndex = instanceIds.length - 16;\n                addressLength = 16;\n            }\n            // End NMS-4906 Lame Force 10 agent!\n\n            if (addressIndex < 0 || addressIndex + addressLength > instanceIds.length) {\n                LogUtils.warnf(this, \"BAD AGENT: Returned instanceId %s does not enough bytes to contain address!. Skipping.\", instance);\n                return null;\n            }\n\n            if (addressType == TYPE_IPV4 || addressType == TYPE_IPV6 || addressType == TYPE_IPV6Z) {\n                final InetAddress address = getInetAddress(instanceIds, addressIndex, addressLength);\n                return str(address);\n            }\n            return null;\n        }","commit_id":"cfc0adb4a1658c00b8843dc983bd7f8d25b9accd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a hack, we get the IP address from the instance information when storing one of the columns.  :P\n     */\n    public void storeResult(final SnmpResult result) {\n    \tfinal int[] instanceIds = result.getInstance().getIds();\n    \tfinal int addressType = instanceIds[1];\n\t\tif (addressType == IPAddressTableTracker.TYPE_IPV4 || addressType == IPAddressTableTracker.TYPE_IPV6) {\n\t\t\tm_inetAddress = InetAddressUtils.getInetAddress(instanceIds, 2, addressType);\n\t\t} else {\n\t\t\tLogUtils.warnf(this, \"Unable to determine IP address type (%d)\", addressType);\n\t\t}\n\n    \tsuper.storeResult(result);\n    }","id":66283,"modified_method":"/**\n     * This is a hack, we get the IP address from the instance information when storing one of the columns.  :P\n     */\n    public void storeResult(final SnmpResult result) {\n    \tfinal int[] instanceIds = result.getInstance().getIds();\n    \tfinal int addressType = instanceIds[1];\n\t\tif (addressType == IPAddressTableTracker.TYPE_IPV4 || addressType == IPAddressTableTracker.TYPE_IPV6 || addressType == IPAddressTableTracker.TYPE_IPV6Z) {\n\t\t\tm_inetAddress = InetAddressUtils.getInetAddress(instanceIds, 2, addressType);\n\t\t} else {\n\t\t\tLogUtils.warnf(this, \"Unable to determine IP address type (%d)\", addressType);\n\t\t}\n\n    \tsuper.storeResult(result);\n    }","commit_id":"cfc0adb4a1658c00b8843dc983bd7f8d25b9accd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getIpAdEntNetMask<\/p>\n     *\n     * @return a {@link java.net.InetAddress} object.\n     */\n    public InetAddress getIpAddressNetMask() {\n    \tfinal SnmpValue value = getValue(IP_ADDR_ENT_NETMASK);\n    \t// LogUtils.debugf(this, \"getIpAddressNetMask: value = %s\", value.toDisplayString());\n    \tfinal SnmpObjId netmaskRef = value.toSnmpObjId().getInstance(IPAddressTableTracker.IP_ADDRESS_PREFIX_ORIGIN_INDEX);\n    \t\n    \tfinal int[] rawIds = netmaskRef.getIds();\n    \tfinal int addressType = rawIds[1];\n    \tfinal int addressLength = rawIds[2];\n    \tfinal InetAddress address = getInetAddress(rawIds, 3, addressLength);\n    \tfinal int mask = rawIds[rawIds.length - 1];\n\n    \tif (addressType == IPAddressTableTracker.TYPE_IPV4) {\n    \t    return InetAddressUtils.convertCidrToInetAddressV4(mask);\n    \t} else if (addressType == IPAddressTableTracker.TYPE_IPV6) {\n    \t    return InetAddressUtils.convertCidrToInetAddressV6(mask);\n    \t} else {\n    \t    LogUtils.warnf(this, \"unknown address type, expected 1 (IPv4) or 2 (IPv6), but got %d\", addressType);\n    \t    return null;\n    \t}\n    }","id":66284,"modified_method":"/**\n     * <p>getIpAdEntNetMask<\/p>\n     *\n     * @return a {@link java.net.InetAddress} object.\n     */\n    public InetAddress getIpAddressNetMask() {\n    \tfinal SnmpValue value = getValue(IP_ADDR_ENT_NETMASK);\n    \t// LogUtils.debugf(this, \"getIpAddressNetMask: value = %s\", value.toDisplayString());\n    \tfinal SnmpObjId netmaskRef = value.toSnmpObjId().getInstance(IPAddressTableTracker.IP_ADDRESS_PREFIX_ORIGIN_INDEX);\n\n    \tif (netmaskRef == null) {\n    \t    LogUtils.warnf(this, \"Unable to get netmask reference from instance.\");\n    \t    return null;\n    \t}\n\n    \tfinal int[] rawIds = netmaskRef.getIds();\n    \tfinal int addressType = rawIds[1];\n    \tfinal int addressLength = rawIds[2];\n    \tfinal InetAddress address = getInetAddress(rawIds, 3, addressLength);\n    \tfinal int mask = rawIds[rawIds.length - 1];\n\n    \tif (addressType == IPAddressTableTracker.TYPE_IPV4) {\n    \t    return InetAddressUtils.convertCidrToInetAddressV4(mask);\n    \t} else if (addressType == IPAddressTableTracker.TYPE_IPV6) {\n    \t    return InetAddressUtils.convertCidrToInetAddressV6(mask);\n    \t} else if (addressType == IPAddressTableTracker.TYPE_IPV6Z) {\n    \t    LogUtils.debugf(this, \"Got an IPv6z address, returning %s\", address);\n    \t} else {\n    \t    LogUtils.warnf(this, \"Unsure how to handle IP address type (%d)\", addressType);\n    \t}\n        return address;\n    }","commit_id":"cfc0adb4a1658c00b8843dc983bd7f8d25b9accd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public void disposeComponent() {\n    try {\n      myInternalKeyEnumerator.close();\n      myPackageEnumerator.close();\n      myNamesEnumerator.close();\n      myCompoundKeyEnumerator.close();\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":66285,"modified_method":"@Override\n  public void disposeComponent() {\n    try {\n      myPackageEnumerator.close();\n      myNamesEnumerator.close();\n      myCompoundKeyEnumerator.close();\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean writeType(int[] compoundKey, int i, PsiType psiType) throws IOException {\n    int dimensions = 0;\n    psiType = TypeConversionUtil.erasure(psiType);\n    if (psiType instanceof PsiArrayType) {\n      PsiArrayType arrayType = (PsiArrayType)psiType;\n      psiType = arrayType.getDeepComponentType();\n      dimensions = arrayType.getArrayDimensions();\n    }\n\n    if (psiType instanceof PsiClassType) {\n      PsiClass psiClass = ((PsiClassType)psiType).resolve();\n      if (psiClass != null) {\n        writeClass(compoundKey, i, psiClass, dimensions);\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n    else if (psiType instanceof PsiPrimitiveType) {\n      String packageName = \"\";\n      String className = psiType.getPresentableText();\n      compoundKey[i] = myPackageEnumerator.enumerate(packageName);\n      compoundKey[i + 1] = myNamesEnumerator.enumerate(className);\n      return true;\n    }\n    return false;\n  }","id":66286,"modified_method":"private boolean writeType(int[] compoundKey, int i, PsiType psiType) throws IOException {\n    int dimensions = 0;\n    psiType = TypeConversionUtil.erasure(psiType);\n    if (psiType instanceof PsiArrayType) {\n      PsiArrayType arrayType = (PsiArrayType)psiType;\n      psiType = arrayType.getDeepComponentType();\n      dimensions = arrayType.getArrayDimensions();\n    }\n\n    if (psiType instanceof PsiClassType) {\n      // no resolve() -> no package/class split\n      PsiClass psiClass = ((PsiClassType)psiType).resolve();\n      if (psiClass != null) {\n        writeClass(compoundKey, i, psiClass, dimensions);\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n    else if (psiType instanceof PsiPrimitiveType) {\n      String packageName = \"\";\n      String className = psiType.getPresentableText();\n      compoundKey[i] = myPackageEnumerator.enumerate(packageName);\n      if (dimensions == 0) {\n        compoundKey[i + 1] = myNamesEnumerator.enumerate(className);\n      } else {\n        StringBuilder sb = new StringBuilder(className);\n        for (int j = 0; j < dimensions; j++) {\n          sb.append(\"[]\");\n        }\n        compoundKey[i + 1] = myNamesEnumerator.enumerate(sb.toString());\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void initComponent() {\n    try {\n      File keysDir = new File(PathManager.getIndexRoot(), \"bytecodeKeys\");\n      final File internalKeysFile = new File(keysDir, \"faba.internalIds\");\n      final File packageKeysFile = new File(keysDir, \"faba.packages\");\n      final File namesFile = new File(keysDir, \"faba.names1\");\n      final File compoundKeysFile = new File(keysDir, \"faba.keys\");\n      myInternalKeyEnumerator = new PersistentStringEnumerator(internalKeysFile);\n      myPackageEnumerator = new PersistentStringEnumerator(packageKeysFile);\n      myNamesEnumerator = new PersistentStringEnumerator(namesFile);\n      myCompoundKeyEnumerator = new PersistentEnumeratorDelegate<int[]>(compoundKeysFile, new IntArrayKeyDescriptor(), 1024 * 4);\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":66287,"modified_method":"@Override\n  public void initComponent() {\n    try {\n      File keysDir = new File(PathManager.getIndexRoot(), \"bytecodeKeys\");\n      final File packageKeysFile = new File(keysDir, \"packages\");\n      final File namesFile = new File(keysDir, \"names\");\n      final File compoundKeysFile = new File(keysDir, \"compound\");\n      myPackageEnumerator = new PersistentStringEnumerator(packageKeysFile);\n      myNamesEnumerator = new PersistentStringEnumerator(namesFile);\n      myCompoundKeyEnumerator = new PersistentEnumeratorDelegate<int[]>(compoundKeysFile, new IntArrayKeyDescriptor(), 1024 * 4);\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MostlySingularMultiMap<String, AnnotationData> makeAnnotations(TIntObjectHashMap<Value> internalIdSolutions) {\n    MostlySingularMultiMap<String, AnnotationData> annotations = new MostlySingularMultiMap<String, AnnotationData>();\n    HashMap<String, StringBuilder> contracts = new HashMap<String, StringBuilder>();\n    TIntObjectIterator<Value> iterator = internalIdSolutions.iterator();\n    for (int i = internalIdSolutions.size(); i-- > 0;) {\n      iterator.advance();\n      int inKey = iterator.key();\n      Value value = iterator.value();\n      if (value == Value.Top || value == Value.Bot) {\n        continue;\n      }\n      InternalKey key;\n      try {\n        String s = myInternalKeyEnumerator.valueOf(inKey);\n        key = readInternalKey(s);\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n\n      if (key != null) {\n        Direction direction = key.dir;\n        String baseAnnKey = key.annotationKey;\n\n        if (direction instanceof In && value == Value.NotNull) {\n          String annKey = baseAnnKey + \" \" + ((In)direction).paramIndex;\n          // TODO - here\n          annotations.add(annKey, new AnnotationData(\"org.jetbrains.annotations.NotNull\", \"\"));\n        }\n        else if (direction instanceof Out && value == Value.NotNull) {\n          // TODO - here\n          annotations.add(baseAnnKey, new AnnotationData(\"org.jetbrains.annotations.NotNull\", \"\"));\n        }\n        // TODO - sort (normalize) contract clauses\n        else if (direction instanceof InOut) {\n          StringBuilder sb = contracts.get(baseAnnKey);\n          if (sb == null) {\n            sb = new StringBuilder(\"\\\"\");\n            contracts.put(baseAnnKey, sb);\n          }\n          else {\n            sb.append(';');\n          }\n          contractElement(sb, calculateArity(baseAnnKey), (InOut)direction, value);\n        }\n      }\n    }\n\n    for (Map.Entry<String, StringBuilder> contract : contracts.entrySet()) {\n      if (!annotations.containsKey(contract.getKey())) {\n        annotations.add(contract.getKey(), new AnnotationData(\"org.jetbrains.annotations.Contract\", contract.getValue().append('\"').toString()));\n      }\n    }\n    return annotations;\n  }","id":66288,"modified_method":"public Annotations makeAnnotations(TIntObjectHashMap<Value> internalIdSolutions) {\n    final TIntObjectHashMap<AnnotationData> outs = new TIntObjectHashMap<AnnotationData>();\n    final TIntObjectHashMap<AnnotationData> params = new TIntObjectHashMap<AnnotationData>();\n    final TIntObjectHashMap<AnnotationData> contracts = new TIntObjectHashMap<AnnotationData>();\n\n    TIntObjectHashMap<StringBuilder> contractBuilders = new TIntObjectHashMap<StringBuilder>();\n    TIntObjectIterator<Value> solutionsIterator = internalIdSolutions.iterator();\n\n    for (int i = internalIdSolutions.size(); i-- > 0;) {\n      solutionsIterator.advance();\n      int key = solutionsIterator.key();\n      Value value = solutionsIterator.value();\n      if (value == Value.Top || value == Value.Bot) {\n        continue;\n      }\n      int[] compoundKey = null;\n      try {\n        compoundKey = myCompoundKeyEnumerator.valueOf(key);\n      }\n      catch (IOException e) {\n        // TODO: question: how to react?\n      }\n\n      if (compoundKey != null) {\n        Direction direction = extractDirection(compoundKey);\n\n        if (direction instanceof In && value == Value.NotNull) {\n          params.put(key, new AnnotationData(\"org.jetbrains.annotations.NotNull\", \"\"));\n        }\n        else if (direction instanceof Out && value == Value.NotNull) {\n          outs.put(key, new AnnotationData(\"org.jetbrains.annotations.NotNull\", \"\"));\n        }\n        else if (direction instanceof InOut) {\n          compoundKey[0] = 0;\n          compoundKey[1] = 0;\n          compoundKey[2] = 0;\n          try {\n            // TODO - sort (normalize) contract clauses\n            int baseKey = myCompoundKeyEnumerator.enumerate(compoundKey);\n            StringBuilder sb = contractBuilders.get(baseKey);\n            if (sb == null) {\n              sb = new StringBuilder(\"\\\"\");\n              contractBuilders.put(baseKey, sb);\n            }\n            else {\n              sb.append(';');\n            }\n            int arity = compoundKey[8];\n            contractElement(sb, arity, (InOut)direction, value);\n          }\n          catch (IOException e) {\n            // TODO: question: how to react?\n          }\n        }\n      }\n    }\n\n    TIntObjectIterator<StringBuilder> buildersIterator = contractBuilders.iterator();\n    for (int i = contractBuilders.size(); i-- > 0;) {\n      buildersIterator.advance();\n      int key = buildersIterator.key();\n      StringBuilder value = buildersIterator.value();\n      if (!outs.contains(key)) {\n        contracts.put(key, new AnnotationData(\"org.jetbrains.annotations.Contract\", value.append('\"').toString()));\n      }\n    }\n\n    return new Annotations(outs, params, contracts);\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String showCompoundKey(@NotNull int[] key) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(key[0]);\n    sb.append(\", \");\n    sb.append(key[1]);\n    sb.append(\", \");\n    sb.append(key[2]);\n    sb.append(\", \");\n    sb.append(myPackageEnumerator.valueOf(key[3]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[4]));\n    sb.append(\", \");\n    sb.append(myPackageEnumerator.valueOf(key[5]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[6]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[7]));\n    sb.append(\", \");\n    sb.append(key[8]);\n    sb.append(\", \");\n\n    for (int i = 0; i < key[8]; i++) {\n      sb.append(myPackageEnumerator.valueOf(key[9 + 2*i]));\n      sb.append(\", \");\n      sb.append(myNamesEnumerator.valueOf(key[9 + 2*i + 1]));\n      sb.append(\", \");\n\n    }\n    return sb.toString();\n  }","id":66289,"modified_method":"public String debugCompoundKey(@NotNull int[] key) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(key[0]);\n    sb.append(\", \");\n    sb.append(key[1]);\n    sb.append(\", \");\n    sb.append(key[2]);\n    sb.append(\", \");\n    sb.append(myPackageEnumerator.valueOf(key[3]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[4]));\n    sb.append(\", \");\n    sb.append(myPackageEnumerator.valueOf(key[5]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[6]));\n    sb.append(\", \");\n    sb.append(myNamesEnumerator.valueOf(key[7]));\n    sb.append(\", \");\n    sb.append(key[8]);\n    sb.append(\", \");\n\n    for (int i = 0; i < key[8]; i++) {\n      sb.append(myPackageEnumerator.valueOf(key[9 + 2*i]));\n      sb.append(\", \");\n      sb.append(myNamesEnumerator.valueOf(key[9 + 2*i + 1]));\n      sb.append(\", \");\n\n    }\n    return sb.toString();\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"IntIdEquation convert(Equation<Key, Value> equation) throws IOException {\n    Result<Key, Value> rhs = equation.rhs;\n    IntIdResult result;\n    if (rhs instanceof Final) {\n      result = new IntIdFinal(((Final<Key, Value>)rhs).value);\n    } else {\n      Pending<Key, Value> pending = (Pending<Key, Value>)rhs;\n      Set<Set<Key>> deltaOrig = pending.delta;\n      IntIdComponent[] components = new IntIdComponent[deltaOrig.size()];\n      int componentI = 0;\n      for (Set<Key> keyComponent : deltaOrig) {\n        int[] ids = new int[keyComponent.size()];\n        int idI = 0;\n        for (Key id : keyComponent) {\n          // TODO refactor here\n          ids[idI] = myInternalKeyEnumerator.enumerate(internalKeyString(id));\n          idI++;\n        }\n        IntIdComponent intIdComponent = new IntIdComponent(ids);\n        components[componentI] = intIdComponent;\n        componentI++;\n      }\n      result = new IntIdPending(pending.infinum, components);\n    }\n    int key = myInternalKeyEnumerator.enumerate(internalKeyString(equation.id));\n    return new IntIdEquation(key, result);\n  }","id":66290,"modified_method":"IntIdEquation convert(Equation<Key, Value> equation) throws IOException {\n    Result<Key, Value> rhs = equation.rhs;\n    IntIdResult result;\n    if (rhs instanceof Final) {\n      result = new IntIdFinal(((Final<Key, Value>)rhs).value);\n    } else {\n      Pending<Key, Value> pending = (Pending<Key, Value>)rhs;\n      Set<Set<Key>> deltaOrig = pending.delta;\n      IntIdComponent[] components = new IntIdComponent[deltaOrig.size()];\n      int componentI = 0;\n      for (Set<Key> keyComponent : deltaOrig) {\n        int[] ids = new int[keyComponent.size()];\n        int idI = 0;\n        for (Key id : keyComponent) {\n          int[] compoundKey = mkCompoundKey(id);\n          ids[idI] = myCompoundKeyEnumerator.enumerate(compoundKey);\n          idI++;\n        }\n        IntIdComponent intIdComponent = new IntIdComponent(ids);\n        components[componentI] = intIdComponent;\n        componentI++;\n      }\n      result = new IntIdPending(pending.infinum, components);\n    }\n\n    int key = myCompoundKeyEnumerator.enumerate(mkCompoundKey(equation.id));\n    return new IntIdEquation(key, result);\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public int[] mkCompoundKey(@NotNull Key key) throws IOException {\n    Direction direction = key.direction;\n    Method method = key.method;\n\n    Type ownerType = Type.getType(method.internalClassName);\n    Type[] argTypes = Type.getArgumentTypes(method.methodDesc);\n    Type returnType = Type.getReturnType(method.methodDesc);\n\n    int arity = argTypes.length;\n    int[] compoundKey = new int[9 + arity * 2];\n\n    compoundKey[0] = direction.directionId();\n    compoundKey[1] = direction.paramId();\n    compoundKey[2] = direction.valueId();\n    writeType(compoundKey, 3, ownerType);\n    writeType(compoundKey, 5, returnType);\n    compoundKey[7] = myNamesEnumerator.enumerate(method.methodName);\n    compoundKey[8] = argTypes.length;\n\n    for (int i = 0; i < argTypes.length; i++) {\n      writeType(compoundKey, 9 + 2*i, argTypes[i]);\n    }\n    return compoundKey;\n  }","id":66291,"modified_method":"@NotNull\n  public int[] mkCompoundKey(@NotNull Key key) throws IOException {\n    Direction direction = key.direction;\n    Method method = key.method;\n\n    Type ownerType = Type.getObjectType(method.internalClassName);\n    Type[] argTypes = Type.getArgumentTypes(method.methodDesc);\n    Type returnType = Type.getReturnType(method.methodDesc);\n\n    int arity = argTypes.length;\n    int[] compoundKey = new int[9 + arity * 2];\n\n    compoundKey[0] = direction.directionId();\n    compoundKey[1] = direction.paramId();\n    compoundKey[2] = direction.valueId();\n    writeType(compoundKey, 3, ownerType);\n    writeType(compoundKey, 5, returnType);\n    compoundKey[7] = myNamesEnumerator.enumerate(method.methodName);\n    compoundKey[8] = argTypes.length;\n\n    for (int i = 0; i < argTypes.length; i++) {\n      writeType(compoundKey, 9 + 2*i, argTypes[i]);\n    }\n    return compoundKey;\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCompoundId(Method method, PsiMethod psiMethod, boolean noKey) throws IOException {\n    Direction direction = new Out();\n    int[] psiKey = myBytecodeAnalysisConverter.mkCompoundKey(psiMethod, direction);\n    if (noKey) {\n      assertNull(psiKey);\n      return;\n    }\n    else {\n      assertNotNull(psiKey);\n    }\n\n    int[] asmKey = myBytecodeAnalysisConverter.mkCompoundKey(new Key(method, direction));\n\n    System.out.println(Arrays.toString(asmKey));\n    System.out.println(Arrays.toString(psiKey));\n\n    System.out.println(myBytecodeAnalysisConverter.showCompoundKey(asmKey));\n    System.out.println(myBytecodeAnalysisConverter.showCompoundKey(psiKey));\n\n    Assert.assertArrayEquals(asmKey, psiKey);\n  }","id":66292,"modified_method":"private void checkCompoundId(Method method, PsiMethod psiMethod, boolean noKey) throws IOException {\n    Direction direction = new Out();\n    int[] psiKey = myBytecodeAnalysisConverter.mkCompoundKey(psiMethod, direction);\n    if (noKey) {\n      assertNull(psiKey);\n      return;\n    }\n    else {\n      assertNotNull(psiKey);\n    }\n\n    int[] asmKey = myBytecodeAnalysisConverter.mkCompoundKey(new Key(method, direction));\n\n    System.out.println(Arrays.toString(asmKey));\n    System.out.println(Arrays.toString(psiKey));\n\n    System.out.println(myBytecodeAnalysisConverter.debugCompoundKey(asmKey));\n    System.out.println(myBytecodeAnalysisConverter.debugCompoundKey(psiKey));\n\n    Assert.assertArrayEquals(asmKey, psiKey);\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myJavaPsiFacade = JavaPsiFacade.getInstance(myModule.getProject());\n    myInferredAnnotationsManager = InferredAnnotationsManager.getInstance(myModule.getProject());\n    myBytecodeAnalysisConverter = BytecodeAnalysisConverter.getInstance();\n\n    setUpDataClasses();\n  }","id":66293,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myJavaPsiFacade = JavaPsiFacade.getInstance(myModule.getProject());\n    myInferredAnnotationsManager = InferredAnnotationsManager.getInstance(myModule.getProject());\n    myBytecodeAnalysisConverter = BytecodeAnalysisConverter.getInstance();\n\n    setUpDataClasses();\n    setUpVelocityLibrary();\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkAnnotations(Class<?> javaClass) {\n    PsiClass psiClass = myJavaPsiFacade.findClass(javaClass.getName(), GlobalSearchScope.moduleWithLibrariesScope(myModule));\n    assertNotNull(psiClass);\n\n    for (java.lang.reflect.Method javaMethod : javaClass.getDeclaredMethods()) {\n      PsiMethod psiMethod = psiClass.findMethodsByName(javaMethod.getName(), false)[0];\n      Annotation[][] annotations = javaMethod.getParameterAnnotations();\n\n      // not-null parameters\n      params: for (int i = 0; i < annotations.length; i++) {\n        Annotation[] parameterAnnotations = annotations[i];\n        PsiParameter psiParameter = psiMethod.getParameterList().getParameters()[i];\n        PsiAnnotation inferredAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiParameter, AnnotationUtil.NOT_NULL);\n        for (int j = 0; j < parameterAnnotations.length; j++) {\n          Annotation parameterAnnotation = parameterAnnotations[j];\n          if (parameterAnnotation.annotationType() == ExpectNotNull.class) {\n            assertNotNull(inferredAnnotation);\n            continue params;\n          }\n        }\n        assertNull(inferredAnnotation);\n      }\n\n      // not-null result\n      ExpectNotNull expectedAnnotation = javaMethod.getAnnotation(ExpectNotNull.class);\n      PsiAnnotation actualAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiMethod, AnnotationUtil.NOT_NULL);\n      assertEquals(expectedAnnotation == null, actualAnnotation == null);\n\n      // contracts\n      ExpectContract expectedContract = javaMethod.getAnnotation(ExpectContract.class);\n      PsiAnnotation actualContractAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiMethod, ORG_JETBRAINS_ANNOTATIONS_CONTRACT);\n\n      assertEquals(expectedContract == null, actualContractAnnotation == null);\n\n      if (expectedAnnotation != null) {\n        String expectedContractValue = expectedContract.value();\n        String actualContractValue = AnnotationUtil.getStringAttributeValue(actualContractAnnotation, null);\n        assertEquals(expectedContractValue, actualContractValue);\n      }\n    }\n  }","id":66294,"modified_method":"private void checkAnnotations(Class<?> javaClass) {\n    PsiClass psiClass = myJavaPsiFacade.findClass(javaClass.getName(), GlobalSearchScope.moduleWithLibrariesScope(myModule));\n    assertNotNull(psiClass);\n\n    for (java.lang.reflect.Method javaMethod : javaClass.getDeclaredMethods()) {\n      PsiMethod psiMethod = psiClass.findMethodsByName(javaMethod.getName(), false)[0];\n      Annotation[][] annotations = javaMethod.getParameterAnnotations();\n\n      // not-null parameters\n      params: for (int i = 0; i < annotations.length; i++) {\n        Annotation[] parameterAnnotations = annotations[i];\n        PsiParameter psiParameter = psiMethod.getParameterList().getParameters()[i];\n        PsiAnnotation inferredAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiParameter, AnnotationUtil.NOT_NULL);\n        for (Annotation parameterAnnotation : parameterAnnotations) {\n          if (parameterAnnotation.annotationType() == ExpectNotNull.class) {\n            assertNotNull(inferredAnnotation);\n            continue params;\n          }\n        }\n        assertNull(inferredAnnotation);\n      }\n\n      // not-null result\n      ExpectNotNull expectedAnnotation = javaMethod.getAnnotation(ExpectNotNull.class);\n      PsiAnnotation actualAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiMethod, AnnotationUtil.NOT_NULL);\n      assertEquals(expectedAnnotation == null, actualAnnotation == null);\n\n      // contracts\n      ExpectContract expectedContract = javaMethod.getAnnotation(ExpectContract.class);\n      PsiAnnotation actualContractAnnotation = myInferredAnnotationsManager.findInferredAnnotation(psiMethod, ORG_JETBRAINS_ANNOTATIONS_CONTRACT);\n\n      assertEquals(expectedContract == null, actualContractAnnotation == null);\n\n      if (expectedContract != null) {\n        String expectedContractValue = expectedContract.value();\n        String actualContractValue = AnnotationUtil.getStringAttributeValue(actualContractAnnotation, null);\n        assertEquals(expectedContractValue, actualContractValue);\n      }\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCompoundIds(Class<?> javaClass) throws IOException {\n    String javaClassName = javaClass.getCanonicalName();\n    System.out.println(javaClassName);\n    PsiClass psiClass = myJavaPsiFacade.findClass(javaClassName, GlobalSearchScope.moduleWithLibrariesScope(myModule));\n    assertNotNull(psiClass);\n\n    for (java.lang.reflect.Method javaMethod : javaClass.getDeclaredMethods()) {\n      System.out.println(javaMethod.getName());\n      Method method = new Method(Type.getDescriptor(javaClass), javaMethod.getName(), Type.getMethodDescriptor(javaMethod));\n      boolean noKey = javaMethod.getAnnotation(ExpectNoPsiKey.class) != null;\n      PsiMethod psiMethod = psiClass.findMethodsByName(javaMethod.getName(), false)[0];\n      checkCompoundId(method, psiMethod, noKey);\n    }\n\n    for (Constructor<?> constructor : javaClass.getDeclaredConstructors()) {\n      Method method = new Method(Type.getDescriptor(javaClass), \"<init>\", Type.getConstructorDescriptor(constructor));\n      boolean noKey = constructor.getAnnotation(ExpectNoPsiKey.class) != null;\n      PsiMethod[] constructors = psiClass.getConstructors();\n      PsiMethod psiMethod = constructors[0];\n      checkCompoundId(method, psiMethod, noKey);\n    }\n  }","id":66295,"modified_method":"private void checkCompoundIds(Class<?> javaClass) throws IOException {\n    String javaClassName = javaClass.getCanonicalName();\n    System.out.println(javaClassName);\n    PsiClass psiClass = myJavaPsiFacade.findClass(javaClassName, GlobalSearchScope.moduleWithLibrariesScope(myModule));\n    assertNotNull(psiClass);\n\n    for (java.lang.reflect.Method javaMethod : javaClass.getDeclaredMethods()) {\n      System.out.println(javaMethod.getName());\n      Method method = new Method(Type.getType(javaClass).getInternalName(), javaMethod.getName(), Type.getMethodDescriptor(javaMethod));\n      boolean noKey = javaMethod.getAnnotation(ExpectNoPsiKey.class) != null;\n      PsiMethod psiMethod = psiClass.findMethodsByName(javaMethod.getName(), false)[0];\n      checkCompoundId(method, psiMethod, noKey);\n    }\n\n    for (Constructor<?> constructor : javaClass.getDeclaredConstructors()) {\n      Method method = new Method(Type.getType(javaClass).getInternalName(), \"<init>\", Type.getConstructorDescriptor(constructor));\n      boolean noKey = constructor.getAnnotation(ExpectNoPsiKey.class) != null;\n      PsiMethod[] constructors = psiClass.getConstructors();\n      PsiMethod psiMethod = constructors[0];\n      checkCompoundId(method, psiMethod, noKey);\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiAnnotation[] findInferredAnnotations(@NotNull PsiModifierListOwner listOwner) {\n    List<AnnotationData> result = collectInferredAnnotations(listOwner);\n    if (result == null || result.isEmpty()) return null;\n    PsiAnnotation[] myResult = ContainerUtil.map2Array(result, PsiAnnotation.EMPTY_ARRAY, new Function<AnnotationData, PsiAnnotation>() {\n      @Override\n      public PsiAnnotation fun(AnnotationData data) {\n        return data.getAnnotation(ProjectBytecodeAnalysis.this);\n      }\n    });\n    String key = getExternalName(listOwner);\n    LOG.info(\"annotations: \" + key + \" \" + result);\n    return myResult;\n  }","id":66296,"modified_method":"@Nullable\n  public PsiAnnotation[] findInferredAnnotations(@NotNull PsiModifierListOwner listOwner) {\n    List<AnnotationData> result = collectInferredAnnotations(listOwner);\n    if (result == null || result.isEmpty()) return null;\n    return ContainerUtil.map2Array(result, PsiAnnotation.EMPTY_ARRAY, new Function<AnnotationData, PsiAnnotation>() {\n      @Override\n      public PsiAnnotation fun(AnnotationData data) {\n        return data.getAnnotation(ProjectBytecodeAnalysis.this);\n      }\n    });\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void loadAnnotations() {\n    LOG.info(\"initializing annotations\");\n    final IntIdSolver solver = new IntIdSolver();\n    FileBasedIndex.getInstance().processValues(\n      BytecodeAnalysisIndex.NAME, BytecodeAnalysisIndex.KEY, null, new FileBasedIndex.ValueProcessor<Collection<IntIdEquation>>() {\n        @Override\n        public boolean process(VirtualFile file, Collection<IntIdEquation> value) {\n          for (IntIdEquation intIdEquation : value) {\n            solver.addEquation(intIdEquation);\n          }\n          return true;\n        }\n      }, ProjectScope.getLibrariesScope(myProject));\n    LOG.info(\"equations are constructed\");\n    TIntObjectHashMap<Value> solutions = solver.solve();\n    LOG.info(\"equations are solved\");\n    myAnnotations = BytecodeAnalysisConverter.getInstance().makeAnnotations(solutions);\n    LOG.info(\"initialized \" + myAnnotations.size());\n  }","id":66297,"modified_method":"private void loadAnnotations() {\n    LOG.info(\"initializing annotations\");\n    final IntIdSolver solver = new IntIdSolver();\n    FileBasedIndex.getInstance().processValues(\n      BytecodeAnalysisIndex.NAME, BytecodeAnalysisIndex.KEY, null, new FileBasedIndex.ValueProcessor<Collection<IntIdEquation>>() {\n        @Override\n        public boolean process(VirtualFile file, Collection<IntIdEquation> value) {\n          for (IntIdEquation intIdEquation : value) {\n            solver.addEquation(intIdEquation);\n          }\n          return true;\n        }\n      }, ProjectScope.getLibrariesScope(myProject));\n    LOG.info(\"equations are constructed\");\n    TIntObjectHashMap<Value> solutions = solver.solve();\n    LOG.info(\"equations are solved\");\n    myAnnotations = BytecodeAnalysisConverter.getInstance().makeAnnotations(solutions);\n    LOG.info(\"initialized \");\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized List<AnnotationData> collectInferredAnnotations(PsiModifierListOwner listOwner) {\n    String key = getExternalName(listOwner);\n    if (key == null) {\n      return NO_DATA;\n    }\n    SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n\n    if (myAnnotations == null) {\n      loadAnnotations();\n    }\n\n    Iterable<AnnotationData> inferred = myAnnotations.get(key);\n    ContainerUtil.addAll(result, inferred);\n    return result;\n  }","id":66298,"modified_method":"private synchronized List<AnnotationData> collectInferredAnnotations(PsiModifierListOwner listOwner) {\n    if (myAnnotations == null) {\n      loadAnnotations();\n    }\n    try {\n      int key = getKey(listOwner);\n      if (key == -1) {\n        return NO_DATA;\n      }\n      SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n      ContainerUtil.addIfNotNull(result, myAnnotations.contracts.get(key));\n      ContainerUtil.addIfNotNull(result, myAnnotations.outs.get(key));\n      ContainerUtil.addIfNotNull(result, myAnnotations.params.get(key));\n      return result;\n    }\n    catch (IOException e) {\n      return NO_DATA;\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiAnnotation findInferredAnnotation(@NotNull PsiModifierListOwner listOwner, @NotNull String annotationFQN) {\n    String key = getExternalName(listOwner);\n    if (key == null) {\n      return null;\n    }\n    List<AnnotationData> list = collectInferredAnnotations(listOwner);\n    AnnotationData data = findByFQN(list, annotationFQN);\n    if (data == null) {\n      return null;\n    }\n    LOG.info(\"annotation: \" + key + \" \" + data);\n    return data.getAnnotation(this);\n  }","id":66299,"modified_method":"@Nullable\n  public PsiAnnotation findInferredAnnotation(@NotNull PsiModifierListOwner listOwner, @NotNull String annotationFQN) {\n    List<AnnotationData> list = collectInferredAnnotations(listOwner);\n    AnnotationData data = findByFQN(list, annotationFQN);\n    if (data == null) {\n      return null;\n    }\n    return data.getAnnotation(this);\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static String getExternalName(@NotNull PsiModifierListOwner listOwner) {\n    String rawExternalName = PsiFormatUtil.getRawExternalName(listOwner);\n    if (rawExternalName != null) {\n      rawExternalName = rawExternalName.replace(\"...)\", \"[])\");\n    }\n    return rawExternalName;\n  }","id":66300,"modified_method":"protected static int getKey(@NotNull PsiModifierListOwner owner) throws IOException {\n    if (owner instanceof PsiMethod) {\n      return BytecodeAnalysisConverter.getInstance().mkKey((PsiMethod)owner, new Out());\n    }\n    else if (owner instanceof PsiParameter) {\n      final PsiElement declarationScope = ((PsiParameter)owner).getDeclarationScope();\n      if (!(declarationScope instanceof PsiMethod)) {\n        return -1;\n      }\n      final PsiMethod psiMethod = (PsiMethod)declarationScope;\n      final int index = psiMethod.getParameterList().getParameterIndex((PsiParameter)owner);\n      return BytecodeAnalysisConverter.getInstance().mkKey(psiMethod, new In(index));\n    } else {\n      return -1;\n    }\n  }","commit_id":"383752b4a061e756c1e09cd8d9a54ebf6bf0c7fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public Object[] getVariants() {\n      return ContainerUtil.map2Array(strutsModel.getStrutsPackages(), LookupElement.class,\n          new Function<StrutsPackage, LookupElement>() {\n            public LookupElement fun(final StrutsPackage strutsPackage) {\n              return LookupElementBuilder.create(strutsPackage.getXmlTag(), strutsPackage.searchNamespace())\n                  .setTypeText(strutsPackage.getName().getStringValue());\n            }\n          });\n    }","id":66301,"modified_method":"@NotNull\n    public Object[] getVariants() {\n      return ContainerUtil.map2Array(strutsModel.getStrutsPackages(), LookupElement.class,\n                                     STRUTS_PACKAGE_LOOKUP_ELEMENT_FUNCTION);\n    }","commit_id":"7dac9f54ff9415c69c12e26aa0473a716ddf4cf7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ASTNode findChildByRole(int role) {\n    LOG.assertTrue(ChildRole.isUnique(role));\n    switch (role) {\n      default:\n        return null;\n\n      case ChildRole.LPARENTH:\n        return getFirstChildNode() != null && getFirstChildNode().getElementType() == LPARENTH ? getFirstChildNode() : null;\n\n      case ChildRole.RPARENTH:\n        if (getLastChildNode() != null && getLastChildNode().getElementType() == RPARENTH) {\n          return getLastChildNode();\n        }\n        else {\n          return null;\n        }\n    }\n  }","id":66302,"modified_method":"public ASTNode findChildByRole(int role) {\n    LOG.assertTrue(ChildRole.isUnique(role));\n    switch (role) {\n      default:\n        return null;\n\n      case ChildRole.LPARENTH:\n        return getFirstChildNode() != null && getFirstChildNode().getElementType() == JavaTokenType.LPARENTH ? getFirstChildNode() : null;\n\n      case ChildRole.RPARENTH:\n        if (getLastChildNode() != null && getLastChildNode().getElementType() == JavaTokenType.RPARENTH) {\n          return getLastChildNode();\n        }\n        else {\n          return null;\n        }\n    }\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement addInternal(TreeElement first, ASTNode last, ASTNode anchor, Boolean before) {\n    final CharTable treeCharTab = SharedImplUtil.findCharTableByTree(this);\n    if (anchor == null) {\n      if (before == null || before.booleanValue()) {\n        anchor = findChildByRole(ChildRole.RPARENTH);\n        if (anchor == null) {\n          LeafElement lparenth = Factory.createSingleLeafElement(LPARENTH, \"(\", 0, 1, treeCharTab, getManager());\n          super.addInternal(lparenth, lparenth, null, Boolean.FALSE);\n          LeafElement rparenth = Factory.createSingleLeafElement(RPARENTH, \")\", 0, 1, treeCharTab, getManager());\n          super.addInternal(rparenth, rparenth, null, Boolean.TRUE);\n          anchor = findChildByRole(ChildRole.RPARENTH);\n          LOG.assertTrue(anchor != null);\n        }\n        before = Boolean.TRUE;\n      }\n      else {\n        anchor = findChildByRole(ChildRole.LPARENTH);\n        if (anchor == null) {\n          LeafElement lparenth = Factory.createSingleLeafElement(LPARENTH, \"(\", 0, 1, treeCharTab, getManager());\n          super.addInternal(lparenth, lparenth, null, Boolean.FALSE);\n          LeafElement rparenth = Factory.createSingleLeafElement(RPARENTH, \")\", 0, 1, treeCharTab, getManager());\n          super.addInternal(rparenth, rparenth, null, Boolean.TRUE);\n          anchor = findChildByRole(ChildRole.LPARENTH);\n          LOG.assertTrue(anchor != null);\n        }\n        before = Boolean.FALSE;\n      }\n    }\n    TreeElement firstAdded = super.addInternal(first, last, anchor, before);\n    if (ElementType.EXPRESSION_BIT_SET.contains(first.getElementType())) {\n      ASTNode element = first;\n      for (ASTNode child = element.getTreeNext(); child != null; child = child.getTreeNext()) {\n        if (child.getElementType() == COMMA) break;\n        if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n          TreeElement comma = Factory.createSingleLeafElement(COMMA, \",\", 0, 1, treeCharTab, getManager());\n          super.addInternal(comma, comma, element, Boolean.FALSE);\n          break;\n        }\n      }\n      for (ASTNode child = element.getTreePrev(); child != null; child = child.getTreePrev()) {\n        if (child.getElementType() == COMMA) break;\n        if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n          TreeElement comma = Factory.createSingleLeafElement(COMMA, \",\", 0, 1, treeCharTab, getManager());\n          super.addInternal(comma, comma, child, Boolean.FALSE);\n          break;\n        }\n      }\n    }\n    return firstAdded;\n  }","id":66303,"modified_method":"public TreeElement addInternal(TreeElement first, ASTNode last, ASTNode anchor, Boolean before) {\n    final CharTable treeCharTab = SharedImplUtil.findCharTableByTree(this);\n    if (anchor == null) {\n      if (before == null || before.booleanValue()) {\n        anchor = findChildByRole(ChildRole.RPARENTH);\n        if (anchor == null) {\n          LeafElement lparenth = Factory.createSingleLeafElement(JavaTokenType.LPARENTH, \"(\", 0, 1, treeCharTab, getManager());\n          super.addInternal(lparenth, lparenth, null, Boolean.FALSE);\n          LeafElement rparenth = Factory.createSingleLeafElement(JavaTokenType.RPARENTH, \")\", 0, 1, treeCharTab, getManager());\n          super.addInternal(rparenth, rparenth, null, Boolean.TRUE);\n          anchor = findChildByRole(ChildRole.RPARENTH);\n          LOG.assertTrue(anchor != null);\n        }\n        before = Boolean.TRUE;\n      }\n      else {\n        anchor = findChildByRole(ChildRole.LPARENTH);\n        if (anchor == null) {\n          LeafElement lparenth = Factory.createSingleLeafElement(JavaTokenType.LPARENTH, \"(\", 0, 1, treeCharTab, getManager());\n          super.addInternal(lparenth, lparenth, null, Boolean.FALSE);\n          LeafElement rparenth = Factory.createSingleLeafElement(JavaTokenType.RPARENTH, \")\", 0, 1, treeCharTab, getManager());\n          super.addInternal(rparenth, rparenth, null, Boolean.TRUE);\n          anchor = findChildByRole(ChildRole.LPARENTH);\n          LOG.assertTrue(anchor != null);\n        }\n        before = Boolean.FALSE;\n      }\n    }\n    TreeElement firstAdded = super.addInternal(first, last, anchor, before);\n    if (ElementType.EXPRESSION_BIT_SET.contains(first.getElementType())) {\n      ASTNode element = first;\n      for (ASTNode child = element.getTreeNext(); child != null; child = child.getTreeNext()) {\n        if (child.getElementType() == JavaTokenType.COMMA) break;\n        if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n          TreeElement comma = Factory.createSingleLeafElement(JavaTokenType.COMMA, \",\", 0, 1, treeCharTab, getManager());\n          super.addInternal(comma, comma, element, Boolean.FALSE);\n          break;\n        }\n      }\n      for (ASTNode child = element.getTreePrev(); child != null; child = child.getTreePrev()) {\n        if (child.getElementType() == JavaTokenType.COMMA) break;\n        if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n          TreeElement comma = Factory.createSingleLeafElement(JavaTokenType.COMMA, \",\", 0, 1, treeCharTab, getManager());\n          super.addInternal(comma, comma, child, Boolean.FALSE);\n          break;\n        }\n      }\n    }\n    return firstAdded;\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiType[] getExpressionTypes() {\n    return ContainerUtil.map2Array(getExpressions(), PsiType.class, new Function<PsiExpression, PsiType>() {\n      public PsiType fun(final PsiExpression expression) {\n        return expression.getType();\n      }\n    });\n  }","id":66304,"modified_method":"@NotNull\n  public PsiType[] getExpressionTypes() {\n    return ContainerUtil.map2Array(getExpressions(), PsiType.class, PsiExpression.EXPRESSION_TO_TYPE);\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiExpression[] getExpressions() {\n    return getChildrenAsPsiElements(EXPRESSION_BIT_SET, PSI_EXPRESSION_ARRAY_CONSTRUCTOR);\n  }","id":66305,"modified_method":"@NotNull\n  public PsiExpression[] getExpressions() {\n    return getChildrenAsPsiElements(ElementType.EXPRESSION_BIT_SET, Constants.PSI_EXPRESSION_ARRAY_CONSTRUCTOR);\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getChildRole(ASTNode child) {\n    LOG.assertTrue(child.getTreeParent() == this);\n    IElementType i = child.getElementType();\n    if (i == COMMA) {\n      return ChildRole.COMMA;\n    }\n    else if (i == LPARENTH) {\n      return ChildRole.LPARENTH;\n    }\n    else if (i == RPARENTH) {\n      return ChildRole.RPARENTH;\n    }\n    else {\n      if (EXPRESSION_BIT_SET.contains(child.getElementType())) {\n        return ChildRole.EXPRESSION_IN_LIST;\n      }\n      return ChildRoleBase.NONE;\n    }\n  }","id":66306,"modified_method":"public int getChildRole(ASTNode child) {\n    LOG.assertTrue(child.getTreeParent() == this);\n    IElementType i = child.getElementType();\n    if (i == JavaTokenType.COMMA) {\n      return ChildRole.COMMA;\n    }\n    else if (i == JavaTokenType.LPARENTH) {\n      return ChildRole.LPARENTH;\n    }\n    else if (i == JavaTokenType.RPARENTH) {\n      return ChildRole.RPARENTH;\n    }\n    else {\n      if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n        return ChildRole.EXPRESSION_IN_LIST;\n      }\n      return ChildRoleBase.NONE;\n    }\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void deleteChildInternal(@NotNull ASTNode child) {\n    if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n      ASTNode next = TreeUtil.skipElements(child.getTreeNext(), StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n      if (next != null && next.getElementType() == COMMA) {\n        deleteChildInternal(next);\n      }\n      else {\n        ASTNode prev = TreeUtil.skipElementsBack(child.getTreePrev(), StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n        if (prev != null && prev.getElementType() == COMMA) {\n          deleteChildInternal(prev);\n        }\n      }\n    }\n    super.deleteChildInternal(child);\n  }","id":66307,"modified_method":"public void deleteChildInternal(@NotNull ASTNode child) {\n    if (ElementType.EXPRESSION_BIT_SET.contains(child.getElementType())) {\n      ASTNode next = TreeUtil.skipElements(child.getTreeNext(), StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n      if (next != null && next.getElementType() == JavaTokenType.COMMA) {\n        deleteChildInternal(next);\n      }\n      else {\n        ASTNode prev = TreeUtil.skipElementsBack(child.getTreePrev(), StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n        if (prev != null && prev.getElementType() == JavaTokenType.COMMA) {\n          deleteChildInternal(prev);\n        }\n      }\n    }\n    super.deleteChildInternal(child);\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiExpressionListImpl() {\n    super(EXPRESSION_LIST);\n  }","id":66308,"modified_method":"public PsiExpressionListImpl() {\n    super(JavaElementType.EXPRESSION_LIST);\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isApplicable(PsiMethod method, PsiSubstitutor substitutorForMethod, PsiExpression[] argList) {\n    return getApplicabilityLevel(method, substitutorForMethod, ContainerUtil.map2Array(argList, PsiType.class, new Function<PsiExpression, PsiType>() {\n        public PsiType fun(final PsiExpression expression) {\n          return expression.getType();\n        }\n      }),getLanguageLevel(method)) != ApplicabilityLevel.NOT_APPLICABLE;\n  }","id":66309,"modified_method":"public static boolean isApplicable(PsiMethod method, PsiSubstitutor substitutorForMethod, PsiExpression[] argList) {\n    return getApplicabilityLevel(method, substitutorForMethod, ContainerUtil.map2Array(argList, PsiType.class, PsiExpression.EXPRESSION_TO_TYPE),getLanguageLevel(method)) != ApplicabilityLevel.NOT_APPLICABLE;\n  }","commit_id":"987a0a9f3e57e4fc400c1c01aa155c84df377050","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void enable_https_port() throws Exception {\n    // start server\n    URL jksKeystore = getClass().getResource(\"/server/HttpsTest/keystore.jks\");\n    orchestrator = Orchestrator.builderEnv()\n      .setSonarVersion(\"DEV\")\n      .setServerProperty(\"sonar.web.https.port\", String.valueOf(httpsPort))\n      .setServerProperty(\"sonar.web.https.keyAlias\", \"tests\")\n      .setServerProperty(\"sonar.web.https.keyPass\", \"thetests\")\n      .setServerProperty(\"sonar.web.https.keystoreFile\", new File(jksKeystore.toURI()).getAbsolutePath())\n      .setServerProperty(\"sonar.web.https.keystorePass\", \"thepassword\")\n      .build();\n    orchestrator.start();\n\n    // check logs\n    File logFile = orchestrator.getServer().getLogs();\n    assertThat(FileUtils.readFileToString(logFile)).contains(\"HTTPS connector enabled on port \" + httpsPort);\n\n    // connect from clients\n    connectTrusted();\n    connectUntrusted();\n  }","id":66310,"modified_method":"@Test\n  public void enable_https_port() throws Exception {\n    // start server\n    URL jksKeystore = getClass().getResource(\"/server/HttpsTest/keystore.jks\");\n    orchestrator = Orchestrator.builderEnv()\n      .setServerProperty(\"sonar.web.https.port\", String.valueOf(httpsPort))\n      .setServerProperty(\"sonar.web.https.keyAlias\", \"tests\")\n      .setServerProperty(\"sonar.web.https.keyPass\", \"thetests\")\n      .setServerProperty(\"sonar.web.https.keystoreFile\", new File(jksKeystore.toURI()).getAbsolutePath())\n      .setServerProperty(\"sonar.web.https.keystorePass\", \"thepassword\")\n      .build();\n    orchestrator.start();\n\n    // check logs\n    File logFile = orchestrator.getServer().getLogs();\n    assertThat(FileUtils.readFileToString(logFile)).contains(\"HTTPS connector enabled on port \" + httpsPort);\n\n    // connect from clients\n    connectTrusted();\n    connectUntrusted();\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_start_if_bad_keystore_credentials() throws Exception {\n    try {\n      URL jksKeystore = getClass().getResource(\"/server/HttpsTest/keystore.jks\");\n      orchestrator = Orchestrator.builderEnv()\n        .setSonarVersion(\"DEV\")\n        .setServerProperty(\"sonar.web.https.port\", String.valueOf(httpsPort))\n        .setServerProperty(\"sonar.web.https.keyAlias\", \"tests\")\n        .setServerProperty(\"sonar.web.https.keyPass\", \"__wrong__\")\n        .setServerProperty(\"sonar.web.https.keystoreFile\", new File(jksKeystore.toURI()).getAbsolutePath())\n        .setServerProperty(\"sonar.web.https.keystorePass\", \"__wrong__\")\n        .build();\n      orchestrator.start();\n      fail();\n    } catch (Exception e) {\n      File logFile = orchestrator.getServer().getLogs();\n      assertThat(FileUtils.readFileToString(logFile)).contains(\"Password verification failed\");\n    }\n  }","id":66311,"modified_method":"@Test\n  public void fail_to_start_if_bad_keystore_credentials() throws Exception {\n    try {\n      URL jksKeystore = getClass().getResource(\"/server/HttpsTest/keystore.jks\");\n      orchestrator = Orchestrator.builderEnv()\n        .setServerProperty(\"sonar.web.https.port\", String.valueOf(httpsPort))\n        .setServerProperty(\"sonar.web.https.keyAlias\", \"tests\")\n        .setServerProperty(\"sonar.web.https.keyPass\", \"__wrong__\")\n        .setServerProperty(\"sonar.web.https.keystoreFile\", new File(jksKeystore.toURI()).getAbsolutePath())\n        .setServerProperty(\"sonar.web.https.keystorePass\", \"__wrong__\")\n        .build();\n      orchestrator.start();\n      fail();\n    } catch (Exception e) {\n      File logFile = orchestrator.getServer().getLogs();\n      assertThat(FileUtils.readFileToString(logFile)).contains(\"Password verification failed\");\n    }\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@BeforeClass\n  public static void startServer() {\n    OrchestratorBuilder builder = Orchestrator.builderEnv();\n\n    // install latest compatible releases of plugins\n    builder.setSonarVersion(\"DEV\");\n    org.sonar.updatecenter.common.Version sonarVersion = org.sonar.updatecenter.common.Version.create(builder.getSonarVersion());\n    builder.getUpdateCenter().setInstalledSonarVersion(sonarVersion);\n    for (Plugin plugin : builder.getUpdateCenter().findAllCompatiblePlugins()) {\n      if (!DISABLED_PLUGINS.contains(plugin.getKey())) {\n        Release release = plugin.getLastCompatibleRelease(sonarVersion);\n        if (release != null) {\n          builder.setOrchestratorProperty(plugin.getKey() + \"Version\", release.getVersion().toString());\n          builder.addPlugin(plugin.getKey());\n        }\n      }\n    }\n    activateLicenses(builder);\n    orchestrator = builder.build();\n    orchestrator.start();\n  }","id":66312,"modified_method":"@BeforeClass\n  public static void startServer() {\n    OrchestratorBuilder builder = Orchestrator.builderEnv();\n\n    // install latest compatible releases of plugins\n    org.sonar.updatecenter.common.Version sonarVersion = org.sonar.updatecenter.common.Version.create(builder.getSonarVersion());\n    builder.getUpdateCenter().setInstalledSonarVersion(sonarVersion);\n    for (Plugin plugin : builder.getUpdateCenter().findAllCompatiblePlugins()) {\n      if (!DISABLED_PLUGINS.contains(plugin.getKey())) {\n        Release release = plugin.getLastCompatibleRelease(sonarVersion);\n        if (release != null) {\n          builder.setOrchestratorProperty(plugin.getKey() + \"Version\", release.getVersion().toString());\n          builder.addPlugin(plugin.getKey());\n        }\n      }\n    }\n    activateLicenses(builder);\n    orchestrator = builder.build();\n    orchestrator.start();\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void support_install_dir_with_whitespaces() throws Exception {\n    String dirName = \"target/has space\";\n    FileUtils.deleteDirectory(new File(dirName));\n    orchestrator = Orchestrator.builderEnv()\n        .setSonarVersion(\"DEV\")\n        .setOrchestratorProperty(\"orchestrator.workspaceDir\", dirName)\n        .build();\n    orchestrator.start();\n\n    Server.Status status = orchestrator.getServer().getAdminWsClient().find(new ServerQuery()).getStatus();\n    assertThat(status).isEqualTo(Server.Status.UP);\n  }","id":66313,"modified_method":"@Test\n  public void support_install_dir_with_whitespaces() throws Exception {\n    String dirName = \"target/has space\";\n    FileUtils.deleteDirectory(new File(dirName));\n    orchestrator = Orchestrator.builderEnv()\n        .setOrchestratorProperty(\"orchestrator.workspaceDir\", dirName)\n        .build();\n    orchestrator.start();\n\n    Server.Status status = orchestrator.getServer().getAdminWsClient().find(new ServerQuery()).getStatus();\n    assertThat(status).isEqualTo(Server.Status.UP);\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_settings() {\n    URL secretKeyUrl = getClass().getResource(\"/server/ServerTest/sonar-secret.txt\");\n    orchestrator = Orchestrator.builderEnv()\n      .setSonarVersion(\"DEV\")\n      .addPlugin(ItUtils.pluginArtifact(\"settings-plugin\"))\n      .addPlugin(ItUtils.pluginArtifact(\"license-plugin\"))\n      .setServerProperty(\"sonar.secretKeyPath\", secretKeyUrl.getFile())\n      .build();\n    orchestrator.start();\n\n    Selenese selenese = Selenese.builder().setHtmlTestsInClasspath(\"settings\",\n      \"/server/ServerTest/settings/general-settings.html\",\n\n      // SONAR-2869 the annotation @Properties can be used on extensions and not only on plugin entry points\n      \"/server/ServerTest/settings/hidden-extension-property.html\",\n      \"/server/ServerTest/settings/global-extension-property.html\",\n\n      // SONAR-3344 - licenses\n      \"/server/ServerTest/settings/ignore-corrupted-license.html\",\n      \"/server/ServerTest/settings/display-license.html\",\n      \"/server/ServerTest/settings/display-untyped-license.html\",\n\n      // SONAR-2084 - encryption\n      \"/server/ServerTest/settings/generate-secret-key.html\",\n      \"/server/ServerTest/settings/encrypt-text.html\",\n\n      // SONAR-1378 - property types\n      \"/server/ServerTest/settings/validate-property-type.html\",\n\n      // SONAR-3127 - hide passwords\n      \"/server/ServerTest/settings/hide-passwords.html\"\n      ).build();\n    new SeleneseTest(selenese).runOn(orchestrator);\n  }","id":66314,"modified_method":"@Test\n  public void test_settings() {\n    URL secretKeyUrl = getClass().getResource(\"/server/ServerTest/sonar-secret.txt\");\n    orchestrator = Orchestrator.builderEnv()\n      .addPlugin(ItUtils.pluginArtifact(\"settings-plugin\"))\n      .addPlugin(ItUtils.pluginArtifact(\"license-plugin\"))\n      .setServerProperty(\"sonar.secretKeyPath\", secretKeyUrl.getFile())\n      .build();\n    orchestrator.start();\n\n    Selenese selenese = Selenese.builder().setHtmlTestsInClasspath(\"settings\",\n      \"/server/ServerTest/settings/general-settings.html\",\n\n      // SONAR-2869 the annotation @Properties can be used on extensions and not only on plugin entry points\n      \"/server/ServerTest/settings/hidden-extension-property.html\",\n      \"/server/ServerTest/settings/global-extension-property.html\",\n\n      // SONAR-3344 - licenses\n      \"/server/ServerTest/settings/ignore-corrupted-license.html\",\n      \"/server/ServerTest/settings/display-license.html\",\n      \"/server/ServerTest/settings/display-untyped-license.html\",\n\n      // SONAR-2084 - encryption\n      \"/server/ServerTest/settings/generate-secret-key.html\",\n      \"/server/ServerTest/settings/encrypt-text.html\",\n\n      // SONAR-1378 - property types\n      \"/server/ServerTest/settings/validate-property-type.html\",\n\n      // SONAR-3127 - hide passwords\n      \"/server/ServerTest/settings/hide-passwords.html\"\n      ).build();\n    new SeleneseTest(selenese).runOn(orchestrator);\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-4843\n   */\n  @Test\n  public void restart_on_dev_mode() throws Exception {\n    // server classloader locks Jar files on Windows\n    if (!SystemUtils.IS_OS_WINDOWS) {\n      orchestrator = Orchestrator.builderEnv()\n        .setSonarVersion(\"DEV\")\n        .setServerProperty(\"sonar.web.dev\", \"true\")\n        .build();\n      orchestrator.start();\n\n      orchestrator.getServer().adminWsClient().systemClient().restart();\n      assertThat(FileUtils.readFileToString(orchestrator.getServer().getLogs()))\n        .contains(\"Restart server\")\n        .contains(\"Server restarted\");\n    }\n  }","id":66315,"modified_method":"/**\n   * SONAR-4843\n   */\n  @Test\n  public void restart_on_dev_mode() throws Exception {\n    // server classloader locks Jar files on Windows\n    if (!SystemUtils.IS_OS_WINDOWS) {\n      orchestrator = Orchestrator.builderEnv()\n        .setServerProperty(\"sonar.web.dev\", \"true\")\n        .build();\n      orchestrator.start();\n\n      orchestrator.getServer().adminWsClient().systemClient().restart();\n      assertThat(FileUtils.readFileToString(orchestrator.getServer().getLogs()))\n        .contains(\"Restart server\")\n        .contains(\"Server restarted\");\n    }\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_create_in_temp_folder() throws Exception {\n    orchestrator = Orchestrator.builderEnv()\n      .setSonarVersion(\"DEV\")\n      .addPlugin(ItUtils.pluginArtifact(\"server-plugin\"))\n      .setServerProperty(\"sonar.createTempFiles\", \"true\")\n      .build();\n    orchestrator.start();\n\n    File tempDir = new File(orchestrator.getServer().getHome(), \"temp/tmp\");\n\n    String logs = FileUtils.readFileToString(orchestrator.getServer().getLogs());\n    assertThat(logs).contains(\"Creating temp directory: \" + tempDir.getAbsolutePath() + File.separator + \"sonar-it\");\n    assertThat(logs).contains(\"Creating temp file: \" + tempDir.getAbsolutePath() + File.separator + \"sonar-it\");\n\n    // Verify temp folder is created\n    assertThat(new File(tempDir, \"sonar-it\")).isDirectory().exists();\n\n    orchestrator.stop();\n\n    // Verify temp folder is deleted after shutdown\n    assertThat(new File(tempDir, \"sonar-it\")).doesNotExist();\n  }","id":66316,"modified_method":"@Test\n  public void should_create_in_temp_folder() throws Exception {\n    orchestrator = Orchestrator.builderEnv()\n      .addPlugin(ItUtils.pluginArtifact(\"server-plugin\"))\n      .setServerProperty(\"sonar.createTempFiles\", \"true\")\n      .build();\n    orchestrator.start();\n\n    File tempDir = new File(orchestrator.getServer().getHome(), \"temp/tmp\");\n\n    String logs = FileUtils.readFileToString(orchestrator.getServer().getLogs());\n    assertThat(logs).contains(\"Creating temp directory: \" + tempDir.getAbsolutePath() + File.separator + \"sonar-it\");\n    assertThat(logs).contains(\"Creating temp file: \" + tempDir.getAbsolutePath() + File.separator + \"sonar-it\");\n\n    // Verify temp folder is created\n    assertThat(new File(tempDir, \"sonar-it\")).isDirectory().exists();\n\n    orchestrator.stop();\n\n    // Verify temp folder is deleted after shutdown\n    assertThat(new File(tempDir, \"sonar-it\")).doesNotExist();\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-4843\n   */\n  @Test\n  public void restart_forbidden_if_not_dev_mode() throws Exception {\n    // server classloader locks Jar files on Windows\n    if (!SystemUtils.IS_OS_WINDOWS) {\n      orchestrator = Orchestrator.builderEnv()\n        .setSonarVersion(\"DEV\")\n        .build();\n      orchestrator.start();\n      try {\n        orchestrator.getServer().adminWsClient().systemClient().restart();\n        fail();\n      } catch (Exception e) {\n        assertThat(e.getMessage()).contains(\"403\");\n      }\n    }\n  }","id":66317,"modified_method":"/**\n   * SONAR-4843\n   */\n  @Test\n  public void restart_forbidden_if_not_dev_mode() throws Exception {\n    // server classloader locks Jar files on Windows\n    if (!SystemUtils.IS_OS_WINDOWS) {\n      orchestrator = Orchestrator.builderEnv()\n        .build();\n      orchestrator.start();\n      try {\n        orchestrator.getServer().adminWsClient().systemClient().restart();\n        fail();\n      } catch (Exception e) {\n        assertThat(e.getMessage()).contains(\"403\");\n      }\n    }\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void property_relocation() {\n    orchestrator = Orchestrator.builderEnv()\n      .setSonarVersion(\"DEV\")\n      .addPlugin(ItUtils.pluginArtifact(\"property-relocation-plugin\"))\n      .addPlugin(ItUtils.xooPlugin())\n      .setServerProperty(\"sonar.deprecatedKey\", \"true\")\n      .build();\n    orchestrator.start();\n\n    SonarRunner withDeprecatedKey = SonarRunner.create(ItUtils.projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.deprecatedKey\", \"true\");\n    SonarRunner withNewKey = SonarRunner.create(ItUtils.projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.newKey\", \"true\");\n    // should not fail\n    orchestrator.executeBuilds(withDeprecatedKey, withNewKey);\n\n    Selenese selenese = Selenese.builder().setHtmlTestsInClasspath(\"property_relocation\",\n      \"/server/ServerTest/settings/property_relocation.html\"\n      ).build();\n    new SeleneseTest(selenese).runOn(orchestrator);\n  }","id":66318,"modified_method":"@Test\n  public void property_relocation() {\n    orchestrator = Orchestrator.builderEnv()\n      .addPlugin(ItUtils.pluginArtifact(\"property-relocation-plugin\"))\n      .addPlugin(ItUtils.xooPlugin())\n      .setServerProperty(\"sonar.deprecatedKey\", \"true\")\n      .build();\n    orchestrator.start();\n\n    SonarRunner withDeprecatedKey = SonarRunner.create(ItUtils.projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.deprecatedKey\", \"true\");\n    SonarRunner withNewKey = SonarRunner.create(ItUtils.projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.newKey\", \"true\");\n    // should not fail\n    orchestrator.executeBuilds(withDeprecatedKey, withNewKey);\n\n    Selenese selenese = Selenese.builder().setHtmlTestsInClasspath(\"property_relocation\",\n      \"/server/ServerTest/settings/property_relocation.html\"\n      ).build();\n    new SeleneseTest(selenese).runOn(orchestrator);\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-3516\n   */\n  @Test\n  public void check_minimal_sonar_version_at_startup() throws Exception {\n    try {\n      orchestrator = Orchestrator.builderEnv()\n        .setSonarVersion(\"DEV\")\n        .addPlugin(FileLocation.of(new File(ServerTest.class.getResource(\"/server/ServerTest/incompatible-plugin-1.0.jar\").toURI())))\n        .build();\n      orchestrator.start();\n      fail();\n    } catch (Exception e) {\n      assertThat(FileUtils.readFileToString(orchestrator.getServer().getLogs())).contains(\n        \"Plugin incompatible-plugin [incompatibleplugin] requires at least SonarQube 5.9\");\n    }\n  }","id":66319,"modified_method":"/**\n   * SONAR-3516\n   */\n  @Test\n  public void check_minimal_sonar_version_at_startup() throws Exception {\n    try {\n      orchestrator = Orchestrator.builderEnv()\n        .addPlugin(FileLocation.of(new File(ServerTest.class.getResource(\"/server/ServerTest/incompatible-plugin-1.0.jar\").toURI())))\n        .build();\n      orchestrator.start();\n      fail();\n    } catch (Exception e) {\n      assertThat(FileUtils.readFileToString(orchestrator.getServer().getLogs())).contains(\n        \"Plugin incompatible-plugin [incompatibleplugin] requires at least SonarQube 5.9\");\n    }\n  }","commit_id":"3510446ff5cc2342a31c0d01631e0347f15ebab2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static String getSearchContainerFieldText(Object object) {\n\t\tif (object == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString string = GetterUtil.getString(object);\n\n\t\treturn HtmlUtil.escape(StringUtil.shorten(string, 400));\n\t}","id":66320,"modified_method":"public static String getSearchContainerFieldText(Object object) {\n\t\tif (object == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString string = GetterUtil.getString(object);\n\n\t\tstring = StringUtil.shorten(string, 400);\n\t\tstring = HtmlUtil.stripHtml(string);\n\t\tstring = HtmlUtil.escape(string);\n\n\t\treturn string;\n\t}","commit_id":"5c8045946c8891cd3fa3fac80ff9cd2603c03b5b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong announcementEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tAnnouncementsEntry announcementEntry =\n\t\t\tAnnouncementsEntryLocalServiceUtil.fetchAnnouncementsEntry(\n\t\t\t\tannouncementEntryId);\n\n\t\tif (announcementEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString title = serviceContext.translate(\n\t\t\t\"x-sent-a-new-announcement\",\n\t\t\tHtmlUtil.escape(\n\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\tannouncementEntry.getUserId(), StringPool.BLANK)));\n\n\t\treturn StringUtil.replace(\n\t\t\tgetBodyTemplate(), new String[] {\"[$BODY$]\", \"[$TITLE$]\"},\n\t\t\tnew String[] {\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tStringUtil.shorten(announcementEntry.getContent(), 50)),\n\t\t\t\ttitle\n\t\t\t});\n\t}","id":66321,"modified_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong announcementEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tAnnouncementsEntry announcementEntry =\n\t\t\tAnnouncementsEntryLocalServiceUtil.fetchAnnouncementsEntry(\n\t\t\t\tannouncementEntryId);\n\n\t\tif (announcementEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString title = serviceContext.translate(\n\t\t\t\"x-sent-a-new-announcement\",\n\t\t\tHtmlUtil.escape(\n\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\tannouncementEntry.getUserId(), StringPool.BLANK)));\n\n\t\treturn StringUtil.replace(\n\t\t\tgetBodyTemplate(), new String[] {\"[$BODY$]\", \"[$TITLE$]\"},\n\t\t\tnew String[] {\n\t\t\t\tStringUtil.shorten(announcementEntry.getContent(), 50), title\n\t\t\t});\n\t}","commit_id":"f01b8326f3c6d07595432601a26de7f44f0e6011","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong microblogsEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tMicroblogsEntry microblogsEntry =\n\t\t\tMicroblogsEntryLocalServiceUtil.fetchMicroblogsEntry(\n\t\t\t\tmicroblogsEntryId);\n\n\t\tif (microblogsEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\n\t\tif (microblogsEntry.getType() == MicroblogsEntryConstants.TYPE_REPLY) {\n\t\t\tString userFullName = HtmlUtil.escape(\n\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\tmicroblogsEntry.getUserId(), StringPool.BLANK));\n\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\"x-commented-on-your-post\", userFullName));\n\t\t}\n\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(HtmlUtil.escape(microblogsEntry.getContent()));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":66322,"modified_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong microblogsEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tMicroblogsEntry microblogsEntry =\n\t\t\tMicroblogsEntryLocalServiceUtil.fetchMicroblogsEntry(\n\t\t\t\tmicroblogsEntryId);\n\n\t\tif (microblogsEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\n\t\tif (microblogsEntry.getType() == MicroblogsEntryConstants.TYPE_REPLY) {\n\t\t\tString userFullName = HtmlUtil.escape(\n\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\tmicroblogsEntry.getUserId(), StringPool.BLANK));\n\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\"x-commented-on-your-post\", userFullName));\n\t\t}\n\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(\n\t\t\tHtmlUtil.escape(\n\t\t\t\tStringUtil.shorten(microblogsEntry.getContent(), 50)));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d8683d3c3d7f212dbd81abf4563870a6fe190850","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString body = null;\n\t\tlong userId = 0;\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong classPK = jsonObject.getLong(\"classPK\");\n\n\t\tMBMessage mbMessage = MBMessageLocalServiceUtil.fetchMBMessage(classPK);\n\n\t\tif (mbMessage == null) {\n\t\t\tbody = jsonObject.getString(\"body\");\n\n\t\t\tif (Validator.isNull(body)) {\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvent(\n\t\t\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tuserId = jsonObject.getLong(\"userId\");\n\t\t}\n\t\telse {\n\t\t\tbody = mbMessage.getBody();\n\t\t\tuserId = mbMessage.getUserId();\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\n\t\t\t\t\"x-sent-you-a-message\",\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tPortalUtil.getUserName(userId, StringPool.BLANK))));\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(HtmlUtil.escape(StringUtil.shorten(body)));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":66323,"modified_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString body = null;\n\t\tlong userId = 0;\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong classPK = jsonObject.getLong(\"classPK\");\n\n\t\tMBMessage mbMessage = MBMessageLocalServiceUtil.fetchMBMessage(classPK);\n\n\t\tif (mbMessage == null) {\n\t\t\tbody = jsonObject.getString(\"body\");\n\n\t\t\tif (Validator.isNull(body)) {\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvent(\n\t\t\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tuserId = jsonObject.getLong(\"userId\");\n\t\t}\n\t\telse {\n\t\t\tbody = mbMessage.getBody();\n\t\t\tuserId = mbMessage.getUserId();\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\n\t\t\t\t\"x-sent-you-a-message\",\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tPortalUtil.getUserName(userId, StringPool.BLANK))));\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(HtmlUtil.escape(StringUtil.shorten(body, 50)));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d8683d3c3d7f212dbd81abf4563870a6fe190850","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong announcementEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tAnnouncementsEntry announcementEntry =\n\t\t\tAnnouncementsEntryLocalServiceUtil.fetchAnnouncementsEntry(\n\t\t\t\tannouncementEntryId);\n\n\t\tif (announcementEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\n\t\t\t\t\"x-sent-a-new-announcement\",\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\t\tannouncementEntry.getUserId(), StringPool.BLANK))));\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(\n\t\t\tHtmlUtil.escape(\n\t\t\t\tStringUtil.shorten(announcementEntry.getContent())));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":66324,"modified_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong announcementEntryId = jsonObject.getLong(\"classPK\");\n\n\t\tAnnouncementsEntry announcementEntry =\n\t\t\tAnnouncementsEntryLocalServiceUtil.fetchAnnouncementsEntry(\n\t\t\t\tannouncementEntryId);\n\n\t\tif (announcementEntry == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"title\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\n\t\t\t\t\"x-sent-a-new-announcement\",\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tPortalUtil.getUserName(\n\t\t\t\t\t\tannouncementEntry.getUserId(), StringPool.BLANK))));\n\t\tsb.append(\"<\/div><div class=\\\"body\\\">\");\n\t\tsb.append(StringUtil.shorten(announcementEntry.getContent(), 50));\n\t\tsb.append(\"<\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d8683d3c3d7f212dbd81abf4563870a6fe190850","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private String intrafilterRequestLog(MutableHttpServletRequest mutableHttpRequest,\n                                         FilterContext filterContext, UUID uuid) throws IOException {\n\n        //adding a UUID header\n        if (StringUtils.isEmpty(mutableHttpRequest.getHeader(INTRAFILTER_UUID))) {\n            mutableHttpRequest.addHeader(INTRAFILTER_UUID, uuid.toString());\n        }\n\n        //converting log object to json string\n        RequestLog requestLog = new RequestLog(mutableHttpRequest, filterContext);\n        String jsonStringOfRequestLog = convertPojoToJsonString(requestLog);\n\n        return jsonStringOfRequestLog;\n    }","id":66325,"modified_method":"private String intrafilterRequestLog(MutableHttpServletRequest mutableHttpRequest,\n                                         FilterContext filterContext, UUID uuid) throws IOException {\n\n        //adding a UUID header\n        if (StringUtils.isEmpty(mutableHttpRequest.getHeader(INTRAFILTER_UUID))) {\n            mutableHttpRequest.addHeader(INTRAFILTER_UUID, uuid.toString());\n        }\n\n        //converting log object to json string\n        RequestLog requestLog = new RequestLog(mutableHttpRequest, filterContext);\n\n        return convertPojoToJsonString(requestLog);\n    }","commit_id":"c2005af4a0e9ea7a6e8f4390787d6b60016727c0","url":"https://github.com/rackerlabs/repose"},{"original_method":"private String intrafilterResponseLog(MutableHttpServletResponse mutableHttpResponse,\n                                          FilterContext filterContext, String uuid) throws IOException {\n\n        //adding a UUID header\n        if (StringUtils.isEmpty(mutableHttpResponse.getHeader(INTRAFILTER_UUID))) {\n            mutableHttpResponse.addHeader(INTRAFILTER_UUID, uuid);\n        }\n\n        //converting log object to json string\n        ResponseLog responseLog = new ResponseLog(mutableHttpResponse, filterContext);\n        String jsonStringOfResponseLog = convertPojoToJsonString(responseLog);\n\n        return jsonStringOfResponseLog;\n    }","id":66326,"modified_method":"private String intrafilterResponseLog(MutableHttpServletResponse mutableHttpResponse,\n                                          FilterContext filterContext, String uuid) throws IOException {\n\n        //adding a UUID header\n        if (StringUtils.isEmpty(mutableHttpResponse.getHeader(INTRAFILTER_UUID))) {\n            mutableHttpResponse.addHeader(INTRAFILTER_UUID, uuid);\n        }\n\n        //converting log object to json string\n        ResponseLog responseLog = new ResponseLog(mutableHttpResponse, filterContext);\n\n        return convertPojoToJsonString(responseLog);\n    }","commit_id":"c2005af4a0e9ea7a6e8f4390787d6b60016727c0","url":"https://github.com/rackerlabs/repose"},{"original_method":"private String convertPojoToJsonString(Object object) throws IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(JsonMethod.FIELD, JsonAutoDetect.Visibility.ANY);//http://stackoverflow.com/a/8395924\n        String prettyJsonStringOfPojo = objectMapper.writeValueAsString(object);\n\n        return prettyJsonStringOfPojo;\n    }","id":66327,"modified_method":"private String convertPojoToJsonString(Object object) throws IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(JsonMethod.FIELD, JsonAutoDetect.Visibility.ANY);//http://stackoverflow.com/a/8395924\n\n        return objectMapper.writeValueAsString(object);\n    }","commit_id":"c2005af4a0e9ea7a6e8f4390787d6b60016727c0","url":"https://github.com/rackerlabs/repose"},{"original_method":"public static String toJson(Object dto) throws JsonProcessingException {\n        Class<?> clazz = dto.getClass();\n        String json = objectMapper.writerWithType(clazz).writeValueAsString(dto);\n        System.out.println(\"Writing class + \" + clazz + \" dto \" + dto + \" to json is: \" + json);\n        return json;\n    }","id":66328,"modified_method":"public static String toJson(Object dto) throws JsonProcessingException {\n        Class<?> clazz = dto.getClass();\n        return objectMapper.writerWithType(clazz).writeValueAsString(dto);\n    }","commit_id":"1323ac8eca96145267e52102131d4ce2a5b904ea","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void initServlet(final Resource resource,\n            final ServletResolver sr) {\n        // the resource and the request path info, will never be null\n        RequestPathInfo requestPathInfo = new SlingRequestPathInfo(resource);\n        ContentData contentData = setContent(resource, requestPathInfo);\n\n\t    requestProgressTracker.log(\"Resource Path Info: {0}\", requestPathInfo);\n\n        // finally resolve the servlet for the resource\n        requestProgressTracker.startTimer(\"ServletResolution\");\n        Servlet servlet = sr.resolveServlet(slingRequest);\n        requestProgressTracker.logTimer(\"ServletResolution\",\n            \"URI={0} handled by Servlet={1}\",\n            getServletRequest().getRequestURI(), RequestUtil.getServletName(servlet));\n        contentData.setServlet(servlet);\n    }","id":66329,"modified_method":"public void initServlet(final Resource resource,\n            final ServletResolver sr) {\n        // the resource and the request path info, will never be null\n        RequestPathInfo requestPathInfo = new SlingRequestPathInfo(resource);\n        ContentData contentData = setContent(resource, requestPathInfo);\n\n\t    requestProgressTracker.log(\"Resource Path Info: {0}\", requestPathInfo);\n\n        // finally resolve the servlet for the resource\n        requestProgressTracker.startTimer(\"ServletResolution\");\n        Servlet servlet = sr.resolveServlet(slingRequest);\n        requestProgressTracker.logTimer(\"ServletResolution\",\n            \"URI={0} handled by Servlet={1}\",\n            getServletRequest().getRequestURI(), (servlet == null ? \"-none-\" : RequestUtil.getServletName(servlet)));\n        contentData.setServlet(servlet);\n    }","commit_id":"add3316f0cf62aafd16effdbf69eb6597ad4fb7a","url":"https://github.com/apache/sling"},{"original_method":"public Servlet resolveServlet(SlingHttpServletRequest request) {\n\n        // get the servlet by resource type\n        Servlet servlet = getServlet(request.getResource().getResourceType());\n\n        // no typed servlet, so lets try scripting\n        if (servlet == null) {\n            try {\n                servlet = getScriptServlet(request);\n            } catch (SlingException se) {\n                log.error(\"resolveServlet: Error trying to find script\", se);\n            }\n        }\n\n        // use default servlet, create one if missing\n        if (servlet == null) {\n            servlet = getServlet(DEFAULT_SERVLET_NAME);\n            if (servlet == null) {\n                try {\n                    servlet = new DefaultServlet();\n                    servlet.init(new SlingServletConfig(null, null, DEFAULT_SERVLET_NAME));\n                    servlets.put(DEFAULT_SERVLET_NAME, servlet);\n                } catch (ServletException se) {\n                    log.error(\"Failed to initiliaze Servlet\", se);\n                }\n            }\n        }\n\n        if (servlet != null) {\n            String name = servlet.getServletConfig().getServletName();\n            log.debug(\"Using Component {} for {}\", name, path);\n        }\n\n        return servlet;\n    }","id":66330,"modified_method":"public Servlet resolveServlet(SlingHttpServletRequest request) {\n\n        // get the servlet by resource type\n        Servlet servlet = getServlet(request.getResource().getResourceType());\n\n        // no typed servlet, so lets try scripting\n        if (servlet == null) {\n            try {\n                servlet = getScriptServlet(request);\n            } catch (SlingException se) {\n                log.error(\"resolveServlet: Error trying to find script\", se);\n            }\n        }\n\n        // use default servlet, create one if missing\n        if (servlet == null) {\n            servlet = getServlet(DEFAULT_SERVLET_NAME);\n            if (servlet == null) {\n                try {\n                    servlet = new DefaultServlet();\n                    servlet.init(new SlingServletConfig(null, null, DEFAULT_SERVLET_NAME));\n                    servlets.put(DEFAULT_SERVLET_NAME, servlet);\n                } catch (ServletException se) {\n                    log.error(\"Failed to initiliaze Servlet\", se);\n                }\n            }\n        }\n\n        if (servlet != null && log.isDebugEnabled()) {\n            String name;\n            if (servlet.getServletConfig() != null) {\n                name = servlet.getServletConfig().getServletName();\n            } else {\n                name = servlet.getServletInfo();\n            }\n            if (name == null) {\n                name = servlet.getClass().getName();\n            }\n            log.debug(\"Using Component {} for {}\", name, path);\n        }\n\n        return servlet;\n    }","commit_id":"587c65628fe03dba62070f98161fb7d13a3fa4b8","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * Template method with default implementation (which may be overridden by a\n\t * subclass), to load or obtain an ApplicationContext instance which will be\n\t * used as the parent context of the root WebApplicationContext. If the\n\t * return value from the method is null, no parent context is set.\n\t * <p>The main reason to load a parent context here is to allow multiple root\n\t * web application contexts to all be children of a shared EAR context, or\n\t * alternately to also share the same parent context that is visible to\n\t * EJBs. For pure web applications, there is usually no need to worry about\n\t * having a parent context to the root web application context.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.context.access.ContextSingletonBeanFactoryLocator},\n\t * configured via {@link #LOCATOR_FACTORY_SELECTOR_PARAM} and\n\t * {@link #LOCATOR_FACTORY_KEY_PARAM}, to load a parent context\n\t * which will be shared by all other users of ContextsingletonBeanFactoryLocator\n\t * which also use the same configuration parameters.\n\t * @param servletContext current servlet context\n\t * @return the parent application context, or <code>null<\/code> if none\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see org.springframework.context.access.ContextSingletonBeanFactoryLocator\n\t */\n\tprotected ApplicationContext loadParentContext(ServletContext servletContext)\n\t\t\tthrows BeansException {\n\n\t\tApplicationContext parentContext = null;\n\t\tString locatorFactorySelector = servletContext.getInitParameter(LOCATOR_FACTORY_SELECTOR_PARAM);\n\t\tString parentContextKey = servletContext.getInitParameter(LOCATOR_FACTORY_KEY_PARAM);\n\n\t\tif (parentContextKey != null) {\n\t\t\t// locatorFactorySelector may be null, indicating the default \"classpath*:beanRefContext.xml\"\n\t\t\tBeanFactoryLocator locator = ContextSingletonBeanFactoryLocator.getInstance(locatorFactorySelector);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Getting parent context definition: using parent context key of '\" +\n\t\t\t\t\t\tparentContextKey + \"' with BeanFactoryLocator\");\n\t\t\t}\n\t\t\tthis.parentContextRef = locator.useBeanFactory(parentContextKey);\n\t\t\tparentContext = (ApplicationContext) this.parentContextRef.getFactory();\n\t\t}\n\n\t\treturn parentContext;\n\t}","id":66331,"modified_method":"/**\n\t * Template method with default implementation (which may be overridden by a\n\t * subclass), to load or obtain an ApplicationContext instance which will be\n\t * used as the parent context of the root WebApplicationContext. If the\n\t * return value from the method is null, no parent context is set.\n\t * <p>The main reason to load a parent context here is to allow multiple root\n\t * web application contexts to all be children of a shared EAR context, or\n\t * alternately to also share the same parent context that is visible to\n\t * EJBs. For pure web applications, there is usually no need to worry about\n\t * having a parent context to the root web application context.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.context.access.ContextSingletonBeanFactoryLocator},\n\t * configured via {@link #LOCATOR_FACTORY_SELECTOR_PARAM} and\n\t * {@link #LOCATOR_FACTORY_KEY_PARAM}, to load a parent context\n\t * which will be shared by all other users of ContextsingletonBeanFactoryLocator\n\t * which also use the same configuration parameters.\n\t * @param servletContext current servlet context\n\t * @return the parent application context, or <code>null<\/code> if none\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see org.springframework.context.access.ContextSingletonBeanFactoryLocator\n\t */\n\tprotected ApplicationContext loadParentContext(ServletContext servletContext)\n\t\t\tthrows BeansException {\n\n\t\tApplicationContext parentContext = null;\n\t\tString locatorFactorySelector = servletContext.getInitParameter(LOCATOR_FACTORY_SELECTOR_PARAM);\n\t\tString parentContextKey = servletContext.getInitParameter(LOCATOR_FACTORY_KEY_PARAM);\n\n\t\tif (parentContextKey != null) {\n\t\t\t// locatorFactorySelector may be null, indicating the default \"classpath*:beanRefContext.xml\"\n\t\t\tBeanFactoryLocator locator = ContextSingletonBeanFactoryLocator.getInstance(locatorFactorySelector);\n\t\t\tLog logger = LogFactory.getLog(ContextLoader.class);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Getting parent context definition: using parent context key of '\" +\n\t\t\t\t\t\tparentContextKey + \"' with BeanFactoryLocator\");\n\t\t\t}\n\t\t\tthis.parentContextRef = locator.useBeanFactory(parentContextKey);\n\t\t\tparentContext = (ApplicationContext) this.parentContextRef.getFactory();\n\t\t}\n\n\t\treturn parentContext;\n\t}","commit_id":"6b824d9af7bc13c6306fee2a25da9276c936189c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Initialize Spring's web application context for the given servlet context,\n\t * according to the \"{@link #CONTEXT_CLASS_PARAM contextClass}\" and\n\t * \"{@link #CONFIG_LOCATION_PARAM contextConfigLocation}\" context-params.\n\t * @param servletContext current servlet context\n\t * @return the new WebApplicationContext\n\t * @throws IllegalStateException if there is already a root application context present\n\t * @throws BeansException if the context failed to initialize\n\t * @see #CONTEXT_CLASS_PARAM\n\t * @see #CONFIG_LOCATION_PARAM\n\t */\n\tpublic WebApplicationContext initWebApplicationContext(ServletContext servletContext)\n\t\t\tthrows IllegalStateException, BeansException {\n\n\t\tif (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot initialize context because there is already a root application context present - \" +\n\t\t\t\t\t\"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n\t\t}\n\n\t\tservletContext.log(\"Initializing Spring root WebApplicationContext\");\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Root WebApplicationContext: initialization started\");\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\ttry {\n\t\t\t// Determine parent for root web application context, if any.\n\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\n\t\t\t// Store context in local instance variable, to guarantee that\n\t\t\t// it is available on ServletContext shutdown.\n\t\t\tthis.context = createWebApplicationContext(servletContext, parent);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\t\t\tcurrentContextPerThread.put(Thread.currentThread().getContextClassLoader(), this.context);\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Published root WebApplicationContext as ServletContext attribute with name [\" +\n\t\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + \"]\");\n\t\t\t}\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\t\tlogger.info(\"Root WebApplicationContext: initialization completed in \" + elapsedTime + \" ms\");\n\t\t\t}\n\n\t\t\treturn this.context;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tlogger.error(\"Context initialization failed\", ex);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Error err) {\n\t\t\tlogger.error(\"Context initialization failed\", err);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n\t\t\tthrow err;\n\t\t}\n\t}","id":66332,"modified_method":"/**\n\t * Initialize Spring's web application context for the given servlet context,\n\t * according to the \"{@link #CONTEXT_CLASS_PARAM contextClass}\" and\n\t * \"{@link #CONFIG_LOCATION_PARAM contextConfigLocation}\" context-params.\n\t * @param servletContext current servlet context\n\t * @return the new WebApplicationContext\n\t * @throws IllegalStateException if there is already a root application context present\n\t * @throws BeansException if the context failed to initialize\n\t * @see #CONTEXT_CLASS_PARAM\n\t * @see #CONFIG_LOCATION_PARAM\n\t */\n\tpublic WebApplicationContext initWebApplicationContext(ServletContext servletContext)\n\t\t\tthrows IllegalStateException, BeansException {\n\n\t\tif (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot initialize context because there is already a root application context present - \" +\n\t\t\t\t\t\"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n\t\t}\n\n\t\tLog logger = LogFactory.getLog(ContextLoader.class);\n\t\tservletContext.log(\"Initializing Spring root WebApplicationContext\");\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Root WebApplicationContext: initialization started\");\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\ttry {\n\t\t\t// Determine parent for root web application context, if any.\n\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\n\t\t\t// Store context in local instance variable, to guarantee that\n\t\t\t// it is available on ServletContext shutdown.\n\t\t\tthis.context = createWebApplicationContext(servletContext, parent);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\t\t\tcurrentContextPerThread.put(Thread.currentThread().getContextClassLoader(), this.context);\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Published root WebApplicationContext as ServletContext attribute with name [\" +\n\t\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + \"]\");\n\t\t\t}\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\t\tlogger.info(\"Root WebApplicationContext: initialization completed in \" + elapsedTime + \" ms\");\n\t\t\t}\n\n\t\t\treturn this.context;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tlogger.error(\"Context initialization failed\", ex);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Error err) {\n\t\t\tlogger.error(\"Context initialization failed\", err);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n\t\t\tthrow err;\n\t\t}\n\t}","commit_id":"6b824d9af7bc13c6306fee2a25da9276c936189c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Instantiate the root WebApplicationContext for this loader, either the\n\t * default context class or a custom context class if specified.\n\t * <p>This implementation expects custom contexts to implement the\n\t * {@link ConfigurableWebApplicationContext} interface.\n\t * Can be overridden in subclasses.\n\t * <p>In addition, {@link #customizeContext} gets called prior to refreshing the\n\t * context, allowing subclasses to perform custom modifications to the context.\n\t * @param servletContext current servlet context\n\t * @param parent the parent ApplicationContext to use, or <code>null<\/code> if none\n\t * @return the root WebApplicationContext\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see ConfigurableWebApplicationContext\n\t */\n\tprotected WebApplicationContext createWebApplicationContext(\n\t\t\tServletContext servletContext, ApplicationContext parent) throws BeansException {\n\n\t\tClass contextClass = determineContextClass(servletContext);\n\t\tif (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n\t\t\tthrow new ApplicationContextException(\"Custom context class [\" + contextClass.getName() +\n\t\t\t\t\t\"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\");\n\t\t}\n\n\t\tConfigurableWebApplicationContext wac =\n\t\t\t\t(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\t\twac.setId(servletContext.getServletContextName());\n\t\twac.setParent(parent);\n\t\twac.setServletContext(servletContext);\n\t\twac.setConfigLocation(servletContext.getInitParameter(CONFIG_LOCATION_PARAM));\n\t\tcustomizeContext(servletContext, wac);\n\t\twac.refresh();\n\n\t\treturn wac;\n\t}","id":66333,"modified_method":"/**\n\t * Instantiate the root WebApplicationContext for this loader, either the\n\t * default context class or a custom context class if specified.\n\t * <p>This implementation expects custom contexts to implement the\n\t * {@link ConfigurableWebApplicationContext} interface.\n\t * Can be overridden in subclasses.\n\t * <p>In addition, {@link #customizeContext} gets called prior to refreshing the\n\t * context, allowing subclasses to perform custom modifications to the context.\n\t * @param servletContext current servlet context\n\t * @param parent the parent ApplicationContext to use, or <code>null<\/code> if none\n\t * @return the root WebApplicationContext\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see ConfigurableWebApplicationContext\n\t */\n\tprotected WebApplicationContext createWebApplicationContext(\n\t\t\tServletContext servletContext, ApplicationContext parent) throws BeansException {\n\n\t\tClass<?> contextClass = determineContextClass(servletContext);\n\t\tif (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n\t\t\tthrow new ApplicationContextException(\"Custom context class [\" + contextClass.getName() +\n\t\t\t\t\t\"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\");\n\t\t}\n\n\t\tConfigurableWebApplicationContext wac =\n\t\t\t\t(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n\t\t// Assign the best possible id value.\n\t\tif (servletContext.getMajorVersion() > 2 || servletContext.getMinorVersion() >= 5) {\n\t\t\t// Servlet 2.5's getContextPath available!\n\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContext.getContextPath());\n\t\t}\n\t\telse {\n\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\tString servletContextName = servletContext.getServletContextName();\n\t\t\tif (servletContextName != null) {\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContextName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX);\n\t\t\t}\n\t\t}\n\n\t\twac.setParent(parent);\n\t\twac.setServletContext(servletContext);\n\t\twac.setConfigLocation(servletContext.getInitParameter(CONFIG_LOCATION_PARAM));\n\t\tcustomizeContext(servletContext, wac);\n\t\twac.refresh();\n\n\t\treturn wac;\n\t}","commit_id":"6b824d9af7bc13c6306fee2a25da9276c936189c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Instantiate the Portlet ApplicationContext for this portlet, either a default\n\t * XmlPortletApplicationContext or a custom context class if set.\n\t * <p>This implementation expects custom contexts to implement\n\t * ConfigurablePortletApplicationContext. Can be overridden in subclasses.\n\t * @param parent the parent ApplicationContext to use, or null if none\n\t * @return the Portlet ApplicationContext for this portlet\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see #setContextClass\n\t * @see org.springframework.web.portlet.context.XmlPortletApplicationContext\n\t */\n\tprotected ApplicationContext createPortletApplicationContext(ApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Portlet with name '\" + getPortletName() +\n\t\t\t\t\t\"' will try to create custom ApplicationContext context of class '\" +\n\t\t\t\t\tgetContextClass().getName() + \"'\" + \", using parent context [\" + parent + \"]\");\n\t\t}\n\t\tif (!ConfigurablePortletApplicationContext.class.isAssignableFrom(getContextClass())) {\n\t\t\tthrow new ApplicationContextException(\"Fatal initialization error in portlet with name '\" + getPortletName() +\n\t\t\t\t\t\"': custom ApplicationContext class [\" + getContextClass().getName() +\n\t\t\t\t\t\"] is not of type ConfigurablePortletApplicationContext\");\n\t\t}\n\n\t\tConfigurablePortletApplicationContext pac =\n\t\t\t\t(ConfigurablePortletApplicationContext) BeanUtils.instantiateClass(getContextClass());\n\t\tpac.setId(getPortletContext().getPortletContextName() + \".\" + getPortletName());\n\t\tpac.setParent(parent);\n\t\tpac.setPortletContext(getPortletContext());\n\t\tpac.setPortletConfig(getPortletConfig());\n\t\tpac.setNamespace(getNamespace());\n\t\tpac.setConfigLocation(getContextConfigLocation());\n\t\tpac.addApplicationListener(new SourceFilteringListener(pac, this));\n\n\t\tpostProcessPortletApplicationContext(pac);\n\t\tpac.refresh();\n\n\t\treturn pac;\n\t}","id":66334,"modified_method":"/**\n\t * Instantiate the Portlet ApplicationContext for this portlet, either a default\n\t * XmlPortletApplicationContext or a custom context class if set.\n\t * <p>This implementation expects custom contexts to implement\n\t * ConfigurablePortletApplicationContext. Can be overridden in subclasses.\n\t * @param parent the parent ApplicationContext to use, or null if none\n\t * @return the Portlet ApplicationContext for this portlet\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see #setContextClass\n\t * @see org.springframework.web.portlet.context.XmlPortletApplicationContext\n\t */\n\tprotected ApplicationContext createPortletApplicationContext(ApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tClass<?> contextClass = getContextClass();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Portlet with name '\" + getPortletName() +\n\t\t\t\t\t\"' will try to create custom ApplicationContext context of class '\" +\n\t\t\t\t\tcontextClass.getName() + \"'\" + \", using parent context [\" + parent + \"]\");\n\t\t}\n\t\tif (!ConfigurablePortletApplicationContext.class.isAssignableFrom(contextClass)) {\n\t\t\tthrow new ApplicationContextException(\"Fatal initialization error in portlet with name '\" + getPortletName() +\n\t\t\t\t\t\"': custom ApplicationContext class [\" + contextClass.getName() +\n\t\t\t\t\t\"] is not of type ConfigurablePortletApplicationContext\");\n\t\t}\n\n\t\tConfigurablePortletApplicationContext pac =\n\t\t\t\t(ConfigurablePortletApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n\t\t// Assign the best possible id value.\n\t\tString portletContextName = getPortletContext().getPortletContextName();\n\t\tif (portletContextName != null) {\n\t\t\tpac.setId(ConfigurablePortletApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + portletContextName + \".\" + getPortletName());\n\t\t}\n\t\telse {\n\t\t\tpac.setId(ConfigurablePortletApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + getPortletName());\n\t\t}\n\n\t\tpac.setParent(parent);\n\t\tpac.setPortletContext(getPortletContext());\n\t\tpac.setPortletConfig(getPortletConfig());\n\t\tpac.setNamespace(getNamespace());\n\t\tpac.setConfigLocation(getContextConfigLocation());\n\t\tpac.addApplicationListener(new SourceFilteringListener(pac, this));\n\n\t\tpostProcessPortletApplicationContext(pac);\n\t\tpac.refresh();\n\n\t\treturn pac;\n\t}","commit_id":"6b824d9af7bc13c6306fee2a25da9276c936189c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Instantiate the WebApplicationContext for this servlet, either a default\n\t * {@link org.springframework.web.context.support.XmlWebApplicationContext}\n\t * or a {@link #setContextClass custom context class}, if set.\n\t * <p>This implementation expects custom contexts to implement the\n\t * {@link org.springframework.web.context.ConfigurableWebApplicationContext}\n\t * interface. Can be overridden in subclasses.\n\t * <p>Do not forget to register this servlet instance as application listener on the\n\t * created context (for triggering its {@link #onRefresh callback}, and to call\n\t * {@link org.springframework.context.ConfigurableApplicationContext#refresh()}\n\t * before returning the context instance.\n\t * @param parent the parent ApplicationContext to use, or <code>null<\/code> if none\n\t * @return the WebApplicationContext for this servlet\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see org.springframework.web.context.support.XmlWebApplicationContext\n\t */\n\tprotected WebApplicationContext createWebApplicationContext(WebApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Servlet with name '\" + getServletName() +\n\t\t\t\t\t\"' will try to create custom WebApplicationContext context of class '\" +\n\t\t\t\t\tgetContextClass().getName() + \"'\" + \", using parent context [\" + parent + \"]\");\n\t\t}\n\t\tif (!ConfigurableWebApplicationContext.class.isAssignableFrom(getContextClass())) {\n\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\"Fatal initialization error in servlet with name '\" + getServletName() +\n\t\t\t\t\t\"': custom WebApplicationContext class [\" + getContextClass().getName() +\n\t\t\t\t\t\"] is not of type ConfigurableWebApplicationContext\");\n\t\t}\n\n\t\tConfigurableWebApplicationContext wac =\n\t\t\t\t(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(getContextClass());\n\t\twac.setId(getServletContext().getServletContextName() + \".\" + getServletName());\n\t\twac.setParent(parent);\n\t\twac.setServletContext(getServletContext());\n\t\twac.setServletConfig(getServletConfig());\n\t\twac.setNamespace(getNamespace());\n\t\twac.setConfigLocation(getContextConfigLocation());\n\t\twac.addApplicationListener(new SourceFilteringListener(wac, this));\n\n\t\tpostProcessWebApplicationContext(wac);\n\t\twac.refresh();\n\n\t\treturn wac;\n\t}","id":66335,"modified_method":"/**\n\t * Instantiate the WebApplicationContext for this servlet, either a default\n\t * {@link org.springframework.web.context.support.XmlWebApplicationContext}\n\t * or a {@link #setContextClass custom context class}, if set.\n\t * <p>This implementation expects custom contexts to implement the\n\t * {@link org.springframework.web.context.ConfigurableWebApplicationContext}\n\t * interface. Can be overridden in subclasses.\n\t * <p>Do not forget to register this servlet instance as application listener on the\n\t * created context (for triggering its {@link #onRefresh callback}, and to call\n\t * {@link org.springframework.context.ConfigurableApplicationContext#refresh()}\n\t * before returning the context instance.\n\t * @param parent the parent ApplicationContext to use, or <code>null<\/code> if none\n\t * @return the WebApplicationContext for this servlet\n\t * @throws BeansException if the context couldn't be initialized\n\t * @see org.springframework.web.context.support.XmlWebApplicationContext\n\t */\n\tprotected WebApplicationContext createWebApplicationContext(WebApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tClass<?> contextClass = getContextClass();\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Servlet with name '\" + getServletName() +\n\t\t\t\t\t\"' will try to create custom WebApplicationContext context of class '\" +\n\t\t\t\t\tcontextClass.getName() + \"'\" + \", using parent context [\" + parent + \"]\");\n\t\t}\n\t\tif (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\"Fatal initialization error in servlet with name '\" + getServletName() +\n\t\t\t\t\t\"': custom WebApplicationContext class [\" + contextClass.getName() +\n\t\t\t\t\t\"] is not of type ConfigurableWebApplicationContext\");\n\t\t}\n\n\t\tConfigurableWebApplicationContext wac =\n\t\t\t\t(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n\t\t// Assign the best possible id value.\n\t\tServletContext servletContext = getServletContext();\n\t\tif (servletContext.getMajorVersion() > 2 || servletContext.getMinorVersion() >= 5) {\n\t\t\t// Servlet 2.5's getContextPath available!\n\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContext.getContextPath() + \"/\" + getServletName());\n\t\t}\n\t\telse {\n\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\tString servletContextName = servletContext.getServletContextName();\n\t\t\tif (servletContextName != null) {\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContextName + \".\" + getServletName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + getServletName());\n\t\t\t}\n\t\t}\n\n\t\twac.setParent(parent);\n\t\twac.setServletContext(getServletContext());\n\t\twac.setServletConfig(getServletConfig());\n\t\twac.setNamespace(getNamespace());\n\t\twac.setConfigLocation(getContextConfigLocation());\n\t\twac.addApplicationListener(new SourceFilteringListener(wac, this));\n\n\t\tpostProcessWebApplicationContext(wac);\n\t\twac.refresh();\n\n\t\treturn wac;\n\t}","commit_id":"6b824d9af7bc13c6306fee2a25da9276c936189c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * This test is supposed to verify that hostname verification works as described in:\n     * http://www.ietf.org/rfc/rfc2818.txt section 3.1. It uses a certificate with a common name different to localhost\n     * and sends a request to localhost. This should fail with a SSLHandshakeException.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void simpleGetWithHostnameVerificationEnabledTest() throws Exception\n    {\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n            fail(\"sending request to client should have failed with an Exception!\");\n        }\n        catch (ExecutionException x)\n        {\n            // The test may fail in 2 ways, since the CertificateException thrown because of the hostname\n            // verification failure is not rethrown immediately by the JDK SSL implementation, but only\n            // rethrown on the next read or write.\n            // Therefore this test may catch a SSLHandshakeException, or a ClosedChannelException.\n            // If it is the former, we verify that its cause is a CertificateException.\n\n            // ExecutionException wraps an EofException that wraps the SSLHandshakeException\n            Throwable cause = x.getCause().getCause();\n            if (cause instanceof SSLHandshakeException)\n                assertThat(cause.getCause().getCause(), instanceOf(CertificateException.class));\n            else\n                assertThat(cause, instanceOf(ClosedChannelException.class));\n        }\n    }","id":66336,"modified_method":"/**\n     * This test is supposed to verify that hostname verification works as described in:\n     * http://www.ietf.org/rfc/rfc2818.txt section 3.1. It uses a certificate with a common name different to localhost\n     * and sends a request to localhost. This should fail with a SSLHandshakeException.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void simpleGetWithHostnameVerificationEnabledTest() throws Exception\n    {\n        clientSslContextFactory.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n            fail(\"sending request to client should have failed with an Exception!\");\n        }\n        catch (ExecutionException x)\n        {\n            // The test may fail in 2 ways, since the CertificateException thrown because of the hostname\n            // verification failure is not rethrown immediately by the JDK SSL implementation, but only\n            // rethrown on the next read or write.\n            // Therefore this test may catch a SSLHandshakeException, or a ClosedChannelException.\n            // If it is the former, we verify that its cause is a CertificateException.\n\n            // ExecutionException wraps an EofException that wraps the SSLHandshakeException\n            Throwable cause = x.getCause().getCause();\n            if (cause instanceof SSLHandshakeException)\n                assertThat(cause.getCause().getCause(), instanceOf(CertificateException.class));\n            else\n                assertThat(cause, instanceOf(ClosedChannelException.class));\n        }\n    }","commit_id":"92400393667236c9d4a2823e610d725af0213cd3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * This test has hostname verification disabled and connecting, ssl handshake and sending the request should just\n     * work fine.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void simpleGetWithHostnameVerificationDisabledTest() throws Exception\n    {\n        sslContextFactory.setEndpointIdentificationAlgorithm(null);\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"SSLHandshake should work just fine as hostname verification is disabled! \" + e.getMessage());\n        }\n    }","id":66337,"modified_method":"/**\n     * This test has hostname verification disabled and connecting, ssl handshake and sending the request should just\n     * work fine.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void simpleGetWithHostnameVerificationDisabledTest() throws Exception\n    {\n        clientSslContextFactory.setEndpointIdentificationAlgorithm(null);\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"SSLHandshake should work just fine as hostname verification is disabled! \" + e.getMessage());\n        }\n    }","commit_id":"92400393667236c9d4a2823e610d725af0213cd3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * This test has hostname verification disabled by setting trustAll to true and connecting,\n     * ssl handshake and sending the request should just work fine.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void trustAllDisablesHostnameVerificationTest() throws Exception\n    {\n        sslContextFactory.setTrustAll(true);\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"SSLHandshake should work just fine as hostname verification is disabled! \" + e.getMessage());\n        }\n    }","id":66338,"modified_method":"/**\n     * This test has hostname verification disabled by setting trustAll to true and connecting,\n     * ssl handshake and sending the request should just work fine.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void trustAllDisablesHostnameVerificationTest() throws Exception\n    {\n        clientSslContextFactory.setTrustAll(true);\n        String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\n        try\n        {\n            client.GET(uri);\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"SSLHandshake should work just fine as hostname verification is disabled! \" + e.getMessage());\n        }\n    }","commit_id":"92400393667236c9d4a2823e610d725af0213cd3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        if (sslContextFactory != null)\n        {\n            // keystore contains a hostname which doesn't match localhost\n            sslContextFactory.setKeyStorePath(\"src/test/resources/keystore.jks\");\n            sslContextFactory.setKeyStorePassword(\"storepwd\");\n        }\n        sslContextFactory.setEndpointIdentificationAlgorithm(\"HTTPS\");\n\n        if (server == null)\n            server = new Server();\n        connector = new ServerConnector(server, sslContextFactory);\n        server.addConnector(connector);\n        server.setHandler(new DefaultHandler()\n        {\n            @Override\n            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                response.getWriter().write(\"foobar\");\n            }\n        });\n        server.start();\n\n        QueuedThreadPool executor = new QueuedThreadPool();\n        executor.setName(executor.getName() + \"-client\");\n        client = new HttpClient(sslContextFactory);\n        client.setExecutor(executor);\n        client.start();\n    }","id":66339,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        SslContextFactory serverSslContextFactory = new SslContextFactory();\n        serverSslContextFactory.setKeyStorePath(\"src/test/resources/keystore.jks\");\n        serverSslContextFactory.setKeyStorePassword(\"storepwd\");\n        connector = new ServerConnector(server, serverSslContextFactory);\n        server.addConnector(connector);\n        server.setHandler(new DefaultHandler()\n        {\n            @Override\n            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                response.getWriter().write(\"foobar\");\n            }\n        });\n        server.start();\n\n        // keystore contains a hostname which doesn't match localhost\n        clientSslContextFactory.setKeyStorePath(\"src/test/resources/keystore.jks\");\n        clientSslContextFactory.setKeyStorePassword(\"storepwd\");\n\n        QueuedThreadPool executor = new QueuedThreadPool();\n        executor.setName(executor.getName() + \"-client\");\n        client = new HttpClient(clientSslContextFactory);\n        client.setExecutor(executor);\n        client.start();\n    }","commit_id":"92400393667236c9d4a2823e610d725af0213cd3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetConnectionKey() {\n        defaultWebsocket.setConnectionKey(null);\n        assertNull(defaultWebsocket.getConnectionKey());\n        defaultWebsocket.onOpen(connection);\n        assertNotNull(defaultWebsocket.getConnectionKey());\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        assertEquals(CONNECTION_KEY, defaultWebsocket.getConnectionKey());\n        defaultWebsocket.setConnectionKey(null);\n        assertNull(defaultWebsocket.getConnectionKey());\n    }","id":66340,"modified_method":"@Test\n    public void testGetConnectionKey() {\n        defaultWebsocket.setConnectionKey(null);\n        assertNull(defaultWebsocket.getConnectionKey());\n        defaultWebsocket.onConnect(session);\n        assertNotNull(defaultWebsocket.getConnectionKey());\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        assertEquals(CONNECTION_KEY, defaultWebsocket.getConnectionKey());\n        defaultWebsocket.setConnectionKey(null);\n        assertNull(defaultWebsocket.getConnectionKey());\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOnMessageWithNullConsumer() {\n        defaultWebsocket = new DefaultWebsocket(sync, null);\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        defaultWebsocket.onMessage(MESSAGE);\n        InOrder inOrder = inOrder(connection, consumer, sync);\n        inOrder.verify(consumer, times(0)).sendMessage(CONNECTION_KEY, MESSAGE);\n        inOrder.verifyNoMoreInteractions();\n    }","id":66341,"modified_method":"@Test\n    public void testOnMessageWithNullConsumer() {\n        defaultWebsocket = new DefaultWebsocket(sync, null);\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        defaultWebsocket.onMessage(MESSAGE);\n        InOrder inOrder = inOrder(session, consumer, sync);\n        inOrder.verify(consumer, times(0)).sendMessage(CONNECTION_KEY, MESSAGE);\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testGetConnection() {\n        assertNull(defaultWebsocket.getConnection());\n        defaultWebsocket.onOpen(connection);\n        assertEquals(connection, defaultWebsocket.getConnection());\n        defaultWebsocket.setConnection(null);\n        assertNull(defaultWebsocket.getConnection());\n        defaultWebsocket.setConnection(connection);\n        assertEquals(connection, defaultWebsocket.getConnection());\n    }","id":66342,"modified_method":"@Test\n    public void testGetConnection() {\n        assertNull(defaultWebsocket.getSession());\n        defaultWebsocket.onConnect(session);\n        assertEquals(session, defaultWebsocket.getSession());\n        defaultWebsocket.setSession(null);\n        assertNull(defaultWebsocket.getSession());\n        defaultWebsocket.setSession(session);\n        assertEquals(session, defaultWebsocket.getSession());\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOnClose() {\n        defaultWebsocket.onClose(CLOSE_CODE, MESSAGE);\n        InOrder inOrder = inOrder(connection, consumer, sync);\n        inOrder.verify(sync, times(1)).removeSocket(defaultWebsocket);\n        inOrder.verifyNoMoreInteractions();\n    }","id":66343,"modified_method":"@Test\n    public void testOnClose() {\n        defaultWebsocket.onClose(CLOSE_CODE, MESSAGE);\n        InOrder inOrder = inOrder(session, consumer, sync);\n        inOrder.verify(sync, times(1)).removeSocket(defaultWebsocket);\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOnMessage() {\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        defaultWebsocket.onMessage(MESSAGE);\n        InOrder inOrder = inOrder(connection, consumer, sync);\n        inOrder.verify(consumer, times(1)).sendMessage(CONNECTION_KEY, MESSAGE);\n        inOrder.verifyNoMoreInteractions();\n    }","id":66344,"modified_method":"@Test\n    public void testOnMessage() {\n        defaultWebsocket.setConnectionKey(CONNECTION_KEY);\n        defaultWebsocket.onMessage(MESSAGE);\n        InOrder inOrder = inOrder(session, consumer, sync);\n        inOrder.verify(consumer, times(1)).sendMessage(CONNECTION_KEY, MESSAGE);\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOnOpen() {\n        defaultWebsocket.onOpen(connection);\n\n        /*\n         * keyCaptor not functional anymore, because addSocket cannot be called with connectionKey\n         * \n         * InOrder inOrder = inOrder(connection, consumer, sync); ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class); inOrder.verify(sync,\n         * times(1)).addSocket((eq(defaultWebsocket))); inOrder.verifyNoMoreInteractions();\n         */\n\n        assertEquals(connection, defaultWebsocket.getConnection());\n    }","id":66345,"modified_method":"@Test\n    public void testOnOpen() {\n        defaultWebsocket.onConnect(session);\n\n        /*\n         * keyCaptor not functional anymore, because addSocket cannot be called with connectionKey\n         * \n         * InOrder inOrder = inOrder(connection, consumer, sync); ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class); inOrder.verify(sync,\n         * times(1)).addSocket((eq(defaultWebsocket))); inOrder.verifyNoMoreInteractions();\n         */\n\n        assertEquals(session, defaultWebsocket.getSession());\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            ObjectHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            Connector connector = staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }","id":66346,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            ObjectHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            ServerConnector connector = (ServerConnector) staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"private void enableJmx(Server server) {\n        MBeanContainer containerToRegister = getMbContainer();\n        if (containerToRegister != null) {\n            LOG.info(\"Jetty JMX Extensions is enabled\");\n            server.getContainer().addEventListener(containerToRegister);\n            // Since we may have many Servers running, don't tie the MBeanContainer\n            // to a Server lifecycle or we end up closing it while it is still in use.\n            //server.addBean(mbContainer);\n        }\n    }","id":66347,"modified_method":"private void enableJmx(Server server) {\n        MBeanContainer containerToRegister = getMbContainer();\n        if (containerToRegister != null) {\n            LOG.info(\"Jetty JMX Extensions is enabled\");\n            server.addEventListener(containerToRegister);\n            // Since we may have many Servers running, don't tie the MBeanContainer\n            // to a Server lifecycle or we end up closing it while it is still in use.\n            //server.addBean(mbContainer);\n        }\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     */\n    public void disconnect(WebsocketProducerConsumer prodcon) throws Exception {\n        // If the connector is not needed anymore then stop it\n        WebsocketEndpoint endpoint = prodcon.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    LOG.info(\"Stopping Jetty Server as the last connector is disconnecting: {}:{}\"\n                            , connectorRef.connector.getHost()\n                            , connectorRef.connector.getPort());\n                    servlets.remove(createPathSpec(endpoint.getResourceUri()));\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    if (connectorRef.connector != null) {\n                        // static server may not have set a connector\n                        connectorRef.connector.stop();\n                    }\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    CONNECTORS.remove(connectorKey);\n                    // Camel controls the lifecycle of these entities so remove the\n                    // registered MBeans when Camel is done with the managed objects.\n                    if (mbContainer != null) {\n                        mbContainer.removeBean(connectorRef.server);\n                        mbContainer.removeBean(connectorRef.connector);\n                    }\n                }\n                if (prodcon instanceof WebsocketConsumer) {\n                    connectorRef.servlet.disconnect((WebsocketConsumer) prodcon);\n                }\n                if (prodcon instanceof WebsocketProducer) {\n                    ((WebsocketProducer) prodcon).setStore(null);\n                }\n            }\n        }\n    }","id":66348,"modified_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     */\n    public void disconnect(WebsocketProducerConsumer prodcon) throws Exception {\n        // If the connector is not needed anymore then stop it\n        WebsocketEndpoint endpoint = prodcon.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    LOG.info(\"Stopping Jetty Server as the last connector is disconnecting: {}:{}\"\n                            , connectorRef.connector.getHost()\n                            , connectorRef.connector.getPort());\n                    servlets.remove(createPathSpec(endpoint.getResourceUri()));\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    if (connectorRef.connector != null) {\n                        // static server may not have set a connector\n                        connectorRef.connector.stop();\n                    }\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    CONNECTORS.remove(connectorKey);\n                    // Camel controls the lifecycle of these entities so remove the\n                    // registered MBeans when Camel is done with the managed objects.\n                    if (mbContainer != null) {\n                        mbContainer.beanRemoved(null, connectorRef.server);\n                        mbContainer.beanRemoved(null,connectorRef.connector);\n                    }\n                }\n                if (prodcon instanceof WebsocketConsumer) {\n                    connectorRef.servlet.disconnect((WebsocketConsumer) prodcon);\n                }\n                if (prodcon instanceof WebsocketProducer) {\n                    ((WebsocketProducer) prodcon).setStore(null);\n                }\n            }\n        }\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    public void connect(WebsocketProducerConsumer prodcon) throws Exception {\n\n        Server server = null;\n        WebsocketEndpoint endpoint = prodcon.getEndpoint();\n\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (endpoint.getSslContextParameters() != null) {\n                    connector = getSslSocketConnector(endpoint.getSslContextParameters());\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n\n                if (endpoint.getPort() != null) {\n                    connector.setPort(endpoint.getPort());\n                } else {\n                    connector.setPort(port);\n                }\n\n                if (endpoint.getHost() != null) {\n                    connector.setHost(endpoint.getHost());\n                } else {\n                    connector.setHost(host);\n                }\n\n                // Create Server and add connector\n                server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                server.addConnector(connector);\n                LOG.trace(\"Jetty Connector added: {}\", connector.getName());\n\n                // Create ServletContextHandler\n                ServletContextHandler context = createContext(server, connector, endpoint.getHandlers());\n                // setup the WebSocketComponentServlet initial parameters \n                setWebSocketComponentServletInitialParameter(context, endpoint);\n                server.setHandler(context);\n\n                // Apply CORS (http://www.w3.org/TR/cors/)\n                applyCrossOriginFiltering(endpoint, context);\n\n                // Create Static resources\n                if (endpoint.getStaticResources() != null) {\n                    server = createStaticResourcesServer(server, context, endpoint.getStaticResources());\n                }\n\n                MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n                \n                // Don't provide a Servlet object as Producer/Consumer will create them later on\n                connectorRef = new ConnectorRef(server, connector, null, memoryStore);\n\n                // must enable session before we start\n                if (endpoint.isSessionSupport()) {\n                    enableSessionSupport(connectorRef.server, connectorKey);\n                }\n                LOG.info(\"Jetty Server starting on host: {}:{}\", connector.getHost(), connector.getPort());\n                connectorRef.memoryStore.start();\n                connectorRef.server.start();\n\n                CONNECTORS.put(connectorKey, connectorRef);\n\n            } else {\n                connectorRef.increment();\n            }\n\n            // check the session support\n            if (endpoint.isSessionSupport()) {\n                enableSessionSupport(connectorRef.server, connectorKey);\n            }\n\n            NodeSynchronization sync = new DefaultNodeSynchronization(connectorRef.memoryStore);\n            WebsocketComponentServlet servlet = addServlet(sync, prodcon, endpoint.getResourceUri());\n            if (prodcon instanceof WebsocketConsumer) {\n                WebsocketConsumer consumer = WebsocketConsumer.class.cast(prodcon);\n                if (servlet.getConsumer() == null) {\n                    servlet.setConsumer(consumer);\n                }\n                // register the consumer here\n                servlet.connect(consumer);\n            }\n            if (prodcon instanceof WebsocketProducer) {\n                WebsocketProducer producer = WebsocketProducer.class.cast(prodcon);\n                producer.setStore(connectorRef.memoryStore);\n            }\n        }\n    }","id":66349,"modified_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    public void connect(WebsocketProducerConsumer prodcon) throws Exception {\n\n        Server server = null;\n        WebsocketEndpoint endpoint = prodcon.getEndpoint();\n\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                ServerConnector connector;\n                // Create Server and add connector\n                server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                if (endpoint.getSslContextParameters() != null) {\n                    connector = getSslSocketConnector(server, endpoint.getSslContextParameters());\n                } else {\n                    connector = new ServerConnector(server);\n                }\n\n                if (endpoint.getPort() != null) {\n                    connector.setPort(endpoint.getPort());\n                } else {\n                    connector.setPort(port);\n                }\n\n                if (endpoint.getHost() != null) {\n                    connector.setHost(endpoint.getHost());\n                } else {\n                    connector.setHost(host);\n                }\n\n                server.addConnector(connector);\n                LOG.trace(\"Jetty Connector added: {}\", connector.getName());\n\n                // Create ServletContextHandler\n                ServletContextHandler context = createContext(server, connector, endpoint.getHandlers());\n                // setup the WebSocketComponentServlet initial parameters \n                setWebSocketComponentServletInitialParameter(context, endpoint);\n                server.setHandler(context);\n\n                // Apply CORS (http://www.w3.org/TR/cors/)\n                applyCrossOriginFiltering(endpoint, context);\n\n                // Create Static resources\n                if (endpoint.getStaticResources() != null) {\n                    server = createStaticResourcesServer(server, context, endpoint.getStaticResources());\n                }\n\n                MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n                \n                // Don't provide a Servlet object as Producer/Consumer will create them later on\n                connectorRef = new ConnectorRef(server, connector, null, memoryStore);\n\n                // must enable session before we start\n                if (endpoint.isSessionSupport()) {\n                    enableSessionSupport(connectorRef.server, connectorKey);\n                }\n                LOG.info(\"Jetty Server starting on host: {}:{}\", connector.getHost(), connector.getPort());\n                connectorRef.memoryStore.start();\n                connectorRef.server.start();\n\n                CONNECTORS.put(connectorKey, connectorRef);\n\n            } else {\n                connectorRef.increment();\n            }\n\n            // check the session support\n            if (endpoint.isSessionSupport()) {\n                enableSessionSupport(connectorRef.server, connectorKey);\n            }\n\n            NodeSynchronization sync = new DefaultNodeSynchronization(connectorRef.memoryStore);\n            WebsocketComponentServlet servlet = addServlet(sync, prodcon, endpoint.getResourceUri());\n            if (prodcon instanceof WebsocketConsumer) {\n                WebsocketConsumer consumer = WebsocketConsumer.class.cast(prodcon);\n                if (servlet.getConsumer() == null) {\n                    servlet.setConsumer(consumer);\n                }\n                // register the consumer here\n                servlet.connect(consumer);\n            }\n            if (prodcon instanceof WebsocketProducer) {\n                WebsocketProducer producer = WebsocketProducer.class.cast(prodcon);\n                producer.setStore(connectorRef.memoryStore);\n            }\n        }\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"protected ServletContextHandler createContext(Server server, Connector connector, List<Handler> handlers) throws Exception {\n        ServletContextHandler context = new ServletContextHandler(server, \"/\", ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);\n        context.setConnectorNames(new String[]{connector.getName()});\n\n        if (handlers != null && !handlers.isEmpty()) {\n            for (Handler handler : handlers) {\n                if (handler instanceof HandlerWrapper) {\n                    ((HandlerWrapper) handler).setHandler(server.getHandler());\n                    server.setHandler(handler);\n                } else {\n                    HandlerCollection handlerCollection = new HandlerCollection();\n                    handlerCollection.addHandler(server.getHandler());\n                    handlerCollection.addHandler(handler);\n                    server.setHandler(handlerCollection);\n                }\n            }\n        }\n\n        return context;\n    }","id":66350,"modified_method":"protected ServletContextHandler createContext(Server server, Connector connector, List<Handler> handlers) throws Exception {\n        ServletContextHandler context = new ServletContextHandler(server, \"/\", ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);\n        server.addConnector(connector);\n\n        if (handlers != null && !handlers.isEmpty()) {\n            for (Handler handler : handlers) {\n                if (handler instanceof HandlerWrapper) {\n                    ((HandlerWrapper) handler).setHandler(server.getHandler());\n                    server.setHandler(handler);\n                } else {\n                    HandlerCollection handlerCollection = new HandlerCollection();\n                    handlerCollection.addHandler(server.getHandler());\n                    handlerCollection.addHandler(handler);\n                    server.setHandler(handlerCollection);\n                }\n            }\n        }\n\n        return context;\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"protected Server createStaticResourcesServer(ServletContextHandler context, String host, int port, String home) throws Exception {\n        Server server = new Server();\n        Connector connector = new SelectChannelConnector();\n        connector.setHost(host);\n        connector.setPort(port);\n        server.addConnector(connector);\n        return createStaticResourcesServer(server, context, home);\n    }","id":66351,"modified_method":"protected Server createStaticResourcesServer(ServletContextHandler context, String host, int port, String home) throws Exception {\n        Server server = new Server();\n        HttpConfiguration http_config = new HttpConfiguration();\n        ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(http_config));\n        connector.setHost(host);\n        connector.setPort(port);\n        server.addConnector(connector);\n        return createStaticResourcesServer(server, context, home);\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"public ConnectorRef(Server server, Connector connector, WebsocketComponentServlet servlet, MemoryWebsocketStore memoryStore) {\n            this.server = server;\n            this.connector = connector;\n            this.servlet = servlet;\n            this.memoryStore = memoryStore;\n            increment();\n        }","id":66352,"modified_method":"public ConnectorRef(Server server, ServerConnector connector, WebsocketComponentServlet servlet, MemoryWebsocketStore memoryStore) {\n            this.server = server;\n            this.connector = connector;\n            this.servlet = servlet;\n            this.memoryStore = memoryStore;\n            increment();\n        }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"private SslConnector getSslSocketConnector(SSLContextParameters sslContextParameters) throws Exception {\n        SslSelectChannelConnector sslSocketConnector = null;\n        if (sslContextParameters != null) {\n            SslContextFactory sslContextFactory = new WebSocketComponentSslContextFactory();\n            sslContextFactory.setSslContext(sslContextParameters.createSSLContext());\n            sslSocketConnector = new SslSelectChannelConnector(sslContextFactory);\n        } else {\n            sslSocketConnector = new SslSelectChannelConnector();\n            // with default null values, jetty ssl system properties\n            // and console will be read by jetty implementation\n            sslSocketConnector.getSslContextFactory().setKeyManagerPassword(sslPassword);\n            sslSocketConnector.getSslContextFactory().setKeyStorePassword(sslKeyPassword);\n            if (sslKeystore != null) {\n                sslSocketConnector.getSslContextFactory().setKeyStorePath(sslKeystore);\n            }\n\n        }\n        return sslSocketConnector;\n    }","id":66353,"modified_method":"private ServerConnector getSslSocketConnector(Server server, SSLContextParameters sslContextParameters) throws Exception {\n        ServerConnector sslSocketConnector = null;\n        if (sslContextParameters != null) {\n            SslContextFactory sslContextFactory = new WebSocketComponentSslContextFactory();\n            sslContextFactory.setSslContext(sslContextParameters.createSSLContext());\n            sslSocketConnector = new ServerConnector(server, sslContextFactory);\n        } else {\n            SslContextFactory sslContextFactory = new SslContextFactory();\n            sslContextFactory.setKeyStorePassword(sslKeyPassword);\n            sslContextFactory.setKeyManagerPassword(sslPassword);\n            if (sslKeystore != null) {\n            \tsslContextFactory.setKeyStorePath(sslKeystore);\n            }\n            sslSocketConnector = new ServerConnector(server, sslContextFactory);\n\n        }\n        return sslSocketConnector;\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"public synchronized MBeanContainer getMbContainer() {\n        // If null, provide the default implementation.\n        if (mbContainer == null) {\n            MBeanServer mbs = null;\n\n            final ManagementStrategy mStrategy = this.getCamelContext().getManagementStrategy();\n            final ManagementAgent mAgent = mStrategy.getManagementAgent();\n            if (mAgent != null) {\n                mbs = mAgent.getMBeanServer();\n            }\n\n            if (mbs != null) {\n                mbContainer = new MBeanContainer(mbs);\n                startMbContainer();\n            } else {\n                LOG.warn(\"JMX disabled in CamelContext. Jetty JMX extensions will remain disabled.\");\n            }\n        }\n\n        return this.mbContainer;\n    }","id":66354,"modified_method":"public synchronized MBeanContainer getMbContainer() {\n        // If null, provide the default implementation.\n        if (mbContainer == null) {\n            mbContainer=new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n        }\n\n        return this.mbContainer;\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"protected Server createServer() throws Exception {\n        Server server = new Server();\n        ContextHandlerCollection collection = new ContextHandlerCollection();\n        server.setHandler(collection);\n\n        // configure thread pool if min/max given\n        if (minThreads != null || maxThreads != null) {\n            if (getThreadPool() != null) {\n                throw new IllegalArgumentException(\"You cannot configure both minThreads/maxThreads and a custom threadPool on JettyHttpComponent: \" + this);\n            }\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            if (minThreads != null) {\n                qtp.setMinThreads(minThreads.intValue());\n            }\n            if (maxThreads != null) {\n                qtp.setMaxThreads(maxThreads.intValue());\n            }\n            // let the thread names indicate they are from the server\n            qtp.setName(\"CamelJettyWebSocketServer(\" + ObjectHelper.getIdentityHashCode(server) + \")\");\n            try {\n                qtp.start();\n            } catch (Exception e) {\n                throw new RuntimeCamelException(\"Error starting JettyWebSocketServer thread pool: \" + qtp, e);\n            }\n            server.setThreadPool(qtp);\n        }\n\n        if (getThreadPool() != null) {\n            server.setThreadPool(getThreadPool());\n        }\n\n        return server;\n    }","id":66355,"modified_method":"protected Server createServer() throws Exception {\n        Server server = null;\n\n        // configure thread pool if min/max given\n        if (minThreads != null || maxThreads != null) {\n            if (getThreadPool() != null) {\n                throw new IllegalArgumentException(\"You cannot configure both minThreads/maxThreads and a custom threadPool on JettyHttpComponent: \" + this);\n            }\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            if (minThreads != null) {\n                qtp.setMinThreads(minThreads.intValue());\n            }\n            if (maxThreads != null) {\n                qtp.setMaxThreads(maxThreads.intValue());\n            }\n            // let the thread names indicate they are from the server\n            qtp.setName(\"CamelJettyWebSocketServer(\" + ObjectHelper.getIdentityHashCode(server) + \")\");\n            try {\n                qtp.start();\n            } catch (Exception e) {\n                throw new RuntimeCamelException(\"Error starting JettyWebSocketServer thread pool: \" + qtp, e);\n            }\n            server = new Server(qtp);\n            ContextHandlerCollection collection = new ContextHandlerCollection();\n            server.setHandler(collection);\n        }\n\n        if (getThreadPool() != null) {\n            server = new Server(getThreadPool());\n            ContextHandlerCollection collection = new ContextHandlerCollection();\n            server.setHandler(collection);\n        }\n\n        return server;\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"void sendMessage(DefaultWebsocket websocket, Object message) throws IOException {\n        // in case there is web socket and socket connection is open - send message\n        if (websocket != null && websocket.getConnection().isOpen()) {\n            log.trace(\"Sending to websocket {} -> {}\", websocket.getConnectionKey(), message);\n            if (message instanceof String) {\n                websocket.getConnection().sendMessage((String) message);\n            } else if (message instanceof byte[]) {\n                websocket.getConnection().sendMessage((byte[]) message, 0, ((byte[]) message).length);\n            }\n        }\n    }","id":66356,"modified_method":"void sendMessage(DefaultWebsocket websocket, Object message) throws IOException {\n        // in case there is web socket and socket connection is open - send message\n        if (websocket != null && websocket.getSession().isOpen()) {\n            log.trace(\"Sending to websocket {} -> {}\", websocket.getConnectionKey(), message);\n            if (message instanceof String) {\n                websocket.getSession().getRemote().sendString((String) message);\n            } else if (message instanceof byte[]) {\n            \tByteBuffer buf = ByteBuffer.wrap((byte[]) message);\n                websocket.getSession().getRemote().sendBytes(buf);\n            }\n        }\n    }","commit_id":"51ca71eb72604965ad70b5c65d82e91705ebc6af","url":"https://github.com/apache/camel"},{"original_method":"public ConnectorRef(Connector connector, CometdServlet servlet, Server server) {\n            this.connector = connector;\n            this.servlet = servlet;\n            this.server = server;\n            increment();\n        }","id":66357,"modified_method":"public ConnectorRef(Connector connector, CometDServlet servlet, Server server) {\n            this.connector = connector;\n            this.servlet = servlet;\n            this.server = server;\n            increment();\n        }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"protected CometdServlet createServletForConnector(Server server, Connector connector, CometdEndpoint endpoint) throws Exception {\n        CometdServlet servlet = new CometdServlet();\n\n        ServletContextHandler context = new ServletContextHandler(server, \"/\", ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);\n        context.setConnectorNames(new String[]{connector.getName()});\n\n        ServletHolder holder = new ServletHolder();\n        holder.setServlet(servlet);\n        holder.setAsyncSupported(true);\n\n        // Use baseResource to pass as a parameter the url\n        // pointing to by example classpath:webapp\n        if (endpoint.getBaseResource() != null) {\n            String[] resources = endpoint.getBaseResource().split(\":\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\">>> Protocol found: \" + resources[0] + \", and resource: \" + resources[1]);\n            }\n\n            if (resources[0].equals(\"file\")) {\n                context.setBaseResource(Resource.newResource(resources[1]));\n            } else if (resources[0].equals(\"classpath\")) {\n                // Create a URL handler using classpath protocol\n                URL url = this.getCamelContext().getClassResolver().loadResourceAsURL(resources[1]);\n                context.setBaseResource(Resource.newResource(url));\n            }\n        }\n\n        applyCrossOriginFiltering(endpoint, context);\n\n        context.addServlet(holder, \"/cometd/*\");\n        context.addServlet(\"org.eclipse.jetty.servlet.DefaultServlet\", \"/\");\n        context.setSessionHandler(new SessionHandler(new HashSessionManager()));\n\n        holder.setInitParameter(\"timeout\", Integer.toString(endpoint.getTimeout()));\n        holder.setInitParameter(\"interval\", Integer.toString(endpoint.getInterval()));\n        holder.setInitParameter(\"maxInterval\", Integer.toString(endpoint.getMaxInterval()));\n        holder.setInitParameter(\"multiFrameInterval\", Integer.toString(endpoint.getMultiFrameInterval()));\n        holder.setInitParameter(\"JSONCommented\", Boolean.toString(endpoint.isJsonCommented()));\n        holder.setInitParameter(\"logLevel\", Integer.toString(endpoint.getLogLevel()));\n\n        return servlet;\n    }","id":66358,"modified_method":"protected CometDServlet createServletForConnector(Server server, Connector connector, CometdEndpoint endpoint) throws Exception {\n    \tCometDServlet servlet = new CometDServlet();\n\n        ServletContextHandler context = new ServletContextHandler(server, \"/\", ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);\n\n        ServletHolder holder = new ServletHolder();\n        holder.setServlet(servlet);\n        holder.setAsyncSupported(true);\n\n        // Use baseResource to pass as a parameter the url\n        // pointing to by example classpath:webapp\n        if (endpoint.getBaseResource() != null) {\n            String[] resources = endpoint.getBaseResource().split(\":\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\">>> Protocol found: \" + resources[0] + \", and resource: \" + resources[1]);\n            }\n\n            if (resources[0].equals(\"file\")) {\n                context.setBaseResource(Resource.newResource(resources[1]));\n            } else if (resources[0].equals(\"classpath\")) {\n                // Create a URL handler using classpath protocol\n                URL url = this.getCamelContext().getClassResolver().loadResourceAsURL(resources[1]);\n                context.setBaseResource(Resource.newResource(url));\n            }\n        }\n\n        applyCrossOriginFiltering(endpoint, context);\n\n        context.addServlet(holder, \"/cometd/*\");\n        context.addServlet(\"org.eclipse.jetty.servlet.DefaultServlet\", \"/\");\n        context.setSessionHandler(new SessionHandler(new HashSessionManager()));\n\n        holder.setInitParameter(\"timeout\", Integer.toString(endpoint.getTimeout()));\n        holder.setInitParameter(\"interval\", Integer.toString(endpoint.getInterval()));\n        holder.setInitParameter(\"maxInterval\", Integer.toString(endpoint.getMaxInterval()));\n        holder.setInitParameter(\"multiFrameInterval\", Integer.toString(endpoint.getMultiFrameInterval()));\n        holder.setInitParameter(\"JSONCommented\", Boolean.toString(endpoint.isJsonCommented()));\n        holder.setInitParameter(\"logLevel\", Integer.toString(endpoint.getLogLevel()));\n\n        return servlet;\n    }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"protected SslConnector getSslSocketConnector() {\n        SslSelectChannelConnector sslSocketConnector = null;\n        if (sslContextParameters != null) {\n            SslContextFactory sslContextFactory = new CometdComponentSslContextFactory();\n            try {\n                sslContextFactory.setSslContext(sslContextParameters.createSSLContext());\n            } catch (Exception e) {\n                throw new RuntimeCamelException(\"Error initiating SSLContext.\", e);\n            }\n            sslSocketConnector = new SslSelectChannelConnector(sslContextFactory);\n        } else {\n\n            sslSocketConnector = new SslSelectChannelConnector();\n            // with default null values, jetty ssl system properties\n            // and console will be read by jetty implementation\n            sslSocketConnector.getSslContextFactory().setKeyManagerPassword(sslPassword);\n            sslSocketConnector.getSslContextFactory().setKeyStorePassword(sslKeyPassword);\n            if (sslKeystore != null) {\n                sslSocketConnector.getSslContextFactory().setKeyStorePath(sslKeystore);\n            }\n\n        }\n\n        return sslSocketConnector;\n    }","id":66359,"modified_method":"protected ServerConnector getSslSocketConnector(Server server) throws Exception {\n        ServerConnector sslSocketConnector = null;\n        if (sslContextParameters != null) {\n            SslContextFactory sslContextFactory = new CometdComponentSslContextFactory();\n            sslContextFactory.setSslContext(sslContextParameters.createSSLContext());\n            sslSocketConnector = new ServerConnector(server, sslContextFactory);\n        } else {\n            SslContextFactory sslContextFactory = new SslContextFactory();\n            sslContextFactory.setKeyStorePassword(sslKeyPassword);\n            sslContextFactory.setKeyManagerPassword(sslPassword);\n            if (sslKeystore != null) {\n                sslContextFactory.setKeyStorePath(sslKeystore);\n            }\n            sslSocketConnector = new ServerConnector(server, sslContextFactory);\n\n        }\n        return sslSocketConnector;\n    }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    public void connect(CometdProducerConsumer prodcon) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        CometdEndpoint endpoint = prodcon.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"cometds\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector();\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                            + \" Don't you want to use 0.0.0.0 instead (all network interfaces)?\");\n                }\n                Server server = createServer();\n                server.addConnector(connector);\n\n                CometdServlet servlet = createServletForConnector(server, connector, endpoint);\n                connectorRef = new ConnectorRef(connector, servlet, server);\n                server.start();\n\n                connectors.put(connectorKey, connectorRef);\n            } else {\n                connectorRef.increment();\n            }\n\n            BayeuxServerImpl bayeux = connectorRef.servlet.getBayeux();\n\n            if (securityPolicy != null) {\n                bayeux.setSecurityPolicy(securityPolicy);\n            }\n            if (extensions != null) {\n                for (BayeuxServer.Extension extension : extensions) {\n                    bayeux.addExtension(extension);\n                }\n            }\n            if (serverListeners != null) {\n                for (BayeuxServer.BayeuxServerListener serverListener : serverListeners) {\n                    bayeux.addListener(serverListener);\n                }\n            }\n            prodcon.setBayeux(bayeux);\n        }\n    }","id":66360,"modified_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    public void connect(CometdProducerConsumer prodcon) throws Exception {\n    \tServer server = null;\n        // Make sure that there is a connector for the requested endpoint.\n        CometdEndpoint endpoint = prodcon.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef == null) {\n                ServerConnector connector;\n                server = createServer();\n                if (\"cometds\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector(server);\n                } else {\n                    connector = new ServerConnector(server);\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                            + \" Don't you want to use 0.0.0.0 instead (all network interfaces)?\");\n                }\n                \n                server.addConnector(connector);\n\n                CometDServlet servlet = createServletForConnector(server, connector, endpoint);\n                connectorRef = new ConnectorRef(connector, servlet, server);\n                server.start();\n\n                connectors.put(connectorKey, connectorRef);\n            } else {\n                connectorRef.increment();\n            }\n\n            BayeuxServerImpl bayeux = connectorRef.servlet.getBayeux();\n\n            if (securityPolicy != null) {\n                bayeux.setSecurityPolicy(securityPolicy);\n            }\n            if (extensions != null) {\n                for (BayeuxServer.Extension extension : extensions) {\n                    bayeux.addExtension(extension);\n                }\n            }\n            if (serverListeners != null) {\n                for (BayeuxServer.BayeuxServerListener serverListener : serverListeners) {\n                    bayeux.addListener(serverListener);\n                }\n            }\n            prodcon.setBayeux(bayeux);\n        }\n    }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"public ConsumerService(String channel, BayeuxServerImpl bayeux, CometdConsumer consumer) {\n            super(bayeux, channel);\n            this.endpoint = consumer.getEndpoint();\n            this.binding = createBinding(bayeux);\n            this.consumer = consumer;\n            addService(channel, \"push\");\n        }","id":66361,"modified_method":"public ConsumerService(String channel, BayeuxServerImpl bayeux, CometdConsumer consumer) {\n            super(bayeux, channel);\n            this.endpoint = consumer.getEndpoint();\n            this.binding = createBinding(bayeux);\n            this.consumer = consumer;\n            this.channelName = channel;\n            addService(channel, \"push\");\n        }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"public void push(ServerSession remote, String channelName, ServerMessage cometdMessage, String messageId) throws Exception {\n            Object data = null;\n\n            Message message = binding.createCamelMessage(remote, cometdMessage, data);\n\n            Exchange exchange = endpoint.createExchange();\n            exchange.setIn(message);\n\n            consumer.getProcessor().process(exchange);\n\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                ServerChannel channel = getBayeux().getChannel(channelName);\n                ServerSession serverSession = getServerSession();\n\n                ServerMessage.Mutable outMessage = binding.createCometdMessage(channel, serverSession, exchange.getOut());\n                remote.deliver(serverSession, outMessage);\n            }\n        }","id":66362,"modified_method":"public void push(ServerSession remote, ServerMessage cometdMessage) throws Exception {\n            Object data = null;\n\n            Message message = binding.createCamelMessage(remote, cometdMessage, data);\n\n            Exchange exchange = endpoint.createExchange();\n            exchange.setIn(message);\n\n            consumer.getProcessor().process(exchange);\n\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                ServerChannel channel = getBayeux().getChannel(channelName);\n                ServerSession serverSession = getServerSession();\n\n                ServerMessage.Mutable outMessage = binding.createCometdMessage(channel, serverSession, exchange.getOut());\n                remote.deliver(serverSession, outMessage);\n            }\n        }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void before() {\n        when(bayeuxServerImpl.newLocalSession(anyString())).thenReturn(localSession);\n        when(bayeuxServerImpl.getLogger()).thenReturn(logger);\n        when(bayeuxServerImpl.getChannel(anyString())).thenReturn(serverChannel);\n\n        testObj = new CometdConsumer(endpoint, processor);\n        testObj.setBayeux(bayeuxServerImpl);\n        \n        Set<String> attributeNames = new HashSet<String>();\n        String attributeKey = USER_NAME;\n        attributeNames.add(attributeKey);\n        when(remote.getAttributeNames()).thenReturn(attributeNames);\n        when(remote.getAttribute(attributeKey)).thenReturn(MEMEBER_USER_NAME);\n    }","id":66363,"modified_method":"@Before\n    public void before() {\n        when(bayeuxServerImpl.newLocalSession(anyString())).thenReturn(localSession);\n        //when(bayeuxServerImpl.get).thenReturn(logger);\n        when(bayeuxServerImpl.getChannel(anyString())).thenReturn(serverChannel);\n        when(bayeuxServerImpl.createChannelIfAbsent(anyString())).thenReturn(markedReferenceServerChannel);\n        when(markedReferenceServerChannel.getReference()).thenReturn(serverChannel);\n\n        testObj = new CometdConsumer(endpoint, processor);\n        testObj.setBayeux(bayeuxServerImpl);\n        \n        Set<String> attributeNames = new HashSet<String>();\n        String attributeKey = USER_NAME;\n        attributeNames.add(attributeKey);\n        when(remote.getAttributeNames()).thenReturn(attributeNames);\n        when(remote.getAttribute(attributeKey)).thenReturn(MEMEBER_USER_NAME);\n    }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSessionHeadersAdded() throws Exception {\n        // setup\n        when(endpoint.isSessionHeadersEnabled()).thenReturn(true);\n        testObj.start();\n        ServerMessage cometdMessage = mock(ServerMessage.class);\n        Exchange exchange = mock(Exchange.class);\n        when(endpoint.createExchange()).thenReturn(exchange);\n        ArgumentCaptor<Message> transferredMessage = ArgumentCaptor.forClass(Message.class);\n\n        // act\n        testObj.getConsumerService().push(remote, \"channelName\", cometdMessage, \"messageId\");\n\n        // verify\n        verify(exchange).setIn(transferredMessage.capture());\n        Message message = transferredMessage.getValue();\n        assertEquals(MEMEBER_USER_NAME, message.getHeader(USER_NAME));\n    }","id":66364,"modified_method":"@Test\n    public void testSessionHeadersAdded() throws Exception {\n        // setup\n        when(endpoint.isSessionHeadersEnabled()).thenReturn(true);\n        testObj.start();\n        ServerMessage cometdMessage = mock(ServerMessage.class);\n        Exchange exchange = mock(Exchange.class);\n        when(endpoint.createExchange()).thenReturn(exchange);\n        ArgumentCaptor<Message> transferredMessage = ArgumentCaptor.forClass(Message.class);\n\n        // act\n        testObj.getConsumerService().push(remote, cometdMessage);\n\n        // verify\n        verify(exchange).setIn(transferredMessage.capture());\n        Message message = transferredMessage.getValue();\n        assertEquals(MEMEBER_USER_NAME, message.getHeader(USER_NAME));\n    }","commit_id":"2a2505f69c5676d77601342fcbcceaed4850fd5a","url":"https://github.com/apache/camel"},{"original_method":"protected void prepareExchangeAfterFailure(final Exchange exchange, final RedeliveryData data,\n                                               final boolean shouldHandle, final boolean shouldContinue) {\n        // we could not process the exchange so we let the failure processor handled it\n        ExchangeHelper.setFailureHandled(exchange);\n\n        // honor if already set a handling\n        boolean alreadySet = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED) != null;\n        if (alreadySet) {\n            boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class);\n            log.trace(\"This exchange has already been marked for handling: {}\", handled);\n            if (handled) {\n                exchange.setException(null);\n            } else {\n                // exception not handled, put exception back in the exchange\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n                // and put failure endpoint back as well\n                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            }\n            return;\n        }\n\n        if (shouldHandle) {\n            log.trace(\"This exchange is handled so its marked as not failed: {}\", exchange);\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.TRUE);\n        } else if (shouldContinue) {\n            log.trace(\"This exchange is continued: {}\", exchange);\n            // okay we want to continue then prepare the exchange for that as well\n            prepareExchangeForContinue(exchange, data);\n        } else {\n            log.trace(\"This exchange is not handled or continued so its marked as failed: {}\", exchange);\n            // exception not handled, put exception back in the exchange\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.FALSE);\n            exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n            // and put failure endpoint back as well\n            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            // and store the route id so we know in which route we failed\n            if (exchange.getUnitOfWork().getRouteContext() != null) {\n                exchange.setProperty(Exchange.FAILURE_ROUTE_ID, exchange.getUnitOfWork().getRouteContext().getRoute().getId());\n            }\n        }\n    }","id":66365,"modified_method":"protected void prepareExchangeAfterFailure(final Exchange exchange, final RedeliveryData data,\n                                               final boolean shouldHandle, final boolean shouldContinue) {\n        // we could not process the exchange so we let the failure processor handled it\n        ExchangeHelper.setFailureHandled(exchange);\n\n        // honor if already set a handling\n        boolean alreadySet = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED) != null;\n        if (alreadySet) {\n            boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class);\n            log.trace(\"This exchange has already been marked for handling: {}\", handled);\n            if (handled) {\n                exchange.setException(null);\n            } else {\n                // exception not handled, put exception back in the exchange\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n                // and put failure endpoint back as well\n                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            }\n            return;\n        }\n\n        if (shouldHandle) {\n            log.trace(\"This exchange is handled so its marked as not failed: {}\", exchange);\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.TRUE);\n        } else if (shouldContinue) {\n            log.trace(\"This exchange is continued: {}\", exchange);\n            // okay we want to continue then prepare the exchange for that as well\n            prepareExchangeForContinue(exchange, data);\n        } else {\n            log.trace(\"This exchange is not handled or continued so its marked as failed: {}\", exchange);\n            // exception not handled, put exception back in the exchange\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.FALSE);\n            exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n            // and put failure endpoint back as well\n            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            // and store the route id so we know in which route we failed\n            UnitOfWork uow = exchange.getUnitOfWork();\n            if (uow != null && uow.getRouteContext() != null) {\n                exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId());\n            }\n        }\n    }","commit_id":"03af89fe232ad524c346262a4a57b173a542e69b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * All redelivery attempts failed so move the exchange to the dead letter queue\n     */\n    protected boolean deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange,\n                                                final RedeliveryData data, final AsyncCallback callback) {\n        boolean sync = true;\n\n        Exception caught = exchange.getException();\n\n        // we did not success with the redelivery so now we let the failure processor handle it\n        // clear exception as we let the failure processor handle it\n        exchange.setException(null);\n\n        // always handle if dead letter channel\n        final boolean shouldHandle = isDeadLetterChannel || shouldHandled(exchange, data);\n        final boolean shouldContinue = shouldContinue(exchange, data);\n        // regard both handled or continued as being handled\n        boolean handled = false;\n\n        if (shouldHandle || shouldContinue) {\n            // its handled then remove traces of redelivery attempted\n            exchange.getIn().removeHeader(Exchange.REDELIVERED);\n            exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n            exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n\n            // and remove traces of rollback only and uow exhausted markers\n            exchange.removeProperty(Exchange.ROLLBACK_ONLY);\n            exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED);\n\n            handled = true;\n        } else {\n            // must decrement the redelivery counter as we didn't process the redelivery but is\n            // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n            decrementRedeliveryCounter(exchange);\n        }\n\n        // is the a failure processor to process the Exchange\n        if (processor != null) {\n\n            // prepare original IN body if it should be moved instead of current body\n            if (data.useOriginalInMessage) {\n                log.trace(\"Using the original IN message instead of current\");\n                Message original = exchange.getUnitOfWork().getOriginalInMessage();\n                exchange.setIn(original);\n                if (exchange.hasOut()) {\n                    log.trace(\"Removing the out message to avoid some uncertain behavior\");\n                    exchange.setOut(null);\n                }\n            }\n\n            // reset cached streams so they can be read again\n            MessageHelper.resetStreamCache(exchange.getIn());\n\n            log.trace(\"Failure processor {} is processing Exchange: {}\", processor, exchange);\n\n            // store the last to endpoint as the failure endpoint\n            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            // and store the route id so we know in which route we failed\n            if (exchange.getUnitOfWork().getRouteContext() != null) {\n                exchange.setProperty(Exchange.FAILURE_ROUTE_ID, exchange.getUnitOfWork().getRouteContext().getRoute().getId());\n            }\n\n            // the failure processor could also be asynchronous\n            AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor);\n            sync = afp.process(exchange, new AsyncCallback() {\n                public void done(boolean sync) {\n                    log.trace(\"Failure processor done: {} processing Exchange: {}\", processor, exchange);\n                    try {\n                        prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);\n                        // fire event as we had a failure processor to handle it, which there is a event for\n                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                    } finally {\n                        // if the fault was handled asynchronously, this should be reflected in the callback as well\n                        data.sync &= sync;\n                        callback.done(data.sync);\n                    }\n                }\n            });\n        } else {\n            try {\n                // no processor but we need to prepare after failure as well\n                prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);\n            } finally {\n                // callback we are done\n                callback.done(data.sync);\n            }\n        }\n\n        // create log message\n        String msg = \"Failed delivery for \" + ExchangeHelper.logIds(exchange);\n        msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n        if (processor != null) {\n            msg = msg + \". Processed by failure processor: \" + processor;\n        }\n\n        // log that we failed delivery as we are exhausted\n        logFailedDelivery(false, handled, false, exchange, msg, data, null);\n\n        return sync;\n    }","id":66366,"modified_method":"/**\n     * All redelivery attempts failed so move the exchange to the dead letter queue\n     */\n    protected boolean deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange,\n                                                final RedeliveryData data, final AsyncCallback callback) {\n        boolean sync = true;\n\n        Exception caught = exchange.getException();\n\n        // we did not success with the redelivery so now we let the failure processor handle it\n        // clear exception as we let the failure processor handle it\n        exchange.setException(null);\n\n        // always handle if dead letter channel\n        final boolean shouldHandle = isDeadLetterChannel || shouldHandled(exchange, data);\n        final boolean shouldContinue = shouldContinue(exchange, data);\n        // regard both handled or continued as being handled\n        boolean handled = false;\n\n        if (shouldHandle || shouldContinue) {\n            // its handled then remove traces of redelivery attempted\n            exchange.getIn().removeHeader(Exchange.REDELIVERED);\n            exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n            exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n\n            // and remove traces of rollback only and uow exhausted markers\n            exchange.removeProperty(Exchange.ROLLBACK_ONLY);\n            exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED);\n\n            handled = true;\n        } else {\n            // must decrement the redelivery counter as we didn't process the redelivery but is\n            // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n            decrementRedeliveryCounter(exchange);\n        }\n\n        // is the a failure processor to process the Exchange\n        if (processor != null) {\n\n            // prepare original IN body if it should be moved instead of current body\n            if (data.useOriginalInMessage) {\n                log.trace(\"Using the original IN message instead of current\");\n                Message original = exchange.getUnitOfWork().getOriginalInMessage();\n                exchange.setIn(original);\n                if (exchange.hasOut()) {\n                    log.trace(\"Removing the out message to avoid some uncertain behavior\");\n                    exchange.setOut(null);\n                }\n            }\n\n            // reset cached streams so they can be read again\n            MessageHelper.resetStreamCache(exchange.getIn());\n\n            log.trace(\"Failure processor {} is processing Exchange: {}\", processor, exchange);\n\n            // store the last to endpoint as the failure endpoint\n            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n            // and store the route id so we know in which route we failed\n            UnitOfWork uow = exchange.getUnitOfWork();\n            if (uow != null && uow.getRouteContext() != null) {\n                exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId());\n            }\n\n            // the failure processor could also be asynchronous\n            AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor);\n            sync = afp.process(exchange, new AsyncCallback() {\n                public void done(boolean sync) {\n                    log.trace(\"Failure processor done: {} processing Exchange: {}\", processor, exchange);\n                    try {\n                        prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);\n                        // fire event as we had a failure processor to handle it, which there is a event for\n                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                    } finally {\n                        // if the fault was handled asynchronously, this should be reflected in the callback as well\n                        data.sync &= sync;\n                        callback.done(data.sync);\n                    }\n                }\n            });\n        } else {\n            try {\n                // no processor but we need to prepare after failure as well\n                prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);\n            } finally {\n                // callback we are done\n                callback.done(data.sync);\n            }\n        }\n\n        // create log message\n        String msg = \"Failed delivery for \" + ExchangeHelper.logIds(exchange);\n        msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n        if (processor != null) {\n            msg = msg + \". Processed by failure processor: \" + processor;\n        }\n\n        // log that we failed delivery as we are exhausted\n        logFailedDelivery(false, handled, false, exchange, msg, data, null);\n\n        return sync;\n    }","commit_id":"01957e8ab1fe83f2e7322cff5eebaf30607500cd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Calls the async version of the processor's process method.\n     * <p/>\n     * This implementation supports transacted {@link Exchange}s which ensure those are run in a synchronous fashion.\n     * See more details at {@link org.apache.camel.AsyncProcessor}.\n     *\n     * @param processor the processor\n     * @param exchange  the exchange\n     * @param callback  the callback\n     * @return <tt>true<\/tt> to continue execute synchronously, <tt>false<\/tt> to continue being executed asynchronously\n     */\n    public static boolean process(final AsyncProcessor processor, final Exchange exchange, final AsyncCallback callback) {\n        boolean sync;\n\n        if (exchange.isTransacted()) {\n            // must be synchronized for transacted exchanges\n            LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            try {\n                process(processor, exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            callback.done(true);\n            sync = true;\n        } else {\n            // allow unit of work to wrap callback in case it need to do some special work\n            // for example the MDCUnitOfWork\n            AsyncCallback async = callback;\n            if (exchange.getUnitOfWork() != null) {\n                async = exchange.getUnitOfWork().beforeProcess(processor, exchange, callback);\n            }\n\n            // we support asynchronous routing so invoke it\n            sync = processor.process(exchange, async);\n\n            // execute any after processor work\n            if (exchange.getUnitOfWork() != null) {\n                exchange.getUnitOfWork().afterProcess(processor, exchange, callback, sync);\n            }\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exchange processed and is continued routed {} for exchangeId: {} -> {}\",\n                    new Object[]{sync ? \"synchronously\" : \"asynchronously\", exchange.getExchangeId(), exchange});\n        }\n        return sync;\n    }","id":66367,"modified_method":"/**\n     * Calls the async version of the processor's process method.\n     * <p/>\n     * This implementation supports transacted {@link Exchange}s which ensure those are run in a synchronous fashion.\n     * See more details at {@link org.apache.camel.AsyncProcessor}.\n     *\n     * @param processor the processor\n     * @param exchange  the exchange\n     * @param callback  the callback\n     * @return <tt>true<\/tt> to continue execute synchronously, <tt>false<\/tt> to continue being executed asynchronously\n     */\n    public static boolean process(final AsyncProcessor processor, final Exchange exchange, final AsyncCallback callback) {\n        boolean sync;\n\n        if (exchange.isTransacted()) {\n            // must be synchronized for transacted exchanges\n            LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            try {\n                process(processor, exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            callback.done(true);\n            sync = true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            // allow unit of work to wrap callback in case it need to do some special work\n            // for example the MDCUnitOfWork\n            AsyncCallback async = callback;\n            if (uow != null) {\n                async = uow.beforeProcess(processor, exchange, callback);\n            }\n\n            // we support asynchronous routing so invoke it\n            sync = processor.process(exchange, async);\n\n            // execute any after processor work (in current thread, not in the callback)\n            if (uow != null) {\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exchange processed and is continued routed {} for exchangeId: {} -> {}\",\n                    new Object[]{sync ? \"synchronously\" : \"asynchronously\", exchange.getExchangeId(), exchange});\n        }\n        return sync;\n    }","commit_id":"7e39c2b17dd6a1edb498371f7d0a54faf35c6651","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  @Nullable\n  public ConceptPresentation getDescriptor(SAbstractConcept c) {\n    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) LanguageRegistry.getInstance().getLanguage(MetaAdapterFactory.getLanguage(SLanguageId.deserialize(\"817e4e70-961e-4a95-98a1-15e9f32231f1\"), \"jetbrains.mps.ide.httpsupport\")).getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);\n    switch (structureDescriptor.internalIndex(c)) {\n      case 0:\n        return props_CanHandleRequestFunction;\n      case 1:\n        return props_HandleRequestFunction;\n      case 2:\n        return props_HttpRequestParameter;\n      case 3:\n        return props_QueryParameter;\n      case 4:\n        return props_QueryParameterReference;\n      case 5:\n        return props_RequestHandler;\n      case 6:\n        return props_ResponseSendStatement;\n    }\n    throw new IllegalStateException();\n  }","id":66368,"modified_method":"@Override\n  @Nullable\n  public ConceptPresentation getDescriptor(SAbstractConcept c) {\n    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) LanguageRegistry.getInstance().getLanguage(MetaAdapterFactory.getLanguage(SLanguageId.deserialize(\"817e4e70-961e-4a95-98a1-15e9f32231f1\"), \"jetbrains.mps.ide.httpsupport\")).getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);\n    switch (structureDescriptor.internalIndex(c)) {\n      case 0:\n        return props_CanHandleRequestFunction;\n      case 1:\n        return props_HandleRequestFunction;\n      case 2:\n        return props_HttpRequestOperation;\n      case 3:\n        return props_HttpRequestParameter;\n      case 4:\n        return props_QueryParameter;\n      case 5:\n        return props_QueryParameterReference;\n      case 6:\n        return props_RequestHandler;\n      case 7:\n        return props_ResponseSendOperation;\n    }\n    throw new IllegalStateException();\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = concept;\n      Integer preIndex = indices_2qnle6_a0c.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return new QueryParameterReference_Constraints();\n          }\n          break;\n        case 1:\n          if (true) {\n            return new RequestHandler_Constraints();\n          }\n          break;\n        case 2:\n          if (true) {\n            return new ResponseSendStatement_Constraints();\n          }\n          break;\n        default:\n          // default \n      }\n    }\n    return new BaseConstraintsDescriptor(concept);\n  }","id":66369,"modified_method":"@Override\n  public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = concept;\n      Integer preIndex = indices_2qnle6_a0c.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return new HttpRequestOperation_Constraints();\n          }\n          break;\n        case 1:\n          if (true) {\n            return new QueryParameterReference_Constraints();\n          }\n          break;\n        case 2:\n          if (true) {\n            return new RequestHandler_Constraints();\n          }\n          break;\n        default:\n          // default \n      }\n    }\n    return new BaseConstraintsDescriptor(concept);\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public Collection<IDataFlowBuilder> getDataFlowBuilders(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = ((SAbstractConcept) concept);\n      Integer preIndex = indices_vhxjlb_a0b.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return Collections.<IDataFlowBuilder>singletonList(new ResponseSendStatement_DataFlow());\n          }\n          break;\n        default:\n          // default \n      }\n    }\n    return Collections.<IDataFlowBuilder>emptyList();\n  }","id":66370,"modified_method":"@NotNull\n  @Override\n  public Collection<IDataFlowBuilder> getDataFlowBuilders(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = ((SAbstractConcept) concept);\n      Integer preIndex = indices_vhxjlb_a0b.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return Collections.<IDataFlowBuilder>singletonList(new ResponseSendOperation_DataFlow());\n          }\n          break;\n        default:\n          // default \n      }\n    }\n    return Collections.<IDataFlowBuilder>emptyList();\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Collection<ConceptEditor> getDeclaredEditors(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = ((SAbstractConcept) concept);\n      Integer preIndex = indices_xbvbvu_a0a.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new QueryParameter_Editor());\n          }\n          break;\n        case 1:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new QueryParameterReference_Editor());\n          }\n          break;\n        case 2:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new RequestHandler_Editor());\n          }\n          break;\n        case 3:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new ResponseSendStatement_Editor());\n          }\n          break;\n        default:\n      }\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","id":66371,"modified_method":"@NotNull\n  public Collection<ConceptEditor> getDeclaredEditors(SAbstractConcept concept) {\n    {\n      SAbstractConcept cncpt = ((SAbstractConcept) concept);\n      Integer preIndex = indices_xbvbvu_a0a.get(cncpt);\n      int switchIndex = (preIndex == null ? -1 : preIndex);\n      switch (switchIndex) {\n        case 0:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new QueryParameter_Editor());\n          }\n          break;\n        case 1:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new QueryParameterReference_Editor());\n          }\n          break;\n        case 2:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new RequestHandler_Editor());\n          }\n          break;\n        case 3:\n          if (true) {\n            return Collections.<ConceptEditor>singletonList(new ResponseSendOperation_Editor());\n          }\n          break;\n        default:\n      }\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean process(@NotNull QueryStringDecoder decoder, @NotNull FullHttpRequest request, @NotNull ChannelHandlerContext context) throws IOException {\n    HttpRequest boxedRequest;\n    try {\n      boxedRequest = new HttpRequest(request, decoder, context.channel());\n    } catch (URISyntaxException exception) {\n      return false;\n    }\n\n    for (IHttpRequestHandler handler : Sequence.fromIterable(new ExtensionPoint<IHttpRequestHandler>(\"jetbrains.mps.ide.httpsupport.HttpRequestHandlerEP\").getObjects())) {\n      if (handler.canHandle(boxedRequest)) {\n\n        if (!(handler.isTrustful())) {\n          if (!(isTrustedHost(boxedRequest.getReferrerHost(), handler))) {\n            return false;\n          }\n        }\n\n        try {\n          handler.handle(boxedRequest);\n        } catch (Exception e) {\n          String errorHeader = \"Request handler '\" + handler.getName() + \"' throws exception\";\n\n          boxedRequest.sendResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR, \"text/plain\", Unpooled.copiedBuffer(errorHeader + \"\\n\\n\" + ExceptionUtil.getThrowableText(e), CharsetUtil.UTF_8));\n          if (LOG.isEnabledFor(Level.ERROR)) {\n            LOG.error(errorHeader, e);\n          }\n        } finally {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":66372,"modified_method":"@Override\n  public boolean process(@NotNull QueryStringDecoder decoder, @NotNull FullHttpRequest request, @NotNull ChannelHandlerContext context) throws IOException {\n    HttpRequest boxedRequest;\n    try {\n      boxedRequest = new HttpRequest(request, decoder, context.channel());\n    } catch (URISyntaxException exception) {\n      return false;\n    }\n\n    for (IHttpRequestHandler handler : Sequence.fromIterable(new ExtensionPoint<IHttpRequestHandler>(\"jetbrains.mps.ide.httpsupport.HttpRequestHandlerEP\").getObjects())) {\n      if (handler.canHandle(boxedRequest)) {\n\n        if (!(handler.isTrustful())) {\n          if (!(isTrustedHost(boxedRequest.getReferrerHost(), handler))) {\n            return false;\n          }\n        }\n\n        try {\n          handler.handle(boxedRequest);\n        } catch (Exception e) {\n          String errorHeader = \"Request handler '\" + handler.getName() + \"' throws exception\";\n\n          boxedRequest.sendErrorResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR, errorHeader, e);\n          if (LOG.isEnabledFor(Level.ERROR)) {\n            LOG.error(errorHeader, e);\n          }\n        } finally {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_6550075386185843069(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"))), new Pattern_1drinxvtk80fb(_quotation_createNode_x583g4_a0b0a0a0c()), true) != null;\n  }","id":66373,"modified_method":"public static boolean baseMappingRule_Condition_6550075386185843069(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"))), _quotation_createNode_x583g4_b0a0a2());\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_a0b0a0a0c() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"498d89d2-c2e9-11e2-ad49-6cf049e62fe5/java:io.netty.buffer(MPS.IDEA/)\"), facade.createNodeId(\"~ByteBuf\")));\n    return quotedNode_1;\n  }","id":66374,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a0a1() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, \"jetbrains.mps.baseLanguage.structure.ArrayType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d5b617L, \"jetbrains.mps.baseLanguage.structure.ByteType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, 0xf940d819f8L, \"componentType\"), quotedNode_2);\n    return quotedNode_1;\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7166526225171473294(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"));\n  }","id":66375,"modified_method":"public static SNode sourceNodeQuery_7166526225171473294(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_6550075386185867055(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a80L, \"type\"));\n  }","id":66376,"modified_method":"public static Object propertyMacro_GetPropertyValue_6550075386185867055(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503dL, \"type\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_6550075386185836801(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a80L, \"type\"));\n  }","id":66377,"modified_method":"public static Object propertyMacro_GetPropertyValue_6550075386185836801(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503dL, \"type\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_7166526225171473286(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a80L, \"type\"));\n  }","id":66378,"modified_method":"public static Object propertyMacro_GetPropertyValue_7166526225171473286(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503dL, \"type\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_7166526225171447415(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"))), new Pattern_1drinxvtk6yv6(_quotation_createNode_x583g4_a0b0a0a0b()), true) != null;\n  }","id":66379,"modified_method":"public static boolean baseMappingRule_Condition_7166526225171447415(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"))), _quotation_createNode_x583g4_b0a0a1());\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_a0b0a0a0b() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, \"jetbrains.mps.baseLanguage.structure.ArrayType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d5b617L, \"jetbrains.mps.baseLanguage.structure.ByteType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, 0xf940d819f8L, \"componentType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":66380,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a0a0() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/java:java.lang(JDK/)\"), facade.createNodeId(\"~String\")));\n    return quotedNode_1;\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_a0b0a0a0a() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/java:java.lang(JDK/)\"), facade.createNodeId(\"~String\")));\n    return quotedNode_1;\n  }","id":66381,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a0a2() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"498d89d2-c2e9-11e2-ad49-6cf049e62fe5/java:io.netty.buffer(MPS.IDEA/)\"), facade.createNodeId(\"~ByteBuf\")));\n    return quotedNode_1;\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_6550075386186283747(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"));\n  }","id":66382,"modified_method":"public static SNode sourceNodeQuery_6550075386186283747(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_7166526225171406484(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"))), new Pattern_1drinxvtk6f0e(_quotation_createNode_x583g4_a0b0a0a0a()), true) != null;\n  }","id":66383,"modified_method":"public static boolean baseMappingRule_Condition_7166526225171406484(final BaseMappingRuleContext _context) {\n    return TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"))), _quotation_createNode_x583g4_b0a0a0());\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_2332657309401958814(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a80L, \"type\"));\n  }","id":66384,"modified_method":"public static Object propertyMacro_GetPropertyValue_2332657309401958814(final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503dL, \"type\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_2332657309401909877(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL, 0x205f4376c59c0a82L, \"buffer\"));\n  }","id":66385,"modified_method":"public static SNode sourceNodeQuery_2332657309401909877(final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L, 0x5f91294323b6503fL, \"buffer\"));\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  @Nullable\n  public ConceptDescriptor getDescriptor(SConceptId id) {\n    Integer index = myIndexMap.get(id);\n    if (index == null) {\n      return null;\n    }\n    switch (((int) index)) {\n      case 0:\n        return myConceptCanHandleRequestFunction;\n      case 1:\n        return myConceptHandleRequestFunction;\n      case 2:\n        return myConceptHttpRequestParameter;\n      case 3:\n        return myConceptQueryParameter;\n      case 4:\n        return myConceptQueryParameterReference;\n      case 5:\n        return myConceptRequestHandler;\n      case 6:\n        return myConceptResponseSendStatement;\n      default:\n        throw new IllegalStateException();\n    }\n  }","id":66386,"modified_method":"@Override\n  @Nullable\n  public ConceptDescriptor getDescriptor(SConceptId id) {\n    Integer index = myIndexMap.get(id);\n    if (index == null) {\n      return null;\n    }\n    switch (((int) index)) {\n      case 0:\n        return myConceptCanHandleRequestFunction;\n      case 1:\n        return myConceptHandleRequestFunction;\n      case 2:\n        return myConceptHttpRequestOperation;\n      case 3:\n        return myConceptHttpRequestParameter;\n      case 4:\n        return myConceptQueryParameter;\n      case 5:\n        return myConceptQueryParameterReference;\n      case 6:\n        return myConceptRequestHandler;\n      case 7:\n        return myConceptResponseSendOperation;\n      default:\n        throw new IllegalStateException();\n    }\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public StructureAspectDescriptor() {\n    myIndexMap.put(myConceptCanHandleRequestFunction.getId(), 0);\n    myIndexMap.put(myConceptHandleRequestFunction.getId(), 1);\n    myIndexMap.put(myConceptHttpRequestParameter.getId(), 2);\n    myIndexMap.put(myConceptQueryParameter.getId(), 3);\n    myIndexMap.put(myConceptQueryParameterReference.getId(), 4);\n    myIndexMap.put(myConceptRequestHandler.getId(), 5);\n    myIndexMap.put(myConceptResponseSendStatement.getId(), 6);\n  }","id":66387,"modified_method":"public StructureAspectDescriptor() {\n    myIndexMap.put(myConceptCanHandleRequestFunction.getId(), 0);\n    myIndexMap.put(myConceptHandleRequestFunction.getId(), 1);\n    myIndexMap.put(myConceptHttpRequestOperation.getId(), 2);\n    myIndexMap.put(myConceptHttpRequestParameter.getId(), 3);\n    myIndexMap.put(myConceptQueryParameter.getId(), 4);\n    myIndexMap.put(myConceptQueryParameterReference.getId(), 5);\n    myIndexMap.put(myConceptRequestHandler.getId(), 6);\n    myIndexMap.put(myConceptResponseSendOperation.getId(), 7);\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<ConceptDescriptor> getDescriptors() {\n    return Arrays.asList(myConceptCanHandleRequestFunction, myConceptHandleRequestFunction, myConceptHttpRequestParameter, myConceptQueryParameter, myConceptQueryParameterReference, myConceptRequestHandler, myConceptResponseSendStatement);\n  }","id":66388,"modified_method":"@Override\n  public Collection<ConceptDescriptor> getDescriptors() {\n    return Arrays.asList(myConceptCanHandleRequestFunction, myConceptHandleRequestFunction, myConceptHttpRequestOperation, myConceptHttpRequestParameter, myConceptQueryParameter, myConceptQueryParameterReference, myConceptRequestHandler, myConceptResponseSendOperation);\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ConceptDescriptor createDescriptorForResponseSendStatement() {\n    return new ConceptDescriptorBuilder(\"jetbrains.mps.ide.httpsupport.structure.ResponseSendStatement\", MetaIdFactory.conceptId(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x205f4376c59c0a7fL)).super_(\"jetbrains.mps.baseLanguage.structure.Statement\").version(1).super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents(\"jetbrains.mps.baseLanguage.structure.Statement\").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(0x205f4376c59c0a80L, \"type\", new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"2332657309401746048\"))).properties(\"type\").childDescriptors(new ConceptDescriptorBuilder.Link(0x205f4376c59c0a82L, \"buffer\", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false, new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"2332657309401746050\"))).children(new String[]{\"buffer\"}, new boolean[]{false}).alias(\"send response\", \"\").sourceNode(new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"2332657309401746047\")).create();\n  }","id":66389,"modified_method":"private static ConceptDescriptor createDescriptorForResponseSendOperation() {\n    return new ConceptDescriptorBuilder(\"jetbrains.mps.ide.httpsupport.structure.ResponseSendOperation\", MetaIdFactory.conceptId(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b64fc1L)).super_(\"jetbrains.mps.ide.httpsupport.structure.HttpRequestOperation\").version(1).super_(MetaIdFactory.conceptId(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b595d2L)).parents(\"jetbrains.mps.ide.httpsupport.structure.HttpRequestOperation\").parentIds(MetaIdFactory.conceptId(0x817e4e70961e4a95L, 0x98a115e9f32231f1L, 0x5f91294323b595d2L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(0x5f91294323b6503dL, \"type\", new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"6886330673564897341\"))).properties(\"type\").childDescriptors(new ConceptDescriptorBuilder.Link(0x5f91294323b6503fL, \"buffer\", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false, new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"6886330673564897343\"))).children(new String[]{\"buffer\"}, new boolean[]{false}).alias(\"send response\", \"\").sourceNode(new SNodePointer(\"r:3c30b5c5-2f86-4daf-bab8-b406cfefcb4f(jetbrains.mps.ide.httpsupport.structure)\", \"6886330673564897217\")).create();\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_HttpRequestParameter_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_QueryParameterReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ResponseSendStatement_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n  }","id":66390,"modified_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_HttpRequestParameter_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_QueryParameterReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ResponseSendOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n  }","commit_id":"3c19a18d803150ae6b4bcb11bb692c0251ce4ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_create_8260330507834998478(SNode thisNode) {\n    SNode method = SNodeFactoryOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\", null);\n    SPropertyOperations.set(method, \"name\", SPropertyOperations.getString(thisNode, \"name\"));\n    SLinkOperations.setTarget(method, \"body\", SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null), true);\n    ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"param\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n          SNode type = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\", null);\n          SLinkOperations.setTarget(type, \"decl\", SNodeOperations.cast(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"), false);\n          SNode result = createParameterDeclaration_9j0ugw_a0c0a0a0a0a3a0(SPropertyOperations.getString(it, \"name\"), SNodeOperations.cast(HUtil.copyIfNecessary(type), \"jetbrains.mps.baseLanguage.structure.Type\"));\n          SLinkOperations.setTarget(type, \"point\", result, false);\n          return result;\n        } else {\n          return createParameterDeclaration_9j0ugw_a0a0a0a0a0a3a0(SPropertyOperations.getString(it, \"name\"), SNodeOperations.cast(HUtil.copyIfNecessary(SLinkOperations.getTarget(it, \"type\", true)), \"jetbrains.mps.baseLanguage.structure.Type\"));\n        }\n      }\n    }));\n    if (SLinkOperations.getTarget(thisNode, \"retType\", true) == null) {\n      SLinkOperations.setTarget(method, \"returnType\", _quotation_createNode_9j0ugw_a0a0e0a(), true);\n    } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(thisNode, \"retType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\", null);\n      SLinkOperations.setTarget(node, \"decl\", SNodeOperations.cast(SLinkOperations.getTarget(thisNode, \"retType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"), false);\n      SLinkOperations.setTarget(node, \"point\", method, false);\n      SLinkOperations.setTarget(method, \"returnType\", node, true);\n    } else {\n      SLinkOperations.setTarget(method, \"returnType\", SNodeOperations.copyNode(SLinkOperations.getTarget(thisNode, \"retType\", true)), true);\n    }\n\n    SLinkOperations.setTarget(method, \"decl\", thisNode, false);\n\n    return method;\n  }","id":66391,"modified_method":"public static SNode virtual_create_8260330507834998478(SNode thisNode) {\n    SNode method = SNodeFactoryOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\", null);\n    SPropertyOperations.set(method, \"name\", SPropertyOperations.getString(thisNode, \"name\"));\n    SLinkOperations.setTarget(method, \"body\", SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null), true);\n    ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"param\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n          SNode type = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\", null);\n          SLinkOperations.setTarget(type, \"decl\", SNodeOperations.cast(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"), false);\n          SNode result = createParameterDeclaration_9j0ugw_a0c0a0a0a0a3a0(SPropertyOperations.getString(it, \"name\"), SNodeOperations.cast(HUtil.copyIfNecessary(type), \"jetbrains.mps.baseLanguage.structure.Type\"));\n          SLinkOperations.setTarget(type, \"point\", result, false);\n          return result;\n        } else {\n          return createParameterDeclaration_9j0ugw_a0a0a0a0a0a3a0(SPropertyOperations.getString(it, \"name\"), SNodeOperations.cast(HUtil.copyIfNecessary(SLinkOperations.getTarget(it, \"type\", true)), \"jetbrains.mps.baseLanguage.structure.Type\"));\n        }\n      }\n    }));\n    SNode returnType = MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(thisNode);\n    if (SNodeOperations.isInstanceOf(returnType, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\", null);\n      SLinkOperations.setTarget(node, \"decl\", SNodeOperations.cast(returnType, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"), false);\n      SLinkOperations.setTarget(node, \"point\", method, false);\n      SLinkOperations.setTarget(method, \"returnType\", node, true);\n    } else {\n      SLinkOperations.setTarget(method, \"returnType\", SNodeOperations.copyNode(returnType), true);\n    }\n\n    SLinkOperations.setTarget(method, \"decl\", thisNode, false);\n\n    return method;\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_9j0ugw_a0a0e0a() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    return quotedNode_1;\n  }","id":66392,"modified_method":"private static SNode _quotation_createNode_9j0ugw_a0a0a1() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    return quotedNode_1;\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_create_8260330507834998478(SNode thisNode) {\n    SNode res;\n    if (PrimitiveDataTypeDeclaration_Behavior.call_isString_1220268752134(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeStringProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0b0a(), true);\n      res = node;\n    } else if (PrimitiveDataTypeDeclaration_Behavior.call_isBoolean_1220268791641(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeBooleanProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0a1a0(), true);\n      res = node;\n    } else if (PrimitiveDataTypeDeclaration_Behavior.call_isBoolean_1220268791641(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeIntegerProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0b1a0(), true);\n      res = node;\n    } else {\n      throw new IllegalStateException(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(thisNode, \"type\", false), \"virtual_getPresentation_1213877396640\", new Object[]{}));\n    }\n\n    SPropertyOperations.set(res, \"name\", SPropertyOperations.getString(thisNode, \"name\"));\n    SLinkOperations.setTarget(res, \"decl\", thisNode, false);\n\n    return res;\n  }","id":66393,"modified_method":"public static SNode virtual_create_8260330507834998478(SNode thisNode) {\n    SNode res;\n    if (PrimitiveDataTypeDeclaration_Behavior.call_isString_1220268752134(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeStringProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0b0a(), true);\n      res = node;\n    } else if (PrimitiveDataTypeDeclaration_Behavior.call_isBoolean_1220268791641(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeBooleanProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0a1a0(), true);\n      res = node;\n    } else if (PrimitiveDataTypeDeclaration_Behavior.call_isInteger_1220268780075(SLinkOperations.getTarget(thisNode, \"type\", false))) {\n      SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.classLike.structure.ClassLikeIntegerProperty\", null);\n      SLinkOperations.setTarget(node, \"type\", _quotation_createNode_j9hr46_a0b0b1a0(), true);\n      res = node;\n    } else {\n      throw new IllegalStateException(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(thisNode, \"type\", false), \"virtual_getPresentation_1213877396640\", new Object[]{}));\n    }\n\n    SPropertyOperations.set(res, \"name\", SPropertyOperations.getString(thisNode, \"name\"));\n    SLinkOperations.setTarget(res, \"decl\", thisNode, false);\n\n    return res;\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ClassLikeMethod_3751132065236797750(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n          public Iterable<SNode> compute() {\n            return Util.getMethodDescriptors(_context.getParentNode());\n          }\n        }.compute();\n        if (queryResult != null) {\n          for (final SNode item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                return ((SNode) BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), (item), \"virtual_create_8260330507834998478\", new Object[]{}));\n              }\n              public String getMatchingText(String pattern) {\n                return SPropertyOperations.getString((item), \"name\");\n              }\n              public String getVisibleMatchingText(String pattern) {\n                return getMatchingText(pattern);\n              }\n              public String getDescriptionText(String pattern) {\n                return \"method\";\n              }\n            });\n          }\n        }\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n          public Iterable<SNode> compute() {\n            return Util.getPropertyDescriptors(_context.getParentNode());\n          }\n        }.compute();\n        if (queryResult != null) {\n          for (final SNode item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                return ((SNode) BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), (item), \"virtual_create_8260330507834998478\", new Object[]{}));\n              }\n              public String getMatchingText(String pattern) {\n                return SPropertyOperations.getString((item), \"name\");\n              }\n              public String getVisibleMatchingText(String pattern) {\n                return getMatchingText(pattern);\n              }\n              public String getDescriptionText(String pattern) {\n                return \"property\";\n              }\n            });\n          }\n        }\n      }\n    }\n    {\n      Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n        public Iterable<SNode> compute() {\n          return Sequence.fromIterable(Util.getCustomDescriptors(_context.getParentNode())).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return ((SNode) SLinkOperations.getTarget(it, \"cncpt\", false));\n            }\n          });\n        }\n      }.compute();\n      if (queryResult != null) {\n        for (SNode item : queryResult) {\n          ListSequence.fromList(result).addSequence(ListSequence.fromList(ChildSubstituteActionsHelper.createDefaultSubstituteActions(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext)));\n        }\n      }\n    }\n    return result;\n  }","id":66394,"modified_method":"public static List<SubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ClassifierMember_3751132065236797750(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n          public Iterable<SNode> compute() {\n            return Util.getMethodDescriptors(_context.getParentNode());\n          }\n        }.compute();\n        if (queryResult != null) {\n          for (final SNode item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                return ((SNode) BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), (item), \"virtual_create_8260330507834998478\", new Object[]{}));\n              }\n              public String getMatchingText(String pattern) {\n                return SPropertyOperations.getString((item), \"name\");\n              }\n              public String getVisibleMatchingText(String pattern) {\n                return getMatchingText(pattern);\n              }\n              public String getDescriptionText(String pattern) {\n                return \"method\";\n              }\n            });\n          }\n        }\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n          public Iterable<SNode> compute() {\n            return Util.getPropertyDescriptors(_context.getParentNode());\n          }\n        }.compute();\n        if (queryResult != null) {\n          for (final SNode item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                return ((SNode) BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), (item), \"virtual_create_8260330507834998478\", new Object[]{}));\n              }\n              public String getMatchingText(String pattern) {\n                return SPropertyOperations.getString((item), \"name\");\n              }\n              public String getVisibleMatchingText(String pattern) {\n                return getMatchingText(pattern);\n              }\n              public String getDescriptionText(String pattern) {\n                return \"property\";\n              }\n            });\n          }\n        }\n      }\n    }\n    {\n      Iterable<SNode> queryResult = new Computable<Iterable<SNode>>() {\n        public Iterable<SNode> compute() {\n          return Sequence.fromIterable(Util.getCustomDescriptors(_context.getParentNode())).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return ((SNode) SLinkOperations.getTarget(it, \"cncpt\", false));\n            }\n          });\n        }\n      }.compute();\n      if (queryResult != null) {\n        for (SNode item : queryResult) {\n          ListSequence.fromList(result).addSequence(ListSequence.fromList(ChildSubstituteActionsHelper.createDefaultSubstituteActions(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext)));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeAnnotation\").super_(\"jetbrains.mps.lang.core.structure.NodeAttribute\").parents(\"jetbrains.mps.lang.core.structure.NodeAttribute\").references(\"descriptor\").create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeBooleanProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").references(\"preferredConcept\").children(new String[]{\"initializer\", \"member\"}, new boolean[]{false, true}).create();\n      case 3:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeIntegerProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 4:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").interface_().children(new String[]{\"modifier\"}, new boolean[]{true}).create();\n      case 5:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\").interface_().create();\n      case 6:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMemberPlaceholder\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\", \"jetbrains.mps.baseLanguage.structure.ClassifierMember\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").properties(\"caption\").references(\"decl\").create();\n      case 7:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\").super_(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\").parents(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\").references(\"decl\").create();\n      case 8:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").super_(\"jetbrains.mps.baseLanguage.structure.FieldDeclaration\").parents(\"jetbrains.mps.baseLanguage.structure.FieldDeclaration\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\").references(\"decl\").abstract_().create();\n      case 9:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeStringProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 10:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.CustomMemberDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").references(\"cncpt\").alias(\"custom member\", \"\").create();\n      case 11:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\").super_(\"jetbrains.mps.baseLanguage.structure.Type\").parents(\"jetbrains.mps.baseLanguage.structure.Type\").children(new String[]{\"getter\"}, new boolean[]{false}).alias(\"deptype\", \"\").create();\n      case 12:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\").super_(\"jetbrains.mps.baseLanguage.structure.Type\").parents(\"jetbrains.mps.baseLanguage.structure.Type\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").references(\"decl\", \"point\").create();\n      case 13:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.EmptyMember\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").alias(\"empty line\", \"\").create();\n      case 14:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.GenerateModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").properties(\"name\").alias(\"generate\", \"\").create();\n      case 15:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.MemberModifier\").interface_().create();\n      case 16:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.MethodDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").children(new String[]{\"param\", \"retType\"}, new boolean[]{true, false}).alias(\"method\", \"\").create();\n      case 17:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ParameterDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").children(new String[]{\"type\"}, new boolean[]{false}).create();\n      case 18:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.PlaceholderModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").properties(\"caption\").alias(\"placeholder\", \"\").create();\n      case 19:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.PropertyDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").references(\"type\").alias(\"property\", \"\").create();\n      case 20:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.RequiredModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").alias(\"required\", \"\").create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":66395,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeAnnotation\").super_(\"jetbrains.mps.lang.core.structure.NodeAttribute\").parents(\"jetbrains.mps.lang.core.structure.NodeAttribute\").references(\"descriptor\").create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeBooleanProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").references(\"preferredConcept\").children(new String[]{\"initializer\", \"member\"}, new boolean[]{false, true}).create();\n      case 3:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeIntegerProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 4:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").interface_().children(new String[]{\"modifier\"}, new boolean[]{true}).create();\n      case 5:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\").interface_().create();\n      case 6:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMemberPlaceholder\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\", \"jetbrains.mps.baseLanguage.structure.ClassifierMember\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").properties(\"caption\").references(\"decl\").create();\n      case 7:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeMethod\").super_(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\").parents(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").references(\"decl\").create();\n      case 8:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").super_(\"jetbrains.mps.baseLanguage.structure.FieldDeclaration\").parents(\"jetbrains.mps.baseLanguage.structure.FieldDeclaration\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMemberInstance\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").references(\"decl\").abstract_().create();\n      case 9:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ClassLikeStringProperty\").super_(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").parents(\"jetbrains.mps.lang.classLike.structure.ClassLikeProperty\").properties(\"value\").create();\n      case 10:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.CustomMemberDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").references(\"cncpt\").alias(\"custom member\", \"\").create();\n      case 11:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\").super_(\"jetbrains.mps.baseLanguage.structure.Type\").parents(\"jetbrains.mps.baseLanguage.structure.Type\").children(new String[]{\"getter\"}, new boolean[]{false}).alias(\"deptype\", \"\").create();\n      case 12:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\").super_(\"jetbrains.mps.baseLanguage.structure.Type\").parents(\"jetbrains.mps.baseLanguage.structure.Type\", \"jetbrains.mps.lang.core.structure.IDontSubstituteByDefault\").references(\"decl\", \"point\").create();\n      case 13:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.EmptyMember\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").alias(\"empty line\", \"\").create();\n      case 14:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.GenerateModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").properties(\"name\").alias(\"generate\", \"\").create();\n      case 15:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.MemberModifier\").interface_().create();\n      case 16:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.MethodDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").children(new String[]{\"param\", \"retType\"}, new boolean[]{true, false}).alias(\"method\", \"\").create();\n      case 17:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.ParameterDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").children(new String[]{\"type\"}, new boolean[]{false}).create();\n      case 18:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.PlaceholderModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").properties(\"caption\").alias(\"placeholder\", \"\").create();\n      case 19:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.PropertyDescriptor\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.lang.classLike.structure.ClassLikeMember\").references(\"type\").alias(\"property\", \"\").create();\n      case 20:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.lang.classLike.structure.RequiredModifier\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.classLike.structure.MemberModifier\").alias(\"required\", \"\").create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable<SNode> getPropertyDescriptors(SNode node) {\n    if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"))) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n\n    SNode descr = SLinkOperations.getTarget(AttributeOperations.getAttribute(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), new IAttributeDescriptor.NodeAttribute(\"jetbrains.mps.lang.classLike.structure.ClassLikeAnnotation\")), \"descriptor\", false);\n    if (descr == null) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n\n    return SNodeOperations.ofConcept(SLinkOperations.getTargets(descr, \"member\", true), \"jetbrains.mps.lang.classLike.structure.PropertyDescriptor\");\n  }","id":66396,"modified_method":"public static Iterable<SNode> getPropertyDescriptors(SNode node) {\n    if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"))) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n\n    SNode descr = SLinkOperations.getTarget(AttributeOperations.getAttribute(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), new IAttributeDescriptor.NodeAttribute(\"jetbrains.mps.lang.classLike.structure.ClassLikeAnnotation\")), \"descriptor\", false);\n    if (descr == null) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n\n    return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getTargets(descr, \"member\", true), \"jetbrains.mps.lang.classLike.structure.PropertyDescriptor\")).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SLinkOperations.getTarget(it, \"type\", false) != null;\n      }\n    });\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode classLikeMethod, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    boolean error = false;\n\n    if (ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).count()) {\n      for (int i = 0; i < ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).count(); i++) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n          error |= !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\"), \"decl\", false) == SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true));\n        } else {\n          error |= !(MatchingUtil.matchNodes(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true)));\n        }\n        error |= neq_w6mbdo_a0a1a0a2a1(SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"name\"), SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"name\"));\n      }\n    } else {\n      error = true;\n    }\n\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"retType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n      error |= !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\"), \"decl\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"retType\", true));\n    } else {\n      error |= !(MatchingUtil.matchNodes(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"retType\", true)));\n    }\n\n    if (error) {\n      {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        errorTarget = new PropertyMessageTarget(\"name\");\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(classLikeMethod, \"Method signature is not the same as in descriptor\", \"c7d5b9dd-a05f-4be2-bc73-f2e16994cc67/r:e04b7053-8c89-4f87-b296-94779c625d9d(jetbrains.mps.lang.classLike/jetbrains.mps.lang.classLike.typesystem)\", \"1901385213796809109\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.lang.classLike.typesystem.fix_SignatureMismatch_QuickFix\", false);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","id":66397,"modified_method":"public void applyRule(final SNode classLikeMethod, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    boolean error = false;\n\n    if (ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).count()) {\n      for (int i = 0; i < ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).count(); i++) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n          error |= !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\"), \"decl\", false) == SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true));\n        } else {\n          error |= !(MatchingUtil.matchNodes(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"type\", true), SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"type\", true)));\n        }\n        error |= neq_w6mbdo_a0a1a0a2a1(SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(classLikeMethod, \"decl\", false), \"param\", true)).getElement(i), \"name\"), SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(classLikeMethod, \"parameter\", true)).getElement(i), \"name\"));\n      }\n    } else {\n      error = true;\n    }\n\n    if (SNodeOperations.isInstanceOf(MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(SLinkOperations.getTarget(classLikeMethod, \"decl\", false)), \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")) {\n      error |= !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\"), \"decl\", false) == MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(SLinkOperations.getTarget(classLikeMethod, \"decl\", false)));\n    } else {\n      error |= !(MatchingUtil.matchNodes(SLinkOperations.getTarget(classLikeMethod, \"returnType\", true), MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(SLinkOperations.getTarget(classLikeMethod, \"decl\", false))));\n    }\n\n    if (error) {\n      {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        errorTarget = new PropertyMessageTarget(\"name\");\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(classLikeMethod, \"Method signature is not the same as in descriptor\", \"c7d5b9dd-a05f-4be2-bc73-f2e16994cc67/r:e04b7053-8c89-4f87-b296-94779c625d9d(jetbrains.mps.lang.classLike/jetbrains.mps.lang.classLike.typesystem)\", \"1901385213796809109\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.lang.classLike.typesystem.fix_SignatureMismatch_QuickFix\", false);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"e3eb31c90b0871876ab572f0b40ac6ecda1ff360","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a1a0v0e0a0g_0(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","id":66398,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a1a0p0e0a0g_0(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_b0a0a0a12a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x65e54712ab56011cL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_Completion\"), null, null, false);\n    return quotedNode_1;\n  }","id":66399,"modified_method":"private static SNode _quotation_createNode_o8m9jz_b0a0a0a51a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x65e54712ab56011cL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_Completion\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a0a12a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","id":66400,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a2a3a81a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6a77f9c87420a6caL, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeSubstituteMenu\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_c0a0a0a12a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x7c45559defd26bcbL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_ContextAssistant\"), null, null, false);\n    return quotedNode_1;\n  }","id":66401,"modified_method":"private static SNode _quotation_createNode_o8m9jz_c0a0a0a51a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x7c45559defd26bcbL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_ContextAssistant\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a0v0e0a0g() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","id":66402,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a0p0e0a0g() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a12a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","id":66403,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a51a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_o8m9jz_a0a0a01a6a0a6_0(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":66404,"modified_method":"private static boolean eq_o8m9jz_a0a0a2a8a6a0a6_0(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<String> getSideTransformTags(SNode cell) {\n    Set<String> sideTransformTags = new HashSet<String>();\n    for (SNode item : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\")))) {\n      if (SPropertyOperations.getString_def(item, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x11abb1e8d86L, \"tag\"), null) != null) {\n        sideTransformTags.add(SPropertyOperations.getString_def(item, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x11abb1e8d86L, \"tag\"), null));\n      } else {\n        for (SNode tagWrapper : ListSequence.fromList(SLinkOperations.getChildren(item, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x3212fe82cb95ffe6L, \"tags\")))) {\n          sideTransformTags.add(SPropertyOperations.getString_def(tagWrapper, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x3212fe82cb95ffe7L, 0x3212fe82cb95ffeaL, \"tag\"), null));\n        }\n      }\n    }\n    return sideTransformTags;\n  }","id":66405,"modified_method":"private Set<String> getSideTransformTags(SNode cell) {\n    Set<String> sideTransformTags = new HashSet<String>();\n    if (isChildCell(cell)) {\n      return sideTransformTags;\n    }\n    for (SNode item : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\")))) {\n      if (SPropertyOperations.getString_def(item, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x11abb1e8d86L, \"tag\"), null) != null) {\n        sideTransformTags.add(SPropertyOperations.getString_def(item, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x11abb1e8d86L, \"tag\"), null));\n      } else {\n        for (SNode tagWrapper : ListSequence.fromList(SLinkOperations.getChildren(item, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, 0x3212fe82cb95ffe6L, \"tags\")))) {\n          sideTransformTags.add(SPropertyOperations.getString_def(tagWrapper, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x3212fe82cb95ffe7L, 0x3212fe82cb95ffeaL, \"tag\"), null));\n        }\n      }\n    }\n    return sideTransformTags;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a2a52a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x65e54712ab56011cL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_Completion\"), null, null, false);\n    return quotedNode_1;\n  }","id":66406,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a0a51a4a0a6() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"LEFT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, \"jetbrains.mps.lang.editor.structure.TransformationLocation_SideTransform_PlaceInCellHolder\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x30335f3d1845bdccL, 0x30335f3d1845bdcdL, \"placeInCell\"), \"RIGHT\");\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x28336854e4c19a06L, 0x30335f3d1845bdcfL, \"placeInCell\"), quotedNode_3);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_o8m9jz_a0a0b0d0z0g0a0g(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":66407,"modified_method":"private static boolean eq_o8m9jz_a0a0b0a0c0d0s0g0a0g(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SNode getConceptDeclaration(SNode cell) {\n    return SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfba0eb7c50L, \"jetbrains.mps.lang.editor.structure.BaseEditorComponent\"), false, false), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f7df344a9L, 0x10f7df451aeL, \"conceptDeclaration\"));\n  }","id":66408,"modified_method":"private SNode getConceptDeclaration(SNode cell) {\n    if (SNodeOperations.isInstanceOf(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb05cdc7L, \"jetbrains.mps.lang.editor.structure.CellModel_RefNode\"))) {\n      return SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb05cdc7L, \"jetbrains.mps.lang.editor.structure.CellModel_RefNode\")), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, \"target\"));\n    } else if (SNodeOperations.isInstanceOf(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb05cdc7L, \"jetbrains.mps.lang.editor.structure.CellModel_RefNode\"))) {\n      return SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb0ad38eL, \"jetbrains.mps.lang.editor.structure.CellModel_RefNodeList\")), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, \"target\"));\n    }\n    return SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(cell, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfba0eb7c50L, \"jetbrains.mps.lang.editor.structure.BaseEditorComponent\"), false, false), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f7df344a9L, 0x10f7df451aeL, \"conceptDeclaration\"));\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void commentAndAddAnnotations(SNode cell) {\n    for (SNode styleItem : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\")))) {\n      addMigrationAnnotation(styleItem, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n      CommentUtil.commentOut(styleItem);\n    }\n    if ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null)) {\n      for (SNode apply : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\")))) {\n        addMigrationAnnotation(apply, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n        CommentUtil.commentOut(apply);\n      }\n      if (SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null && ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\"))).isEmpty()) {\n        CommentUtil.commentOut(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")));\n      }\n    }\n\n  }","id":66409,"modified_method":"private void commentAndAddAnnotations(SNode cell) {\n    for (SNode styleItem : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\")))) {\n      if (isChildCell(cell)) {\n        addMigrationAnnotation(styleItem, null);\n      } else {\n        addMigrationAnnotation(styleItem, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n      }\n      CommentUtil.commentOut(styleItem);\n    }\n    if ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null)) {\n      for (SNode apply : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\")))) {\n        addMigrationAnnotation(apply, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n        CommentUtil.commentOut(apply);\n      }\n      if (SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null && ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\"))).isEmpty()) {\n        CommentUtil.commentOut(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")));\n      }\n    }\n\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_o8m9jz_a0a0a01a6a0a6(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":66410,"modified_method":"private static boolean eq_o8m9jz_a0a0a2a8a6a0a6(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a1a12a4a0a6(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","id":66411,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a0a1a51a4a0a6(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_o8m9jz_a0a1a0v0e0a0g() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    return quotedNode_1;\n  }","id":66412,"modified_method":"private static SNode _quotation_createNode_o8m9jz_a0a1a0p0e0a0g() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_o8m9jz_a0a1a3a52a6a0a6(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":66413,"modified_method":"private static boolean eq_o8m9jz_a0a1a0a2a3a81a6a0a6(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"void migrate() {\n    {\n      final SearchScope scope = CommandUtil.createScope(myModule);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      Iterable<SNode> cellsWithTagsOrApplySideTransforms = CollectionSequence.fromCollection(CommandUtil.instances(CommandUtil.createConsoleScope(null, false, context), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\"))).isNotEmpty() || (SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null) && Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"))).isNotEmpty();\n        }\n      });\n      Map<Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>>, SNode> conceptAndTagsToAdditionalMenu = MapSequence.fromMap(new HashMap<Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>>, SNode>());\n      Map<SNode, Integer> conceptToCounter = MapSequence.fromMap(new HashMap<SNode, Integer>());\n      boolean menuWasFound = false;\n      for (SNode cell : Sequence.fromIterable(cellsWithTagsOrApplySideTransforms)) {\n        SNode concept = getConceptDeclaration(cell);\n        if (concept == null) {\n          continue;\n        }\n        Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>> key = createKey(cell);\n        SNode cachedReference = MapSequence.fromMap(conceptAndTagsToAdditionalMenu).get(key);\n        boolean isNullTransformationMenu = SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")) == null;\n        if (cachedReference != null && isNullTransformationMenu) {\n          SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), SNodeOperations.copyNode(cachedReference));\n          commentAndAddAnnotations(cell);\n          continue;\n        }\n\n        Set<String> sideTransformTags = getSideTransformTags(cell);\n        boolean containsDefaultTag = false;\n        Set<SNode> menusFound = new HashSet<SNode>();\n        for (String tag : sideTransformTags) {\n          if (eq_o8m9jz_a0a0a01a6a0a6_0(tag, null) || eq_o8m9jz_a0a0a01a6a0a6(tag, DEFAULT_TAG_NAME)) {\n            containsDefaultTag = true;\n            menuWasFound = true;\n            continue;\n          }\n          menusFound.addAll(findAllMainNamedMenusForTag(concept, tag));\n        }\n        List<SNode> menuReferences = new ArrayList<SNode>();\n        if (containsDefaultTag) {\n          menuReferences.add(createDefaultTransformationMenuReference(concept));\n        }\n        for (SNode menu : SetSequence.fromSet(menusFound)) {\n          menuWasFound = true;\n          menuReferences.add(createNamedTransformationMenuReference(menu));\n          addMissingReference(menu, cell);\n        }\n        if (menuReferences.size() == 1 && ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) == null) || Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"))).isEmpty())) {\n          SNode reference = menuReferences.get(0);\n          SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), reference);\n          MapSequence.fromMap(conceptAndTagsToAdditionalMenu).put(key, reference);\n          commentAndAddAnnotations(cell);\n          continue;\n        }\n        SNode additionalMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0ac4ee8L, \"jetbrains.mps.lang.editor.structure.TransformationMenu_Named\"));\n        SLinkOperations.setTarget(additionalMenu, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x169efbc9a9048c53L, 0x5b7b4c4d511049b4L, \"conceptDeclaration\"), concept);\n        SPropertyOperations.set(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), concept + \"_ApplySideTransforms\");\n\n        if (MapSequence.fromMap(conceptToCounter).get(concept) == null) {\n          MapSequence.fromMap(conceptToCounter).put(concept, 1);\n        } else {\n          SPropertyOperations.set(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_\" + MapSequence.fromMap(conceptToCounter).get(concept));\n          MapSequence.fromMap(conceptToCounter).put(concept, MapSequence.fromMap(conceptToCounter).get(concept) + 1);\n        }\n        SNode includeSection = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, \"jetbrains.mps.lang.editor.structure.TransformationMenuSection\"));\n        if (!(menuReferences.isEmpty())) {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a12a4a0a6());\n          for (SNode menuReference : ListSequence.fromList(menuReferences)) {\n            ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a0a1a12a4a0a6(menuReference));\n          }\n        } else if (isNullTransformationMenu) {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a0v0e0a0g());\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a1a0v0e0a0g());\n        } else {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addSequence(ListSequence.fromList(Arrays.asList(_quotation_createNode_o8m9jz_a0a0a0a12a4a0a6(), _quotation_createNode_o8m9jz_b0a0a0a12a4a0a6(), _quotation_createNode_o8m9jz_c0a0a0a12a4a0a6())));\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a1a0v0e0a0g_0(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"))));\n        }\n        ListSequence.fromList(SLinkOperations.getChildren(additionalMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0c11832L, 0x16be955f384efffcL, \"sections\"))).addElement(includeSection);\n\n        Iterable<SNode> applySideTransforms = ListSequence.fromList(new ArrayList<SNode>());\n        if ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null)) {\n          applySideTransforms = SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"));\n          SNode section = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, \"jetbrains.mps.lang.editor.structure.TransformationMenuSection\"));\n          if (Sequence.fromIterable(applySideTransforms).isNotEmpty()) {\n            ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a2a52a4a0a6());\n            ListSequence.fromList(SLinkOperations.getChildren(additionalMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0c11832L, 0x16be955f384efffcL, \"sections\"))).addElement(section);\n          }\n          for (SNode apply : Sequence.fromIterable(applySideTransforms)) {\n            String tag = SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0xc14e9fba94cb682L, \"tag\"), null);\n            if (tag == null || eq_o8m9jz_a0a0b0d0z0g0a0g(tag, \"\") || eq_o8m9jz_a0a1a3a52a6a0a6(tag, DEFAULT_TAG_NAME)) {\n              SNode location = ActionMigrationHelper.createLocation(SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0x72449b609d0f1475L, \"side\"), null));\n              SNode includeMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"));\n              SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x1a0027b1197f7335L, \"location\"), location);\n\n              menuWasFound = true;\n              SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), createDefaultTransformationMenuReference(concept));\n              ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(includeMenu);\n            } else {\n              for (SNode menu : SetSequence.fromSet(findAllMainNamedMenusForTag(concept, tag))) {\n                SNode location = ActionMigrationHelper.createLocation(SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0x72449b609d0f1475L, \"side\"), null));\n                SNode includeMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"));\n                SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x1a0027b1197f7335L, \"location\"), location);\n\n                if (menu != null) {\n                  addMissingReference(menu, cell);\n                  menuWasFound = true;\n                  SNode transformationMenuReference = createNamedTransformationMenuReference(menu);\n                  if (transformationMenuReference != null) {\n                    SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), transformationMenuReference);\n                  }\n                }\n                ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(includeMenu);\n              }\n            }\n          }\n        }\n\n        if (menuWasFound) {\n          SNodeOperations.getModel(cell).addRootNode(additionalMenu);\n          SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, \"jetbrains.mps.lang.editor.structure.TransformationMenuReference_Named\")));\n          SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, \"jetbrains.mps.lang.editor.structure.TransformationMenuReference_Named\")), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, 0x5d3b34577b3cff0aL, \"menu\"), additionalMenu);\n          if (isNullTransformationMenu) {\n            MapSequence.fromMap(conceptAndTagsToAdditionalMenu).put(key, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n          }\n        }\n        commentAndAddAnnotations(cell);\n      }\n    }\n  }","id":66414,"modified_method":"void migrate() {\n    {\n      final SearchScope scope = CommandUtil.createScope(myModule);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      Iterable<SNode> cellsWithTagsOrApplySideTransforms = CollectionSequence.fromCollection(CommandUtil.instances(CommandUtil.createConsoleScope(null, false, context), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11abb1e8d85L, \"jetbrains.mps.lang.editor.structure.SideTransformAnchorTagStyleClassItem\"))).isNotEmpty() || (SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null) && Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"))).isNotEmpty();\n        }\n      });\n      Map<Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>>, SNode> conceptAndTagsToAdditionalMenu = MapSequence.fromMap(new HashMap<Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>>, SNode>());\n      Map<SNode, Integer> conceptToCounter = MapSequence.fromMap(new HashMap<SNode, Integer>());\n      boolean menuWasFound = false;\n      for (SNode cell : Sequence.fromIterable(cellsWithTagsOrApplySideTransforms)) {\n        SNode concept = getConceptDeclaration(cell);\n        if (concept == null) {\n          continue;\n        }\n        Pair<SNode, Pair<Set<String>, Set<Pair<String, String>>>> key = createKey(cell);\n        SNode cachedReference = MapSequence.fromMap(conceptAndTagsToAdditionalMenu).get(key);\n        boolean isNullTransformationMenu = SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")) == null;\n        if (cachedReference != null && isNullTransformationMenu) {\n          SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), SNodeOperations.copyNode(cachedReference));\n          commentAndAddAnnotations(cell);\n          continue;\n        }\n        List<SNode> menuReferences = new ArrayList<SNode>();\n        Set<String> sideTransformTags = getSideTransformTags(cell);\n        if (!(isChildCell(cell))) {\n          boolean containsDefaultTag = false;\n          Set<SNode> menusFound = new HashSet<SNode>();\n          for (String tag : sideTransformTags) {\n            if (eq_o8m9jz_a0a0a2a8a6a0a6_0(tag, null) || eq_o8m9jz_a0a0a2a8a6a0a6(tag, DEFAULT_TAG_NAME)) {\n              containsDefaultTag = true;\n              menuWasFound = true;\n              continue;\n            }\n            menusFound.addAll(findAllMainNamedMenusForTag(concept, tag));\n          }\n          if (containsDefaultTag) {\n            menuReferences.add(createDefaultTransformationMenuReference(concept));\n          }\n          for (SNode menu : SetSequence.fromSet(menusFound)) {\n            menuWasFound = true;\n            menuReferences.add(createNamedTransformationMenuReference(menu));\n            addMissingReference(menu, cell);\n          }\n          if (menuReferences.size() == 1 && ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) == null) || Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"))).isEmpty())) {\n            SNode reference = menuReferences.get(0);\n            SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), reference);\n            MapSequence.fromMap(conceptAndTagsToAdditionalMenu).put(key, reference);\n            commentAndAddAnnotations(cell);\n            continue;\n          }\n        }\n        SNode additionalMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0ac4ee8L, \"jetbrains.mps.lang.editor.structure.TransformationMenu_Named\"));\n        SLinkOperations.setTarget(additionalMenu, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x169efbc9a9048c53L, 0x5b7b4c4d511049b4L, \"conceptDeclaration\"), concept);\n        SPropertyOperations.set(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), concept + \"_ApplySideTransforms\");\n\n        if (MapSequence.fromMap(conceptToCounter).get(concept) == null) {\n          MapSequence.fromMap(conceptToCounter).put(concept, 1);\n        } else {\n          SPropertyOperations.set(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(additionalMenu, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_\" + MapSequence.fromMap(conceptToCounter).get(concept));\n          MapSequence.fromMap(conceptToCounter).put(concept, MapSequence.fromMap(conceptToCounter).get(concept) + 1);\n        }\n        SNode includeSection = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, \"jetbrains.mps.lang.editor.structure.TransformationMenuSection\"));\n        if (!(menuReferences.isEmpty())) {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a51a4a0a6());\n          for (SNode menuReference : ListSequence.fromList(menuReferences)) {\n            ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a0a1a51a4a0a6(menuReference));\n          }\n        } else if (isNullTransformationMenu) {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a0p0e0a0g());\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a1a0p0e0a0g());\n        } else {\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addSequence(ListSequence.fromList(Arrays.asList(_quotation_createNode_o8m9jz_a0a0a0a51a4a0a6(), _quotation_createNode_o8m9jz_b0a0a0a51a4a0a6(), _quotation_createNode_o8m9jz_c0a0a0a51a4a0a6())));\n          ListSequence.fromList(SLinkOperations.getChildren(includeSection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(_quotation_createNode_o8m9jz_a0a1a0p0e0a0g_0(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"))));\n        }\n        ListSequence.fromList(SLinkOperations.getChildren(additionalMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0c11832L, 0x16be955f384efffcL, \"sections\"))).addElement(includeSection);\n\n        if ((SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")) != null)) {\n          Iterable<SNode> applySideTransforms = SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x10f3514bb7cL, \"menuDescriptor\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10f34f6aaacL, 0x10f34f82910L, \"cellMenuPart\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, \"jetbrains.mps.lang.editor.structure.CellMenuPart_ApplySideTransforms\"));\n          SNode section = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, \"jetbrains.mps.lang.editor.structure.TransformationMenuSection\"));\n          SNode emptyCellLink = getEmptyCellLink(cell);\n          if (Sequence.fromIterable(applySideTransforms).isNotEmpty() || emptyCellLink != null) {\n            ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbdL, \"locations\"))).addElement(_quotation_createNode_o8m9jz_a0a0a3a81a4a0a6());\n            ListSequence.fromList(SLinkOperations.getChildren(additionalMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x4e0f93d8a0c11832L, 0x16be955f384efffcL, \"sections\"))).addElement(section);\n            if (Sequence.fromIterable(applySideTransforms).isNotEmpty()) {\n              for (SNode apply : Sequence.fromIterable(applySideTransforms)) {\n                String tag = SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0xc14e9fba94cb682L, \"tag\"), null);\n                if (tag == null || eq_o8m9jz_a0a0b0a0c0d0s0g0a0g(tag, \"\") || eq_o8m9jz_a0a1a0a2a3a81a6a0a6(tag, DEFAULT_TAG_NAME)) {\n                  SNode location = ActionMigrationHelper.createLocation(SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0x72449b609d0f1475L, \"side\"), null));\n                  SNode includeMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"));\n                  SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x1a0027b1197f7335L, \"location\"), location);\n\n                  menuWasFound = true;\n                  SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), createDefaultTransformationMenuReference(concept));\n                  ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(includeMenu);\n                } else {\n                  for (SNode menu : SetSequence.fromSet(findAllMainNamedMenusForTag(concept, tag))) {\n                    SNode location = ActionMigrationHelper.createLocation(SPropertyOperations.getString_def(apply, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x72449b609d0e77bbL, 0x72449b609d0f1475L, \"side\"), null));\n                    SNode includeMenu = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, \"jetbrains.mps.lang.editor.structure.TransformationMenuPart_IncludeMenu\"));\n                    SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x1a0027b1197f7335L, \"location\"), location);\n\n                    if (menu != null) {\n                      addMissingReference(menu, cell);\n                      menuWasFound = true;\n                      SNode transformationMenuReference = createNamedTransformationMenuReference(menu);\n                      if (transformationMenuReference != null) {\n                        SLinkOperations.setTarget(includeMenu, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xae2d2fe1c9d6be2L, 0x5d3b34577b3f7ee5L, \"menuReference\"), transformationMenuReference);\n                      }\n                    }\n                    ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(includeMenu);\n                  }\n                }\n              }\n            } else if (emptyCellLink != null) {\n              SNode includeSubstituteForLink = _quotation_createNode_o8m9jz_a0a0a2a3a81a4a0a6();\n              SLinkOperations.setTarget(includeSubstituteForLink, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6a77f9c87420a6caL, 0x5480a271c0f085b7L, \"link\"), emptyCellLink);\n              ListSequence.fromList(SLinkOperations.getChildren(section, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x6ec02d9918b4efbcL, 0x6ec02d9918b4efbfL, \"parts\"))).addElement(includeSubstituteForLink);\n            }\n          }\n        }\n\n        if (menuWasFound) {\n          SNodeOperations.getModel(cell).addRootNode(additionalMenu);\n          SLinkOperations.setTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\"), SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, \"jetbrains.mps.lang.editor.structure.TransformationMenuReference_Named\")));\n          SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, \"jetbrains.mps.lang.editor.structure.TransformationMenuReference_Named\")), MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5d3b34577b3cff09L, 0x5d3b34577b3cff0aL, \"menu\"), additionalMenu);\n          if (isNullTransformationMenu) {\n            MapSequence.fromMap(conceptAndTagsToAdditionalMenu).put(key, SLinkOperations.getTarget(cell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, 0x3a52dff8e5ebd740L, \"transformationMenu\")));\n          }\n        }\n        commentAndAddAnnotations(cell);\n      }\n    }\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addMissingReference(SNode menu, SNode cell) {\n    if (neq_o8m9jz_a0a0h(SNodeOperations.getModel(menu), SNodeOperations.getModel(cell))) {\n      SModelReference reference = SNodeOperations.getModel(menu).getReference();\n      if (SNodeOperations.getModel(cell) instanceof SModelInternal && ((SModelInternal) SNodeOperations.getModel(cell)).getModelImports().contains(reference)) {\n        ((SModelInternal) SNodeOperations.getModel(cell)).addModelImport(reference);\n      }\n    }\n  }","id":66415,"modified_method":"private void addMissingReference(SNode menuToReference, SNode node) {\n    if (neq_o8m9jz_a0a0h(SNodeOperations.getModel(menuToReference), SNodeOperations.getModel(node))) {\n      SModelReference reference = SNodeOperations.getModel(menuToReference).getReference();\n      if (SNodeOperations.getModel(node) instanceof SModelInternal && ((SModelInternal) SNodeOperations.getModel(node)).getModelImports().contains(reference)) {\n        ((SModelInternal) SNodeOperations.getModel(node)).addModelImport(reference);\n      }\n    }\n  }","commit_id":"ec1c3dae71bbb80ef878c761976a592121bea885","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @see org.ofbiz.webapp.view.ViewHandler#render(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void render(String name, String page, String info, String contentType, String encoding, HttpServletRequest request, HttpServletResponse response) throws ViewHandlerException {\n    \t\n        String contentId = request.getParameter(\"contentId\");\n        String rootContentId = request.getParameter(\"rootContentId\");\n        String mapKey = request.getParameter(\"mapKey\");\n        String fromDateStr = request.getParameter(\"fromDate\");\n    \tString dataResourceId = request.getParameter(\"dataResourceId\");\n        String contentRevisionSeqId = request.getParameter(\"contentRevisionSeqId\");\n        String mimeTypeId = request.getParameter(\"mimeTypeId\");\n        ByteWrapper byteWrapper = null;\n        Locale locale = UtilHttp.getLocale(request);\n        String rootDir = null;\n        String webSiteId = null;\n        String https = null;\n        \n        if (UtilValidate.isEmpty(rootDir)) {\n            rootDir = servletContext.getRealPath(\"/\");\n        }\n        if (UtilValidate.isEmpty(webSiteId)) {\n            webSiteId = (String) servletContext.getAttribute(\"webSiteId\");\n        }\n        if (UtilValidate.isEmpty(https)) {\n            https = (String) servletContext.getAttribute(\"https\");\n        }\n    \ttry {\n            Debug.logInfo(\"SCVH(0a)- dataResourceId:\" + dataResourceId, module);\n            GenericDelegator delegator = (GenericDelegator)request.getAttribute(\"delegator\");\n            if (UtilValidate.isEmpty(dataResourceId)) {\n                if (UtilValidate.isEmpty(contentRevisionSeqId)) {\n                    if (UtilValidate.isEmpty(mapKey)) {\n                        GenericValue content = delegator.findByPrimaryKeyCache(\"Content\", UtilMisc.toMap(\"contentId\", contentId));\n                        dataResourceId = content.getString(\"dataResourceId\");\n                        Debug.logInfo(\"SCVH(0b)- dataResourceId:\" + dataResourceId, module);\n                    } else {\n                        Timestamp fromDate = null;\n                        if (UtilValidate.isEmpty(fromDateStr)) {\n                            fromDateStr = UtilDateTime.nowAsString();\n                        }\n                        try {\n                            fromDate = UtilDateTime.stringToTimeStamp(fromDateStr, null, locale);\n                        } catch (ParseException e) {\n                            fromDate = UtilDateTime.nowTimestamp();\n                        }\n                        GenericValue content = ContentWorker.getSubContent(delegator, contentId, mapKey, null, null, null, fromDate);\n                        dataResourceId = content.getString(\"dataResourceId\");\n                        Debug.logInfo(\"SCVH(0b)- dataResourceId:\" + dataResourceId, module);\n                    }\n                } else {\n                   GenericValue contentRevisionItem = delegator.findByPrimaryKeyCache(\"ContentRevisionItem\", UtilMisc.toMap(\"contentId\", rootContentId, \"itemContentId\", contentId, \"contentRevisionSeqId\", contentRevisionSeqId));\n                   if (contentRevisionItem == null) {\n                       throw new ViewHandlerException(\"ContentRevisionItem record not found for contentId=\" + rootContentId\n                                                      + \", contentRevisionSeqId=\" + contentRevisionSeqId + \", itemContentId=\" + contentId);\n                   }\n                   Debug.logInfo(\"SCVH(1)- contentRevisionItem:\" + contentRevisionItem, module);\n                   Debug.logInfo(\"SCVH(2)-contentId=\" + rootContentId\n                           + \", contentRevisionSeqId=\" + contentRevisionSeqId + \", itemContentId=\" + contentId, module);\n                   dataResourceId = contentRevisionItem.getString(\"newDataResourceId\");\n                   Debug.logInfo(\"SCVH(3)- dataResourceId:\" + dataResourceId, module);\n                }\n    \t\t}\n\t\t\tGenericValue dataResource = delegator.findByPrimaryKeyCache(\"DataResource\", UtilMisc.toMap(\"dataResourceId\", dataResourceId));\n    \t\tbyteWrapper = DataResourceWorker.getContentAsByteWrapper(delegator, dataResourceId, https, webSiteId, locale, rootDir);\n    \t\tByteArrayInputStream bais = new ByteArrayInputStream(byteWrapper.getBytes());\n            // hack for IE and mime types\n            //String userAgent = request.getHeader(\"User-Agent\");\n            //if (userAgent.indexOf(\"MSIE\") > -1) {\n            //    Debug.log(\"Found MSIE changing mime type from - \" + mimeTypeId, module);\n            //    mimeTypeId = \"application/octet-stream\";\n            //}\n            // setup chararcter encoding and content type\n            String charset = dataResource.getString(\"characterSetId\");\n            mimeTypeId = dataResource.getString(\"mimeTypeId\");\n            if (UtilValidate.isEmpty(charset)) {\n            \tcharset = servletContext.getInitParameter(\"charset\");\n            }\n            if (UtilValidate.isEmpty(charset)) {\n            \tcharset = \"ISO-8859-1\";\n            }\n\n            // setup content type\n            String contentType2 = UtilValidate.isNotEmpty(mimeTypeId) ? mimeTypeId + \"; charset=\" +charset : contentType;\n\n            UtilHttp.streamContentToBrowser(response, bais, byteWrapper.getLength(), contentType2);\n    \t} catch(GenericEntityException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t} catch(IOException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t} catch(GeneralException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t}\n     }","id":66416,"modified_method":"/**\n     * @see org.ofbiz.webapp.view.ViewHandler#render(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void render(String name, String page, String info, String contentType, String encoding, HttpServletRequest request, HttpServletResponse response) throws ViewHandlerException {\n    \t\n        String contentId = request.getParameter(\"contentId\");\n        String rootContentId = request.getParameter(\"rootContentId\");\n        String mapKey = request.getParameter(\"mapKey\");\n        String contentAssocTypeId = request.getParameter(\"contentAssocTypeId\");\n        String fromDateStr = request.getParameter(\"fromDate\");\n    \tString dataResourceId = request.getParameter(\"dataResourceId\");\n        String contentRevisionSeqId = request.getParameter(\"contentRevisionSeqId\");\n        String mimeTypeId = request.getParameter(\"mimeTypeId\");\n        ByteWrapper byteWrapper = null;\n        Locale locale = UtilHttp.getLocale(request);\n        String rootDir = null;\n        String webSiteId = null;\n        String https = null;\n        \n        if (UtilValidate.isEmpty(rootDir)) {\n            rootDir = servletContext.getRealPath(\"/\");\n        }\n        if (UtilValidate.isEmpty(webSiteId)) {\n            webSiteId = (String) servletContext.getAttribute(\"webSiteId\");\n        }\n        if (UtilValidate.isEmpty(https)) {\n            https = (String) servletContext.getAttribute(\"https\");\n        }\n    \ttry {\n            Debug.logInfo(\"SCVH(0a)- dataResourceId:\" + dataResourceId, module);\n            GenericDelegator delegator = (GenericDelegator)request.getAttribute(\"delegator\");\n            if (UtilValidate.isEmpty(dataResourceId)) {\n                if (UtilValidate.isEmpty(contentRevisionSeqId)) {\n                    if (UtilValidate.isEmpty(mapKey) && UtilValidate.isEmpty(contentAssocTypeId)) {\n                        GenericValue content = delegator.findByPrimaryKeyCache(\"Content\", UtilMisc.toMap(\"contentId\", contentId));\n                        dataResourceId = content.getString(\"dataResourceId\");\n                        Debug.logInfo(\"SCVH(0b)- dataResourceId:\" + dataResourceId, module);\n                    } else {\n                        Timestamp fromDate = null;\n                        if (UtilValidate.isNotEmpty(fromDateStr)) {\n                            try {\n                                fromDate = UtilDateTime.stringToTimeStamp(fromDateStr, null, locale);\n                            } catch (ParseException e) {\n                                fromDate = UtilDateTime.nowTimestamp();\n                            }\n                        }\n                        List assocList = null;\n                        if (UtilValidate.isNotEmpty(contentAssocTypeId)) {\n                            assocList = UtilMisc.toList(contentAssocTypeId);\n                        }\n                        GenericValue content = ContentWorker.getSubContent(delegator, contentId, mapKey, null, null, assocList, fromDate);\n                        dataResourceId = content.getString(\"dataResourceId\");\n                        Debug.logInfo(\"SCVH(0b)- dataResourceId:\" + dataResourceId, module);\n                    }\n                } else {\n                   GenericValue contentRevisionItem = delegator.findByPrimaryKeyCache(\"ContentRevisionItem\", UtilMisc.toMap(\"contentId\", rootContentId, \"itemContentId\", contentId, \"contentRevisionSeqId\", contentRevisionSeqId));\n                   if (contentRevisionItem == null) {\n                       throw new ViewHandlerException(\"ContentRevisionItem record not found for contentId=\" + rootContentId\n                                                      + \", contentRevisionSeqId=\" + contentRevisionSeqId + \", itemContentId=\" + contentId);\n                   }\n                   Debug.logInfo(\"SCVH(1)- contentRevisionItem:\" + contentRevisionItem, module);\n                   Debug.logInfo(\"SCVH(2)-contentId=\" + rootContentId\n                           + \", contentRevisionSeqId=\" + contentRevisionSeqId + \", itemContentId=\" + contentId, module);\n                   dataResourceId = contentRevisionItem.getString(\"newDataResourceId\");\n                   Debug.logInfo(\"SCVH(3)- dataResourceId:\" + dataResourceId, module);\n                }\n    \t\t}\n\t\t\tGenericValue dataResource = delegator.findByPrimaryKeyCache(\"DataResource\", UtilMisc.toMap(\"dataResourceId\", dataResourceId));\n    \t\tbyteWrapper = DataResourceWorker.getContentAsByteWrapper(delegator, dataResourceId, https, webSiteId, locale, rootDir);\n    \t\tByteArrayInputStream bais = new ByteArrayInputStream(byteWrapper.getBytes());\n            // hack for IE and mime types\n            //String userAgent = request.getHeader(\"User-Agent\");\n            //if (userAgent.indexOf(\"MSIE\") > -1) {\n            //    Debug.log(\"Found MSIE changing mime type from - \" + mimeTypeId, module);\n            //    mimeTypeId = \"application/octet-stream\";\n            //}\n            // setup chararcter encoding and content type\n            String charset = dataResource.getString(\"characterSetId\");\n            mimeTypeId = dataResource.getString(\"mimeTypeId\");\n            if (UtilValidate.isEmpty(charset)) {\n            \tcharset = servletContext.getInitParameter(\"charset\");\n            }\n            if (UtilValidate.isEmpty(charset)) {\n            \tcharset = \"ISO-8859-1\";\n            }\n\n            // setup content type\n            String contentType2 = UtilValidate.isNotEmpty(mimeTypeId) ? mimeTypeId + \"; charset=\" +charset : contentType;\n\n            UtilHttp.streamContentToBrowser(response, bais, byteWrapper.getLength(), contentType2);\n    \t} catch(GenericEntityException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t} catch(IOException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t} catch(GeneralException e) {\n            throw new ViewHandlerException(e.getMessage());\n    \t}\n     }","commit_id":"68f9dbc94d99b67fa732dc24cdc431ba52655ca0","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * persistContentAndAssoc\n     * A combination method that will create or update all or one of the following\n     * a Content entity, a ContentAssoc related to the Content and \n     * the ElectronicText that may be associated with the Content.\n     * The keys for determining if each entity is created is the presence\n     * of the contentTypeId, contentAssocTypeId and dataResourceTypeId.\n     * This service tries to handle DataResource and ContentAssoc fields with and\n     * without \"dr\" and \"ca\" prefixes.\n     * Assumes binary data is always in field, \"imageData\".\n     * \n     * This service does not accept straight ContentAssoc parameters. They must be prefaced with \"ca\" + cap first letter\n     */\n    public static Map persistContentAndAssoc(DispatchContext dctx, Map context) throws GenericServiceException {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        \n        Debug.logInfo(\"=========== type:\" + (String)context.get(\"dataresourceTypeId\") , module);\n        // Knowing why a request fails permission check is one of the more difficult\n        // aspects of content management. Setting \"displayFailCond\" to true will\n        // put an html table in result.errorMessage that will show what tests were performed\n        Boolean bDisplayFailCond = (Boolean)context.get(\"displayFailCond\");\n        String mapKey = (String) context.get(\"mapKey\"); \n        \n        // If \"deactivateExisting\" is set, other Contents that are tied to the same\n        // contentIdTo will be deactivated (thruDate set to now)\n        String deactivateString = (String) context.get(\"deactivateExisting\");\n        boolean deactivateExisting = \"true\".equalsIgnoreCase(deactivateString); \n\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... mapKey(0):\" + mapKey, null);\n\n        // ContentPurposes can get passed in as a delimited string or a list. Combine.\n        List contentPurposeList = (List)context.get(\"contentPurposeList\");\n        if (contentPurposeList == null)\n            contentPurposeList = new ArrayList();\n        String contentPurposeString = (String) context.get(\"contentPurposeString\");\n        if (UtilValidate.isNotEmpty(contentPurposeString)) {\n            List tmpPurposes = StringUtil.split(contentPurposeString, \"|\");\n            contentPurposeList.addAll(tmpPurposes);\n        }\n        if (contentPurposeList != null ) {\n            context.put(\"contentPurposeList\", contentPurposeList);   \n            context.put(\"contentPurposeString\", null);   \n        }\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentPurposeList(0):\" + contentPurposeList, null);\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... textData(0):\" + context.get(\"textData\"), null);\n        \n\n        GenericValue content = delegator.makeValue(\"Content\", null);\n        content.setPKFields(context);\n        content.setNonPKFields(context);\n        String contentId = (String) content.get(\"contentId\");\n        String contentTypeId = (String) content.get(\"contentTypeId\");\n        String origContentId = (String) content.get(\"contentId\");\n        String origDataResourceId = (String) content.get(\"dataResourceId\");\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentId(0):\" + contentId, null);\n\n        GenericValue dataResource = delegator.makeValue(\"DataResource\", null);\n        dataResource.setPKFields(context);\n        dataResource.setNonPKFields(context);\n        dataResource.setAllFields(context, false, \"dr\", null);\n        context.putAll(dataResource);\n        String dataResourceId = (String) dataResource.get(\"dataResourceId\");\n        String dataResourceTypeId = (String) dataResource.get(\"dataResourceTypeId\");\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... dataResourceId(0):\" + dataResourceId, null);\n\n        GenericValue contentAssoc = delegator.makeValue(\"ContentAssoc\", null);\n        contentAssoc.setAllFields(context, false, \"ca\", null);\n        context.putAll(contentAssoc);\n\n        GenericValue electronicText = delegator.makeValue(\"ElectronicText\", null);\n        electronicText.setPKFields(context);\n        electronicText.setNonPKFields(context);\n        \n        // save expected primary keys on result now in case there is no operation that uses them\n        Map results = ServiceUtil.returnSuccess();\n        results.put(\"contentId\", content.get(\"contentId\"));\n        results.put(\"dataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"drDataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"drDataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"caContentIdTo\", contentAssoc.get(\"contentIdTo\"));\n        results.put(\"caContentId\", contentAssoc.get(\"contentId\"));\n        results.put(\"caFromDate\", contentAssoc.get(\"fromDate\"));\n        results.put(\"caContentAssocTypeId\", contentAssoc.get(\"contentAssocTypeId\"));\n        \n        // get user info for multiple use\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\"); \n\n        // TODO: DEJ20060221 Should these be used somewhere?\n        //String textData = (String)electronicText.get(\"textData\");\n\n        //String userLoginId = (String)userLogin.get(\"userLoginId\");\n        \n        //String createdByUserLogin = userLoginId;\n        //String lastModifiedByUserLogin = userLoginId;\n        //Timestamp createdDate = UtilDateTime.nowTimestamp();\n        //Timestamp lastModifiedDate = UtilDateTime.nowTimestamp();\n\n        // Do update and create permission checks on DataResource if warranted.\n        //boolean updatePermOK = false;\n        //boolean createPermOK = false;\n\n\n        boolean dataResourceExists = true;\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... dataResourceTypeId(0):\" + dataResourceTypeId, null);\n        if (UtilValidate.isNotEmpty(dataResourceTypeId) ) {\n            Map dataResourceResult = new HashMap();\n            try {\n                dataResourceResult = persistDataResourceAndDataMethod(dctx, context);\n            } catch (GenericServiceException e) {\n                return ServiceUtil.returnError(e.getMessage());\n            } catch (GenericEntityException e) {\n                return ServiceUtil.returnError(e.getMessage());\n            } catch (Exception e) {\n                return ServiceUtil.returnError(e.getMessage());\n            }\n            String errorMsg = ServiceUtil.getErrorMessage(dataResourceResult);\n            if (UtilValidate.isNotEmpty(errorMsg)) {\n                return ServiceUtil.returnError(errorMsg);\n            }\n            dataResourceId = (String)dataResourceResult.get(\"dataResourceId\");\n            results.put(\"dataResourceId\", dataResourceId);\n            results.put(\"drDataResourceId\", dataResourceId);\n            context.put(\"dataResourceId\", dataResourceId);\n            content.put(\"dataResourceId\", dataResourceId);\n            context.put(\"drDataResourceId\", dataResourceId);\n        }\n        // Do update and create permission checks on Content if warranted.\n\n        context.put(\"skipPermissionCheck\", null);  // Force check here\n        boolean contentExists = true;\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentTypeId:\" +  contentTypeId + \" dataResourceTypeId:\" + dataResourceTypeId + \" contentId:\" + contentId + \" dataResourceId:\" + dataResourceId, null);\n        if (UtilValidate.isNotEmpty(contentTypeId) ) {\n            if (UtilValidate.isEmpty(contentId)) {\n                contentExists = false;\n            } else {\n                try {\n                    GenericValue val = delegator.findByPrimaryKey(\"Content\", UtilMisc.toMap(\"contentId\", contentId));\n                    if (val == null) contentExists = false;\n                } catch(GenericEntityException e) {\n                    return ServiceUtil.returnError(e.getMessage());\n                }\n            }\n            //List targetOperations = new ArrayList();\n            //context.put(\"targetOperations\", targetOperations);\n            context.putAll(content);\n            if (contentExists) {\n                //targetOperations.add(\"CONTENT_UPDATE\");\n                Map contentContext = new HashMap();\n                ModelService contentModel = dispatcher.getDispatchContext().getModelService(\"updateContent\");\n                contentContext.putAll(contentModel.makeValid(context, \"IN\"));\n                contentContext.put(\"userLogin\", userLogin);\n                contentContext.put(\"displayFailCond\", bDisplayFailCond);\n                contentContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n                Map thisResult = dispatcher.runSync(\"updateContent\", contentContext);\n                if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult)) {\n                    return ServiceUtil.returnError(\"Error updating content (updateContent) in persistContentAndAssoc\", null, null, thisResult);\n                }\n                //Map thisResult = ContentServices.updateContentMethod(dctx, context);\n            } else {\n                //targetOperations.add(\"CONTENT_CREATE\");\n                Map contentContext = new HashMap();\n                ModelService contentModel = dispatcher.getDispatchContext().getModelService(\"createContent\");\n                contentContext.putAll(contentModel.makeValid(context, \"IN\"));\n                contentContext.put(\"userLogin\", userLogin);\n                contentContext.put(\"displayFailCond\", bDisplayFailCond);\n                contentContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n                Debug.logInfo(\"In persistContentAndAssoc calling createContent with content: \" + contentContext, module);\n                Map thisResult = dispatcher.runSync(\"createContent\", contentContext);\n                if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult)) {\n                    return ServiceUtil.returnError(\"Error creating content (createContent) in persistContentAndAssoc\", null, null, thisResult);\n                }\n                //Map thisResult = ContentServices.createContentMethod(dctx, context);\n\n                contentId = (String) thisResult.get(\"contentId\");\n            }\n            results.put(\"contentId\", contentId);\n            context.put(\"contentId\", contentId);\n            context.put(\"caContentIdTo\", contentId);\n            contentAssoc.put(\"contentIdTo\", contentId);\n\n            // Add ContentPurposes if this is a create operation\n            if (contentId != null && !contentExists) {\n                try {\n                    if (contentPurposeList != null) {\n                        HashSet contentPurposeSet = new HashSet(contentPurposeList);\n                        Iterator iter = contentPurposeSet.iterator();\n                        while (iter.hasNext()) {\n                            String contentPurposeTypeId = (String)iter.next();\n                            GenericValue contentPurpose = delegator.makeValue(\"ContentPurpose\",\n                                   UtilMisc.toMap(\"contentId\", contentId, \n                                                  \"contentPurposeTypeId\", contentPurposeTypeId) );\n                            contentPurpose.create();\n                        }\n                    }\n                } catch(GenericEntityException e) {\n                    return ServiceUtil.returnError(e.getMessage());\n                }\n            }\n\n        } else if (UtilValidate.isNotEmpty(dataResourceTypeId) && UtilValidate.isNotEmpty(contentId)) {\n            // If dataResource was not previously existing, then update the associated content with its id\n            if (UtilValidate.isNotEmpty(dataResourceId) && !dataResourceExists) {\n                Map map = new HashMap();\n                map.put(\"userLogin\", userLogin);\n                map.put(\"dataResourceId\", dataResourceId);\n                map.put(\"contentId\", contentId);\n                if (Debug.infoOn()) Debug.logInfo(\"in persist... context:\" + context, module);\n                Map r = ContentServices.updateContentMethod(dctx, map);\n                boolean isError = ModelService.RESPOND_ERROR.equals(r.get(ModelService.RESPONSE_MESSAGE));\n                if (isError) \n                    return ServiceUtil.returnError( (String)r.get(ModelService.ERROR_MESSAGE));\n            }\n        }\n\n        // If parentContentIdTo or parentContentIdFrom exists, create association with newly created content\n        String contentAssocTypeId = (String)context.get(\"contentAssocTypeId\");\n        if (UtilValidate.isEmpty(contentAssocTypeId)) \n            contentAssocTypeId = (String)context.get(\"caContentAssocTypeId\");\n\n        if (Debug.infoOn()) Debug.logInfo(\"CREATING contentASSOC contentAssocTypeId:\" +  contentAssocTypeId, null);\n        // create content assoc if the key values are present....\n        if (contentAssocTypeId != null && contentAssocTypeId.length() > 0 && contentAssoc.get(\"contentId\") != null && contentAssoc.get(\"contentIdTo\") != null ) {\n            if (Debug.infoOn()) Debug.logInfo(\"in persistContentAndAssoc, deactivateExisting:\" +  deactivateExisting, null);\n            Map contentAssocContext = new HashMap();\n            contentAssocContext.put(\"userLogin\", userLogin);\n            contentAssocContext.put(\"displayFailCond\", bDisplayFailCond);\n            contentAssocContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n            Map thisResult = null;\n            try {\n                GenericValue contentAssocExisting = delegator.findByPrimaryKey(\"ContentAssoc\", contentAssoc.getPrimaryKey());\n                if (contentAssocExisting == null) {\n                    ModelService contentAssocModel = dispatcher.getDispatchContext().getModelService(\"createContentAssoc\");\n                    Map ctx = contentAssocModel.makeValid(contentAssoc, \"IN\");\n                    contentAssocContext.putAll(ctx);\n                    thisResult = dispatcher.runSync(\"createContentAssoc\", contentAssocContext);\n                    String errMsg = ServiceUtil.getErrorMessage(thisResult);\n                    if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult) || UtilValidate.isNotEmpty(errMsg)) {\n                        return ServiceUtil.returnError(errMsg);\n                    }\n//                    results.put(\"contentIdTo\", thisResult.get(\"contentIdTo\"));\n//                    results.put(\"contentIdFrom\", thisResult.get(\"contentIdFrom\"));\n//                    //results.put(\"contentId\", thisResult.get(\"contentIdFrom\"));\n//                    results.put(\"contentAssocTypeId\", thisResult.get(\"contentAssocTypeId\"));\n//                    results.put(\"fromDate\", thisResult.get(\"fromDate\"));\n//                    results.put(\"sequenceNum\", thisResult.get(\"sequenceNum\"));\n                    \n                    results.put(\"caContentIdTo\", thisResult.get(\"contentIdTo\"));\n                    results.put(\"caContentId\", thisResult.get(\"contentIdFrom\"));\n                    results.put(\"caContentAssocTypeId\", thisResult.get(\"contentAssocTypeId\"));\n                    results.put(\"caFromDate\", thisResult.get(\"fromDate\"));\n                    results.put(\"caSequenceNum\", thisResult.get(\"sequenceNum\"));\n                } else {\n                    if (deactivateExisting) {\n                        contentAssoc.put(\"thruDate\",UtilDateTime.nowTimestamp());\n                    }\n                    ModelService contentAssocModel = dispatcher.getDispatchContext().getModelService(\"updateContentAssoc\");\n                    Map ctx = contentAssocModel.makeValid(contentAssoc, \"IN\");\n                    contentAssocContext.putAll(ctx);\n                    thisResult = dispatcher.runSync(\"updateContentAssoc\", contentAssocContext);\n                    String errMsg = ServiceUtil.getErrorMessage(thisResult);\n                    if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult) || UtilValidate.isNotEmpty(errMsg)) {\n                        return ServiceUtil.returnError(errMsg);\n                    }\n                }\n            } catch (GenericEntityException e) {\n                throw new GenericServiceException(e.getMessage());\n            } catch (Exception e2) {\n                throw new GenericServiceException(e2.getMessage());\n            }\n            String errMsg = ServiceUtil.getErrorMessage(thisResult);\n           if (UtilValidate.isNotEmpty(errMsg)) {\n               return ServiceUtil.returnError(errMsg);\n           }\n       }\n       context.remove(\"skipPermissionCheck\");\n       context.put(\"contentId\", origContentId);\n       context.put(\"dataResourceId\", origDataResourceId);\n       context.remove(\"dataResource\");\n       Debug.logInfo(\"results:\" + results, module);\n       return results;\n    }","id":66417,"modified_method":"/**\n     * persistContentAndAssoc\n     * A combination method that will create or update all or one of the following:\n     * a Content entity, a ContentAssoc related to the Content, and \n     * the ElectronicText that may be associated with the Content.\n     * The keys for determining if each entity is created is the presence\n     * of the contentTypeId, contentAssocTypeId and dataResourceTypeId.\n     * This service tries to handle DataResource fields with and\n     * without \"dr\" prefixes.\n     * Assumes binary data is always in field, \"imageData\".\n     * \n     * This service does not accept straight ContentAssoc parameters. They must be prefaced with \"ca\" + cap first letter\n     */\n    public static Map persistContentAndAssoc(DispatchContext dctx, Map context) throws GenericServiceException {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        \n        Debug.logInfo(\"=========== type:\" + (String)context.get(\"dataresourceTypeId\") , module);\n        // Knowing why a request fails permission check is one of the more difficult\n        // aspects of content management. Setting \"displayFailCond\" to true will\n        // put an html table in result.errorMessage that will show what tests were performed\n        Boolean bDisplayFailCond = (Boolean)context.get(\"displayFailCond\");\n        String mapKey = (String) context.get(\"mapKey\"); \n        \n        // If \"deactivateExisting\" is set, other Contents that are tied to the same\n        // contentIdTo will be deactivated (thruDate set to now)\n        String deactivateString = (String) context.get(\"deactivateExisting\");\n        boolean deactivateExisting = \"true\".equalsIgnoreCase(deactivateString); \n\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... mapKey(0):\" + mapKey, null);\n\n        // ContentPurposes can get passed in as a delimited string or a list. Combine.\n        List contentPurposeList = (List)context.get(\"contentPurposeList\");\n        if (contentPurposeList == null)\n            contentPurposeList = new ArrayList();\n        String contentPurposeString = (String) context.get(\"contentPurposeString\");\n        if (UtilValidate.isNotEmpty(contentPurposeString)) {\n            List tmpPurposes = StringUtil.split(contentPurposeString, \"|\");\n            contentPurposeList.addAll(tmpPurposes);\n        }\n        if (contentPurposeList != null ) {\n            context.put(\"contentPurposeList\", contentPurposeList);   \n            context.put(\"contentPurposeString\", null);   \n        }\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentPurposeList(0):\" + contentPurposeList, null);\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... textData(0):\" + context.get(\"textData\"), null);\n        \n\n        GenericValue content = delegator.makeValue(\"Content\", null);\n        content.setPKFields(context);\n        content.setNonPKFields(context);\n        String contentId = (String) content.get(\"contentId\");\n        String contentTypeId = (String) content.get(\"contentTypeId\");\n        String origContentId = (String) content.get(\"contentId\");\n        String origDataResourceId = (String) content.get(\"dataResourceId\");\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentId(0):\" + contentId, null);\n\n        GenericValue dataResource = delegator.makeValue(\"DataResource\", null);\n        dataResource.setPKFields(context);\n        dataResource.setNonPKFields(context);\n        dataResource.setAllFields(context, false, \"dr\", null);\n        context.putAll(dataResource);\n        String dataResourceId = (String) dataResource.get(\"dataResourceId\");\n        String dataResourceTypeId = (String) dataResource.get(\"dataResourceTypeId\");\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... dataResourceId(0):\" + dataResourceId, null);\n\n        GenericValue contentAssoc = delegator.makeValue(\"ContentAssoc\", null);\n        String contentAssocTypeId = (String)context.get(\"contentAssocTypeId\");\n        if (UtilValidate.isNotEmpty(contentAssocTypeId)) {\n            context.put(\"caContentAssocTypeId\", contentAssocTypeId);\n        }\n        contentAssocTypeId = (String)context.get(\"caContentAssocTypeId\");\n        contentAssoc.setAllFields(context, false, \"ca\", null);\n        contentAssoc.put(\"contentId\", context.get(\"caContentId\"));\n        context.putAll(contentAssoc);\n\n        GenericValue electronicText = delegator.makeValue(\"ElectronicText\", null);\n        electronicText.setPKFields(context);\n        electronicText.setNonPKFields(context);\n        \n        // save expected primary keys on result now in case there is no operation that uses them\n        Map results = ServiceUtil.returnSuccess();\n        results.put(\"contentId\", content.get(\"contentId\"));\n        results.put(\"dataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"drDataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"drDataResourceId\", dataResource.get(\"dataResourceId\"));\n        results.put(\"caContentIdTo\", contentAssoc.get(\"contentIdTo\"));\n        results.put(\"caContentId\", contentAssoc.get(\"contentId\"));\n        results.put(\"caFromDate\", contentAssoc.get(\"fromDate\"));\n        results.put(\"caContentAssocTypeId\", contentAssoc.get(\"contentAssocTypeId\"));\n        \n        // get user info for multiple use\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\"); \n\n        // TODO: DEJ20060221 Should these be used somewhere?\n        //String textData = (String)electronicText.get(\"textData\");\n\n        //String userLoginId = (String)userLogin.get(\"userLoginId\");\n        \n        //String createdByUserLogin = userLoginId;\n        //String lastModifiedByUserLogin = userLoginId;\n        //Timestamp createdDate = UtilDateTime.nowTimestamp();\n        //Timestamp lastModifiedDate = UtilDateTime.nowTimestamp();\n\n        // Do update and create permission checks on DataResource if warranted.\n        //boolean updatePermOK = false;\n        //boolean createPermOK = false;\n\n\n        boolean dataResourceExists = true;\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... dataResourceTypeId(0):\" + dataResourceTypeId, null);\n        if (UtilValidate.isNotEmpty(dataResourceTypeId) ) {\n            Map dataResourceResult = new HashMap();\n            try {\n                dataResourceResult = persistDataResourceAndDataMethod(dctx, context);\n            } catch (GenericServiceException e) {\n                return ServiceUtil.returnError(e.getMessage());\n            } catch (GenericEntityException e) {\n                return ServiceUtil.returnError(e.getMessage());\n            } catch (Exception e) {\n                return ServiceUtil.returnError(e.getMessage());\n            }\n            String errorMsg = ServiceUtil.getErrorMessage(dataResourceResult);\n            if (UtilValidate.isNotEmpty(errorMsg)) {\n                return ServiceUtil.returnError(errorMsg);\n            }\n            dataResourceId = (String)dataResourceResult.get(\"dataResourceId\");\n            results.put(\"dataResourceId\", dataResourceId);\n            results.put(\"drDataResourceId\", dataResourceId);\n            context.put(\"dataResourceId\", dataResourceId);\n            content.put(\"dataResourceId\", dataResourceId);\n            context.put(\"drDataResourceId\", dataResourceId);\n        }\n        // Do update and create permission checks on Content if warranted.\n\n        context.put(\"skipPermissionCheck\", null);  // Force check here\n        boolean contentExists = true;\n        if (Debug.infoOn()) Debug.logInfo(\"in persist... contentTypeId:\" +  contentTypeId + \" dataResourceTypeId:\" + dataResourceTypeId + \" contentId:\" + contentId + \" dataResourceId:\" + dataResourceId, null);\n        if (UtilValidate.isNotEmpty(contentTypeId) ) {\n            if (UtilValidate.isEmpty(contentId)) {\n                contentExists = false;\n            } else {\n                try {\n                    GenericValue val = delegator.findByPrimaryKey(\"Content\", UtilMisc.toMap(\"contentId\", contentId));\n                    if (val == null) contentExists = false;\n                } catch(GenericEntityException e) {\n                    return ServiceUtil.returnError(e.getMessage());\n                }\n            }\n            //List targetOperations = new ArrayList();\n            //context.put(\"targetOperations\", targetOperations);\n            context.putAll(content);\n            if (contentExists) {\n                //targetOperations.add(\"CONTENT_UPDATE\");\n                Map contentContext = new HashMap();\n                ModelService contentModel = dispatcher.getDispatchContext().getModelService(\"updateContent\");\n                contentContext.putAll(contentModel.makeValid(content, \"IN\"));\n                contentContext.put(\"userLogin\", userLogin);\n                contentContext.put(\"displayFailCond\", bDisplayFailCond);\n                contentContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n                Map thisResult = dispatcher.runSync(\"updateContent\", contentContext);\n                if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult)) {\n                    return ServiceUtil.returnError(\"Error updating content (updateContent) in persistContentAndAssoc\", null, null, thisResult);\n                }\n                //Map thisResult = ContentServices.updateContentMethod(dctx, context);\n            } else {\n                //targetOperations.add(\"CONTENT_CREATE\");\n                Map contentContext = new HashMap();\n                ModelService contentModel = dispatcher.getDispatchContext().getModelService(\"createContent\");\n                contentContext.putAll(contentModel.makeValid(content, \"IN\"));\n                contentContext.put(\"userLogin\", userLogin);\n                contentContext.put(\"displayFailCond\", bDisplayFailCond);\n                contentContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n                Debug.logInfo(\"In persistContentAndAssoc calling createContent with content: \" + contentContext, module);\n                Map thisResult = dispatcher.runSync(\"createContent\", contentContext);\n                if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult)) {\n                    return ServiceUtil.returnError(\"Error creating content (createContent) in persistContentAndAssoc\", null, null, thisResult);\n                }\n                //Map thisResult = ContentServices.createContentMethod(dctx, context);\n\n                contentId = (String) thisResult.get(\"contentId\");\n            }\n            results.put(\"contentId\", contentId);\n            context.put(\"contentId\", contentId);\n            context.put(\"caContentIdTo\", contentId);\n            contentAssoc.put(\"contentIdTo\", contentId);\n\n            // Add ContentPurposes if this is a create operation\n            if (contentId != null && !contentExists) {\n                try {\n                    if (contentPurposeList != null) {\n                        HashSet contentPurposeSet = new HashSet(contentPurposeList);\n                        Iterator iter = contentPurposeSet.iterator();\n                        while (iter.hasNext()) {\n                            String contentPurposeTypeId = (String)iter.next();\n                            GenericValue contentPurpose = delegator.makeValue(\"ContentPurpose\",\n                                   UtilMisc.toMap(\"contentId\", contentId, \n                                                  \"contentPurposeTypeId\", contentPurposeTypeId) );\n                            contentPurpose.create();\n                        }\n                    }\n                } catch(GenericEntityException e) {\n                    return ServiceUtil.returnError(e.getMessage());\n                }\n            }\n\n        } else if (UtilValidate.isNotEmpty(dataResourceTypeId) && UtilValidate.isNotEmpty(contentId)) {\n            // If dataResource was not previously existing, then update the associated content with its id\n            if (UtilValidate.isNotEmpty(dataResourceId) && !dataResourceExists) {\n                Map map = new HashMap();\n                map.put(\"userLogin\", userLogin);\n                map.put(\"dataResourceId\", dataResourceId);\n                map.put(\"contentId\", contentId);\n                if (Debug.infoOn()) Debug.logInfo(\"in persist... context:\" + context, module);\n                Map r = ContentServices.updateContentMethod(dctx, map);\n                boolean isError = ModelService.RESPOND_ERROR.equals(r.get(ModelService.RESPONSE_MESSAGE));\n                if (isError) \n                    return ServiceUtil.returnError( (String)r.get(ModelService.ERROR_MESSAGE));\n            }\n        }\n\n        // If parentContentIdTo or parentContentIdFrom exists, create association with newly created content\n        if (Debug.infoOn()) {\n            Debug.logInfo(\"CREATING contentASSOC contentAssocTypeId:\" + contentAssocTypeId, null);\n        }\n        // create content assoc if the key values are present....\n        Debug.logInfo(\"contentAssoc: \" + contentAssoc.toString(), null);\n        if (UtilValidate.isNotEmpty(contentAssocTypeId) && contentAssoc.get(\"contentId\") != null && contentAssoc.get(\"contentIdTo\") != null) {\n            if (Debug.infoOn())\n                Debug.logInfo(\"in persistContentAndAssoc, deactivateExisting:\" + deactivateExisting, null);\n            Map contentAssocContext = new HashMap();\n            contentAssocContext.put(\"userLogin\", userLogin);\n            contentAssocContext.put(\"displayFailCond\", bDisplayFailCond);\n            contentAssocContext.put(\"skipPermissionCheck\", context.get(\"skipPermissionCheck\"));\n            Map thisResult = null;\n            try {\n                GenericValue contentAssocExisting = delegator.findByPrimaryKey(\"ContentAssoc\", contentAssoc.getPrimaryKey());\n                if (contentAssocExisting == null) {\n                    ModelService contentAssocModel = dispatcher.getDispatchContext().getModelService(\"createContentAssoc\");\n                    Map ctx = contentAssocModel.makeValid(contentAssoc, \"IN\");\n                    contentAssocContext.putAll(ctx);\n                    thisResult = dispatcher.runSync(\"createContentAssoc\", contentAssocContext);\n                    String errMsg = ServiceUtil.getErrorMessage(thisResult);\n                    if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult) || UtilValidate.isNotEmpty(errMsg)) {\n                        return ServiceUtil.returnError(errMsg);\n                    }\n                    // results.put(\"contentIdTo\",\n                    // thisResult.get(\"contentIdTo\"));\n                    // results.put(\"contentIdFrom\",\n                    // thisResult.get(\"contentIdFrom\"));\n                    // results.put(\"contentId\",\n                    // thisResult.get(\"contentIdFrom\"));\n                    // results.put(\"contentAssocTypeId\",\n                    // thisResult.get(\"contentAssocTypeId\"));\n                    // results.put(\"fromDate\", thisResult.get(\"fromDate\"));\n                    // results.put(\"sequenceNum\",\n                    // thisResult.get(\"sequenceNum\"));\n\n                    results.put(\"caContentIdTo\", thisResult.get(\"contentIdTo\"));\n                    results.put(\"caContentId\", thisResult.get(\"contentIdFrom\"));\n                    results.put(\"caContentAssocTypeId\", thisResult.get(\"contentAssocTypeId\"));\n                    results.put(\"caFromDate\", thisResult.get(\"fromDate\"));\n                    results.put(\"caSequenceNum\", thisResult.get(\"sequenceNum\"));\n                } else {\n                    if (deactivateExisting) {\n                        contentAssoc.put(\"thruDate\", UtilDateTime.nowTimestamp());\n                    }\n                    ModelService contentAssocModel = dispatcher.getDispatchContext().getModelService(\"updateContentAssoc\");\n                    Map ctx = contentAssocModel.makeValid(contentAssoc, \"IN\");\n                    contentAssocContext.putAll(ctx);\n                    thisResult = dispatcher.runSync(\"updateContentAssoc\", contentAssocContext);\n                    String errMsg = ServiceUtil.getErrorMessage(thisResult);\n                    if (ServiceUtil.isError(thisResult) || ServiceUtil.isFailure(thisResult) || UtilValidate.isNotEmpty(errMsg)) {\n                        return ServiceUtil.returnError(errMsg);\n                    }\n                }\n            } catch (GenericEntityException e) {\n                throw new GenericServiceException(e.getMessage());\n            } catch (Exception e2) {\n                throw new GenericServiceException(e2.getMessage());\n            }\n            String errMsg = ServiceUtil.getErrorMessage(thisResult);\n            if (UtilValidate.isNotEmpty(errMsg)) {\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n        context.remove(\"skipPermissionCheck\");\n        context.put(\"contentId\", origContentId);\n        context.put(\"dataResourceId\", origDataResourceId);\n        context.remove(\"dataResource\");\n        Debug.logInfo(\"results:\" + results, module);\n        return results;\n    }","commit_id":"dd2ee4962049be9105a2b236d7443fd897920a8b","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", \"en\" );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:asfext\", \"http://projects.apache.org/ns/asfext#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n\n        // Project\n        writer.startElement( \"Project\" );\n        writer.addAttribute( \"rdf:about\", \"http://Maven.rdf.apache.org/\" );\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        DoapUtil.writeRdfResourceElement( writer, \"asfext:pmc\", project.getUrl() );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        DoapUtil.writeRdfResourceElement( writer, \"download-page\", composeUrl( project.getUrl(), \"/download.html\" ) );\n        DoapUtil.writeElement( writer, \"programming-language\", language );\n        //TODO: how to lookup category, map it, or just declare it.\n        DoapUtil.writeRdfResourceElement( writer, \"category\", \"http://projects.apache.org/category/\" + category );\n\n        // Releases\n        publishReleases();\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        writer.endElement(); // Project\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n    }","id":66418,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", \"en\" );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:asfext\", \"http://projects.apache.org/ns/asfext#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n\n        // Project\n        writer.startElement( \"Project\" );\n        writer.addAttribute( \"rdf:about\", \"http://Maven.rdf.apache.org/\" );\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage and old-homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        DoapUtil.writeRdfResourceElement( writer, \"asfext:pmc\", project.getUrl() );\n\n        // programming-language\n        writeProgrammingLanguage( writer );\n\n        // category\n        writeCategory( writer );\n\n        // os\n        writeOS( writer );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        // download-page and download-mirror\n        writeDownloadPage( writer );\n\n        // screenshots\n        writeScreenshots( writer );\n\n        // Releases\n        publishReleases();\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        writer.endElement(); // Project\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n    }","commit_id":"7607890d37265e95a706d9ba0c8474241c6b58e8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write all DOAP repositories.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#Repository\">http://usefulinc.com/ns/doap#Repository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#CVSRepository\">http://usefulinc.com/ns/doap#CVSRepository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#SVNRepository\">http://usefulinc.com/ns/doap#SVNRepository<\/a>\n     */\n    private void writeSourceRepositories( XMLWriter writer )\n    {\n        Scm scm = project.getScm();\n        if ( scm == null )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Anonymous Connection\", 2 );\n        String anonymousConnection = scm.getConnection();\n        writeSourceRepository( writer, anonymousConnection );\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Developer Connection\", 2 );\n        String developerConnection = scm.getDeveloperConnection();\n        writeSourceRepository( writer, developerConnection );\n    }","id":66419,"modified_method":"/**\n     * Write all DOAP repositories.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#Repository\">http://usefulinc.com/ns/doap#Repository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#CVSRepository\">http://usefulinc.com/ns/doap#CVSRepository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#SVNRepository\">http://usefulinc.com/ns/doap#SVNRepository<\/a>\n     */\n    private void writeSourceRepositories( XMLWriter writer )\n    {\n        Scm scm = project.getScm();\n        if ( scm == null )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Anonymous Source Repository\", 2 );\n        String anonymousConnection = scm.getConnection();\n        writeSourceRepository( writer, anonymousConnection );\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Developer Source Repository\", 2 );\n        String developerConnection = scm.getDeveloperConnection();\n        writeSourceRepository( writer, developerConnection );\n    }","commit_id":"7607890d37265e95a706d9ba0c8474241c6b58e8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP created.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#created\">http://usefulinc.com/ns/doap#created<\/a>\n     */\n    private void writeCreated( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getInceptionYear() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Date when something was created, in YYYY-MM-DD form. e.g. 2004-04-05\",\n                                        2 );\n        // http://usefulinc.com/ns/doap#created\n        DoapUtil.writeElement( writer, \"created\", project.getInceptionYear() + \"/01/01\" );\n    }","id":66420,"modified_method":"/**\n     * Write DOAP created.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#created\">http://usefulinc.com/ns/doap#created<\/a>\n     */\n    private void writeCreated( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getInceptionYear() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Date when something was created, in YYYY-MM-DD form. e.g. 2004-04-05\",\n                                        2 );\n        // http://usefulinc.com/ns/doap#created\n        DoapUtil.writeElement( writer, \"created\", project.getInceptionYear() + \"-01-01\" );\n    }","commit_id":"7607890d37265e95a706d9ba0c8474241c6b58e8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP homepage.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#homepage\">http://usefulinc.com/ns/doap#homepage<\/a>\n     */\n    private void writeHomepage( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getUrl() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"URL of a project's homepage, associated with exactly one project.\", 2 );\n        // http://usefulinc.com/ns/doap#homepage\n        DoapUtil.writeRdfResourceElement( writer, \"homepage\", project.getUrl() );\n    }","id":66421,"modified_method":"/**\n     * Write DOAP homepage and old-homepage.\n     *\n     * @param writer\n     * @see <a href=\"http://usefulinc.com/ns/doap#homepage\">http://usefulinc.com/ns/doap#homepage<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#old-homepage\">http://usefulinc.com/ns/doap#old-homepage<\/a>\n     */\n    private void writeHomepage( XMLWriter writer )\n    {\n        if ( StringUtils.isNotEmpty( project.getUrl() ) )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer,\n                                            \"URL of a project's homepage, associated with exactly one project.\", 2 );\n            // http://usefulinc.com/ns/doap#homepage\n            DoapUtil.writeRdfResourceElement( writer, \"homepage\", project.getUrl() );\n        }\n\n        if ( StringUtils.isNotEmpty( doapOptions.getOldHomepage() ) )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil\n                .writeCommentText( writer, \"URL of a project's past homepage, associated with exactly one project.\", 2 );\n            // http://usefulinc.com/ns/doap#old-homepage\n            DoapUtil.writeRdfResourceElement( writer, \"old-homepage\", doapOptions.getOldHomepage() );\n        }\n    }","commit_id":"7607890d37265e95a706d9ba0c8474241c6b58e8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param locale the wanted locale (actually unused).\n     * @throws MavenReportException if any\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = JavadocUtil.getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( JavadocUtil.quotedArgument( this.locale ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( JavadocUtil.quotedPathArgument( classpath ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n        }\n        if ( proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", JavadocUtil.quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", JavadocUtil.quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", JavadocUtil.quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", JavadocUtil.quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( getOverview() != null ) && ( getOverview().exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", JavadocUtil.quotedPathArgument( getOverview().getAbsolutePath() ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_5 );\n        addArgIfNotEmpty( arguments, \"-source\", JavadocUtil.quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", JavadocUtil.quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", JavadocUtil.quotedArgument( getBottomText() ), false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", JavadocUtil.quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", JavadocUtil.quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", JavadocUtil.quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", JavadocUtil.quotedArgument( getDoctitle() ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", JavadocUtil.quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", JavadocUtil.quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", JavadocUtil.quotedArgument( groupTitle ) + \" \"\n                            + JavadocUtil.quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", JavadocUtil.quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", JavadocUtil.quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n            }\n            addLinkofflineArguments( arguments );\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", JavadocUtil.quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", JavadocUtil.quotedArgument( packagesheader ), SINCE_JAVADOC_1_4_2 );\n            if ( fJavadocVersion >= SINCE_JAVADOC_1_4 && fJavadocVersion < SINCE_JAVADOC_1_5 ) // Sun bug: 4714350\n            {\n                addArgIf( arguments, quiet, \"-quiet\" );\n            }\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n            {\n                addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n            }\n            else\n            {\n                addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            }\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              JavadocUtil.quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", JavadocUtil.quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( StringUtils.isEmpty( tags[i].getName() ) )\n                    {\n                        getLog().info( \"A tag name is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName();\n                        if ( StringUtils.isNotEmpty( tags[i].getPlacement() ) )\n                        {\n                            value += \":\" + tags[i].getPlacement();\n                            if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                            {\n                                value += \":\" + tags[i].getHead();\n                            }\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIfNotEmpty( arguments, \"-top\", JavadocUtil.quotedArgument( top ), false, false, SINCE_JAVADOC_1_6 );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", JavadocUtil.quotedArgument( getWindowtitle() ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","id":66422,"modified_method":"/**\n     * @param locale the wanted locale (actually unused).\n     * @throws MavenReportException if any\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = JavadocUtil.getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( JavadocUtil.quotedArgument( this.locale ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( JavadocUtil.quotedPathArgument( classpath ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n        cmd.getShell().setQuotedArgumentsEnabled( false ); // for Javadoc JVM args\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // Javadoc JVM args\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        addProxyArg( cmd );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        // General javadoc arguments\n        List arguments = new ArrayList();\n\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", JavadocUtil.quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", JavadocUtil.quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", JavadocUtil.quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", JavadocUtil.quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( getOverview() != null ) && ( getOverview().exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", JavadocUtil.quotedPathArgument( getOverview().getAbsolutePath() ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_5 );\n        addArgIfNotEmpty( arguments, \"-source\", JavadocUtil.quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", JavadocUtil.quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", JavadocUtil.quotedArgument( getBottomText() ), false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", JavadocUtil.quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", JavadocUtil.quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", JavadocUtil.quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", JavadocUtil.quotedArgument( getDoctitle() ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", JavadocUtil.quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", JavadocUtil.quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", JavadocUtil.quotedArgument( groupTitle ) + \" \"\n                            + JavadocUtil.quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", JavadocUtil.quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", JavadocUtil.quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n            }\n            addLinkofflineArguments( arguments );\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", JavadocUtil.quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", JavadocUtil.quotedArgument( packagesheader ), SINCE_JAVADOC_1_4_2 );\n            if ( fJavadocVersion >= SINCE_JAVADOC_1_4 && fJavadocVersion < SINCE_JAVADOC_1_5 ) // Sun bug: 4714350\n            {\n                addArgIf( arguments, quiet, \"-quiet\" );\n            }\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n            {\n                addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n            }\n            else\n            {\n                addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            }\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              JavadocUtil.quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", JavadocUtil.quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( StringUtils.isEmpty( tags[i].getName() ) )\n                    {\n                        getLog().info( \"A tag name is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName();\n                        if ( StringUtils.isNotEmpty( tags[i].getPlacement() ) )\n                        {\n                            value += \":\" + tags[i].getPlacement();\n                            if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                            {\n                                value += \":\" + tags[i].getHead();\n                            }\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIfNotEmpty( arguments, \"-top\", JavadocUtil.quotedArgument( top ), false, false, SINCE_JAVADOC_1_6 );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", JavadocUtil.quotedArgument( getWindowtitle() ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ).replaceAll( \"'\", \"\" ) ); // no quoted arguments\n\n        if ( debug )\n        {\n            File commandLineFile = new File( javadocOutputDirectory, \"javadoc.\" + ( SystemUtils.IS_OS_WINDOWS ? \"bat\" : \"sh\" ) );\n\n            try\n            {\n                FileUtils.fileWrite( commandLineFile.getAbsolutePath(), Commandline.toString( cmd.getCommandline() ).replaceAll( \"'\", \"\" ) );\n\n                if ( !SystemUtils.IS_OS_WINDOWS )\n                {\n                    Runtime.getRuntime().exec( new String[] { \"chmod\", \"a+x\", commandLineFile.getAbsolutePath() } );\n                }\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Unable to write '\" + commandLineFile.getName() + \"' debug script file\", e );\n            }\n        }\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ).replaceAll( \"'\", \"\" ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","commit_id":"faac4257641e596b52a5593e135846db3bf0aa69","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Fetch an URL\n     *\n     * @param settings the user settings used to fetch the url like a proxy\n     * @param url the url to fetch\n     * @throws IOException if any\n     */\n    protected static void fetchURL( Settings settings, URL url )\n        throws IOException\n    {\n        if ( url == null )\n        {\n            throw new IOException( \"The url is null\" );\n        }\n\n        if ( settings != null )\n        {\n            String scheme = url.getProtocol();\n            if ( !\"file\".equals( scheme ) )\n            {\n                Proxy proxy = settings.getActiveProxy();\n                if ( proxy != null )\n                {\n                    if ( \"http\".equals( scheme ) || \"https\".equals( scheme ) )\n                    {\n                        scheme = \"http.\";\n                    }\n                    else if ( \"ftp\".equals( scheme ) )\n                    {\n                        scheme = \"ftp.\";\n                    }\n                    else\n                    {\n                        scheme = \"\";\n                    }\n\n                    String host = proxy.getHost();\n                    if ( !StringUtils.isEmpty( host ) )\n                    {\n                        Properties p = System.getProperties();\n                        p.setProperty( scheme + \"proxySet\", \"true\" );\n                        p.setProperty( scheme + \"proxyHost\", host );\n                        p.setProperty( scheme + \"proxyPort\", String.valueOf( proxy.getPort() ) );\n                        if ( !StringUtils.isEmpty( proxy.getNonProxyHosts() ) )\n                        {\n                            p.setProperty( scheme + \"nonProxyHosts\", proxy.getNonProxyHosts() );\n                        }\n\n                        final String userName = proxy.getUsername();\n                        if ( !StringUtils.isEmpty( userName ) )\n                        {\n                            final String pwd = StringUtils.isEmpty( proxy.getPassword() ) ? \"\" : proxy.getPassword();\n                            Authenticator.setDefault( new Authenticator()\n                            {\n                                protected PasswordAuthentication getPasswordAuthentication()\n                                {\n                                    return new PasswordAuthentication( userName, pwd.toCharArray() );\n                                }\n                            } );\n                        }\n                    }\n                }\n            }\n        }\n\n        InputStream in = null;\n        try\n        {\n            in = url.openStream();\n        }\n        finally\n        {\n            IOUtil.close( in );\n        }\n    }","id":66423,"modified_method":"/**\n     * Fetch an URL\n     *\n     * @param settings the user settings used to fetch the url with an active proxy, if defined.\n     * @param url the url to fetch\n     * @throws IOException if any\n     */\n    protected static void fetchURL( Settings settings, URL url )\n        throws IOException\n    {\n        if ( url == null )\n        {\n            throw new IOException( \"The url is null\" );\n        }\n\n        Properties oldSystemProperties = new Properties();\n        oldSystemProperties.putAll( System.getProperties() );\n\n        if ( settings != null )\n        {\n            String scheme = url.getProtocol();\n\n            if ( !\"file\".equals( scheme ) )\n            {\n                Proxy activeProxy = settings.getActiveProxy();\n                if ( activeProxy != null )\n                {\n                    if ( \"http\".equals( scheme ) || \"https\".equals( scheme ) || \"ftp\".equals( scheme ) )\n                    {\n                        scheme += \".\";\n                    }\n                    else\n                    {\n                        scheme = \"\";\n                    }\n\n                    if ( StringUtils.isNotEmpty( activeProxy.getHost() ) )\n                    {\n                        Properties systemProperties = System.getProperties();\n                        systemProperties.setProperty( scheme + \"proxySet\", \"true\" );\n                        systemProperties.setProperty( scheme + \"proxyHost\", activeProxy.getHost() );\n\n                        if ( activeProxy.getPort() > 0 )\n                        {\n                            systemProperties.setProperty( scheme + \"proxyPort\", String.valueOf( activeProxy.getPort() ) );\n                        }\n\n                        if ( StringUtils.isNotEmpty( activeProxy.getNonProxyHosts() ) )\n                        {\n                            systemProperties.setProperty( scheme + \"nonProxyHosts\", activeProxy.getNonProxyHosts() );\n                        }\n\n                        final String userName = activeProxy.getUsername();\n                        if ( StringUtils.isNotEmpty( userName ) )\n                        {\n                            final String pwd = StringUtils.isEmpty( activeProxy.getPassword() ) ? \"\" : activeProxy.getPassword();\n                            Authenticator.setDefault( new Authenticator()\n                            {\n                                protected PasswordAuthentication getPasswordAuthentication()\n                                {\n                                    return new PasswordAuthentication( userName, pwd.toCharArray() );\n                                }\n                            } );\n                        }\n                    }\n                }\n            }\n        }\n\n        InputStream in = null;\n        try\n        {\n            in = url.openStream();\n        }\n        finally\n        {\n            IOUtil.close( in );\n\n            // Reset system properties\n            if ( ( settings != null ) && ( !\"file\".equals( url.getProtocol() ) )\n                && ( settings.getActiveProxy() != null ) && ( StringUtils.isNotEmpty( settings.getActiveProxy().getHost() ) ) )\n            {\n                System.setProperties( oldSystemProperties );\n                Authenticator.setDefault( null );\n            }\n        }\n    }","commit_id":"faac4257641e596b52a5593e135846db3bf0aa69","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om == null && !(source.isOpennet() || node.passOpennetRefsThroughDarknet())) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinishOpennetNoRelayInner(om);\n\t}","id":66424,"modified_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om == null && !(source.isOpennet() || node.passOpennetRefsThroughDarknet())) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(!finishOpennetNoRelayInner(om)) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"4af7fdd19e9422a50f7b7fc14dba20cbdc4684a9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Send our noderef to the request source, wait for a reply, if we get one add it. Called when either the request\n\t * wasn't routed, or the node it was routed to didn't return a noderef.\n\t */\n    private void finishOpennetNoRelayInner(OpennetManager om) {\n    \tif(logMINOR)\n    \t\tLogger.minor(this, \"Finishing opennet: sending own reference\");\n\t\tif(om.wantPeer(null, false)) {\n\t\t\t\n\t\t\ttry {\n\t\t\t\tom.sendOpennetRef(false, uid, source, om.crypto.myCompressedFullRef(), this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Can't send opennet ref because node disconnected on \"+this);\n\t\t\t\t// Oh well...\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Wait for response\n\t\t\t\n\t\t\tbyte[] noderef = \n\t\t\t\tom.waitForOpennetNoderef(true, source, uid, this);\n\t\t\t\n\t\t\tif(noderef == null) {\n\t\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\t\ttry {\n\t\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t// Oh well...\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tSimpleFieldSet ref = om.validateNoderef(noderef, 0, noderef.length, source);\n\t\t\t\n\t\t\tif(ref == null) {\n\t\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\t\ttry {\n\t\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t// Oh well...\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t    try {\n\t\t\t\tif(!node.addNewOpennetNode(ref)) {\n\t\t\t\t\tLogger.normal(this, \"Asked for opennet ref but didn't want it for \"+this+\" :\\n\"+ref);\n\t\t\t\t} else {\n\t\t\t\t\tLogger.normal(this, \"Added opennet noderef in \"+this);\n\t\t\t\t}\n\t\t\t} catch (FSParseException e) {\n\t\t\t\tLogger.error(this, \"Could not parse opennet noderef for \"+this+\" from \"+source, e);\n\t\t\t} catch (PeerParseException e) {\n\t\t\t\tLogger.error(this, \"Could not parse opennet noderef for \"+this+\" from \"+source, e);\n\t\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\t\tLogger.error(this, \"Bad signature on opennet noderef for \"+this+\" from \"+source+\" : \"+e, e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\ttry {\n\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t} catch (NotConnectedException e) {\n\t\t\t// Oh well...\n\t\t}\n    }","id":66425,"modified_method":"/**\n\t * Send our noderef to the request source, wait for a reply, if we get one add it. Called when either the request\n\t * wasn't routed, or the node it was routed to didn't return a noderef.\n\t * @return True if success, or lost connection; false if we need to send an ack.\n\t */\n    private boolean finishOpennetNoRelayInner(OpennetManager om) {\n    \tif(logMINOR)\n    \t\tLogger.minor(this, \"Finishing opennet: sending own reference\");\n\t\tif(om.wantPeer(null, false)) {\n\t\t\t\n\t\t\ttry {\n\t\t\t\tom.sendOpennetRef(false, uid, source, om.crypto.myCompressedFullRef(), this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Can't send opennet ref because node disconnected on \"+this);\n\t\t\t\t// Oh well...\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\t// Wait for response\n\t\t\t\n\t\t\tbyte[] noderef = \n\t\t\t\tom.waitForOpennetNoderef(true, source, uid, this);\n\t\t\t\n\t\t\tif(noderef == null)\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tSimpleFieldSet ref = om.validateNoderef(noderef, 0, noderef.length, source);\n\t\t\t\n\t\t\tif(ref == null) \n\t\t\t\treturn false;\n\t\t\t\n\t\t    try {\n\t\t\t\tif(!node.addNewOpennetNode(ref)) {\n\t\t\t\t\tLogger.normal(this, \"Asked for opennet ref but didn't want it for \"+this+\" :\\n\"+ref);\n\t\t\t\t} else {\n\t\t\t\t\tLogger.normal(this, \"Added opennet noderef in \"+this);\n\t\t\t\t}\n\t\t\t} catch (FSParseException e) {\n\t\t\t\tLogger.error(this, \"Could not parse opennet noderef for \"+this+\" from \"+source, e);\n\t\t\t} catch (PeerParseException e) {\n\t\t\t\tLogger.error(this, \"Could not parse opennet noderef for \"+this+\" from \"+source, e);\n\t\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\t\tLogger.error(this, \"Bad signature on opennet noderef for \"+this+\" from \"+source+\" : \"+e, e);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n    }","commit_id":"4af7fdd19e9422a50f7b7fc14dba20cbdc4684a9","url":"https://github.com/freenet/fred"},{"original_method":"private void finishOpennetInner() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om == null) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] noderef = rs.waitForOpennetNoderef();\n\t\tif(noderef == null) {\n\t\t\tfinishOpennetNoRelayInner(om);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(node.random.nextInt(OpennetManager.RESET_PATH_FOLDING_PROB) == 0) {\n\t\t\tfinishOpennetNoRelayInner(om);\n\t\t\treturn;\n\t\t}\n\t\t\n    \tfinishOpennetRelay(noderef, om);\n    }","id":66426,"modified_method":"private void finishOpennetInner() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om == null) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] noderef = rs.waitForOpennetNoderef();\n\t\tif(noderef == null) {\n\t\t\tif(!finishOpennetNoRelayInner(om)) {\n\t\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\t\ttry {\n\t\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t// Oh well...\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(node.random.nextInt(OpennetManager.RESET_PATH_FOLDING_PROB) == 0) {\n\t\t\tfinishOpennetNoRelayInner(om);\n\t\t\treturn;\n\t\t}\n\t\t\n    \tfinishOpennetRelay(noderef, om);\n    }","commit_id":"4af7fdd19e9422a50f7b7fc14dba20cbdc4684a9","url":"https://github.com/freenet/fred"},{"original_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(!(om == null || !(source.isOpennet() || node.passOpennetRefsThroughDarknet()))) {\n\t\t\tif(finishOpennetNoRelayInner(om)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\ttry {\n\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t} catch (NotConnectedException e) {\n\t\t\t// Oh well...\n\t\t}\n\t}","id":66427,"modified_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om != null && (source.isOpennet() || node.passOpennetRefsThroughDarknet()) &&\n\t\t\t\tfinishOpennetNoRelayInner(om))\n\t\t\treturn;\n\t\t\n\t\t// Otherwise just ack it.\n\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\ttry {\n\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t} catch (NotConnectedException e) {\n\t\t\t// Oh well...\n\t\t}\n\t}","commit_id":"e65a07c6deafb325e82238aa0c5c742502f0d564","url":"https://github.com/freenet/fred"},{"original_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(om == null || !(source.isOpennet() || node.passOpennetRefsThroughDarknet())) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(!finishOpennetNoRelayInner(om)) {\n\t\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\t\ttry {\n\t\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t// Oh well...\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","id":66428,"modified_method":"private void finishOpennetNoRelay() {\n\t\tOpennetManager om = node.getOpennet();\n\t\t\n\t\tif(!(om == null || !(source.isOpennet() || node.passOpennetRefsThroughDarknet()))) {\n\t\t\tif(finishOpennetNoRelayInner(om)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tMessage msg = DMT.createFNPOpennetCompletedAck(uid);\n\t\ttry {\n\t\t\tsource.sendAsync(msg, null, 0, this);\n\t\t} catch (NotConnectedException e) {\n\t\t\t// Oh well...\n\t\t}\n\t}","commit_id":"825bb5c80ead0a7de16f9a9495ca9274c19af1e0","url":"https://github.com/freenet/fred"},{"original_method":"@Test\n  public void testRowWeights() {\n    Frame tfr = null, vfr = null;\n    DRFModel drf = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights.csv\");\n      DKV.put(tfr);\n      DRFModel.DRFParameters parms = new DRFModel.DRFParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 234;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n\n      // Build a first model; all remaining models should be equal\n      DRF job = new DRF(parms);\n      drf = job.trainModel().get();\n\n      // OOB\n      // Reduced number of rows changes the row sampling -> results differ\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)drf._output._training_metrics;\n      assertEquals(0.9, mm.auc()._auc, 1e-8);\n      assertEquals(0.09090909090909091, mm.mse(), 1e-8);\n      assertEquals(0.6333333333333333, mm.r2(), 1e-6);\n      assertEquals(3.1398887631736985, mm.logloss(), 1e-6);\n\n\n      // test set scoring (on the same dataset, but without normalizing the weights)\n      drf.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(drf, parms.train());\n\n      // Non-OOB\n      assertEquals(1, mm2.auc()._auc, 1e-8);\n      assertEquals(0.006172839506172841, mm2.mse(), 1e-8);\n      assertEquals(0.9753086419753086, mm2.r2(), 1e-8);\n      assertEquals(0.02252583933934247, mm2.logloss(), 1e-8);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (drf != null) drf.delete();\n      Scope.exit();\n    }\n  }","id":66429,"modified_method":"@Test\n  public void testRowWeights() {\n    Frame tfr = null, vfr = null;\n    DRFModel drf = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights.csv\");\n      DKV.put(tfr);\n      DRFModel.DRFParameters parms = new DRFModel.DRFParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 234;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n\n      // Build a first model; all remaining models should be equal\n      DRF job = new DRF(parms);\n      drf = job.trainModel().get();\n\n      // OOB\n      // Reduced number of rows changes the row sampling -> results differ\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)drf._output._training_metrics;\n      assertEquals(0.9, mm.auc()._auc, 1e-8);\n      assertEquals(0.09090909090909091, mm.mse(), 1e-8);\n      assertEquals(0.6333333333333333, mm.r2(), 1e-6);\n      assertEquals(3.1398887631736985, mm.logloss(), 1e-6);\n\n\n      // test set scoring (on the same dataset, but without normalizing the weights)\n      Frame pred = drf.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(drf, parms.train());\n\n      // Non-OOB\n      assertEquals(1, mm2.auc()._auc, 1e-8);\n      assertEquals(0.006172839506172841, mm2.mse(), 1e-8);\n      assertEquals(0.9753086419753086, mm2.r2(), 1e-8);\n      assertEquals(0.02252583933934247, mm2.logloss(), 1e-8);\n\n      pred.remove();\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (drf != null) drf.delete();\n      Scope.exit();\n    }\n  }","commit_id":"227fb8c5215beb33763ef8440b1a7a7d642c4c8d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testRowWeights() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66430,"modified_method":"@Test\n  public void testRowWeights() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testNoRowWeightsShuffled() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/no_weights_shuffled.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66431,"modified_method":"@Test\n  public void testNoRowWeightsShuffled() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/no_weights_shuffled.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testRowWeightsOne() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_ones.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66432,"modified_method":"@Test\n  public void testRowWeightsOne() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_ones.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testNoRowWeights() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/no_weights.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66433,"modified_method":"@Test\n  public void testNoRowWeights() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"smalldata/junit/no_weights.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 1;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testRowWeightsTwo() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_twos.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 2; //Must be adapted to the weights\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66434,"modified_method":"@Test\n  public void testRowWeightsTwo() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_twos.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 2; //Must be adapted to the weights\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Ignore\n  @Test\n  public void testStochasticGBM() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"./smalldata/airlines/allyears2k_headers.zip\");\n      for (String s : new String[]{\n              \"DepTime\", \"ArrTime\", \"ActualElapsedTime\",\n              \"AirTime\", \"ArrDelay\", \"DepDelay\", \"Cancelled\",\n              \"CancellationCode\", \"CarrierDelay\", \"WeatherDelay\",\n              \"NASDelay\", \"SecurityDelay\", \"LateAircraftDelay\", \"IsArrDelayed\"\n      }) {\n        tfr.remove(s).remove();\n      }\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"IsDepDelayed\";\n      parms._seed = 234;\n      parms._min_rows = 2;\n      parms._max_depth = 5;\n      parms._ntrees = 5;\n      parms._col_sample_rate = 0.5f;\n      parms._sample_rate = 0.5f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(0.7264331810371721, mm.auc()._auc, 1e-4); // 1 node\n      assertEquals(0.22686348162897116, mm.mse(), 1e-4);\n      assertEquals(0.09039195554728074, mm.r2(), 1e-4);\n      assertEquals(0.6461880794975307, mm.logloss(), 1e-4);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66435,"modified_method":"@Ignore\n  @Test\n  public void testStochasticGBM() {\n    Frame tfr = null, vfr = null;\n    GBMModel gbm = null;\n\n    Scope.enter();\n    try {\n      tfr = parse_test_file(\"./smalldata/junit/cars.csv\");\n      for (String s : new String[]{\n              \"name\",\n      }) {\n        tfr.remove(s).remove();\n      }\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"cylinders\"; //regression\n      parms._seed = 234;\n      parms._min_rows = 2;\n      parms._max_depth = 5;\n      parms._ntrees = 5;\n      parms._col_sample_rate = 1f;\n      parms._sample_rate = 0.5f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsRegression mm = (ModelMetricsRegression)gbm._output._training_metrics;\n      assertEquals(1.03088, mm.mse(), 1e-4);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testRowWeightsTiny() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_tiny.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 0.01242; //Must be adapted to the weights\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","id":66436,"modified_method":"@Test\n  public void testRowWeightsTiny() {\n    Frame tfr = null, vfr = null;\n\n    Scope.enter();\n    GBMModel gbm = null;\n    try {\n      tfr = parse_test_file(\"smalldata/junit/weights_all_tiny.csv\");\n      DKV.put(tfr);\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._train = tfr._key;\n      parms._response_column = \"response\";\n      parms._weights_column = \"weight\";\n      parms._seed = 0xdecaf;\n      parms._min_rows = 0.01242; //Must be adapted to the weights\n      parms._max_depth = 2;\n      parms._ntrees = 3;\n      parms._learn_rate = 1e-3f;\n\n      // Build a first model; all remaining models should be equal\n      GBM job = new GBM(parms);\n      gbm = job.trainModel().get();\n\n      ModelMetricsBinomial mm = (ModelMetricsBinomial)gbm._output._training_metrics;\n      assertEquals(_AUC, mm.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm.mse(), 1e-8);\n      assertEquals(_R2, mm.r2(), 1e-6);\n      assertEquals(_LogLoss, mm.logloss(), 1e-6);\n\n      Frame pred = gbm.score(parms.train());\n      hex.ModelMetricsBinomial mm2 = hex.ModelMetricsBinomial.getFromDKV(gbm, parms.train());\n      assertEquals(_AUC, mm2.auc()._auc, 1e-8);\n      assertEquals(_MSE, mm2.mse(), 1e-8);\n      assertEquals(_R2, mm2.r2(), 1e-6);\n      assertEquals(_LogLoss, mm2.logloss(), 1e-6);\n      pred.remove();\n\n      job.remove();\n    } finally {\n      if (tfr != null) tfr.remove();\n      if (vfr != null) vfr.remove();\n      if (gbm != null) gbm.delete();\n      Scope.exit();\n    }\n  }","commit_id":"73245d87ffb82a8e5b94d17d422b1ebc24cbcdfd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n    public void testGetSliceFromAdvanced() throws Throwable\n    {\n        // tests slicing against data from one row spread across two sstables\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n        final String ROW = \"row2\";\n        Runner setup = new Runner()\n        {\n            public void run() throws Exception\n            {\n                RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n                ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n                cf.addColumn(column(\"col1\", \"val1\", 1L));\n                cf.addColumn(column(\"col2\", \"val2\", 1L));\n                cf.addColumn(column(\"col3\", \"val3\", 1L));\n                cf.addColumn(column(\"col4\", \"val4\", 1L));\n                cf.addColumn(column(\"col5\", \"val5\", 1L));\n                cf.addColumn(column(\"col6\", \"val6\", 1L));\n                rm.add(cf);\n                rm.apply();\n                cfStore.forceBlockingFlush();\n\n                rm = new RowMutation(\"Keyspace1\", ROW);\n                cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n                cf.addColumn(column(\"col1\", \"valx\", 2L));\n                cf.addColumn(column(\"col2\", \"valx\", 2L));\n                cf.addColumn(column(\"col3\", \"valx\", 2L));\n                rm.add(cf);\n                rm.apply();\n            }\n        };\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col2\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);\n                assertColumns(cf, \"col2\", \"col3\", \"col4\");\n                assertEquals(new String(cf.getColumn(\"col2\".getBytes()).value()), \"valx\");\n                assertEquals(new String(cf.getColumn(\"col3\".getBytes()).value()), \"valx\");\n                assertEquals(new String(cf.getColumn(\"col4\".getBytes()).value()), \"val4\");\n            }\n        };\n\n        reTest(setup, table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","id":66437,"modified_method":"@Test\n    public void testGetSliceFromAdvanced() throws Throwable\n    {\n        // tests slicing against data from one row spread across two sstables\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n        final String ROW = \"row2\";\n\n        RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n        ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        cf.addColumn(column(\"col1\", \"val1\", 1L));\n        cf.addColumn(column(\"col2\", \"val2\", 1L));\n        cf.addColumn(column(\"col3\", \"val3\", 1L));\n        cf.addColumn(column(\"col4\", \"val4\", 1L));\n        cf.addColumn(column(\"col5\", \"val5\", 1L));\n        cf.addColumn(column(\"col6\", \"val6\", 1L));\n        rm.add(cf);\n        rm.apply();\n        cfStore.forceBlockingFlush();\n\n        rm = new RowMutation(\"Keyspace1\", ROW);\n        cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        cf.addColumn(column(\"col1\", \"valx\", 2L));\n        cf.addColumn(column(\"col2\", \"valx\", 2L));\n        cf.addColumn(column(\"col3\", \"valx\", 2L));\n        rm.add(cf);\n        rm.apply();\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col2\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);\n                assertColumns(cf, \"col2\", \"col3\", \"col4\");\n                assertEquals(new String(cf.getColumn(\"col2\".getBytes()).value()), \"valx\");\n                assertEquals(new String(cf.getColumn(\"col3\".getBytes()).value()), \"valx\");\n                assertEquals(new String(cf.getColumn(\"col4\".getBytes()).value()), \"val4\");\n            }\n        };\n\n        reTest(table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"private void reTest(Runner setup, ColumnFamilyStore cfs, Runner verify) throws Exception\n    {\n        setup.run();\n        verify.run();\n        cfs.forceBlockingFlush();\n        verify.run();\n    }","id":66438,"modified_method":"private void reTest(ColumnFamilyStore cfs, Runner verify) throws Exception\n    {\n        verify.run();\n        cfs.forceBlockingFlush();\n        verify.run();\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testGetSliceFromBasic() throws Throwable\n    {\n        // tests slicing against data from one row in a memtable and then flushed to an sstable\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n        final String ROW = \"row1\";\n        Runner setup = new Runner()\n        {\n            public void run() throws Exception\n            {\n                RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n                ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n                cf.addColumn(column(\"col1\", \"val1\", 1L));\n                cf.addColumn(column(\"col3\", \"val3\", 1L));\n                cf.addColumn(column(\"col4\", \"val4\", 1L));\n                cf.addColumn(column(\"col5\", \"val5\", 1L));\n                cf.addColumn(column(\"col7\", \"val7\", 1L));\n                cf.addColumn(column(\"col9\", \"val9\", 1L));\n                rm.add(cf);\n                rm.apply();\n\n                rm = new RowMutation(\"Keyspace1\", ROW);\n                rm.delete(new QueryPath(\"Standard1\", null, \"col4\".getBytes()), 2L);\n                rm.apply();\n            }\n        };\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col5\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf, \"col5\", \"col7\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col4\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf, \"col4\", \"col5\", \"col7\");\n                assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), \"col5\", \"col7\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col5\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col3\", \"col4\", \"col5\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col6\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col3\", \"col4\", \"col5\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col7\", \"col9\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col95\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf);\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col0\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf);\n            }\n        };\n\n        reTest(setup, table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","id":66439,"modified_method":"@Test\n    public void testGetSliceFromBasic() throws Throwable\n    {\n        // tests slicing against data from one row in a memtable and then flushed to an sstable\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n        final String ROW = \"row1\";\n\n        RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n        ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        cf.addColumn(column(\"col1\", \"val1\", 1L));\n        cf.addColumn(column(\"col3\", \"val3\", 1L));\n        cf.addColumn(column(\"col4\", \"val4\", 1L));\n        cf.addColumn(column(\"col5\", \"val5\", 1L));\n        cf.addColumn(column(\"col7\", \"val7\", 1L));\n        cf.addColumn(column(\"col9\", \"val9\", 1L));\n        rm.add(cf);\n        rm.apply();\n\n        rm = new RowMutation(\"Keyspace1\", ROW);\n        rm.delete(new QueryPath(\"Standard1\", null, \"col4\".getBytes()), 2L);\n        rm.apply();\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col5\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf, \"col5\", \"col7\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col4\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf, \"col4\", \"col5\", \"col7\");\n                assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), \"col5\", \"col7\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col5\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col3\", \"col4\", \"col5\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col6\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col3\", \"col4\", \"col5\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf, \"col7\", \"col9\");\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col95\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);\n                assertColumns(cf);\n\n                cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Standard1\"), \"col0\".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);\n                assertColumns(cf);\n            }\n        };\n\n        reTest(table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testGetRowSingleColumn() throws Throwable\n    {\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n\n        Runner setup = new Runner()\n        {\n            public void run() throws Exception\n            {\n                RowMutation rm = makeSimpleRowMutation();\n                rm.apply();\n            }\n        };\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard1\"), \"col1\".getBytes()));\n                assertColumns(cf, \"col1\");\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard1\"), \"col3\".getBytes()));\n                assertColumns(cf, \"col3\");\n            }\n        };\n        reTest(setup, table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","id":66440,"modified_method":"@Test\n    public void testGetRowSingleColumn() throws Throwable\n    {\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard1\");\n\n        RowMutation rm = new RowMutation(\"Keyspace1\", TEST_KEY);\n        ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        cf.addColumn(column(\"col1\",\"val1\", 1L));\n        cf.addColumn(column(\"col2\",\"val2\", 1L));\n        cf.addColumn(column(\"col3\",\"val3\", 1L));\n        rm.add(cf);\n        rm.apply();\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard1\"), \"col1\".getBytes()));\n                assertColumns(cf, \"col1\");\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard1\"), \"col3\".getBytes()));\n                assertColumns(cf, \"col3\");\n            }\n        };\n        reTest(table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testGetSliceFromSuperBasic() throws Throwable\n    {\n        // tests slicing against data from one row spread across two sstables\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Super1\");\n        final String ROW = \"row2\";\n        Runner setup = new Runner()\n        {\n            public void run() throws Exception\n            {\n                RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n                ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Super1\");\n                SuperColumn sc = new SuperColumn(\"sc1\".getBytes(), new LongType());\n                sc.addColumn(new Column(getBytes(1), \"val1\".getBytes(), 1L));\n                cf.addColumn(sc);\n                rm.add(cf);\n                rm.apply();\n            }\n        };\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Super1\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 10);\n                assertColumns(cf, \"sc1\");\n                assertEquals(new String(cf.getColumn(\"sc1\".getBytes()).getSubColumn(getBytes(1)).value()), \"val1\");\n            }\n        };\n\n        reTest(setup, table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","id":66441,"modified_method":"@Test\n    public void testGetSliceFromSuperBasic() throws Throwable\n    {\n        // tests slicing against data from one row spread across two sstables\n        final Table table = Table.open(\"Keyspace1\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Super1\");\n        final String ROW = \"row2\";\n\n        RowMutation rm = new RowMutation(\"Keyspace1\", ROW);\n        ColumnFamily cf = ColumnFamily.create(\"Keyspace1\", \"Super1\");\n        SuperColumn sc = new SuperColumn(\"sc1\".getBytes(), new LongType());\n        sc.addColumn(new Column(getBytes(1), \"val1\".getBytes(), 1L));\n        cf.addColumn(sc);\n        rm.add(cf);\n        rm.apply();\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath(\"Super1\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 10);\n                assertColumns(cf, \"sc1\");\n                assertEquals(new String(cf.getColumn(\"sc1\".getBytes()).getSubColumn(getBytes(1)).value()), \"val1\");\n            }\n        };\n\n        reTest(table.getColumnFamilyStore(\"Standard1\"), verify);\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testGetRowNoColumns() throws Throwable\n    {\n        final Table table = Table.open(\"Keyspace2\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard3\");\n\n        Runner setup = new Runner()\n        {\n            public void run() throws Exception\n            {\n                RowMutation rm = makeSimpleRowMutation();\n                rm.apply();\n            }\n        };\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard3\"), new TreeSet<byte[]>()));\n                assertColumns(cf);\n\n                cf = cfStore.getColumnFamily(new SliceQueryFilter(TEST_KEY, new QueryPath(\"Standard3\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 0));\n                assertColumns(cf);\n            }\n        };\n        reTest(setup, table.getColumnFamilyStore(\"Standard3\"), verify);\n    }","id":66442,"modified_method":"@Test\n    public void testGetRowNoColumns() throws Throwable\n    {\n        final Table table = Table.open(\"Keyspace2\");\n        final ColumnFamilyStore cfStore = table.getColumnFamilyStore(\"Standard3\");\n\n        RowMutation rm = new RowMutation(\"Keyspace2\", TEST_KEY);\n        ColumnFamily cf = ColumnFamily.create(\"Keyspace2\", \"Standard3\");\n        cf.addColumn(column(\"col1\",\"val1\", 1L));\n        rm.add(cf);\n        rm.apply();\n\n        Runner verify = new Runner()\n        {\n            public void run() throws Exception\n            {\n                ColumnFamily cf;\n\n                cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath(\"Standard3\"), new TreeSet<byte[]>()));\n                assertColumns(cf);\n\n                cf = cfStore.getColumnFamily(new SliceQueryFilter(TEST_KEY, new QueryPath(\"Standard3\"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 0));\n                assertColumns(cf);\n            }\n        };\n        reTest(table.getColumnFamilyStore(\"Standard3\"), verify);\n    }","commit_id":"00190bf20e8c290adbd4d7ab044be01a13a40775","url":"https://github.com/apache/cassandra"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\t\n\t\tif(args[0].isEmpty()) {\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t}\n\t\tItem inputNode = args[0].itemAt(0);\n\t\tItem stylesheetItem = args[1].itemAt(0);\n\t\t\n\t\tNode options = null;\n\t\tif(!args[2].isEmpty())\n\t\t\toptions = ((NodeValue)args[2].itemAt(0)).getNode();\n\n        // apply serialization options set on the XQuery context\n        Properties serializeOptions = new Properties();\n        if (getArgumentCount() == 4) {\n            String serOpts = args[3].getStringValue();\n            String[] contents = Option.tokenize(serOpts);\n            for (int i = 0; i < contents.length; i++) {\n                String[] pair = Option.parseKeyValuePair(contents[i]);\n                if (pair == null)\n                    throw new XPathException(this, \"Found invalid serialization option: \" + pair);\n                logger.info(\"Setting serialization property: \" + pair[0] + \" = \" + pair[1]);\n                serializeOptions.setProperty(pair[0], pair[1]);\n            }\n        } else\n            context.checkOptions(serializeOptions);\n        boolean expandXIncludes =\n                serializeOptions.getProperty(EXistOutputKeys.EXPAND_XINCLUDES, \"yes\").equals(\"yes\");\n\n        Properties stylesheetParams = new Properties();\n        if (options != null)\n            parseParameters(stylesheetParams, options);\n        TransformerHandler handler = createHandler(stylesheetItem, stylesheetParams);\n        TransformErrorListener errorListener = new TransformErrorListener();\n        handler.getTransformer().setErrorListener(errorListener);\n        if (isCalledAs(\"transform\"))\n        {\n        \t//transform:transform()\n\n        \tTransformer transformer = handler.getTransformer();\n        \tif (transformer.getClass().getName().equals(\"org.exist.xslt.TransformerImpl\")) {\n        \t\tcontext.pushDocumentContext();\n\n        \t\tSequence seq = ((org.exist.xslt.Transformer)transformer).transform(args[0]);\n\n        \t\tcontext.popDocumentContext();\n        \t\treturn seq;\n        \t} else {\n            ValueSequence seq = new ValueSequence();\n    \t\tcontext.pushDocumentContext();\n    \t\tMemTreeBuilder builder = context.getDocumentBuilder();\n    \t\tDocumentBuilderReceiver builderReceiver = new DocumentBuilderReceiver(builder, true);\n    \t\tSAXResult result = new SAXResult(builderReceiver);\n    \t\tresult.setLexicalHandler(builderReceiver);\t\t//preserve comments etc... from xslt output\n    \t\thandler.setResult(result);\n            Receiver receiver = new ReceiverToSAX(handler);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            try {\n                serializer.setProperties(serializeOptions);\n                if (expandXIncludes) {\n                    XIncludeFilter xinclude = new XIncludeFilter(serializer, receiver);\n                    String xipath = serializeOptions.getProperty(EXistOutputKeys.XINCLUDE_PATH);\n                    if (xipath != null) {\n                        File f = new File(xipath);\n                        if (!f.isAbsolute())\n                            xipath = new File(context.getModuleLoadPath(), xipath).getAbsolutePath();\n                    } else\n                        xipath = context.getModuleLoadPath();\n                    xinclude.setModuleLoadPath(xipath);\n                    receiver = xinclude;\n                }\n                serializer.setReceiver(receiver);\n    \t\t\tserializer.toSAX((NodeValue)inputNode);\n    \t\t} catch (Exception e) {\n    \t\t\tthrow new XPathException(this, \"Exception while transforming node: \" + e.getMessage(), e);\n    \t\t}\n            errorListener.checkForErrors();\n    \t\tNode next = builder.getDocument().getFirstChild();\n            while (next != null) {\n                seq.add((NodeValue) next);\n                next = next.getNextSibling();\n            }\n    \t\tcontext.popDocumentContext();\n    \t\treturn seq;\n        \t}\n        }\n        else\n        {\n        \t//transform:stream-transform()\n        \t\n            ResponseModule myModule = (ResponseModule)context.getModule(ResponseModule.NAMESPACE_URI);\n            // response object is read from global variable $response\n            Variable respVar = myModule.resolveVariable(ResponseModule.RESPONSE_VAR);\n            if(respVar == null)\n                throw new XPathException(this, \"No response object found in the current XQuery context.\");\n            if(respVar.getValue().getItemType() != Type.JAVA_OBJECT)\n                throw new XPathException(this, \"Variable $response is not bound to an Java object.\");\n            JavaObjectValue respValue = (JavaObjectValue)\n                respVar.getValue().itemAt(0);\n            if (!\"org.exist.http.servlets.HttpResponseWrapper\".equals(respValue.getObject().getClass().getName()))\n                throw new XPathException(this, signatures[1].toString() +\n                        \" can only be used within the EXistServlet or XQueryServlet\");\n            ResponseWrapper response = (ResponseWrapper) respValue.getObject();\n            \n            //setup the response correctly\n            String mediaType = handler.getTransformer().getOutputProperty(\"media-type\");\n            String encoding = handler.getTransformer().getOutputProperty(\"encoding\");\n            if(mediaType != null)\n            {\n            \tif(encoding == null)\n            \t{\n            \t\tresponse.setContentType(mediaType);\n            \t}\n            \telse\n            \t{\n            \t\tresponse.setContentType(mediaType + \"; charset=\" + encoding);\n            \t}\n            }\n            \n            //do the transformation\n            try {\n                OutputStream os = new BufferedOutputStream(response.getOutputStream());\n                StreamResult result = new StreamResult(os);\n                handler.setResult(result);\n                Serializer serializer = context.getBroker().getSerializer();\n                serializer.reset();\n                Receiver receiver = new ReceiverToSAX(handler);\n                try {\n                    serializer.setProperties(serializeOptions);\n                    if (expandXIncludes) {\n                        XIncludeFilter xinclude = new XIncludeFilter(serializer, receiver);\n                        String xipath = serializeOptions.getProperty(EXistOutputKeys.XINCLUDE_PATH);\n                        if (xipath != null) {\n                            File f = new File(xipath);\n                            if (!f.isAbsolute())\n                                xipath = new File(context.getModuleLoadPath(), xipath).getAbsolutePath();\n                        } else\n                            xipath = context.getModuleLoadPath();\n                        xinclude.setModuleLoadPath(xipath);\n                        receiver = xinclude;\n                    }\n                    serializer.setReceiver(receiver);\n                    serializer.toSAX((NodeValue)inputNode);\n                } catch (Exception e) {\n                    throw new XPathException(this, \"Exception while transforming node: \" + e.getMessage(), e);\n                }\n                errorListener.checkForErrors();\n                os.close();\n                \n                //commit the response\n                response.flushBuffer();\n            } catch (IOException e) {\n                throw new XPathException(this, \"IO exception while transforming node: \" + e.getMessage(), e);\n            }\n            return Sequence.EMPTY_SEQUENCE;\n        }\n\t}","id":66443,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n\t\t\n\t\tif(args[0].isEmpty()) {\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t}\n\t\tItem inputNode = args[0].itemAt(0);\n\t\tItem stylesheetItem = args[1].itemAt(0);\n\t\t\n\t\tNode options = null;\n\t\tif(!args[2].isEmpty())\n\t\t\toptions = ((NodeValue)args[2].itemAt(0)).getNode();\n\n        // apply serialization options set on the XQuery context\n        Properties serializeOptions = new Properties();\n        if (getArgumentCount() == 4) {\n            String serOpts = args[3].getStringValue();\n            String[] contents = Option.tokenize(serOpts);\n            for (int i = 0; i < contents.length; i++) {\n                String[] pair = Option.parseKeyValuePair(contents[i]);\n                if (pair == null)\n                    throw new XPathException(this, \"Found invalid serialization option: \" + pair);\n                logger.info(\"Setting serialization property: \" + pair[0] + \" = \" + pair[1]);\n                serializeOptions.setProperty(pair[0], pair[1]);\n            }\n        } else\n            context.checkOptions(serializeOptions);\n        boolean expandXIncludes =\n                serializeOptions.getProperty(EXistOutputKeys.EXPAND_XINCLUDES, \"yes\").equals(\"yes\");\n\n        Properties stylesheetParams = new Properties();\n        if (options != null)\n            parseParameters(stylesheetParams, options);\n        TransformerHandler handler = createHandler(stylesheetItem, stylesheetParams);\n        TransformErrorListener errorListener = new TransformErrorListener();\n        handler.getTransformer().setErrorListener(errorListener);\n        if (isCalledAs(\"transform\"))\n        {\n        \t//transform:transform()\n\n        \tTransformer transformer = handler.getTransformer();\n        \tif (transformer.getClass().getName().equals(\"org.exist.xslt.TransformerImpl\")) {\n        \t\tcontext.pushDocumentContext();\n\n        \t\tSequence seq = ((org.exist.xslt.Transformer)transformer).transform(args[0]);\n\n        \t\tcontext.popDocumentContext();\n        \t\treturn seq;\n        \t} else {\n            ValueSequence seq = new ValueSequence();\n    \t\tcontext.pushDocumentContext();\n    \t\tMemTreeBuilder builder = context.getDocumentBuilder();\n    \t\tDocumentBuilderReceiver builderReceiver = new DocumentBuilderReceiver(builder, true);\n    \t\tSAXResult result = new SAXResult(builderReceiver);\n    \t\tresult.setLexicalHandler(builderReceiver);\t\t//preserve comments etc... from xslt output\n    \t\thandler.setResult(result);\n            Receiver receiver = new ReceiverToSAX(handler);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            try {\n                serializer.setProperties(serializeOptions);\n                serializer.setReceiver(receiver, true);\n                if (expandXIncludes) {\n                    String xipath = serializeOptions.getProperty(EXistOutputKeys.XINCLUDE_PATH);\n                    if (xipath != null) {\n                        File f = new File(xipath);\n                        if (!f.isAbsolute())\n                            xipath = new File(context.getModuleLoadPath(), xipath).getAbsolutePath();\n                    } else\n                        xipath = context.getModuleLoadPath();\n                    serializer.getXIncludeFilter().setModuleLoadPath(xipath);\n                }\n    \t\t\tserializer.toSAX((NodeValue)inputNode);\n    \t\t} catch (Exception e) {\n    \t\t\tthrow new XPathException(this, \"Exception while transforming node: \" + e.getMessage(), e);\n    \t\t}\n            errorListener.checkForErrors();\n    \t\tNode next = builder.getDocument().getFirstChild();\n            while (next != null) {\n                seq.add((NodeValue) next);\n                next = next.getNextSibling();\n            }\n    \t\tcontext.popDocumentContext();\n    \t\treturn seq;\n        \t}\n        }\n        else\n        {\n        \t//transform:stream-transform()\n        \t\n            ResponseModule myModule = (ResponseModule)context.getModule(ResponseModule.NAMESPACE_URI);\n            // response object is read from global variable $response\n            Variable respVar = myModule.resolveVariable(ResponseModule.RESPONSE_VAR);\n            if(respVar == null)\n                throw new XPathException(this, \"No response object found in the current XQuery context.\");\n            if(respVar.getValue().getItemType() != Type.JAVA_OBJECT)\n                throw new XPathException(this, \"Variable $response is not bound to an Java object.\");\n            JavaObjectValue respValue = (JavaObjectValue)\n                respVar.getValue().itemAt(0);\n            if (!\"org.exist.http.servlets.HttpResponseWrapper\".equals(respValue.getObject().getClass().getName()))\n                throw new XPathException(this, signatures[1].toString() +\n                        \" can only be used within the EXistServlet or XQueryServlet\");\n            ResponseWrapper response = (ResponseWrapper) respValue.getObject();\n            \n            //setup the response correctly\n            String mediaType = handler.getTransformer().getOutputProperty(\"media-type\");\n            String encoding = handler.getTransformer().getOutputProperty(\"encoding\");\n            if(mediaType != null)\n            {\n            \tif(encoding == null)\n            \t{\n            \t\tresponse.setContentType(mediaType);\n            \t}\n            \telse\n            \t{\n            \t\tresponse.setContentType(mediaType + \"; charset=\" + encoding);\n            \t}\n            }\n            \n            //do the transformation\n            try {\n                OutputStream os = new BufferedOutputStream(response.getOutputStream());\n                StreamResult result = new StreamResult(os);\n                handler.setResult(result);\n                Serializer serializer = context.getBroker().getSerializer();\n                serializer.reset();\n                Receiver receiver = new ReceiverToSAX(handler);\n                try {\n                    serializer.setProperties(serializeOptions);\n                    if (expandXIncludes) {\n                        XIncludeFilter xinclude = new XIncludeFilter(serializer, receiver);\n                        String xipath = serializeOptions.getProperty(EXistOutputKeys.XINCLUDE_PATH);\n                        if (xipath != null) {\n                            File f = new File(xipath);\n                            if (!f.isAbsolute())\n                                xipath = new File(context.getModuleLoadPath(), xipath).getAbsolutePath();\n                        } else\n                            xipath = context.getModuleLoadPath();\n                        xinclude.setModuleLoadPath(xipath);\n                        receiver = xinclude;\n                    }\n                    serializer.setReceiver(receiver);\n                    serializer.toSAX((NodeValue)inputNode);\n                } catch (Exception e) {\n                    throw new XPathException(this, \"Exception while transforming node: \" + e.getMessage(), e);\n                }\n                errorListener.checkForErrors();\n                os.close();\n                \n                //commit the response\n                response.flushBuffer();\n            } catch (IOException e) {\n                throw new XPathException(this, \"IO exception while transforming node: \" + e.getMessage(), e);\n            }\n            return Sequence.EMPTY_SEQUENCE;\n        }\n\t}","commit_id":"20f3163e45eed65dca85011ae1c4b0dd7388076c","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n    public void testBasicOperations() throws Exception {\n        String groupName = GROUP;\n        Channel c1 = createChannel(\"A\");\n        c1.connect(groupName);\n        Util.sleep(1000);\n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n       \n        c1.connect(groupName);\n\n        c1.disconnect();\n       \n        assert c1.isConnected() == false;\n        assert c1.isOpen();\n        assert c1.getLocalAddress() == null;\n        assert c1.getView() == null;\n        assert c1.getClusterName() == null;\n       \n        c1.connect(groupName);\n\n        c1.close();\n       \n        try {\n            c1.connect(groupName);\n            throw new IllegalStateException(\"Should generated exception, and it has NOT\");\n        }\n        catch (Exception e) {\n            assert e instanceof ChannelClosedException;\n        }\n       \n        assert c1.isConnected() == false;\n        assert c1.isOpen() == false;\n        assert c1.getLocalAddress() == null;\n        assert c1.getView() == null;\n       \n        assert c1.getClusterName() == null;\n       \n        c1 = createChannel(\"A\");\n        c1.connect(groupName);\n        Channel c2 = createChannel(\"A\");\n        c2.connect(groupName);\n       \n        Util.sleep(1000);\n       \n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n        assert c1.getView().getMembers().contains(c2.getLocalAddress());\n       \n        assert c2.isOpen();\n        assert c2.isConnected();\n       \n        assert c2.getLocalAddress() != null;\n        assert c2.getView() != null;\n        assert c2.getView().getMembers().contains(c2.getLocalAddress());\n        assert c2.getView().getMembers().contains(c1.getLocalAddress());\n       \n        c2.close();\n        Util.sleep(1000);\n       \n        assert c2.isOpen() == false;\n        assert c2.isConnected() == false;\n       \n        assert c2.getLocalAddress() == null;\n        assert c2.getView() == null;\n       \n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n        assert c1.getView().getMembers().contains(c2.getLocalAddress()) == false;\n        c1.close();\n    }","id":66444,"modified_method":"@Test\n    public void testBasicOperations() throws Exception {\n        Channel c1 = createChannelWithProps(PROPS.get());\n        Channel c2=null;\n\n        try {\n            c1.connect(GROUP.get());\n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n       \n            c1.connect(GROUP.get());\n            c1.disconnect();\n            assert c1.isConnected() == false;\n            assert c1.isOpen();\n            assert c1.getLocalAddress() == null;\n            assert c1.getView() == null;\n            assert c1.getClusterName() == null;\n       \n            c1.connect(GROUP.get());\n\n            c1.close();\n       \n            try {\n                c1.connect(GROUP.get());\n                throw new IllegalStateException(\"Should generated exception, and it has NOT\");\n            }\n            catch (Exception e) {\n                assert e instanceof ChannelClosedException;\n            }\n       \n            assert c1.isConnected() == false;\n            assert c1.isOpen() == false;\n            assert c1.getLocalAddress() == null;\n            assert c1.getView() == null;\n       \n            assert c1.getClusterName() == null;\n       \n            c1 = createChannelWithProps(PROPS.get());\n            c1.connect(GROUP.get());\n            c2 = createChannelWithProps(PROPS.get());\n            c2.connect(GROUP.get());\n       \n            Util.sleep(1000);\n       \n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n            assert c1.getView().getMembers().contains(c2.getLocalAddress());\n       \n            assert c2.isOpen();\n            assert c2.isConnected();\n       \n            assert c2.getLocalAddress() != null;\n            assert c2.getView() != null;\n            assert c2.getView().getMembers().contains(c2.getLocalAddress());\n            assert c2.getView().getMembers().contains(c1.getLocalAddress());\n       \n            c2.close();\n            Util.sleep(1000);\n       \n            assert c2.isOpen() == false;\n            assert c2.isConnected() == false;\n       \n            assert c2.getLocalAddress() == null;\n            assert c2.getView() == null;\n       \n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n            assert c1.getView().getMembers().contains(c2.getLocalAddress()) == false;\n        }\n        finally {\n            Util.close(c2);\n            Util.close(c1);\n        }\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test(expectedExceptions=TimeoutException.class)\n    public void testReceiveTimeout() throws ChannelException, TimeoutException {\n        ch.receive(1000); // this one works, because we're expecting a View\n        ch.receive(2000); // .. but this one doesn't (no msg available) - needs to throw a TimeoutException\n    }","id":66445,"modified_method":"@Test(expectedExceptions=TimeoutException.class)\n    public void testReceiveTimeout() throws ChannelException, TimeoutException {\n        ch.get().receive(1000); // this one works, because we're expecting a View\n        ch.get().receive(2000); // .. but this one doesn't (no msg available) - needs to throw a TimeoutException\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testViewChange() throws Exception {\n        ViewChecker checker=new ViewChecker(ch);\n        ch.setReceiver(checker);\n\n        Channel ch2=createChannel();\n        ch2.connect(GROUP);\n        assert checker.isSuccess() : checker.getReason();\n\n        ch2.close();\n        assert checker.isSuccess() : checker.getReason();\n    }","id":66446,"modified_method":"@Test\n    public void testViewChange() throws Exception {\n        ViewChecker checker=new ViewChecker(ch.get());\n        ch.get().setReceiver(checker);\n\n        Channel ch2=createChannelWithProps(PROPS.get());\n        try {\n            ch2.connect(GROUP.get());\n            assertTrue(checker.getReason(), checker.isSuccess());\n            ch2.close();\n            assertTrue(checker.getReason(), checker.isSuccess());\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testOrdering() throws Exception {\n        final int NUM=100;\n        MyReceiver receiver=new MyReceiver(NUM);\n        ch.setReceiver(receiver);\n        for(int i=1; i <= NUM; i++) {\n            ch.send(new Message(null, null, new Integer(i)));\n            System.out.println(\"-- sent \" + i);\n        }\n\n        receiver.waitForCompletion();\n\n        List<Integer> nums=receiver.getNums();\n        checkMonotonicallyIncreasingNumbers(nums);\n    }","id":66447,"modified_method":"@Test\n    public void testOrdering() throws Exception {\n        final int NUM=100;\n        MyReceiver receiver=new MyReceiver(NUM);\n        ch.get().setReceiver(receiver);\n        for(int i=1; i <= NUM; i++) {\n            ch.get().send(new Message(null, null, new Integer(i)));\n            System.out.println(\"-- sent \" + i);\n        }\n        receiver.waitForCompletion();\n        List<Integer> nums=receiver.getNums();\n        checkMonotonicallyIncreasingNumbers(nums);\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testNoViewIsReceivedAferClose() throws Exception {\n        final Channel ch2 = createChannel();\n        ReceiverAdapter ra = new ReceiverAdapter() {\n            public void viewAccepted(View new_view) {\n                receivedViewWhenDisconnected = !new_view.containsMember(ch2.getLocalAddress());\n            }\n        };\n        ch2.setReceiver(ra);\n        ch2.connect(GROUP);\n\n        Util.sleep(1000);\n        ch2.close();\n        Util.sleep(1000);\n        assert !receivedViewWhenDisconnected : \"Received view where not member\";\n    }","id":66448,"modified_method":"@Test\n    public void testNoViewIsReceivedAferClose() throws Exception {\n        final Channel ch2 = createChannelWithProps(PROPS.get());\n        MyViewChecker ra = new MyViewChecker(ch2);\n        ch2.setReceiver(ra);\n\n        try {\n            ch2.connect(GROUP.get());\n            Util.sleep(200);\n            ch2.close();\n            Util.sleep(1000);\n            assert !ra.receivedViewWhenDisconnected : \"Received view where not member\";\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testFirstView() throws Exception {\n        Object obj=ch.receive(5000);\n        System.out.println(\"view is \" + obj);\n        assert obj instanceof View : \"first object returned needs to be a View (was \" + obj + \")\";\n    }","id":66449,"modified_method":"@Test\n    public void testFirstView() throws Exception {\n        Object obj=ch.get().receive(5000);\n        assert obj instanceof View : \"first object returned needs to be a View (was \" + obj + \")\";\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testNoViewIsReceivedAferDisconnect() throws Exception {\n        final Channel ch2 = createChannel();\n        ReceiverAdapter ra = new ReceiverAdapter() {\n            public void viewAccepted(View new_view) {\n                receivedViewWhenDisconnected = !new_view.containsMember(ch2.getLocalAddress());\n            }\n        };\n        ch2.setReceiver(ra);\n        ch2.connect(GROUP);\n\n        Util.sleep(1000);\n        ch2.disconnect();\n        Util.sleep(1000);\n        assert !receivedViewWhenDisconnected : \"Received view where not member\";\n        ch2.close();\n    }","id":66450,"modified_method":"@Test\n    public void testNoViewIsReceivedAferDisconnect() throws Exception {\n        final Channel ch2 = createChannelWithProps(PROPS.get());\n        MyViewChecker ra = new MyViewChecker(ch2);\n        ch2.setReceiver(ra);\n\n        try {\n            ch2.connect(GROUP.get());\n            Util.sleep(500);\n            ch2.disconnect();\n            Util.sleep(1000);\n            assert !ra.receivedViewWhenDisconnected : \"Received view where not member\";\n        }\n        finally {\n            ch2.close();\n        }\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testIsConnectedOnFirstViewChange() throws Exception {\n        Channel ch2=createChannel();\n        ConnectedChecker tmp=new ConnectedChecker(ch2);\n        ch2.setReceiver(tmp);\n        ch2.connect(GROUP);\n\n        assert tmp.isConnected() == false;\n        ch2.close();\n    }","id":66451,"modified_method":"@Test\n    public void testIsConnectedOnFirstViewChange() throws Exception {\n        Channel ch2=createChannelWithProps(PROPS.get());\n        ConnectedChecker tmp=new ConnectedChecker(ch2);\n        ch2.setReceiver(tmp);\n        try {\n            ch2.connect(GROUP.get());\n            assertFalse(tmp.isConnected());\n            ch2.close();\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test(expectedExceptions={NullPointerException.class})\n    public void testNullMessage() throws ChannelClosedException, ChannelNotConnectedException {\n        ch.send(null);\n    }","id":66452,"modified_method":"@Test(expectedExceptions={NullPointerException.class})\n    public void testNullMessage() throws ChannelClosedException, ChannelNotConnectedException {\n        ch.get().send(null);\n    }","commit_id":"5bf5c9cb71ca12b3642b7624ffe0f21bc48afa93","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testNoViewIsReceivedAferClose() throws Exception {\n        final Channel ch2 = createChannel();\n        ReceiverAdapter ra = new ReceiverAdapter() {\n            public void viewAccepted(View new_view) {\n                receivedViewWhenDisconnected = !new_view.containsMember(ch2.getLocalAddress());\n            }\n        };\n        ch2.setReceiver(ra);\n        ch2.connect(GROUP);\n\n        Util.sleep(1000);\n        ch2.close();\n        Util.sleep(1000);\n        assert !receivedViewWhenDisconnected : \"Received view where not member\";\n    }","id":66453,"modified_method":"@Test\n    public void testNoViewIsReceivedAferClose() throws Exception {\n        final Channel ch2 = createChannelWithProps(PROPS.get());\n        MyViewChecker ra = new MyViewChecker(ch2);\n        ch2.setReceiver(ra);\n\n        try {\n            ch2.connect(GROUP.get());\n            Util.sleep(200);\n            ch2.close();\n            Util.sleep(1000);\n            assert !ra.receivedViewWhenDisconnected : \"Received view where not member\";\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testOrdering() throws Exception {\n        final int NUM=100;\n        MyReceiver receiver=new MyReceiver(NUM);\n        ch.setReceiver(receiver);\n        for(int i=1; i <= NUM; i++) {\n            ch.send(new Message(null, null, new Integer(i)));\n            System.out.println(\"-- sent \" + i);\n        }\n\n        receiver.waitForCompletion();\n\n        List<Integer> nums=receiver.getNums();\n        checkMonotonicallyIncreasingNumbers(nums);\n    }","id":66454,"modified_method":"@Test\n    public void testOrdering() throws Exception {\n        final int NUM=100;\n        MyReceiver receiver=new MyReceiver(NUM);\n        ch.get().setReceiver(receiver);\n        for(int i=1; i <= NUM; i++) {\n            ch.get().send(new Message(null, null, new Integer(i)));\n            System.out.println(\"-- sent \" + i);\n        }\n        receiver.waitForCompletion();\n        List<Integer> nums=receiver.getNums();\n        checkMonotonicallyIncreasingNumbers(nums);\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test(expectedExceptions={NullPointerException.class})\n    public void testNullMessage() throws ChannelClosedException, ChannelNotConnectedException {\n        ch.send(null);\n    }","id":66455,"modified_method":"@Test(expectedExceptions={NullPointerException.class})\n    public void testNullMessage() throws ChannelClosedException, ChannelNotConnectedException {\n        ch.get().send(null);\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testNoViewIsReceivedAferDisconnect() throws Exception {\n        final Channel ch2 = createChannel();\n        ReceiverAdapter ra = new ReceiverAdapter() {\n            public void viewAccepted(View new_view) {\n                receivedViewWhenDisconnected = !new_view.containsMember(ch2.getLocalAddress());\n            }\n        };\n        ch2.setReceiver(ra);\n        ch2.connect(GROUP);\n\n        Util.sleep(1000);\n        ch2.disconnect();\n        Util.sleep(1000);\n        assert !receivedViewWhenDisconnected : \"Received view where not member\";\n        ch2.close();\n    }","id":66456,"modified_method":"@Test\n    public void testNoViewIsReceivedAferDisconnect() throws Exception {\n        final Channel ch2 = createChannelWithProps(PROPS.get());\n        MyViewChecker ra = new MyViewChecker(ch2);\n        ch2.setReceiver(ra);\n\n        try {\n            ch2.connect(GROUP.get());\n            Util.sleep(500);\n            ch2.disconnect();\n            Util.sleep(1000);\n            assert !ra.receivedViewWhenDisconnected : \"Received view where not member\";\n        }\n        finally {\n            ch2.close();\n        }\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testBasicOperations() throws Exception {\n        String groupName = GROUP;\n        Channel c1 = createChannel(\"A\");\n        c1.connect(groupName);\n        Util.sleep(1000);\n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n       \n        c1.connect(groupName);\n\n        c1.disconnect();\n       \n        assert c1.isConnected() == false;\n        assert c1.isOpen();\n        assert c1.getLocalAddress() == null;\n        assert c1.getView() == null;\n        assert c1.getClusterName() == null;\n       \n        c1.connect(groupName);\n\n        c1.close();\n       \n        try {\n            c1.connect(groupName);\n            throw new IllegalStateException(\"Should generated exception, and it has NOT\");\n        }\n        catch (Exception e) {\n            assert e instanceof ChannelClosedException;\n        }\n       \n        assert c1.isConnected() == false;\n        assert c1.isOpen() == false;\n        assert c1.getLocalAddress() == null;\n        assert c1.getView() == null;\n       \n        assert c1.getClusterName() == null;\n       \n        c1 = createChannel(\"A\");\n        c1.connect(groupName);\n        Channel c2 = createChannel(\"A\");\n        c2.connect(groupName);\n       \n        Util.sleep(1000);\n       \n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n        assert c1.getView().getMembers().contains(c2.getLocalAddress());\n       \n        assert c2.isOpen();\n        assert c2.isConnected();\n       \n        assert c2.getLocalAddress() != null;\n        assert c2.getView() != null;\n        assert c2.getView().getMembers().contains(c2.getLocalAddress());\n        assert c2.getView().getMembers().contains(c1.getLocalAddress());\n       \n        c2.close();\n        Util.sleep(1000);\n       \n        assert c2.isOpen() == false;\n        assert c2.isConnected() == false;\n       \n        assert c2.getLocalAddress() == null;\n        assert c2.getView() == null;\n       \n        assert c1.isOpen();\n        assert c1.isConnected();\n       \n        assert c1.getLocalAddress() != null;\n        assert c1.getView() != null;\n        assert c1.getView().getMembers().contains(c1.getLocalAddress());\n        assert c1.getView().getMembers().contains(c2.getLocalAddress()) == false;\n        c1.close();\n    }","id":66457,"modified_method":"@Test\n    public void testBasicOperations() throws Exception {\n        Channel c1 = createChannelWithProps(PROPS.get());\n        Channel c2=null;\n\n        try {\n            c1.connect(GROUP.get());\n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n       \n            c1.connect(GROUP.get());\n            c1.disconnect();\n            assert c1.isConnected() == false;\n            assert c1.isOpen();\n            assert c1.getLocalAddress() == null;\n            assert c1.getView() == null;\n            assert c1.getClusterName() == null;\n       \n            c1.connect(GROUP.get());\n\n            c1.close();\n       \n            try {\n                c1.connect(GROUP.get());\n                throw new IllegalStateException(\"Should generated exception, and it has NOT\");\n            }\n            catch (Exception e) {\n                assert e instanceof ChannelClosedException;\n            }\n       \n            assert c1.isConnected() == false;\n            assert c1.isOpen() == false;\n            assert c1.getLocalAddress() == null;\n            assert c1.getView() == null;\n       \n            assert c1.getClusterName() == null;\n       \n            c1 = createChannelWithProps(PROPS.get());\n            c1.connect(GROUP.get());\n            c2 = createChannelWithProps(PROPS.get());\n            c2.connect(GROUP.get());\n       \n            Util.sleep(1000);\n       \n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n            assert c1.getView().getMembers().contains(c2.getLocalAddress());\n       \n            assert c2.isOpen();\n            assert c2.isConnected();\n       \n            assert c2.getLocalAddress() != null;\n            assert c2.getView() != null;\n            assert c2.getView().getMembers().contains(c2.getLocalAddress());\n            assert c2.getView().getMembers().contains(c1.getLocalAddress());\n       \n            c2.close();\n            Util.sleep(1000);\n       \n            assert c2.isOpen() == false;\n            assert c2.isConnected() == false;\n       \n            assert c2.getLocalAddress() == null;\n            assert c2.getView() == null;\n       \n            assert c1.isOpen();\n            assert c1.isConnected();\n       \n            assert c1.getLocalAddress() != null;\n            assert c1.getView() != null;\n            assert c1.getView().getMembers().contains(c1.getLocalAddress());\n            assert c1.getView().getMembers().contains(c2.getLocalAddress()) == false;\n        }\n        finally {\n            Util.close(c2);\n            Util.close(c1);\n        }\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testIsConnectedOnFirstViewChange() throws Exception {\n        Channel ch2=createChannel();\n        ConnectedChecker tmp=new ConnectedChecker(ch2);\n        ch2.setReceiver(tmp);\n        ch2.connect(GROUP);\n\n        assert tmp.isConnected() == false;\n        ch2.close();\n    }","id":66458,"modified_method":"@Test\n    public void testIsConnectedOnFirstViewChange() throws Exception {\n        Channel ch2=createChannelWithProps(PROPS.get());\n        ConnectedChecker tmp=new ConnectedChecker(ch2);\n        ch2.setReceiver(tmp);\n        try {\n            ch2.connect(GROUP.get());\n            assertFalse(tmp.isConnected());\n            ch2.close();\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test(expectedExceptions=TimeoutException.class)\n    public void testReceiveTimeout() throws ChannelException, TimeoutException {\n        ch.receive(1000); // this one works, because we're expecting a View\n        ch.receive(2000); // .. but this one doesn't (no msg available) - needs to throw a TimeoutException\n    }","id":66459,"modified_method":"@Test(expectedExceptions=TimeoutException.class)\n    public void testReceiveTimeout() throws ChannelException, TimeoutException {\n        ch.get().receive(1000); // this one works, because we're expecting a View\n        ch.get().receive(2000); // .. but this one doesn't (no msg available) - needs to throw a TimeoutException\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testViewChange() throws Exception {\n        ViewChecker checker=new ViewChecker(ch);\n        ch.setReceiver(checker);\n\n        Channel ch2=createChannel();\n        ch2.connect(GROUP);\n        assert checker.isSuccess() : checker.getReason();\n\n        ch2.close();\n        assert checker.isSuccess() : checker.getReason();\n    }","id":66460,"modified_method":"@Test\n    public void testViewChange() throws Exception {\n        ViewChecker checker=new ViewChecker(ch.get());\n        ch.get().setReceiver(checker);\n\n        Channel ch2=createChannelWithProps(PROPS.get());\n        try {\n            ch2.connect(GROUP.get());\n            assertTrue(checker.getReason(), checker.isSuccess());\n            ch2.close();\n            assertTrue(checker.getReason(), checker.isSuccess());\n        }\n        finally {\n            Util.close(ch2);\n        }\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testFirstView() throws Exception {\n        Object obj=ch.receive(5000);\n        System.out.println(\"view is \" + obj);\n        assert obj instanceof View : \"first object returned needs to be a View (was \" + obj + \")\";\n    }","id":66461,"modified_method":"@Test\n    public void testFirstView() throws Exception {\n        Object obj=ch.get().receive(5000);\n        assert obj instanceof View : \"first object returned needs to be a View (was \" + obj + \")\";\n    }","commit_id":"31bbc544da8889d1101f2861410b132f1a34bfad","url":"https://github.com/belaban/JGroups"},{"original_method":"public AbstractEditorComponent(IdeMain ideMain) {\n    myIdeMain = ideMain;\n\n    setDoubleBuffered(true);\n    setFocusTraversalKeysEnabled(false);\n    myScrollPane = new JScrollPane();\n    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setViewportView(this);\n//    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n//    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n    myContainer = new JPanel();\n    myContainer.setLayout(new BorderLayout());\n    myContainer.add(myScrollPane, BorderLayout.CENTER);\n\n    myNodeSubstituteChooser = new NodeSubstituteChooser(this);\n    myCellRangeSelection = new EditorCellRangeSelection(this);\n\n    // --- keyboard handling ---\n    myKbdHandlersStack = new Stack<IKeyboardHandler>();\n    myKbdHandlersStack.push(new EditorComponentKeyboardHandler());\n\n    // --- init action map --\n    myActionMap = new HashMap();\n    // -- navigation\n    myActionMap.put(EditorCellAction.LEFT, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP, new NodeEditorActions.UP());\n    myActionMap.put(EditorCellAction.DOWN, new NodeEditorActions.DOWN());\n    myActionMap.put(EditorCellAction.NEXT, new NodeEditorActions.NEXT());\n    myActionMap.put(EditorCellAction.PREV, new NodeEditorActions.PREV());\n    myActionMap.put(EditorCellAction.LEFT_SPECIAL, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT_SPECIAL, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP_SPECIAL, new NodeEditorActions.UP_SPECIAL());\n    myActionMap.put(EditorCellAction.DOWN_SPECIAL, new NodeEditorActions.DOWN_SPECIAL());\n    // ----\n    myActionMap.put(EditorCellAction.COPY, new CellAction_CopyNode());\n    myActionMap.put(EditorCellAction.PASTE, new CellAction_PasteNode());\n    myActionMap.put(EditorCellAction.PASTE_BEFORE, new CellAction_PasteNodeRelative(true));\n    myActionMap.put(EditorCellAction.PASTE_AFTER, new CellAction_PasteNodeRelative(false));\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (mySelectedCell != null && mySelectedCell.getSemanticNode() != null) {\n          createShowTypeInfoAction(mySelectedCell.getSemanticNode()).actionPerformed(e);\n        }\n      }\n    }, KeyStroke.getKeyStroke(\"control T\"), WHEN_FOCUSED);\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (mySelectedCell != null && mySelectedCell.getSemanticNode() != null) {\n          SemanticNode node = mySelectedCell.getSemanticNode();\n          ProjectPane projectPane = myIdeMain.getProjectPane();\n          projectPane.selectNode(node);\n          projectPane.getTree().requestFocus();          \n        }\n      }\n    }, KeyStroke.getKeyStroke(\"control P\"), WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (mySelectedCell != null && mySelectedCell.getSemanticNode() != null) {\n          SemanticNode selectedNode = mySelectedCell.getSemanticNode();\n          for (SemanticReference reference : selectedNode.getReferences()) {\n            SemanticNode targetNode = reference.getTargetNode();\n            SemanticNode rootNode = myRootCell.getSemanticNode();\n\n            if (rootNode.isAncestorOf(targetNode)) {\n              selectNode(targetNode);\n            } else {\n              AbstractEditorComponent editor = myIdeMain.getEditorsPane().openEditor(targetNode.getContainingRoot());\n              editor.selectNode(targetNode);\n            }\n          }\n        }\n      }\n    }, KeyStroke.getKeyStroke(\"control B\"), WHEN_FOCUSED);\n\n\n    addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        } else {\n          processMousePressed(e);\n        }\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        }\n        super.mouseReleased(e);\n      }\n    });\n\n    myKeyListener = new KeyAdapter() {\n      public void keyPressed(final KeyEvent e) {\n        processKeyPressed(e);\n      }\n\n      public void keyReleased(final KeyEvent e) {\n        processKeyReleased(e);\n      }\n    };\n    addKeyListener(myKeyListener);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        EditorCell selectedCell = getSelectedCell();\n        if (selectedCell == null) {\n          EditorCell rootCell = getRootCell();\n          if (rootCell instanceof EditorCell_Collection) {\n            EditorCell firstSelectableLeaf = ((EditorCell_Collection) rootCell).findFirstSelectableLeaf();\n            if (firstSelectableLeaf != null) {\n              changeSelection(firstSelectableLeaf);\n              return;\n            }\n          }\n          if (rootCell != null && rootCell.isSelectable()) {\n            changeSelection(rootCell);\n          }\n        }\n      }\n\n      public void focusLost(FocusEvent e) {\n        if (myNodeSubstituteChooser.getWindow() != null &&\n                (myNodeSubstituteChooser.getWindow().isAncestorOf(e.getOppositeComponent()) || myNodeSubstituteChooser.getWindow() == e.getOppositeComponent())) return; \n        myNodeSubstituteChooser.setVisible(false);\n      }\n    });\n  }","id":66462,"modified_method":"public AbstractEditorComponent(IdeMain ideMain) {\n    myIdeMain = ideMain;\n\n    setDoubleBuffered(true);\n    setFocusTraversalKeysEnabled(false);\n    myScrollPane = new JScrollPane();\n    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setViewportView(this);\n//    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n//    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n    myContainer = new JPanel();\n    myContainer.setLayout(new BorderLayout());\n    myContainer.add(myScrollPane, BorderLayout.CENTER);\n\n    myNodeSubstituteChooser = new NodeSubstituteChooser(this);\n    myCellRangeSelection = new EditorCellRangeSelection(this);\n\n    // --- keyboard handling ---\n    myKbdHandlersStack = new Stack<IKeyboardHandler>();\n    myKbdHandlersStack.push(new EditorComponentKeyboardHandler());\n\n    // --- init action map --\n    myActionMap = new HashMap();\n    // -- navigation\n    myActionMap.put(EditorCellAction.LEFT, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP, new NodeEditorActions.UP());\n    myActionMap.put(EditorCellAction.DOWN, new NodeEditorActions.DOWN());\n    myActionMap.put(EditorCellAction.NEXT, new NodeEditorActions.NEXT());\n    myActionMap.put(EditorCellAction.PREV, new NodeEditorActions.PREV());\n    myActionMap.put(EditorCellAction.LEFT_SPECIAL, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT_SPECIAL, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP_SPECIAL, new NodeEditorActions.UP_SPECIAL());\n    myActionMap.put(EditorCellAction.DOWN_SPECIAL, new NodeEditorActions.DOWN_SPECIAL());\n    // ----\n    myActionMap.put(EditorCellAction.COPY, new CellAction_CopyNode());\n    myActionMap.put(EditorCellAction.PASTE, new CellAction_PasteNode());\n    myActionMap.put(EditorCellAction.PASTE_BEFORE, new CellAction_PasteNodeRelative(true));\n    myActionMap.put(EditorCellAction.PASTE_AFTER, new CellAction_PasteNodeRelative(false));\n\n    registerKeyboardAction(new ShowTypeAction(), KeyStroke.getKeyStroke(\"control T\"), WHEN_FOCUSED);\n    registerKeyboardAction(new ShowInProjectAction(), KeyStroke.getKeyStroke(\"control P\"), WHEN_FOCUSED);\n    registerKeyboardAction(new GoByReferenceAction(), KeyStroke.getKeyStroke(\"control B\"), WHEN_FOCUSED);\n\n    addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        } else {\n          processMousePressed(e);\n        }\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        }\n        super.mouseReleased(e);\n      }\n    });\n\n    myKeyListener = new KeyAdapter() {\n      public void keyPressed(final KeyEvent e) {\n        processKeyPressed(e);\n      }\n\n      public void keyReleased(final KeyEvent e) {\n        processKeyReleased(e);\n      }\n    };\n    addKeyListener(myKeyListener);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        EditorCell selectedCell = getSelectedCell();\n        if (selectedCell == null) {\n          EditorCell rootCell = getRootCell();\n          if (rootCell instanceof EditorCell_Collection) {\n            EditorCell firstSelectableLeaf = ((EditorCell_Collection) rootCell).findFirstSelectableLeaf();\n            if (firstSelectableLeaf != null) {\n              changeSelection(firstSelectableLeaf);\n              return;\n            }\n          }\n          if (rootCell != null && rootCell.isSelectable()) {\n            changeSelection(rootCell);\n          }\n        }\n      }\n\n      public void focusLost(FocusEvent e) {\n        if (myNodeSubstituteChooser.getWindow() != null &&\n                (myNodeSubstituteChooser.getWindow().isAncestorOf(e.getOppositeComponent()) || myNodeSubstituteChooser.getWindow() == e.getOppositeComponent())) return; \n        myNodeSubstituteChooser.setVisible(false);\n      }\n    });\n  }","commit_id":"e0a380d13a804e8d199c53704714cb01d5470750","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AbstractEditorComponent(IdeMain ideMain) {\n    addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) {\n        myPreviousFocusOwner = e.getOppositeComponent();\n      }\n    });\n\n    myIdeMain = ideMain;\n\n    setFocusTraversalPolicyProvider(true);\n    setFocusCycleRoot(true);\n    setFocusTraversalPolicy(new FocusTraversalPolicy() {\n      public Component getComponentAfter(Container aContainer, Component aComponent) {\n        executeComponentAction(EditorCellAction.NEXT);\n        return aContainer;\n      }\n\n      public Component getComponentBefore(Container aContainer, Component aComponent) {\n        executeComponentAction(EditorCellAction.PREV);\n        return aContainer;\n      }\n\n      public Component getFirstComponent(Container aContainer) {\n        return aContainer;\n      }\n\n      public Component getLastComponent(Container aContainer) {\n        return aContainer;\n      }\n\n      public Component getDefaultComponent(Container aContainer) {\n        return aContainer;\n      }\n    });\n    setFocusTraversalKeysEnabled(false);\n\n    setDoubleBuffered(true);\n    myScrollPane = new JScrollPane();\n    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setViewportView(this);\n//    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n//    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n    myContainer = new JPanel();\n    myContainer.setLayout(new BorderLayout());\n    myContainer.add(myScrollPane, BorderLayout.CENTER);\n\n    myNodeSubstituteChooser = new NodeSubstituteChooser(this);\n    myCellRangeSelection = new EditorCellRangeSelection(this);\n\n    // --- keyboard handling ---\n    myKbdHandlersStack = new Stack<IKeyboardHandler>();\n    myKbdHandlersStack.push(new EditorComponentKeyboardHandler());\n\n    // --- init action map --\n    myActionMap = new HashMap();\n    // -- navigation\n    myActionMap.put(EditorCellAction.LEFT, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP, new NodeEditorActions.UP());\n    myActionMap.put(EditorCellAction.DOWN, new NodeEditorActions.DOWN());\n    myActionMap.put(EditorCellAction.NEXT, new NodeEditorActions.NEXT());\n    myActionMap.put(EditorCellAction.PREV, new NodeEditorActions.PREV());\n    myActionMap.put(EditorCellAction.LEFT_SPECIAL, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT_SPECIAL, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP_SPECIAL, new NodeEditorActions.UP_SPECIAL());\n    myActionMap.put(EditorCellAction.DOWN_SPECIAL, new NodeEditorActions.DOWN_SPECIAL());\n    // ----\n    myActionMap.put(EditorCellAction.COPY, new CellAction_CopyNode());\n    myActionMap.put(EditorCellAction.PASTE, new CellAction_PasteNode());\n    myActionMap.put(EditorCellAction.PASTE_BEFORE, new CellAction_PasteNodeRelative(true));\n    myActionMap.put(EditorCellAction.PASTE_AFTER, new CellAction_PasteNodeRelative(false));\n\n    registerKeyboardAction(new ShowTypeAction(), KeyStroke.getKeyStroke(\"control T\"), WHEN_FOCUSED);\n    registerKeyboardAction(new ShowInProjectAction(), KeyStroke.getKeyStroke(\"control P\"), WHEN_FOCUSED);\n    registerKeyboardAction(new GoByReferenceAction(), KeyStroke.getKeyStroke(\"control B\"), WHEN_FOCUSED);\n    registerKeyboardAction(new GoToDefinitionAction(), KeyStroke.getKeyStroke(\"control shift S\"), WHEN_FOCUSED);\n    registerKeyboardAction(new GoToEditorAction(), KeyStroke.getKeyStroke(\"control shift E\"), WHEN_FOCUSED);\n    registerKeyboardAction(new GoToConceptEditorAction(), KeyStroke.getKeyStroke(\"control E\"), WHEN_FOCUSED);\n    registerKeyboardAction(new FindUsagesAction(), KeyStroke.getKeyStroke(\"alt F7\"), WHEN_FOCUSED);\n    registerKeyboardAction(new ReturnToPreviousComponentAction(), KeyStroke.getKeyStroke(\"ESCAPE\"), WHEN_FOCUSED);\n\n    addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        } else {\n          processMousePressed(e);\n        }\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        }\n        super.mouseReleased(e);\n      }\n    });\n\n    myKeyListener = new KeyAdapter() {\n      public void keyPressed(final KeyEvent e) {\n        if (myRecorder != null) {\n          myRecorder.record(e, AbstractEditorComponent.this instanceof InspectorEditorComponent);\n        }\n        processKeyPressed(e);\n      }\n\n      public void keyReleased(final KeyEvent e) {\n        if (myRecorder != null) {\n          myRecorder.record(e, AbstractEditorComponent.this instanceof InspectorEditorComponent);\n        }\n        processKeyReleased(e);\n      }\n    };\n    addKeyListener(myKeyListener);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        EditorCell selectedCell = getSelectedCell();\n        if (selectedCell == null) {\n          EditorCell rootCell = getRootCell();\n          if (rootCell instanceof EditorCell_Collection) {\n            EditorCell firstSelectableLeaf = ((EditorCell_Collection) rootCell).findFirstSelectableLeaf();\n            if (firstSelectableLeaf != null) {\n              changeSelection(firstSelectableLeaf);\n              return;\n            }\n          }\n          if (rootCell != null && rootCell.isSelectable()) {\n            changeSelection(rootCell);\n          }\n        }\n      }\n\n      public void focusLost(FocusEvent e) {\n        if (myNodeSubstituteChooser.getWindow() != null &&\n                (myNodeSubstituteChooser.getWindow().isAncestorOf(e.getOppositeComponent()) || myNodeSubstituteChooser.getWindow() == e.getOppositeComponent()))\n          return;\n        myNodeSubstituteChooser.setVisible(false);\n      }\n    });\n  }","id":66463,"modified_method":"public AbstractEditorComponent(IdeMain ideMain) {\n    addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) {\n        myPreviousFocusOwner = e.getOppositeComponent();\n      }\n    });\n\n    myIdeMain = ideMain;\n\n    setFocusTraversalPolicyProvider(true);\n    setFocusCycleRoot(true);\n    setFocusTraversalPolicy(new FocusTraversalPolicy() {\n      public Component getComponentAfter(Container aContainer, Component aComponent) {\n        executeComponentAction(EditorCellAction.NEXT);\n        return aContainer;\n      }\n\n      public Component getComponentBefore(Container aContainer, Component aComponent) {\n        executeComponentAction(EditorCellAction.PREV);\n        return aContainer;\n      }\n\n      public Component getFirstComponent(Container aContainer) {\n        return aContainer;\n      }\n\n      public Component getLastComponent(Container aContainer) {\n        return aContainer;\n      }\n\n      public Component getDefaultComponent(Container aContainer) {\n        return aContainer;\n      }\n    });\n    setFocusTraversalKeysEnabled(false);\n\n    setDoubleBuffered(true);\n    myScrollPane = new JScrollPane();\n    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.setViewportView(this);\n//    myScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n//    myScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\n    myContainer = new JPanel();\n    myContainer.setLayout(new BorderLayout());\n    myContainer.add(myScrollPane, BorderLayout.CENTER);\n\n    myNodeSubstituteChooser = new NodeSubstituteChooser(this);\n    myCellRangeSelection = new EditorCellRangeSelection(this);\n\n    // --- keyboard handling ---\n    myKbdHandlersStack = new Stack<IKeyboardHandler>();\n    myKbdHandlersStack.push(new EditorComponentKeyboardHandler());\n\n    // --- init action map --\n    myActionMap = new HashMap();\n    // -- navigation\n    myActionMap.put(EditorCellAction.LEFT, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP, new NodeEditorActions.UP());\n    myActionMap.put(EditorCellAction.DOWN, new NodeEditorActions.DOWN());\n    myActionMap.put(EditorCellAction.NEXT, new NodeEditorActions.NEXT());\n    myActionMap.put(EditorCellAction.PREV, new NodeEditorActions.PREV());\n    myActionMap.put(EditorCellAction.LEFT_SPECIAL, new NodeEditorActions.LEFT());\n    myActionMap.put(EditorCellAction.RIGHT_SPECIAL, new NodeEditorActions.RIGHT());\n    myActionMap.put(EditorCellAction.UP_SPECIAL, new NodeEditorActions.UP_SPECIAL());\n    myActionMap.put(EditorCellAction.DOWN_SPECIAL, new NodeEditorActions.DOWN_SPECIAL());\n    // ----\n    myActionMap.put(EditorCellAction.COPY, new CellAction_CopyNode());\n    myActionMap.put(EditorCellAction.PASTE, new CellAction_PasteNode());\n    myActionMap.put(EditorCellAction.PASTE_BEFORE, new CellAction_PasteNodeRelative(true));\n    myActionMap.put(EditorCellAction.PASTE_AFTER, new CellAction_PasteNodeRelative(false));\n\n\n    registerNodeAction(new ShowNodeTypeAction(), \"control T\");\n    registerNodeAction(new FindUsagesNodeAction(), \"alt F7\");\n    registerNodeAction(new ShowInProjectAction(), \"control P\");\n    registerNodeAction(new GoByReferenceAction(), \"control B\");\n    registerNodeAction(new GoToDefinitionAction(), \"control shift S\");\n    registerNodeAction(new GoToEditorAction(), \"control shift E\");\n    registerNodeAction(new GoToConceptEditorDeclarationAction(), \"control E\");\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (myPreviousFocusOwner != null) {\n          myPreviousFocusOwner.requestFocus();\n        }\n      }\n    }, KeyStroke.getKeyStroke(\"ESCAPE\"), WHEN_FOCUSED);\n\n    addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        } else {\n          processMousePressed(e);\n        }\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          processPopupMenu(e);\n        }\n        super.mouseReleased(e);\n      }\n    });\n\n    myKeyListener = new KeyAdapter() {\n      public void keyPressed(final KeyEvent e) {\n        if (myRecorder != null) {\n          myRecorder.record(e, AbstractEditorComponent.this instanceof InspectorEditorComponent);\n        }\n        processKeyPressed(e);\n      }\n\n      public void keyReleased(final KeyEvent e) {\n        if (myRecorder != null) {\n          myRecorder.record(e, AbstractEditorComponent.this instanceof InspectorEditorComponent);\n        }\n        processKeyReleased(e);\n      }\n    };\n    addKeyListener(myKeyListener);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        EditorCell selectedCell = getSelectedCell();\n        if (selectedCell == null) {\n          EditorCell rootCell = getRootCell();\n          if (rootCell instanceof EditorCell_Collection) {\n            EditorCell firstSelectableLeaf = ((EditorCell_Collection) rootCell).findFirstSelectableLeaf();\n            if (firstSelectableLeaf != null) {\n              changeSelection(firstSelectableLeaf);\n              return;\n            }\n          }\n          if (rootCell != null && rootCell.isSelectable()) {\n            changeSelection(rootCell);\n          }\n        }\n      }\n\n      public void focusLost(FocusEvent e) {\n        if (myNodeSubstituteChooser.getWindow() != null &&\n                (myNodeSubstituteChooser.getWindow().isAncestorOf(e.getOppositeComponent()) || myNodeSubstituteChooser.getWindow() == e.getOppositeComponent()))\n          return;\n        myNodeSubstituteChooser.setVisible(false);\n      }\n    });\n  }","commit_id":"6e8278d11312a721a83cb2742f102dec6b007a95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void showPopupMenu(MouseEvent e) {\n    final SemanticNode selectedNode = getSelectedCell().getSemanticNode();\n    if (selectedNode == null) return;\n//    selectNode(selectedNode);\n    JPopupMenu popupMenu = new JPopupMenu();\n    String header = JavaNameUtil.shortName(selectedNode.getClass().getName());\n    if (selectedNode.getName() != null) {\n      header = header + \" \\\"\" + selectedNode.getName() + \"\\\"\";\n    }\n//    String header = selectedNode.getDebugText();\n    popupMenu.add(JavaNameUtil.shortName(header));\n    popupMenu.addSeparator();\n    popupMenu.add(createGoToProjectAction(selectedNode));\n    if (selectedNode instanceof ConceptDeclaration) {\n      popupMenu.add(createGoToEditorAction((ConceptDeclaration) selectedNode));\n    }\n    popupMenu.addSeparator();\n    popupMenu.add(createGoByReferenceMenu(selectedNode));\n    popupMenu.add(createFindUsagesAction(selectedNode));\n    popupMenu.add(createGoToDeclarationAction(selectedNode));\n    popupMenu.add(new AbstractAction(\"Print node id\") {\n      public void actionPerformed(ActionEvent e) {\n        System.out.println(selectedNode.getId());\n      }\n    });\n    popupMenu.addSeparator();\n    popupMenu.add(createShowTypeInfoAction(selectedNode));\n\n    if (selectedNode instanceof JavaClass) {\n      popupMenu.addSeparator();\n      popupMenu.add(createGenStubFromClassFileAction((JavaClass) selectedNode));\n    }\n\n    popupMenu.show(AbstractEditorComponent.this, e.getX(), e.getY());\n  }","id":66464,"modified_method":"private void showPopupMenu(MouseEvent e) {\n    final SemanticNode selectedNode = getSelectedCell().getSemanticNode();\n    if (selectedNode == null) return;\n//    selectNode(selectedNode);\n    JPopupMenu popupMenu = new JPopupMenu();\n    String header = JavaNameUtil.shortName(selectedNode.getClass().getName());\n    if (selectedNode.getName() != null) {\n      header = header + \" \\\"\" + selectedNode.getName() + \"\\\"\";\n    }\n//    String header = selectedNode.getDebugText();\n    popupMenu.add(JavaNameUtil.shortName(header));\n    popupMenu.addSeparator();\n    popupMenu.add(createGoToProjectAction(selectedNode));\n    if (selectedNode instanceof ConceptDeclaration) {\n      popupMenu.add(new GoToConceptEditorDeclarationAction().toAction(selectedNode));\n    }\n    popupMenu.addSeparator();\n    popupMenu.add(createGoByReferenceMenu(selectedNode));\n    popupMenu.add(new FindUsagesNodeAction().toAction(selectedNode));\n    popupMenu.add(createGoToDeclarationAction(selectedNode));\n    popupMenu.add(new AbstractAction(\"Print node id\") {\n      public void actionPerformed(ActionEvent e) {\n        System.out.println(selectedNode.getId());\n      }\n    });\n    popupMenu.addSeparator();\n    popupMenu.add(new ShowNodeTypeAction().toAction(selectedNode));\n\n    if (selectedNode instanceof JavaClass) {\n      popupMenu.addSeparator();\n      popupMenu.add(createGenStubFromClassFileAction((JavaClass) selectedNode));\n    }\n\n    popupMenu.show(AbstractEditorComponent.this, e.getX(), e.getY());\n  }","commit_id":"6e8278d11312a721a83cb2742f102dec6b007a95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initComponent() {\n    addComponent(MPSProject.class, this);\n    addComponent(EditorManager.class, new EditorManager());\n    addComponent(UndoManager.class, UndoManager.instance());\n    addComponent(EditorsPaneComponent.class, new EditorsPaneComponent(this));\n    addComponent(ProjectPaneComponent.class, new ProjectPaneComponent(this));\n    addComponent(MainFrameComponent.class, new MainFrameComponent());\n    addComponent(SemanticModels.class, new SemanticModels(this));\n    addComponent(ExecutionManager.class, new ExecutionManager());\n    addComponent(RootManager.class, myRootManager);\n  }","id":66465,"modified_method":"private void initComponent() {\n    addComponent(MPSProject.class, this);\n    addComponent(EditorManager.class, new EditorManager());\n    addComponent(UndoManager.class, UndoManager.instance());\n    addComponent(EditorsPaneComponent.class, new EditorsPaneComponent(this));\n    addComponent(ProjectPaneComponent.class, new ProjectPaneComponent(this));\n    addComponent(MainFrameComponent.class, new MainFrameComponent());\n    addComponent(SemanticModels.class, new SemanticModels(this));\n    addComponent(ExecutionManager.class, new ExecutionManager());\n    addComponent(RootManager.class, myRootManager);\n    addComponent(ActionManager.class, new ActionManager());\n  }","commit_id":"6e8278d11312a721a83cb2742f102dec6b007a95","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void filter() {\n      DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode();\n      buildTree(rootNode);\n\n      String filterText;\n\n      DefaultMutableTreeNode newContainingClassNode;\n\n      TreeNode containingClassNode;\n      try {\n        containingClassNode = rootNode.getFirstChild();\n      } catch (Exception e) {\n        return;\n      }\n\n      while (containingClassNode != null) {\n        if (!(containingClassNode instanceof DefaultMutableTreeNode)) break;\n\n        TreeNode child;\n        try {\n          child = ((DefaultMutableTreeNode) containingClassNode).getFirstChild();\n        } catch (Exception e) {\n          return;\n        }\n\n        DefaultMutableTreeNode newChild;\n        while (child != null) {\n          if (!(child instanceof DefaultMutableTreeNode)) break;\n\n          final Object userObject = ((DefaultMutableTreeNode) child).getUserObject();\n          if (!(userObject instanceof DPPropertyElement)) break;\n\n          filterText = getFilter();\n          if (filterText == null) break;\n\n          final String propertyName = ((DPPropertyElement) userObject).getPropertyName();\n\n          if (propertyName == null || \"\".equals(filterText)) break;\n\n          newChild = ((DefaultMutableTreeNode) child).getNextSibling();\n\n          if (!propertyName.contains(filterText)) {\n            final TreeNode parent = child.getParent();\n\n            if (!(parent instanceof DefaultMutableTreeNode)) break;\n\n            ((DefaultMutableTreeNode) parent).remove(((DefaultMutableTreeNode) child));\n          } else {\n            ((DPPropertyElement) userObject).setHightlightedText(filterText);\n          }\n\n          child = newChild;\n        }\n\n        newContainingClassNode = ((DefaultMutableTreeNode) containingClassNode).getNextSibling();\n\n        if (containingClassNode.getChildCount() == 0) {\n          final TreeNode parent = containingClassNode.getParent();\n\n          if (!(parent instanceof DefaultMutableTreeNode)) break;\n          ((DefaultMutableTreeNode) parent).remove(((DefaultMutableTreeNode) containingClassNode));\n        }\n\n        containingClassNode = newContainingClassNode;\n      }\n\n      rebuildTreeView(rootNode, true);\n    }","id":66466,"modified_method":"public void filter() {\n      DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode();\n      buildTree(myProject, rootNode);\n\n      String filterText;\n\n      DefaultMutableTreeNode newContainingClassNode;\n\n      TreeNode containingClassNode;\n      try {\n        containingClassNode = rootNode.getFirstChild();\n      } catch (Exception e) {\n        return;\n      }\n\n      while (containingClassNode != null) {\n        if (!(containingClassNode instanceof DefaultMutableTreeNode)) break;\n\n        TreeNode child;\n        try {\n          child = ((DefaultMutableTreeNode) containingClassNode).getFirstChild();\n        } catch (Exception e) {\n          return;\n        }\n\n        DefaultMutableTreeNode newChild;\n        while (child != null) {\n          if (!(child instanceof DefaultMutableTreeNode)) break;\n\n          final Object userObject = ((DefaultMutableTreeNode) child).getUserObject();\n          if (!(userObject instanceof DPPropertyNode)) break;\n\n          filterText = getFilter();\n          if (filterText == null) break;\n\n          final String propertyName = ((DPPropertyNode) userObject).getElement().getPropertyName();\n\n          if (propertyName == null || \"\".equals(filterText)) break;\n\n          newChild = ((DefaultMutableTreeNode) child).getNextSibling();\n\n          if (!propertyName.contains(filterText)) {\n            final TreeNode parent = child.getParent();\n\n            if (!(parent instanceof DefaultMutableTreeNode)) break;\n\n            ((DefaultMutableTreeNode) parent).remove(((DefaultMutableTreeNode) child));\n          } else {\n            ((DPPropertyNode) userObject).getElement().setHightlightedText(filterText);\n          }\n\n          child = newChild;\n        }\n\n        newContainingClassNode = ((DefaultMutableTreeNode) containingClassNode).getNextSibling();\n\n        if (containingClassNode.getChildCount() == 0) {\n          final TreeNode parent = containingClassNode.getParent();\n\n          if (!(parent instanceof DefaultMutableTreeNode)) break;\n          ((DefaultMutableTreeNode) parent).remove(((DefaultMutableTreeNode) containingClassNode));\n        }\n\n        containingClassNode = newContainingClassNode;\n      }\n\n      rebuildTreeView(myProject, rootNode, true);\n    }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private DefaultMutableTreeNode buildTree(DefaultMutableTreeNode rootNode) {\n    final Module module = getModule();\n    if (module == null) return new DefaultMutableTreeNode();\n\n    final Set<String> containingClasses = DynamicPropertiesManager.getInstance(myProject).getAllContainingClasses(module.getName());\n\n    DefaultMutableTreeNode containingClassNode;\n    for (String containingClassName : containingClasses) {\n      containingClassNode = new DefaultMutableTreeNode(new DPClassNode(new DPContainingClassElement(containingClassName)));\n\n      final String[] properties = DynamicPropertiesManager.getInstance(myProject).findDynamicPropertiesOfClass(module.getName(), containingClassName);\n\n      if (properties.length == 0) continue;\n\n      DefaultMutableTreeNode propertyTreeNode;\n      for (String propertyName : properties) {\n        final String propertyType = DynamicPropertiesManager.getInstance(myProject).findDynamicPropertyType(module.getName(), containingClassName, propertyName);\n        //TODO: simplify Hierarchy\n        propertyTreeNode = new DefaultMutableTreeNode(new DPPopertyNode(new DPPropertyElement(new DynamicPropertyVirtual(propertyName, containingClassName, module.getName(), propertyType))));\n        containingClassNode.add(propertyTreeNode);\n      }\n\n      rootNode.add(containingClassNode);\n    }\n    return rootNode;\n  }","id":66467,"modified_method":"private static DefaultMutableTreeNode buildTree(Project project, DefaultMutableTreeNode rootNode) {\n    final Module module = getModule(project);\n    if (module == null) return new DefaultMutableTreeNode();\n\n    final Set<String> containingClasses = DynamicPropertiesManager.getInstance(project).getAllContainingClasses(module.getName());\n\n    DefaultMutableTreeNode containingClassNode;\n    for (String containingClassName : containingClasses) {\n      containingClassNode = new DefaultMutableTreeNode(new DPClassNode(new DPContainingClassElement(containingClassName)));\n\n      final String[] properties = DynamicPropertiesManager.getInstance(project).findDynamicPropertiesOfClass(module.getName(), containingClassName);\n\n      if (properties.length == 0) continue;\n\n      DefaultMutableTreeNode propertyTreeNode;\n      for (String propertyName : properties) {\n        final String propertyType = DynamicPropertiesManager.getInstance(project).findDynamicPropertyType(module.getName(), containingClassName, propertyName);\n        //TODO: simplify Hierarchy\n        propertyTreeNode = new DefaultMutableTreeNode(new DPPropertyNode(new DPPropertyElement(new DynamicPropertyVirtual(propertyName, containingClassName, module.getName(), propertyType))));\n        containingClassNode.add(propertyTreeNode);\n      }\n\n      rootNode.add(containingClassNode);\n    }\n    return rootNode;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JPanel getContentPane() {\n    if (myPanel == null) {\n      buildWholePanel();\n    }\n    return myPanel;\n  }","id":66468,"modified_method":"protected boolean isDynamicToolWindowShowing(Project project) {\n    ToolWindowManager windowManager = ToolWindowManager.getInstance(project);\n    ToolWindow toolWindow = windowManager.getToolWindow(DYNAMIC_TOOLWINDOW_ID);\n    return toolWindow != null && toolWindow.isVisible();\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DynamicTreeViewState getState() {\n    DynamicTreeViewState structureViewState = new DynamicTreeViewState();\n    if (myTreeTable.getTree() != null) {\n      structureViewState.setExpandedElements(getExpandedElements());\n      structureViewState.setSelectedElements(getSelectedElements());\n    }\n    return structureViewState;\n  }","id":66469,"modified_method":"private static DynamicTreeViewState getState() {\n    DynamicTreeViewState structureViewState = new DynamicTreeViewState();\n    if (myTreeTable.getTree() != null) {\n      structureViewState.setExpandedElements(getExpandedElements());\n      structureViewState.setSelectedElements(getSelectedElements());\n    }\n    return structureViewState;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeTable getTreeTable() {\n    return myTreeTable;\n  }","id":66470,"modified_method":"private static TreeTable returnTreeTable() {\n    return myTreeTable;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void rebuildTreeView(DefaultMutableTreeNode root, boolean expandAll) {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n//    if (!isDynamicToolWindowShowing()) return;\n\n//    storeState();\n    myTreeTablePanel.removeAll();\n\n    final JScrollPane treeTable = createTable(root);\n\n\n    if (expandAll) {\n      TreeUtil.expandAll(myTreeTable.getTree());\n    }\n\n//    boolean hadFocus = IJSwingUtilities.hasFocus2(myTreeTable);\n//    if (hadFocus) {\n//      JComponent focusedComponent = IdeFocusTraversalPolicy.getPreferredFocusedComponent(myTreeTable);\n//      if (focusedComponent != null) {\n//        focusedComponent.requestFocus();\n//      }\n//    }\n\n    myTreeTablePanel.add(treeTable);\n  }","id":66471,"modified_method":"private static void rebuildTreeView(Project project, DefaultMutableTreeNode root, boolean expandAll) {\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n//    if (!isDynamicToolWindowShowing()) return;\n\n//    storeState();\n    myTreeTablePanel.removeAll();\n\n    final JScrollPane treeTable = createTable(project, root);\n\n    if (expandAll) {\n      TreeUtil.expandAll(myTreeTable.getTree());\n    }\n\n    myTreeTablePanel.add(treeTable);\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void rebuildTreePanel() {\n\n//    storeState();\n//    if (!isDynamicToolWindowShowing()) return;\n\n    DefaultMutableTreeNode myRootNode = new DefaultMutableTreeNode();\n    buildTree(myRootNode);\n\n    rebuildTreeView(myRootNode, false);\n\n//    restoreState();\n  }","id":66472,"modified_method":"private static void rebuildTreePanel(Project project) {\n//    storeState(project);\n//    if (!isDynamicToolWindowShowing()) return;\n\n    DefaultMutableTreeNode myRootNode = new DefaultMutableTreeNode();\n    buildTree(project, myRootNode);\n\n    rebuildTreeView(project, myRootNode, false);\n\n//    restoreState(project);\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void restoreState() {\n    if (myTreeTable != null && myTreeTable.getTree() != null) {\n      final Module module = getModule();\n\n      if (module != null) {\n        myState = module.getUserData(DYNAMIC_TOOLWINDOW_STATE_KEY);\n      }\n\n      TreeUtil.restoreExpandedPaths(myTreeTable.getTree(), myState.getExpandedElements());\n    }\n  }","id":66473,"modified_method":"private static void restoreState(Project project) {\n    if (doesTreeTableInit()) {\n      final Module module = getModule(project);\n\n      if (module != null) {\n        myState = module.getUserData(DYNAMIC_TOOLWINDOW_STATE_KEY);\n      }\n\n      TreeUtil.restoreExpandedPaths(myTreeTable.getTree(), myState.getExpandedElements());\n    }\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JScrollPane createTable(MutableTreeNode myTreeRoot) {\n    ColumnInfo[] columnInfos = {new ClassColumnInfo(myColumnNames[0]), new PropertyTypeColumnInfo(myColumnNames[1])};\n\n    myTreeTableModel = new ListTreeTableModelOnColumns(myTreeRoot, columnInfos);\n    myTreeTable = new TreeTable(myTreeTableModel);\n    myTreeTable.setRootVisible(false);\n\n    myTreeTable.registerKeyboardAction(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent event) {\n//            final List<TreePath> expandedTreePathList = TreeUtil.collectExpandedPaths(myTreeTable.getTree());\n            final int[] rows = myTreeTable.getSelectedRows();\n//            for (int row : rows) {\n            final TreePath selectionPath = myTreeTable.getTree().getAnchorSelectionPath();\n\n            //class\n            final TreePath parent = selectionPath.getParentPath();\n\n            final Module module = getModule();\n            if (parent.getParentPath() == null) {\n              //selectionPath is class\n\n              final Object containingClassRow = parent.getLastPathComponent();\n\n              if (!(containingClassRow instanceof DefaultMutableTreeNode)) return;\n              final Object containingClass = ((DefaultMutableTreeNode) containingClassRow).getUserObject();\n\n              if (module == null) return;\n              if (!(containingClass instanceof DPContainingClassElement)) return;\n\n              DynamicPropertiesManager.getInstance(myProject).removeDynamicPropertiesOfClass(module.getName(), ((DPContainingClassElement) containingClass).getContainingClassName());\n            } else {\n              //selectionPath is property\n              final Object containingClass = parent.getLastPathComponent();\n              final Object property = selectionPath.getLastPathComponent();\n\n              if (!(containingClass instanceof DefaultMutableTreeNode)) return;\n              if (!(property instanceof DefaultMutableTreeNode)) return;\n\n              final Object classElement = ((DefaultMutableTreeNode) containingClass).getUserObject();\n              final Object propertyElement = ((DefaultMutableTreeNode) property).getUserObject();\n\n              if (!(classElement instanceof DPContainingClassElement)) return;\n              if (!(propertyElement instanceof DPPropertyElement)) return;\n\n              final String containingClassName = ((DPContainingClassElement) classElement).getContainingClassName();\n              final String propertyName = ((DPPropertyElement) propertyElement).getPropertyName();\n              final String propertyType = ((DPPropertyElement) propertyElement).getPropertyType();\n\n              DynamicPropertyVirtual dynamicProperty = new DynamicPropertyVirtual(propertyName, containingClassName, module.getName(), propertyType);\n\n              DynamicPropertiesManager.getInstance(myProject).removeDynamicProperty(dynamicProperty);\n            }\n          }\n        },\n        KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\n        JComponent.WHEN_FOCUSED\n    );\n\n    // todo use \"myTreeTable.setAutoCreateRowSorter(true);\" since 1.6\n\n    myTreeTable.getTree().setShowsRootHandles(true);\n    myTreeTable.getTableHeader().setReorderingAllowed(false);\n\n    myTreeTable.setTreeCellRenderer(new ColoredTreeCellRenderer() {\n      public void customizeCellRenderer(JTree tree,\n                                        Object value,\n                                        boolean selected,\n                                        boolean expanded,\n                                        boolean leaf,\n                                        int row,\n                                        boolean hasFocus) {\n        value = ((DefaultMutableTreeNode) value).getUserObject();\n\n        setPaintFocusBorder(false);\n\n        if (value != null) {\n\n          if (value instanceof DPClassNode) {\n            append(((DPClassNode) value).getElement().getContainingClassName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n\n          } else if (value instanceof DPPopertyNode) {\n            final DPPopertyNode propertyElement = (DPPopertyNode) value;\n            final String substringToHighlight = propertyElement.getElement().getHightlightedText();\n            final String propertyName = propertyElement.getElement().getPropertyName();\n\n            if (substringToHighlight != null) {\n              final int begin = propertyName.indexOf(substringToHighlight);\n              final String first = propertyName.substring(0, begin);\n              append(first, SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n              final TextAttributes textAttributes = TextAttributes.ERASE_MARKER;\n//              textAttributes.setEffectColor(new Color(200, 200, 200));\n              textAttributes.setBackgroundColor(UIUtil.getListSelectionBackground());\n              append(substringToHighlight, SimpleTextAttributes.fromTextAttributes(textAttributes));\n              append(propertyName.substring(first.length() + substringToHighlight.length()), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n            } else {\n              append(propertyName, SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n            }\n\n          }/* else if (value instanceof DPPropertyTypeElement) {\n            append(((DPPropertyTypeElement) value).getPropertyType(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n          }*/\n        }\n      }\n    });\n\n    myTreeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTreeTable.setPreferredScrollableViewportSize(new Dimension(300, myTreeTable.getRowHeight() * 10));\n    myTreeTable.getColumn(myColumnNames[0]).setPreferredWidth(200);\n    myTreeTable.getColumn(myColumnNames[1]).setPreferredWidth(160);\n\n    myTreeTable.addMouseListener(\n        new MouseAdapter() {\n          public void mouseClicked(MouseEvent e) {\n            final Point point = e.getPoint();\n            if (e.getClickCount() == 2 && myTreeTable.columnAtPoint(point) == 1) {\n              myTreeTable.editCellAt(myTreeTable.rowAtPoint(point), myTreeTable.columnAtPoint(point), e);\n            }\n          }\n        }\n    );\n\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myTreeTable);\n\n    scrollpane.setPreferredSize(new Dimension(600, 400));\n    return scrollpane;\n  }","id":66474,"modified_method":"private static JScrollPane createTable(final Project project, MutableTreeNode myTreeRoot) {\n    ColumnInfo[] columnInfos = {new ClassColumnInfo(myColumnNames[0]), new PropertyTypeColumnInfo(myColumnNames[1])};\n\n    myTreeTableModel = new ListTreeTableModelOnColumns(myTreeRoot, columnInfos);\n    myTreeTable = new TreeTable(myTreeTableModel);\n    myTreeTable.setRootVisible(false);\n\n    myTreeTable.registerKeyboardAction(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent event) {\n            storeState(project);\n            deleteRow(project);\n            restoreState(project);\n          }\n        },\n        KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\n        JComponent.WHEN_FOCUSED\n    );\n\n    // todo use \"myTreeTable.setAutoCreateRowSorter(true);\" since 1.6\n\n    myTreeTable.getTree().setShowsRootHandles(true);\n    myTreeTable.getTableHeader().setReorderingAllowed(false);\n\n    myTreeTable.setTreeCellRenderer(new ColoredTreeCellRenderer() {\n      public void customizeCellRenderer(JTree tree,\n                                        Object value,\n                                        boolean selected,\n                                        boolean expanded,\n                                        boolean leaf,\n                                        int row,\n                                        boolean hasFocus) {\n        value = ((DefaultMutableTreeNode) value).getUserObject();\n\n        setPaintFocusBorder(false);\n\n        if (value != null) {\n\n          if (value instanceof DPClassNode) {\n            append(((DPClassNode) value).getElement().getContainingClassName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n\n          } else if (value instanceof DPPropertyNode) {\n            final DPPropertyNode propertyElement = (DPPropertyNode) value;\n            final String substringToHighlight = propertyElement.getElement().getHightlightedText();\n            final String propertyName = propertyElement.getElement().getPropertyName();\n\n            if (substringToHighlight != null) {\n              final int begin = propertyName.indexOf(substringToHighlight);\n              final String first = propertyName.substring(0, begin);\n              append(first, SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n              final TextAttributes textAttributes = TextAttributes.ERASE_MARKER;\n//              textAttributes.setEffectColor(new Color(200, 200, 200));\n              textAttributes.setBackgroundColor(UIUtil.getListSelectionBackground());\n              append(substringToHighlight, SimpleTextAttributes.fromTextAttributes(textAttributes));\n              append(propertyName.substring(first.length() + substringToHighlight.length()), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n            } else {\n              append(propertyName, SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n            }\n\n          }/* else if (value instanceof DPPropertyTypeElement) {\n            append(((DPPropertyTypeElement) value).getPropertyType(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n          }*/\n        }\n      }\n    });\n\n    myTreeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTreeTable.setPreferredScrollableViewportSize(new Dimension(300, myTreeTable.getRowHeight() * 10));\n    myTreeTable.getColumn(myColumnNames[0]).setPreferredWidth(200);\n    myTreeTable.getColumn(myColumnNames[1]).setPreferredWidth(160);\n\n    myTreeTable.addMouseListener(\n        new MouseAdapter() {\n          public void mouseClicked(MouseEvent e) {\n            final Point point = e.getPoint();\n            if (e.getClickCount() == 2 && myTreeTable.columnAtPoint(point) == 1) {\n              myTreeTable.editCellAt(myTreeTable.rowAtPoint(point), myTreeTable.columnAtPoint(point), e);\n            }\n          }\n        }\n    );\n\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myTreeTable);\n\n    scrollpane.setPreferredSize(new Dimension(600, 400));\n    return scrollpane;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DynamicFilterComponent(@NonNls String propertyName, int historySize) {\n      super(propertyName, historySize);\n    }","id":66475,"modified_method":"public DynamicFilterComponent(Project project, @NonNls String propertyName, int historySize) {\n      super(propertyName, historySize);\n      myProject = project;\n    }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void storeState() {\n    if (myTreeTable != null && myTreeTable.getTree() != null) {\n      final Module module = getModule();\n\n      if (module != null) {\n        myState = getState();\n        module.putUserData(DYNAMIC_TOOLWINDOW_STATE_KEY, myState);\n      }\n    }\n  }","id":66476,"modified_method":"private static void storeState(Project project) {\n    if (doesTreeTableInit()) {\n      final Module module = getModule(project);\n\n      if (module != null) {\n        myState = getState();\n        module.putUserData(DYNAMIC_TOOLWINDOW_STATE_KEY, myState);\n      }\n    }\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Module getModule() {\n    //TODO\n    final VirtualFile currentFile = FileEditorManagerEx.getInstanceEx(myProject).getCurrentFile();\n\n    if (currentFile == null) {\n      //TODO\n      final Module[] modules = ModuleManager.getInstance(myProject).getModules();\n      return modules[0];\n    }\n\n    return ProjectRootManager.getInstance(myProject).getFileIndex().getModuleForFile(currentFile);\n  }","id":66477,"modified_method":"private static Module getModule(Project project) {\n    //TODO\n    final VirtualFile currentFile = FileEditorManagerEx.getInstanceEx(project).getCurrentFile();\n\n    if (currentFile == null) {\n      //TODO\n      final Module[] modules = ModuleManager.getInstance(project).getModules();\n      return modules[0];\n    }\n\n    return ProjectRootManager.getInstance(project).getFileIndex().getModuleForFile(currentFile);\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PropertyTypeColumnInfo(String name) {\n      super(name);\n    }","id":66478,"modified_method":"private static JPanel getContentPane(Project project) {\n    if (!doesTreeTableInit()) {\n      buildBigPanel(project);\n    }\n\n    return myBigPanel;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DPPropertyTypeElement valueOf(DefaultMutableTreeNode treeNode) {\n      Object userObject = treeNode.getUserObject();\n\n      if (userObject instanceof DPPropertyElement) return ((DPPropertyElement) userObject).getPropertyTypeElement();\n\n      return null;\n    }","id":66479,"modified_method":"public DPPropertyTypeElement valueOf(DefaultMutableTreeNode treeNode) {\n      Object userObject = treeNode.getUserObject();\n\n      if (userObject instanceof DPPropertyNode)\n        return ((DPPropertyNode) userObject).getElement().getPropertyTypeElement();\n\n      return null;\n    }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ListTreeTableModelOnColumns getTreeTableModel() {\n    return myTreeTableModel;\n  }","id":66480,"modified_method":"private static ListTreeTableModelOnColumns returnTreeTableModel() {\n    return myTreeTableModel;\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n    final Project myProject = myNameIdentifier.getProject();\n    final ToolWindow window = ToolWindowManager.getInstance(myProject).getToolWindow(DynamicToolWindowUtil.DYNAMIC_TOOLWINDOW_ID);\n    DynamicToolWindowWrapper dynamicToolWindowWrapper = new DynamicToolWindowWrapper(myProject, window);\n    dynamicToolWindowWrapper.setupToolWindow(window);\n\n    final ListTreeTableModelOnColumns model = dynamicToolWindowWrapper.getTreeTableModel();\n    final TreeTable treeTable = dynamicToolWindowWrapper.getTreeTable();\n\n    if (model != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          window.activate(new Runnable() {\n            public void run() {\n              Object root = model.getRoot();\n\n              if (root == null || !(root instanceof DefaultMutableTreeNode)) return;\n\n              DefaultMutableTreeNode treeRoot = ((DefaultMutableTreeNode) root);\n\n              final DefaultMutableTreeNode desiredNode = TreeUtil.findNodeWithObject(treeRoot, new DPPopertyNode(new DPPropertyElement(myNameIdentifier.getText())));\n//          int rootNum = treeModel.getIndexOfChild(root, desiredNode);\n              final TreePath path = TreeUtil.getPathFromRoot(desiredNode);\n\n              treeTable.getTree().setSelectionPath(path);\n//          final int rowToSelect = treeTable.getTree().getRowForPath(path);\n\n//          ToolWindowManager.getInstance(myProject).requestFocus(new ActionCallback.Runnable(){\n//            public ActionCallback run() {\n//              window.show(null);\n//              return new ActionCallback.Done();\n//            }\n//          }, true);\n            }\n          }, true);\n        }\n      });\n\n    }\n  }","id":66481,"modified_method":"public void navigate(boolean requestFocus) {\n    final Project myProject = myNameIdentifier.getProject();\n    final ToolWindow window = ToolWindowManager.getInstance(myProject).getToolWindow(DynamicToolWindowWrapper.DYNAMIC_TOOLWINDOW_ID);\n\n    window.activate(new Runnable() {\n      public void run() {\n        final TreeTable treeTable = DynamicToolWindowWrapper.getTreeTable(window, myProject);\n        final ListTreeTableModelOnColumns model = DynamicToolWindowWrapper.getTreeTableModel(window, myProject);\n\n        Object root = model.getRoot();\n\n        if (root == null || !(root instanceof DefaultMutableTreeNode)) return;\n\n        DefaultMutableTreeNode treeRoot = ((DefaultMutableTreeNode) root);\n\n        final DefaultMutableTreeNode desiredNode = TreeUtil.findNodeWithObject(treeRoot, new DPPropertyNode(new DPPropertyElement(myNameIdentifier.getText())));\n        final TreePath path = TreeUtil.getPathFromRoot(desiredNode);\n\n        treeTable.getTree().expandPath(path);\n        treeTable.getTree().setSelectionPath(path);\n        treeTable.getTree().fireTreeExpanded(path);\n\n        treeTable.getTree().requestFocus();\n        treeTable.revalidate();\n        treeTable.repaint();\n      }\n    }, true);\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void loadGroovy() {\n    ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            FileTypeManager.getInstance().registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GROOVY_EXTENSIONS.toArray(new String[GROOVY_EXTENSIONS.size()]));\n          }\n        }\n    );\n\n    //Register factory for special Groovy elements\n    Factory.addElementFactory(new GspElementFactory());\n\n    //register editor actions\n    GroovyEditorActionsManager.registerGroovyEditorActions();\n\n    CompletionUtil.registerCompletionData(GroovyFileType.GROOVY_FILE_TYPE, new GroovyCompletionData());\n\n    SelectWordUtil.registerSelectioner(new GroovyLiteralSelectioner());\n\n    MethodReferencesSearch.INSTANCE.registerExecutor(new AccessorReferencesSearcher());\n    MethodReferencesSearch.INSTANCE.registerExecutor(new MethodLateBoundReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new ConstructorReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new PropertyReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new TypeAliasReferenceSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new LateBoundReferencesSearcher());\n\n    TypedHandler.registerQuoteHandler(GroovyFileType.GROOVY_FILE_TYPE, new GroovyQuoteHandler());\n\n    ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n      public void projectOpened(final Project project) {\n        TextEditorHighlightingPassRegistrar registrar = TextEditorHighlightingPassRegistrar.getInstance(project);\n        GroovyUnusedImportsPassFactory unusedImportsPassFactory = project.getComponent(GroovyUnusedImportsPassFactory.class);\n        registrar.registerTextEditorHighlightingPass(unusedImportsPassFactory, new int[]{Pass.UPDATE_ALL}, null, true, -1);\n\n        WolfTheProblemSolver.getInstance(project).registerFileHighlightFilter(new Condition<VirtualFile>() {\n          public boolean value(VirtualFile virtualFile) {\n            return FileTypeManager.getInstance().getFileTypeByFile(virtualFile) == GroovyFileType.GROOVY_FILE_TYPE;\n          }\n        }, project);\n\n        CompilerManager compilerManager = CompilerManager.getInstance(project);\n        GroovyToJavaGenerator generator = new GroovyToJavaGenerator(project);\n        compilerManager.addCompiler(generator);\n        compilerManager.addCompilationStatusListener(generator);\n\n        compilerManager.addCompiler(new GroovyCompiler(project));\n        compilerManager.addCompilableFileType(GroovyFileType.GROOVY_FILE_TYPE);\n\n        DebuggerManager.getInstance(project).registerPositionManagerFactory(new Function<DebugProcess, PositionManager>() {\n          public PositionManager fun(DebugProcess debugProcess) {\n            return new GroovyPositionManager(debugProcess);\n          }\n        });\n\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrLiteral.class, new PropertiesReferenceProvider());\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrReferenceExpression.class, new DynamicPropertiesReferenceProvider());\n\n        StartupManager.getInstance(project).registerPostStartupActivity(new Runnable() {\n          public void run() {\n            final ToolWindow dynamicToolWindow = ToolWindowManager.getInstance(project).registerToolWindow(DynamicToolWindowUtil.DYNAMIC_TOOLWINDOW_ID, true, ToolWindowAnchor.RIGHT);\n            dynamicToolWindow.setIcon(IconLoader.getIcon(\"/org/jetbrains/plugins/groovy/images/dynamicProperty.png\"));\n\n            DynamicToolWindowUtil.setUpDynamicToolWindow(project, dynamicToolWindow);\n          }\n        });\n\n      }\n    });\n  }","id":66482,"modified_method":"private static void loadGroovy() {\n    ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            FileTypeManager.getInstance().registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GROOVY_EXTENSIONS.toArray(new String[GROOVY_EXTENSIONS.size()]));\n          }\n        }\n    );\n\n    //Register factory for special Groovy elements\n    Factory.addElementFactory(new GspElementFactory());\n\n    //register editor actions\n    GroovyEditorActionsManager.registerGroovyEditorActions();\n\n    CompletionUtil.registerCompletionData(GroovyFileType.GROOVY_FILE_TYPE, new GroovyCompletionData());\n\n    SelectWordUtil.registerSelectioner(new GroovyLiteralSelectioner());\n\n    MethodReferencesSearch.INSTANCE.registerExecutor(new AccessorReferencesSearcher());\n    MethodReferencesSearch.INSTANCE.registerExecutor(new MethodLateBoundReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new ConstructorReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new PropertyReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new TypeAliasReferenceSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new LateBoundReferencesSearcher());\n\n    TypedHandler.registerQuoteHandler(GroovyFileType.GROOVY_FILE_TYPE, new GroovyQuoteHandler());\n\n    ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n      public void projectOpened(final Project project) {\n        TextEditorHighlightingPassRegistrar registrar = TextEditorHighlightingPassRegistrar.getInstance(project);\n        GroovyUnusedImportsPassFactory unusedImportsPassFactory = project.getComponent(GroovyUnusedImportsPassFactory.class);\n        registrar.registerTextEditorHighlightingPass(unusedImportsPassFactory, new int[]{Pass.UPDATE_ALL}, null, true, -1);\n\n        WolfTheProblemSolver.getInstance(project).registerFileHighlightFilter(new Condition<VirtualFile>() {\n          public boolean value(VirtualFile virtualFile) {\n            return FileTypeManager.getInstance().getFileTypeByFile(virtualFile) == GroovyFileType.GROOVY_FILE_TYPE;\n          }\n        }, project);\n\n        CompilerManager compilerManager = CompilerManager.getInstance(project);\n        GroovyToJavaGenerator generator = new GroovyToJavaGenerator(project);\n        compilerManager.addCompiler(generator);\n        compilerManager.addCompilationStatusListener(generator);\n\n        compilerManager.addCompiler(new GroovyCompiler(project));\n        compilerManager.addCompilableFileType(GroovyFileType.GROOVY_FILE_TYPE);\n\n        DebuggerManager.getInstance(project).registerPositionManagerFactory(new Function<DebugProcess, PositionManager>() {\n          public PositionManager fun(DebugProcess debugProcess) {\n            return new GroovyPositionManager(debugProcess);\n          }\n        });\n\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrLiteral.class, new PropertiesReferenceProvider());\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrReferenceExpression.class, new DynamicPropertiesReferenceProvider());\n\n        StartupManager.getInstance(project).registerPostStartupActivity(new Runnable() {\n          public void run() {\n            final ToolWindow dynamicToolWindow = ToolWindowManager.getInstance(project).registerToolWindow(DynamicToolWindowWrapper.DYNAMIC_TOOLWINDOW_ID, true, ToolWindowAnchor.RIGHT);\n            dynamicToolWindow.setIcon(IconLoader.getIcon(\"/org/jetbrains/plugins/groovy/images/dynamicProperty.png\"));\n\n            DynamicToolWindowWrapper.configureWindow(project, dynamicToolWindow);\n          }\n        });\n\n      }\n    });\n  }","commit_id":"3aacba7e2b0bd66f59790077db3a2dd635e3b0ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StatisticsInfo serialize(final LookupElement element, final CompletionLocation location) {\n    final Object o = element.getObject();\n    PsiType qualifierType = JavaCompletionUtil.getQualifierType((LookupItem) element);\n    if (qualifierType == null) {\n      final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n      if (infos != null && infos.length > 0) {\n        qualifierType = infos[0].getDefaultType();\n      }\n    }\n\n    final CompletionType type = location.getCompletionType();\n    if (o instanceof PsiMember) {\n      final boolean isClass = o instanceof PsiClass;\n      if (qualifierType != null) {\n        if (isClass && type == CompletionType.SMART) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        if (!isClass && type == CompletionType.BASIC) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        return StatisticsInfo.EMPTY;\n      }\n\n      if (type == CompletionType.CLASS_NAME && isClass) {\n        final String qualifiedName = ((PsiClass)o).getQualifiedName();\n        if (qualifiedName != null) {\n          return new StatisticsInfo(\"classNameCompletion#\" + location.getCompletionParameters().getOriginalFile().getLanguage(), qualifiedName);\n        }\n      }\n    }\n\n    if (qualifierType != null) return StatisticsInfo.EMPTY;\n\n    return null;\n  }","id":66483,"modified_method":"public StatisticsInfo serialize(final LookupElement element, final CompletionLocation location) {\n    final Object o = element.getObject();\n    PsiType qualifierType = JavaCompletionUtil.getQualifierType((LookupItem) element);\n    if (qualifierType == null) {\n      final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n      if (infos != null && infos.length > 0) {\n        qualifierType = infos[0].getDefaultType();\n      }\n    }\n\n    final CompletionType type = location.getCompletionType();\n    if (o instanceof PsiMember) {\n      final boolean isClass = o instanceof PsiClass;\n      if (qualifierType != null) {\n        if (isClass && type == CompletionType.SMART) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        if (!isClass && type == CompletionType.BASIC) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        return StatisticsInfo.EMPTY;\n      }\n\n      if (type == CompletionType.CLASS_NAME && isClass) {\n        final String qualifiedName = ((PsiClass)o).getQualifiedName();\n        if (qualifiedName != null) {\n          return new StatisticsInfo(\"classNameCompletion#\" + PrefixMatchingWeigher.PREFIX_CAPITALS.getValue(location), qualifiedName);\n        }\n      }\n    }\n\n    if (qualifierType != null) return StatisticsInfo.EMPTY;\n\n    return null;\n  }","commit_id":"d3cee43d97ff4f9e582461a56719fed3280ee61b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Comparable weigh(@NotNull final LookupElement<?> item, final CompletionLocation location) {\n    final Object object = item.getObject();\n    final ExpectedTypeInfo[] expectedInfos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    if (expectedInfos == null) return 0;\n\n    final PsiType itemType = JavaCompletionUtil.getPsiType(object);\n    if (itemType == null) return 0;\n\n    if (object instanceof PsiClass) {\n      for (final ExpectedTypeInfo info : expectedInfos) {\n        if (info.getType().getDeepComponentType().equals(itemType)) {\n          return SkipAbstractExpectedTypeWeigher.getSkippingStatus(item, location) != SkipAbstractExpectedTypeWeigher.Result.ACCEPT ? 2 : 1;\n        }\n      }\n    }\n\n    return 0;\n  }","id":66484,"modified_method":"public Comparable weigh(@NotNull final LookupElement<?> item, final CompletionLocation location) {\n    final Object object = item.getObject();\n    final ExpectedTypeInfo[] expectedInfos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    if (expectedInfos == null) return 0;\n\n    final PsiType itemType = JavaCompletionUtil.getPsiType(object);\n    if (itemType == null) return 0;\n\n    if (object instanceof PsiClass) {\n      for (final ExpectedTypeInfo info : expectedInfos) {\n        if (TypeConversionUtil.erasure(info.getType().getDeepComponentType()).equals(TypeConversionUtil.erasure(itemType))) {\n          return SkipAbstractExpectedTypeWeigher.getSkippingStatus(item, location) != SkipAbstractExpectedTypeWeigher.Result.ACCEPT ? 2 : 1;\n        }\n      }\n    }\n\n    return 0;\n  }","commit_id":"d3cee43d97ff4f9e582461a56719fed3280ee61b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Result getSkippingStatus(final LookupElement<?> item, final CompletionLocation location) {\n    if (location.getCompletionType() != CompletionType.SMART) return Result.ACCEPT;\n\n    final Object object = item.getObject();\n    if (!(object instanceof PsiClass)) return Result.ACCEPT;\n\n    PsiClass psiClass = (PsiClass)object;\n\n    int toImplement = OverrideImplementUtil.getMethodSignaturesToImplement(psiClass).size();\n    if (toImplement > 2) return Result.ABSTRACT;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        toImplement++;\n        if (toImplement > 2) return Result.ABSTRACT;\n      }\n    }\n\n    final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    boolean isDefaultType = false;\n    if (infos != null) {\n      final PsiType type = JavaPsiFacade.getInstance(psiClass.getProject()).getElementFactory().createType(psiClass);\n      for (final ExpectedTypeInfo info : infos) {\n        final PsiType infoType = info.getType().getDeepComponentType();\n        final PsiType defaultType = info.getDefaultType().getDeepComponentType();\n        //todo raw\n        if (!defaultType.equals(infoType) && infoType.isAssignableFrom(type)) {\n          if (!defaultType.isAssignableFrom(type)) return Result.NON_DEFAULT;\n          isDefaultType = true;\n        }\n      }\n    }\n\n    if (toImplement > 0) return Result.ACCEPT;\n\n    if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) return Result.ABSTRACT;\n    if (!isDefaultType && CommonClassNames.JAVA_LANG_STRING.equals(psiClass.getQualifiedName())) return Result.STRING;\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(psiClass.getQualifiedName())) return Result.NON_DEFAULT;\n\n    return Result.ACCEPT;\n  }","id":66485,"modified_method":"public static Result getSkippingStatus(final LookupElement<?> item, final CompletionLocation location) {\n    if (location.getCompletionType() != CompletionType.SMART) return Result.ACCEPT;\n\n    final Object object = item.getObject();\n    if (!(object instanceof PsiClass)) return Result.ACCEPT;\n\n    if (StatisticsManager.getInstance().getUseCount(CompletionRegistrar.STATISTICS_KEY, item, location) > 1) return Result.ACCEPT;\n\n    PsiClass psiClass = (PsiClass)object;\n\n    int toImplement = OverrideImplementUtil.getMethodSignaturesToImplement(psiClass).size();\n    if (toImplement > 2) return Result.ABSTRACT;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        toImplement++;\n        if (toImplement > 2) return Result.ABSTRACT;\n      }\n    }\n\n    final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    boolean isDefaultType = false;\n    if (infos != null) {\n      final PsiType type = JavaPsiFacade.getInstance(psiClass.getProject()).getElementFactory().createType(psiClass);\n      for (final ExpectedTypeInfo info : infos) {\n        final PsiType infoType = info.getType().getDeepComponentType();\n        final PsiType defaultType = info.getDefaultType().getDeepComponentType();\n        //todo raw\n        if (!defaultType.equals(infoType) && infoType.isAssignableFrom(type)) {\n          if (!defaultType.isAssignableFrom(type)) return Result.NON_DEFAULT;\n          isDefaultType = true;\n        }\n      }\n    }\n\n    if (toImplement > 0) return Result.ACCEPT;\n\n    if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) return Result.ABSTRACT;\n    if (!isDefaultType && CommonClassNames.JAVA_LANG_STRING.equals(psiClass.getQualifiedName())) return Result.STRING;\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(psiClass.getQualifiedName())) return Result.NON_DEFAULT;\n\n    return Result.ACCEPT;\n  }","commit_id":"d3cee43d97ff4f9e582461a56719fed3280ee61b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Result getSkippingStatus(final LookupElement<?> item, final CompletionLocation location) {\n    if (location.getCompletionType() != CompletionType.SMART) return Result.ACCEPT;\n\n    final Object object = item.getObject();\n    if (!(object instanceof PsiClass)) return Result.ACCEPT;\n\n    if (StatisticsManager.getInstance().getUseCount(CompletionRegistrar.STATISTICS_KEY, item, location) > 1) return Result.ACCEPT;\n\n    PsiClass psiClass = (PsiClass)object;\n\n    int toImplement = OverrideImplementUtil.getMethodSignaturesToImplement(psiClass).size();\n    if (toImplement > 2) return Result.ABSTRACT;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        toImplement++;\n        if (toImplement > 2) return Result.ABSTRACT;\n      }\n    }\n\n    final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    boolean isDefaultType = false;\n    if (infos != null) {\n      final PsiType type = JavaPsiFacade.getInstance(psiClass.getProject()).getElementFactory().createType(psiClass);\n      for (final ExpectedTypeInfo info : infos) {\n        final PsiType infoType = info.getType().getDeepComponentType();\n        final PsiType defaultType = info.getDefaultType().getDeepComponentType();\n        //todo raw\n        if (!defaultType.equals(infoType) && infoType.isAssignableFrom(type)) {\n          if (!defaultType.isAssignableFrom(type)) return Result.NON_DEFAULT;\n          isDefaultType = true;\n        }\n      }\n    }\n\n    if (toImplement > 0) return Result.ACCEPT;\n\n    if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) return Result.ABSTRACT;\n    if (!isDefaultType && CommonClassNames.JAVA_LANG_STRING.equals(psiClass.getQualifiedName())) return Result.STRING;\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(psiClass.getQualifiedName())) return Result.NON_DEFAULT;\n\n    return Result.ACCEPT;\n  }","id":66486,"modified_method":"public static Result getSkippingStatus(final LookupElement<?> item, final CompletionLocation location) {\n    if (location.getCompletionType() != CompletionType.SMART) return Result.ACCEPT;\n\n    final Object object = item.getObject();\n    if (!(object instanceof PsiClass)) return Result.ACCEPT;\n\n    if (StatisticsManager.getInstance().getUseCount(CompletionRegistrar.STATISTICS_KEY, item, location) > 1) return Result.ACCEPT;\n\n    PsiClass psiClass = (PsiClass)object;\n\n    int toImplement = OverrideImplementUtil.getMethodSignaturesToImplement(psiClass).size();\n    if (toImplement > 2) return Result.ABSTRACT;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        toImplement++;\n        if (toImplement > 2) return Result.ABSTRACT;\n      }\n    }\n\n    final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n    boolean isDefaultType = false;\n    if (infos != null) {\n      final PsiType type = JavaPsiFacade.getInstance(psiClass.getProject()).getElementFactory().createType(psiClass);\n      for (final ExpectedTypeInfo info : infos) {\n        final PsiType infoType = TypeConversionUtil.erasure(info.getType().getDeepComponentType());\n        final PsiType defaultType = TypeConversionUtil.erasure(info.getDefaultType().getDeepComponentType());\n        if (!defaultType.equals(infoType) && infoType.isAssignableFrom(type)) {\n          if (!defaultType.isAssignableFrom(type)) return Result.NON_DEFAULT;\n          isDefaultType = true;\n        }\n      }\n    }\n\n    if (toImplement > 0) return Result.ACCEPT;\n\n    if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) return Result.ABSTRACT;\n    if (!isDefaultType && CommonClassNames.JAVA_LANG_STRING.equals(psiClass.getQualifiedName())) return Result.STRING;\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(psiClass.getQualifiedName())) return Result.NON_DEFAULT;\n\n    return Result.ACCEPT;\n  }","commit_id":"3b7ea1f915c59ae74400358ea04a8933607eecbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n\tpublic void cone(float width, float height, float depth, int divisions, float angleFrom, float angleTo) {\r\n\t\t// FIXME create better cylinder method (- axis on which to create the cone (matrix?))\r\n\t\tensureTriangles(divisions + 2, divisions);\r\n\t\t\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal float us = 1f / divisions;\r\n\t\tfloat u = 0f;\r\n\t\tfloat angle = 0f;\t\t\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\tVertexInfo curr2 = vertTmp4.set(null, null, null, null).setPos(0,hh,0).setNor(0,1,0).setUV(0.5f, 0);\r\n\t\tfinal int base = vertex(curr2);\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tu = 1f - us * i;\r\n\t\t\tcurr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);\r\n\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\tcurr1.position.y = -hh;\r\n\t\t\tcurr1.uv.set(u, 1);\r\n\t\t\tvertex(curr1);\r\n\t\t\tif (i == 0)\r\n\t\t\t\tcontinue;\r\n\t\t\ttriangle((short)base, (short)(vindex-1), (short)(vindex-2)); // FIXME don't duplicate lines and points\r\n\t\t}\r\n\t\tellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f-angleTo, 180f-angleFrom);\r\n\t}","id":66487,"modified_method":"@Override\r\n\tpublic void cone(float width, float height, float depth, int divisions, float angleFrom, float angleTo) {\r\n\t\t// FIXME create better cylinder method (- axis on which to create the cone (matrix?))\r\n\t\tensureTriangles(divisions + 2, divisions);\r\n\t\t\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal float us = 1f / divisions;\r\n\t\tfloat u = 0f;\r\n\t\tfloat angle = 0f;\t\t\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\tVertexInfo curr2 = vertTmp4.set(null, null, null, null).setPos(0,hh,0).setNor(0,1,0).setUV(0.5f, 0);\r\n\t\tfinal short base = vertex(curr2);\r\n\t\tshort i1, i2 = 0;\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tu = 1f - us * i;\r\n\t\t\tcurr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);\r\n\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\tcurr1.position.y = -hh;\r\n\t\t\tcurr1.uv.set(u, 1);\r\n\t\t\ti1 = vertex(curr1);\r\n\t\t\tif (i != 0)\r\n\t\t\t\ttriangle(base, i1, i2); // FIXME don't duplicate lines and points\r\n\t\t\ti2 = i1;\r\n\t\t}\r\n\t\tellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f-angleTo, 180f-angleFrom);\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void ellipse(float width, float height, float innerWidth, float innerHeight, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ, float angleFrom, float angleTo) {\r\n\t\tif(innerWidth <= 0 || innerHeight <= 0)\t{\t\t\t\t\t\r\n\t\t\tensureTriangles(divisions + 2, divisions);\r\n\t\t}\r\n\t\telse if (innerWidth == width && innerHeight == height){\r\n\t\t\tensureVertices(divisions + 1);\r\n\t\t\tensureIndices(divisions + 1);\r\n\t\t\tif(primitiveType != GL10.GL_LINES)\r\n\t\t\t\tthrow new GdxRuntimeException(\"Incorrect primitive type : expect GL_LINES because innerWidth == width && innerHeight == height\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\tensureRectangles((divisions + 1)*2, divisions + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal Vector3 sxEx = tempV1.set(tangentX, tangentY, tangentZ).scl(width * 0.5f);\r\n\t\tfinal Vector3 syEx = tempV2.set(binormalX, binormalY, binormalZ).scl(height * 0.5f);\r\n\t\tfinal Vector3 sxIn = tempV3.set(tangentX, tangentY, tangentZ).scl(innerWidth * 0.5f);\r\n\t\tfinal Vector3 syIn = tempV4.set(binormalX, binormalY, binormalZ).scl(innerHeight * 0.5f);\r\n\t\tVertexInfo currIn = vertTmp3.set(null, null, null, null);\r\n\t\tcurrIn.hasUV = currIn.hasPosition = currIn.hasNormal = true;\r\n\t\tcurrIn.uv.set(.5f, .5f);\r\n\t\tcurrIn.position.set(centerX, centerY, centerZ);\r\n\t\tcurrIn.normal.set(normalX, normalY, normalZ);\t\r\n\t\tVertexInfo currEx = vertTmp4.set(null, null, null, null);\r\n\t\tcurrEx.hasUV = currEx.hasPosition = currEx.hasNormal = true;\r\n\t\tcurrEx.uv.set(.5f, .5f);\r\n\t\tcurrEx.position.set(centerX, centerY, centerZ);\r\n\t\tcurrEx.normal.set(normalX, normalY, normalZ);\r\n\t\tfinal short center = vertex(currEx);\r\n\t\tfloat angle = 0f;\r\n\t\tfinal float us = 0.5f * (innerWidth / width);\r\n\t\tfinal float vs = 0.5f * (innerHeight / height);\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tfinal float x = MathUtils.cos(angle);\r\n\t\t\tfinal float y = MathUtils.sin(angle);\r\n\t\t\tcurrEx.position.set(centerX, centerY, centerZ).add(sxEx.x*x+syEx.x*y, sxEx.y*x+syEx.y*y, sxEx.z*x+syEx.z*y);\r\n\t\t\tcurrEx.uv.set(.5f + .5f * x, .5f + .5f * y);\t\t\t\t\r\n\t\t\tvertex(currEx);\r\n\t\t\t\r\n\t\t\tif(innerWidth <= 0f || innerHeight <= 0f)\t{\t\t\t\t\t\r\n\t\t\t\tif (i != 0)\r\n\t\t\t\t\ttriangle((short)(vindex - 1), (short)(vindex - 2), center);\r\n\t\t\t}\r\n\t\t\telse if (innerWidth == width && innerHeight == height){\r\n\t\t\t\tif (i != 0)\r\n\t\t\t\t\tline((short)(vindex - 1), (short)(vindex - 2));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcurrIn.position.set(centerX, centerY, centerZ).add(sxIn.x*x+syIn.x*y, sxIn.y*x+syIn.y*y, sxIn.z*x+syIn.z*y);\r\n\t\t\t\tcurrIn.uv.set(.5f + us * x, .5f + vs * y);\t\t\t\t\r\n\t\t\t\tvertex(currIn);\r\n\t\t\t\t\r\n\t\t\t\tif( i != 0)\r\n\t\t\t\t\trect((short)(vindex - 1), (short)(vindex - 2),(short)(vindex - 4), (short)(vindex - 3));\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":66488,"modified_method":"@Override\r\n\tpublic void ellipse(float width, float height, float innerWidth, float innerHeight, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ, float angleFrom, float angleTo) {\r\n\t\tif(innerWidth <= 0 || innerHeight <= 0)\t{\t\t\t\t\t\r\n\t\t\tensureTriangles(divisions + 2, divisions);\r\n\t\t}\r\n\t\telse if (innerWidth == width && innerHeight == height){\r\n\t\t\tensureVertices(divisions + 1);\r\n\t\t\tensureIndices(divisions + 1);\r\n\t\t\tif(primitiveType != GL10.GL_LINES)\r\n\t\t\t\tthrow new GdxRuntimeException(\"Incorrect primitive type : expect GL_LINES because innerWidth == width && innerHeight == height\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\tensureRectangles((divisions + 1)*2, divisions + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal Vector3 sxEx = tempV1.set(tangentX, tangentY, tangentZ).scl(width * 0.5f);\r\n\t\tfinal Vector3 syEx = tempV2.set(binormalX, binormalY, binormalZ).scl(height * 0.5f);\r\n\t\tfinal Vector3 sxIn = tempV3.set(tangentX, tangentY, tangentZ).scl(innerWidth * 0.5f);\r\n\t\tfinal Vector3 syIn = tempV4.set(binormalX, binormalY, binormalZ).scl(innerHeight * 0.5f);\r\n\t\tVertexInfo currIn = vertTmp3.set(null, null, null, null);\r\n\t\tcurrIn.hasUV = currIn.hasPosition = currIn.hasNormal = true;\r\n\t\tcurrIn.uv.set(.5f, .5f);\r\n\t\tcurrIn.position.set(centerX, centerY, centerZ);\r\n\t\tcurrIn.normal.set(normalX, normalY, normalZ);\t\r\n\t\tVertexInfo currEx = vertTmp4.set(null, null, null, null);\r\n\t\tcurrEx.hasUV = currEx.hasPosition = currEx.hasNormal = true;\r\n\t\tcurrEx.uv.set(.5f, .5f);\r\n\t\tcurrEx.position.set(centerX, centerY, centerZ);\r\n\t\tcurrEx.normal.set(normalX, normalY, normalZ);\r\n\t\tfinal short center = vertex(currEx);\r\n\t\tfloat angle = 0f;\r\n\t\tfinal float us = 0.5f * (innerWidth / width);\r\n\t\tfinal float vs = 0.5f * (innerHeight / height);\r\n\t\tshort i1, i2 = 0, i3 = 0, i4 = 0;\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tfinal float x = MathUtils.cos(angle);\r\n\t\t\tfinal float y = MathUtils.sin(angle);\r\n\t\t\tcurrEx.position.set(centerX, centerY, centerZ).add(sxEx.x*x+syEx.x*y, sxEx.y*x+syEx.y*y, sxEx.z*x+syEx.z*y);\r\n\t\t\tcurrEx.uv.set(.5f + .5f * x, .5f + .5f * y);\t\t\t\t\r\n\t\t\ti1 = vertex(currEx);\r\n\t\t\t\r\n\t\t\tif(innerWidth <= 0f || innerHeight <= 0f)\t{\t\t\t\t\t\r\n\t\t\t\tif (i != 0)\r\n\t\t\t\t\ttriangle(i1, i2, center);\r\n\t\t\t\ti2 = i1;\r\n\t\t\t}\r\n\t\t\telse if (innerWidth == width && innerHeight == height){\r\n\t\t\t\tif (i != 0)\r\n\t\t\t\t\tline(i1, i2);\r\n\t\t\t\ti2 = i1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcurrIn.position.set(centerX, centerY, centerZ).add(sxIn.x*x+syIn.x*y, sxIn.y*x+syIn.y*y, sxIn.z*x+syIn.z*y);\r\n\t\t\t\tcurrIn.uv.set(.5f + us * x, .5f + vs * y);\r\n\t\t\t\ti2 = i1;\r\n\t\t\t\ti1 = vertex(currIn);\r\n\t\t\t\t\r\n\t\t\t\tif( i != 0)\r\n\t\t\t\t\trect(i1, i2, i4, i3);\r\n\t\t\t\ti4 = i2;\r\n\t\t\t\ti3 = i1;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic short lastIndex() {\r\n\t\treturn (short)(vindex-1);\r\n\t}","id":66489,"modified_method":"@Override\r\n\tpublic short lastIndex() {\r\n\t\treturn lastIndex;\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Add a cylinder */\r\n\tpublic void cylinder(float width, float height, float depth, int divisions, float angleFrom, float angleTo, boolean close) {\r\n\t\t// FIXME create better cylinder method (- axis on which to create the cylinder (matrix?))\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal float us = 1f / divisions;\r\n\t\tfloat u = 0f;\r\n\t\tfloat angle = 0f;\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\tVertexInfo curr2 = vertTmp4.set(null, null, null, null);\r\n\t\tcurr2.hasUV = curr2.hasPosition = curr2.hasNormal = true;\r\n\t\t\r\n\t\tensureRectangles(2 * (divisions + 1), divisions);\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tu = 1f - us * i;\r\n\t\t\tcurr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);\r\n\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\tcurr1.position.y = -hh;\r\n\t\t\tcurr1.uv.set(u, 1);\r\n\t\t\tcurr2.position.set(curr1.position);\r\n\t\t\tcurr2.normal.set(curr1.normal);\r\n\t\t\tcurr2.position.y = hh;\r\n\t\t\tcurr2.uv.set(u, 0);\r\n\t\t\tvertex(curr1);\r\n\t\t\tvertex(curr2);\r\n\t\t\tif (i != 0)\r\n\t\t\t\trect((short)(vindex-3), (short)(vindex-1), (short)(vindex-2), (short)(vindex-4)); // FIXME don't duplicate lines and points\r\n\t\t}\r\n\t\tif (close) {\r\n\t\t\tellipse(width, depth, 0, 0, divisions, 0, hh, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, angleFrom, angleTo);\r\n\t\t\tellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f-angleTo, 180f-angleFrom);\r\n\t\t}\r\n\t}","id":66490,"modified_method":"/** Add a cylinder */\r\n\tpublic void cylinder(float width, float height, float depth, int divisions, float angleFrom, float angleTo, boolean close) {\r\n\t\t// FIXME create better cylinder method (- axis on which to create the cylinder (matrix?))\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float ao = MathUtils.degreesToRadians * angleFrom;\r\n\t\tfinal float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;\r\n\t\tfinal float us = 1f / divisions;\r\n\t\tfloat u = 0f;\r\n\t\tfloat angle = 0f;\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\tVertexInfo curr2 = vertTmp4.set(null, null, null, null);\r\n\t\tcurr2.hasUV = curr2.hasPosition = curr2.hasNormal = true;\r\n\t\tshort i1, i2, i3 = 0, i4 = 0;\r\n\t\t\r\n\t\tensureRectangles(2 * (divisions + 1), divisions);\r\n\t\tfor (int i = 0; i <= divisions; i++) {\r\n\t\t\tangle = ao + step * i;\r\n\t\t\tu = 1f - us * i;\r\n\t\t\tcurr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);\r\n\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\tcurr1.position.y = -hh;\r\n\t\t\tcurr1.uv.set(u, 1);\r\n\t\t\tcurr2.position.set(curr1.position);\r\n\t\t\tcurr2.normal.set(curr1.normal);\r\n\t\t\tcurr2.position.y = hh;\r\n\t\t\tcurr2.uv.set(u, 0);\r\n\t\t\ti2 = vertex(curr1);\r\n\t\t\ti1 = vertex(curr2);\r\n\t\t\tif (i != 0)\r\n\t\t\t\trect(i3, i1, i2, i4); // FIXME don't duplicate lines and points\r\n\t\t\ti4 = i2;\r\n\t\t\ti3 = i1;\r\n\t\t}\r\n\t\tif (close) {\r\n\t\t\tellipse(width, depth, 0, 0, divisions, 0, hh, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, angleFrom, angleTo);\r\n\t\t\tellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f-angleTo, 180f-angleFrom);\r\n\t\t}\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic short vertex(Vector3 pos, Vector3 nor, Color col, Vector2 uv) {\r\n\t\tif (vindex >= Short.MAX_VALUE)\r\n\t\t\tthrow new GdxRuntimeException(\"Too many vertices used\");\r\n\t\tif (col == null && colorSet)\r\n\t\t\tcol = color;\r\n\t\tif (pos != null) {\r\n\t\t\tif(vertexTransformationEnabled) {\r\n\t\t\t\ttempVTransformed.set(pos).mul(positionTransform);\r\n\t\t\t\tvertex[posOffset  ] = tempVTransformed.x;\r\n\t\t\t\tif (posSize > 1) vertex[posOffset+1] = tempVTransformed.y;\r\n\t\t\t\tif (posSize > 2) vertex[posOffset+2] = tempVTransformed.z;\r\n\t\t\t} else {\r\n\t\t\t\tvertex[posOffset  ] = pos.x;\r\n\t\t\t\tif (posSize > 1) vertex[posOffset+1] = pos.y;\r\n\t\t\t\tif (posSize > 2) vertex[posOffset+2] = pos.z;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (nor != null && norOffset >= 0) {\r\n\t\t\tif(vertexTransformationEnabled) {\r\n\t\t\t\ttempVTransformed.set(nor).mul(normalTransform).nor();\r\n\t\t\t\tvertex[norOffset  ] = tempVTransformed.x;\r\n\t\t\t\tvertex[norOffset+1] = tempVTransformed.y;\r\n\t\t\t\tvertex[norOffset+2] = tempVTransformed.z;\r\n\t\t\t} else {\r\n\t\t\t\tvertex[norOffset  ] = nor.x;\r\n\t\t\t\tvertex[norOffset+1] = nor.y;\r\n\t\t\t\tvertex[norOffset+2] = nor.z;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (col != null) {\r\n\t\t\tif (colOffset >= 0) {\r\n\t\t\t\tvertex[colOffset  ] = col.r;\r\n\t\t\t\tvertex[colOffset+1] = col.g;\r\n\t\t\t\tvertex[colOffset+2] = col.b;\r\n\t\t\t\tif (colSize > 3) vertex[colOffset+3] = col.a;\r\n\t\t\t} else if (cpOffset > 0)\r\n\t\t\t\tvertex[cpOffset] = col.toFloatBits(); // FIXME cache packed color?\r\n\t\t}\r\n\t\tif (uv != null && uvOffset >= 0) {\r\n\t\t\tvertex[uvOffset  ] = uv.x;\r\n\t\t\tvertex[uvOffset+1] = uv.y;\r\n\t\t}\r\n\t\tvertices.addAll(vertex);\r\n\t\treturn (short)(vindex++);\r\n\t}","id":66491,"modified_method":"@Override\r\n\tpublic short vertex(Vector3 pos, Vector3 nor, Color col, Vector2 uv) {\r\n\t\tif (vindex >= Short.MAX_VALUE)\r\n\t\t\tthrow new GdxRuntimeException(\"Too many vertices used\");\r\n\t\tif (col == null && colorSet)\r\n\t\t\tcol = color;\r\n\t\tif (pos != null) {\r\n\t\t\tif(vertexTransformationEnabled) {\r\n\t\t\t\ttempVTransformed.set(pos).mul(positionTransform);\r\n\t\t\t\tvertex[posOffset  ] = tempVTransformed.x;\r\n\t\t\t\tif (posSize > 1) vertex[posOffset+1] = tempVTransformed.y;\r\n\t\t\t\tif (posSize > 2) vertex[posOffset+2] = tempVTransformed.z;\r\n\t\t\t} else {\r\n\t\t\t\tvertex[posOffset  ] = pos.x;\r\n\t\t\t\tif (posSize > 1) vertex[posOffset+1] = pos.y;\r\n\t\t\t\tif (posSize > 2) vertex[posOffset+2] = pos.z;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (nor != null && norOffset >= 0) {\r\n\t\t\tif(vertexTransformationEnabled) {\r\n\t\t\t\ttempVTransformed.set(nor).mul(normalTransform).nor();\r\n\t\t\t\tvertex[norOffset  ] = tempVTransformed.x;\r\n\t\t\t\tvertex[norOffset+1] = tempVTransformed.y;\r\n\t\t\t\tvertex[norOffset+2] = tempVTransformed.z;\r\n\t\t\t} else {\r\n\t\t\t\tvertex[norOffset  ] = nor.x;\r\n\t\t\t\tvertex[norOffset+1] = nor.y;\r\n\t\t\t\tvertex[norOffset+2] = nor.z;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (col != null) {\r\n\t\t\tif (colOffset >= 0) {\r\n\t\t\t\tvertex[colOffset  ] = col.r;\r\n\t\t\t\tvertex[colOffset+1] = col.g;\r\n\t\t\t\tvertex[colOffset+2] = col.b;\r\n\t\t\t\tif (colSize > 3) vertex[colOffset+3] = col.a;\r\n\t\t\t} else if (cpOffset > 0)\r\n\t\t\t\tvertex[cpOffset] = col.toFloatBits(); // FIXME cache packed color?\r\n\t\t}\r\n\t\tif (uv != null && uvOffset >= 0) {\r\n\t\t\tvertex[uvOffset  ] = uv.x;\r\n\t\t\tvertex[uvOffset+1] = uv.y;\r\n\t\t}\r\n\t\taddVertex(vertex, 0);\r\n\t\treturn lastIndex;\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void sphere(final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV, float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {\r\n\t\t// FIXME create better sphere method (- only one vertex for each pole, - position)\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float auo = MathUtils.degreesToRadians * angleUFrom;\r\n\t\tfinal float stepU = (MathUtils.degreesToRadians * (angleUTo - angleUFrom)) / divisionsU;\r\n\t\tfinal float avo = MathUtils.degreesToRadians * angleVFrom;\r\n\t\tfinal float stepV = (MathUtils.degreesToRadians * (angleVTo - angleVFrom)) / divisionsV;\r\n\t\tfinal float us = 1f / divisionsU;\r\n\t\tfinal float vs = 1f / divisionsV;\r\n\t\tfloat u = 0f;\r\n\t\tfloat v = 0f;\r\n\t\tfloat angleU = 0f;\r\n\t\tfloat angleV = 0f;\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\t\r\n\t\tensureRectangles((divisionsV + 1) * (divisionsU + 1), divisionsV * divisionsU);\r\n\t\tfor (int iv = 0; iv <= divisionsV; iv++) {\r\n\t\t\tangleV = avo + stepV * iv;\r\n\t\t\tv = vs * iv;\r\n\t\t\tfinal float t = MathUtils.sin(angleV);\r\n\t\t\tfinal float h = MathUtils.cos(angleV) * hh;\r\n\t\t\tfor (int iu = 0; iu <= divisionsU; iu++) {\r\n\t\t\t\tangleU = auo + stepU * iu;\r\n\t\t\t\tu = 1f - us * iu;\r\n\t\t\t\tcurr1.position.set(MathUtils.cos(angleU) * hw * t, h, MathUtils.sin(angleU) * hd * t).mul(transform);\r\n\t\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\t\tcurr1.uv.set(u, v);\r\n\t\t\t\tvertex(curr1);\r\n\t\t\t\tif ((iv > 0) && (iu > 0)) // FIXME don't duplicate lines and points\r\n\t\t\t\t\trect((short)(vindex-1), (short)(vindex-2), (short)(vindex-(divisionsU+3)), (short)(vindex-(divisionsU+2))); \r\n\t\t\t}\r\n\t\t}\r\n\t}","id":66492,"modified_method":"@Override\r\n\tpublic void sphere(final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV, float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {\r\n\t\t// FIXME create better sphere method (- only one vertex for each pole, - position)\r\n\t\tfinal float hw = width * 0.5f;\r\n\t\tfinal float hh = height * 0.5f;\r\n\t\tfinal float hd = depth * 0.5f;\r\n\t\tfinal float auo = MathUtils.degreesToRadians * angleUFrom;\r\n\t\tfinal float stepU = (MathUtils.degreesToRadians * (angleUTo - angleUFrom)) / divisionsU;\r\n\t\tfinal float avo = MathUtils.degreesToRadians * angleVFrom;\r\n\t\tfinal float stepV = (MathUtils.degreesToRadians * (angleVTo - angleVFrom)) / divisionsV;\r\n\t\tfinal float us = 1f / divisionsU;\r\n\t\tfinal float vs = 1f / divisionsV;\r\n\t\tfloat u = 0f;\r\n\t\tfloat v = 0f;\r\n\t\tfloat angleU = 0f;\r\n\t\tfloat angleV = 0f;\r\n\t\tVertexInfo curr1 = vertTmp3.set(null, null, null, null);\r\n\t\tcurr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;\r\n\t\t\r\n\t\tif (tmpIndices == null)\r\n\t\t\ttmpIndices = new ShortArray(divisionsU * 2);\r\n\t\tfinal int s = divisionsU+3;\r\n\t\ttmpIndices.ensureCapacity(s);\r\n\t\twhile (tmpIndices.size > s)\r\n\t\t\ttmpIndices.pop();\r\n\t\twhile (tmpIndices.size < s)\r\n\t\t\ttmpIndices.add(-1);\r\n\t\tint tempOffset = 0;\r\n\t\t\r\n\t\tensureRectangles((divisionsV + 1) * (divisionsU + 1), divisionsV * divisionsU);\r\n\t\tfor (int iv = 0; iv <= divisionsV; iv++) {\r\n\t\t\tangleV = avo + stepV * iv;\r\n\t\t\tv = vs * iv;\r\n\t\t\tfinal float t = MathUtils.sin(angleV);\r\n\t\t\tfinal float h = MathUtils.cos(angleV) * hh;\r\n\t\t\tfor (int iu = 0; iu <= divisionsU; iu++) {\r\n\t\t\t\tangleU = auo + stepU * iu;\r\n\t\t\t\tu = 1f - us * iu;\r\n\t\t\t\tcurr1.position.set(MathUtils.cos(angleU) * hw * t, h, MathUtils.sin(angleU) * hd * t).mul(transform);\r\n\t\t\t\tcurr1.normal.set(curr1.position).nor();\r\n\t\t\t\tcurr1.uv.set(u, v);\r\n\t\t\t\ttmpIndices.set(tempOffset, vertex(curr1));\r\n\t\t\t\tfinal int o = tempOffset+s;\r\n\t\t\t\tif ((iv > 0) && (iu > 0)) // FIXME don't duplicate lines and points\r\n\t\t\t\t\trect(tmpIndices.get(tempOffset), tmpIndices.get((o-1)%s), tmpIndices.get((o-(divisionsU+2))%s), tmpIndices.get((o-(divisionsU+1))%s));\r\n\t\t\t\ttempOffset = (tempOffset + 1) % tmpIndices.size;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic short vertex(final float... values) {\r\n\t\tvertices.addAll(values);\r\n\t\tvindex += values.length / stride;\r\n\t\treturn (short)(vindex-1);\r\n\t}","id":66493,"modified_method":"@Override\r\n\tpublic short vertex(final float... values) {\r\n\t\tfinal int n = values.length - stride;\r\n\t\tfor (int i = 0; i <= n; i += stride)\r\n\t\t\taddVertex(values, i);\r\n\t\treturn lastIndex;\r\n\t}","commit_id":"5c76a51aae9e99562f5fb5fe42203f00f1326542","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected abstract void blockForContent() throws IOException;","id":66494,"modified_method":"/**\n     * Blocks until some content or some end-of-file event arrives.\n     *\n     * @throws IOException if the wait is interrupted\n     */\n    protected abstract void blockForContent() throws IOException;","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * A convenience method to call nextContent and to check the return value, which if null then the\n     * a check is made for EOF and the state changed accordingly.\n     * @see #nextContent()\n     * @return Content or null if none available.\n     * @throws IOException\n     */\n    protected T getNextContent() throws IOException\n    {\n        T content=nextContent();\n\n        if (content==null && _eof!=null)\n        {\n            LOG.debug(\"{} eof {}\",this,_eof);\n            _state=_eof;\n            _eof=null;\n        }\n\n        return content;\n    }","id":66495,"modified_method":"/**\n     * A convenience method to call nextContent and to check the return value, which if null then the\n     * a check is made for EOF and the state changed accordingly.\n     *\n     * @return Content or null if none available.\n     * @throws IOException\n     * @see #nextContent()\n     */\n    protected T getNextContent() throws IOException\n    {\n        T content = nextContent();\n        if (content == null)\n        {\n            synchronized (lock())\n            {\n                if (_eofState != null)\n                {\n                    LOG.debug(\"{} eof {}\", this, _eofState);\n                    _contentState = _eofState;\n                }\n            }\n        }\n        return content;\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void messageComplete()\n    {\n        synchronized (lock())\n        {\n            if (_eof==null || !_eof.isEOF())\n            {\n                LOG.debug(\"{} EOF\", this);\n                _eof=EOF;\n                if (_listener!=null)\n                    _channelState.onReadPossible();\n            }\n        }\n    }","id":66496,"modified_method":"/**\n     * This method should be called to signal that all the expected\n     * content arrived.\n     */\n    public void messageComplete()\n    {\n        synchronized (lock())\n        {\n            if (!isEOF())\n            {\n                LOG.debug(\"{} EOF\", this);\n                _eofState = EOF;\n                if (_listener == null)\n                    return;\n            }\n        }\n        _channelState.onReadPossible();\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void setReadListener(ReadListener readListener)\n    {\n        if (readListener==null)\n            throw new NullPointerException(\"readListener==null\");\n        synchronized (lock())\n        {\n            if (_state!=BLOCKING)\n                throw new IllegalStateException(\"state=\"+_state);\n            _state=ASYNC;\n            _listener=readListener;\n            _notReady=true;\n\n            _channelState.onReadPossible();\n        }\n    }","id":66497,"modified_method":"@Override\n    public void setReadListener(ReadListener readListener)\n    {\n        readListener = Objects.requireNonNull(readListener);\n        synchronized (lock())\n        {\n            if (_contentState != STREAM)\n                throw new IllegalStateException(\"state=\" + _contentState);\n            _contentState = ASYNC;\n            _listener = readListener;\n            _notReady = true;\n        }\n        _channelState.onReadPossible();\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public int read(byte[] b, int off, int len) throws IOException\n    {\n        T item = null;\n        int l;\n        synchronized (lock())\n        {\n            // System.err.printf(\"read s=%s q=%d e=%s%n\",_state,_inputQ.size(),_eof);\n\n            // Get the current head of the input Q\n            item = getNextContent();\n\n            // If we have no item\n            if (item == null)\n            {\n                _state.waitForContent(this);\n                item=getNextContent();\n                if (item==null)\n                    return _state.noContent();\n            }\n            \n            l=get(item, b, off, len);\n            _contentRead+=l;\n            \n        }\n        return l;\n    }","id":66498,"modified_method":"@Override\n    public int read(byte[] b, int off, int len) throws IOException\n    {\n        synchronized (lock())\n        {\n            T item = getNextContent();\n            if (item == null)\n            {\n                _contentState.waitForContent(this);\n                item = getNextContent();\n                if (item == null)\n                    return _contentState.noContent();\n            }\n            int l = get(item, b, off, len);\n            _contentRead += l;\n            return l;\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void consumeAll()\n    {\n        synchronized (lock())\n        {\n            try\n            {\n                while (!isFinished())\n                {\n                    T item = getNextContent();\n                    if (item==null)\n                        _state.waitForContent(this);\n                    else\n                        consume(item,remaining(item));\n                }\n            }\n            catch (IOException e)\n            {\n                LOG.debug(e);\n            }\n        }\n    }","id":66499,"modified_method":"public void consumeAll()\n    {\n        synchronized (lock())\n        {\n            try\n            {\n                while (!isFinished())\n                {\n                    T item = getNextContent();\n                    if (item == null)\n                        _contentState.waitForContent(this);\n                    else\n                        consume(item, remaining(item));\n                }\n            }\n            catch (IOException e)\n            {\n                LOG.debug(e);\n            }\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected abstract void consume(T item, int length);","id":66500,"modified_method":"/**\n     * Consumes the given content.\n     *\n     * @param item   the content to consume\n     * @param length the number of bytes to consume\n     */\n    protected abstract void consume(T item, int length);","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void recycle()\n    {\n        synchronized (lock())\n        {\n            _state = BLOCKING;\n            _eof=null;\n            _onError=null;\n            _contentRead=0;\n        }\n    }","id":66501,"modified_method":"public void recycle()\n    {\n        synchronized (lock())\n        {\n            _listener = null;\n            _onError = null;\n            _notReady = false;\n            _contentState = STREAM;\n            _eofState = null;\n            _contentRead = 0;\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void run()\n    {\n        final boolean available;\n        final boolean eof;\n        final Throwable x;\n\n        synchronized (lock())\n        {\n            if (!_notReady || _listener==null)\n                return;\n\n            x=_onError;\n            T item;\n            try\n            {\n                item = getNextContent();\n            }\n            catch(Exception e)\n            {\n                item=null;\n                failed(e);\n            }\n            available= item!=null && remaining(item)>0;\n\n            eof = !available && _state.isEOF();\n            _notReady=!available&&!eof;\n        }\n\n        try\n        {\n            if (x!=null)\n                _listener.onError(x);\n            else if (available)\n                _listener.onDataAvailable();\n            else if (eof)\n                _listener.onAllDataRead();\n            else\n                unready();\n        }\n        catch(Throwable e)\n        {\n            LOG.warn(e.toString());\n            LOG.debug(e);\n            _listener.onError(e);\n        }\n    }","id":66502,"modified_method":"@Override\n    public void run()\n    {\n        final Throwable error;\n        final ReadListener listener;\n        boolean available = false;\n        final boolean eof;\n\n        synchronized (lock())\n        {\n            if (!_notReady || _listener == null)\n                return;\n\n            error = _onError;\n            listener = _listener;\n\n            try\n            {\n                T item = getNextContent();\n                available = item != null && remaining(item) > 0;\n            }\n            catch (Exception e)\n            {\n                failed(e);\n            }\n\n            eof = !available && isFinished();\n            _notReady = !available && !eof;\n        }\n\n        try\n        {\n            if (error != null)\n                listener.onError(error);\n            else if (available)\n                listener.onDataAvailable();\n            else if (eof)\n                listener.onAllDataRead();\n            else\n                unready();\n        }\n        catch (Throwable e)\n        {\n            LOG.warn(e.toString());\n            LOG.debug(e);\n            listener.onError(e);\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** This method should be called to signal to the HttpInput\n     * that an EOF has arrived before all the expected content.\n     * Typically this will result in an EOFException being thrown\n     * from a subsequent read rather than a -1 return.\n     */\n    public void earlyEOF()\n    {\n        synchronized (lock())\n        {\n            if (_eof==null || !_eof.isEOF())\n            {\n                LOG.debug(\"{} early EOF\", this);\n                _eof=EARLY_EOF;\n                if (_listener!=null)\n                    _channelState.onReadPossible();\n            }\n        }\n    }","id":66503,"modified_method":"/**\n     * This method should be called to signal that an EOF has been\n     * detected before all the expected content arrived.\n     * <p/>\n     * Typically this will result in an EOFException being thrown\n     * from a subsequent read rather than a -1 return.\n     */\n    public void earlyEOF()\n    {\n        synchronized (lock())\n        {\n            if (!isEOF())\n            {\n                LOG.debug(\"{} early EOF\", this);\n                _eofState = EARLY_EOF;\n                if (_listener == null)\n                    return;\n            }\n        }\n        _channelState.onReadPossible();\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean isFinished()\n    {\n        synchronized (lock())\n        {\n            return _state.isEOF();\n        }\n    }","id":66504,"modified_method":"@Override\n    public boolean isFinished()\n    {\n        synchronized (lock())\n        {\n            return _contentState.isEOF();\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public int read() throws IOException\n    {\n        int read = read(_oneByteBuffer, 0, 1);\n        return read < 0 ? -1 : 0xff & _oneByteBuffer[0];\n    }","id":66505,"modified_method":"@Override\n    public int read() throws IOException\n    {\n        int read = read(_oneByteBuffer, 0, 1);\n        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean isReady()\n    {\n        synchronized (lock())\n        {\n            if (_listener==null)\n                return true;\n            int available = available();\n            if (available>0)\n                return true;\n            if (!_notReady)\n            {\n                _notReady=true;\n                if (_state.isEOF())\n                    _channelState.onReadPossible();\n                else\n                    unready();\n            }\n            return false;\n        }\n    }","id":66506,"modified_method":"@Override\n    public boolean isReady()\n    {\n        boolean finished;\n        synchronized (lock())\n        {\n            if (_listener == null)\n                return true;\n            if (available() > 0)\n                return true;\n            if (_notReady)\n                return false;\n            _notReady = true;\n            finished = isFinished();\n        }\n        if (finished)\n            _channelState.onReadPossible();\n        else\n            unready();\n        return false;\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected boolean onAsyncRead()\n    {\n        if (_listener == null)\n            return false;\n        _channelState.onReadPossible();\n        return true;\n    }","id":66507,"modified_method":"protected boolean onAsyncRead()\n    {\n        synchronized (lock())\n        {\n            if (_listener == null)\n                return false;\n        }\n        _channelState.onReadPossible();\n        return true;\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected abstract int get(T item, byte[] buffer, int offset, int length);","id":66508,"modified_method":"/**\n     * Copies the given content into the given byte buffer.\n     *\n     * @param item   the content to copy from\n     * @param buffer the buffer to copy into\n     * @param offset the buffer offset to start copying from\n     * @param length the space available in the buffer\n     * @return the number of bytes actually copied\n     */\n    protected abstract int get(T item, byte[] buffer, int offset, int length);","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected abstract int remaining(T item);","id":66509,"modified_method":"/**\n     * @param item the content\n     * @return how many bytes remain in the given content\n     */\n    protected abstract int remaining(T item);","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void blockForContent() throws IOException\n    {\n        synchronized (lock())\n        {\n            while (_inputQ.isEmpty() && !isFinished())\n            {\n                try\n                {\n                    LOG.debug(\"{} waiting for content\", this);\n                    lock().wait();\n                }\n                catch (InterruptedException e)\n                {\n                    throw (IOException)new InterruptedIOException().initCause(e);\n                }\n            }\n        }\n    }","id":66510,"modified_method":"protected void blockForContent() throws IOException\n    {\n        synchronized (lock())\n        {\n            while (_inputQ.isEmpty() && !isFinished() && !isEOF())\n            {\n                try\n                {\n                    LOG.debug(\"{} waiting for content\", this);\n                    lock().wait();\n                }\n                catch (InterruptedException e)\n                {\n                    throw (IOException)new InterruptedIOException().initCause(e);\n                }\n            }\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Add some content to the input stream\n     * @param item\n     */\n    public void content(T item)\n    {\n        // The buffer is not copied here.  This relies on the caller not recycling the buffer\n        // until the it is consumed.  The onContentConsumed and onAllContentConsumed() callbacks are \n        // the signals to the caller that the buffers can be recycled.\n        \n        synchronized (lock())\n        {\n            boolean empty=_inputQ.isEmpty();\n            \n            _inputQ.add(item);\n\n            if (empty)\n            {\n                if (!onAsyncRead())\n                    lock().notify();\n            }\n            \n            LOG.debug(\"{} queued {}\", this, item);\n        }\n    }","id":66511,"modified_method":"public void content(T item)\n    {\n        // The buffer is not copied here.  This relies on the caller not recycling the buffer\n        // until the it is consumed.  The onContentConsumed and onAllContentConsumed() callbacks are\n        // the signals to the caller that the buffers can be recycled.\n\n        synchronized (lock())\n        {\n            boolean wasEmpty = _inputQ.isEmpty();\n            _inputQ.add(item);\n            LOG.debug(\"{} queued {}\", this, item);\n            if (wasEmpty)\n            {\n                if (!onAsyncRead())\n                    lock().notify();\n            }\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected T nextContent()\n    {\n        T item = _inputQ.peekUnsafe();\n\n        // Skip empty items at the head of the queue\n        while (item != null && remaining(item) == 0)\n        {\n            _inputQ.pollUnsafe();\n            onContentConsumed(item);\n            LOG.debug(\"{} consumed {}\", this, item);\n            item = _inputQ.peekUnsafe();\n\n            // If that was the last item then notify\n            if (item==null)\n                onAllContentConsumed();\n        }\n        return item;\n    }","id":66512,"modified_method":"@Override\n    protected T nextContent()\n    {\n        synchronized (lock())\n        {\n            // Items are removed only when they are fully consumed.\n            T item = _inputQ.peekUnsafe();\n            // Skip consumed items at the head of the queue.\n            while (item != null && remaining(item) == 0)\n            {\n                _inputQ.pollUnsafe();\n                onContentConsumed(item);\n                LOG.debug(\"{} consumed {}\", this, item);\n                item = _inputQ.peekUnsafe();\n            }\n            return item;\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void recycle()\n    {\n        synchronized (lock())\n        {\n            T item = _inputQ.peekUnsafe();\n            while (item != null)\n            {\n                _inputQ.pollUnsafe();\n                onContentConsumed(item);\n\n                item = _inputQ.peekUnsafe();\n                if (item == null)\n                    onAllContentConsumed();\n            }\n            super.recycle();\n        }\n    }","id":66513,"modified_method":"public void recycle()\n    {\n        synchronized (lock())\n        {\n            T item = _inputQ.pollUnsafe();\n            while (item != null)\n            {\n                onContentConsumed(item);\n                item = _inputQ.pollUnsafe();\n            }\n            super.recycle();\n        }\n    }","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected abstract void onContentConsumed(T item);","id":66514,"modified_method":"/**\n     * Callback that signals that the given content has been consumed.\n     *\n     * @param item the consumed content\n     */\n    protected abstract void onContentConsumed(T item);","commit_id":"93013b36ddc4549b81129d403364a79314d1044b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public int compareTo(@NotNull StdArrangementMatchRule o) {\n    final Set<ArrangementSettingsToken> tokens = ArrangementUtil.extractTokens(getMatcher().getCondition()).keySet();\n    final Set<ArrangementSettingsToken> tokens1 = ArrangementUtil.extractTokens(o.getMatcher().getCondition()).keySet();\n    return tokens1.containsAll(tokens) ? 1 : tokens.containsAll(tokens1) ? -1 : 0;\n  }","id":66515,"modified_method":"@Override\n  public int compareTo(@NotNull StdArrangementMatchRule o) {\n    final Set<ArrangementSettingsToken> tokens = ArrangementUtil.extractTokens(getMatcher().getCondition()).keySet();\n    final Set<ArrangementSettingsToken> tokens1 = ArrangementUtil.extractTokens(o.getMatcher().getCondition()).keySet();\n    if (tokens1.containsAll(tokens)) {\n      return tokens.containsAll(tokens1) ? 0 : 1;\n    }\n    else {\n      return tokens.containsAll(tokens1) ? -1 : 0;\n    }\n  }","commit_id":"70b3267c9f183508cbf83ba50b16fb1574d53b7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PrefabGraph[] getQueriesByResourceTypeAttributes(String resourceType,\n            Set<GraphAttribute> attributes, PrefabGraph[] availableQueries) {\n\n        List<PrefabGraph> returnList = new LinkedList<PrefabGraph>();\n\n        Set<String> availDataSourceList = new HashSet<String>(attributes.size());\n        for (GraphAttribute attribute : attributes) {\n            availDataSourceList.add(attribute.getName());\n        }\n\n        for (PrefabGraph query : availableQueries) {\n            if (resourceType != null &&\n                    !resourceType.equals(query.getType())) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"skipping \" + query.getName() + \" because its type \\\"\" + query.getType() + \"\\\" does not equal resourceType \\\"\" + resourceType + \"\\\"\");\n                }\n                continue;\n            }\n            \n            List requiredList = Arrays.asList(query.getColumns());\n\n            if (availDataSourceList.containsAll(requiredList)) {\n                returnList.add(query);\n            }\n        }\n\n        PrefabGraph[] availQueries = (PrefabGraph[])\n        returnList.toArray(new PrefabGraph[returnList.size()]);\n\n        return availQueries;\n    }","id":66516,"modified_method":"public PrefabGraph[] getQueriesByResourceTypeAttributes(String resourceType,\n            Set<GraphAttribute> attributes, PrefabGraph[] availableQueries) {\n\n        List<PrefabGraph> returnList = new LinkedList<PrefabGraph>();\n\n        Set<String> availDataSourceList = new HashSet<String>(attributes.size());\n        for (GraphAttribute attribute : attributes) {\n            availDataSourceList.add(attribute.getName());\n        }\n\n        for (PrefabGraph query : availableQueries) {\n            if (resourceType != null &&\n                    !resourceType.equals(query.getType())) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"skipping \" + query.getName() + \" because its type \\\"\" + query.getType() + \"\\\" does not equal resourceType \\\"\" + resourceType + \"\\\"\");\n                }\n                continue;\n            }\n            \n            List<String> requiredList = Arrays.asList(query.getColumns());\n\n            if (availDataSourceList.containsAll(requiredList)) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"adding \" + query.getName() + \" to query list\");\n                }\n                returnList.add(query);\n            } else {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"not adding \" + query.getName() + \" to query list because required list of attributes (\" + StringUtils.collectionToDelimitedString(requiredList, \", \") + \") is not in the list of attributes on the resource (\" + StringUtils.collectionToDelimitedString(availDataSourceList, \", \")+ \")\");\n                }\n            }\n        }\n\n        PrefabGraph[] availQueries = (PrefabGraph[])\n        returnList.toArray(new PrefabGraph[returnList.size()]);\n\n        return availQueries;\n    }","commit_id":"d482d8ea7445df956f9dc97cf08f3072340efe3a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PrefabGraph[] getQueriesByResourceTypeAttributes(String resourceType,\n            Set<GraphAttribute> attributes, PrefabGraph[] availableQueries) {\n\n        List<PrefabGraph> returnList = new LinkedList<PrefabGraph>();\n\n        Set<String> availDataSourceList = new HashSet<String>(attributes.size());\n        for (GraphAttribute attribute : attributes) {\n            availDataSourceList.add(attribute.getName());\n        }\n\n        for (PrefabGraph query : availableQueries) {\n            if (resourceType != null &&\n                    !resourceType.equals(query.getType())) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"skipping \" + query.getName() + \" because its type \\\"\" + query.getType() + \"\\\" does not equal resourceType \\\"\" + resourceType + \"\\\"\");\n                }\n                continue;\n            }\n            \n            List requiredList = Arrays.asList(query.getColumns());\n\n            if (availDataSourceList.containsAll(requiredList)) {\n                returnList.add(query);\n            }\n        }\n\n        PrefabGraph[] availQueries = (PrefabGraph[])\n        returnList.toArray(new PrefabGraph[returnList.size()]);\n\n        return availQueries;\n    }","id":66517,"modified_method":"public PrefabGraph[] getQueriesByResourceTypeAttributes(String resourceType,\n            Set<GraphAttribute> attributes, PrefabGraph[] availableQueries) {\n\n        List<PrefabGraph> returnList = new LinkedList<PrefabGraph>();\n\n        Set<String> availDataSourceList = new HashSet<String>(attributes.size());\n        for (GraphAttribute attribute : attributes) {\n            availDataSourceList.add(attribute.getName());\n        }\n\n        for (PrefabGraph query : availableQueries) {\n            if (resourceType != null &&\n                    !resourceType.equals(query.getType())) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"skipping \" + query.getName() + \" because its type \\\"\" + query.getType() + \"\\\" does not equal resourceType \\\"\" + resourceType + \"\\\"\");\n                }\n                continue;\n            }\n            \n            List<String> requiredList = Arrays.asList(query.getColumns());\n\n            if (availDataSourceList.containsAll(requiredList)) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"adding \" + query.getName() + \" to query list\");\n                }\n                returnList.add(query);\n            } else {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"not adding \" + query.getName() + \" to query list because required list of attributes (\" + StringUtils.collectionToDelimitedString(requiredList, \", \") + \") is not in the list of attributes on the resource (\" + StringUtils.collectionToDelimitedString(availDataSourceList, \", \")+ \")\");\n                }\n            }\n        }\n\n        PrefabGraph[] availQueries = (PrefabGraph[])\n        returnList.toArray(new PrefabGraph[returnList.size()]);\n\n        return availQueries;\n    }","commit_id":"f244c2c2e9499235a400a964f813d1ab0434cccf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public int compareTo(@NotNull StdArrangementMatchRule o) {\n    final Set<ArrangementSettingsToken> tokens = ArrangementUtil.extractTokens(getMatcher().getCondition()).keySet();\n    final Set<ArrangementSettingsToken> tokens1 = ArrangementUtil.extractTokens(o.getMatcher().getCondition()).keySet();\n    if (tokens1.containsAll(tokens)) {\n      return tokens.containsAll(tokens1) ? 0 : 1;\n    }\n    else {\n      return tokens.containsAll(tokens1) ? -1 : 0;\n    }\n  }","id":66518,"modified_method":"@Override\n  public int compareTo(@NotNull StdArrangementMatchRule o) {\n    final Set<ArrangementSettingsToken> tokens = ArrangementUtil.extractTokens(getMatcher().getCondition()).keySet();\n    final Set<ArrangementSettingsToken> tokens1 = ArrangementUtil.extractTokens(o.getMatcher().getCondition()).keySet();\n    if (tokens1.containsAll(tokens)) {\n      return tokens.containsAll(tokens1) ? 0 : 1;\n    }\n    else {\n      if (tokens.containsAll(tokens1)) {\n        return -1;\n      }\n\n      final String entryType = getEntryType(tokens);\n      final String entryType1 = getEntryType(tokens1);\n      final int compare = StringUtil.compare(entryType, entryType1, false);\n      if (compare != 0 || tokens.size() == tokens1.size()) {\n        return compare;\n      }\n      return tokens.size() < tokens1.size() ? 1 : -1;\n    }\n  }","commit_id":"c3e242f03f52dea22c310775cbf11e89d37971c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param model\n\t *            the EOModel\n\t * @param optionsCreate\n\t *            a NSDictionary containing the different options. Possible keys are\n\t *            <ul>\n\t *            <li>EOSchemaGeneration.DropTablesKey<\/li>\n\t *            <li>EOSchemaGeneration.DropPrimaryKeySupportKey<\/li>\n\t *            <li>EOSchemaGeneration.CreateTablesKey<\/li>\n\t *            <li>EOSchemaGeneration.CreatePrimaryKeySupportKey<\/li>\n\t *            <li>EOSchemaGeneration.PrimaryKeyConstraintsKey<\/li>\n\t *            <li>EOSchemaGeneration.ForeignKeyConstraintsKey<\/li>\n\t *            <li>EOSchemaGeneration.CreateDatabaseKey<\/li>\n\t *            <\/ul>\n\t *            <li>EOSchemaGeneration.DropDatabaseKey<\/li>\n\t *            <br/><br>\n\t *            Possible values are <code>YES<\/code> and <code>NO<\/code>\n\t * \n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInModelAndOptions(NSArray entities, EOModel model, NSDictionary optionsCreate) {\n\t\tEODatabaseContext databaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, ERXEC.newEditingContext());\n\t\tif (entities == null) {\n\t\t\tEnumeration e = model.entities().objectEnumerator();\n\t\t\tNSMutableArray ar = new NSMutableArray();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tEOEntity currentEntity = (EOEntity) e.nextElement();\n\t\t\t\tif (ERXModelGroup.isPrototypeEntity(currentEntity)) {\n\t\t\t\t\t// we do not want to add EOXXXPrototypes entities\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!ERXEOAccessUtilities.entityUsesSeparateTable(currentEntity)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tar.addObject(currentEntity);\n\t\t\t}\n\t\t\tentities = ar;\n\t\t}\n\t\treturn createSchemaSQLForEntitiesWithOptions(entities, databaseContext, optionsCreate);\n\t}","id":66519,"modified_method":"/**\n\t * creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param model\n\t *            the EOModel\n\t * @param optionsCreate\n\t *            a NSDictionary containing the different options\n\t * \n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInModelAndOptions(NSArray entities, EOModel model, NSDictionary optionsCreate) {\n\t\tEOEditingContext ec = ERXEC.newEditingContext();\n\t\tec.lock();\n\t\ttry {\n\t\t\tEODatabaseContext databaseContext = databaseContextForModel(model, (EOObjectStoreCoordinator)ec.rootObjectStore());\n\t\t\t// AK the default implementation loads the shared objects, and when they don't exist, throw an an error\n\t\t\t// which is not very useful for schema generation\n\t\t\t// But you would probably want to exit soon after calling this....\n\t\t\t// EODatabaseContext databaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, ec);\n\t\t\tif (entities == null) {\n\t\t\t\tEnumeration e = model.entities().objectEnumerator();\n\t\t\t\tNSMutableArray ar = new NSMutableArray();\n\t\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t\tEOEntity currentEntity = (EOEntity) e.nextElement();\n\t\t\t\t\tif (ERXModelGroup.isPrototypeEntity(currentEntity)) {\n\t\t\t\t\t\t// we do not want to add EOXXXPrototypes entities\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ERXEOAccessUtilities.entityUsesSeparateTable(currentEntity)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tar.addObject(currentEntity);\n\t\t\t\t}\n\t\t\t\tentities = ar;\n\t\t\t}\n\t\t\tString result = createSchemaSQLForEntitiesWithOptions(entities, databaseContext, optionsCreate);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tec.unlock();\n\t\t}\n\t}","commit_id":"486288feac96e0cba2f70366fb4f4d9c15f586a8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param model\n\t *            the EOModel <br/><br/>This method uses the following defaults options:\n\t *            <ul>\n\t *            <li>EOSchemaGeneration.DropTablesKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.DropPrimaryKeySupportKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.CreateTablesKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.CreatePrimaryKeySupportKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.PrimaryKeyConstraintsKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.ForeignKeyConstraintsKey=YES<\/li>\n\t *            <li>EOSchemaGeneration.CreateDatabaseKey=NO<\/li>\n\t *            <li>EOSchemaGeneration.DropDatabaseKey=NO<\/li>\n\t *            <\/ul>\n\t *            <br/><br>\n\t *            Possible values are <code>YES<\/code> and <code>NO<\/code>\n\t * \n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInModel(NSArray entities, EOModel model) {\n\t\tNSMutableDictionary optionsCreate = new NSMutableDictionary();\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.DropTablesKey);\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.DropPrimaryKeySupportKey);\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.CreateTablesKey);\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.CreatePrimaryKeySupportKey);\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.PrimaryKeyConstraintsKey);\n\t\toptionsCreate.setObjectForKey(\"YES\", EOSchemaGeneration.ForeignKeyConstraintsKey);\n\t\toptionsCreate.setObjectForKey(\"NO\", EOSchemaGeneration.CreateDatabaseKey);\n\t\toptionsCreate.setObjectForKey(\"NO\", EOSchemaGeneration.DropDatabaseKey);\n\t\treturn createSchemaSQLForEntitiesInModelAndOptions(entities, model, optionsCreate);\n\t}","id":66520,"modified_method":"/**\n\t * Creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param model the EOModel\n\t * \n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInModel(NSArray entities, EOModel model) {\n\t\treturn createSchemaSQLForEntitiesInModelAndOptions(entities, model, defaultOptionDictionary(true, true));\n\t}","commit_id":"486288feac96e0cba2f70366fb4f4d9c15f586a8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param databaseContext\n\t *            the databaseContext\n\t * \n\t * @param create\n\t *            if true, tables and keys are created\n\t * @param drop\n\t *            if true, tables and keys are dropped\n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInDatabaseContext(NSArray entities, EODatabaseContext databaseContext, boolean create, boolean drop) {\n\t\tNSMutableDictionary optionsCreate = new NSMutableDictionary();\n\t\toptionsCreate.setObjectForKey((drop) ? \"YES\" : \"NO\", EOSchemaGeneration.DropTablesKey);\n\t\toptionsCreate.setObjectForKey((drop) ? \"YES\" : \"NO\", EOSchemaGeneration.DropPrimaryKeySupportKey);\n\t\toptionsCreate.setObjectForKey((create) ? \"YES\" : \"NO\", EOSchemaGeneration.CreateTablesKey);\n\t\toptionsCreate.setObjectForKey((create) ? \"YES\" : \"NO\", EOSchemaGeneration.CreatePrimaryKeySupportKey);\n\t\toptionsCreate.setObjectForKey((create) ? \"YES\" : \"NO\", EOSchemaGeneration.PrimaryKeyConstraintsKey);\n\t\toptionsCreate.setObjectForKey((create) ? \"YES\" : \"NO\", EOSchemaGeneration.ForeignKeyConstraintsKey);\n\t\toptionsCreate.setObjectForKey(\"NO\", EOSchemaGeneration.CreateDatabaseKey);\n\t\toptionsCreate.setObjectForKey(\"NO\", EOSchemaGeneration.DropDatabaseKey);\n\t\treturn createSchemaSQLForEntitiesWithOptions(entities, databaseContext, optionsCreate);\n\t}","id":66521,"modified_method":"/**\n\t * creates SQL to create tables for the specified Entities. This can be used with EOUtilities rawRowsForSQL method\n\t * to create the tables.\n\t * \n\t * @param entities\n\t *            a NSArray containing the entities for which create table statements should be generated or null if all\n\t *            entitites in the model should be used.\n\t * @param databaseContext\n\t *            the databaseContext\n\t * \n\t * @param create\n\t *            if true, tables and keys are created\n\t * @param drop\n\t *            if true, tables and keys are dropped\n\t * @return a <code>String<\/code> containing SQL statements to create tables\n\t */\n\tpublic String createSchemaSQLForEntitiesInDatabaseContext(NSArray entities, EODatabaseContext databaseContext, boolean create, boolean drop) {\n\t\treturn createSchemaSQLForEntitiesWithOptions(entities, databaseContext, defaultOptionDictionary(create,drop));\n\t}","commit_id":"486288feac96e0cba2f70366fb4f4d9c15f586a8","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected NSArray defaultBranchChoices(D2WContext context) {\n        NSArray result = super.defaultBranchChoices(context);\n        Bug bug = (Bug)object(context);\n        // AK: this is just an illustration\n        if(!bug.state().equals(State.ANALYZE)) {\n            result = choiceByRemovingKeys(new NSArray(\"delete\"), result);\n        }\n        return result;\n    }","id":66522,"modified_method":"protected NSArray defaultBranchChoices(D2WContext context) {\n        NSArray result = super.defaultBranchChoices(context);\n        log.info(\"in: \" + result);\n         Bug bug = (Bug)object(context);\n        // AK: this is just an illustration\n        if(!bug.state().equals(State.ANALYZE)) {\n            result = choiceByRemovingKeys(new NSArray(\"delete\"), result);\n        }\n        if(!bug.state().equals(State.CLOSED)) {\n        \tresult = choiceByRemovingKeys(new NSArray(new Object[] {\"reopen\", \"view\"}), result);\n        }\n        if(bug.state().equals(State.CLOSED)) {\n        \tresult = choiceByRemovingKeys(new NSArray(new Object[] {\"resolve\", \"edit\"}), result);\n        }\n        if(!bug.state().equals(State.VERIFY)) {\n            result = choiceByRemovingKeys(new NSArray(\"reject\"), result);\n        }\n        log.info(\"out: \" + result + \" -> \" + bug.state().textDescription());\n        return result;\n    }","commit_id":"939d47373ad4d9e000fe1b5e064c8ba004b69dc6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent listMyTestItems() {\n        EODatabaseDataSource ds = new EODatabaseDataSource(ERXEC.newEditingContext(), \"TestItem\");\n        return (WOComponent) listPageNamed(\"ListMyTestItem\", ds);\n    }","id":66523,"modified_method":"public WOComponent listMyTestItems() {\n    \tEOEditingContext ec = ERXEC.newEditingContext();\n\t\tec.lock();\n\t\ttry {\n\t        NSArray array = TestItem.clazz.unclosedTestItemsWithUser(ec, People.clazz.currentUser(ec));\n\t        EOArrayDataSource ds = TestItem.clazz.newArrayDataSource(ec);\n\t        ds.setArray(array);\n\t        return (WOComponent) listPageNamed(\"ListMyTestItem\", ds);\n\t\t} finally {\n\t\t\tec.unlock();\n\t\t}\n    }","commit_id":"939d47373ad4d9e000fe1b5e064c8ba004b69dc6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent queryBugs() {\n        return (WOComponent) pageForConfigurationNamed(\"QueryBug\");\n    }","id":66524,"modified_method":"public WOComponent queryBugs() {\n    \tERD2WQueryPage page = (ERD2WQueryPage) pageForConfigurationNamed(\"QueryBug\");\n    \tpage.setQueryMatchForKey(new NSArray(Priority.CRITICAL), EOQualifier.QualifierOperatorEqual.name(), \"priority\");\n    \tpage.setQueryMatchForKey(new NSArray(People.clazz.currentUser(session().defaultEditingContext())), EOQualifier.QualifierOperatorEqual.name(), \"originator\");\n    \tpage.setShowResults(true);\n    \treturn page;\n    }","commit_id":"939d47373ad4d9e000fe1b5e064c8ba004b69dc6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent listMyRequirements() {\n        EODatabaseDataSource ds = new EODatabaseDataSource(ERXEC.newEditingContext(), \"Requirement\");\n        return (WOComponent) listPageNamed(\"ListRequirement\", ds);\n    }","id":66525,"modified_method":"public WOComponent listMyRequirements() {\n    \tEOEditingContext ec = ERXEC.newEditingContext();\n\t\tec.lock();\n\t\ttry {\n\t        NSArray array = Requirement.clazz.myRequirementsWithUser(ec, People.clazz.currentUser(ec));\n\t        EOArrayDataSource ds = Requirement.clazz.newArrayDataSource(ec);\n\t        ds.setArray(array);\n\t        return (WOComponent) listPageNamed(\"ListMyRequirement\", ds);\n\t\t} finally {\n\t\t\tec.unlock();\n\t\t}\n    }","commit_id":"939d47373ad4d9e000fe1b5e064c8ba004b69dc6","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public void consume(final Task.Backgroundable backgroundable, final Runnable runnable) {\n      final BackgroundableProcessIndicator pi = new BackgroundableProcessIndicator(backgroundable);\n      if (StringUtil.isEmptyOrSpaces(backgroundable.getTitle())) {\n        pi.setTitle(myTitle);\n      }\n      ProgressManager.getInstance().runProcess(new Runnable() {\n        @Override\n        public void run() {\n          // calls task's run and onCancel() or onSuccess()\n          RunBackgroundable.runIfBackgroundThread(backgroundable, pi, runnable);\n        }\n      }, pi);\n    }","id":66526,"modified_method":"@Override\n    public void consume(final Task.Backgroundable backgroundable, final Runnable runnable) {\n      final BackgroundableProcessIndicator pi = new BackgroundableProcessIndicator(backgroundable);\n      if (StringUtil.isEmptyOrSpaces(backgroundable.getTitle())) {\n        pi.setTitle(myTitle);\n      }\n      ProgressManager.getInstance().runProcess(new Runnable() {\n        @Override\n        public void run() {\n          ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n            @Override\n            public void run() {\n              // calls task's run and onCancel() or onSuccess()\n              RunBackgroundable.runIfBackgroundThread(backgroundable, pi, runnable);\n            }\n          });\n        }\n      }, pi);\n    }","commit_id":"4b5668c455eb06589f08f2c3df69198178df8913","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processTextUsages(final Map<String, Set<PsiFile>> processedTextToFiles,\n                                 final String text,\n                                 final Map<String, Set<PsiFile>> processedFoundTextToFiles,\n                                 final PsiSearchHelper searchHelper,\n                                 final GlobalSearchScope scope) {\n    if (!processedTextToFiles.containsKey(text)){\n      if (processedFoundTextToFiles.containsKey(text)){\n        final Set<PsiFile> filesWithValue = processedFoundTextToFiles.get(text);\n        processedTextToFiles.put(text, filesWithValue);\n      } else {\n        final Set<PsiFile> resultFiles = new HashSet<PsiFile>();\n        findFilesWithText(text, searchHelper, scope, resultFiles);\n        if (resultFiles.size() == 0) return;\n        processedTextToFiles.put(text, resultFiles);\n      }\n    }\n  }","id":66527,"modified_method":"private static void processTextUsages(final Map<String, Set<PsiFile>> processedTextToFiles,\n                                        final String text,\n                                        final Map<String, Set<PsiFile>> processedFoundTextToFiles,\n                                        final PsiSearchHelper searchHelper,\n                                        final GlobalSearchScope scope) {\n    if (!processedTextToFiles.containsKey(text)) {\n      if (processedFoundTextToFiles.containsKey(text)) {\n        final Set<PsiFile> filesWithValue = processedFoundTextToFiles.get(text);\n        processedTextToFiles.put(text, filesWithValue);\n      }\n      else {\n        final Set<PsiFile> resultFiles = new HashSet<PsiFile>();\n        findFilesWithText(text, searchHelper, scope, resultFiles);\n        if (resultFiles.isEmpty()) return;\n        processedTextToFiles.put(text, resultFiles);\n      }\n    }\n  }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void findFilesWithText(String stringToFind,\n                                        PsiSearchHelper searchHelper,\n                                        GlobalSearchScope scope,\n                                        final Set<PsiFile> resultFiles) {\n    final List<String> words = StringUtil.getWordsIn(stringToFind);\n    if (words.size() == 0) return;\n    Collections.sort(words, new Comparator<String>() {\n      public int compare(final String o1, final String o2) {\n        return o2.length() - o1.length();\n      }\n    });\n    for (String word : words) {\n      final Set<PsiFile> files = new THashSet<PsiFile>();\n      searchHelper.processAllFilesWithWord(word, scope, new CommonProcessors.CollectProcessor<PsiFile>(files), true);\n      if (resultFiles.size() == 0) {\n        resultFiles.addAll(files);\n      }\n      else {\n        resultFiles.retainAll(files);\n      }\n      if (resultFiles.size() == 0) return;\n    }\n  }","id":66528,"modified_method":"private static void findFilesWithText(String stringToFind,\n                                        PsiSearchHelper searchHelper,\n                                        GlobalSearchScope scope,\n                                        final Set<PsiFile> resultFiles) {\n    final List<String> words = StringUtil.getWordsIn(stringToFind);\n    if (words.isEmpty()) return;\n    Collections.sort(words, new Comparator<String>() {\n      public int compare(final String o1, final String o2) {\n        return o2.length() - o1.length();\n      }\n    });\n    for (String word : words) {\n      final Set<PsiFile> files = new THashSet<PsiFile>();\n      searchHelper.processAllFilesWithWord(word, scope, new CommonProcessors.CollectProcessor<PsiFile>(files), true);\n      if (resultFiles.isEmpty()) {\n        resultFiles.addAll(files);\n      }\n      else {\n        resultFiles.retainAll(files);\n      }\n      if (resultFiles.isEmpty()) return;\n    }\n  }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkFile(final PsiFile file, final InspectionManager manager) {\n    if (!(file instanceof PropertiesFile)) return;\n    if (getContext().RUN_WITH_EDITOR_PROFILE &&\n        InspectionProjectProfileManager.getInstance(file.getProject()).getInspectionProfile((PsiElement)file).getInspectionTool(getShortName()) != this) {\n      return;\n    }\n    final PsiSearchHelper searchHelper = file.getManager().getSearchHelper();\n    final PropertiesFile propertiesFile = ((PropertiesFile)file);\n    final List<Property> properties = propertiesFile.getProperties();\n    Module module = ModuleUtil.findModuleForPsiElement(file);\n    if (module == null) return;\n    final GlobalSearchScope scope = CURRENT_FILE\n                                    ? (GlobalSearchScope)GlobalSearchScope.fileScope(file)\n                                    : (MODULE_WITH_DEPENDENCIES\n                                       ? GlobalSearchScope.moduleWithDependenciesScope(module)\n                                       : GlobalSearchScope.projectScope(file.getProject()));\n    final Map<String, Set<PsiFile>> processedValueToFiles = new HashMap<String, Set<PsiFile>>();\n    final Map<String, Set<PsiFile>> processedKeyToFiles = new HashMap<String, Set<PsiFile>>();\n    final ProgressIndicator original = ProgressManager.getInstance().getProgressIndicator();\n    final ProgressIndicator progress = original == null ? null : new ProgressWrapper(original);\n    ProgressManager.getInstance().runProcess(new Runnable() {\n      public void run() {\n        for (Property property : properties) {\n          if (original != null) {\n            if (original.isCanceled()) throw new ProcessCanceledException();\n            original.setText2(PropertiesBundle.message(\"searching.for.property.key.progress.text\", property.getUnescapedKey()));\n          }\n          processTextUsages(processedValueToFiles, property.getValue(), processedKeyToFiles, searchHelper, scope);\n          processTextUsages(processedKeyToFiles, property.getUnescapedKey(), processedValueToFiles, searchHelper, scope);\n        }\n\n        List<ProblemDescriptor> problemDescriptors = new ArrayList<ProblemDescriptor>();\n        Map<String, Set<String> > keyToDifferentValues = new HashMap<String, Set<String>>();\n        if (CHECK_DUPLICATE_KEYS || CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) prepareDuplicateKeysByFile(processedKeyToFiles, manager, keyToDifferentValues, problemDescriptors, file, original);\n        if (CHECK_DUPLICATE_VALUES) prepareDuplicateValuesByFile(processedValueToFiles, manager, problemDescriptors, file, original);\n        if (CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) processDuplicateKeysWithDifferentValues(keyToDifferentValues, processedKeyToFiles, problemDescriptors, manager, file, original);\n        if (problemDescriptors.size() > 0) {\n          addProblemElement(getRefManager().getReference(file), problemDescriptors.toArray(new ProblemDescriptor[problemDescriptors.size()]));\n        }\n      }\n    }, progress);\n  }","id":66529,"modified_method":"private void checkFile(final PsiFile file, final InspectionManager manager) {\n    if (!(file instanceof PropertiesFile)) return;\n    if (getContext().RUN_WITH_EDITOR_PROFILE &&\n        InspectionProjectProfileManager.getInstance(file.getProject()).getInspectionProfile(file).getInspectionTool(getShortName()) != this) {\n      return;\n    }\n    final PsiSearchHelper searchHelper = file.getManager().getSearchHelper();\n    final PropertiesFile propertiesFile = (PropertiesFile)file;\n    final List<Property> properties = propertiesFile.getProperties();\n    Module module = ModuleUtil.findModuleForPsiElement(file);\n    if (module == null) return;\n    final GlobalSearchScope scope = CURRENT_FILE\n                                    ? (GlobalSearchScope)GlobalSearchScope.fileScope(file)\n                                    : MODULE_WITH_DEPENDENCIES\n                                      ? GlobalSearchScope.moduleWithDependenciesScope(module)\n                                      : GlobalSearchScope.projectScope(file.getProject());\n    final Map<String, Set<PsiFile>> processedValueToFiles = Collections.synchronizedMap(new HashMap<String, Set<PsiFile>>());\n    final Map<String, Set<PsiFile>> processedKeyToFiles = Collections.synchronizedMap(new HashMap<String, Set<PsiFile>>());\n    final ProgressIndicator original = ProgressManager.getInstance().getProgressIndicator();\n    final ProgressIndicator progress = original == null ? null : new ProgressWrapper(original);\n    ProgressManager.getInstance().runProcess(new Runnable() {\n      public void run() {\n        final Job<?> job = JobScheduler.getInstance().createJob(\"Searching properties usages\", Job.DEFAULT_PRIORITY); // TODO: Better name, handle priority\n\n        for (final Property property : properties) {\n          job.addTask(new Runnable(){\n            public void run() {\n              if (original != null) {\n                original.checkCanceled();\n                original.setText2(PropertiesBundle.message(\"searching.for.property.key.progress.text\", property.getUnescapedKey()));\n              }\n              processTextUsages(processedValueToFiles, property.getValue(), processedKeyToFiles, searchHelper, scope);\n              processTextUsages(processedKeyToFiles, property.getUnescapedKey(), processedValueToFiles, searchHelper, scope);\n            }\n          });\n        }\n        try {\n          job.scheduleAndWaitForResults();\n        }\n        catch (ProcessCanceledException e) {\n          throw e;\n        }\n        catch (Throwable e) {\n          LOG.error(e);\n        }\n\n        List<ProblemDescriptor> problemDescriptors = new ArrayList<ProblemDescriptor>();\n        Map<String, Set<String> > keyToDifferentValues = new HashMap<String, Set<String>>();\n        if (CHECK_DUPLICATE_KEYS || CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) prepareDuplicateKeysByFile(processedKeyToFiles, manager, keyToDifferentValues, problemDescriptors, file, original);\n        if (CHECK_DUPLICATE_VALUES) prepareDuplicateValuesByFile(processedValueToFiles, manager, problemDescriptors, file, original);\n        if (CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) processDuplicateKeysWithDifferentValues(keyToDifferentValues, processedKeyToFiles, problemDescriptors, manager, file, original);\n        if (!problemDescriptors.isEmpty()) {\n          addProblemElement(getRefManager().getReference(file), problemDescriptors.toArray(new ProblemDescriptor[problemDescriptors.size()]));\n        }\n      }\n    }, progress);\n  }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void prepareDuplicateValuesByFile(final Map<String, Set<PsiFile>> valueToFiles,\n                                                   final InspectionManager manager,\n                                                   final List<ProblemDescriptor> problemDescriptors,\n                                                   final PsiFile psiFile,\n                                                   final ProgressIndicator progress) {\n    for (String value : valueToFiles.keySet()) {\n      if (progress != null){\n        progress.setText2(InspectionsBundle.message(\"duplicate.property.value.progress.indicator.text\", value));\n        if (progress.isCanceled()) throw new ProcessCanceledException();\n      }\n      StringSearcher searcher = new StringSearcher(value);\n      StringBuffer message = new StringBuffer();\n      int duplicatesCount = 0;\n      Set<PsiFile> psiFilesWithDuplicates = valueToFiles.get(value);\n      for (PsiFile file : psiFilesWithDuplicates) {\n        CharSequence text = file.getViewProvider().getContents();\n        for (int offset = LowLevelSearchUtil.searchWord(text, 0, text.length(), searcher);\n             offset >= 0;\n             offset = LowLevelSearchUtil.searchWord(text, offset + searcher.getPattern().length(), text.length(), searcher)\n          ) {\n          PsiElement element = file.findElementAt(offset);\n          if (element != null && element.getParent() instanceof Property) {\n            final Property property = ((Property)element.getParent());\n            if (Comparing.equal(property.getValue(), value) && element.getStartOffsetInParent() != 0) {\n              if (duplicatesCount == 0){\n                message.append(InspectionsBundle.message(\"duplicate.property.value.problem.descriptor\", property.getValue()));\n              }\n              surroundWithHref(message, element, true);\n              duplicatesCount ++;\n            }\n          }\n        }\n      }\n      if (duplicatesCount > 1) {\n        problemDescriptors.add(manager.createProblemDescriptor(psiFile, message.toString(),\n                                                               (LocalQuickFix[])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n    }\n\n\n  }","id":66530,"modified_method":"private static void prepareDuplicateValuesByFile(final Map<String, Set<PsiFile>> valueToFiles,\n                                                   final InspectionManager manager,\n                                                   final List<ProblemDescriptor> problemDescriptors,\n                                                   final PsiFile psiFile,\n                                                   final ProgressIndicator progress) {\n    for (String value : valueToFiles.keySet()) {\n      if (progress != null){\n        progress.setText2(InspectionsBundle.message(\"duplicate.property.value.progress.indicator.text\", value));\n        if (progress.isCanceled()) throw new ProcessCanceledException();\n      }\n      StringSearcher searcher = new StringSearcher(value);\n      StringBuffer message = new StringBuffer();\n      int duplicatesCount = 0;\n      Set<PsiFile> psiFilesWithDuplicates = valueToFiles.get(value);\n      for (PsiFile file : psiFilesWithDuplicates) {\n        CharSequence text = file.getViewProvider().getContents();\n        for (int offset = LowLevelSearchUtil.searchWord(text, 0, text.length(), searcher);\n             offset >= 0;\n             offset = LowLevelSearchUtil.searchWord(text, offset + searcher.getPattern().length(), text.length(), searcher)\n          ) {\n          PsiElement element = file.findElementAt(offset);\n          if (element != null && element.getParent() instanceof Property) {\n            final Property property = (Property)element.getParent();\n            if (Comparing.equal(property.getValue(), value) && element.getStartOffsetInParent() != 0) {\n              if (duplicatesCount == 0){\n                message.append(InspectionsBundle.message(\"duplicate.property.value.problem.descriptor\", property.getValue()));\n              }\n              surroundWithHref(message, element, true);\n              duplicatesCount ++;\n            }\n          }\n        }\n      }\n      if (duplicatesCount > 1) {\n        problemDescriptors.add(manager.createProblemDescriptor(psiFile, message.toString(),\n                                                               (LocalQuickFix[])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n    }\n\n\n  }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n      return myProperty != null && myProperty.isValid();\n    }","id":66531,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n      return myProperty.isValid();\n    }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProblemDescriptor[] checkFile(@NotNull PsiFile file, @NotNull final InspectionManager manager, boolean isOnTheFly) {\n    if (!(file instanceof PropertiesFile)) return null;\n    final List<Property> properties = ((PropertiesFile)file).getProperties();\n    Module module = ModuleUtil.findModuleForPsiElement(file);\n    if (module == null) return null;\n    final List<ProblemDescriptor> descriptors = new SmartList<ProblemDescriptor>();\n\n    final GlobalSearchScope searchScope = GlobalSearchScope.moduleWithDependentsScope(module);\n    final ProgressIndicator original = ProgressManager.getInstance().getProgressIndicator();\n    final ProgressIndicator progress = original == null ? null : new ProgressWrapper(original);\n\n    ProgressManager.getInstance().runProcess(new Runnable() {\n      public void run() {\n        for (Property property : properties) {\n          if (original != null) {\n            original.setText(PropertiesBundle.message(\"searching.for.property.key.progress.text\", property.getUnescapedKey()));\n          }\n\n          final PsiReference usage = ReferencesSearch.search(property, searchScope, false).findFirst();\n          if (usage == null) {\n            final ASTNode propertyNode = property.getNode();\n            assert propertyNode != null;\n\n            ASTNode[] nodes = propertyNode.getChildren(null);\n            PsiElement key = nodes.length == 0 ? property : nodes[0].getPsi();\n            String description = PropertiesBundle.message(\"unused.property.problem.descriptor.name\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(key, description, RemovePropertyLocalFix.INSTANCE, ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n            descriptors.add(descriptor);\n          }\n        }\n      }\n    }, progress);\n    return descriptors.toArray(new ProblemDescriptor[descriptors.size()]);\n  }","id":66532,"modified_method":"public ProblemDescriptor[] checkFile(@NotNull PsiFile file, @NotNull final InspectionManager manager, boolean isOnTheFly) {\n    if (!(file instanceof PropertiesFile)) return null;\n    final List<Property> properties = ((PropertiesFile)file).getProperties();\n    Module module = ModuleUtil.findModuleForPsiElement(file);\n    if (module == null) return null;\n    final List<ProblemDescriptor> descriptors = new SmartList<ProblemDescriptor>();\n\n    final GlobalSearchScope searchScope = GlobalSearchScope.moduleWithDependentsScope(module);\n    final ProgressIndicator original = ProgressManager.getInstance().getProgressIndicator();\n    final ProgressIndicator progress = original == null ? null : new ProgressWrapper(original);\n    ProgressManager.getInstance().runProcess(new Runnable() {\n      public void run() {\n\n    final Job<?> job = JobScheduler.getInstance().createJob(\"Searching properties usages\", Job.DEFAULT_PRIORITY); // TODO: Better name, handle priority\n    for (final Property property : properties) {\n      job.addTask(new Runnable() {\n        public void run() {\n          if (original != null) {\n            original.checkCanceled();\n            original.setText(PropertiesBundle.message(\"searching.for.property.key.progress.text\", property.getUnescapedKey()));\n          }\n\n          final PsiReference usage = ReferencesSearch.search(property, searchScope, false).findFirst();\n          if (usage == null) {\n            final ASTNode propertyNode = property.getNode();\n            assert propertyNode != null;\n\n            ASTNode[] nodes = propertyNode.getChildren(null);\n            PsiElement key = nodes.length == 0 ? property : nodes[0].getPsi();\n            String description = PropertiesBundle.message(\"unused.property.problem.descriptor.name\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(key, description, RemovePropertyLocalFix.INSTANCE, ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n            synchronized (descriptors) {\n              descriptors.add(descriptor);\n            }\n          }\n        }\n      });\n    }\n    try {\n      job.scheduleAndWaitForResults();\n    }\n    catch (ProcessCanceledException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      LOG.error(e);\n    }\n      }\n    }, progress);\n    return descriptors.toArray(new ProblemDescriptor[descriptors.size()]);\n  }","commit_id":"7fba400db2484fb865f4c38b720980d76c7ebdb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSomeFilesWhileUserIsInactive(final FileContentQueue queue,\n                                                      final Consumer<VirtualFile> progressUpdater,\n                                                      final boolean processInReadAction) {\n    final ProgressIndicatorBase innerIndicator = new ProgressIndicatorBase();\n    final ApplicationAdapter canceller = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        innerIndicator.cancel();\n      }\n    };\n    final Application application = ApplicationManager.getApplication();\n    application.addApplicationListener(canceller);\n\n    final boolean[] isFinished = new boolean[1];\n    try {\n      ProgressManager.getInstance().runProcess(new Runnable() {\n        public void run() {\n          while (true) {\n            if (myProject.isDisposed()) return;\n            if (innerIndicator.isCanceled()) return;\n\n            final FileContent fileContent = queue.take();\n            if (fileContent == null) {\n              isFinished[0] = true;\n              return;\n            }\n\n            try {\n              final Runnable action = new Runnable() {\n                public void run() {\n                  innerIndicator.checkCanceled();\n\n                  if (myProject.isDisposed()) return;\n\n                  final VirtualFile file = fileContent.getVirtualFile();\n                  progressUpdater.consume(file);\n                  mySession.processFile(fileContent);\n                }\n              };\n              if (processInReadAction) {\n                application.runReadAction(action);\n              }\n              else {\n                action.run();\n              }\n            }\n            catch (ProcessCanceledException e) {\n              queue.pushback(fileContent);\n              return;\n            }\n          }\n        }\n      }, innerIndicator);\n    }\n    finally {\n      application.removeApplicationListener(canceller);\n    }\n\n    return isFinished[0];\n  }","id":66533,"modified_method":"private boolean processSomeFilesWhileUserIsInactive(final FileContentQueue queue,\n                                                      final Consumer<VirtualFile> progressUpdater,\n                                                      final boolean processInReadAction) {\n    final ProgressIndicatorBase innerIndicator = new ProgressIndicatorBase();\n    final ApplicationAdapter canceller = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        innerIndicator.cancel();\n      }\n    };\n    final Application application = ApplicationManager.getApplication();\n    application.addApplicationListener(canceller);\n\n    final boolean[] isFinished = new boolean[1];\n    try {\n      int threadsCount = Registry.intValue(\"caches.indexerThreadsCount\");\n      if (threadsCount == 1) {\n        Runnable process = new MyRunnable(innerIndicator, queue, isFinished, progressUpdater, processInReadAction, application);\n        ProgressManager.getInstance().runProcess(process, innerIndicator);\n      }\n      else {\n        Job<Object> job = JobScheduler.getInstance().createJob(\"Indexing\", Thread.NORM_PRIORITY);\n        for (int i = 0; i < threadsCount; i++) {\n          Runnable process = new MyRunnable(innerIndicator, queue, isFinished, progressUpdater, processInReadAction, application);\n          job.addTask(process);\n        }\n        try {\n          job.scheduleAndWaitForResults();\n        }\n        catch (Throwable throwable) {\n          LOG.error(throwable);\n        }\n      }\n    }\n    finally {\n      application.removeApplicationListener(canceller);\n    }\n\n    return isFinished[0];\n  }","commit_id":"2838bfb7166ec5675a0e24ebb9af219992b8b09f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileContent take() {\n    FileContent result;\n    synchronized (this) {\n      if (myPushbackBuffer != null) {\n        result = myPushbackBuffer;\n        myPushbackBuffer = null;\n        return result;\n      }\n    }\n\n    try {\n      result = myQueue.take();\n    }\n    catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n\n    final VirtualFile file = result.getVirtualFile();\n    if (file == null) {\n      return null;\n    }\n    if (result.getLength() < PersistentFS.MAX_INTELLISENSE_FILESIZE) {\n      synchronized (this) {\n        try {\n          myTotalSize -= result.getLength();\n        }\n        finally {\n          notifyAll();\n        }\n      }\n    }\n\n    return result;\n  }","id":66534,"modified_method":"@Nullable\n  public FileContent take() {\n    FileContent result;\n    synchronized (this) {\n      result = myPushbackBuffer.poll();\n      if (result != null) {\n        return result;\n      }\n    }\n\n    try {\n      result = myQueue.take();\n    }\n    catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n\n    final VirtualFile file = result.getVirtualFile();\n    if (file == null) {\n      try {\n        myQueue.put(result); // put it back to notify the others\n      }\n      catch (InterruptedException ignore) {\n        // should not happen\n      }\n      return null;\n    }\n    if (result.getLength() < PersistentFS.MAX_INTELLISENSE_FILESIZE) {\n      synchronized (this) {\n        try {\n          myTotalSize -= result.getLength();\n        }\n        finally {\n          notifyAll();\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"2838bfb7166ec5675a0e24ebb9af219992b8b09f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void pushback(@NotNull FileContent content) {\n    LOG.assertTrue(myPushbackBuffer == null, \"Pushback buffer is already full\");\n    myPushbackBuffer = content;\n  }","id":66535,"modified_method":"public synchronized void pushback(@NotNull FileContent content) {\n    myPushbackBuffer.add(content);\n  }","commit_id":"2838bfb7166ec5675a0e24ebb9af219992b8b09f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isEssentialStaticContextAbsent(final Match match) {\n    if (!myMethod.hasModifierProperty(PsiModifier.STATIC)) {\n      final PsiExpression instanceExpression = match.getInstanceExpression();\n      if (instanceExpression != null) return false;\n      if (isExternal(match)) return true;\n      if (PsiTreeUtil.isAncestor(myMethod.getContainingClass(), match.getMatchStart(), false) && RefactoringUtil.isInStaticContext(match.getMatchStart(), myMethod.getContainingClass())) return true;\n    }\n    return false;\n  }","id":66536,"modified_method":"private boolean isEssentialStaticContextAbsent(final Match match) {\n    if (!myMethod.hasModifierProperty(PsiModifier.STATIC)) {\n      final PsiExpression instanceExpression = match.getInstanceExpression();\n      if (instanceExpression != null) return false;\n      if (isExternal(match)) return true;\n\n      final PsiElement matchStart = match.getMatchStart();\n      final PsiClass containingClass = myMethod.getContainingClass();\n\n      if (PsiTreeUtil.isAncestor(containingClass, matchStart, false)) {\n        if (RefactoringUtil.isInStaticContext(matchStart, containingClass)) return true;\n      }\n      else {\n        PsiClass psiClass = PsiTreeUtil.getParentOfType(matchStart, PsiClass.class);\n        while (psiClass != null) {\n          if (InheritanceUtil.isInheritorOrSelf(psiClass, containingClass, true)) {\n            if (RefactoringUtil.isInStaticContext(matchStart, psiClass)) return true;\n            break;\n          }\n          psiClass = PsiTreeUtil.getParentOfType(psiClass, PsiClass.class);\n        }\n      }\n    }\n    return false;\n  }","commit_id":"9c1e06ac8d4d1970e1f55325638755e38ecaf1d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Match isDuplicateFragment(PsiElement candidate) {\n    if (candidate == myPattern[0]) return null;\n    PsiElement sibling = candidate;\n    ArrayList<PsiElement> candidates = new ArrayList<PsiElement>();\n    for (final PsiElement element : myPattern) {\n      if (sibling == null) return null;\n      if (!canBeEquivalent(element, sibling)) return null;\n      candidates.add(sibling);\n      sibling = sibling.getNextSibling();\n      while (sibling instanceof PsiWhiteSpace) {\n        sibling = sibling.getNextSibling();\n      }\n    }\n    LOG.assertTrue(myPattern.length == candidates.size());\n    if (myPattern.length == 1 && myPattern[0] instanceof PsiExpression) {\n      if (candidates.get(0) instanceof PsiExpression) {\n        final PsiExpression candidateExpression = (PsiExpression)candidates.get(0);\n        if (PsiUtil.isAccessedForWriting(candidateExpression)) return null;\n        final PsiType patternType = ((PsiExpression)myPattern[0]).getType();\n        final PsiType candidateType = candidateExpression.getType();\n        if (patternType != null && candidateType != null && !candidateType.isAssignableFrom(patternType)) {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n\n    }\n    final Match match = new Match(candidates.get(0), candidates.get(candidates.size() - 1));\n    for (int i = 0; i < myPattern.length; i++) {\n      if (!matchPattern(myPattern[i], candidates.get(i), candidates, match)) return null;\n    }\n\n    return match;\n  }","id":66537,"modified_method":"@Nullable\n  private Match isDuplicateFragment(PsiElement candidate) {\n    if (candidate == myPattern[0]) return null;\n    PsiElement sibling = candidate;\n    ArrayList<PsiElement> candidates = new ArrayList<PsiElement>();\n    for (final PsiElement element : myPattern) {\n      if (sibling == null) return null;\n      if (!canBeEquivalent(element, sibling)) return null;\n      candidates.add(sibling);\n      sibling = PsiTreeUtil.skipSiblingsForward(sibling, PsiWhiteSpace.class, PsiComment.class);\n    }\n    LOG.assertTrue(myPattern.length == candidates.size());\n    if (myPattern.length == 1 && myPattern[0] instanceof PsiExpression) {\n      if (candidates.get(0) instanceof PsiExpression) {\n        final PsiExpression candidateExpression = (PsiExpression)candidates.get(0);\n        if (PsiUtil.isAccessedForWriting(candidateExpression)) return null;\n        final PsiType patternType = ((PsiExpression)myPattern[0]).getType();\n        final PsiType candidateType = candidateExpression.getType();\n        if (patternType != null && candidateType != null && !candidateType.isAssignableFrom(patternType)) {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n\n    }\n    final Match match = new Match(candidates.get(0), candidates.get(candidates.size() - 1));\n    for (int i = 0; i < myPattern.length; i++) {\n      if (!matchPattern(myPattern[i], candidates.get(i), candidates, match)) return null;\n    }\n\n    return match;\n  }","commit_id":"1c704759f04028086a9ebd571d3626cd7402d624","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processMatch(Match match) throws IncorrectOperationException {\n      if (RefactoringUtil.isInStaticContext(match.getMatchStart(), myMethod.getContainingClass())) {\n        myMethod.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n      }\n      final PsiElementFactory factory = myMethod.getManager().getElementFactory();\n      final boolean needQualifier = match.getInstanceExpression() != null;\n      final @NonNls String text = needQualifier ?  \"q.\" + myMethod.getName() + \"()\": myMethod.getName() + \"()\";\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)factory.createExpressionFromText(text, null);\n      methodCallExpression = (PsiMethodCallExpression)CodeStyleManager.getInstance(myMethod.getManager()).reformat(methodCallExpression);\n      final PsiParameter[] parameters = myMethod.getParameterList().getParameters();\n      for (final PsiParameter parameter : parameters) {\n        methodCallExpression.getArgumentList().add(match.getParameterValue(parameter));\n      }\n      if (needQualifier) {\n        methodCallExpression.getMethodExpression().getQualifierExpression().replace(match.getInstanceExpression());\n      }\n      match.replace(methodCallExpression, null);\n    }","id":66538,"modified_method":"public void processMatch(Match match) throws IncorrectOperationException {\n      final PsiClass containingClass = myMethod.getContainingClass();\n      if (isEssentialStaticContextAbsent(match)) {\n        myMethod.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n      }\n      final PsiElementFactory factory = myMethod.getManager().getElementFactory();\n      final boolean needQualifier = match.getInstanceExpression() != null;\n      final boolean needStaticQualifier = isExternal(match);\n      final @NonNls String text = needQualifier || needStaticQualifier ?  \"q.\" + myMethod.getName() + \"()\": myMethod.getName() + \"()\";\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)factory.createExpressionFromText(text, null);\n      methodCallExpression = (PsiMethodCallExpression)CodeStyleManager.getInstance(myMethod.getManager()).reformat(methodCallExpression);\n      final PsiParameter[] parameters = myMethod.getParameterList().getParameters();\n      for (final PsiParameter parameter : parameters) {\n        methodCallExpression.getArgumentList().add(match.getParameterValue(parameter));\n      }\n      if (needQualifier || needStaticQualifier) {\n        final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n        LOG.assertTrue(qualifierExpression != null);\n        if (needQualifier) {\n          qualifierExpression.replace(match.getInstanceExpression());\n        } else {\n          qualifierExpression.replace(factory.createReferenceExpression(containingClass));\n        }\n      }\n      VisibilityUtil.escalateVisibility(myMethod, match.getMatchStart());\n      match.replace(methodCallExpression, null);\n    }","commit_id":"1c704759f04028086a9ebd571d3626cd7402d624","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String getConfirmDuplicatePrompt(Match match) {\n      if (RefactoringUtil.isInStaticContext(match.getMatchStart(), myMethod.getContainingClass()) && !myMethod.hasModifierProperty(PsiModifier.STATIC)) {\n      return RefactoringBundle.message(\"replace.this.code.fragment.and.make.method.static\");\n    }\n    return RefactoringBundle.message(\"replace.this.code.fragment\");\n    }","id":66539,"modified_method":"@NotNull\n    public String getConfirmDuplicatePrompt(final Match match) {\n      final PsiElement matchStart = match.getMatchStart();\n      final boolean needToEscalateVisibility = !PsiUtil.isAccessible(myMethod, matchStart, null);\n      if (needToEscalateVisibility) {\n        try {\n          final String visibility = VisibilityUtil.getPossibleVisibility(myMethod, matchStart);\n          @NonNls final String visibilityPresentation = visibility == PsiModifier.PACKAGE_LOCAL ? \"package local\" : visibility;\n          if (isEssentialStaticContextAbsent(match)) {\n            return RefactoringBundle.message(\"replace.this.code.fragment.and.make.method.static.visible\", visibilityPresentation);\n          } else {\n            return RefactoringBundle.message(\"replace.this.code.fragment.and.make.method.visible\", visibilityPresentation);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      if (isEssentialStaticContextAbsent(match)) {\n        return RefactoringBundle.message(\"replace.this.code.fragment.and.make.method.static\");\n      }\n      return RefactoringBundle.message(\"replace.this.code.fragment\");\n    }","commit_id":"1c704759f04028086a9ebd571d3626cd7402d624","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiElement element = file.findElementAt(offset);\n    final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n    if (method == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"locate.caret.inside.a.method\"));\n      showErrorMessage(message, project);\n      return;\n    }\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) return;\n    if (method.isConstructor()) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"replace.with.method.call.does.not.work.for.constructors\"));\n      showErrorMessage(message, project);\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.does.not.have.a.body\", method.getName()));\n      showErrorMessage(message, project);\n      return;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length == 0) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.has.an.empty.body\", method.getName()));\n\n      showErrorMessage(message, project);\n      return;\n    }\n    final DuplicatesFinder duplicatesFinder;\n    final PsiElement[] pattern;\n    if (statements.length != 1 || !(statements[0] instanceof PsiReturnStatement)) {\n      pattern = statements;\n    } else {\n      final PsiExpression returnValue = ((PsiReturnStatement)statements[0]).getReturnValue();\n      if (returnValue != null) {\n        pattern = new PsiElement[]{returnValue};\n      }\n      else {\n        pattern = statements;\n      }\n    }\n    duplicatesFinder = new DuplicatesFinder(pattern, Arrays.asList(method.getParameterList().getParameters()),\n                                            new ArrayList<PsiVariable>());\n\n    final List<Match> duplicates = duplicatesFinder.findDuplicates(file);\n    if (duplicates.isEmpty()) {\n      final String message =\n        RefactoringBundle.message(\"idea.has.not.found.any.code.that.can.be.replaced.with.method.call\", ApplicationNamesInfo.getInstance().getProductName());\n      Messages.showInfoMessage(project, message, REFACTORING_NAME);\n      return;\n    }\n    final int duplicatesNo = duplicates.size();\n    final ArrayList<RangeHighlighter> highlighters = new ArrayList<RangeHighlighter>();\n    for (final Match match : duplicates) {\n      DuplicatesImpl.highlightMatch(project, editor, match, highlighters);\n    }\n    final MethodDuplicatesDialog dialog = new MethodDuplicatesDialog(project, method, duplicatesNo);\n    dialog.show();\n    for (final RangeHighlighter rangeHighlighter : highlighters) {\n      HighlightManager.getInstance(project).removeSegmentHighlighter(editor, rangeHighlighter);\n    }\n    if (!dialog.isOK()) return;\n    WindowManager.getInstance().getStatusBar(project).setInfo(getStatusMessage(duplicatesNo));\n    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n      public void run() {\n        PostprocessReformattingAspect.getInstance(project).postponeFormattingInside(new Runnable () {\n          public void run() {\n            DuplicatesImpl.invoke(project, editor, new MethodDuplicatesMatchProvider(method, duplicates));\n          }\n        });\n      }\n    }, REFACTORING_NAME, null);\n\n    WindowManager.getInstance().getStatusBar(project).setInfo(\"\");\n  }","id":66540,"modified_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiElement element = file.findElementAt(offset);\n    final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n    if (method == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"locate.caret.inside.a.method\"));\n      showErrorMessage(message, project);\n      return;\n    }\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) return;\n    if (method.isConstructor()) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"replace.with.method.call.does.not.work.for.constructors\"));\n      showErrorMessage(message, project);\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.does.not.have.a.body\", method.getName()));\n      showErrorMessage(message, project);\n      return;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length == 0) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.has.an.empty.body\", method.getName()));\n\n      showErrorMessage(message, project);\n      return;\n    }\n    AnalysisScope scope = new AnalysisScope(file);\n    final Module module = ModuleUtil.findModuleForPsiElement(file);\n    BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.title\", REFACTORING_NAME),\n                                                                RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.message\"),\n                                                                project, scope, module != null ? module.getName() : null, false);\n    dlg.show();\n    if (dlg.isOK()) {\n      scope = dlg.getScope(((InspectionManagerEx)InspectionManager.getInstance(project)).getUIOptions(), scope, project, module);\n\n      invokeOnScope(project, method, scope);\n    }\n  }","commit_id":"1c704759f04028086a9ebd571d3626cd7402d624","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invokeAdded(DependencyService service) {\n    \tif (m_debug) {\n    \t\tlog(\"invoke added due to configure. (component is activated)\");\n    \t}\n        ServiceReference[] refs = m_tracker.getServiceReferences();\n        if (refs != null) {\n            for (int i = 0; i < refs.length; i++) {\n                ServiceReference sr = refs[i];\n                Object svc = m_context.getService(sr);\n                invokeAdded(service, sr, svc);\n            }\n        }\n    }","id":66541,"modified_method":"public void invokeAdded(DependencyService service) {\n\t\tdebugLog(\"invoke added due to configure. (component is activated)\");\n        ServiceReference[] refs = m_tracker.getServiceReferences();\n        if (refs != null) {\n            for (int i = 0; i < refs.length; i++) {\n                ServiceReference sr = refs[i];\n                Object svc = m_context.getService(sr);\n                invokeAdded(service, sr, svc);\n            }\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void invoke(DependencyService dependencyService, ServiceReference reference, Object service, String name) {\n    \tif (m_debug) {\n    \t\tlog(\"invoke: \" + name);\n    \t}\n        if (name != null) {\n            dependencyService.invokeCallbackMethod(getCallbackInstances(dependencyService), name, \n                new Class[][] {\n                    {Component.class, ServiceReference.class, m_trackedServiceName}, {Component.class, ServiceReference.class, Object.class}, {Component.class, ServiceReference.class}, {Component.class, m_trackedServiceName}, {Component.class, Object.class}, {Component.class}, {Component.class, Map.class, m_trackedServiceName},\n                    {ServiceReference.class, m_trackedServiceName}, {ServiceReference.class, Object.class}, {ServiceReference.class}, {m_trackedServiceName}, {Object.class}, {}, {Map.class, m_trackedServiceName}\n                },\n                new Object[][] {\n                    {dependencyService, reference, service}, {dependencyService, reference, service}, {dependencyService, reference}, {dependencyService, service}, {dependencyService, service}, {dependencyService}, {dependencyService, new ServicePropertiesMap(reference), service},\n                    {reference, service}, {reference, service}, {reference}, {service}, {service}, {}, {new ServicePropertiesMap(reference), service}\n                }    \n            );\n        }\n    }","id":66542,"modified_method":"public void invoke(DependencyService dependencyService, ServiceReference reference, Object service, String name) {\n\t\tdebugLog(\"invoke: \" + name);\n        if (name != null) {\n            dependencyService.invokeCallbackMethod(getCallbackInstances(dependencyService), name, \n                new Class[][] {\n                    {Component.class, ServiceReference.class, m_trackedServiceName}, {Component.class, ServiceReference.class, Object.class}, {Component.class, ServiceReference.class}, {Component.class, m_trackedServiceName}, {Component.class, Object.class}, {Component.class}, {Component.class, Map.class, m_trackedServiceName},\n                    {ServiceReference.class, m_trackedServiceName}, {ServiceReference.class, Object.class}, {ServiceReference.class}, {m_trackedServiceName}, {Object.class}, {}, {Map.class, m_trackedServiceName}\n                },\n                new Object[][] {\n                    {dependencyService, reference, service}, {dependencyService, reference, service}, {dependencyService, reference}, {dependencyService, service}, {dependencyService, service}, {dependencyService}, {dependencyService, new ServicePropertiesMap(reference), service},\n                    {reference, service}, {reference, service}, {reference}, {service}, {service}, {}, {new ServicePropertiesMap(reference), service}\n                }    \n            );\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"private void log(String message) {\n    \tm_logger.log(Logger.LOG_DEBUG, message);\n    }","id":66543,"modified_method":"private void debugLog(String message) {\n    \tif (m_debug) {\n    \t\tm_logger.log(Logger.LOG_DEBUG, \"[\" + m_debugKey + \"] \" + message);\n    \t}\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"private boolean isLastService(DependencyService dependencyService, ServiceReference reference, Object object, Long serviceId) {\n\t\t// get the collection of rankings\n\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\n\t\tMap rankings = null; /* <Integer, Tuple> */\n\t\tif (componentMap != null) {\n\t\t\trankings = (Map) componentMap.get(serviceId);\n\t\t}\n\t\t// if there is only one element left in the collection of rankings\n\t\t// and this last element has the same ranking as the supplied service (in other words, it is the same)\n\t\t// then this is the last service\n\t\t// NOTE: it is possible that there is only one element, but that it's not equal to the supplied service,\n\t\t// because an aspect on top of the original service is being removed (but the original service is still\n\t\t// there). That in turn triggers:\n\t\t// 1) a call to added(original-service)\n\t\t// 2) that causes a swap\n\t\t// 3) a call to removed(aspect-service) <-- that's what we're talking about\n\t\tif (m_debug) {\n\t\t\tlog(m_componentByRank.toString());\n\t\t}\n\t\treturn (componentMap != null && rankings != null && rankings.size() == 1 && ((Entry)rankings.entrySet().iterator().next()).getKey()\n\t\t\t\t.equals(ServiceUtil.getRankingAsInteger(reference)));\n\t}","id":66544,"modified_method":"private boolean isLastService(DependencyService dependencyService, ServiceReference reference, Object object, Long serviceId) {\n\t\t// get the collection of rankings\n\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\n\t\tMap rankings = null; /* <Integer, Tuple> */\n\t\tif (componentMap != null) {\n\t\t\trankings = (Map) componentMap.get(serviceId);\n\t\t}\n\t\t// if there is only one element left in the collection of rankings\n\t\t// and this last element has the same ranking as the supplied service (in other words, it is the same)\n\t\t// then this is the last service\n\t\t// NOTE: it is possible that there is only one element, but that it's not equal to the supplied service,\n\t\t// because an aspect on top of the original service is being removed (but the original service is still\n\t\t// there). That in turn triggers:\n\t\t// 1) a call to added(original-service)\n\t\t// 2) that causes a swap\n\t\t// 3) a call to removed(aspect-service) <-- that's what we're talking about\n\t\tdebugLog(\"last service: \" + m_componentByRank.toString());\n\t\treturn (componentMap != null && rankings != null && rankings.size() == 1 && ((Entry)rankings.entrySet().iterator().next()).getKey()\n\t\t\t\t.equals(ServiceUtil.getRankingAsInteger(reference)));\n\t}","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void addedService(ServiceReference ref, Object service) {\n    \tif (m_debug) {\n    \t\tlog(\"addedservice: \" + ref);\n    \t}\n        boolean makeAvailable = makeAvailable();\n        \n        Object[] services;\n        synchronized (this) {\n            services = m_services.toArray();\n        }\n        for (int i = 0; i < services.length; i++) {\n            DependencyService ds = (DependencyService) services[i];\n            if (makeAvailable) {\n                if (ds.isInstantiated() && isInstanceBound() && isRequired()) {\n                \tif (m_debug) {\n                \t\tlog(\"invoke added: \" + ref);\n                \t}\n                    invokeAdded(ds, ref, service); //**\n                }\n                // The dependency callback will be deferred until all required dependency are available.\n                if (m_debug) {\n                \tlog(\"dependency available: \" + ref);\n                }\n                ds.dependencyAvailable(this); //**\n                if (!isRequired()) {\n                    // For optional dependency, we always invoke callback, because at this point, we know\n                    // that the service has been started, and the service start method has been called.\n                    // (See the ServiceImpl.bindService method, which will activate optional dependencies using \n                    // startTrackingOptional() method).\n                \tif (m_debug) {\n                \t\tlog(\"invoke added: \" + ref);\n                \t}\n                    invokeAdded(ds, ref, service); //**\n                }\n            }\n            else {\n            \tif (m_debug) {\n            \t\tlog(\"dependency changed: \" + ref);\n            \t}\n                ds.dependencyChanged(this); //**\n                // At this point, either the dependency is optional (meaning that the service has been started,\n                // because if not, then our dependency would not be active); or the dependency is required,\n                // meaning that either the service is not yet started, or already started.\n                // In all cases, we have to inject the required dependency.\n                \n                // we only try to invoke the method here if we are really already instantiated\n                if (ds.isInstantiated() && ds.getCompositionInstances().length > 0) {\n                \tif (m_debug) {\n                \t\tlog(\"invoke added: \" + ref);\n                \t}\n                    invokeAdded(ds, ref, service); //**\n                }\n            }\n        }\n    }","id":66545,"modified_method":"public void addedService(ServiceReference ref, Object service) {\n\t\tdebugLog(\"addedservice: \" + ref);\n        boolean makeAvailable = makeAvailable();\n        \n        Object[] services;\n        synchronized (this) {\n            services = m_services.toArray();\n        }\n        for (int i = 0; i < services.length; i++) {\n            DependencyService ds = (DependencyService) services[i];\n            if (makeAvailable) {\n                if (ds.isInstantiated() && isInstanceBound() && isRequired()) {\n            \t\tdebugLog(\"invoke added: \" + ref);\n                    invokeAdded(ds, ref, service); //**\n                }\n                // The dependency callback will be deferred until all required dependency are available.\n            \tdebugLog(\"dependency available: \" + ref);\n                ds.dependencyAvailable(this); //**\n                if (!isRequired()) {\n                    // For optional dependency, we always invoke callback, because at this point, we know\n                    // that the service has been started, and the service start method has been called.\n                    // (See the ServiceImpl.bindService method, which will activate optional dependencies using \n                    // startTrackingOptional() method).\n            \t\tdebugLog(\"invoke added: \" + ref);\n                    invokeAdded(ds, ref, service); //**\n                }\n            }\n            else {\n        \t\tdebugLog(\"dependency changed: \" + ref);\n                ds.dependencyChanged(this); //**\n                // At this point, either the dependency is optional (meaning that the service has been started,\n                // because if not, then our dependency would not be active); or the dependency is required,\n                // meaning that either the service is not yet started, or already started.\n                // In all cases, we have to inject the required dependency.\n                \n                // we only try to invoke the method here if we are really already instantiated\n                if (ds.isInstantiated() && ds.getCompositionInstances().length > 0) {\n            \t\tdebugLog(\"invoke added: \" + ref);\n                    invokeAdded(ds, ref, service); //**\n                }\n            }\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void removedService(ServiceReference ref, Object service) {\n    \tif (m_debug) {\n    \t\tlog(\"removedservice: \" + ref);\n    \t}\n        boolean makeUnavailable = makeUnavailable();\n        if (m_debug) {\n        \tlog(\"make unavailable: \" + makeUnavailable);\n        }\n        Object[] services;\n        synchronized (this) {\n            services = m_services.toArray();\n        }\n\n        for (int i = 0; i < services.length; i++) {\n            DependencyService ds = (DependencyService) services[i];\n            if (makeUnavailable) {\n                ds.dependencyUnavailable(this);\n                // when the dependency is optional or the dependency is instance bound and the component is instantiated (and the dependency is required)\n                // then remove is invoked. In other cases the removed has been when the component was unconfigured.\n                if (!isRequired() || (ds.isInstantiated() && isInstanceBound())) {\n                    invokeRemoved(ds, ref, service);\n                }\n            }\n            else {\n                ds.dependencyChanged(this);\n                invokeRemoved(ds, ref, service);\n            }\n        }\n        // unget what we got in addingService (see ServiceTracker 701.4.1)\n        m_context.ungetService(ref);\n\n    }","id":66546,"modified_method":"public void removedService(ServiceReference ref, Object service) {\n\t\tdebugLog(\"removedservice: \" + ref + \", rank: \" + ref.getProperty(\"service.ranking\"));\n        boolean makeUnavailable = makeUnavailable();\n    \tdebugLog(\"make unavailable: \" + makeUnavailable);\n        Object[] services;\n        synchronized (this) {\n            services = m_services.toArray();\n        }\n\n        for (int i = 0; i < services.length; i++) {\n            DependencyService ds = (DependencyService) services[i];\n            if (makeUnavailable) {\n                ds.dependencyUnavailable(this);\n                // when the dependency is optional or the dependency is instance bound and the component is instantiated (and the dependency is required)\n                // then remove is invoked. In other cases the removed has been when the component was unconfigured.\n                if (!isRequired() || (ds.isInstantiated() && isInstanceBound())) {\n                    invokeRemoved(ds, ref, service);\n                }\n            }\n            else {\n                ds.dependencyChanged(this);\n                invokeRemoved(ds, ref, service);\n            }\n        }\n        // unget what we got in addingService (see ServiceTracker 701.4.1)\n       \tm_context.ungetService(ref);\n\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void invokeAdded(DependencyService dependencyService, ServiceReference reference, Object service) {\n    \tif (m_debug) {\n    \t\tlog(\"invoke added\");\n    \t}\n        boolean added = false;\n        synchronized (m_sr) {\n            Set set = (Set) m_sr.get(dependencyService);\n            if (set == null) {\n                set = new HashSet();\n                m_sr.put(dependencyService, set);\n            }\n            added = set.add(new Tuple(reference, service));\n        }\n        if (added) { \n        \t// when a changed callback is specified we might not call the added callback just yet\n        \tif (m_callbackSwapped != null) {\n        \t\thandleAspectAwareAdded(dependencyService, reference, service);\n        \t}\n        \telse {\n        \t\tinvoke(dependencyService, reference, service, m_callbackAdded);\n        \t}\n        }\n    }","id":66547,"modified_method":"public void invokeAdded(DependencyService dependencyService, ServiceReference reference, Object service) {\n\t\tdebugLog(\"invoke added\");\n        boolean added = false;\n        synchronized (m_sr) {\n            Set set = (Set) m_sr.get(dependencyService);\n            if (set == null) {\n                set = new HashSet();\n                m_sr.put(dependencyService, set);\n            }\n            added = set.add(new Tuple(reference, service));\n        }\n        if (added) { \n        \t// when a changed callback is specified we might not call the added callback just yet\n        \tif (m_callbackSwapped != null) {\n        \t\thandleAspectAwareAdded(dependencyService, reference, service);\n        \t}\n        \telse {\n        \t\tinvoke(dependencyService, reference, service, m_callbackAdded);\n        \t}\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"private void handleAspectAwareAdded(final DependencyService dependencyService, final ServiceReference reference, final Object service) {\n    \tif (m_debug) {\n    \t\tlog(\"aspectawareadded: \" + reference.getProperty(\"service.ranking\"));\n    \t}\n\t\tif (componentIsDependencyManagerFactory(dependencyService)) {\n\t\t\t// component is either aspect or adapter factory instance, these must be ignored.\n\t\t\treturn;\n\t\t}\n\t\tboolean invokeAdded = false;\n\t\tboolean invokeSwapped = false;\n\t\tInteger ranking = ServiceUtil.getRankingAsInteger(reference);\n\t\tTuple newHighestRankedService = null;\n\t\tTuple prevHighestRankedService = null;\n\t\tRunnable callbackRunnable = null;\n\t\tMap rankings = null;\n\t\tsynchronized (m_componentByRank) {\n\t\t\tLong originalServiceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\tif (componentMap == null) {\n\t\t\t\t// create new componentMap\n\t\t\t\tcomponentMap = new HashMap(); /* <Long, Map<Integer, Tuple>> */\n\t\t\t\tm_componentByRank.put(dependencyService, componentMap);\n\t\t\t}\n\t\t\trankings = (Map) componentMap.get(originalServiceId); /* <Integer, Tuple> */\n\t\t\tif (rankings == null) {\n\t\t\t\t// new component added\n\t\t\t\trankings = new HashMap(); /* <Integer, Tuple> */\n\t\t\t\tcomponentMap.put(originalServiceId, rankings);\n\t\t\t\trankings.put(ranking, new Tuple(reference, service));\n\t\t\t\tinvokeAdded = true;\n\t\t\t} \n\t\t\t\n\t\t\tif (!invokeAdded) {\n\t\t\t\t// current highest ranked\n\t\t\t\tprevHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t\tnewHighestRankedService = swapHighestRankedService(dependencyService, originalServiceId, reference, service, ranking);\n\t\t\t\tif (m_debug) {\n\t\t\t\t\tlog(\"prevhigh: \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \", new high: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\t}\n\t\t\t\tif (!prevHighestRankedService.getServiceReference().equals(newHighestRankedService.getServiceReference())) {\n\t\t\t\t\t// new highest ranked service\n\t\t\t\t\tif (m_debug) {\n\t\t\t\t\t\tlog(\"New highest ranked to swap to\");\n\t\t\t\t\t}\n\t\t\t\t\tinvokeSwapped = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (m_debug) {\n\t\t\t\t\t\tlog(\"Ignoring lower ranked or irrelevant swap\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_debug) {\n\t\t\t\tlog(m_componentByRank.toString());\n\t\t\t}\n\t\t\t\n\t\t\t// up until this point should be synchronized on m_componentsByRank to keep integrity of the administration and consequences\n\t\t\t// then the do phase comes, here we want to guarantee the effects of this operation are done like they were synchronized, however\n\t\t\t// synchronization on m_componentsByRank to too course grained here, so we'd like to switch to synchronization on the\n\t\t\t// original service id, therefore we're using our own guarded block to ensure the correct order.\n\t\t\t\n\t\t\tif (invokeAdded) {\n\t\t\t\tif (m_debug) {\n\t\t\t\t\tlog(\"invoke added: \" + reference.getProperty(\"service.ranking\"));\n\t\t\t\t}\n\t\t\t\tcallbackRunnable = createCallbackRunnable(dependencyService, reference, service, m_callbackAdded);\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t} else if (invokeSwapped) {\n\t\t\t\tif (m_debug) {\n\t\t\t\t\tlog(\"invoke swapped: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \" replacing \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\t}\n\t\t\t\tcallbackRunnable = createSwapRunnable(dependencyService, prevHighestRankedService.getServiceReference(), prevHighestRankedService.getService(), newHighestRankedService.getServiceReference(), newHighestRankedService.getService());\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t}    \t\n\t\t}\n\t\tif (callbackRunnable != null) {\n\t\t\twaitForCallbackLock(callbackRunnable);\n\t\t\tsynchronized (rankings) {\n\t\t\t\treleaseCallback(callbackRunnable);\n\t\t\t\texecute(callbackRunnable);\n\t\t\t}\n\t\t}\n    }","id":66548,"modified_method":"private void handleAspectAwareAdded(final DependencyService dependencyService, final ServiceReference reference, final Object service) {\n\t\tdebugLog(\"aspectawareadded: \" + reference.getProperty(\"service.ranking\"));\n\t\tif (componentIsDependencyManagerFactory(dependencyService)) {\n\t\t\t// component is either aspect or adapter factory instance, these must be ignored.\n\t\t\treturn;\n\t\t}\n\t\tboolean invokeAdded = false;\n\t\tboolean invokeSwapped = false;\n\t\tInteger ranking = ServiceUtil.getRankingAsInteger(reference);\n\t\tTuple newHighestRankedService = null;\n\t\tTuple prevHighestRankedService = null;\n\t\tRunnable callbackRunnable = null;\n\t\tMap rankings = null;\n\t\tsynchronized (m_componentByRank) {\n\t\t\tLong originalServiceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\tif (componentMap == null) {\n\t\t\t\t// create new componentMap\n\t\t\t\tcomponentMap = new HashMap(); /* <Long, Map<Integer, Tuple>> */\n\t\t\t\tm_componentByRank.put(dependencyService, componentMap);\n\t\t\t}\n\t\t\trankings = (Map) componentMap.get(originalServiceId); /* <Integer, Tuple> */\n\t\t\tif (rankings == null) {\n\t\t\t\t// new component added\n\t\t\t\trankings = new HashMap(); /* <Integer, Tuple> */\n\t\t\t\tcomponentMap.put(originalServiceId, rankings);\n\t\t\t\trankings.put(ranking, new Tuple(reference, service));\n\t\t\t\tinvokeAdded = true;\n\t\t\t} \n\t\t\t\n\t\t\tif (!invokeAdded) {\n\t\t\t\t// current highest ranked\n\t\t\t\tprevHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t\tnewHighestRankedService = swapHighestRankedService(dependencyService, originalServiceId, reference, service, ranking);\n\t\t\t\tdebugLog(\"prevhigh: \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \", new high: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\tif (!prevHighestRankedService.getServiceReference().equals(newHighestRankedService.getServiceReference())) {\n\t\t\t\t\t// new highest ranked service\n\t\t\t\t\tdebugLog(\"New highest ranked to swap to\");\n\t\t\t\t\tinvokeSwapped = true;\n\t\t\t\t} else {\n\t\t\t\t\tdebugLog(\"Ignoring lower ranked or irrelevant swap\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebugLog(m_componentByRank.toString());\n\t\t\t\n\t\t\t// up until this point should be synchronized on m_componentsByRank to keep integrity of the administration and consequences\n\t\t\t// then the do phase comes, here we want to guarantee the effects of this operation are done like they were synchronized, however\n\t\t\t// synchronization on m_componentsByRank to too course grained here, so we'd like to switch to synchronization on the\n\t\t\t// original service id, therefore we're using our own guarded block to ensure the correct order.\n\t\t\t\n\t\t\tif (invokeAdded) {\n\t\t\t\tdebugLog(\"invoke added: \" + reference.getProperty(\"service.ranking\"));\n\t\t\t\tcallbackRunnable = createCallbackRunnable(dependencyService, reference, service, m_callbackAdded);\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t} else if (invokeSwapped) {\n\t\t\t\tdebugLog(\"invoke swapped: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \" replacing \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\tcallbackRunnable = createSwapRunnable(dependencyService, prevHighestRankedService.getServiceReference(), prevHighestRankedService.getService(), newHighestRankedService.getServiceReference(), newHighestRankedService.getService());\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t}    \t\n\t\t}\n\t\tif (callbackRunnable != null) {\n\t\t\twaitForCallbackLock(callbackRunnable);\n\t\t\tsynchronized (rankings) {\n\t\t\t\treleaseCallback(callbackRunnable);\n\t\t\t\texecute(callbackRunnable);\n\t\t\t}\n\t\t}\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void invokeRemoved(DependencyService dependencyService, ServiceReference reference, Object service) {\n    \tif (m_debug) {\n    \t\tlog(\"invoke removed\");\n    \t}\n        boolean removed = false;\n        synchronized (m_sr) {\n            Set set = (Set) m_sr.get(dependencyService);\n            removed = (set != null && set.remove(new Tuple(reference, service)));\n        }\n        if (m_debug) {\n        \tlog(\"removed: \" + removed);\n        }\n        if (removed) {\n        \tif (m_callbackSwapped != null) {\n        \t\thandleAspectAwareRemoved(dependencyService, reference, service);\n        \t}\n        \telse {\n        \t\tinvoke(dependencyService, reference, service, m_callbackRemoved);\n        \t}\n        }\n    }","id":66549,"modified_method":"public void invokeRemoved(DependencyService dependencyService, ServiceReference reference, Object service) {\n\t\tdebugLog(\"invoke removed\");\n        boolean removed = false;\n        synchronized (m_sr) {\n            Set set = (Set) m_sr.get(dependencyService);\n            removed = (set != null && set.remove(new Tuple(reference, service)));\n        }\n    \tdebugLog(\"removed: \" + removed);\n        if (removed) {\n        \tif (m_callbackSwapped != null) {\n        \t\thandleAspectAwareRemoved(dependencyService, reference, service);\n        \t}\n        \telse {\n        \t\tinvoke(dependencyService, reference, service, m_callbackRemoved);\n        \t}\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"private void handleAspectAwareRemoved(DependencyService dependencyService, ServiceReference reference, Object service) {\n\t\tif (m_debug) {\n\t\t\tlog(\"aspectawareremoved: \" + reference.getProperty(\"service.ranking\"));\n\t\t}\n\t\tif (componentIsDependencyManagerFactory(dependencyService)) {\n\t\t\t// component is either aspect or adapter factory instance, these must be ignored.\n\t\t\treturn;\n\t\t}\n\t\t// we might need to swap here too!\n\t\tboolean invokeRemoved = false;\n\t\tLong serviceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\tTuple prevHighestRankedService = null;\n\t\tTuple newHighestRankedService = null;\n\t\tboolean invokeSwapped = false;\n\t\tMap rankings = null;\n\t\tRunnable callbackRunnable = null;\n\t\tsynchronized (m_componentByRank) {\n\t\t\tLong originalServiceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\t\tif (isLastService(dependencyService, reference, service, serviceId)) {\n\t\t\t\tinvokeRemoved = true;\n\t\t\t} else {\n\t\t\t\t// not the last service, but should we swap?\n\t\t\t\tprevHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t\tif (prevHighestRankedService.getServiceReference().equals(reference)) {\n\t\t\t\t\t// swapping out\n\t\t\t\t\tif (m_debug) {\n\t\t\t\t\t\tlog(\"Swap out on remove!\");\n\t\t\t\t\t}\n\t\t\t\t\tinvokeSwapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_debug) {\n\t\t\t\tlog(\"is last service: \" + invokeRemoved);\n\t\t\t}\n\t\t\t// cleanup\n\t\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\tif (componentMap != null) {\n\t\t\t\trankings = (Map) componentMap.get(originalServiceId); /* <Integer, Tuple> */\n\t\t\t\tList rankingsToRemove = new ArrayList();\n\t\t\t\tfor (Iterator entryIterator = rankings.entrySet().iterator(); entryIterator.hasNext(); ) {\n\t\t\t\t\tEntry mapEntry = (Entry) entryIterator.next();\n\t\t\t\t\tif (((Tuple)mapEntry.getValue()).getServiceReference().equals(reference)) {\n\t\t\t\t\t\t// remove the reference\n\t\t\t\t\t\t// rankings.remove(mapEntry.getKey());\n\t\t\t\t\t\trankingsToRemove.add(mapEntry.getKey());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Iterator rankingIterator = rankingsToRemove.iterator(); rankingIterator.hasNext(); ) {\n\t\t\t\t\trankings.remove(rankingIterator.next());\n\t\t\t\t}\n\t\t\t\tif (rankings.size() == 0) {\n\t\t\t\t\tcomponentMap.remove(originalServiceId);\n\t\t\t\t}\n\t\t\t\tif (componentMap.size() == 0) {\n\t\t\t\t\tm_componentByRank.remove(dependencyService);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// determine current highest ranked service\n\t\t\tif (invokeSwapped) {\n\t\t\t\tnewHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t}\n\t\t\tif (invokeRemoved) {\n\t\t\t\t// handle invoke outside the sync block since we won't know what will happen there\n\t\t\t\tif (m_debug) {\n\t\t\t\t\tlog(\"invoke removed: \" + reference.getProperty(\"service.ranking\"));\n\t\t\t\t}\n\t\t\t\tcallbackRunnable = createCallbackRunnable(dependencyService, reference, service, m_callbackRemoved);\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t} else if (invokeSwapped) {\n\t\t\t\tif (m_debug) {\n\t\t\t\t\tlog(\"invoke swapped: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \" replacing \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\t}\n\t\t\t\tcallbackRunnable = createSwapRunnable(dependencyService, prevHighestRankedService.getServiceReference(), prevHighestRankedService.getService(), newHighestRankedService.getServiceReference(), newHighestRankedService.getService());\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t}\n\t\t}\n\t\tif (callbackRunnable != null) {\n\t\t\twaitForCallbackLock(callbackRunnable);\n\t\t\tsynchronized (rankings) {\n\t\t\t\treleaseCallback(callbackRunnable);\n\t\t\t\texecute(callbackRunnable);\n\t\t\t}\n\t\t}\n\t}","id":66550,"modified_method":"private void handleAspectAwareRemoved(DependencyService dependencyService, ServiceReference reference, Object service) {\n\t\tdebugLog(\"aspectawareremoved: \" + reference.getProperty(\"service.ranking\"));\n\t\tif (componentIsDependencyManagerFactory(dependencyService)) {\n\t\t\t// component is either aspect or adapter factory instance, these must be ignored.\n\t\t\treturn;\n\t\t}\n\t\t// we might need to swap here too!\n\t\tboolean invokeRemoved = false;\n\t\tLong serviceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\tTuple prevHighestRankedService = null;\n\t\tTuple newHighestRankedService = null;\n\t\tboolean invokeSwapped = false;\n\t\tMap rankings = null;\n\t\tRunnable callbackRunnable = null;\n\t\tsynchronized (m_componentByRank) {\n\t\t\tLong originalServiceId = ServiceUtil.getServiceIdAsLong(reference);\n\t\t\tif (isLastService(dependencyService, reference, service, serviceId)) {\n\t\t\t\tinvokeRemoved = true;\n\t\t\t} else {\n\t\t\t\t// not the last service, but should we swap?\n\t\t\t\tprevHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t\tif (prevHighestRankedService.getServiceReference().equals(reference)) {\n\t\t\t\t\t// swapping out\n\t\t\t\t\tdebugLog(\"Swap out on remove!\");\n\t\t\t\t\tinvokeSwapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebugLog(\"is last service: \" + invokeRemoved);\n\t\t\t// cleanup\n\t\t\tMap componentMap = (Map) m_componentByRank.get(dependencyService); /* <Long, Map<Integer, Tuple>> */\n\t\t\tif (componentMap != null) {\n\t\t\t\trankings = (Map) componentMap.get(originalServiceId); /* <Integer, Tuple> */\n\t\t\t\tList rankingsToRemove = new ArrayList();\n\t\t\t\tfor (Iterator entryIterator = rankings.entrySet().iterator(); entryIterator.hasNext(); ) {\n\t\t\t\t\tEntry mapEntry = (Entry) entryIterator.next();\n\t\t\t\t\tif (((Tuple)mapEntry.getValue()).getServiceReference().equals(reference)) {\n\t\t\t\t\t\t// remove the reference\n\t\t\t\t\t\t// rankings.remove(mapEntry.getKey());\n\t\t\t\t\t\trankingsToRemove.add(mapEntry.getKey());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Iterator rankingIterator = rankingsToRemove.iterator(); rankingIterator.hasNext(); ) {\n\t\t\t\t\trankings.remove(rankingIterator.next());\n\t\t\t\t}\n\t\t\t\tif (rankings.size() == 0) {\n\t\t\t\t\tcomponentMap.remove(originalServiceId);\n\t\t\t\t}\n\t\t\t\tif (componentMap.size() == 0) {\n\t\t\t\t\tm_componentByRank.remove(dependencyService);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// determine current highest ranked service\n\t\t\tif (invokeSwapped) {\n\t\t\t\tnewHighestRankedService = (Tuple)getHighestRankedService(dependencyService, originalServiceId).getValue();\n\t\t\t}\n\t\t\tif (invokeRemoved) {\n\t\t\t\t// handle invoke outside the sync block since we won't know what will happen there\n\t\t\t\tdebugLog(\"invoke removed: \" + reference.getProperty(\"service.ranking\"));\n\t\t\t\tcallbackRunnable = createCallbackRunnable(dependencyService, reference, service, m_callbackRemoved);\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t} else if (invokeSwapped) {\n\t\t\t\tdebugLog(\"invoke swapped: \" + newHighestRankedService.getServiceReference().getProperty(\"service.ranking\") + \" replacing \" + prevHighestRankedService.getServiceReference().getProperty(\"service.ranking\"));\n\t\t\t\tcallbackRunnable = createSwapRunnable(dependencyService, prevHighestRankedService.getServiceReference(), prevHighestRankedService.getService(), newHighestRankedService.getServiceReference(), newHighestRankedService.getService());\n\t\t\t\tenqueueCallback(callbackRunnable);\n\t\t\t}\n\t\t}\n\t\tif (callbackRunnable != null) {\n\t\t\twaitForCallbackLock(callbackRunnable);\n\t\t\tsynchronized (rankings) {\n\t\t\t\treleaseCallback(callbackRunnable);\n\t\t\t\texecute(callbackRunnable);\n\t\t\t}\n\t\t}\n\t}","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public void invokeRemoved(DependencyService service) {\n    \tif (m_debug) {\n    \t\tlog(\"invoke removed due to unconfigure. (component is destroyed)\");\n    \t}\n        Set references = null;\n        Object[] tupleArray = null;\n        synchronized (m_sr) {\n            references = (Set) m_sr.get(service);\n            // is this null check necessary ??\n            if (references != null) {\n\t            tupleArray = references.toArray(new Tuple[references.size()]);\n            }\n        }\n\n        Tuple[] refs = (Tuple[]) (tupleArray != null ?  tupleArray : new Tuple[0]);\n    \n        for (int i = 0; i < refs.length; i++) {\n            ServiceReference sr = refs[i].getServiceReference();\n            Object svc = refs[i].getService();\n            invokeRemoved(service, sr, svc);\n        }\n    }","id":66551,"modified_method":"public void invokeRemoved(DependencyService service) {\n\t\tdebugLog(\"invoke removed due to unconfigure. (component is destroyed)\");\n        Set references = null;\n        Object[] tupleArray = null;\n        synchronized (m_sr) {\n            references = (Set) m_sr.get(service);\n            // is this null check necessary ??\n            if (references != null) {\n\t            tupleArray = references.toArray(new Tuple[references.size()]);\n            }\n        }\n\n        Tuple[] refs = (Tuple[]) (tupleArray != null ?  tupleArray : new Tuple[0]);\n    \n        for (int i = 0; i < refs.length; i++) {\n            ServiceReference sr = refs[i].getServiceReference();\n            Object svc = refs[i].getService();\n            invokeRemoved(service, sr, svc);\n        }\n    }","commit_id":"29a1e3e2b43841a6dfb281917ee6345602c2c38a","url":"https://github.com/apache/felix"},{"original_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {\n\n        super(endpoint, processor);\n        Bus bus = null;\n        this.endpoint = endpoint;\n        boolean isWebServiceProvider = false;\n        if (endpoint.getApplicationContext() != null) {            \n            bus = endpoint.getCxfEndpointBean().getBus();\n            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {\n                BusFactory.setThreadDefaultBus(bus);\n            }\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getThreadDefaultBus();\n        }\n        ServerFactoryBean svrBean = null;\n\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();\n            CxfEndpointUtils.checkServiceClass(endpointBean.getServiceClass());\n            svrBean = CxfEndpointUtils.getServerFactoryBean(endpointBean.getServiceClass());\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(endpointBean.getServiceClass(),\n                                                                  WebServiceProvider.class);\n            endpoint.configure(svrBean);\n\n        } else { // setup the serverFactoryBean with the URI parameters\n            CxfEndpointUtils.checkServiceClassName(endpoint.getServiceClass());\n            Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n            svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass, WebServiceProvider.class);\n            svrBean.setAddress(endpoint.getAddress());\n            svrBean.setServiceClass(serviceClass);            \n            if (endpoint.getWsdlURL() != null) {\n                svrBean.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        \n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n        }\n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n        }\n        \n        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n\n        svrBean.setInvoker(new CamelInvoker(this));\n\n        // apply feature here\n        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {\n\n            if (dataFormat.equals(DataFormat.PAYLOAD)) {\n                svrBean.getFeatures().add(new PayLoadDataFormatFeature());\n                // adding the logging feature here for debug\n                //features.add(new LoggingFeature());\n            } else if (dataFormat.equals(DataFormat.MESSAGE)) {\n                svrBean.getFeatures().add(new MessageDataFormatFeature());\n                //features.add(new LoggingFeature());\n            }\n        }\n        svrBean.setBus(bus);\n        svrBean.setStart(false);\n        server = svrBean.create();\n\n    }","id":66552,"modified_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {\n\n        super(endpoint, processor);\n        Bus bus = null;\n        this.endpoint = endpoint;\n        boolean isWebServiceProvider = false;\n        if (endpoint.getApplicationContext() != null) {            \n            bus = endpoint.getCxfEndpointBean().getBus();\n            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {\n                BusFactory.setThreadDefaultBus(bus);\n            }\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getThreadDefaultBus();\n        }\n        \n        Class serviceClass = CxfEndpointUtils.getServiceClass(endpoint);\n        ServerFactoryBean svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);\n        isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass,\n                                                              WebServiceProvider.class);\n        \n        if (endpoint.isSpringContextEndpoint()) {\n            endpoint.configure(svrBean);\n        } else { // setup the serverFactoryBean with the URI parameters\n            svrBean.setAddress(endpoint.getAddress());                       \n            if (endpoint.getWsdlURL() != null) {\n                svrBean.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        \n        svrBean.setServiceClass(serviceClass);\n        \n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n        }\n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n        }\n        \n        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n\n        svrBean.setInvoker(new CamelInvoker(this));\n\n        // apply feature here\n        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {\n\n            if (dataFormat.equals(DataFormat.PAYLOAD)) {\n                svrBean.getFeatures().add(new PayLoadDataFormatFeature());\n                // adding the logging feature here for debug\n                //features.add(new LoggingFeature());\n            } else if (dataFormat.equals(DataFormat.MESSAGE)) {\n                svrBean.getFeatures().add(new MessageDataFormatFeature());\n                //features.add(new LoggingFeature());\n            }\n        }\n        svrBean.setBus(bus);\n        svrBean.setStart(false);\n        server = svrBean.create();\n\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public void testCheckServiceClassWithTheEndpoint() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            CxfEndpointUtils.checkServiceClassName(endpoint.getServiceClass());\n            fail(\"Should get a CamelException here\");\n        } catch (CamelException exception) {\n            assertNotNull(\"Should get a CamelException here\", exception);\n            assertEquals(\"serviceClass is required for CXF endpoint configuration\", exception.getMessage());\n        }\n    }","id":66553,"modified_method":"public void testCheckServiceClassWithTheEndpoint() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            CxfEndpointUtils.getServiceClass(endpoint);\n            fail(\"Should get a CamelException here\");\n        } catch (ClassNotFoundException exception) {\n            assertNotNull(\"Should get a ClassNotFoundExceptionException here\", exception);\n            assertEquals(\"Can't find serviceClass from uri, please check the cxf endpoint configuration\", exception.getMessage());\n        }\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public void testCheckServiceClassProcedure() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            endpoint.createProducer();\n        } catch (CamelException exception) {\n            assertNotNull(\"Should get a CamelException here\", exception);\n            assertEquals(\"serviceClass is required for CXF endpoint configuration\", exception.getMessage());\n        }\n    }","id":66554,"modified_method":"public void testCheckServiceClassProcedure() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            endpoint.createProducer();\n        } catch (ClassNotFoundException exception) {\n            assertNotNull(\"Should get a ClassNotFoundException here\", exception);\n            assertEquals(\"Can't find serviceClass from uri, please check the cxf endpoint configuration\", exception.getMessage());\n        }\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public void testCheckServiceClassConsumer() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            endpoint.createConsumer(new NullProcessor());\n        } catch (CamelException exception) {\n            assertNotNull(\"Should get a CamelException here\", exception);\n            assertEquals(\"serviceClass is required for CXF endpoint configuration\", exception.getMessage());\n        }\n    }","id":66555,"modified_method":"public void testCheckServiceClassConsumer() throws Exception {\n        CxfEndpoint endpoint = createEndpoint(getNoServiceClassURI());\n        try {\n            endpoint.createConsumer(new NullProcessor());\n        } catch (ClassNotFoundException exception) {\n            assertNotNull(\"Should get a ClassNotFoundException here\", exception);\n            assertEquals(\"Can't find serviceClass from uri, please check the cxf endpoint configuration\", exception.getMessage());\n        }\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"private Client createClientForStreamMessage() throws CamelException {\n        CxfClientFactoryBean cfb = new CxfClientFactoryBean();\n        Class serviceClass = null;\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();\n            serviceClass = cxfEndpointBean.getServiceClass();\n            CxfEndpointUtils.checkServiceClass(serviceClass);\n        } else {\n            CxfEndpointUtils.checkServiceClassName(endpoint.getServiceClass());\n            try {\n                serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new CamelException(e);\n            }\n        }\n        \n        boolean jsr181Enabled = CxfEndpointUtils.hasWebServiceAnnotation(serviceClass);\n        cfb.setJSR181Enabled(jsr181Enabled);\n       \n        return createClientFromClientFactoryBean(jsr181Enabled ? new JaxWsProxyFactoryBean(cfb)\n            : new ClientProxyFactoryBean(cfb));\n    }","id":66556,"modified_method":"private Client createClientForStreamMessage() throws Exception {\n        CxfClientFactoryBean cfb = new CxfClientFactoryBean();\n        Class serviceClass = null;\n        try {\n            serviceClass = CxfEndpointUtils.getServiceClass(endpoint);\n        } catch (ClassNotFoundException e) {\n            throw new CamelException(e);\n        }       \n        \n        boolean jsr181Enabled = CxfEndpointUtils.hasWebServiceAnnotation(serviceClass);\n        cfb.setJSR181Enabled(jsr181Enabled);\n       \n        return createClientFromClientFactoryBean(jsr181Enabled ? new JaxWsProxyFactoryBean(cfb)\n            : new ClientProxyFactoryBean(cfb));\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"private Client createClientFromClientFactoryBean(ClientProxyFactoryBean cfb) throws CamelException {\n        Bus bus = null;\n        if (endpoint.getApplicationContext() != null) {            \n            bus = endpoint.getCxfEndpointBean().getBus();\n            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {\n                BusFactory.setThreadDefaultBus(bus);\n            }\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getThreadDefaultBus();\n        }\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();\n            CxfEndpointUtils.checkServiceClass(cxfEndpointBean.getServiceClass());\n            if (cfb == null) {\n                cfb = CxfEndpointUtils.getClientFactoryBean(cxfEndpointBean.getServiceClass());\n            }\n            endpoint.configure(cfb);\n\n        } else { // set up the clientFactoryBean by using URI information\n            CxfEndpointUtils.checkServiceClassName(endpoint.getServiceClass());\n            try {\n                // We need to choose the right front end to create the\n                // clientFactoryBean\n                Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n                if (cfb == null) {\n                    cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);\n                }\n                cfb.setAddress(endpoint.getAddress());\n                if (null != endpoint.getServiceClass()) {\n                    cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));\n                }\n                if (null != endpoint.getWsdlURL()) {\n                    cfb.setWsdlURL(endpoint.getWsdlURL());\n                }\n            } catch (ClassNotFoundException e) {\n                throw new CamelException(e);\n            }\n            \n            if (endpoint.getWsdlURL() != null) {\n                cfb.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        \n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n        }\n        if (CxfEndpointUtils.getPortName(endpoint) != null) {\n            cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n        }\n        \n        if (dataFormat.equals(DataFormat.MESSAGE)) {\n            cfb.getFeatures().add(new MessageDataFormatFeature());\n        } else if (dataFormat.equals(DataFormat.PAYLOAD)) {\n            cfb.getFeatures().add(new PayLoadDataFormatFeature());\n        }\n        \n        cfb.setBus(bus);\n        return ((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();\n    }","id":66557,"modified_method":"private Client createClientFromClientFactoryBean(ClientProxyFactoryBean cfb) throws Exception {\n        Bus bus = null;\n        if (endpoint.getApplicationContext() != null) {            \n            bus = endpoint.getCxfEndpointBean().getBus();\n            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {\n                BusFactory.setThreadDefaultBus(bus);\n            }\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getThreadDefaultBus();\n        }\n        \n        Class serviceClass = CxfEndpointUtils.getServiceClass(endpoint);\n        // We need to choose the right front end to create the clientFactoryBean        \n        if (cfb == null) {\n            cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);\n        }\n        \n        if (endpoint.isSpringContextEndpoint()) {            \n            endpoint.configure(cfb);\n        } else { // set up the clientFactoryBean by using URI information\n            cfb.setAddress(endpoint.getAddress());\n            if (null != endpoint.getServiceClass()) {\n                cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));\n            }\n            if (null != endpoint.getWsdlURL()) {\n                cfb.setWsdlURL(endpoint.getWsdlURL());\n            }\n\n            if (endpoint.getWsdlURL() != null) {\n                cfb.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        cfb.setServiceClass(serviceClass);\n        \n        if (CxfEndpointUtils.getServiceName(endpoint) != null) {\n            cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n        }\n        if (CxfEndpointUtils.getPortName(endpoint) != null) {\n            cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n        }\n        \n        if (dataFormat.equals(DataFormat.MESSAGE)) {\n            cfb.getFeatures().add(new MessageDataFormatFeature());\n        } else if (dataFormat.equals(DataFormat.PAYLOAD)) {\n            cfb.getFeatures().add(new PayLoadDataFormatFeature());\n        }\n        \n        cfb.setBus(bus);\n        return ((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public CxfProducer(CxfEndpoint endpoint) throws CamelException {\n        super(endpoint);\n        this.endpoint = endpoint;\n        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n        if (dataFormat.equals(DataFormat.POJO)) {\n            client = createClientFromClientFactoryBean(null);\n        } else {\n            // Create CxfClient for message or payload type\n            client = createClientForStreamMessage();\n        }\n    }","id":66558,"modified_method":"public CxfProducer(CxfEndpoint endpoint) throws Exception {\n        super(endpoint);\n        this.endpoint = endpoint;\n        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n        if (dataFormat.equals(DataFormat.POJO)) {\n            client = createClientFromClientFactoryBean(null);\n        } else {\n            // Create CxfClient for message or payload type\n            client = createClientForStreamMessage();\n        }\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public CxfSoapConsumer(CxfSoapEndpoint endpoint, Processor processor) throws Exception {\n        this.endpoint = endpoint;\n        Processor soapProcessor = new AsyncProcessorDecorator(processor,\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapConsumerIn(exchange);\n                    }\n                },\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapConsumerOut(exchange);\n                    }\n                });\n        this.consumer = endpoint.getInnerEndpoint().createConsumer(soapProcessor);\n        Class sei = CxfEndpointUtils.getSEIClass(endpoint.getServiceClass());\n        ServerFactoryBean sfb = CxfEndpointUtils.getServerFactoryBean(sei);\n        sfb.setWsdlURL(endpoint.getWsdl().getURL().toString());\n        if (endpoint.getServiceName() != null) {\n            sfb.setServiceName(endpoint.getServiceName());\n        }\n        if (endpoint.getEndpointName() != null) {\n            sfb.setEndpointName(endpoint.getEndpointName());\n        }\n        // we do not need use the destination here\n        sfb.setDestinationFactory(new NullDestinationFactory());\n        sfb.setStart(false);\n\n        server = sfb.create();\n    }","id":66559,"modified_method":"public CxfSoapConsumer(CxfSoapEndpoint endpoint, Processor processor) throws Exception {\n        this.endpoint = endpoint;\n        Processor soapProcessor = new AsyncProcessorDecorator(processor,\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapConsumerIn(exchange);\n                    }\n                },\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapConsumerOut(exchange);\n                    }\n                });\n        this.consumer = endpoint.getInnerEndpoint().createConsumer(soapProcessor);\n        Class sei = null; \n        if (ObjectHelper.isNotEmpty(endpoint.getServiceClass())) {\n            sei = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n        }\n        ServerFactoryBean sfb = CxfEndpointUtils.getServerFactoryBean(sei);\n        sfb.setWsdlURL(endpoint.getWsdl().getURL().toString());\n        if (endpoint.getServiceName() != null) {\n            sfb.setServiceName(endpoint.getServiceName());\n        }\n        if (endpoint.getEndpointName() != null) {\n            sfb.setEndpointName(endpoint.getEndpointName());\n        }\n        // we do not need use the destination here\n        sfb.setDestinationFactory(new NullDestinationFactory());\n        sfb.setStart(false);\n\n        server = sfb.create();\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"public CxfSoapProducer(CxfSoapEndpoint endpoint) throws Exception {\n        this.endpoint = endpoint;\n        this.producer = endpoint.getInnerEndpoint().createProducer();\n        this.processor = new AsyncProcessorDecorator(producer,\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapProviderIn(exchange);\n                    }\n                },\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapProviderOut(exchange);\n                    }\n                });\n\n        //create the endpoint and setup the interceptors\n        Class sei = CxfEndpointUtils.getSEIClass(endpoint.getServiceClass());\n        ClientProxyFactoryBean cfb = CxfEndpointUtils.getClientFactoryBean(sei);\n        if (sei == null) {\n            cfb.setServiceClass(Dummy.class);\n        } else {\n            cfb.setServiceClass(sei);\n        }\n        cfb.setWsdlURL(endpoint.getWsdl().getURL().toString());\n        if (endpoint.getServiceName() != null) {\n            cfb.setServiceName(endpoint.getServiceName());\n        }\n        if (endpoint.getEndpointName() != null) {\n            cfb.setEndpointName(endpoint.getEndpointName());\n        }\n        cfb.setConduitSelector(new NullConduitSelector());\n        client = (ClientImpl)((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();\n\n    }","id":66560,"modified_method":"public CxfSoapProducer(CxfSoapEndpoint endpoint) throws Exception {\n        this.endpoint = endpoint;\n        this.producer = endpoint.getInnerEndpoint().createProducer();\n        this.processor = new AsyncProcessorDecorator(producer,\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapProviderIn(exchange);\n                    }\n                },\n                new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        processSoapProviderOut(exchange);\n                    }\n                });\n\n        //create the endpoint and setup the interceptors\n        Class sei = null; \n        if (ObjectHelper.isNotEmpty(endpoint.getServiceClass())) {\n            sei = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n        }\n        ClientProxyFactoryBean cfb = CxfEndpointUtils.getClientFactoryBean(sei);\n        if (sei == null) {\n            cfb.setServiceClass(Dummy.class);\n        } else {\n            cfb.setServiceClass(sei);\n        }\n        cfb.setWsdlURL(endpoint.getWsdl().getURL().toString());\n        if (endpoint.getServiceName() != null) {\n            cfb.setServiceName(endpoint.getServiceName());\n        }\n        if (endpoint.getEndpointName() != null) {\n            cfb.setEndpointName(endpoint.getEndpointName());\n        }\n        cfb.setConduitSelector(new NullConduitSelector());\n        client = (ClientImpl)((ClientProxy)Proxy.getInvocationHandler(cfb.create())).getClient();\n\n    }","commit_id":"083d10d91e6bb871650d4c52c9edc352c01d51bd","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected void doDispatch(final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n        int statusCode;\n\n        if (request.getAttribute(\"javax.servlet.error.status_code\") != null) {\n            statusCode = Integer.parseInt(request.getAttribute(\"javax.servlet.error.status_code\").toString());\n        }\n        else {\n            statusCode = 500;\n        }\n\n        Throwable t = null;\n        if (request.getAttribute(\"javax.servlet.error.exception\") != null) {\n            t = (Throwable)request.getAttribute(\"javax.servlet.error.exception\");\n            if (!(t instanceof GrailsWrappedRuntimeException) && request.getAttribute(\"exception\") == null) {\n                request.setAttribute(\"exception\", new GrailsWrappedRuntimeException(getServletContext(), t));\n            }\n        }\n        final UrlMappingsHolder urlMappingsHolder = lookupUrlMappings();\n        UrlMappingInfo matchedInfo = null;\n        if (t != null) {\n            matchedInfo = urlMappingsHolder.matchStatusCode(statusCode, t);\n            if (matchedInfo == null) {\n                matchedInfo = urlMappingsHolder.matchStatusCode(statusCode, GrailsExceptionResolver.getRootCause(t));\n            }\n        }\n\n        if (matchedInfo == null) {\n            matchedInfo = urlMappingsHolder.matchStatusCode(statusCode);\n        }\n        final UrlMappingInfo urlMappingInfo = matchedInfo;\n\n        if (urlMappingInfo != null) {\n            final GrailsWebRequest webRequest = (GrailsWebRequest) RequestContextHolder.getRequestAttributes();\n            request.setAttribute(\"com.opensymphony.sitemesh.APPLIED_ONCE\", null);\n            urlMappingInfo.configure(webRequest);\n\n            String viewName = urlMappingInfo.getViewName();\n            if (viewName == null || viewName.endsWith(GSP_SUFFIX) || viewName.endsWith(JSP_SUFFIX)) {\n                WebUtils.forwardRequestForUrlMappingInfo(request, response, urlMappingInfo, Collections.EMPTY_MAP);\n            }\n            else {\n                ViewResolver viewResolver = WebUtils.lookupViewResolver(getServletContext());\n                if (viewResolver != null) {\n                    View v;\n                    try {\n                        v = WebUtils.resolveView(request, urlMappingInfo, viewName, viewResolver);\n                        IncludeResponseWrapper includeResponse = new IncludeResponseWrapper(response);\n                        v.render(Collections.EMPTY_MAP, request, response);\n                    }\n                    catch (Exception e) {\n                        throw new UrlMappingException(\"Error mapping onto view [\"+viewName+\"]: \" + e.getMessage(),e);\n                    }\n                }\n            }\n        }\n        else {\n            renderDefaultResponse(response, statusCode);\n        }\n    }","id":66561,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected void doDispatch(final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n        int statusCode;\n\n        // Do nothing in the case of an already committed response. Assume error already handled\n        if(response.isCommitted()) return;\n\n        if (request.getAttribute(\"javax.servlet.error.status_code\") != null) {\n            statusCode = Integer.parseInt(request.getAttribute(\"javax.servlet.error.status_code\").toString());\n        }\n        else {\n            statusCode = 500;\n        }\n\n        Throwable t = null;\n        if (request.getAttribute(\"javax.servlet.error.exception\") != null) {\n            t = (Throwable)request.getAttribute(\"javax.servlet.error.exception\");\n            if (!(t instanceof GrailsWrappedRuntimeException) && request.getAttribute(\"exception\") == null) {\n                request.setAttribute(\"exception\", new GrailsWrappedRuntimeException(getServletContext(), t));\n            }\n        }\n        final UrlMappingsHolder urlMappingsHolder = lookupUrlMappings();\n        UrlMappingInfo matchedInfo = null;\n        if (t != null) {\n            matchedInfo = urlMappingsHolder.matchStatusCode(statusCode, t);\n            if (matchedInfo == null) {\n                matchedInfo = urlMappingsHolder.matchStatusCode(statusCode, GrailsExceptionResolver.getRootCause(t));\n            }\n        }\n\n        if (matchedInfo == null) {\n            matchedInfo = urlMappingsHolder.matchStatusCode(statusCode);\n        }\n        final UrlMappingInfo urlMappingInfo = matchedInfo;\n\n        if (urlMappingInfo != null) {\n            RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n            boolean restoreOriginalRequestAttributes = false;\n            if(requestAttributes instanceof GrailsWebRequest) {\n\n                final GrailsWebRequest webRequest = (GrailsWebRequest) requestAttributes;\n                urlMappingInfo.configure(webRequest);\n            }\n            else {\n                restoreOriginalRequestAttributes = true;\n                GrailsWebRequest webRequest = new GrailsWebRequest(request, response, getServletContext());\n                RequestContextHolder.setRequestAttributes(webRequest);\n                urlMappingInfo.configure(webRequest);\n            }\n            request.setAttribute(\"com.opensymphony.sitemesh.APPLIED_ONCE\", null);\n\n            try {\n                String viewName = urlMappingInfo.getViewName();\n                if (viewName == null || viewName.endsWith(GSP_SUFFIX) || viewName.endsWith(JSP_SUFFIX)) {\n                    WebUtils.forwardRequestForUrlMappingInfo(request, response, urlMappingInfo, Collections.EMPTY_MAP);\n                }\n                else {\n                    ViewResolver viewResolver = WebUtils.lookupViewResolver(getServletContext());\n                    if (viewResolver != null) {\n                        View v;\n                        try {\n                            v = WebUtils.resolveView(request, urlMappingInfo, viewName, viewResolver);\n                            v.render(Collections.EMPTY_MAP, request, response);\n                        }\n                        catch (Exception e) {\n                            throw new UrlMappingException(\"Error mapping onto view [\"+viewName+\"]: \" + e.getMessage(),e);\n                        }\n                    }\n                }\n            } finally {\n                if(restoreOriginalRequestAttributes) {\n                    RequestContextHolder.setRequestAttributes(requestAttributes);\n                }\n            }\n        }\n        else {\n            renderDefaultResponse(response, statusCode);\n        }\n    }","commit_id":"6366a81fc8ed581ceeadf581e018bf1c9d2c1d64","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Close the stream.\n     * @see #checkError()\n     */\n    @Override\n    public void close() {\n        flush();\n        if (CONTENT_LENGTH_COUNTING_ENABLED && bytesCounter != null && response != null && !response.isCommitted()) {\n            int size = bytesCounter.size();\n            if (size > 0) {\n                response.setContentLength(size);\n            }\n            try {\n                response.getWriter().flush();\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n    }","id":66562,"modified_method":"/**\n     * Close the stream.\n     * @see #checkError()\n     */\n    @Override\n    public void close() {\n        flush();\n        if (CONTENT_LENGTH_COUNTING_ENABLED && bytesCounter != null && response != null && !response.isCommitted()) {\n            int size = bytesCounter.size();\n            if (size > 0) {\n                response.setContentLength(size);\n            }\n            flushResponse();\n        }\n        else {\n            GrailsWebRequest webRequest = GrailsWebRequest.lookup();\n            if(webRequest != null && webRequest.getCurrentRequest().getAttribute(RequestConstants.PAGE) != null) {\n                // flush the response if its a layout\n                flushResponse();\n            }\n        }\n    }","commit_id":"6366a81fc8ed581ceeadf581e018bf1c9d2c1d64","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected DecoratorSelector initDecoratorSelector(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        final Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new DecoratorMapper2DecoratorSelector(factory.getDecoratorMapper()) {\n            @Override\n            public Decorator selectDecorator(Content content, SiteMeshContext context) {\n                SiteMeshWebAppContext siteMeshWebAppContext = (SiteMeshWebAppContext) context;\n                final com.opensymphony.module.sitemesh.Decorator decorator =\n                    factory.getDecoratorMapper().getDecorator(siteMeshWebAppContext.getRequest(), content2htmlPage(content));\n                if (decorator == null || decorator.getPage() == null) {\n                    return new GrailsNoDecorator();\n                }\n\n                return new OldDecorator2NewDecorator(decorator) {\n                    @Override\n                    protected void render(@SuppressWarnings(\"hiding\") Content content, HttpServletRequest request,\n                                          HttpServletResponse response, ServletContext servletContext,\n                                          @SuppressWarnings(\"hiding\") SiteMeshWebAppContext webAppContext)\n                            throws IOException, ServletException {\n\n                        HTMLPage htmlPage = content2htmlPage(content);\n                        request.setAttribute(PAGE, htmlPage);\n\n                        // see if the URI path (webapp) is set\n                        if (decorator.getURIPath() != null) {\n                            // in a security conscious environment, the servlet container\n                            // may return null for a given URL\n                            if (servletContext.getContext(decorator.getURIPath()) != null) {\n                                servletContext = servletContext.getContext(decorator.getURIPath());\n                            }\n                        }\n                        // get the dispatcher for the decorator\n                        RequestDispatcher dispatcher = servletContext.getRequestDispatcher(decorator.getPage());\n                        if (response.isCommitted()) {\n                            dispatcher.include(request, response);\n                        }\n                        else {\n                            dispatcher.forward(request, response);\n                        }\n\n                        request.removeAttribute(PAGE);\n                    }\n                };\n            }\n        };\n    }","id":66563,"modified_method":"@Override\n    protected DecoratorSelector initDecoratorSelector(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        final Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new DecoratorMapper2DecoratorSelector(factory.getDecoratorMapper()) {\n            @Override\n            public Decorator selectDecorator(Content content, SiteMeshContext context) {\n                SiteMeshWebAppContext siteMeshWebAppContext = (SiteMeshWebAppContext) context;\n                final com.opensymphony.module.sitemesh.Decorator decorator =\n                    factory.getDecoratorMapper().getDecorator(siteMeshWebAppContext.getRequest(), content2htmlPage(content));\n                if (decorator == null || decorator.getPage() == null) {\n                    return new GrailsNoDecorator();\n                }\n\n                return new OldDecorator2NewDecorator(decorator) {\n                    @Override\n                    protected void render(@SuppressWarnings(\"hiding\") Content content, HttpServletRequest request,\n                                          HttpServletResponse response, ServletContext servletContext,\n                                          @SuppressWarnings(\"hiding\") SiteMeshWebAppContext webAppContext)\n                            throws IOException, ServletException {\n\n                        HTMLPage htmlPage = content2htmlPage(content);\n                        request.setAttribute(PAGE, htmlPage);\n\n                        // see if the URI path (webapp) is set\n                        if (decorator.getURIPath() != null) {\n                            // in a security conscious environment, the servlet container\n                            // may return null for a given URL\n                            if (servletContext.getContext(decorator.getURIPath()) != null) {\n                                servletContext = servletContext.getContext(decorator.getURIPath());\n                            }\n                        }\n                        // get the dispatcher for the decorator\n                        RequestDispatcher dispatcher = servletContext.getRequestDispatcher(decorator.getPage());\n                        if (response.isCommitted()) {\n                            dispatcher.include(request, response);\n                        }\n                        else {\n                            dispatcher.forward(request, response);\n                            if(!response.isCommitted()) {\n                                response.getWriter().flush();\n                            }\n                        }\n\n                        request.removeAttribute(PAGE);\n                    }\n                };\n            }\n        };\n    }","commit_id":"6366a81fc8ed581ceeadf581e018bf1c9d2c1d64","url":"https://github.com/grails/grails-core"},{"original_method":"private void configureViewLogging(ViewEntity viewDefinition,ClassLoader cl) {\n    URL resourceURL = cl.getResource(VIEW_LOG_FILE);\n    if( null != resourceURL ){\n      LOG.info(\"setting up logging for view {} as per property file {}\",viewDefinition.getName(), resourceURL);\n      PropertyConfigurator.configure(resourceURL);\n    }\n  }","id":66564,"modified_method":"/**\n   * copies non-log4j properties (like ambari.log.dir) from ambari's log4j.properties into view's log4j properties\n   * and removes log4j specific properties (log4j.rootLogger) inside ambari's log4j.properties from view's log4j properties\n   * It then configures the log4j with view's properties.\n   *\n   * @param viewDefinition\n   * @param cl\n   */\n  private void configureViewLogging(ViewEntity viewDefinition, ClassLoader cl) {\n    InputStream viewLog4jStream = cl.getResourceAsStream(VIEW_LOG_FILE);\n    if (null != viewLog4jStream) {\n      try {\n        Properties viewLog4jConfig = new Properties();\n        viewLog4jConfig.load(viewLog4jStream);\n        LOG.info(\"setting up logging for view {} as per property file {}\", viewDefinition.getName(), VIEW_LOG_FILE);\n\n        InputStream ambariLog4jStream = cl.getResourceAsStream(AMBARI_LOG_FILE);\n        if (null != ambariLog4jStream) {\n          Properties ambariLog4jConfig = new Properties();\n          ambariLog4jConfig.load(ambariLog4jStream);\n\n          // iterate through all the ambari configs and get the once not starting from log4j\n          // set them into view properties and remove any log4j property which view might be overriding.\n          for (Object property : ambariLog4jConfig.keySet()) {\n            String prop = (String) property;\n            if (prop.startsWith(LOG4J)) {\n              viewLog4jConfig.remove(prop);\n            } else {\n              viewLog4jConfig.put(prop, ambariLog4jConfig.getProperty(prop));\n            }\n          }\n        }\n\n        PropertyConfigurator.configure(viewLog4jConfig);\n      } catch (IOException e) {\n        LOG.error(\"Error occurred while configuring logs for {}\", viewDefinition.getName());\n      }\n    }\n  }","commit_id":"1acdb3a8d66817e463ccfc966f168f14f0254133","url":"https://github.com/apache/ambari"},{"original_method":"private FilterSet getSuppressions()\n        throws MavenReportException\n    {\n        try\n        {\n            File suppressionsFile = locator.resolveLocation( suppressionsLocation,\n                                                             getLocationTemp( \"checkstyle-suppressions.xml\" ) );\n\n            if ( suppressionsFile == null )\n            {\n                return null;\n            }\n\n            return SuppressionsLoader.loadSuppressions( suppressionsFile.getAbsolutePath() );\n        }\n        catch ( CheckstyleException ce )\n        {\n            throw new MavenReportException( \"failed to load suppressions location: \" + suppressionsLocation, ce );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to process supressions location: \" + suppressionsLocation, e );\n        }\n    }","id":66565,"modified_method":"private FilterSet getSuppressions()\n        throws MavenReportException\n    {\n        try\n        {\n            File suppressionsFile = locator.resolveLocation( suppressionsLocation, \"checkstyle-suppressions.xml\" );\n\n            if ( suppressionsFile == null )\n            {\n                return null;\n            }\n\n            return SuppressionsLoader.loadSuppressions( suppressionsFile.getAbsolutePath() );\n        }\n        catch ( CheckstyleException ce )\n        {\n            throw new MavenReportException( \"failed to load suppressions location: \" + suppressionsLocation, ce );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to process supressions location: \" + suppressionsLocation, e );\n        }\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        mergeDeprecatedInfo();\n        \n        if ( !canGenerateReport() )\n        {\n            // TODO: failure if not a report\n            throw new MavenReportException( \"No source directory to process for checkstyle\" );\n        }\n        \n//        for when we start using maven-shared-io and maven-shared-monitor...\n//        locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n        \n        locator = new Locator( getLog() );\n\n        Map files = executeCheckstyle();\n\n        CheckstyleReportGenerator generator = new CheckstyleReportGenerator( getSink(), getBundle( locale ) );\n\n        generator.generateReport( files );\n    }","id":66566,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        mergeDeprecatedInfo();\n        \n        if ( !canGenerateReport() )\n        {\n            // TODO: failure if not a report\n            throw new MavenReportException( \"No source directory to process for checkstyle\" );\n        }\n        \n//        for when we start using maven-shared-io and maven-shared-monitor...\n//        locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n        \n        locator = new Locator( getLog(), new File( project.getBuild().getDirectory() ) );\n        \n        String configFile = getConfigFile();\n        Properties overridingProperties = getOverridingProperties();\n        ModuleFactory moduleFactory;\n        Configuration config;\n        CheckstyleResults results;\n        try\n        {\n            moduleFactory = getModuleFactory();\n            config = ConfigurationLoader.loadConfiguration( configFile, new PropertiesExpander( overridingProperties ) );\n            results = executeCheckstyle( config, moduleFactory );\n        }\n        catch ( CheckstyleException e )\n        {\n            throw new MavenReportException( \"Failed during checkstyle configuration\", e );\n        }\n\n        ResourceBundle bundle = getBundle( locale );\n        \n        generateReportStatics();\n        generateMainReport( results, config, moduleFactory, bundle );\n        \n        if( enableRSS )\n        {\n            generateRSS( results );\n        }\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Properties getOverridingProperties()\n        throws MavenReportException\n    {\n        Properties p = new Properties();\n\n        try\n        {\n            File propertiesFile = locator.resolveLocation( propertiesLocation,\n                                                           getLocationTemp( \"checkstyle-checker.properties\" ) );\n            \n            if ( propertiesFile != null )\n            {\n                p.load( new FileInputStream( propertiesFile ) );\n            }\n            \n            if ( StringUtils.isNotEmpty( propertyExpansion ) )\n            {\n                p.load( new StringInputStream( propertyExpansion ) );\n            }\n\n            if ( StringUtils.isNotEmpty( headerLocation ) )\n            {\n                try\n                {\n                    File headerFile = locator.resolveLocation( headerLocation,\n                                                               getLocationTemp( \"checkstyle-header.txt\" ) );\n                    if ( headerFile != null )\n                    {\n                        p.setProperty( \"checkstyle.header.file\", headerFile.getAbsolutePath() );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    throw new MavenReportException( \"Unable to process header location.\", e );\n                }\n            }\n\n            if ( cacheFile != null )\n            {\n                p.setProperty( \"checkstyle.cache.file\", cacheFile );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to get overriding properties\", e );\n        }\n\n        return p;\n    }","id":66567,"modified_method":"private Properties getOverridingProperties()\n        throws MavenReportException\n    {\n        Properties p = new Properties();\n\n        try\n        {\n            File propertiesFile = locator.resolveLocation( propertiesLocation, \"checkstyle-checker.properties\" );\n            \n            if ( propertiesFile != null )\n            {\n                p.load( new FileInputStream( propertiesFile ) );\n            }\n            \n            if ( StringUtils.isNotEmpty( propertyExpansion ) )\n            {\n                p.load( new StringInputStream( propertyExpansion ) );\n            }\n\n            if ( StringUtils.isNotEmpty( headerLocation ) )\n            {\n                try\n                {\n                    File headerFile = locator.resolveLocation( headerLocation, \"checkstyle-header.txt\" );\n                    if ( headerFile != null )\n                    {\n                        p.setProperty( \"checkstyle.header.file\", headerFile.getAbsolutePath() );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    throw new MavenReportException( \"Unable to process header location.\", e );\n                }\n            }\n\n            if ( cacheFile != null )\n            {\n                p.setProperty( \"checkstyle.cache.file\", cacheFile );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to get overriding properties\", e );\n        }\n\n        return p;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private AuditListener getListener()\n        throws MavenReportException\n    {\n        AuditListener listener = null;\n\n        if ( StringUtils.isNotEmpty( outputFileFormat ) )\n        {\n            File resultFile = new File( outputFile );\n\n            OutputStream out = getOutputStream( resultFile );\n\n            if ( \"xml\".equals( outputFileFormat ) )\n            {\n                listener = new XMLLogger( out, true );\n            }\n            else if ( \"plain\".equals( outputFileFormat ) )\n            {\n                listener = new DefaultLogger( out, true );\n            }\n            else\n            {\n                // TODO: failure if not a report\n                throw new MavenReportException(\n                    \"Invalid output file format: (\" + outputFileFormat + \"). Must be 'plain' or 'xml'.\" );\n            }\n        }\n\n        return listener;\n    }","id":66568,"modified_method":"private AuditListener getListener()\n        throws MavenReportException\n    {\n        AuditListener listener = null;\n\n        if ( StringUtils.isNotEmpty( outputFileFormat ) )\n        {\n            File resultFile = outputFile;\n\n            OutputStream out = getOutputStream( resultFile );\n\n            if ( \"xml\".equals( outputFileFormat ) )\n            {\n                listener = new XMLLogger( out, true );\n            }\n            else if ( \"plain\".equals( outputFileFormat ) )\n            {\n                listener = new DefaultLogger( out, true );\n            }\n            else\n            {\n                // TODO: failure if not a report\n                throw new MavenReportException(\n                    \"Invalid output file format: (\" + outputFileFormat + \"). Must be 'plain' or 'xml'.\" );\n            }\n        }\n\n        return listener;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private ModuleFactory getModuleFactory()\n        throws CheckstyleException\n    {\n        try\n        {\n            File packageNamesFile = locator.resolveLocation( packageNamesLocation,\n                                                             getLocationTemp( \"checkstyle-packages.xml\" ) );\n\n            if ( packageNamesFile == null )\n            {\n                return null;\n            }\n\n            return PackageNamesLoader.loadModuleFactory( packageNamesFile.getAbsolutePath() );\n        }\n        catch ( IOException e )\n        {\n            getLog().error( \"Unable to process package names location: \" + packageNamesLocation, e );\n            return null;\n        }\n    }","id":66569,"modified_method":"private ModuleFactory getModuleFactory()\n        throws CheckstyleException\n    {\n        // default to internal module factory.\n        ModuleFactory moduleFactory = PackageNamesLoader.loadModuleFactory( Thread.currentThread()\n            .getContextClassLoader() );\n\n        try\n        {\n            // attempt to locate any specified package file.\n            File packageNamesFile = locator.resolveLocation( packageNamesLocation, \"checkstyle-packages.xml\" );\n\n            if ( packageNamesFile != null )\n            {\n                // load resolved location.\n                moduleFactory = PackageNamesLoader.loadModuleFactory( packageNamesFile.getAbsolutePath() );\n            }\n        }\n        catch ( IOException e )\n        {\n            getLog().error( \"Unable to process package names location: \" + packageNamesLocation, e );\n        }\n        return moduleFactory;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String getConfigFile()\n        throws MavenReportException\n    {\n        try\n        {\n            File configFile = locator.resolveLocation( configLocation, getLocationTemp( \"checkstyle-checker.xml\" ) );\n            if ( configFile == null )\n            {\n                throw new MavenReportException( \"Unable to process null config location.\" );\n            }\n            return configFile.getAbsolutePath();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find configuration file location.\", e );\n        }\n\n    }","id":66570,"modified_method":"private String getConfigFile()\n        throws MavenReportException\n    {\n        try\n        {\n            File configFile = locator.resolveLocation( configLocation, \"checkstyle-checker.xml\" );\n            if ( configFile == null )\n            {\n                throw new MavenReportException( \"Unable to process null config location.\" );\n            }\n            return configFile.getAbsolutePath();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find configuration file location.\", e );\n        }\n\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"public CheckstyleReportGenerator( Sink sink, ResourceBundle bundle )\n    {\n        this.bundle = bundle;\n        \n        this.sink = sink;\n    }","id":66571,"modified_method":"public CheckstyleReportGenerator( Sink sink, ResourceBundle bundle )\n    {\n        this.bundle = bundle;\n        \n        this.sink = sink;\n        \n        this.enableRulesSummary = true;\n        this.enableSeveritySummary = true;\n        this.enableFilesSummary = true;\n        this.enableRSS = true;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void doSeveritySummary( Map files )\n    {\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( bundle.getString( \"report.checkstyle.summary\" ) );\n        sink.sectionTitle1_();\n        \n        sink.table();\n        \n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( bundle.getString( \"report.checkstyle.files\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"Infos\" );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"Warnings\" );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"Errors\" );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n        \n        sink.tableRow();\n        sink.tableCell();\n        sink.text( String.valueOf( files.size() ) );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( countSeverity( files.values().iterator(), SeverityLevel.INFO ) );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( countSeverity( files.values().iterator(), SeverityLevel.WARNING ) );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( countSeverity( files.values().iterator(), SeverityLevel.ERROR ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.table_();\n        \n        sink.section1_();\n    }","id":66572,"modified_method":"public boolean isEnableSeveritySummary()\n    {\n        return enableSeveritySummary;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void doFilesSummary( Map filesMap )\n    {\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( bundle.getString( \"report.checkstyle.files\" ) );\n        sink.sectionTitle1_();\n        \n        sink.table();\n        \n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( bundle.getString( \"report.checkstyle.files\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"I\" );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"W\" );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( \"E\" );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n        \n        for( Iterator files = filesMap.keySet().iterator(); files.hasNext(); )\n        {\n            String filename = (String) files.next();\n            List errors = (List) filesMap.get( filename );\n            \n            sink.tableRow();\n            \n            sink.tableCell();\n            sink.link( \"#\" + filename.replace( '/', '.' ) );\n            sink.text( filename );\n            sink.link_();\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( countSeverity( Collections.singletonList( errors ).iterator(), SeverityLevel.INFO ) );\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( countSeverity( Collections.singletonList( errors ).iterator(), SeverityLevel.WARNING ) );\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( countSeverity( Collections.singletonList( errors ).iterator(), SeverityLevel.ERROR ) );\n            sink.tableCell_();\n            \n            sink.tableRow_();\n        }\n        \n        sink.table_();\n        sink.section1_();\n    }","id":66573,"modified_method":"public boolean isEnableFilesSummary()\n    {\n        return enableFilesSummary;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void doFileEvents( List eventList )\n    {\n        Iterator events = eventList.iterator();\n        while ( events.hasNext() )\n        {\n            AuditEvent event = (AuditEvent) events.next();\n            SeverityLevel level = event.getSeverityLevel();\n            \n            if ( getSeverityLevel() != null )\n                if ( !getSeverityLevel().equals( level ) ) continue;\n\n            sink.tableRow();\n            \n            sink.tableCell();\n            sink.figure();\n            sink.figureCaption();\n            sink.text( level.getName() );\n            sink.figureCaption_();\n            \n            if ( SeverityLevel.INFO.equals( level ) )\n                sink.figureGraphics( \"images/icon_info_sml.gif\" );\n            else if ( SeverityLevel.WARNING.equals( level ) )\n                sink.figureGraphics( \"images/icon_warning_sml.gif\" );\n            else if ( SeverityLevel.ERROR.equals( level ) )\n                sink.figureGraphics( \"images/icon_error_sml.gif\" );\n\n            sink.figure_();\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( String.valueOf( event.getLine() ) );\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n    }","id":66574,"modified_method":"private void doFileEvents( List eventList )\n    {\n        Iterator events = eventList.iterator();\n        while ( events.hasNext() )\n        {\n            AuditEvent event = (AuditEvent) events.next();\n            SeverityLevel level = event.getSeverityLevel();\n            \n            if ( getSeverityLevel() != null )\n                if ( !getSeverityLevel().equals( level ) ) continue;\n\n            sink.tableRow();\n            \n            sink.tableCell();\n            \n            if ( SeverityLevel.INFO.equals( level ) )\n                iconInfo();\n            else if ( SeverityLevel.WARNING.equals( level ) )\n                iconWarning();\n            else if ( SeverityLevel.ERROR.equals( level ) )\n                iconError();\n\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n            \n            sink.tableCell();\n            sink.text( String.valueOf( event.getLine() ) );\n            sink.tableCell_();\n\n            sink.tableRow_();\n            doxiaHack(); \n        }\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void doHeading()\n    {\n        sink.head();\n        sink.title();\n        sink.text( getTitle() );\n        sink.title_();\n        sink.head_();\n\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( getTitle() );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( bundle.getString( \"report.checkstyle.checkstylelink\" ) + \" \" );\n        sink.link( \"http://checkstyle.sourceforge.net/\" );\n        sink.text( \"Checkstyle\" );\n        sink.link_();\n        sink.paragraph_();\n    }","id":66575,"modified_method":"private void doHeading()\n    {\n        sink.head();\n        sink.title();\n        sink.text( getTitle() );\n        sink.title_();\n        sink.head_();\n\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( getTitle() );\n        sink.sectionTitle1_();\n        \n        doxiaHack(); \n        \n        sink.paragraph();\n        sink.text( bundle.getString( \"report.checkstyle.checkstylelink\" ) + \" \" );\n        sink.link( \"http://checkstyle.sourceforge.net/\" );\n        sink.text( \"Checkstyle\" );\n        sink.link_();\n        sink.text( \".\" );\n        \n        if(enableRSS)\n        {\n            sink.nonBreakingSpace();\n            sink.link( \"checkstyle.rss\" );\n            sink.figure();\n            sink.figureCaption();\n            sink.text( \"rss feed\" );\n            sink.figureCaption_();\n            sink.figureGraphics( \"images/rss.png\" );\n            sink.figure_();\n            sink.link_();\n        }\n        \n        sink.paragraph_();\n        doxiaHack(); \n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void auditStarted( AuditEvent event )\n    {\n        setFiles( new TreeMap() );\n    }","id":66576,"modified_method":"public void auditStarted( AuditEvent event )\n    {\n        setResults( new CheckstyleResults() );\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void fileStarted( AuditEvent event )\n    {\n        currentFile = StringUtils.substring( event.getFileName(), sourceDirectory.getPath().length() + 1 );\n        currentFile = StringUtils.replace( currentFile, \"\\\\\", \"/\" );\n\n        if ( !getFiles().containsKey( currentFile ) )\n            getFiles().put( currentFile, new LinkedList() );\n\n        events = (LinkedList) getFiles().get( currentFile );\n    }","id":66577,"modified_method":"public void fileStarted( AuditEvent event )\n    {\n        currentFile = StringUtils.substring( event.getFileName(), sourceDirectory.getPath().length() + 1 );\n        currentFile = StringUtils.replace( currentFile, \"\\\\\", \"/\" );\n\n        events = getResults().getFileViolations( currentFile );\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void fileFinished( AuditEvent event )\n    {\n        getFiles().put( currentFile, events );\n        currentFile = null;\n    }","id":66578,"modified_method":"public void fileFinished( AuditEvent event )\n    {\n        getResults().setFileViolations( currentFile, events );\n        currentFile = null;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * <p>\n     * Attempts to resolve a location parameter into a real file.\n     * <\/p>\n     * \n     * <p>\n     * Checks a location string to for a resource, URL, or File that matches.\n     * If a resource or URL is found, then a local file is created with that\n     * locations contents.\n     * <\/p>\n     * \n     * @param location the location string to match against.\n     * @param localfile the local file to use in case of resource or URL.\n     * @return the File of the resolved location.\n     * @throws IOException if file is unable to be found or copied into <code>localfile<\/code> destination.\n     */\n    public File resolveLocation( String location, String localfile )\n        throws IOException\n    {\n        getLog().debug( \"resolveLocation(\" + location + \", \" + localfile + \")\" );\n        if ( StringUtils.isEmpty( location ) )\n        {\n            return null;\n        }\n\n        File retFile = new File( localfile );\n\n        // Attempt a URL\n        if ( location.indexOf( \"://\" ) > 1 )\n        {\n            // Found a URL\n            URL url = new URL( location );\n            getLog().debug( \"Potential URL: \" + url.toExternalForm() );\n            FileUtils.copyURLToFile( url, retFile );\n        }\n        else\n        {\n            getLog().debug( \"Location is not a URL.\" );\n            // Attempt a File.\n            File fileLocation = new File( location );\n            if ( fileLocation.exists() )\n            {\n                // Found a File.\n                getLog().debug( \"Potential File: \" + fileLocation.getAbsolutePath() );\n                FileUtils.copyFile( fileLocation, retFile );\n            }\n            else\n            {\n                getLog().debug( \"Location is not a File.\" );\n                // Attempt a Resource.\n                URL url = this.getClass().getClassLoader().getResource( location );\n                if ( url != null )\n                {\n                    // Found a Resource.\n                    getLog().debug( \"Potential Resource: \" + url.toExternalForm() );\n                    FileUtils.copyURLToFile( url, retFile );\n                }\n                else\n                {\n                    getLog().debug( \"Location is not a Resource.\" );\n                    throw new IOException( \"Unable to find location '\" + location + \"' as URL, File or Resource.\" );\n                }\n            }\n        }\n\n        if ( !retFile.exists() )\n        {\n            throw new FileNotFoundException( \"Destination file does not exist.\" );\n        }\n\n        if ( retFile.length() <= 0 )\n        {\n            throw new IOException( \"Destination file has no content.\" );\n        }\n\n        return retFile;\n    }","id":66579,"modified_method":"/**\n     * <p>\n     * Attempts to resolve a location parameter into a real file.\n     * <\/p>\n     * \n     * <p>\n     * Checks a location string to for a resource, URL, or File that matches.\n     * If a resource or URL is found, then a local file is created with that\n     * locations contents.\n     * <\/p>\n     * \n     * @param location the location string to match against.\n     * @param localfile the local file to use in case of resource or URL.\n     * @return the File of the resolved location.\n     * @throws IOException if file is unable to be found or copied into <code>localfile<\/code> destination.\n     */\n    public File resolveLocation( String location, String localfile )\n        throws IOException\n    {\n        getLog().debug( \"resolveLocation(\" + location + \", \" + localfile + \")\" );\n        if ( StringUtils.isEmpty( location ) )\n        {\n            return null;\n        }\n\n        File retFile = new File( localDir, localfile );\n\n        // Attempt a URL\n        if ( location.indexOf( \"://\" ) > 1 )\n        {\n            // Found a URL\n            URL url = new URL( location );\n            getLog().debug( \"Potential URL: \" + url.toExternalForm() );\n            FileUtils.copyURLToFile( url, retFile );\n        }\n        else\n        {\n            getLog().debug( \"Location is not a URL.\" );\n            // Attempt a File.\n            File fileLocation = new File( location );\n            if ( fileLocation.exists() )\n            {\n                // Found a File.\n                getLog().debug( \"Potential File: \" + fileLocation.getAbsolutePath() );\n                FileUtils.copyFile( fileLocation, retFile );\n            }\n            else\n            {\n                getLog().debug( \"Location is not a File.\" );\n                // Attempt a Resource.\n                URL url = this.getClass().getClassLoader().getResource( location );\n                if ( url != null )\n                {\n                    // Found a Resource.\n                    getLog().debug( \"Potential Resource: \" + url.toExternalForm() );\n                    FileUtils.copyURLToFile( url, retFile );\n                }\n                else\n                {\n                    getLog().debug( \"Location is not a Resource.\" );\n                    throw new IOException( \"Unable to find location '\" + location + \"' as URL, File or Resource.\" );\n                }\n            }\n        }\n\n        if ( !retFile.exists() )\n        {\n            throw new FileNotFoundException( \"Destination file does not exist.\" );\n        }\n\n        if ( retFile.length() <= 0 )\n        {\n            throw new IOException( \"Destination file has no content.\" );\n        }\n\n        return retFile;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Create a Locator object.\n     * \n     * @param logger the logger object to log with.\n     */\n    public Locator( Log log )\n    {\n        this.log = log;\n    }","id":66580,"modified_method":"/**\n     * Create a Locator object.\n     * \n     * @param logger the logger object to log with.\n     * @param resolveToDir the directory to resolve resources into.\n     */\n    public Locator( Log log, File resolveToDir )\n    {\n        this.log = log;\n        this.localDir = resolveToDir;\n    }","commit_id":"89b36901724a285edf19d87b7a8c8fef8aea6b05","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static void main(String[] args) throws Exception {\n    new MinimumViableSystem().check();\n    CommandLineParser cli = new CommandLineParser();\n    Properties rawProperties = cli.parseArguments(args);\n    Props props = new PropsBuilder(rawProperties, new JdbcSettings()).build();\n    new ProcessLogging().configure(props, \"/org/sonar/application/logback.xml\");\n    App app = new App();\n\n    // start and wait for shutdown command\n    app.start(props);\n\n    LoggerFactory.getLogger(App.class).info(\"stopped\");\n    System.exit(app.isSuccess() ? 0 : 1);\n  }","id":66581,"modified_method":"public static void main(String[] args) {\n\n    new MinimumViableSystem().check();\n    CommandLineParser cli = new CommandLineParser();\n    Properties rawProperties = cli.parseArguments(args);\n    Props props = null;\n\n    try {\n      props = new PropsBuilder(rawProperties, new JdbcSettings()).build();\n      new ProcessLogging().configure(props, \"/org/sonar/application/logback.xml\");\n    } catch (IOException e) {\n      throw new IllegalStateException(e.getMessage());\n    } catch (URISyntaxException e) {\n      throw new IllegalStateException(e.getMessage());\n    }\n\n    App app = new App();\n\n    try {\n      // start and wait for shutdown command\n      app.start(props);\n    } catch (InterruptedException e) {\n      LoggerFactory.getLogger(App.class).info(\"interrupted\");\n    } finally {\n      LoggerFactory.getLogger(App.class).info(\"stopped\");\n      System.exit(app.isSuccess() ? 0 : 1);\n    }\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void start(Props props) throws InterruptedException {\n    try {\n      Logger logger = LoggerFactory.getLogger(getClass());\n      monitor.start();\n\n      File homeDir = props.fileOf(\"sonar.path.home\");\n      File tempDir = props.fileOf(\"sonar.path.temp\");\n      elasticsearch = new ProcessWrapper(JmxUtils.SEARCH_SERVER_NAME)\n        .setWorkDir(homeDir)\n        .setJmxPort(props.intOf(DefaultSettings.SEARCH_JMX_PORT))\n        .addJavaOpts(props.of(DefaultSettings.SEARCH_JAVA_OPTS))\n        .setTempDirectory(tempDir.getAbsoluteFile())\n        .setClassName(\"org.sonar.search.SearchServer\")\n        .addProperties(props.rawProperties())\n        .addClasspath(\"./lib/common/*\")\n        .addClasspath(\"./lib/search/*\");\n      if (elasticsearch.execute()) {\n        monitor.registerProcess(elasticsearch);\n        if (elasticsearch.waitForReady()) {\n          logger.info(\"search server is up\");\n\n          // do not yet start SQ in cluster mode. See SONAR-5483 & SONAR-5391\n          if (StringUtils.isEmpty(props.of(DefaultSettings.CLUSTER_MASTER, null))) {\n            server = new ProcessWrapper(JmxUtils.WEB_SERVER_NAME)\n              .setWorkDir(homeDir)\n              .setJmxPort(props.intOf(DefaultSettings.WEB_JMX_PORT))\n              .addJavaOpts(props.of(DefaultSettings.WEB_JAVA_OPTS))\n              .setTempDirectory(tempDir.getAbsoluteFile())\n              // required for logback tomcat valve\n              .setLogDir(props.fileOf(\"sonar.path.logs\"))\n              .setClassName(\"org.sonar.server.app.WebServer\")\n              .addProperties(props.rawProperties())\n              .addClasspath(\"./lib/common/*\")\n              .addClasspath(\"./lib/server/*\");\n            String driverPath = props.of(JdbcSettings.PROPERTY_DRIVER_PATH);\n            if (driverPath != null) {\n              server.addClasspath(driverPath);\n            }\n            if (server.execute()) {\n              monitor.registerProcess(server);\n              if (server.waitForReady()) {\n                success = true;\n                logger.info(\"web server is up\");\n                monitor.join();\n              }\n            }\n          } else {\n            success = true;\n            monitor.join();\n          }\n        }\n      }\n    } finally {\n      terminate();\n    }\n  }","id":66582,"modified_method":"public void start(Props props) throws InterruptedException {\n    try {\n      Logger logger = LoggerFactory.getLogger(getClass());\n      monitor.start();\n\n      File homeDir = props.fileOf(\"sonar.path.home\");\n      File tempDir = props.fileOf(\"sonar.path.temp\");\n      elasticsearch = new ProcessWrapper(JmxUtils.SEARCH_SERVER_NAME);\n      elasticsearch\n        .setWorkDir(homeDir)\n        .setJmxPort(props.intOf(DefaultSettings.SEARCH_JMX_PORT))\n        .addJavaOpts(props.of(DefaultSettings.SEARCH_JAVA_OPTS))\n        .setTempDirectory(tempDir.getAbsoluteFile())\n        .setClassName(\"org.sonar.search.SearchServer\")\n        .addProperties(props.rawProperties())\n        .addClasspath(\"./lib/common/*\")\n        .addClasspath(\"./lib/search/*\");\n      if (elasticsearch.execute()) {\n        monitor.registerProcess(elasticsearch);\n        if (elasticsearch.waitForReady()) {\n          logger.info(\"search server is up\");\n\n          // do not yet start SQ in cluster mode. See SONAR-5483 & SONAR-5391\n          if (StringUtils.isEmpty(props.of(DefaultSettings.CLUSTER_MASTER, null))) {\n            server = new ProcessWrapper(JmxUtils.WEB_SERVER_NAME)\n              .setWorkDir(homeDir)\n              .setJmxPort(props.intOf(DefaultSettings.WEB_JMX_PORT))\n              .addJavaOpts(props.of(DefaultSettings.WEB_JAVA_OPTS))\n              .setTempDirectory(tempDir.getAbsoluteFile())\n                // required for logback tomcat valve\n              .setLogDir(props.fileOf(\"sonar.path.logs\"))\n              .setClassName(\"org.sonar.server.app.WebServer\")\n              .addProperties(props.rawProperties())\n              .addClasspath(\"./lib/common/*\")\n              .addClasspath(\"./lib/server/*\");\n            String driverPath = props.of(JdbcSettings.PROPERTY_DRIVER_PATH);\n            if (driverPath != null) {\n              server.addClasspath(driverPath);\n            }\n            if (server.execute()) {\n              monitor.registerProcess(server);\n              if (server.waitForReady()) {\n                success = true;\n                logger.info(\"web server is up\");\n                monitor.join();\n              }\n            }\n          } else {\n            success = true;\n            monitor.join();\n          }\n        }\n      }\n    } finally {\n      terminate();\n    }\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public final void terminate() {\n    if (monitor != null) {\n      Logger logger = LoggerFactory.getLogger(getClass());\n      logger.debug(\"Process[{}] terminating\", name);\n      monitor.shutdownNow();\n      monitor = null;\n      if (pingTask != null) {\n        pingTask.cancel(true);\n        pingTask = null;\n      }\n      try {\n        doTerminate();\n      } catch (Exception e) {\n        LoggerFactory.getLogger(getClass()).error(\"Fail to terminate \" + name, e);\n        // do not propagate exception\n      }\n      logger.debug(\"Process[{}] terminated\", name);\n      terminated = true;\n    }\n  }","id":66583,"modified_method":"@Override\n  public final void terminate() {\n    if (monitor != null) {\n      LOGGER.debug(\"Process[{}] terminating\", name);\n      monitor.shutdownNow();\n      monitor = null;\n      if (pingTask != null) {\n        pingTask.cancel(true);\n        pingTask = null;\n      }\n      try {\n        doTerminate();\n      } catch (Exception e) {\n        LOGGER.error(\"Fail to terminate \" + name, e);\n        // do not propagate exception\n      }\n      LOGGER.debug(\"Process[{}] terminated\", name);\n      terminated = true;\n    }\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public final void start() {\n    if (monitor != null) {\n      throw new IllegalStateException(\"Already started\");\n    }\n\n    Logger logger = LoggerFactory.getLogger(getClass());\n    logger.debug(\"Process[{}] starting\", name);\n    scheduleAutokill(this.isMonitored);\n    doStart();\n    logger.debug(\"Process[{}] started\", name);\n  }","id":66584,"modified_method":"public final void start() {\n    if (monitor != null) {\n      throw new IllegalStateException(\"Already started\");\n    }\n    LOGGER.debug(\"Process[{}] starting\", name);\n    scheduleAutokill(this.isMonitored);\n    doStart();\n    LOGGER.debug(\"Process[{}] started\", name);\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static File detectHomeDir() throws Exception {\n    File appJar = new File(PropsBuilder.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n    return appJar.getParentFile().getParentFile();\n  }","id":66585,"modified_method":"static File detectHomeDir() throws URISyntaxException {\n    File appJar = new File(PropsBuilder.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n    return appJar.getParentFile().getParentFile();\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Load optional conf/sonar.properties, interpolates environment variables and\n   * initializes file system\n   */\n  Props build() throws Exception {\n    Properties p = loadPropertiesFile(homeDir);\n    p.putAll(rawProperties);\n    p.setProperty(\"sonar.path.home\", homeDir.getAbsolutePath());\n    p = ConfigurationUtils.interpolateVariables(p, System.getenv());\n\n    // the difference between Properties and Props is that the latter\n    // supports decryption of values, so it must be used when values\n    // are accessed\n    Props props = new Props(p);\n    DefaultSettings.init(props);\n\n    // init file system\n    initExistingDir(props, \"sonar.path.data\", \"data\");\n    initExistingDir(props, \"sonar.path.web\", \"web\");\n    initExistingDir(props, \"sonar.path.logs\", \"logs\");\n    initTempDir(props);\n\n    // check JDBC properties and set path to driver\n    jdbcSettings.checkAndComplete(homeDir, props);\n\n    return props;\n  }","id":66586,"modified_method":"/**\n   * Load optional conf/sonar.properties, interpolates environment variables and\n   * initializes file system\n   */\n  Props build() throws IOException {\n    Properties p = loadPropertiesFile(homeDir);\n    p.putAll(rawProperties);\n    p.setProperty(\"sonar.path.home\", homeDir.getAbsolutePath());\n    p = ConfigurationUtils.interpolateVariables(p, System.getenv());\n\n    // the difference between Properties and Props is that the latter\n    // supports decryption of values, so it must be used when values\n    // are accessed\n    Props props = new Props(p);\n    DefaultSettings.init(props);\n\n    // init file system\n    initExistingDir(props, \"sonar.path.data\", \"data\");\n    initExistingDir(props, \"sonar.path.web\", \"web\");\n    initExistingDir(props, \"sonar.path.logs\", \"logs\");\n    initTempDir(props);\n\n    // check JDBC properties and set path to driver\n    jdbcSettings.checkAndComplete(homeDir, props);\n\n    return props;\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"PropsBuilder(Properties rawProperties, JdbcSettings jdbcSettings) throws Exception {\n    this(rawProperties, jdbcSettings, detectHomeDir());\n  }","id":66587,"modified_method":"PropsBuilder(Properties rawProperties, JdbcSettings jdbcSettings) throws URISyntaxException {\n    this(rawProperties, jdbcSettings, detectHomeDir());\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SearchServer(Props props, boolean monitored, boolean blocking) throws Exception {\n    super(props, monitored);\n    this.isBlocking = blocking;\n    new MinimumViableSystem().check();\n\n    if (StringUtils.isNotEmpty(props.of(ES_CLUSTER_INET, null))) {\n      Collections.addAll(nodes, props.of(ES_CLUSTER_INET).split(\",\"));\n    }\n  }","id":66588,"modified_method":"public SearchServer(final Props props, boolean monitored, boolean blocking) {\n    super(props, monitored);\n\n    this.isBlocking = blocking;\n    new MinimumViableSystem().check();\n\n    String ESNodesInets = props.of(ES_CLUSTER_INET);\n    if (StringUtils.isNotEmpty(ESNodesInets)) {\n      Collections.addAll(nodes, ESNodesInets.split(\",\"));\n    }\n  }","commit_id":"46bd831271222c3a9ae5c51a77e1ad693f1cc3e9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public DefaultLoggingManager captureSystemSources() {\n        stdOutLoggingSystem.setLevel(LogLevel.QUIET);\n        stdErrLoggingSystem.setLevel(LogLevel.ERROR);\n        return this;\n    }","id":66589,"modified_method":"@Override\n    public DefaultLoggingManager captureSystemSources() {\n        stdOutLoggingSystem.enableCapture();\n        stdErrLoggingSystem.enableCapture();\n        javaUtilLoggingSystem.enableCapture();\n        return this;\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultLoggingManager start() {\n        started = true;\n        for (StandardOutputListener stdoutListener : stdoutListeners) {\n            loggingOutput.addStandardOutputListener(stdoutListener);\n        }\n        for (StandardOutputListener stderrListener : stderrListeners) {\n            loggingOutput.addStandardErrorListener(stderrListener);\n        }\n        for (OutputEventListener outputEventListener : outputEventListeners) {\n            loggingOutput.addOutputEventListener(outputEventListener);\n        }\n        loggingRouter.start();\n        slf4jLoggingSystem.start();\n        javaUtilLoggingSystem.start();\n        stdOutLoggingSystem.start();\n        stdErrLoggingSystem.start();\n\n        return this;\n    }","id":66590,"modified_method":"public DefaultLoggingManager start() {\n        started = true;\n        for (StandardOutputListener stdoutListener : stdoutListeners) {\n            loggingOutput.addStandardOutputListener(stdoutListener);\n        }\n        for (StandardOutputListener stderrListener : stderrListeners) {\n            loggingOutput.addStandardErrorListener(stderrListener);\n        }\n        for (OutputEventListener outputEventListener : outputEventListeners) {\n            loggingOutput.addOutputEventListener(outputEventListener);\n        }\n        loggingRouter.start();\n\n        slf4jLoggingSystem.enableCapture();\n        slf4jLoggingSystem.start();\n\n        javaUtilLoggingSystem.start();\n        stdOutLoggingSystem.start();\n        stdErrLoggingSystem.start();\n\n        return this;\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public void setLevel(LogLevel logLevel) {\n            if (this.level == logLevel) {\n                return;\n            }\n\n            this.level = logLevel;\n            if (originalState == null) {\n                // Not started, don't apply the changes\n                return;\n            }\n            loggingSystem.on(logLevel, logLevel);\n        }","id":66591,"modified_method":"/**\n         * Sets the logging level for this log system. Does not take effect until started .\n         */\n        public void setLevel(LogLevel logLevel) {\n            if (this.level == logLevel) {\n                return;\n            }\n\n            this.level = logLevel;\n            if (originalState != null) {\n                // started, update the log level\n                loggingSystem.setLevel(logLevel);\n            }\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public void start() {\n            if (level != null) {\n                originalState = loggingSystem.on(level, level);\n            } else {\n                originalState = loggingSystem.snapshot();\n            }\n        }","id":66592,"modified_method":"/**\n         * Start this logging system: take a snapshot of the current state and start capturing events if enabled.\n         */\n        public void start() {\n            originalState = loggingSystem.snapshot();\n            if (level != null) {\n                loggingSystem.setLevel(level);\n            }\n            if (enabled) {\n                loggingSystem.startCapture();\n            }\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public void stop() {\n            try {\n                if (originalState != null) {\n                    loggingSystem.restore(originalState);\n                }\n            } finally {\n                originalState = null;\n            }\n        }","id":66593,"modified_method":"/**\n         * Stops this logging system. Restores state from when started.\n         */\n        public void stop() {\n            try {\n                if (originalState != null) {\n                    loggingSystem.restore(originalState);\n                }\n            } finally {\n                enabled = false;\n                originalState = null;\n            }\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public SnapshotImpl(boolean installed, java.util.logging.Level level) {\n            this.installed = installed;\n            this.level = level;\n        }","id":66594,"modified_method":"SnapshotImpl(boolean installed, Level javaUtilLevel, LogLevel requestedLevel) {\n            this.installed = installed;\n            this.javaUtilLevel = javaUtilLevel;\n            this.requestedLevel = requestedLevel;\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void restore(Snapshot state) {\n        SnapshotImpl snapshot = (SnapshotImpl) state;\n        if (snapshot.installed) {\n            install(snapshot.level);\n        } else {\n            uninstall(snapshot.level);\n        }\n    }","id":66595,"modified_method":"@Override\n    public void restore(Snapshot state) {\n        SnapshotImpl snapshot = (SnapshotImpl) state;\n        requestedLevel = snapshot.requestedLevel;\n        if (snapshot.installed) {\n            install(snapshot.javaUtilLevel);\n        } else {\n            uninstall(snapshot.javaUtilLevel);\n        }\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Snapshot snapshot() {\n        return new SnapshotImpl(installed, logger.getLevel());\n    }","id":66596,"modified_method":"@Override\n    public Snapshot snapshot() {\n        return new SnapshotImpl(installed, logger.getLevel(), requestedLevel);\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Snapshot on(LogLevel minimumLevel, LogLevel defaultLevel) {\n        SnapshotImpl snapshot = new SnapshotImpl(installed, logger.getLevel());\n        install(LOG_LEVEL_MAPPING.get(minimumLevel));\n        return snapshot;\n    }","id":66597,"modified_method":"@Override\n    public Snapshot setLevel(LogLevel logLevel) {\n        Snapshot snapshot = snapshot();\n        if (logLevel != requestedLevel) {\n            requestedLevel = logLevel;\n            if (installed) {\n                logger.setLevel(LOG_LEVEL_MAPPING.get(logLevel));\n            }\n        }\n        return snapshot;\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"protected DefaultLoggingManagerFactory createLoggingManagerFactory() {\n        OutputEventRenderer renderer = get(OutputEventRenderer.class);\n        LoggingSourceSystem stdout = new DefaultStdOutLoggingSystem(getStdoutListener(), get(TimeProvider.class));\n        LoggingSourceSystem stderr = new DefaultStdErrLoggingSystem(new TextStreamOutputEventListener(get(OutputEventListener.class)), get(TimeProvider.class));\n        return new DefaultLoggingManagerFactory(\n                renderer,\n                new LoggingSystemAdapter(new Slf4jLoggingConfigurer(renderer)),\n                new JavaUtilLoggingSystem(),\n                stdout,\n                stderr);\n    }","id":66598,"modified_method":"protected DefaultLoggingManagerFactory createLoggingManagerFactory() {\n        OutputEventRenderer renderer = get(OutputEventRenderer.class);\n        LoggingSourceSystem stdout = new DefaultStdOutLoggingSystem(getStdoutListener(), get(TimeProvider.class));\n        stdout.setLevel(LogLevel.QUIET);\n        LoggingSourceSystem stderr = new DefaultStdErrLoggingSystem(new TextStreamOutputEventListener(get(OutputEventListener.class)), get(TimeProvider.class));\n        stderr.setLevel(LogLevel.ERROR);\n        return new DefaultLoggingManagerFactory(\n                renderer,\n                new LoggingSystemAdapter(new Slf4jLoggingConfigurer(renderer)),\n                new JavaUtilLoggingSystem(),\n                stdout,\n                stderr);\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public SnapshotImpl(LogLevel level) {\n            this.level = level;\n        }","id":66599,"modified_method":"SnapshotImpl(boolean enabled, LogLevel level) {\n            this.enabled = enabled;\n            this.level = level;\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"private void setLevel(LogLevel level) {\n        configurer.configure(level);\n        this.logLevel = level;\n    }","id":66600,"modified_method":"@Override\n    public Snapshot setLevel(LogLevel logLevel) {\n        Snapshot snapshot = snapshot();\n        if (this.logLevel != logLevel) {\n            this.logLevel = logLevel;\n            if (enabled) {\n                configurer.configure(logLevel);\n            }\n        }\n        return snapshot;\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public Snapshot snapshot() {\n        return new SnapshotImpl(logLevel);\n    }","id":66601,"modified_method":"public Snapshot snapshot() {\n        return new SnapshotImpl(enabled, logLevel);\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public void restore(Snapshot state) {\n        LogLevel oldLevel = ((SnapshotImpl) state).level;\n        this.logLevel = oldLevel;\n        if (oldLevel != null) {\n            configurer.configure(oldLevel);\n        }\n    }","id":66602,"modified_method":"public void restore(Snapshot state) {\n        SnapshotImpl snapshot = (SnapshotImpl) state;\n        logLevel = snapshot.level;\n        enabled = snapshot.enabled;\n        configurer.configure(logLevel);\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Snapshot on(LogLevel minimumLevel, LogLevel defaultLevel) {\n        return dummy();\n    }","id":66603,"modified_method":"@Override\n    public Snapshot setLevel(LogLevel logLevel) {\n        return dummy();\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Snapshot on(LogLevel minimumLevel, LogLevel defaultLevel) {\n        Snapshot snapshot = snapshot();\n        if (original == null) {\n            PrintStream originalStream = get();\n            original = new PrintStreamDestination(originalStream);\n        }\n        outstr.flush();\n        if (get() != outstr) {\n            set(outstr);\n        }\n        this.logLevel = defaultLevel;\n        outputEventListener.onOutput(new LogLevelChangeEvent(logLevel));\n        destination.set(listener);\n        return snapshot;\n    }","id":66604,"modified_method":"@Override\n    public Snapshot setLevel(LogLevel logLevel) {\n        Snapshot snapshot = snapshot();\n        if (logLevel != this.logLevel) {\n            this.logLevel = logLevel;\n            if (enabled) {\n                outstr.flush();\n                outputEventListener.onOutput(new LogLevelChangeEvent(logLevel));\n            }\n        }\n        return snapshot;\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public Snapshot snapshot() {\n        return new SnapshotImpl(logLevel);\n    }","id":66605,"modified_method":"public Snapshot snapshot() {\n        return new SnapshotImpl(enabled, logLevel);\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public SnapshotImpl(LogLevel logLevel) {\n            this.logLevel = logLevel;\n        }","id":66606,"modified_method":"public SnapshotImpl(boolean enabled, LogLevel logLevel) {\n            this.enabled = enabled;\n            this.logLevel = logLevel;\n        }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"public void restore(Snapshot state) {\n        SnapshotImpl snapshot = (SnapshotImpl) state;\n        if (snapshot.logLevel == null) {\n            off();\n        } else {\n            on(snapshot.logLevel, snapshot.logLevel);\n        }\n    }","id":66607,"modified_method":"public void restore(Snapshot state) {\n        SnapshotImpl snapshot = (SnapshotImpl) state;\n        enabled = snapshot.enabled;\n        logLevel = snapshot.logLevel;\n        if (enabled) {\n            install();\n        } else {\n            uninstall();\n        }\n    }","commit_id":"ae53ac1ecb6cdc8d5333561e985b6d4dc5662c8e","url":"https://github.com/gradle/gradle"},{"original_method":"protected HttpMethod execute(UMOEvent event, boolean closeConnection) throws Exception\n    {\n        String method = (String) event.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_POST);\n        URI uri = event.getEndpoint().getEndpointURI().getUri();\n        HttpMethod httpMethod = null;\n        Object body = event.getTransformedMessage();\n        if (body instanceof HttpMethod) {\n            httpMethod = (HttpMethod) body;\n        } else if (\"GET\".equalsIgnoreCase(method) || body instanceof NullPayload) {\n            httpMethod = new GetMethod(uri.toString());\n        } else {\n            PostMethod postMethod = new PostMethod(uri.toString());\n\n            if (body instanceof String) {\n                ObjectToHttpClientMethodRequest trans = new ObjectToHttpClientMethodRequest();\n                httpMethod = (HttpMethod) trans.transform(body.toString());\n            } else if (body instanceof HttpMethod) {\n                httpMethod = (HttpMethod) body;\n            } else {\n                byte[] buffer = event.getTransformedMessageAsBytes();\n                postMethod.setRequestBody(new ByteArrayInputStream(buffer));\n                postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                httpMethod = postMethod;\n            }\n\n        }\n\n        HttpConnection connection = null;\n        try {\n            connection = getConnection(uri);\n\n            if (connection.isProxied() && connection.isSecure()) {\n                httpMethod = new ConnectMethod(httpMethod);\n            }\n            httpMethod.setDoAuthentication(true);\n\n            if (event.getCredentials() != null) {\n                // Add User Creds\n                StringBuffer header = new StringBuffer();\n                header.append(\"Basic \");\n                String creds = event.getCredentials().getUsername().getBytes() + \":\" + new String(event.getCredentials().getPassword());\n                header.append(new BASE64Encoder().encode(creds.getBytes()));\n                httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n            }\n\n            try {\n                httpMethod.execute(state, connection);\n            } catch (BindException e) {\n                //retry\n                Thread.sleep(100);\n                httpMethod.execute(state, connection);\n            }\n            return httpMethod;\n        } catch (Exception e) {\n            if (httpMethod != null)\n                httpMethod.releaseConnection();\n                connection.close();\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        } finally {\n            if(connection!=null && closeConnection) {\n                connection.close();\n            }\n        }\n    }","id":66608,"modified_method":"protected HttpMethod execute(UMOEvent event, boolean closeConnection) throws Exception\n    {\n        String method = (String) event.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_POST);\n        URI uri = event.getEndpoint().getEndpointURI().getUri();\n        HttpMethod httpMethod = null;\n        Object body = event.getTransformedMessage();\n        if (body instanceof HttpMethod) {\n            httpMethod = (HttpMethod) body;\n        } else if (\"GET\".equalsIgnoreCase(method) || body instanceof NullPayload) {\n            httpMethod = new GetMethod(uri.toString());\n        } else {\n            PostMethod postMethod = new PostMethod(uri.toString());\n\n            if (body instanceof String) {\n                ObjectToHttpClientMethodRequest trans = new ObjectToHttpClientMethodRequest();\n                httpMethod = (HttpMethod) trans.transform(body.toString());\n            } else if (body instanceof HttpMethod) {\n                httpMethod = (HttpMethod) body;\n            } else {\n                byte[] buffer = event.getTransformedMessageAsBytes();\n                postMethod.setRequestBody(new ByteArrayInputStream(buffer));\n                postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                httpMethod = postMethod;\n            }\n\n        }\n\n        HttpConnection connection = null;\n        try {\n            connection = getConnection(uri);\n\n            if (connection.isProxied() && connection.isSecure()) {\n                httpMethod = new ConnectMethod(httpMethod);\n            }\n            httpMethod.setDoAuthentication(true);\n\n            if (event.getCredentials() != null) {\n                // Add User Creds\n                StringBuffer header = new StringBuffer();\n                header.append(\"Basic \");\n                String creds = event.getCredentials().getUsername().getBytes() + \":\" + new String(event.getCredentials().getPassword());\n                header.append(new BASE64Encoder().encode(creds.getBytes()));\n                httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n            }\n\n            try {\n                httpMethod.execute(state, connection);\n            } catch (BindException e) {\n                //retry\n                Thread.sleep(100);\n                httpMethod.execute(state, connection);\n            } catch(HttpRecoverableException e) {\n                logger.error(e, e);\n            }\n            return httpMethod;\n        } catch (Exception e) {\n            if (httpMethod != null)\n                httpMethod.releaseConnection();\n                connection.close();\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        } finally {\n            if(connection!=null && closeConnection) {\n                connection.close();\n            }\n        }\n    }","commit_id":"20190f586edc97bd3bc4d369ba26080f0aa1b115","url":"https://github.com/mulesoft/mule"},{"original_method":"protected AbstractMessageReceiver getTargetReceiver(UMOMessage message, UMOEndpoint endpoint) throws ConnectException {\n\n        String path = (String) message.getProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        int i = path.indexOf(\"?\");\n        if (i > -1) path = path.substring(0, i);\n\n        StringBuffer requestUri = new StringBuffer();\n        requestUri.append(endpoint.getProtocol()).append(\"://\");\n        requestUri.append(endpoint.getEndpointURI().getHost());\n        requestUri.append(\":\").append(endpoint.getEndpointURI().getPort());\n        //first check there is a receive on the root address\n        AbstractMessageReceiver receiver = connector.getReceiver(requestUri.toString());\n        //If no receiver on the root and there is a request path, look up the received based on the\n        //root plus request path\n        if (receiver == null && !\"/\".equals(path)) {\n            //remove anything after the last '/'\n            int x = path.lastIndexOf(\"/\");\n            if (x > 1 && path.indexOf(\".\") > x) {\n                requestUri.append(path.substring(0, x));\n            } else {\n                requestUri.append(path);\n            }\n            receiver = connector.getReceiver(requestUri.toString());\n        }\n        if (receiver == null) {\n\n            throw new ConnectException(new Message(Messages.CANNOT_BIND_TO_ADDRESS_X, requestUri.toString()), this);\n        }\n        return receiver;\n    }","id":66609,"modified_method":"protected AbstractMessageReceiver getTargetReceiver(UMOMessage message, UMOEndpoint endpoint) throws ConnectException {\n\n        String path = (String) message.getProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        int i = path.indexOf(\"?\");\n        if (i > -1) path = path.substring(0, i);\n\n        StringBuffer requestUri = new StringBuffer();\n        requestUri.append(endpoint.getProtocol()).append(\"://\");\n        requestUri.append(endpoint.getEndpointURI().getHost());\n        requestUri.append(\":\").append(endpoint.getEndpointURI().getPort());\n        //first check there is a receive on the root address\n        AbstractMessageReceiver receiver = connector.getReceiver(requestUri.toString());\n        //If no receiver on the root and there is a request path, look up the received based on the\n        //root plus request path\n        if (receiver == null && !\"/\".equals(path)) {\n            //remove anything after the last '/'\n            int x = path.lastIndexOf(\"/\");\n            if (x > 1 && path.indexOf(\".\") > x) {\n                requestUri.append(path.substring(0, x));\n            } else {\n                requestUri.append(path);\n            }\n            receiver = connector.getReceiver(requestUri.toString());\n        }\n        return receiver;\n    }","commit_id":"20190f586edc97bd3bc4d369ba26080f0aa1b115","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run() {\n            boolean keepAlive;\n            try {\n                dataIn = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n                dataOut = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n                do {\n                    if (disposing.get() || socket.isClosed()) {\n                        logger.debug(\"Peer closed connection\");\n                        break;\n                    }\n\n                    Properties headers = new Properties();\n                    Object payload = parseRequest(dataIn, headers);\n                    if (payload == null) {\n                        break;\n                    }\n\n                    UMOMessageAdapter adapter = connector.getMessageAdapter(new Object[]{payload, headers});\n\n                    keepAlive = adapter.getBooleanProperty(HttpConstants.HEADER_KEEP_ALIVE, true);\n                    //Removed the keep alive monitoring stuff for now\n                    //Most other http servers tend not to worry about the keep-alive time out\n                    //nstead just wait for the client to disconnect\n//                    if (keepAlive && !keepAliveRegistered) {\n//                        keepAliveRegistered = true;\n//                        if (keepAliveMonitor != null) {\n//                            keepAliveMonitor.addExpirable(((HttpConnector) connector).getKeepAliveTimeout(), this);\n//                        } else {\n//                            logger.info(\"Request has Keep alive set but the HttpConnector has keep alive disables\");\n//                            keepAlive = false;\n//                        }\n//                    }\n\n                    UMOMessage message = new MuleMessage(adapter);\n\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(message.getProperty(HttpConnector.HTTP_REQUEST_PROPERTY));\n                    }\n                    OutputStream os = new ResponseOutputStream(dataOut, socket);\n\n                    //determine if the request path on this request denotes a different receiver\n                    AbstractMessageReceiver receiver = getTargetReceiver(message, endpoint);\n                    UMOMessage returnMessage = receiver.routeMessage(message, endpoint.isSynchronous(), os);\n\n                    if (returnMessage == null) {\n                        returnMessage = new MuleMessage(\"\");\n                    }\n\n                    RequestContext.rewriteEvent(returnMessage);\n\n                    Object response = responseTransformer.transform(returnMessage.getPayload());\n                    if (response instanceof byte[]) {\n                        dataOut.write((byte[]) response);\n                    } else {\n                        dataOut.write(response.toString().getBytes());\n                    }\n                    dataOut.flush();\n//                        if (keepAliveMonitor != null) {\n//                            keepAliveMonitor.resetExpirable(this);\n//                        }\n                } while (socket.isConnected() && keepAlive);\n            } catch (Exception e) {\n                keepAlive = false;\n                handleException(e);\n            } finally {\n//                if (keepAliveMonitor != null) {\n//                    keepAliveMonitor.removeExpirable(this);\n//                }\n                dispose();\n            }\n        }","id":66610,"modified_method":"public void run() {\n            boolean keepAlive;\n            try {\n                dataIn = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n                dataOut = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n                do {\n                    if (disposing.get() || socket.isClosed()) {\n                        logger.debug(\"Peer closed connection\");\n                        break;\n                    }\n\n                    Properties headers = new Properties();\n                    Object payload = parseRequest(dataIn, headers);\n                    if (payload == null) {\n                        break;\n                    }\n\n                    UMOMessageAdapter adapter = connector.getMessageAdapter(new Object[]{payload, headers});\n\n                    keepAlive = adapter.getBooleanProperty(HttpConstants.HEADER_KEEP_ALIVE, true);\n                    //Removed the keep alive monitoring stuff for now\n                    //Most other http servers tend not to worry about the keep-alive time out\n                    //nstead just wait for the client to disconnect\n//                    if (keepAlive && !keepAliveRegistered) {\n//                        keepAliveRegistered = true;\n//                        if (keepAliveMonitor != null) {\n//                            keepAliveMonitor.addExpirable(((HttpConnector) connector).getKeepAliveTimeout(), this);\n//                        } else {\n//                            logger.info(\"Request has Keep alive set but the HttpConnector has keep alive disables\");\n//                            keepAlive = false;\n//                        }\n//                    }\n\n                    UMOMessage message = new MuleMessage(adapter);\n\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(message.getProperty(HttpConnector.HTTP_REQUEST_PROPERTY));\n                    }\n                    OutputStream os = new ResponseOutputStream(dataOut, socket);\n\n                    //determine if the request path on this request denotes a different receiver\n                    AbstractMessageReceiver receiver = getTargetReceiver(message, endpoint);\n\n                    UMOMessage returnMessage = null;\n                    if(receiver!=null) {\n                        returnMessage = receiver.routeMessage(message, endpoint.isSynchronous(), os);\n                        if (returnMessage == null) {\n                            returnMessage = new MuleMessage(\"\");\n                            RequestContext.rewriteEvent(returnMessage);\n                        }\n                    } else {\n                        returnMessage = new MuleMessage(new Message(Messages.CANNOT_BIND_TO_ADDRESS_X, endpoint.getEndpointURI().toString()).toString());\n                        returnMessage.setIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_NOT_FOUND);\n                        RequestContext.setEvent(new MuleEvent(returnMessage, endpoint, new MuleSession(), true));\n                    }\n\n                    Object response = responseTransformer.transform(returnMessage);\n                    if (response instanceof byte[]) {\n                        dataOut.write((byte[]) response);\n                    } else {\n                        dataOut.write(response.toString().getBytes());\n                    }\n                    dataOut.flush();\n//                        if (keepAliveMonitor != null) {\n//                            keepAliveMonitor.resetExpirable(this);\n//                        }\n                } while (socket.isConnected() && keepAlive);\n            } catch (Exception e) {\n                keepAlive = false;\n                handleException(e);\n            } finally {\n//                if (keepAliveMonitor != null) {\n//                    keepAliveMonitor.removeExpirable(this);\n//                }\n                dispose();\n            }\n        }","commit_id":"20190f586edc97bd3bc4d369ba26080f0aa1b115","url":"https://github.com/mulesoft/mule"},{"original_method":"public void poll()\n    {\n        try\n        {\n            if (sendStream)\n            {\n                PushbackInputStream in = new PushbackInputStream(inputStream);\n\n                //Block until we have some data\n                int i = in.read();\n                //Roll back our read\n                in.unread(i);\n                MuleMessage message = new DefaultMuleMessage(connector.getMessageAdapter(in), connector.getMuleContext());\n                routeMessage(message, endpoint.isSynchronous());\n            }\n            else\n            {\n                byte[] inputBuffer = new byte[bufferSize];\n                int len = inputStream.read(inputBuffer);\n\n                if (len == -1)\n                {\n                    return;\n                }\n\n                StringBuffer fullBuffer = new StringBuffer(bufferSize);\n                while (len > 0)\n                {\n                    fullBuffer.append(new String(inputBuffer, 0, len));\n                    len = 0; // mark as read\n                    if (inputStream.available() > 0)\n                    {\n                        len = inputStream.read(inputBuffer);\n                    }\n                }\n\n                // remove any trailing CR/LF\n                String finalMessageString;\n                int noCRLFLength = fullBuffer.length() - SystemUtils.LINE_SEPARATOR.length();\n                if (fullBuffer.indexOf(SystemUtils.LINE_SEPARATOR, noCRLFLength) != -1)\n                {\n                    finalMessageString = fullBuffer.substring(0, noCRLFLength);\n                }\n                else\n                {\n                    finalMessageString = fullBuffer.toString();\n                }\n\n                MuleMessage message = new DefaultMuleMessage(connector.getMessageAdapter(finalMessageString), connector.getMuleContext());\n                routeMessage(message, endpoint.isSynchronous());\n            }\n\n            doConnect();\n        }\n        catch (Exception e)\n        {\n            handleException(e);\n        }\n    }","id":66611,"modified_method":"public void poll()\n    {\n        try\n        {\n            if (sendStream)\n            {\n                PushbackInputStream in = new PushbackInputStream(inputStream);\n\n                //Block until we have some data\n                int i = in.read();\n                //Roll back our read\n                in.unread(i);\n                MuleMessage message = new DefaultMuleMessage(connector.getMessageAdapter(in), connector.getMuleContext());\n                routeMessage(message, endpoint.isSynchronous());\n            }\n            else\n            {\n                byte[] inputBuffer = new byte[bufferSize];\n                int len = inputStream.read(inputBuffer);\n\n                if (len == -1)\n                {\n                    return;\n                }\n\n                StringBuffer fullBuffer = new StringBuffer(bufferSize);\n                while (len > 0)\n                {\n                    fullBuffer.append(new String(inputBuffer, 0, len));\n                    len = 0; // mark as read\n                    if (inputStream.available() > 0)\n                    {\n                        len = inputStream.read(inputBuffer);\n                    }\n                }\n\n                // Each line is a separate message\n                String[] lines = fullBuffer.toString().split(SystemUtils.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; ++i)\n                {                \n                    routeMessage(new DefaultMuleMessage(connector.getMessageAdapter(lines[i]), connector.getMuleContext()), \n                                 endpoint.isSynchronous());\n                }\n            }\n\n            doConnect();\n        }\n        catch (Exception e)\n        {\n            handleException(e);\n        }\n    }","commit_id":"4e9c0038edbebc65b838e75e9a8612c9df49c4d7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doConnect(UMOImmutableEndpoint endpoint) throws Exception\n    {\n        // template method\n    }","id":66612,"modified_method":"protected void doConnect(UMOImmutableEndpoint endpoint) throws Exception\n    {\n        if (connector.isQueueEvents()) {\n            //use the default queue profile to configure this queue.\n            // Todo We may want to allow users to specify this at the connector level\n            MuleManager.getConfiguration().getQueueProfile().configureQueue(endpoint.getEndpointURI().getAddress());\n        }\n    }","commit_id":"011f8d36577f08e063b5765ac2b58e20df86fba5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected List getMessages() throws Exception\n    {\n        QueueSession qs = connector.getQueueSession();\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n        UMOEvent event = (UMOEvent) queue.take();\n        routeMessage(new MuleMessage(event.getTransformedMessage(), event.getMessage()));\n        return null;\n    }","id":66613,"modified_method":"protected List getMessages() throws Exception\n    {\n        QueueSession qs = connector.getQueueSession();\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n        UMOEvent event = (UMOEvent) queue.take();\n        if(event!=null) {\n            routeMessage(new MuleMessage(event.getTransformedMessage(), event.getMessage()));\n        }\n        return null;\n    }","commit_id":"011f8d36577f08e063b5765ac2b58e20df86fba5","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doConnect() throws Exception\n    {\n        if (queueEvents) {\n            // Ensure we can create a vm queue\n            QueueSession queueSession = connector.getQueueSession();\n            queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n        }\n    }","id":66614,"modified_method":"public void doConnect() throws Exception\n    {\n        if (connector.isQueueEvents()) {\n            // Ensure we can create a vm queue\n            QueueSession queueSession = connector.getQueueSession();\n            Queue q = queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n            if(logger.isDebugEnabled()) {\n                logger.debug(\"Current queue depth for queue: \" + endpoint.getEndpointURI().getAddress() + \" is: \" + q.size());\n            }\n        }\n    }","commit_id":"011f8d36577f08e063b5765ac2b58e20df86fba5","url":"https://github.com/mulesoft/mule"},{"original_method":"public VMMessageReceiver(UMOConnector connector, UMOComponent component, UMOEndpoint endpoint)\n            throws InitialisationException\n    {\n        super(connector, component, endpoint, new Long(10));\n        this.connector = (VMConnector) connector;\n        receiveMessagesInTransaction = endpoint.getTransactionConfig().isTransacted();\n        queueEvents = this.connector.isQueueEvents();\n        queueEvents = PropertiesHelper.getBooleanProperty(endpoint.getProperties(), \"queueEvents\", queueEvents);\n    }","id":66615,"modified_method":"public VMMessageReceiver(UMOConnector connector, UMOComponent component, UMOEndpoint endpoint)\n            throws InitialisationException\n    {\n        super(connector, component, endpoint, new Long(10));\n        this.connector = (VMConnector) connector;\n        receiveMessagesInTransaction = endpoint.getTransactionConfig().isTransacted();\n    }","commit_id":"011f8d36577f08e063b5765ac2b58e20df86fba5","url":"https://github.com/mulesoft/mule"},{"original_method":"public void onEvent(UMOEvent event) throws UMOException\n    {\n        if (queueEvents) {\n            QueueSession queueSession = connector.getQueueSession();\n            Queue queue = queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n            try {\n                queue.put(event);\n            } catch (InterruptedException e) {\n                throw new MuleException(new Message(Messages.INTERRUPTED_QUEUING_EVENT_FOR_X,\n                                                    this.endpoint.getEndpointURI()), e);\n            }\n        } else {\n            UMOMessage msg = new MuleMessage(event.getTransformedMessage(), event.getMessage());\n            synchronized(lock) {\n                routeMessage(msg);\n            }\n        }\n    }","id":66616,"modified_method":"public void onEvent(UMOEvent event) throws UMOException\n    {\n        if (connector.isQueueEvents()) {\n            QueueSession queueSession = connector.getQueueSession();\n            Queue queue = queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n            try {\n                queue.put(event);\n            } catch (InterruptedException e) {\n                throw new MuleException(new Message(Messages.INTERRUPTED_QUEUING_EVENT_FOR_X,\n                                                    this.endpoint.getEndpointURI()), e);\n            }\n        } else {\n            UMOMessage msg = new MuleMessage(event.getTransformedMessage(), event.getMessage());\n            synchronized(lock) {\n                routeMessage(msg);\n            }\n        }\n    }","commit_id":"011f8d36577f08e063b5765ac2b58e20df86fba5","url":"https://github.com/mulesoft/mule"},{"original_method":"@NotNull\n    private List<JsExpression> translateArguments() {\n        List<JsExpression> result = new ArrayList<JsExpression>();\n        List<JsExpression> argsBeforeVararg = null;\n        for (ValueParameterDescriptor parameterDescriptor : resolvedCall.getResultingDescriptor().getValueParameters()) {\n            ResolvedValueArgument actualArgument = resolvedCall.getValueArgumentsByIndex().get(parameterDescriptor.getIndex());\n\n            if (actualArgument instanceof VarargValueArgument) {\n                assert !hasSpreadOperator;\n\n                List<ValueArgument> arguments = actualArgument.getArguments();\n                hasSpreadOperator = arguments.size() == 1 && arguments.get(0).getSpreadElement() != null;\n\n                if (isNativeFunctionCall && hasSpreadOperator) {\n                    assert argsBeforeVararg == null;\n                    argsBeforeVararg = result;\n                    result = new SmartList<JsExpression>();\n                }\n            }\n\n            result.addAll(translateSingleArgument(actualArgument, parameterDescriptor));\n        }\n\n        if (isNativeFunctionCall && hasSpreadOperator) {\n            assert argsBeforeVararg != null;\n            if (!argsBeforeVararg.isEmpty()) {\n                JsInvocation concatArguments = new JsInvocation(new JsNameRef(\"concat\", new JsArrayLiteral(argsBeforeVararg)), result);\n                result = new SmartList<JsExpression>(concatArguments);\n            }\n\n            if (receiver != null) {\n                cachedReceiver = context().declareTemporary(receiver);\n                result.add(0, cachedReceiver.reference());\n            }\n            else {\n                result.add(0, JsLiteral.NULL);\n            }\n        }\n\n        return result;\n    }","id":66617,"modified_method":"@NotNull\n    private List<JsExpression> translateArguments() {\n        List<JsExpression> result = new ArrayList<JsExpression>();\n        List<JsExpression> argsBeforeVararg = null;\n        for (ValueParameterDescriptor parameterDescriptor : resolvedCall.getResultingDescriptor().getValueParameters()) {\n            ResolvedValueArgument actualArgument = resolvedCall.getValueArgumentsByIndex().get(parameterDescriptor.getIndex());\n\n            if (actualArgument instanceof VarargValueArgument) {\n                assert !hasSpreadOperator;\n\n                List<ValueArgument> arguments = actualArgument.getArguments();\n                hasSpreadOperator = arguments.size() == 1 && arguments.get(0).getSpreadElement() != null;\n\n                if (isNativeFunctionCall && hasSpreadOperator) {\n                    assert argsBeforeVararg == null;\n                    argsBeforeVararg = result;\n                    result = new SmartList<JsExpression>();\n                }\n            }\n\n            result.addAll(translateSingleArgument(actualArgument, parameterDescriptor));\n        }\n\n        if (isNativeFunctionCall && hasSpreadOperator) {\n            assert argsBeforeVararg != null;\n            if (!argsBeforeVararg.isEmpty()) {\n                JsInvocation concatArguments = new JsInvocation(new JsNameRef(\"concat\", new JsArrayLiteral(argsBeforeVararg)), result);\n                result = new SmartList<JsExpression>(concatArguments);\n            }\n\n            if (receiver != null) {\n                cachedReceiver = context().getOrDeclareTemporaryConstVariable(receiver);\n                result.add(0, cachedReceiver.reference());\n            }\n            else {\n                result.add(0, JsLiteral.NULL);\n            }\n        }\n\n        return result;\n    }","commit_id":"a69744e6fb00e85a82ea7aa61bd589cbe4d8c032","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public TemporaryVariable declareTemporary(@Nullable JsExpression initExpression) {\n        if (vars == null) {\n            vars = new JsVars();\n            currentBlock.getStatements().add(vars);\n        }\n\n        JsName temporaryName = currentScope.declareTemporary();\n        vars.add(new JsVar(temporaryName, null));\n        return new TemporaryVariable(temporaryName, initExpression);\n    }","id":66618,"modified_method":"@NotNull\n    public TemporaryVariable declareTemporary(@Nullable JsExpression initExpression) {\n        if (vars == null) {\n            vars = new JsVars();\n            currentBlock.getStatements().add(vars);\n        }\n\n        JsName temporaryName = currentScope.declareTemporary();\n        vars.add(new JsVar(temporaryName, null));\n        return TemporaryVariable.create(temporaryName, initExpression);\n    }","commit_id":"a69744e6fb00e85a82ea7aa61bd589cbe4d8c032","url":"https://github.com/JetBrains/kotlin"},{"original_method":"TemporaryVariable(@NotNull JsName temporaryName, @Nullable JsExpression initExpression) {\n        this.variableName = temporaryName;\n        this.assignmentExpression = initExpression == null ? null : JsAstUtils.assignment(variableName.makeRef(), initExpression);\n    }","id":66619,"modified_method":"protected TemporaryVariable(@NotNull JsName temporaryName, @Nullable JsExpression assignmentExpression) {\n        this.variableName = temporaryName;\n        this.assignmentExpression = assignmentExpression;\n    }","commit_id":"a69744e6fb00e85a82ea7aa61bd589cbe4d8c032","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static JsExpression translateExclExclOperator(@NotNull JetUnaryExpression expression, @NotNull TranslationContext context) {\n        TemporaryVariable cachedValue = context.declareTemporary(translateAsExpression(getBaseExpression(expression), context));\n        return new JsConditional(isNotNullCheck(cachedValue.assignmentExpression()), cachedValue.reference(), context.namer().throwNPEFunctionCall());\n    }","id":66620,"modified_method":"@NotNull\n    private static JsExpression translateExclExclOperator(@NotNull JetUnaryExpression expression, @NotNull TranslationContext context) {\n        JsExpression translatedExpression = translateAsExpression(getBaseExpression(expression), context);\n        TemporaryConstVariable tempVar = context.getOrDeclareTemporaryConstVariable(translatedExpression);\n\n        JsConditional ensureNotNull = new JsConditional(isNotNullCheck(tempVar.value()), tempVar.value(), context.namer().throwNPEFunctionCall());\n\n        // associate (cache) ensureNotNull expression to new LazyValue with same name.\n        context.associateExpressionToLazyValue(ensureNotNull, new TemporaryConstVariable(tempVar.name(), ensureNotNull));\n        return ensureNotNull;\n    }","commit_id":"a69744e6fb00e85a82ea7aa61bd589cbe4d8c032","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static AccessTranslator getArrayAccessTranslator(\n            @NotNull KtArrayAccessExpression expression,\n            @NotNull TranslationContext context,\n            boolean forceOrderOfEvaluation\n    ) {\n        TranslationContext accessArrayContext;\n        if (forceOrderOfEvaluation) {\n            Map<KtExpression, JsExpression> indexesMap = new LinkedHashMap<KtExpression, JsExpression>();\n            for(KtExpression indexExpression : expression.getIndexExpressions()) {\n                JsExpression jsIndexExpression = Translation.translateAsExpression(indexExpression, context);\n                if (TranslationUtils.isCacheNeeded(jsIndexExpression)) {\n                    jsIndexExpression = context.defineTemporary(jsIndexExpression);\n                }\n                indexesMap.put(indexExpression, jsIndexExpression);\n            }\n            accessArrayContext = context.innerContextWithAliasesForExpressions(indexesMap);\n        } else {\n            accessArrayContext = context;\n        }\n\n        return ArrayAccessTranslator.newInstance(expression, accessArrayContext);\n    }","id":66621,"modified_method":"@NotNull\n    private static AccessTranslator getArrayAccessTranslator(\n            @NotNull KtArrayAccessExpression expression,\n            @NotNull TranslationContext context,\n            boolean forceOrderOfEvaluation\n    ) {\n        TranslationContext accessArrayContext;\n        if (forceOrderOfEvaluation) {\n            Map<KtExpression, JsExpression> indexesMap = new LinkedHashMap<KtExpression, JsExpression>();\n            for(KtExpression indexExpression : expression.getIndexExpressions()) {\n                JsExpression jsIndexExpression = context.cacheExpressionIfNeeded(\n                        Translation.translateAsExpression(indexExpression, context));\n                indexesMap.put(indexExpression, jsIndexExpression);\n            }\n            accessArrayContext = context.innerContextWithAliasesForExpressions(indexesMap);\n        } else {\n            accessArrayContext = context;\n        }\n\n        return ArrayAccessTranslator.newInstance(expression, accessArrayContext);\n    }","commit_id":"a27f5c8fee68e58372bf1028003018082b63990c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JsExpression translateElvis() {\n        JsExpression leftExpression = Translation.translateAsExpression(leftKtExpression, context());\n\n        JsBlock rightBlock = new JsBlock();\n        JsExpression rightExpression = Translation.translateAsExpression(rightKtExpression, context(), rightBlock);\n\n        if (rightBlock.isEmpty()) {\n            return TranslationUtils.notNullConditional(leftExpression, rightExpression, context());\n        }\n\n        JsExpression result;\n        JsIf ifStatement;\n        if (BindingContextUtilsKt.isUsedAsExpression(expression, context().bindingContext())) {\n            if (TranslationUtils.isCacheNeeded(leftExpression)) {\n                result = context().defineTemporary(leftExpression);\n            }\n            else {\n                result = leftExpression;\n            }\n            JsExpression testExpression = TranslationUtils.isNullCheck(result);\n            rightBlock.getStatements().add(JsAstUtils.assignment(result, rightExpression).makeStmt());\n            ifStatement = JsAstUtils.newJsIf(testExpression, rightBlock);\n        }\n        else {\n            result = JsLiteral.NULL;\n            JsExpression testExpression = TranslationUtils.isNullCheck(leftExpression);\n            ifStatement = JsAstUtils.newJsIf(testExpression, rightBlock);\n        }\n        context().addStatementToCurrentBlock(ifStatement);\n        return result;\n    }","id":66622,"modified_method":"@NotNull\n    private JsExpression translateElvis() {\n        JsExpression leftExpression = Translation.translateAsExpression(leftKtExpression, context());\n\n        JsBlock rightBlock = new JsBlock();\n        JsExpression rightExpression = Translation.translateAsExpression(rightKtExpression, context(), rightBlock);\n\n        if (rightBlock.isEmpty()) {\n            return TranslationUtils.notNullConditional(leftExpression, rightExpression, context());\n        }\n\n        JsExpression result;\n        JsIf ifStatement;\n        if (BindingContextUtilsKt.isUsedAsExpression(expression, context().bindingContext())) {\n            result = context().cacheExpressionIfNeeded(leftExpression);\n            JsExpression testExpression = TranslationUtils.isNullCheck(result);\n            rightBlock.getStatements().add(JsAstUtils.assignment(result, rightExpression).makeStmt());\n            ifStatement = JsAstUtils.newJsIf(testExpression, rightBlock);\n        }\n        else {\n            result = JsLiteral.NULL;\n            JsExpression testExpression = TranslationUtils.isNullCheck(leftExpression);\n            ifStatement = JsAstUtils.newJsIf(testExpression, rightBlock);\n        }\n        context().addStatementToCurrentBlock(ifStatement);\n        return result;\n    }","commit_id":"a27f5c8fee68e58372bf1028003018082b63990c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JsExpression applyIntrinsic(@NotNull BinaryOperationIntrinsic intrinsic) {\n        JsExpression leftExpression = Translation.translateAsExpression(leftKtExpression, context());\n\n        JsBlock rightBlock = new JsBlock();\n        JsExpression rightExpression = Translation.translateAsExpression(rightKtExpression, context(), rightBlock);\n\n        if (rightBlock.isEmpty()) {\n            return intrinsic.apply(expression, leftExpression, rightExpression, context());\n        }\n\n        if (TranslationUtils.isCacheNeeded(leftExpression)) {\n            leftExpression = context().defineTemporary(leftExpression);\n        }\n        context().addStatementsToCurrentBlockFrom(rightBlock);\n\n        return intrinsic.apply(expression, leftExpression, rightExpression, context());\n    }","id":66623,"modified_method":"@NotNull\n    private JsExpression applyIntrinsic(@NotNull BinaryOperationIntrinsic intrinsic) {\n        JsExpression leftExpression = Translation.translateAsExpression(leftKtExpression, context());\n\n        JsBlock rightBlock = new JsBlock();\n        JsExpression rightExpression = Translation.translateAsExpression(rightKtExpression, context(), rightBlock);\n\n        if (rightBlock.isEmpty()) {\n            return intrinsic.apply(expression, leftExpression, rightExpression, context());\n        }\n\n        leftExpression = context().cacheExpressionIfNeeded(leftExpression);\n        context().addStatementsToCurrentBlockFrom(rightBlock);\n\n        return intrinsic.apply(expression, leftExpression, rightExpression, context());\n    }","commit_id":"a27f5c8fee68e58372bf1028003018082b63990c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JsExpression throwNPEFunctionCall() {\n        return new JsInvocation(new JsNameRef(THROW_NPE_FUN_NAME, kotlinObject()));\n    }","id":66624,"modified_method":"@NotNull\n    public JsExpression throwNPEFunctionRef() {\n        return new JsNameRef(THROW_NPE_FUN_NAME, kotlinObject());\n    }","commit_id":"78945a94614461d2d74a775144253dda817d9cda","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static JsExpression translateExclExclOperator(@NotNull JetUnaryExpression expression, @NotNull TranslationContext context) {\n        JsExpression translatedExpression = translateAsExpression(getBaseExpression(expression), context);\n        TemporaryConstVariable tempVar = context.getOrDeclareTemporaryConstVariable(translatedExpression);\n\n        JsConditional ensureNotNull = new JsConditional(isNotNullCheck(tempVar.value()), tempVar.value(), context.namer().throwNPEFunctionCall());\n\n        // associate (cache) ensureNotNull expression to new LazyValue with same name.\n        context.associateExpressionToLazyValue(ensureNotNull, new TemporaryConstVariable(tempVar.name(), ensureNotNull));\n        return ensureNotNull;\n    }","id":66625,"modified_method":"@NotNull\n    private static JsExpression translateExclExclOperator(@NotNull JetUnaryExpression expression, @NotNull TranslationContext context) {\n        return sure(translateAsExpression(getBaseExpression(expression), context), context);\n    }","commit_id":"78945a94614461d2d74a775144253dda817d9cda","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private EnumSet<GrIntroduceFieldSettings.Init> getApplicableInitPlaces() {\n    GrIntroduceContext context = getContext();\n    PsiElement[] occurrences = getOccurrences();\n    EnumSet<GrIntroduceFieldSettings.Init> result = EnumSet.of(GrIntroduceFieldSettings.Init.FIELD_DECLARATION);\n\n    if (!(context.getScope() instanceof GroovyScriptClass || context.getScope() instanceof GroovyFileBase)) {\n      result.add(GrIntroduceFieldSettings.Init.CONSTRUCTOR);\n    }\n\n    PsiElement scope = context.getScope();\n\n    if (isReplaceAllOccurrences()) {\n      PsiElement parent = PsiTreeUtil.findCommonParent(occurrences);\n      PsiElement container = GrIntroduceHandlerBase.getEnclosingContainer(parent);\n      if (container != null) {\n        PsiElement anchor = GrIntroduceHandlerBase.findAnchor(occurrences, container);\n        if (anchor != null) {\n          result.add(GrIntroduceFieldSettings.Init.CUR_METHOD);\n        }\n      }\n    }\n\n    if (scope instanceof GrTypeDefinition && TestFrameworks.getInstance().isTestClass((PsiClass)scope)) {\n      result.add(GrIntroduceFieldSettings.Init.SETUP_METHOD);\n    }\n\n    return result;\n  }","id":66626,"modified_method":"private EnumSet<GrIntroduceFieldSettings.Init> getApplicableInitPlaces() {\n    GrIntroduceContext context = getContext();\n    PsiElement[] occurrences = getOccurrences();\n    EnumSet<GrIntroduceFieldSettings.Init> result = EnumSet.noneOf(GrIntroduceFieldSettings.Init.class);\n\n    if (context.getExpression() != null ||\n        context.getVar() != null && context.getVar().getInitializerGroovy() != null ||\n        context.getStringPart() != null) {\n      result.add(GrIntroduceFieldSettings.Init.FIELD_DECLARATION);\n    }\n\n    if (!(context.getScope() instanceof GroovyScriptClass || context.getScope() instanceof GroovyFileBase)) {\n      result.add(GrIntroduceFieldSettings.Init.CONSTRUCTOR);\n    }\n\n    PsiElement scope = context.getScope();\n\n    if (isReplaceAllOccurrences()) {\n      PsiElement parent = PsiTreeUtil.findCommonParent(occurrences);\n      PsiElement container = GrIntroduceHandlerBase.getEnclosingContainer(parent);\n      if (container != null) {\n        PsiElement anchor = GrIntroduceHandlerBase.findAnchor(occurrences, container);\n        if (anchor != null) {\n          result.add(GrIntroduceFieldSettings.Init.CUR_METHOD);\n        }\n      }\n    }\n\n    if (scope instanceof GrTypeDefinition && TestFrameworks.getInstance().isTestClass((PsiClass)scope)) {\n      result.add(GrIntroduceFieldSettings.Init.SETUP_METHOD);\n    }\n\n    return result;\n  }","commit_id":"5bbc86a1a6a8a161faecf59f32f5bce1152ac50c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrVariable run() {\n    PsiElement scope = myContext.getScope();\n    final PsiClass targetClass = scope instanceof GroovyFileBase ? ((GroovyFileBase)scope).getScriptClass() : (PsiClass)scope;\n    if (targetClass == null) return null;\n\n    final GrVariableDeclaration declaration = insertField(targetClass);\n    final GrVariable field = declaration.getVariables()[0];\n\n    if (mySettings.removeLocalVar()) {\n      myLocalVariable = GrIntroduceHandlerBase.resolveLocalVar(myContext);\n      assert myLocalVariable != null : myContext.getExpression() + \", \" + myContext.getVar() + \", \" + myContext.getStringPart();\n    }\n    myInitializer = (GrExpression)getInitializer().copy();\n\n    List<PsiElement> replaced = processOccurrences(targetClass, field);\n\n    switch (mySettings.initializeIn()) {\n      case CUR_METHOD:\n        initializeInMethod(field, replaced);\n        break;\n      case FIELD_DECLARATION:\n        field.setInitializerGroovy(myInitializer);\n        break;\n      case CONSTRUCTOR:\n        initializeInConstructor(field);\n        break;\n      case SETUP_METHOD:\n        initializeInSetup(field);\n        break;\n    }\n\n    JavaCodeStyleManager.getInstance(declaration.getProject()).shortenClassReferences(declaration);\n\n    if (mySettings.removeLocalVar()) {\n      GrIntroduceHandlerBase.deleteLocalVar(myLocalVariable);\n    }\n\n    return field;\n  }","id":66627,"modified_method":"@Nullable\n  public GrVariable run() {\n    PsiElement scope = myContext.getScope();\n    final PsiClass targetClass = scope instanceof GroovyFileBase ? ((GroovyFileBase)scope).getScriptClass() : (PsiClass)scope;\n    if (targetClass == null) return null;\n\n    final GrVariableDeclaration declaration = insertField(targetClass);\n    final GrVariable field = declaration.getVariables()[0];\n\n    if (mySettings.removeLocalVar()) {\n      myLocalVariable = GrIntroduceHandlerBase.resolveLocalVar(myContext);\n      assert myLocalVariable != null : myContext.getExpression() + \", \" + myContext.getVar() + \", \" + myContext.getStringPart();\n    }\n    myInitializer = getInitializer();\n\n    List<PsiElement> replaced = processOccurrences(targetClass, field);\n\n    switch (mySettings.initializeIn()) {\n      case CUR_METHOD:\n        initializeInMethod(field, replaced);\n        break;\n      case FIELD_DECLARATION:\n        field.setInitializerGroovy(myInitializer);\n        break;\n      case CONSTRUCTOR:\n        initializeInConstructor(field);\n        break;\n      case SETUP_METHOD:\n        initializeInSetup(field);\n        break;\n    }\n\n    JavaCodeStyleManager.getInstance(declaration.getProject()).shortenClassReferences(declaration);\n\n    if (mySettings.removeLocalVar()) {\n      GrIntroduceHandlerBase.deleteLocalVar(myLocalVariable);\n    }\n\n    return field;\n  }","commit_id":"5bbc86a1a6a8a161faecf59f32f5bce1152ac50c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateAssignment(@NotNull GrVariable field,\n                                  @Nullable GrStatement anchor,\n                                  @NotNull GrStatementOwner defaultContainer,\n                                  @Nullable PsiElement occurrenceToDelete) {\n    final GrExpression initializer = myInitializer;\n    GrAssignmentExpression init = (GrAssignmentExpression)GroovyPsiElementFactory.getInstance(myContext.getProject())\n      .createExpressionFromText(mySettings.getName() + \" = \" + initializer.getText());\n\n    GrStatementOwner block;\n    if (anchor != null) {\n      anchor = GroovyRefactoringUtil.addBlockIntoParent(anchor);\n      LOG.assertTrue(anchor.getParent() instanceof GrStatementOwner);\n      block = (GrStatementOwner)anchor.getParent();\n    }\n    else {\n      block = defaultContainer;\n    }\n\n    init = (GrAssignmentExpression)block.addStatementBefore(init, anchor);\n    replaceOccurrence(field, init.getLValue(), (PsiClass)myContext.getScope());\n\n    if (occurrenceToDelete != null) {\n      occurrenceToDelete.delete();\n    }\n  }","id":66628,"modified_method":"private void generateAssignment(@NotNull GrVariable field,\n                                  @Nullable GrStatement anchor,\n                                  @NotNull GrStatementOwner defaultContainer,\n                                  @Nullable PsiElement occurrenceToDelete) {\n    if (myInitializer == null) return;\n\n    GrAssignmentExpression init = (GrAssignmentExpression)GroovyPsiElementFactory.getInstance(myContext.getProject())\n      .createExpressionFromText(mySettings.getName() + \" = \" + myInitializer.getText());\n\n    GrStatementOwner block;\n    if (anchor != null) {\n      anchor = GroovyRefactoringUtil.addBlockIntoParent(anchor);\n      LOG.assertTrue(anchor.getParent() instanceof GrStatementOwner);\n      block = (GrStatementOwner)anchor.getParent();\n    }\n    else {\n      block = defaultContainer;\n    }\n\n    init = (GrAssignmentExpression)block.addStatementBefore(init, anchor);\n    replaceOccurrence(field, init.getLValue(), (PsiClass)myContext.getScope());\n\n    if (occurrenceToDelete != null) {\n      occurrenceToDelete.delete();\n    }\n  }","commit_id":"5bbc86a1a6a8a161faecf59f32f5bce1152ac50c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private GrExpression extractVarInitializer() {\n    assert myLocalVariable != null;\n    GrExpression initializer = myLocalVariable.getInitializerGroovy();\n    LOG.assertTrue(initializer != null);\n    return initializer;\n  }","id":66629,"modified_method":"@Nullable\n  private GrExpression extractVarInitializer() {\n    assert myLocalVariable != null;\n    return myLocalVariable.getInitializerGroovy();\n  }","commit_id":"5bbc86a1a6a8a161faecf59f32f5bce1152ac50c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement[] collectVariableUsages(GrVariable variable, PsiElement scope) {\n    final List<PsiElement> list = Collections.synchronizedList(new ArrayList<PsiElement>());\n    ReferencesSearch.search(variable, new LocalSearchScope(scope)).forEach(new Processor<PsiReference>() {\n      @Override\n      public boolean process(PsiReference psiReference) {\n        final PsiElement element = psiReference.getElement();\n        if (element != null) {\n          list.add(element);\n        }\n        return true;\n      }\n    });\n    return list.toArray(new PsiElement[list.size()]);\n  }","id":66630,"modified_method":"public static PsiElement[] collectVariableUsages(GrVariable variable, PsiElement scope) {\n    final List<PsiElement> list = Collections.synchronizedList(new ArrayList<PsiElement>());\n    if (scope instanceof GroovyScriptClass) {\n      scope = scope.getContainingFile();\n    }\n    ReferencesSearch.search(variable, new LocalSearchScope(scope)).forEach(new Processor<PsiReference>() {\n      @Override\n      public boolean process(PsiReference psiReference) {\n        final PsiElement element = psiReference.getElement();\n        if (element != null) {\n          list.add(element);\n        }\n        return true;\n      }\n    });\n    return list.toArray(new PsiElement[list.size()]);\n  }","commit_id":"5bbc86a1a6a8a161faecf59f32f5bce1152ac50c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Constants.Logging.SYSTEM_NAME,\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    // Delete app fabric temp directory\n    File tmpDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR),\n                           configuration.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile();\n    FileUtils.deleteDirectory(tmpDir);\n\n    schedulerService.start();\n    adapterService.start();\n    programRuntimeService.start();\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.APP_FABRIC_HTTP)))\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          }));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","id":66631,"modified_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Constants.Logging.SYSTEM_NAME,\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    // Delete app fabric temp directory\n    File tmpDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR),\n                           configuration.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile();\n    FileUtils.deleteDirectory(tmpDir);\n\n    schedulerService.start();\n    adapterService.start();\n    programRuntimeService.start();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          }));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","commit_id":"022a58571595acc6b3c9ebedb9096aeb541d08a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getDistributedModules() {\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new ConfigStoreModule().getDistributedModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(DistributedSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(LogSaverStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(TransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(MetricsProcessorStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(MetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(StreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(DatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(ExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                             }\n                           });\n  }","id":66632,"modified_method":"@Override\n  public Module getDistributedModules() {\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new ConfigStoreModule().getDistributedModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(DistributedSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(LogSaverStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(TransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(MetricsProcessorStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(MetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(StreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(DatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(ExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n\n                               Multibinder<String> handlerHookNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.handler.hooks\"));\n                               handlerHookNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                             }\n                           });\n  }","commit_id":"022a58571595acc6b3c9ebedb9096aeb541d08a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getInMemoryModules() {\n    return Modules.combine(new AppFabricServiceModule(StreamHandler.class, StreamFetchHandler.class),\n                           new ConfigStoreModule().getInMemoryModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.STREAMS);\n                             }\n                           });\n  }","id":66633,"modified_method":"@Override\n  public Module getInMemoryModules() {\n    return Modules.combine(new AppFabricServiceModule(StreamHandler.class, StreamFetchHandler.class),\n                           new ConfigStoreModule().getInMemoryModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.STREAMS);\n\n                               Multibinder<String> handlerHookNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.handler.hooks\"));\n                               handlerHookNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               handlerHookNamesBinder.addBinding().toInstance(Constants.Stream.STREAM_HANDLER);\n                             }\n                           });\n  }","commit_id":"022a58571595acc6b3c9ebedb9096aeb541d08a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getStandaloneModules() {\n\n    return Modules.combine(new AppFabricServiceModule(StreamHandler.class, StreamFetchHandler.class),\n                           new ConfigStoreModule().getStandaloneModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.STREAMS);\n                             }\n                           });\n  }","id":66634,"modified_method":"@Override\n  public Module getStandaloneModules() {\n\n    return Modules.combine(new AppFabricServiceModule(StreamHandler.class, StreamFetchHandler.class),\n                           new ConfigStoreModule().getStandaloneModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n\n                               Multibinder<String> servicesNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.services.names\"));\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               servicesNamesBinder.addBinding().toInstance(Constants.Service.STREAMS);\n\n                               Multibinder<String> handlerHookNamesBinder =\n                                 Multibinder.newSetBinder(binder(), String.class,\n                                                          Names.named(\"appfabric.handler.hooks\"));\n                               handlerHookNamesBinder.addBinding().toInstance(Constants.Service.APP_FABRIC_HTTP);\n                               handlerHookNamesBinder.addBinding().toInstance(Constants.Stream.STREAM_HANDLER);\n                             }\n                           });\n  }","commit_id":"022a58571595acc6b3c9ebedb9096aeb541d08a3","url":"https://github.com/caskdata/cdap"},{"original_method":"public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                // Special case for anonymous authentication to avoid prompting user for their name.\n                if (callbacks.length == 1 && callbacks[0] instanceof NameCallback) {\n                    ((NameCallback) callbacks[0]).setName(\"anonymous CLI user\");\n                    return;\n                }\n\n                for (Callback current : callbacks) {\n                    if (current instanceof RealmCallback) {\n                        RealmCallback rcb = (RealmCallback) current;\n                        String defaultText = rcb.getDefaultText();\n                        realm = defaultText;\n                        rcb.setText(defaultText); // For now just use the realm suggested.\n                    } else if (current instanceof RealmChoiceCallback) {\n                        throw new UnsupportedCallbackException(current, \"Realm choice not currently supported.\");\n                    } else if (current instanceof NameCallback) {\n                        NameCallback ncb = (NameCallback) current;\n                        if (username == null) {\n                            showRealm();\n                            username = readLine(\"Username: \", false, true);\n                        }\n                        ncb.setName(username);\n                    } else if (current instanceof PasswordCallback && digest == null) {\n                        // If a digest had been set support for PasswordCallback is disabled.\n                        PasswordCallback pcb = (PasswordCallback) current;\n                        if (password == null) {\n                            showRealm();\n                            String temp = readLine(\"Password: \", true, false);\n                            if (temp != null) {\n                                password = temp.toCharArray();\n                            }\n                        }\n                        pcb.setPassword(password);\n                    } else if (current instanceof DigestHashCallback && digest != null) {\n                        // We don't support an interactive use of this callback so it must have been set in advance.\n                        DigestHashCallback dhc = (DigestHashCallback) current;\n                        dhc.setHexHash(digest);\n                    } else {\n                        printLine(\"Unexpected Callback \" + current.getClass().getName());\n                        throw new UnsupportedCallbackException(current);\n                    }\n                }\n            }","id":66635,"modified_method":"public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                // Special case for anonymous authentication to avoid prompting user for their name.\n                if (callbacks.length == 1 && callbacks[0] instanceof NameCallback) {\n                    ((NameCallback) callbacks[0]).setName(\"anonymous CLI user\");\n                    return;\n                }\n\n                for (Callback current : callbacks) {\n                    if (current instanceof RealmCallback) {\n                        RealmCallback rcb = (RealmCallback) current;\n                        String defaultText = rcb.getDefaultText();\n                        realm = defaultText;\n                        rcb.setText(defaultText); // For now just use the realm suggested.\n                    } else if (current instanceof RealmChoiceCallback) {\n                        throw new UnsupportedCallbackException(current, \"Realm choice not currently supported.\");\n                    } else if (current instanceof NameCallback) {\n                        NameCallback ncb = (NameCallback) current;\n                        if (username == null) {\n                            showRealm();\n                            username = readLine(\"Username: \", false, true);\n                            if (username == null || username.length() == 0) {\n                                throw new SaslException(\"No username supplied.\");\n                            }\n                        }\n                        ncb.setName(username);\n                    } else if (current instanceof PasswordCallback && digest == null) {\n                        // If a digest had been set support for PasswordCallback is disabled.\n                        PasswordCallback pcb = (PasswordCallback) current;\n                        if (password == null) {\n                            showRealm();\n                            String temp = readLine(\"Password: \", true, false);\n                            if (temp != null) {\n                                password = temp.toCharArray();\n                            }\n                        }\n                        pcb.setPassword(password);\n                    } else if (current instanceof DigestHashCallback && digest != null) {\n                        // We don't support an interactive use of this callback so it must have been set in advance.\n                        DigestHashCallback dhc = (DigestHashCallback) current;\n                        dhc.setHexHash(digest);\n                    } else {\n                        printLine(\"Unexpected Callback \" + current.getClass().getName());\n                        throw new UnsupportedCallbackException(current);\n                    }\n                }\n            }","commit_id":"54e2444630e20164cffd72533efef99072824d7f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Connection connect(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n        if (connection != null) {\n            throw MESSAGES.alreadyConnected();\n        }\n\n        // TODO - do we need better way to decide this?\n        Builder builder = OptionMap.builder();\n        builder.set(SASL_POLICY_NOANONYMOUS, Boolean.FALSE);\n        if (saslOptions != null) {\n            List<Property> tempProperties = new ArrayList<Property>(saslOptions.size());\n            for (String currentKey : saslOptions.keySet()) {\n                tempProperties.add(Property.of(currentKey, saslOptions.get(currentKey)));\n            }\n\n            builder.set(Options.SASL_PROPERTIES, Sequence.of(tempProperties));\n        }\n\n        CallbackHandler actualHandler = handler != null ? handler : new AnonymousCallbackHandler();\n        WrapperCallbackHandler wrapperHandler = new WrapperCallbackHandler(actualHandler);\n        IoFuture<Connection> future = endpoint.connect(uri, builder.getMap(), wrapperHandler);\n        try {\n            this.connection = future.get();\n        } catch (CancellationException e) {\n            throw MESSAGES.connectWasCancelled();\n        } catch (IOException e) {\n            throw MESSAGES.couldNotConnect(uri, e);\n        }\n\n        return connection;\n    }","id":66636,"modified_method":"public Connection connect(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n        if (connection != null) {\n            throw MESSAGES.alreadyConnected();\n        }\n\n        Builder builder = OptionMap.builder();\n        builder.set(SASL_POLICY_NOANONYMOUS, Boolean.FALSE);\n        builder.set(SASL_POLICY_NOPLAINTEXT, Boolean.FALSE);\n        List<Property> tempProperties = new ArrayList<Property>(saslOptions != null ? saslOptions.size() : 1);\n        tempProperties.add(Property.of(\"jboss.sasl.local-user.quiet-auth\", \"true\"));\n        if (saslOptions != null) {\n            for (String currentKey : saslOptions.keySet()) {\n                tempProperties.add(Property.of(currentKey, saslOptions.get(currentKey)));\n            }\n        }\n        builder.set(Options.SASL_PROPERTIES, Sequence.of(tempProperties));\n\n        CallbackHandler actualHandler = handler != null ? handler : new AnonymousCallbackHandler();\n        WrapperCallbackHandler wrapperHandler = new WrapperCallbackHandler(actualHandler);\n        IoFuture<Connection> future = endpoint.connect(uri, builder.getMap(), wrapperHandler);\n        try {\n            this.connection = future.get();\n        } catch (CancellationException e) {\n            throw MESSAGES.connectWasCancelled();\n        } catch (IOException e) {\n            throw MESSAGES.couldNotConnect(uri, e);\n        }\n\n        return connection;\n    }","commit_id":"54e2444630e20164cffd72533efef99072824d7f","url":"https://github.com/wildfly/wildfly"},{"original_method":"OptionMap getSaslOptionMap() {\n        if (digestMd5Supported()) {\n            Builder builder = OptionMap.builder();\n            builder.set(SASL_MECHANISMS, Sequence.of(\"DIGEST-MD5\"));\n\n            Sequence<Property> properties;\n            if (contains(DigestHashCallback.class, realm.getCallbackHandler().getSupportedCallbacks())) {\n                properties = Sequence.of(Property.of(REALM_PROPERTY, realm.getName()), Property.of(PRE_DIGESTED_PROPERTY, Boolean.TRUE.toString()));\n            } else {\n                properties = Sequence.of(Property.of(REALM_PROPERTY, realm.getName()));\n            }\n\n            builder.set(SASL_PROPERTIES, properties);\n\n            return builder.getMap();\n        }\n\n        if (plainSupported()) {\n            if (true)\n                throw new IllegalStateException(\"PLAIN not enabled until SSL supported for Native Interface\");\n\n            return OptionMap.create(Options.SASL_MECHANISMS, Sequence.of(PLAIN), SASL_POLICY_NOPLAINTEXT, false);\n        }\n\n        if (realm == null) {\n            return OptionMap.create(SASL_MECHANISMS, Sequence.of(ANONYMOUS), SASL_POLICY_NOANONYMOUS, Boolean.FALSE);\n        }\n\n        throw new IllegalStateException(\"A security realm has been specified but no supported mechanism identified.\");\n    }","id":66637,"modified_method":"OptionMap getSaslOptionMap() {\n        List<String> mechanisms = new LinkedList<String>();\n        Set<Property> properties = new HashSet<Property>();\n        Builder builder = OptionMap.builder();\n\n        mechanisms.add(JBOSS_LOCAL_USER);\n        builder.set(SASL_POLICY_NOPLAINTEXT, false);\n        properties.add(Property.of(LOCAL_DEFAULT_USER, DOLLAR_LOCAL));\n        if (digestMd5Supported()) {\n            mechanisms.add(DIGEST_MD5);\n            properties.add(Property.of(REALM_PROPERTY, realm.getName()));\n            if (contains(DigestHashCallback.class, realm.getCallbackHandler().getSupportedCallbacks())) {\n                properties.add(Property.of(PRE_DIGESTED_PROPERTY, Boolean.TRUE.toString()));\n            }\n        } else if (plainSupported()) {\n            int i = 1;\n            if (i + i == 2)\n                throw new IllegalStateException(\"PLAIN not enabled until SSL supported for Native Interface\");\n\n            mechanisms.add(PLAIN);\n        } else if (realm == null) {\n            mechanisms.add(ANONYMOUS);\n            builder.set(SASL_POLICY_NOANONYMOUS, false);\n        } else {\n            throw new IllegalStateException(\"A security realm has been specified but no supported mechanism identified.\");\n        }\n\n        builder.set(SASL_MECHANISMS, Sequence.of(mechanisms));\n        builder.set(SASL_PROPERTIES, Sequence.of(properties));\n\n        return builder.getMap();\n    }","commit_id":"54e2444630e20164cffd72533efef99072824d7f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public CallbackHandler getCallbackHandler(String mechanismName) {\n        // If the mechanism is ANONYMOUS and we don't have a realm we return quickly.\n        if (ANONYMOUS.equals(mechanismName) && realm == null) {\n            return new CallbackHandler() {\n\n                public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                    for (Callback current : callbacks) {\n                        throw new UnsupportedCallbackException(current, \"ANONYMOUS mechanism so not expecting a callback\");\n                    }\n                }\n            };\n        }\n\n        CallbackHandler realmCallbackHandler = null;\n\n        // We must have a match in this block or throw an IllegalStateException.\n        if (DIGEST_MD5.equals(mechanismName) && digestMd5Supported() ||\n                PLAIN.equals(mechanismName) && plainSupported()) {\n            realmCallbackHandler = realm.getCallbackHandler();\n        } else {\n            throw new IllegalStateException(\"Unsupported Callback '\" + mechanismName + \"'\");\n        }\n\n        // If there is not serverCallbackHandler then we don't need to wrap it so we can just return the realm\n        // name fix handler which is already wrapping the real handler.\n        if (serverCallbackHandler == null) {\n            return realmCallbackHandler;\n        }\n\n        final CallbackHandler wrappedHandler = realmCallbackHandler; // Just a copy so it can be made final for the inner class.\n        return new CallbackHandler() {\n            public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                serverCallbackHandler.handle(callbacks);\n                if (handled(callbacks) == false) {\n                    wrappedHandler.handle(callbacks);\n                }\n            }\n\n            /*\n            * Check if the PasswordCallback had already been handled.\n            */\n            private boolean handled(Callback[] callbacks) {\n                // For the moment handled will only return true if the user was successfully authenticated,\n                // may later add a Callback to obtain the server info to verify is a server was identified with\n                // the specified username.\n\n                for (Callback current : callbacks) {\n                    if (current instanceof PasswordCallback) {\n                        PasswordCallback pcb = (PasswordCallback) current;\n                        char[] password = pcb.getPassword();\n                        return (password != null && password.length > 0);\n                    } else if (current instanceof VerifyPasswordCallback) {\n                        return ((VerifyPasswordCallback) current).isVerified();\n                    } else if (current instanceof DigestHashCallback) {\n                        return ((DigestHashCallback) current).getHash() != null;\n                    }\n                }\n                return false;\n            }\n        };\n    }","id":66638,"modified_method":"public CallbackHandler getCallbackHandler(String mechanismName) {\n        // If the mechanism is ANONYMOUS and we don't have a realm we return quickly.\n        if (ANONYMOUS.equals(mechanismName) && realm == null) {\n            return new CallbackHandler() {\n\n                public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                    for (Callback current : callbacks) {\n                        throw new UnsupportedCallbackException(current, \"ANONYMOUS mechanism so not expecting a callback\");\n                    }\n                }\n            };\n        }\n\n        // For now for the JBOSS_LOCAL_USER we are only supporting the $local user and not allowing for\n        // an alternative authorizationID.\n        if (JBOSS_LOCAL_USER.equals(mechanismName)) {\n            return new CallbackHandler() {\n\n                @Override\n                public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                    for (Callback current : callbacks) {\n                        if (current instanceof NameCallback) {\n                            NameCallback ncb = (NameCallback) current;\n                            if (DOLLAR_LOCAL.equals(ncb.getDefaultName()) == false) {\n                                throw new SaslException(\"Only \" + DOLLAR_LOCAL + \" user is acceptable.\");\n                            }\n                        } else if (current instanceof AuthorizeCallback) {\n                            AuthorizeCallback acb = (AuthorizeCallback) current;\n                            acb.setAuthorized(acb.getAuthenticationID().equals(acb.getAuthorizationID()));\n                        } else {\n                            throw new UnsupportedCallbackException(current);\n                        }\n                    }\n\n                }\n            };\n        }\n\n        CallbackHandler realmCallbackHandler = null;\n\n        // We must have a match in this block or throw an IllegalStateException.\n        if (DIGEST_MD5.equals(mechanismName) && digestMd5Supported() ||\n                PLAIN.equals(mechanismName) && plainSupported()) {\n            realmCallbackHandler = realm.getCallbackHandler();\n        } else {\n            throw new IllegalStateException(\"Unsupported Callback '\" + mechanismName + \"'\");\n        }\n\n        // If there is not serverCallbackHandler then we don't need to wrap it so we can just return the realm\n        // name fix handler which is already wrapping the real handler.\n        if (serverCallbackHandler == null) {\n            return realmCallbackHandler;\n        }\n\n        final CallbackHandler wrappedHandler = realmCallbackHandler; // Just a copy so it can be made final for the inner class.\n        return new CallbackHandler() {\n            public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n                serverCallbackHandler.handle(callbacks);\n                if (handled(callbacks) == false) {\n                    wrappedHandler.handle(callbacks);\n                }\n            }\n\n            /*\n            * Check if the PasswordCallback had already been handled.\n            */\n            private boolean handled(Callback[] callbacks) {\n                // For the moment handled will only return true if the user was successfully authenticated,\n                // may later add a Callback to obtain the server info to verify is a server was identified with\n                // the specified username.\n\n                for (Callback current : callbacks) {\n                    if (current instanceof PasswordCallback) {\n                        PasswordCallback pcb = (PasswordCallback) current;\n                        char[] password = pcb.getPassword();\n                        return (password != null && password.length > 0);\n                    } else if (current instanceof VerifyPasswordCallback) {\n                        return ((VerifyPasswordCallback) current).isVerified();\n                    } else if (current instanceof DigestHashCallback) {\n                        return ((DigestHashCallback) current).getHash() != null;\n                    }\n                }\n                return false;\n            }\n        };\n    }","commit_id":"54e2444630e20164cffd72533efef99072824d7f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public List getExtensions() {\n    return ImmutableList.of(\n        DefaultResourceTypes.class,\n        UserManagedMetrics.class,\n        Periods.class,\n\n        // pages\n        Lcom4Viewer.class,\n        TestsViewer.class,\n\n        // measure filters\n        ProjectFilter.class,\n        MyFavouritesFilter.class,\n\n        // widgets\n        AlertsWidget.class,\n        CoverageWidget.class,\n        ItCoverageWidget.class,\n        DescriptionWidget.class,\n        ComplexityWidget.class,\n        RulesWidget.class,\n        SizeWidget.class,\n        EventsWidget.class,\n        CustomMeasuresWidget.class,\n        TimelineWidget.class,\n        TimeMachineWidget.class,\n        HotspotMetricWidget.class,\n        TreemapWidget.class,\n        MeasureFilterListWidget.class,\n        MeasureFilterTreemapWidget.class,\n        WelcomeWidget.class,\n        DocumentationCommentsWidget.class,\n        DuplicationsWidget.class,\n\n        // dashboards\n        ProjectDefaultDashboard.class,\n        ProjectHotspotDashboard.class,\n        ProjectIssuesDashboard.class,\n        ProjectTimeMachineDashboard.class,\n        GlobalDefaultDashboard.class,\n\n        // chart\n        XradarChart.class,\n        DistributionBarChart.class,\n        DistributionAreaChart.class,\n\n        // colorizers\n        JavaColorizerFormat.class,\n\n        // issues\n        IssueTrackingDecorator.class,\n        IssueTracking.class,\n        IssueHandlers.class,\n        CountUnresolvedIssuesDecorator.class,\n        CountFalsePositivesDecorator.class,\n        WeightedIssuesDecorator.class,\n        IssuesDensityDecorator.class,\n        InitialOpenIssuesSensor.class,\n        InitialOpenIssuesStack.class,\n        HotspotMostViolatedResourcesWidget.class,\n        HotspotMostViolatedRulesWidget.class,\n        MyUnresolvedIssuesWidget.class,\n        FalsePositiveIssuesWidget.class,\n        ActionPlansWidget.class,\n        UnresolvedIssuesPerAssigneeWidget.class,\n        UnresolvedIssuesStatusesWidget.class,\n        IssueFilterWidget.class,\n        org.sonar.api.issue.NoSonarFilter.class,\n\n        // issue notifications\n        SendIssueNotificationsPostJob.class,\n        NewIssuesEmailTemplate.class,\n        IssueChangesEmailTemplate.class,\n        ChangesOnMyIssueNotificationDispatcher.class,\n        ChangesOnMyIssueNotificationDispatcher.newMetadata(),\n        NewIssuesNotificationDispatcher.class,\n        NewIssuesNotificationDispatcher.newMetadata(),\n        NewFalsePositiveNotificationDispatcher.class,\n        NewFalsePositiveNotificationDispatcher.newMetadata(),\n\n        // batch\n        ProfileSensor.class,\n        ProfileEventsSensor.class,\n        ProjectLinksSensor.class,\n        UnitTestDecorator.class,\n        VersionEventsSensor.class,\n        CheckAlertThresholds.class,\n        GenerateAlertEvents.class,\n        LineCoverageDecorator.class,\n        CoverageDecorator.class,\n        BranchCoverageDecorator.class,\n        ItLineCoverageDecorator.class,\n        ItCoverageDecorator.class,\n        ItBranchCoverageDecorator.class,\n        OverallLineCoverageDecorator.class,\n        OverallCoverageDecorator.class,\n        OverallBranchCoverageDecorator.class,\n        ApplyProjectRolesDecorator.class,\n        CommentDensityDecorator.class,\n        NoSonarFilter.class,\n        DirectoriesDecorator.class,\n        FilesDecorator.class,\n        IndexProjectPostJob.class,\n        ManualMeasureDecorator.class,\n\n        // time machine\n        TendencyDecorator.class,\n        VariationDecorator.class,\n        TimeMachineConfigurationPersister.class,\n        NewCoverageFileAnalyzer.class,\n        NewItCoverageFileAnalyzer.class,\n        NewOverallCoverageFileAnalyzer.class,\n        NewCoverageAggregator.class,\n\n        // Notify alerts on my favourite projects\n        NewAlerts.class,\n        NewAlerts.newMetadata());\n  }","id":66639,"modified_method":"@SuppressWarnings(\"rawtypes\")\n  public List getExtensions() {\n    ImmutableList.Builder<Object> extensions = ImmutableList.builder();\n\n    extensions.add(\n        DefaultResourceTypes.class,\n        UserManagedMetrics.class,\n        Periods.class,\n\n        // pages\n        Lcom4Viewer.class,\n        TestsViewer.class,\n\n        // measure filters\n        ProjectFilter.class,\n        MyFavouritesFilter.class,\n\n        // widgets\n        AlertsWidget.class,\n        CoverageWidget.class,\n        ItCoverageWidget.class,\n        DescriptionWidget.class,\n        ComplexityWidget.class,\n        RulesWidget.class,\n        SizeWidget.class,\n        EventsWidget.class,\n        CustomMeasuresWidget.class,\n        TimelineWidget.class,\n        TimeMachineWidget.class,\n        HotspotMetricWidget.class,\n        TreemapWidget.class,\n        MeasureFilterListWidget.class,\n        MeasureFilterTreemapWidget.class,\n        WelcomeWidget.class,\n        DocumentationCommentsWidget.class,\n        DuplicationsWidget.class,\n\n        // dashboards\n        ProjectDefaultDashboard.class,\n        ProjectHotspotDashboard.class,\n        ProjectIssuesDashboard.class,\n        ProjectTimeMachineDashboard.class,\n        GlobalDefaultDashboard.class,\n\n        // chart\n        XradarChart.class,\n        DistributionBarChart.class,\n        DistributionAreaChart.class,\n\n        // colorizers\n        JavaColorizerFormat.class,\n\n        // issues\n        IssueTrackingDecorator.class,\n        IssueTracking.class,\n        IssueHandlers.class,\n        CountUnresolvedIssuesDecorator.class,\n        CountFalsePositivesDecorator.class,\n        WeightedIssuesDecorator.class,\n        IssuesDensityDecorator.class,\n        InitialOpenIssuesSensor.class,\n        InitialOpenIssuesStack.class,\n        HotspotMostViolatedResourcesWidget.class,\n        HotspotMostViolatedRulesWidget.class,\n        MyUnresolvedIssuesWidget.class,\n        FalsePositiveIssuesWidget.class,\n        ActionPlansWidget.class,\n        UnresolvedIssuesPerAssigneeWidget.class,\n        UnresolvedIssuesStatusesWidget.class,\n        IssueFilterWidget.class,\n        org.sonar.api.issue.NoSonarFilter.class,\n\n        // issue notifications\n        SendIssueNotificationsPostJob.class,\n        NewIssuesEmailTemplate.class,\n        IssueChangesEmailTemplate.class,\n        ChangesOnMyIssueNotificationDispatcher.class,\n        ChangesOnMyIssueNotificationDispatcher.newMetadata(),\n        NewIssuesNotificationDispatcher.class,\n        NewIssuesNotificationDispatcher.newMetadata(),\n        NewFalsePositiveNotificationDispatcher.class,\n        NewFalsePositiveNotificationDispatcher.newMetadata(),\n\n        // batch\n        ProfileSensor.class,\n        ProfileEventsSensor.class,\n        ProjectLinksSensor.class,\n        UnitTestDecorator.class,\n        VersionEventsSensor.class,\n        CheckAlertThresholds.class,\n        GenerateAlertEvents.class,\n        LineCoverageDecorator.class,\n        CoverageDecorator.class,\n        BranchCoverageDecorator.class,\n        ItLineCoverageDecorator.class,\n        ItCoverageDecorator.class,\n        ItBranchCoverageDecorator.class,\n        OverallLineCoverageDecorator.class,\n        OverallCoverageDecorator.class,\n        OverallBranchCoverageDecorator.class,\n        ApplyProjectRolesDecorator.class,\n        CommentDensityDecorator.class,\n        NoSonarFilter.class,\n        DirectoriesDecorator.class,\n        FilesDecorator.class,\n        IndexProjectPostJob.class,\n        ManualMeasureDecorator.class,\n\n        // time machine\n        TendencyDecorator.class,\n        VariationDecorator.class,\n        TimeMachineConfigurationPersister.class,\n        NewCoverageFileAnalyzer.class,\n        NewItCoverageFileAnalyzer.class,\n        NewOverallCoverageFileAnalyzer.class,\n        NewCoverageAggregator.class,\n\n        // Notify alerts on my favourite projects\n        NewAlerts.class,\n        NewAlerts.newMetadata());\n\n    extensions.addAll(IgnoreIssuesPlugin.getExtensions());\n\n    return extensions.build();\n  }","commit_id":"c6999241df2f34d82c8ba476489a469ca6b61c5a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addPropertiesToProject(File gradleUserHomeDir, Map<String, String> externalProperties, ProjectInternal project) {\n        Properties projectProperties = new Properties();\n        File projectPropertiesFile = new File(project.getProjectDir(), Project.GRADLE_PROPERTIES);\n        logger.debug(\"Looking for project properties from: {}\", projectPropertiesFile);\n        if (projectPropertiesFile.isFile()) {\n            try {\n                projectProperties.load(new FileInputStream(projectPropertiesFile));\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            logger.debug(\"Adding project properties (if not overwritten by user properties): {}\",\n                    projectProperties.keySet());\n        } else {\n            logger.debug(\"project property file does not exists. We continue!\");\n        }\n        projectProperties.putAll(externalProperties);\n        try {\n            project.setGradleUserHome(gradleUserHomeDir.getCanonicalPath());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        for (Object key : projectProperties.keySet()) {\n            project.setProperty((String) key, projectProperties.get(key));\n        }\n    }","id":66640,"modified_method":"private void addPropertiesToProject(File gradleUserHomeDir, Map<String, String> externalProperties, ProjectInternal project) {\n        Properties projectProperties = new Properties();\n        File projectPropertiesFile = new File(project.getProjectDir(), Project.GRADLE_PROPERTIES);\n        logger.debug(\"Looking for project properties from: {}\", projectPropertiesFile);\n        if (projectPropertiesFile.isFile()) {\n            projectProperties = GUtil.loadProperties(projectPropertiesFile);\n            logger.debug(\"Adding project properties (if not overwritten by user properties): {}\",\n                    projectProperties.keySet());\n        } else {\n            logger.debug(\"project property file does not exists. We continue!\");\n        }\n        projectProperties.putAll(externalProperties);\n        try {\n            project.setGradleUserHome(gradleUserHomeDir.getCanonicalPath());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        for (Object key : projectProperties.keySet()) {\n            project.setProperty((String) key, projectProperties.get(key));\n        }\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"public CacheState getCacheState(String scriptText, File scriptCacheDir) {\n        File propertiesFile = new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME);\n        if (!propertiesFile.isFile()) {\n            return CacheState.INVALID;\n        }\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME)));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (properties.get(CachePropertiesHandler.EMPTY_SCRIPT) != null && properties.get(CachePropertiesHandler.EMPTY_SCRIPT).equals(Boolean.TRUE.toString())) {\n            return CacheState.EMPTY_SCRIPT;\n        }\n        if (!properties.get(CachePropertiesHandler.VERSION_KEY).equals(new GradleVersion().getVersion())) {\n            return CacheState.INVALID;\n        }\n        return createHash(scriptText).equals(properties.get(CachePropertiesHandler.HASH_KEY)) ?\n                CacheState.VALID : CacheState.INVALID;\n    }","id":66641,"modified_method":"public CacheState getCacheState(String scriptText, File scriptCacheDir) {\n        File propertiesFile = new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME);\n        if (!propertiesFile.isFile()) {\n            return CacheState.INVALID;\n        }\n        Properties properties = GUtil.loadProperties(new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME));\n        if (properties.get(CachePropertiesHandler.EMPTY_SCRIPT) != null && properties.get(CachePropertiesHandler.EMPTY_SCRIPT).equals(Boolean.TRUE.toString())) {\n            return CacheState.EMPTY_SCRIPT;\n        }\n        if (!properties.get(CachePropertiesHandler.VERSION_KEY).equals(new GradleVersion().getVersion())) {\n            return CacheState.INVALID;\n        }\n        return createHash(scriptText).equals(properties.get(CachePropertiesHandler.HASH_KEY)) ?\n                CacheState.VALID : CacheState.INVALID;\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"public void writeProperties(String scriptText, File scriptCacheDir, boolean emptyScript) {\n        Properties properties = new Properties();\n        properties.put(CachePropertiesHandler.HASH_KEY, createHash(scriptText));\n        properties.put(CachePropertiesHandler.VERSION_KEY, new GradleVersion().getVersion());\n        if (emptyScript) {\n            properties.put(CachePropertiesHandler.EMPTY_SCRIPT, Boolean.TRUE.toString());\n        }\n        try {\n            properties.store(new FileOutputStream(new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME)), null);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":66642,"modified_method":"public void writeProperties(String scriptText, File scriptCacheDir, boolean emptyScript) {\n        Properties properties = new Properties();\n        properties.put(CachePropertiesHandler.HASH_KEY, createHash(scriptText));\n        properties.put(CachePropertiesHandler.VERSION_KEY, new GradleVersion().getVersion());\n        if (emptyScript) {\n            properties.put(CachePropertiesHandler.EMPTY_SCRIPT, Boolean.TRUE.toString());\n        }\n        GUtil.saveProperties(properties, new File(scriptCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME));\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void createPropertiesFile(String scriptText, boolean emptyScript, String version) throws NoSuchAlgorithmException, IOException {\n        Properties properties = new Properties();\n        properties.put(CachePropertiesHandler.HASH_KEY, createHash(scriptText));\n        properties.put(CachePropertiesHandler.VERSION_KEY, version);\n        if (emptyScript) {\n            properties.put(CachePropertiesHandler.EMPTY_SCRIPT, Boolean.TRUE.toString());\n        }\n        properties.store(new FileOutputStream(new File(testCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME)), null);\n    }","id":66643,"modified_method":"private void createPropertiesFile(String scriptText, boolean emptyScript, String version) throws NoSuchAlgorithmException, IOException {\n        Properties properties = new Properties();\n        properties.put(CachePropertiesHandler.HASH_KEY, createHash(scriptText));\n        properties.put(CachePropertiesHandler.VERSION_KEY, version);\n        if (emptyScript) {\n            properties.put(CachePropertiesHandler.EMPTY_SCRIPT, Boolean.TRUE.toString());\n        }\n        GUtil.saveProperties(properties, new File(testCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME));\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void checkWriteProperties(Map additionalExpectedProperties) throws IOException, NoSuchAlgorithmException {\n        File propertiesFile = new File(testCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME);\n        Properties actualProperties = new Properties();\n        actualProperties.load(new FileInputStream(propertiesFile));\n        Properties expectedProperties = new Properties();\n        expectedProperties.put(CachePropertiesHandler.HASH_KEY, createHash(TEST_SCRIPT_TEXT));\n        expectedProperties.put(CachePropertiesHandler.VERSION_KEY, new GradleVersion().getVersion());\n        expectedProperties.putAll(additionalExpectedProperties);\n        assertEquals(expectedProperties, actualProperties);\n    }","id":66644,"modified_method":"private void checkWriteProperties(Map additionalExpectedProperties) throws IOException, NoSuchAlgorithmException {\n        File propertiesFile = new File(testCacheDir, CachePropertiesHandler.PROPERTY_FILE_NAME);\n        Properties actualProperties = GUtil.loadProperties(propertiesFile);\n        Properties expectedProperties = new Properties();\n        expectedProperties.put(CachePropertiesHandler.HASH_KEY, createHash(TEST_SCRIPT_TEXT));\n        expectedProperties.put(CachePropertiesHandler.VERSION_KEY, new GradleVersion().getVersion());\n        expectedProperties.putAll(additionalExpectedProperties);\n        assertEquals(expectedProperties, actualProperties);\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void addGradleProperties(File... files) {\n        for (File propertyFile : files) {\n            if (propertyFile.isFile()) {\n                Properties properties = new Properties();\n                try {\n                    properties.load(new FileInputStream(propertyFile));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                gradleProperties.putAll(new HashMap(properties));\n            }\n        }\n    }","id":66645,"modified_method":"private void addGradleProperties(File... files) {\n        for (File propertyFile : files) {\n            if (propertyFile.isFile()) {\n                Properties properties = GUtil.loadProperties(propertyFile);\n                gradleProperties.putAll(new HashMap(properties));\n            }\n        }\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void writePropertyFile(File location, Map<String, String> propertiesMap) {\n        Properties properties = new Properties();\n        properties.putAll(propertiesMap);\n        try {\n            properties.store(new FileOutputStream(new File(location, Project.GRADLE_PROPERTIES)), \"\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":66646,"modified_method":"private void writePropertyFile(File location, Map<String, String> propertiesMap) {\n        Properties properties = new Properties();\n        properties.putAll(propertiesMap);\n        GUtil.saveProperties(properties, new File(location, Project.GRADLE_PROPERTIES));\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"public static Properties createProperties(File propertyFile) {\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(propertyFile));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return properties;\n    }","id":66647,"modified_method":"public static Properties loadProperties(File propertyFile) {\n        try {\n            return loadProperties(new FileInputStream(propertyFile));\n        } catch (FileNotFoundException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"public PluginRegistry(File pluginProperties) {\n        if (!pluginProperties.isFile()) {\n            return;\n        }\n        logger.debug(\"Checking file= {}\", pluginProperties);\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(pluginProperties));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":66648,"modified_method":"public PluginRegistry(File pluginProperties) {\n        if (!pluginProperties.isFile()) {\n            return;\n        }\n        logger.debug(\"Checking file= {}\", pluginProperties);\n        properties = GUtil.loadProperties(pluginProperties);\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeProperties(File propertiesFileDestination) {\n        Properties wrapperProperties = new Properties();\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.URL_ROOT_PROPERTY, urlRoot);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_BASE_PROPERTY, distributionBase.toString());\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_PATH_PROPERTY, distributionPath);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_NAME_PROPERTY, archiveName);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_CLASSIFIER_PROPERTY, archiveClassifier);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_VERSION_PROPERTY, gradleVersion);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.ZIP_STORE_BASE_PROPERTY, archiveBase.toString());\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.ZIP_STORE_PATH_PROPERTY, archivePath);\n        try {\n            wrapperProperties.store(new FileOutputStream(propertiesFileDestination), \"\");\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","id":66649,"modified_method":"private void writeProperties(File propertiesFileDestination) {\n        Properties wrapperProperties = new Properties();\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.URL_ROOT_PROPERTY, urlRoot);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_BASE_PROPERTY, distributionBase.toString());\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_PATH_PROPERTY, distributionPath);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_NAME_PROPERTY, archiveName);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_CLASSIFIER_PROPERTY, archiveClassifier);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.DISTRIBUTION_VERSION_PROPERTY, gradleVersion);\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.ZIP_STORE_BASE_PROPERTY, archiveBase.toString());\n        wrapperProperties.put(org.gradle.wrapper.Wrapper.ZIP_STORE_PATH_PROPERTY, archivePath);\n        GUtil.saveProperties(wrapperProperties, propertiesFileDestination);\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"private void checkExecute() throws IOException {\n        context.checking(new Expectations() {\n            {\n                one(wrapperScriptGeneratorMock).generate(\n                        targetWrapperJarPath + \"/\" + Install.WRAPPER_JAR,\n                        targetWrapperJarPath + \"/\" + Install.WRAPPER_PROPERTIES,\n                        new File(getProject().getProjectDir(), wrapper.getScriptDestinationPath()));\n            }\n        });\n        wrapper.execute();\n        File unjarDir = HelperUtil.makeNewTestDir(\"unjar\");\n        CompressUtil.unzip(expectedTargetWrapperJar, unjarDir);\n        assertEquals(TEST_TEXT, FileUtils.readFileToString(new File(unjarDir, TEST_FILE_NAME)));\n        Properties properties = GUtil.createProperties(expectedTargetWrapperProperties);\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.URL_ROOT_PROPERTY), wrapper.getUrlRoot());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_BASE_PROPERTY), wrapper.getDistributionBase().toString());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_PATH_PROPERTY), wrapper.getDistributionPath());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_NAME_PROPERTY), wrapper.getArchiveName());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_CLASSIFIER_PROPERTY), wrapper.getArchiveClassifier());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_VERSION_PROPERTY), wrapper.getGradleVersion());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.ZIP_STORE_BASE_PROPERTY), wrapper.getArchiveBase().toString());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.ZIP_STORE_PATH_PROPERTY), wrapper.getArchivePath());\n    }","id":66650,"modified_method":"private void checkExecute() throws IOException {\n        context.checking(new Expectations() {\n            {\n                one(wrapperScriptGeneratorMock).generate(\n                        targetWrapperJarPath + \"/\" + Install.WRAPPER_JAR,\n                        targetWrapperJarPath + \"/\" + Install.WRAPPER_PROPERTIES,\n                        new File(getProject().getProjectDir(), wrapper.getScriptDestinationPath()));\n            }\n        });\n        wrapper.execute();\n        File unjarDir = HelperUtil.makeNewTestDir(\"unjar\");\n        CompressUtil.unzip(expectedTargetWrapperJar, unjarDir);\n        assertEquals(TEST_TEXT, FileUtils.readFileToString(new File(unjarDir, TEST_FILE_NAME)));\n        Properties properties = GUtil.loadProperties(expectedTargetWrapperProperties);\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.URL_ROOT_PROPERTY), wrapper.getUrlRoot());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_BASE_PROPERTY), wrapper.getDistributionBase().toString());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_PATH_PROPERTY), wrapper.getDistributionPath());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_NAME_PROPERTY), wrapper.getArchiveName());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_CLASSIFIER_PROPERTY), wrapper.getArchiveClassifier());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.DISTRIBUTION_VERSION_PROPERTY), wrapper.getGradleVersion());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.ZIP_STORE_BASE_PROPERTY), wrapper.getArchiveBase().toString());\n        assertEquals(properties.getProperty(org.gradle.wrapper.Wrapper.ZIP_STORE_PATH_PROPERTY), wrapper.getArchivePath());\n    }","commit_id":"191b30b4d79ca99abe63d16d1199dc82b14e8313","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public ArtifactPluginDescriptor create(File pluginFolder) throws ArtifactDescriptorCreateException\n    {\n        final String pluginName = pluginFolder.getName();\n        final ArtifactPluginDescriptor descriptor = new ArtifactPluginDescriptor();\n        descriptor.setRootFolder(pluginFolder);\n        descriptor.setName(pluginName);\n\n        final File pluginPropsFile = new File(pluginFolder, PLUGIN_PROPERTIES);\n        if (pluginPropsFile.exists())\n        {\n            Properties props = new Properties();\n            try\n            {\n                props.load(new FileReader(pluginPropsFile));\n            }\n            catch (IOException e)\n            {\n                throw new ArtifactDescriptorCreateException(\"Cannot read plugin.properties file\", e);\n            }\n\n            String exportedClasses = props.getProperty(EXPORTED_CLASS_PACKAGES_PROPERTY);\n            String exportedResources = props.getProperty(EXPORTED_RESOURCE_PACKAGES_PROPERTY);\n\n            final ArtifactClassLoaderFilter classLoaderFilter = classLoaderFilterFactory.create(exportedClasses, exportedResources);\n            descriptor.setClassLoaderFilter(classLoaderFilter);\n        }\n\n        try\n        {\n            descriptor.setRuntimeClassesDir(new File(pluginFolder, \"classes\").toURI().toURL());\n            final File libDir = new File(pluginFolder, \"lib\");\n            URL[] urls = new URL[0];\n            if (libDir.exists())\n            {\n                final File[] jars = libDir.listFiles((FilenameFilter) new SuffixFileFilter(\".jar\"));\n                urls = new URL[jars.length];\n                for (int i = 0; i < jars.length; i++)\n                {\n                    urls[i] = jars[i].toURI().toURL();\n                }\n            }\n            descriptor.setRuntimeLibs(urls);\n        }\n        catch (MalformedURLException e)\n        {\n            throw new ArtifactDescriptorCreateException(\"Failed to create plugin descriptor \" + pluginFolder);\n        }\n\n        return descriptor;\n    }","id":66651,"modified_method":"@Override\n    public ArtifactPluginDescriptor create(File pluginFolder) throws ArtifactDescriptorCreateException\n    {\n        final String pluginName = pluginFolder.getName();\n        final ArtifactPluginDescriptor descriptor = new ArtifactPluginDescriptor();\n        descriptor.setRootFolder(pluginFolder);\n        descriptor.setName(pluginName);\n\n        final File pluginPropsFile = new File(pluginFolder, PLUGIN_PROPERTIES);\n        if (pluginPropsFile.exists())\n        {\n            Properties props;\n            try\n            {\n                props = loadProperties(pluginPropsFile.toURI().toURL());\n            }\n            catch (IOException e)\n            {\n                throw new ArtifactDescriptorCreateException(\"Cannot read plugin.properties file\", e);\n            }\n\n            String exportedClasses = props.getProperty(EXPORTED_CLASS_PACKAGES_PROPERTY);\n            String exportedResources = props.getProperty(EXPORTED_RESOURCE_PACKAGES_PROPERTY);\n\n            final ArtifactClassLoaderFilter classLoaderFilter = classLoaderFilterFactory.create(exportedClasses, exportedResources);\n            descriptor.setClassLoaderFilter(classLoaderFilter);\n        }\n\n        try\n        {\n            descriptor.setRuntimeClassesDir(new File(pluginFolder, \"classes\").toURI().toURL());\n            final File libDir = new File(pluginFolder, \"lib\");\n            URL[] urls = new URL[0];\n            if (libDir.exists())\n            {\n                final File[] jars = libDir.listFiles((FilenameFilter) new SuffixFileFilter(\".jar\"));\n                urls = new URL[jars.length];\n                for (int i = 0; i < jars.length; i++)\n                {\n                    urls[i] = jars[i].toURI().toURL();\n                }\n            }\n            descriptor.setRuntimeLibs(urls);\n        }\n        catch (MalformedURLException e)\n        {\n            throw new ArtifactDescriptorCreateException(\"Failed to create plugin descriptor \" + pluginFolder);\n        }\n\n        return descriptor;\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void autoConfigure(MuleContext muleContext, ConfigResource[] resources) throws ConfigurationException\n    {\n        Map<String, List<ConfigResource>> configsMap = new LinkedHashMap<String, List<ConfigResource>>();\n\n        for (int i = 0; i < resources.length; i++)\n        {\n            String configExtension = StringUtils.substringAfterLast(\n                (resources[i]).getUrl().getFile(), \".\");\n            List<ConfigResource> configs = configsMap.get(configExtension);\n            if (configs == null)\n            {\n                configs = new ArrayList<ConfigResource>();\n                configsMap.put(configExtension, configs);\n            }\n            configs.add(resources[i]);\n        }\n\n        try\n        {\n            Properties props = new Properties();\n            props.load(ClassUtils.getResource(\"configuration-builders.properties\", this.getClass()).openStream());\n\n            for (Map.Entry<String, List<ConfigResource>> e : configsMap.entrySet())\n            {\n                String extension = e.getKey();\n                List<ConfigResource> configs = e.getValue();\n\n                String className = (String) props.get(extension);\n\n                if (className == null || !ClassUtils.isClassOnPath(className, this.getClass()))\n                {\n                    throw new ConfigurationException(\n                        CoreMessages.configurationBuilderNoMatching(createConfigResourcesString()));\n                }\n\n                ConfigResource[] constructorArg = new ConfigResource[configs.size()];\n                System.arraycopy(configs.toArray(), 0, constructorArg, 0, configs.size());\n                ConfigurationBuilder cb = (ConfigurationBuilder) ClassUtils.instanciateClass(className, new Object[] {constructorArg, getArtifactProperties(), artifactType});\n                if (parentContext != null && cb instanceof ParentMuleContextAwareConfigurationBuilder)\n                {\n                    ((ParentMuleContextAwareConfigurationBuilder) cb).setParentContext(parentContext);\n                }\n                else if (parentContext != null)\n                {\n                    throw new MuleRuntimeException(CoreMessages.createStaticMessage(String.format(\"ConfigurationBuilder %s does not support domain context\", cb.getClass().getCanonicalName())));\n                }\n                cb.configure(muleContext);\n            }\n        }\n        catch (ConfigurationException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new ConfigurationException(e);\n        }\n    }","id":66652,"modified_method":"protected void autoConfigure(MuleContext muleContext, ConfigResource[] resources) throws ConfigurationException\n    {\n        Map<String, List<ConfigResource>> configsMap = new LinkedHashMap<String, List<ConfigResource>>();\n\n        for (int i = 0; i < resources.length; i++)\n        {\n            String configExtension = StringUtils.substringAfterLast(\n                (resources[i]).getUrl().getFile(), \".\");\n            List<ConfigResource> configs = configsMap.get(configExtension);\n            if (configs == null)\n            {\n                configs = new ArrayList<ConfigResource>();\n                configsMap.put(configExtension, configs);\n            }\n            configs.add(resources[i]);\n        }\n\n        try\n        {\n            Properties props = loadProperties(getResource(\"configuration-builders.properties\", this.getClass()).openStream());\n\n            for (Map.Entry<String, List<ConfigResource>> e : configsMap.entrySet())\n            {\n                String extension = e.getKey();\n                List<ConfigResource> configs = e.getValue();\n\n                String className = (String) props.get(extension);\n\n                if (className == null || !ClassUtils.isClassOnPath(className, this.getClass()))\n                {\n                    throw new ConfigurationException(\n                        CoreMessages.configurationBuilderNoMatching(createConfigResourcesString()));\n                }\n\n                ConfigResource[] constructorArg = new ConfigResource[configs.size()];\n                System.arraycopy(configs.toArray(), 0, constructorArg, 0, configs.size());\n                ConfigurationBuilder cb = (ConfigurationBuilder) ClassUtils.instanciateClass(className, new Object[] {constructorArg, getArtifactProperties(), artifactType});\n                if (parentContext != null && cb instanceof ParentMuleContextAwareConfigurationBuilder)\n                {\n                    ((ParentMuleContextAwareConfigurationBuilder) cb).setParentContext(parentContext);\n                }\n                else if (parentContext != null)\n                {\n                    throw new MuleRuntimeException(CoreMessages.createStaticMessage(String.format(\"ConfigurationBuilder %s does not support domain context\", cb.getClass().getCanonicalName())));\n                }\n                cb.configure(muleContext);\n            }\n        }\n        catch (ConfigurationException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new ConfigurationException(e);\n        }\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public List<MuleCoreExtension> discover() throws DefaultMuleException\n    {\n        List<MuleCoreExtension> result = new LinkedList<>();\n\n        Enumeration<?> e = ClassUtils.getResources(CORE_EXTENSION_RESOURCE_NAME, getClass());\n        List<Properties> extensions = new LinkedList<Properties>();\n\n        // load ALL of the extension files first\n        while (e.hasMoreElements())\n        {\n            try\n            {\n                URL url = (URL) e.nextElement();\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Reading extension file: \" + url.toString());\n                }\n                Properties p = new Properties();\n                p.load(url.openStream());\n                extensions.add(p);\n            }\n            catch (Exception ex)\n            {\n                throw new DefaultMuleException(\"Error loading Mule core extensions\", ex);\n            }\n        }\n\n        for (Properties extProps : extensions)\n        {\n            for (Map.Entry entry : extProps.entrySet())\n            {\n                String extName = (String) entry.getKey();\n                String extClass = (String) entry.getValue();\n                try\n                {\n                    MuleCoreExtension extension = (MuleCoreExtension) ClassUtils.instanciateClass(extClass);\n                    extension.setContainerClassLoader(containerClassLoader);\n                    result.add(extension);\n                }\n                catch (Exception ex)\n                {\n                    throw new DefaultMuleException(\"Error starting Mule core extension \" + extName, ex);\n                }\n            }\n        }\n\n        return result;\n    }","id":66653,"modified_method":"@Override\n    public List<MuleCoreExtension> discover() throws DefaultMuleException\n    {\n        List<MuleCoreExtension> result = new LinkedList<>();\n\n        Enumeration<?> e = ClassUtils.getResources(CORE_EXTENSION_RESOURCE_NAME, getClass());\n        List<Properties> extensions = new LinkedList<Properties>();\n\n        // load ALL of the extension files first\n        while (e.hasMoreElements())\n        {\n            try\n            {\n                URL url = (URL) e.nextElement();\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Reading extension file: \" + url.toString());\n                }\n                extensions.add(loadProperties(url.openStream()));\n            }\n            catch (Exception ex)\n            {\n                throw new DefaultMuleException(\"Error loading Mule core extensions\", ex);\n            }\n        }\n\n        for (Properties extProps : extensions)\n        {\n            for (Map.Entry entry : extProps.entrySet())\n            {\n                String extName = (String) entry.getKey();\n                String extClass = (String) entry.getValue();\n                try\n                {\n                    MuleCoreExtension extension = (MuleCoreExtension) ClassUtils.instanciateClass(extClass);\n                    extension.setContainerClassLoader(containerClassLoader);\n                    result.add(extension);\n                }\n                catch (Exception ex)\n                {\n                    throw new DefaultMuleException(\"Error starting Mule core extension \" + extName, ex);\n                }\n            }\n        }\n\n        return result;\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"protected ResourceReleaser createResourceReleaserInstance()\n    {\n        try\n        {\n            InputStream classStream = this.getClass().getResourceAsStream(resourceReleaserClassLocation);\n            byte[] classBytes = IOUtils.toByteArray(classStream);\n            Class clazz = this.defineClass(null, classBytes, 0, classBytes.length);\n            return (ResourceReleaser) clazz.newInstance();\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(\"Can not create resource releaser instance from resource: \" + resourceReleaserClassLocation, e);\n        }\n    }","id":66654,"modified_method":"protected ResourceReleaser createResourceReleaserInstance()\n    {\n        InputStream classStream = null;\n        try\n        {\n            classStream = this.getClass().getResourceAsStream(resourceReleaserClassLocation);\n            byte[] classBytes = IOUtils.toByteArray(classStream);\n            classStream.close();\n            Class clazz = defineClass(null, classBytes, 0, classBytes.length);\n            return (ResourceReleaser) clazz.newInstance();\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(\"Can not create resource releaser instance from resource: \" + resourceReleaserClassLocation, e);\n        }\n        finally\n        {\n            closeQuietly(classStream);\n        }\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured XML parser.\n     */\n    @Override\n    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,\n                                 ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception\n    {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        IOUtils.copy(inputSource.getByteStream(), output);\n\n        InputSource defaultInputSource = new InputSource(new ByteArrayInputStream(output.toByteArray()));\n        InputSource enrichInputSource = new InputSource(new ByteArrayInputStream(output.toByteArray()));\n\n        Document doc = defaultLoader.loadDocument(defaultInputSource, entityResolver, errorHandler, validationMode, namespaceAware);\n\n        createSaxAnnotator(doc).parse(enrichInputSource);\n\n        return doc;\n    }","id":66655,"modified_method":"/**\n     * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured XML parser.\n     */\n    @Override\n    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,\n                                 ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception\n    {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        try (InputStream inputStream = inputSource.getByteStream())\n        {\n            IOUtils.copy(inputStream, output);\n        }\n\n        InputSource defaultInputSource = new InputSource(new ByteArrayInputStream(output.toByteArray()));\n        InputSource enrichInputSource = new InputSource(new ByteArrayInputStream(output.toByteArray()));\n\n        Document doc = defaultLoader.loadDocument(defaultInputSource, entityResolver, errorHandler, validationMode, namespaceAware);\n\n        createSaxAnnotator(doc).parse(enrichInputSource);\n\n        return doc;\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"public void load(String fileName)\n    {\n        Properties properties = new Properties();\n        try\n        {\n            InputStream config = IOUtils.getResourceAsStream(fileName, TlsProperties.class);\n\n            if (config == null)\n            {\n                logger.warn(String.format(\"File %s not found, using default configuration.\", fileName));\n            }\n            else\n            {\n                logger.info(String.format(\"Loading configuration file: %s\", fileName));\n                properties.load(config);\n\n                String enabledCipherSuitesProperty = properties.getProperty(\"enabledCipherSuites\");\n                String enabledProtocolsProperty = properties.getProperty(\"enabledProtocols\");\n\n                if (enabledCipherSuitesProperty != null)\n                {\n                    enabledCipherSuites = StringUtils.splitAndTrim(enabledCipherSuitesProperty, \",\");\n\n                }\n                if (enabledProtocolsProperty != null)\n                {\n                    enabledProtocols = StringUtils.splitAndTrim(enabledProtocolsProperty, \",\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            logger.warn(String.format(\"Cannot read file %s, using default configuration\", fileName), e);\n        }\n    }","id":66656,"modified_method":"public void load(String fileName)\n    {\n        try\n        {\n            InputStream config = IOUtils.getResourceAsStream(fileName, TlsProperties.class);\n\n            if (config == null)\n            {\n                logger.warn(String.format(\"File %s not found, using default configuration.\", fileName));\n            }\n            else\n            {\n                logger.info(String.format(\"Loading configuration file: %s\", fileName));\n                Properties properties = loadProperties(config);\n\n                String enabledCipherSuitesProperty = properties.getProperty(\"enabledCipherSuites\");\n                String enabledProtocolsProperty = properties.getProperty(\"enabledProtocols\");\n\n                if (enabledCipherSuitesProperty != null)\n                {\n                    enabledCipherSuites = StringUtils.splitAndTrim(enabledCipherSuitesProperty, \",\");\n\n                }\n                if (enabledProtocolsProperty != null)\n                {\n                    enabledProtocols = StringUtils.splitAndTrim(enabledProtocolsProperty, \",\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            logger.warn(String.format(\"Cannot read file %s, using default configuration\", fileName), e);\n        }\n    }","commit_id":"aac359244572908b9f2fba27688d4be49aec7977","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.filterFindByC_M_R_P(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, -1);\n\n\t\t\tif (!InlineSQLHelperUtil.isEnabled(repositoryId)) {\n\t\t\t\tsyncDLObjects = checkSyncDLObjects(syncDLObjects);\n\t\t\t}\n\n\t\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\t\tif (syncDLObject.getModifiedTime() > lastAccessTime) {\n\t\t\t\t\tlastAccessTime = syncDLObject.getModifiedTime();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":66657,"modified_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tString event = null;\n\n\t\t\tif (lastAccessTime == -1) {\n\t\t\t\tevent = SyncConstants.EVENT_DELETE;\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_M_R_NotE(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, event, 0,\n\t\t\t\t\tPortletPropsValues.SYNC_PAGINATION_DELTA,\n\t\t\t\t\tnew SyncDLObjectTypeComparator());\n\n\t\t\tsyncDLObjects = checkSyncDLObjects(syncDLObjects);\n\n\t\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\t\tif (syncDLObject.getModifiedTime() > lastAccessTime) {\n\t\t\t\t\tlastAccessTime = syncDLObject.getModifiedTime();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"90668bd409ec02abb913f6d5d46a40d986392360","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<SyncDLObject> getSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects, long companyId, long repositoryId,\n\t\t\tlong parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\tList<SyncDLObject> curSyncDLObjects =\n\t\t\tsyncDLObjectFinder.filterFindByC_M_R_P(\n\t\t\t\tcompanyId, lastAccessTime, repositoryId, parentFolderId);\n\n\t\tif (!InlineSQLHelperUtil.isEnabled(repositoryId)) {\n\t\t\tcurSyncDLObjects = checkSyncDLObjects(curSyncDLObjects);\n\t\t}\n\n\t\tsyncDLObjects.addAll(curSyncDLObjects);\n\n\t\tfor (SyncDLObject curSyncDLObject : curSyncDLObjects) {\n\t\t\tString type = curSyncDLObject.getType();\n\n\t\t\tif (!type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgetSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId,\n\t\t\t\tcurSyncDLObject.getTypePK(), lastAccessTime);\n\t\t}\n\n\t\treturn syncDLObjects;\n\t}","id":66658,"modified_method":"protected List<SyncDLObject> getSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects, long companyId, long repositoryId,\n\t\t\tlong parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\tList<SyncDLObject> curSyncDLObjects =\n\t\t\tsyncDLObjectPersistence.findByC_M_R_P(\n\t\t\t\tcompanyId, lastAccessTime, repositoryId, parentFolderId);\n\n\t\tcurSyncDLObjects = checkSyncDLObjects(curSyncDLObjects);\n\n\t\tsyncDLObjects.addAll(curSyncDLObjects);\n\n\t\tfor (SyncDLObject curSyncDLObject : curSyncDLObjects) {\n\t\t\tString type = curSyncDLObject.getType();\n\n\t\t\tif (!type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgetSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId,\n\t\t\t\tcurSyncDLObject.getTypePK(), lastAccessTime);\n\t\t}\n\n\t\treturn syncDLObjects;\n\t}","commit_id":"90668bd409ec02abb913f6d5d46a40d986392360","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.filterFindByC_R(companyId, repositoryId);\n\n\t\t\tif (!InlineSQLHelperUtil.isEnabled(repositoryId)) {\n\t\t\t\treturn checkSyncDLObjects(syncDLObjects);\n\t\t\t}\n\n\t\t\treturn syncDLObjects;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":66659,"modified_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_R_T(\n\t\t\t\t\tcompanyId, repositoryId, SyncConstants.TYPE_FOLDER);\n\n\t\t\treturn checkSyncDLObjects(syncDLObjects);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"90668bd409ec02abb913f6d5d46a40d986392360","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<SyncDLObject> checkSyncDLObjects(\n\t\tList<SyncDLObject> syncDLObjects) {\n\n\t\tIterator<SyncDLObject> iterator = syncDLObjects.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tSyncDLObject syncDLObject = iterator.next();\n\n\t\t\tString type = syncDLObject.getType();\n\n\t\t\ttry {\n\t\t\t\tif (type.equals(SyncConstants.TYPE_FILE) ||\n\t\t\t\t\ttype.equals(SyncConstants.TYPE_PRIVATE_WORKING_COPY)) {\n\n\t\t\t\t\tdlAppService.getFileEntry(syncDLObject.getTypePK());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdlAppService.getFolder(syncDLObject.getTypePK());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn syncDLObjects;\n\t}","id":66660,"modified_method":"protected List<SyncDLObject> checkSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects)\n\t\tthrows PortalException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<SyncDLObject> checkedSyncDLObjects = new ArrayList<>();\n\n\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\tString event = syncDLObject.getEvent();\n\n\t\t\tif (event.equals(SyncConstants.EVENT_DELETE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString type = syncDLObject.getType();\n\n\t\t\tif (type.equals(SyncConstants.TYPE_FILE)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFolderConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_PRIVATE_WORKING_COPY)) {\n\t\t\t\tif ((syncDLObject.getLockUserId() !=\n\t\t\t\t\t\tpermissionChecker.getUserId()) ||\n\t\t\t\t\t!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckedSyncDLObjects.add(syncDLObject);\n\t\t}\n\n\t\treturn checkedSyncDLObjects;\n\t}","commit_id":"90668bd409ec02abb913f6d5d46a40d986392360","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Create a camel endpoint after passing validation on the incoming url.\n     * @param uri the full URI of the endpoint\n     * @param remaining the remaining part of the URI without the query\n     *                parameters or component prefix\n     * @param parameters the optional parameters passed in\n     * @return the camel endpoint\n     * @throws Exception\n     */\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DropboxConfiguration configuration = new DropboxConfiguration();\n\n        // set options from component\n        configuration.setAccessToken((String)parameters.get(\"accessToken\"));\n        configuration.setLocalPath((String)parameters.get(\"localPath\"));\n        configuration.setRemotePath((String)parameters.get(\"remotePath\"));\n        configuration.setNewRemotePath((String)parameters.get(\"newRemotePath\"));\n        configuration.setQuery((String)parameters.get(\"query\"));\n        configuration.setOperation(DropboxOperation.valueOf(remaining));\n        configuration.setClientIdentifier(\n                parameters.get(\"clientIdentifier\") == null\n                        ? DropboxPropertyManager.getInstance().getProperty(\"clientIdentifier\")\n                        : (String) parameters.get(\"clientIdentifier\"));\n        if (parameters.get(\"uploadMode\") != null) {\n            configuration.setUploadMode(DropboxUploadMode.valueOf((String)parameters.get(\"uploadMode\")));\n        }\n\n        //pass validation test\n        DropboxConfigurationValidator.validate(configuration);\n\n        // and then override from parameters\n        setProperties(configuration, parameters);\n\n        Endpoint endpoint = new DropboxEndpoint(uri, this, configuration);\n        return endpoint;\n    }","id":66661,"modified_method":"/**\n     * Create a camel endpoint after passing validation on the incoming url.\n     * @param uri the full URI of the endpoint\n     * @param remaining the remaining part of the URI without the query\n     *                parameters or component prefix\n     * @param parameters the optional parameters passed in\n     * @return the camel endpoint\n     * @throws Exception\n     */\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DropboxConfiguration configuration = new DropboxConfiguration();\n\n        // set options from component\n        configuration.setAccessToken((String)parameters.get(\"accessToken\"));\n        configuration.setLocalPath((String)parameters.get(\"localPath\"));\n        configuration.setRemotePath(((String)parameters.get(\"remotePath\")).replaceAll(\"\\\\s\",\"+\"));\n        configuration.setNewRemotePath((String)parameters.get(\"newRemotePath\"));\n        configuration.setQuery((String)parameters.get(\"query\"));\n        configuration.setOperation(DropboxOperation.valueOf(remaining));\n        configuration.setClientIdentifier(\n                parameters.get(\"clientIdentifier\") == null\n                        ? DropboxPropertyManager.getInstance().getProperty(\"clientIdentifier\")\n                        : (String) parameters.get(\"clientIdentifier\"));\n        if (parameters.get(\"uploadMode\") != null) {\n            configuration.setUploadMode(DropboxUploadMode.valueOf((String)parameters.get(\"uploadMode\")));\n        }\n\n        //pass validation test\n        DropboxConfigurationValidator.validate(configuration);\n\n        // and then override from parameters\n        setProperties(configuration, parameters);\n\n        Endpoint endpoint = new DropboxEndpoint(uri, this, configuration);\n        return endpoint;\n    }","commit_id":"c6a331c2059c8f94a5a3cc46fca677babbad6998","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void shouldCreateGetConsumer() throws Exception {\n        // Given\n        Endpoint dropboxEndpoint = context.getEndpoint(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path\");\n\n        // When\n        Consumer consumer = dropboxEndpoint.createConsumer(null);\n\n        // Then\n        Assert.assertTrue(consumer instanceof DropboxScheduledPollGetConsumer);\n    }","id":66662,"modified_method":"@Test\n    public void shouldCreateGetConsumer() throws Exception {\n        // Given\n        Endpoint dropboxEndpoint1 = context.getEndpoint(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path\");\n\n        // When\n        Consumer consumer1 = dropboxEndpoint1.createConsumer(null);\n\n        // Then\n        Assert.assertTrue(consumer1 instanceof DropboxScheduledPollGetConsumer);\n        \n        // Given\n        Endpoint dropboxEndpoint2 = context.getEndpoint(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path with spaces/file\");\n\n        // When\n        Consumer consumer2 = dropboxEndpoint2.createConsumer(null);\n\n        // Then\n        Assert.assertTrue(consumer2 instanceof DropboxScheduledPollGetConsumer);\n    }","commit_id":"c6a331c2059c8f94a5a3cc46fca677babbad6998","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path\").to(\"mock:test\");\n            }\n        };\n    }","id":66663,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path\").to(\"mock:test1\");\n                \n                from(\"dropbox://get?accessToken={{accessToken}}&clientIdentifier={{clientIdentifier}}&remotePath=/path with spaces/file\").to(\"mock:test2\");\n            }\n        };\n    }","commit_id":"c6a331c2059c8f94a5a3cc46fca677babbad6998","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testFromRestModel() throws Exception {\n        super.testFromRestModel();\n\n        assertEquals(\"dummy-rest\", context.getRestConfiguration().getComponent());\n        assertEquals(\"localhost\", context.getRestConfiguration().getHost());\n        assertEquals(9090, context.getRestConfiguration().getPort());\n        assertEquals(\"bar\", context.getRestConfiguration().getProperties().get(\"foo\"));\n    }","id":66664,"modified_method":"@Test\n    public void testFromRestModel() throws Exception {\n        super.testFromRestModel();\n\n        assertEquals(\"dummy-rest\", context.getRestConfiguration().getComponent());\n        assertEquals(\"localhost\", context.getRestConfiguration().getHost());\n        assertEquals(9090, context.getRestConfiguration().getPort());\n        assertEquals(\"bar\", context.getRestConfiguration().getComponentProperties().get(\"foo\"));\n        assertEquals(\"stuff\", context.getRestConfiguration().getComponentProperties().get(\"other\"));\n        assertEquals(\"200\", context.getRestConfiguration().getEndpointProperties().get(\"size\"));\n        assertEquals(\"1000\", context.getRestConfiguration().getConsumerProperties().get(\"pollTimeout\"));\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void testFromRestModel() throws Exception {\n        super.testFromRestModel();\n\n        assertEquals(\"dummy-rest\", context.getRestConfiguration().getComponent());\n        assertEquals(\"localhost\", context.getRestConfiguration().getHost());\n        assertEquals(9090, context.getRestConfiguration().getPort());\n        assertEquals(\"bar\", context.getRestConfiguration().getProperties().get(\"foo\"));\n    }","id":66665,"modified_method":"@Override\n    public void testFromRestModel() throws Exception {\n        super.testFromRestModel();\n\n        assertEquals(\"dummy-rest\", context.getRestConfiguration().getComponent());\n        assertEquals(\"localhost\", context.getRestConfiguration().getHost());\n        assertEquals(9090, context.getRestConfiguration().getPort());\n        assertEquals(\"bar\", context.getRestConfiguration().getComponentProperties().get(\"foo\"));\n        assertEquals(\"stuff\", context.getRestConfiguration().getComponentProperties().get(\"other\"));\n        assertEquals(\"200\", context.getRestConfiguration().getEndpointProperties().get(\"size\"));\n        assertEquals(\"1000\", context.getRestConfiguration().getConsumerProperties().get(\"pollTimeout\"));\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                restConfiguration().component(\"dummy-rest\").host(\"localhost\").port(9090).property(\"foo\", \"bar\");\n\n                rest(\"/say/hello\")\n                        .get().to(\"direct:hello\");\n\n                rest(\"/say/bye\")\n                        .get().consumes(\"application/json\").to(\"direct:bye\")\n                        .post().to(\"mock:update\");\n\n                from(\"direct:hello\")\n                    .transform().constant(\"Hello World\");\n\n                from(\"direct:bye\")\n                    .transform().constant(\"Bye World\");\n            }\n        };\n    }","id":66666,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                restConfiguration().component(\"dummy-rest\").host(\"localhost\").port(9090)\n                    .componentProperty(\"foo\", \"bar\")\n                    .componentProperty(\"other\", \"stuff\")\n                    .endpointProperty(\"size\", \"200\")\n                    .consumerProperty(\"pollTimeout\", \"1000\");\n\n                rest(\"/say/hello\")\n                        .get().to(\"direct:hello\");\n\n                rest(\"/say/bye\")\n                        .get().consumes(\"application/json\").to(\"direct:bye\")\n                        .post().to(\"mock:update\");\n\n                from(\"direct:hello\")\n                    .transform().constant(\"Hello World\");\n\n                from(\"direct:bye\")\n                    .transform().constant(\"Bye World\");\n            }\n        };\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                rest(\"/hello\")\n                    .get().consumes(\"application/json\")\n                        .route()\n                        .to(\"mock:foo\")\n                        .transform().constant(\"{ \\\"reply\\\": \\\"Bye World\\\" }\");\n            }\n        };\n    }","id":66667,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                restConfiguration().component(\"spark-rest\").componentProperty(\"mapHeaders\", \"false\");\n\n                rest(\"/hello\")\n                    .get().consumes(\"application/json\")\n                        .route()\n                        .to(\"mock:foo\")\n                        .transform().constant(\"{ \\\"reply\\\": \\\"Bye World\\\" }\");\n            }\n        };\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Gets additional options to use to configure the REST consumer\n     *\n     * @return additional options\n     */\n    public Map<String, Object> getProperties() {\n        return properties;\n    }","id":66668,"modified_method":"/**\n     * Gets additional options on endpoint level\n     *\n     * @return additional options\n     */\n    public Map<String, Object> getEndpointProperties() {\n        return endpointProperties;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sets additional options to use to configure the REST consumer\n     *\n     * @param properties the options\n     */\n    public void setProperties(Map<String, Object> properties) {\n        this.properties = properties;\n    }","id":66669,"modified_method":"/**\n     * Sets additional options on endpoint level\n     *\n     * @param endpointProperties the options\n     */\n    public void setEndpointProperties(Map<String, Object> endpointProperties) {\n        this.endpointProperties = endpointProperties;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"public List<RestPropertyDefinition> getProperties() {\n        return properties;\n    }","id":66670,"modified_method":"public List<RestPropertyDefinition> getEndpointProperties() {\n        return endpointProperties;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * For additional configuration options\n     */\n    public RestConfigurationDefinition property(String key, String value) {\n        RestPropertyDefinition prop = new RestPropertyDefinition();\n        prop.setKey(key);\n        prop.setValue(value);\n        getProperties().add(prop);\n        return this;\n    }","id":66671,"modified_method":"/**\n     * For additional configuration options on consumer level\n     */\n    public RestConfigurationDefinition consumerProperty(String key, String value) {\n        RestPropertyDefinition prop = new RestPropertyDefinition();\n        prop.setKey(key);\n        prop.setValue(value);\n        getConsumerProperties().add(prop);\n        return this;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"public void setProperties(List<RestPropertyDefinition> properties) {\n        this.properties = properties;\n    }","id":66672,"modified_method":"public void setConsumerProperties(List<RestPropertyDefinition> consumerProperties) {\n        this.consumerProperties = consumerProperties;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a {@link org.apache.camel.spi.RestConfiguration} instance based on the definition\n     *\n     * @param context     the camel context\n     * @return the configuration\n     * @throws Exception is thrown if error creating the configuration\n     */\n    public RestConfiguration asRestConfiguration(CamelContext context) throws Exception {\n        RestConfiguration answer = new RestConfiguration();\n        if (component != null) {\n            answer.setComponent(CamelContextHelper.parseText(context, component));\n        }\n        if (scheme != null) {\n            answer.setScheme(CamelContextHelper.parseText(context, scheme));\n        }\n        if (host != null) {\n            answer.setHost(CamelContextHelper.parseText(context, host));\n        }\n        if (port != null) {\n            answer.setPort(CamelContextHelper.parseInteger(context, port));\n        }\n        if (!properties.isEmpty()) {\n            Map<String, Object> props = new HashMap<String, Object>();\n            for (RestPropertyDefinition prop : properties) {\n                String key = prop.getKey();\n                String value = CamelContextHelper.parseText(context, prop.getValue());\n                props.put(key, value);\n            }\n            answer.setProperties(props);\n        }\n        return answer;\n    }","id":66673,"modified_method":"/**\n     * Creates a {@link org.apache.camel.spi.RestConfiguration} instance based on the definition\n     *\n     * @param context     the camel context\n     * @return the configuration\n     * @throws Exception is thrown if error creating the configuration\n     */\n    public RestConfiguration asRestConfiguration(CamelContext context) throws Exception {\n        RestConfiguration answer = new RestConfiguration();\n        if (component != null) {\n            answer.setComponent(CamelContextHelper.parseText(context, component));\n        }\n        if (scheme != null) {\n            answer.setScheme(CamelContextHelper.parseText(context, scheme));\n        }\n        if (host != null) {\n            answer.setHost(CamelContextHelper.parseText(context, host));\n        }\n        if (port != null) {\n            answer.setPort(CamelContextHelper.parseInteger(context, port));\n        }\n        if (!componentProperties.isEmpty()) {\n            Map<String, Object> props = new HashMap<String, Object>();\n            for (RestPropertyDefinition prop : componentProperties) {\n                String key = prop.getKey();\n                String value = CamelContextHelper.parseText(context, prop.getValue());\n                props.put(key, value);\n            }\n            answer.setComponentProperties(props);\n        }\n        if (!endpointProperties.isEmpty()) {\n            Map<String, Object> props = new HashMap<String, Object>();\n            for (RestPropertyDefinition prop : endpointProperties) {\n                String key = prop.getKey();\n                String value = CamelContextHelper.parseText(context, prop.getValue());\n                props.put(key, value);\n            }\n            answer.setEndpointProperties(props);\n        }\n        if (!consumerProperties.isEmpty()) {\n            Map<String, Object> props = new HashMap<String, Object>();\n            for (RestPropertyDefinition prop : consumerProperties) {\n                String key = prop.getKey();\n                String value = CamelContextHelper.parseText(context, prop.getValue());\n                props.put(key, value);\n            }\n            answer.setConsumerProperties(props);\n        }\n        return answer;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        component.start();\n    }","id":66674,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        // configure component options\n        RestConfiguration config = getCamelContext().getRestConfiguration();\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"restle\"))) {\n            // configure additional options on spark configuration\n            if (config.getComponentProperties() != null && !config.getComponentProperties().isEmpty()) {\n                setProperties(this, config.getComponentProperties());\n            }\n        }\n\n        component.start();\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Consumer createConsumer(CamelContext camelContext, Processor processor,\n                                   String verb, String path, String consumes, Map<String, Object> parameters) throws Exception {\n\n        path = FileUtil.stripLeadingSeparator(path);\n\n        String scheme = \"http\";\n        String host = \"0.0.0.0\";\n        int port = 0;\n\n        // if no explicit port/host configured, then use port from rest configuration\n        RestConfiguration config = getCamelContext().getRestConfiguration();\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"restlet\"))) {\n            if (config.getScheme() != null) {\n                scheme = config.getScheme();\n            }\n            if (config.getHost() != null) {\n                host = config.getHost();\n            }\n            int num = config.getPort();\n            if (num > 0) {\n                port = num;\n            }\n        }\n\n        // get the endpoint\n        String url = String.format(\"restlet:%s://%s:%s/%s?restletMethod=%s\", scheme, host, port, path, verb);\n        RestletEndpoint endpoint = camelContext.getEndpoint(url, RestletEndpoint.class);\n        setProperties(endpoint, parameters);\n\n        return endpoint.createConsumer(processor);\n    }","id":66675,"modified_method":"@Override\n    public Consumer createConsumer(CamelContext camelContext, Processor processor,\n                                   String verb, String path, String consumes, Map<String, Object> parameters) throws Exception {\n\n        path = FileUtil.stripLeadingSeparator(path);\n\n        String scheme = \"http\";\n        String host = \"0.0.0.0\";\n        int port = 0;\n\n        // if no explicit port/host configured, then use port from rest configuration\n        RestConfiguration config = getCamelContext().getRestConfiguration();\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"restlet\"))) {\n            if (config.getScheme() != null) {\n                scheme = config.getScheme();\n            }\n            if (config.getHost() != null) {\n                host = config.getHost();\n            }\n            int num = config.getPort();\n            if (num > 0) {\n                port = num;\n            }\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        // build query string, and append any endpoint configuration properties\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"restlet\"))) {\n            // setup endpoint options\n            if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n                map.putAll(config.getEndpointProperties());\n            }\n        }\n\n        String query = URISupport.createQueryString(map);\n\n        String url = \"restlet:%s://%s:%s/%s?restletMethod=%s\";\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        url = String.format(url, scheme, host, port, path, verb);\n        RestletEndpoint endpoint = camelContext.getEndpoint(url, RestletEndpoint.class);\n        setProperties(endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config != null && config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(consumer, config.getConsumerProperties());\n        }\n\n        return consumer;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (getPort() != SparkBase.SPARK_DEFAULT_PORT) {\n            Spark.setPort(getPort());\n        } else {\n            // if no explicit port configured, then use port from rest configuration\n            RestConfiguration config = getCamelContext().getRestConfiguration();\n            if (config != null && (config.getComponent() == null || config.getComponent().equals(\"spark-rest\"))) {\n                int port = config.getPort();\n                if (port > 0) {\n                    Spark.setPort(port);\n                }\n            }\n        }\n    }","id":66676,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (getPort() != SparkBase.SPARK_DEFAULT_PORT) {\n            Spark.setPort(getPort());\n        } else {\n            // if no explicit port configured, then use port from rest configuration\n            RestConfiguration config = getCamelContext().getRestConfiguration();\n            if (config != null && (config.getComponent() == null || config.getComponent().equals(\"spark-rest\"))) {\n                int port = config.getPort();\n                if (port > 0) {\n                    Spark.setPort(port);\n                }\n            }\n        }\n\n        // configure component options\n        RestConfiguration config = getCamelContext().getRestConfiguration();\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"spark-rest\"))) {\n            // configure additional options on spark configuration\n            if (config.getComponentProperties() != null && !config.getComponentProperties().isEmpty()) {\n                setProperties(sparkConfiguration, config.getComponentProperties());\n            }\n        }\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Consumer createConsumer(CamelContext camelContext, Processor processor,\n                                   String verb, String path, String consumes, Map<String, Object> parameters) throws Exception {\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = pattern.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint;\n        if (consumes != null) {\n            endpoint = camelContext.getEndpoint(\"spark-rest:\" + verb + \":\" + path + \"?accept=\" + consumes, SparkEndpoint.class);\n        } else {\n            endpoint = camelContext.getEndpoint(\"spark-rest:\" + verb + \":\" + path, SparkEndpoint.class);\n        }\n        setProperties(endpoint, parameters);\n\n        return endpoint.createConsumer(processor);\n    }","id":66677,"modified_method":"@Override\n    public Consumer createConsumer(CamelContext camelContext, Processor processor,\n                                   String verb, String path, String consumes, Map<String, Object> parameters) throws Exception {\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = pattern.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        String uri = String.format(\"spark-rest:%s:%s\", verb, path);\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        if (consumes != null) {\n            map.put(\"accept\", consumes);\n        }\n\n        // build query string, and append any endpoint configuration properties\n        RestConfiguration config = getCamelContext().getRestConfiguration();\n        if (config != null && (config.getComponent() == null || config.getComponent().equals(\"spark-rest\"))) {\n            // setup endpoint options\n            if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n                map.putAll(config.getEndpointProperties());\n            }\n        }\n\n        String query = URISupport.createQueryString(map);\n\n        String url = uri;\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint = camelContext.getEndpoint(url, SparkEndpoint.class);\n        setProperties(endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config != null && config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(consumer, config.getConsumerProperties());\n        }\n\n        return consumer;\n    }","commit_id":"51a8b37ffaf6dd0766c0e18c2079f3c2aca490e1","url":"https://github.com/apache/camel"},{"original_method":"public static PsiMethod substituteGenericMethod(PsiMethod method, PsiSubstitutor substitutor) {\n    Project project = method.getProject();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(method.getProject()).getElementFactory();\n    boolean isRaw = PsiUtil.isRawSubstitutor(method, substitutor);\n\n    PsiTypeParameter[] typeParams = method.getTypeParameters();\n    try {\n      PsiType returnType = method.getReturnType();\n\n      PsiMethod newMethod;\n      if (method.isConstructor()) {\n        newMethod = factory.createConstructor();\n        newMethod.getNameIdentifier().replace(factory.createIdentifier(method.getName()));\n      }\n      else {\n        newMethod = factory.createMethod(method.getName(), substituteType(substitutor, returnType, isRaw));\n      }\n\n      RefactoringUtil.setVisibility(newMethod.getModifierList(), VisibilityUtil.getVisibilityModifier(method.getModifierList()));\n\n      PsiDocComment docComment = ((PsiMethod)method.getNavigationElement()).getDocComment();\n      if (docComment != null) {\n        newMethod.addAfter(docComment, null);\n      }\n\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n      Map<PsiType,Pair<String,Integer>> m = new HashMap<PsiType, Pair<String,Integer>>();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        final PsiType parameterType = parameter.getType();\n        PsiType substituted = substituteType(substitutor, parameterType, isRaw);\n        @NonNls String paramName = parameter.getName();\n        final String[] baseSuggestions = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, parameterType).names;\n        boolean isBaseNameGenerated = false;\n        for (String s : baseSuggestions) {\n          if (s.equals(paramName)) {\n            isBaseNameGenerated = true;\n            break;\n          }\n        }\n        \n        if (paramName == null || isBaseNameGenerated && !substituted.equals(parameterType)) {\n          Pair<String, Integer> pair = m.get(substituted);\n          if (pair != null) {\n            paramName = pair.first + pair.second;\n            m.put(substituted, Pair.create(pair.first, pair.second.intValue() + 1));\n          }\n          else {\n            String[] names = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, substituted).names;\n            if (names.length > 0) {\n              paramName = names[0];\n            } else paramName = \"p\" + i;\n\n            m.put(substituted, new Pair<String, Integer>(paramName, 1));\n          }\n        }\n\n        if (paramName == null) paramName = \"p\" + i;\n\n        PsiParameter newParameter = factory.createParameter(paramName, substituted);\n        if (parameter.getLanguage() == StdLanguages.JAVA) {\n          newParameter.getModifierList().replace(parameter.getModifierList());\n        }\n        newMethod.getParameterList().add(newParameter);\n      }\n\n      for (PsiTypeParameter typeParam : typeParams) {\n        if (substitutor.substitute(typeParam) != null) newMethod.getTypeParameterList().add(typeParam);\n      }\n\n      PsiClassType[] thrownTypes = method.getThrowsList().getReferencedTypes();\n      for (PsiClassType thrownType : thrownTypes) {\n        newMethod.getThrowsList().add(factory.createReferenceElementByType((PsiClassType)substituteType(substitutor, thrownType, isRaw)));\n      }\n      return newMethod;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return method;\n    }\n  }","id":66678,"modified_method":"public static PsiMethod substituteGenericMethod(PsiMethod method, PsiSubstitutor substitutor) {\n    Project project = method.getProject();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(method.getProject()).getElementFactory();\n\n    PsiTypeParameter[] typeParams = method.getTypeParameters();\n    try {\n      PsiType returnType = method.getReturnType();\n\n      PsiMethod newMethod;\n      if (method.isConstructor()) {\n        newMethod = factory.createConstructor();\n        newMethod.getNameIdentifier().replace(factory.createIdentifier(method.getName()));\n      }\n      else {\n        newMethod = factory.createMethod(method.getName(), substituteType(substitutor, returnType));\n      }\n\n      RefactoringUtil.setVisibility(newMethod.getModifierList(), VisibilityUtil.getVisibilityModifier(method.getModifierList()));\n\n      PsiDocComment docComment = ((PsiMethod)method.getNavigationElement()).getDocComment();\n      if (docComment != null) {\n        newMethod.addAfter(docComment, null);\n      }\n\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n      Map<PsiType,Pair<String,Integer>> m = new HashMap<PsiType, Pair<String,Integer>>();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        final PsiType parameterType = parameter.getType();\n        PsiType substituted = substituteType(substitutor, parameterType);\n        @NonNls String paramName = parameter.getName();\n        final String[] baseSuggestions = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, parameterType).names;\n        boolean isBaseNameGenerated = false;\n        for (String s : baseSuggestions) {\n          if (s.equals(paramName)) {\n            isBaseNameGenerated = true;\n            break;\n          }\n        }\n        \n        if (paramName == null || isBaseNameGenerated && !substituted.equals(parameterType)) {\n          Pair<String, Integer> pair = m.get(substituted);\n          if (pair != null) {\n            paramName = pair.first + pair.second;\n            m.put(substituted, Pair.create(pair.first, pair.second.intValue() + 1));\n          }\n          else {\n            String[] names = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, substituted).names;\n            if (names.length > 0) {\n              paramName = names[0];\n            } else paramName = \"p\" + i;\n\n            m.put(substituted, new Pair<String, Integer>(paramName, 1));\n          }\n        }\n\n        if (paramName == null) paramName = \"p\" + i;\n\n        PsiParameter newParameter = factory.createParameter(paramName, substituted);\n        if (parameter.getLanguage() == StdLanguages.JAVA) {\n          newParameter.getModifierList().replace(parameter.getModifierList());\n        }\n        newMethod.getParameterList().add(newParameter);\n      }\n\n      for (PsiTypeParameter typeParam : typeParams) {\n        if (substitutor.substitute(typeParam) != null) newMethod.getTypeParameterList().add(typeParam);\n      }\n\n      PsiClassType[] thrownTypes = method.getThrowsList().getReferencedTypes();\n      for (PsiClassType thrownType : thrownTypes) {\n        newMethod.getThrowsList().add(factory.createReferenceElementByType((PsiClassType)substituteType(substitutor, thrownType)));\n      }\n      return newMethod;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return method;\n    }\n  }","commit_id":"c835a56638230101cace1324ca51f43c4428a07d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiType substituteType(final PsiSubstitutor substitutor, final PsiType type, final boolean isRaw) {\n    return isRaw ? TypeConversionUtil.erasure(type) : substitutor.substitute(type);\n  }","id":66679,"modified_method":"private static PsiType substituteType(final PsiSubstitutor substitutor, final PsiType type) {\n    final PsiType psiType = substitutor.substitute(type);\n    if (psiType != null) return psiType;\n    return TypeConversionUtil.erasure(type);\n  }","commit_id":"c835a56638230101cace1324ca51f43c4428a07d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isCorrectOwnerForEnumMember(@NotNull ClassOrNamespaceDescriptor ownerDescriptor, @NotNull JavaMember member) {\n        return isEnumClassObject(ownerDescriptor) == shouldBeInEnumClassObject(member.getPsi());\n    }","id":66680,"modified_method":"public static boolean isCorrectOwnerForEnumMember(@NotNull ClassOrNamespaceDescriptor ownerDescriptor, @NotNull JavaMember member) {\n        return isEnumClassObject(ownerDescriptor) == shouldBeInEnumClassObject(member);\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @return true if {@code member} is a static member of enum class, which is to be put into its class object (and not into the\n     *         corresponding package). This applies to enum entries, values() and valueOf(String) methods\n     */\n    public static boolean shouldBeInEnumClassObject(@NotNull PsiMember member) {\n        PsiClass psiClass = member.getContainingClass();\n        if (psiClass == null || !psiClass.isEnum()) return false;\n\n        if (member instanceof PsiEnumConstant) return true;\n\n        if (!(member instanceof PsiMethod)) return false;\n        String signature = PsiFormatUtil.formatMethod((PsiMethod) member,\n                                                      PsiSubstitutor.EMPTY, SHOW_NAME | SHOW_PARAMETERS, SHOW_TYPE | SHOW_FQ_CLASS_NAMES);\n\n        return \"values()\".equals(signature) ||\n               \"valueOf(java.lang.String)\".equals(signature);\n    }","id":66681,"modified_method":"/**\n     * @return true if {@code member} is a static member of enum class, which is to be put into its class object (and not into the\n     *         corresponding package). This applies to enum entries, values() and valueOf(String) methods\n     */\n    public static boolean shouldBeInEnumClassObject(@NotNull JavaMember member) {\n        JavaClass javaClass = member.getContainingClass();\n        if (javaClass == null || !javaClass.isEnum()) return false;\n\n        if (member instanceof JavaField && ((JavaField) member).isEnumEntry()) return true;\n\n        if (!(member instanceof JavaMethod)) return false;\n        String signature = PsiFormatUtil.formatMethod(((JavaMethod) member).getPsi(), PsiSubstitutor.EMPTY, SHOW_NAME | SHOW_PARAMETERS,\n                                                      SHOW_TYPE | SHOW_FQ_CLASS_NAMES);\n\n        return \"values()\".equals(signature) ||\n               \"valueOf(java.lang.String)\".equals(signature);\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private SimpleFunctionDescriptor resolveMethodToFunctionDescriptor(\n            @NotNull JavaMethod method,\n            @NotNull ClassOrNamespaceDescriptor ownerDescriptor,\n            boolean record\n    ) {\n        if (!DescriptorResolverUtils.isCorrectOwnerForEnumMember(ownerDescriptor, method)) {\n            return null;\n        }\n\n        JavaType returnJavaType = method.getReturnType();\n        if (returnJavaType == null) {\n            // This means that the method is a constructor\n            return null;\n        }\n\n        PsiMethod psiMethod = method.getPsi();\n\n        SimpleFunctionDescriptor alreadyResolved = trace.get(BindingContext.FUNCTION, psiMethod);\n        if (alreadyResolved != null) {\n            return alreadyResolved;\n        }\n\n        SimpleFunctionDescriptorImpl functionDescriptorImpl = new SimpleFunctionDescriptorImpl(\n                ownerDescriptor,\n                annotationResolver.resolveAnnotations(method),\n                method.getName(),\n                CallableMemberDescriptor.Kind.DECLARATION\n        );\n\n        JavaTypeParameterResolver.Initializer typeParameterInitializer = typeParameterResolver.resolveTypeParameters(functionDescriptorImpl, method);\n        typeParameterInitializer.initialize();\n        List<TypeParameterDescriptor> methodTypeParameters = typeParameterInitializer.getDescriptors();\n\n        TypeVariableResolver typeVariableResolver = new TypeVariableResolver(methodTypeParameters, functionDescriptorImpl);\n\n        JavaValueParameterResolver.ValueParameters valueParameters = valueParameterResolver\n                .resolveValueParameters(functionDescriptorImpl, method, typeVariableResolver);\n        JetType returnType = makeReturnType(returnJavaType, method, typeVariableResolver);\n\n        List<String> signatureErrors = Lists.newArrayList();\n\n        List<FunctionDescriptor> superFunctions;\n        if (ownerDescriptor instanceof ClassDescriptor) {\n            SignaturesPropagationData signaturesPropagationData = new SignaturesPropagationData(\n                    (ClassDescriptor) ownerDescriptor, returnType, valueParameters, methodTypeParameters, method, trace);\n            superFunctions = signaturesPropagationData.getSuperFunctions();\n\n            returnType = signaturesPropagationData.getModifiedReturnType();\n            valueParameters = signaturesPropagationData.getModifiedValueParameters();\n            methodTypeParameters = signaturesPropagationData.getModifiedTypeParameters();\n\n            signatureErrors.addAll(signaturesPropagationData.getSignatureErrors());\n        }\n        else {\n            superFunctions = Collections.emptyList();\n        }\n\n        AlternativeMethodSignatureData alternativeMethodSignatureData =\n                new AlternativeMethodSignatureData(method, valueParameters, returnType, methodTypeParameters,\n                                                   !superFunctions.isEmpty());\n        if (alternativeMethodSignatureData.isAnnotated() && !alternativeMethodSignatureData.hasErrors()) {\n            valueParameters = alternativeMethodSignatureData.getValueParameters();\n            returnType = alternativeMethodSignatureData.getReturnType();\n            methodTypeParameters = alternativeMethodSignatureData.getTypeParameters();\n        }\n        else if (alternativeMethodSignatureData.hasErrors()) {\n            signatureErrors.add(alternativeMethodSignatureData.getError());\n        }\n\n        functionDescriptorImpl.initialize(\n                valueParameters.getReceiverType(),\n                DescriptorUtils.getExpectedThisObjectIfNeeded(ownerDescriptor),\n                methodTypeParameters,\n                valueParameters.getDescriptors(),\n                returnType,\n                Modality.convertFromFlags(method.isAbstract(), !method.isFinal()),\n                method.getVisibility(),\n                /*isInline = */ false\n        );\n\n        if (functionDescriptorImpl.getKind() == CallableMemberDescriptor.Kind.DECLARATION && record) {\n            BindingContextUtils.recordFunctionDeclarationToDescriptor(trace, psiMethod, functionDescriptorImpl);\n        }\n\n        if (record) {\n            trace.record(JavaBindingContext.IS_DECLARED_IN_JAVA, functionDescriptorImpl);\n        }\n\n        if (!RawTypesCheck.hasRawTypesInHierarchicalSignature(psiMethod)\n            && JavaMethodSignatureUtil.isMethodReturnTypeCompatible(psiMethod)\n            && !containsErrorType(superFunctions, functionDescriptorImpl)) {\n            if (signatureErrors.isEmpty()) {\n                checkFunctionsOverrideCorrectly(method, superFunctions, functionDescriptorImpl);\n            }\n            else {\n                if (record) {\n                    trace.record(JavaBindingContext.LOAD_FROM_JAVA_SIGNATURE_ERRORS, functionDescriptorImpl, signatureErrors);\n                }\n            }\n        }\n\n        return functionDescriptorImpl;\n    }","id":66682,"modified_method":"@Nullable\n    private SimpleFunctionDescriptor resolveMethodToFunctionDescriptor(\n            @NotNull JavaMethod method,\n            @NotNull ClassOrNamespaceDescriptor ownerDescriptor,\n            boolean record\n    ) {\n        if (!DescriptorResolverUtils.isCorrectOwnerForEnumMember(ownerDescriptor, method)) {\n            return null;\n        }\n\n        JavaType returnJavaType = method.getReturnType();\n        if (returnJavaType == null) {\n            // This means that the method is a constructor\n            return null;\n        }\n\n        SimpleFunctionDescriptor alreadyResolved = trace.get(BindingContext.FUNCTION, method.getPsi());\n        if (alreadyResolved != null) {\n            return alreadyResolved;\n        }\n\n        SimpleFunctionDescriptorImpl functionDescriptorImpl = new SimpleFunctionDescriptorImpl(\n                ownerDescriptor,\n                annotationResolver.resolveAnnotations(method),\n                method.getName(),\n                CallableMemberDescriptor.Kind.DECLARATION\n        );\n\n        JavaTypeParameterResolver.Initializer typeParameterInitializer = typeParameterResolver.resolveTypeParameters(functionDescriptorImpl, method);\n        typeParameterInitializer.initialize();\n        List<TypeParameterDescriptor> methodTypeParameters = typeParameterInitializer.getDescriptors();\n\n        TypeVariableResolver typeVariableResolver = new TypeVariableResolver(methodTypeParameters, functionDescriptorImpl);\n\n        JavaValueParameterResolver.ValueParameters valueParameters = valueParameterResolver\n                .resolveValueParameters(functionDescriptorImpl, method, typeVariableResolver);\n        JetType returnType = makeReturnType(returnJavaType, method, typeVariableResolver);\n\n        List<String> signatureErrors = Lists.newArrayList();\n\n        List<FunctionDescriptor> superFunctions;\n        if (ownerDescriptor instanceof ClassDescriptor) {\n            SignaturesPropagationData signaturesPropagationData = new SignaturesPropagationData(\n                    (ClassDescriptor) ownerDescriptor, returnType, valueParameters, methodTypeParameters, method, trace);\n            superFunctions = signaturesPropagationData.getSuperFunctions();\n\n            returnType = signaturesPropagationData.getModifiedReturnType();\n            valueParameters = signaturesPropagationData.getModifiedValueParameters();\n            methodTypeParameters = signaturesPropagationData.getModifiedTypeParameters();\n\n            signatureErrors.addAll(signaturesPropagationData.getSignatureErrors());\n        }\n        else {\n            superFunctions = Collections.emptyList();\n        }\n\n        AlternativeMethodSignatureData alternativeMethodSignatureData =\n                new AlternativeMethodSignatureData(method, valueParameters, returnType, methodTypeParameters,\n                                                   !superFunctions.isEmpty());\n        if (alternativeMethodSignatureData.isAnnotated() && !alternativeMethodSignatureData.hasErrors()) {\n            valueParameters = alternativeMethodSignatureData.getValueParameters();\n            returnType = alternativeMethodSignatureData.getReturnType();\n            methodTypeParameters = alternativeMethodSignatureData.getTypeParameters();\n        }\n        else if (alternativeMethodSignatureData.hasErrors()) {\n            signatureErrors.add(alternativeMethodSignatureData.getError());\n        }\n\n        functionDescriptorImpl.initialize(\n                valueParameters.getReceiverType(),\n                DescriptorUtils.getExpectedThisObjectIfNeeded(ownerDescriptor),\n                methodTypeParameters,\n                valueParameters.getDescriptors(),\n                returnType,\n                Modality.convertFromFlags(method.isAbstract(), !method.isFinal()),\n                method.getVisibility(),\n                /*isInline = */ false\n        );\n\n        if (functionDescriptorImpl.getKind() == CallableMemberDescriptor.Kind.DECLARATION && record) {\n            BindingContextUtils.recordFunctionDeclarationToDescriptor(trace, method.getPsi(), functionDescriptorImpl);\n        }\n\n        if (record) {\n            trace.record(JavaBindingContext.IS_DECLARED_IN_JAVA, functionDescriptorImpl);\n        }\n\n        if (!RawTypesCheck.hasRawTypesInHierarchicalSignature(method)\n            && JavaMethodSignatureUtil.isMethodReturnTypeCompatible(method)\n            && !containsErrorType(superFunctions, functionDescriptorImpl)) {\n            if (signatureErrors.isEmpty()) {\n                checkFunctionsOverrideCorrectly(method, superFunctions, functionDescriptorImpl);\n            }\n            else {\n                if (record) {\n                    trace.record(JavaBindingContext.LOAD_FROM_JAVA_SIGNATURE_ERRORS, functionDescriptorImpl, signatureErrors);\n                }\n            }\n        }\n\n        return functionDescriptorImpl;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"static boolean isMethodReturnTypeCompatible(@NotNull PsiMethod method) {\n        if (method.hasModifierProperty(PsiModifier.STATIC)) return true;\n        HierarchicalMethodSignature methodSignature = method.getHierarchicalMethodSignature();\n        List<HierarchicalMethodSignature> superSignatures = methodSignature.getSuperSignatures();\n\n        PsiType returnType = methodSignature.getSubstitutor().substitute(method.getReturnType());\n        PsiClass aClass = method.getContainingClass();\n        if (aClass == null) return false;\n        for (MethodSignatureBackedByPsiMethod superMethodSignature : superSignatures) {\n            PsiMethod superMethod = superMethodSignature.getMethod();\n            PsiType declaredReturnType = superMethod.getReturnType();\n            PsiType superReturnType = declaredReturnType;\n            if (superMethodSignature.isRaw()) superReturnType = TypeConversionUtil.erasure(declaredReturnType);\n            if (returnType == null || superReturnType == null || method == superMethod) continue;\n            PsiClass superClass = superMethod.getContainingClass();\n            if (superClass == null) continue;\n            if (!areMethodsReturnTypesCompatible(superMethodSignature, superReturnType, method, methodSignature, returnType)) return false;\n        }\n\n        return true;\n    }","id":66683,"modified_method":"static boolean isMethodReturnTypeCompatible(@NotNull JavaMethod method) {\n        if (method.isStatic()) return true;\n        if (method.getContainingClass() == null) return false;\n\n        HierarchicalMethodSignature methodSignature = method.getPsi().getHierarchicalMethodSignature();\n        List<HierarchicalMethodSignature> superSignatures = methodSignature.getSuperSignatures();\n\n        PsiType returnType = methodSignature.getSubstitutor().substitute(method.getPsi().getReturnType());\n        if (returnType == null) return true;\n\n        for (MethodSignatureBackedByPsiMethod superMethodSignature : superSignatures) {\n            PsiMethod superMethod = superMethodSignature.getMethod();\n            PsiType declaredReturnType = superMethod.getReturnType();\n            PsiType superReturnType = superMethodSignature.isRaw() ? TypeConversionUtil.erasure(declaredReturnType) : declaredReturnType;\n            if (superReturnType == null || method == superMethod || superMethod.getContainingClass() == null) continue;\n            if (!areMethodsReturnTypesCompatible(superMethodSignature, superReturnType, methodSignature, returnType)) {\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean areMethodsReturnTypesCompatible(\n            MethodSignatureBackedByPsiMethod superMethodSignature,\n            PsiType superReturnType,\n            PsiMethod method,\n            MethodSignatureBackedByPsiMethod methodSignature,\n            PsiType returnType\n    ) {\n        if (superReturnType == null) return false;\n        PsiType substitutedSuperReturnType;\n        boolean isJdk15 = PsiUtil.isLanguageLevel5OrHigher(method);\n        if (isJdk15 && !superMethodSignature.isRaw() && superMethodSignature.equals(methodSignature)) { //see 8.4.5\n            PsiSubstitutor unifyingSubstitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(methodSignature,\n                                                                                                        superMethodSignature);\n            substitutedSuperReturnType = unifyingSubstitutor == null\n                                         ? superReturnType\n                                         : unifyingSubstitutor.substitute(superReturnType);\n        }\n        else {\n            substitutedSuperReturnType = TypeConversionUtil.erasure(superMethodSignature.getSubstitutor().substitute(superReturnType));\n        }\n\n        if (returnType.equals(substitutedSuperReturnType)) return true;\n        if (!(returnType instanceof PsiPrimitiveType) && substitutedSuperReturnType.getDeepComponentType() instanceof PsiClassType) {\n            if (isJdk15 && TypeConversionUtil.isAssignable(substitutedSuperReturnType, returnType)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":66684,"modified_method":"private static boolean areMethodsReturnTypesCompatible(\n            @NotNull MethodSignatureBackedByPsiMethod superMethodSignature,\n            @NotNull PsiType superReturnType,\n            @NotNull MethodSignatureBackedByPsiMethod methodSignature,\n            @NotNull PsiType returnType\n    ) {\n        PsiType substitutedSuperReturnType;\n        boolean isJdk15 = PsiUtil.isLanguageLevel5OrHigher(methodSignature.getMethod());\n        if (isJdk15 && !superMethodSignature.isRaw() && superMethodSignature.equals(methodSignature)) { //see 8.4.5\n            PsiSubstitutor unifyingSubstitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(methodSignature,\n                                                                                                        superMethodSignature);\n            substitutedSuperReturnType = unifyingSubstitutor == null\n                                         ? superReturnType\n                                         : unifyingSubstitutor.substitute(superReturnType);\n        }\n        else {\n            substitutedSuperReturnType = TypeConversionUtil.erasure(superMethodSignature.getSubstitutor().substitute(superReturnType));\n        }\n\n        if (returnType.equals(substitutedSuperReturnType)) return true;\n        if (!(returnType instanceof PsiPrimitiveType) && substitutedSuperReturnType.getDeepComponentType() instanceof PsiClassType) {\n            if (isJdk15 && TypeConversionUtil.isAssignable(substitutedSuperReturnType, returnType)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private JetScope doCreateNamespaceScope(\n            @NotNull FqName fqName,\n            @NotNull NamespaceDescriptor namespaceDescriptor,\n            boolean record\n    ) {\n        JavaPackage javaPackage = javaClassFinder.findPackage(fqName);\n        if (javaPackage != null) {\n            FqName packageClassFqName = PackageClassUtils.getPackageClassFqName(fqName);\n            VirtualFile virtualFile = virtualFileFinder.find(packageClassFqName);\n\n            trace.record(JavaBindingContext.JAVA_NAMESPACE_KIND, namespaceDescriptor, JavaNamespaceKind.PROPER);\n\n            if (virtualFile != null) {\n                ErrorReporter errorReporter = AbiVersionUtil.abiVersionErrorReporter(virtualFile, packageClassFqName, trace);\n                JetScope kotlinPackageScope = deserializedDescriptorResolver.createKotlinPackageScope(namespaceDescriptor,\n                                                                                                      virtualFile, errorReporter);\n                if (kotlinPackageScope != null) {\n                    return kotlinPackageScope;\n                }\n            }\n\n\n            // Otherwise (if psiClass is null or doesn't have a supported Kotlin annotation), it's a Java class and the package is empty\n            if (record) {\n                trace.record(BindingContext.NAMESPACE, javaPackage.getPsi(), namespaceDescriptor);\n            }\n\n            return new JavaPackageScope(namespaceDescriptor, javaPackage, fqName, javaDescriptorResolver);\n        }\n\n        JavaClass javaClass = javaClassFinder.findClass(fqName);\n        if (javaClass == null) {\n            return null;\n        }\n\n        PsiClass psiClass = javaClass.getPsi();\n        if (DescriptorResolverUtils.isCompiledKotlinClassOrPackageClass(psiClass)) {\n            return null;\n        }\n        if (!hasStaticMembers(psiClass)) {\n            return null;\n        }\n\n        trace.record(JavaBindingContext.JAVA_NAMESPACE_KIND, namespaceDescriptor, JavaNamespaceKind.CLASS_STATICS);\n\n        if (record) {\n            trace.record(BindingContext.NAMESPACE, psiClass, namespaceDescriptor);\n        }\n\n        return new JavaClassStaticMembersScope(namespaceDescriptor, fqName, javaClass, javaDescriptorResolver);\n    }","id":66685,"modified_method":"@Nullable\n    private JetScope doCreateNamespaceScope(\n            @NotNull FqName fqName,\n            @NotNull NamespaceDescriptor namespaceDescriptor,\n            boolean record\n    ) {\n        JavaPackage javaPackage = javaClassFinder.findPackage(fqName);\n        if (javaPackage != null) {\n            FqName packageClassFqName = PackageClassUtils.getPackageClassFqName(fqName);\n            VirtualFile virtualFile = virtualFileFinder.find(packageClassFqName);\n\n            trace.record(JavaBindingContext.JAVA_NAMESPACE_KIND, namespaceDescriptor, JavaNamespaceKind.PROPER);\n\n            if (virtualFile != null) {\n                ErrorReporter errorReporter = AbiVersionUtil.abiVersionErrorReporter(virtualFile, packageClassFqName, trace);\n                JetScope kotlinPackageScope = deserializedDescriptorResolver.createKotlinPackageScope(namespaceDescriptor,\n                                                                                                      virtualFile, errorReporter);\n                if (kotlinPackageScope != null) {\n                    return kotlinPackageScope;\n                }\n            }\n\n\n            // Otherwise (if psiClass is null or doesn't have a supported Kotlin annotation), it's a Java class and the package is empty\n            if (record) {\n                trace.record(BindingContext.NAMESPACE, javaPackage.getPsi(), namespaceDescriptor);\n            }\n\n            return new JavaPackageScope(namespaceDescriptor, javaPackage, fqName, javaDescriptorResolver);\n        }\n\n        JavaClass javaClass = javaClassFinder.findClass(fqName);\n        if (javaClass == null) {\n            return null;\n        }\n\n        if (DescriptorResolverUtils.isCompiledKotlinClassOrPackageClass(javaClass.getPsi())) {\n            return null;\n        }\n        if (!hasStaticMembers(javaClass)) {\n            return null;\n        }\n\n        trace.record(JavaBindingContext.JAVA_NAMESPACE_KIND, namespaceDescriptor, JavaNamespaceKind.CLASS_STATICS);\n\n        if (record) {\n            trace.record(BindingContext.NAMESPACE, javaClass.getPsi(), namespaceDescriptor);\n        }\n\n        return new JavaClassStaticMembersScope(namespaceDescriptor, fqName, javaClass, javaDescriptorResolver);\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public JetScope getJavaPackageScopeForExistingNamespaceDescriptor(@NotNull NamespaceDescriptor namespaceDescriptor) {\n        FqName fqName = DescriptorUtils.getFQName(namespaceDescriptor).toSafe();\n        if (unresolvedCache.contains(fqName)) {\n            throw new IllegalStateException(\n                    \"This means that we are trying to create a Java package, but have a package with the same FQN defined in Kotlin: \" +\n                    fqName);\n        }\n        JetScope alreadyResolvedScope = resolvedNamespaceCache.get(fqName);\n        if (alreadyResolvedScope != null) {\n            return alreadyResolvedScope;\n        }\n        return createNamespaceScope(fqName, namespaceDescriptor, false);\n    }","id":66686,"modified_method":"private static boolean hasStaticMembers(@NotNull JavaClass javaClass) {\n        for (JavaMethod method : javaClass.getMethods()) {\n            if (method.isStatic() && !DescriptorResolverUtils.shouldBeInEnumClassObject(method)) {\n                return true;\n            }\n        }\n\n        for (JavaField field : javaClass.getFields()) {\n            if (field.isStatic() && !DescriptorResolverUtils.shouldBeInEnumClassObject(field)) {\n                return true;\n            }\n        }\n\n        for (JavaClass nestedClass : javaClass.getInnerClasses()) {\n            if (SingleAbstractMethodUtils.isSamInterface(nestedClass)) {\n                return true;\n            }\n            if (nestedClass.isStatic() && hasStaticMembers(nestedClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean typeParameterIsErased(@NotNull PsiMethod a, @NotNull PsiMethod b) {\n        // Java allows you to write\n        //   <T extends Foo> T foo(), in the superclass and then\n        //   Foo foo(), in the subclass\n        // this is a valid Java override, but in fact it is an erasure\n        return a.getTypeParameters().length != b.getTypeParameters().length;\n    }","id":66687,"modified_method":"private static boolean typeParameterIsErased(@NotNull JavaMethod method, @NotNull JavaMethod superMethod) {\n        // Java allows you to write\n        //   <T extends Foo> T foo(), in the superclass and then\n        //   Foo foo(), in the subclass\n        // this is a valid Java override, but in fact it is an erasure\n        return method.getTypeParameters().size() != superMethod.getTypeParameters().size();\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean hasRawTypesInSignature(@NotNull PsiMethod method) {\n        PsiType returnType = method.getReturnType();\n        if (returnType != null && isPartiallyRawType(returnType)) {\n            return true;\n        }\n\n        for (PsiParameter parameter : method.getParameterList().getParameters()) {\n            if (isPartiallyRawType(parameter.getType())) {\n                return true;\n            }\n        }\n\n        for (PsiTypeParameter typeParameter : method.getTypeParameters()) {\n            for (PsiClassType upperBound : typeParameter.getExtendsList().getReferencedTypes()) {\n                if (isPartiallyRawType(upperBound)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","id":66688,"modified_method":"private static boolean hasRawTypesInSignature(@NotNull JavaMethod method) {\n        JavaType returnType = method.getReturnType();\n        if (returnType != null && isPartiallyRawType(returnType)) {\n            return true;\n        }\n\n        for (JavaValueParameter parameter : method.getValueParameters()) {\n            if (isPartiallyRawType(parameter.getType())) {\n                return true;\n            }\n        }\n\n        for (JavaTypeParameter typeParameter : method.getTypeParameters()) {\n            for (JavaClassifierType upperBound : typeParameter.getUpperBounds()) {\n                if (isPartiallyRawType(upperBound)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"static boolean hasRawTypesInHierarchicalSignature(@NotNull PsiMethod method) {\n        // This is a very important optimization: package-classes are big and full of static methods\n        // building method hierarchies for such classes takes a very long time\n        if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n\n        if (hasRawTypesInSignature(method)) {\n            return true;\n        }\n\n        for (HierarchicalMethodSignature superSignature : method.getHierarchicalMethodSignature().getSuperSignatures()) {\n            PsiMethod superMethod = superSignature.getMethod();\n            if (superSignature.isRaw() || typeParameterIsErased(method, superMethod) || hasRawTypesInSignature(superMethod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":66689,"modified_method":"static boolean hasRawTypesInHierarchicalSignature(@NotNull JavaMethod method) {\n        // This is a very important optimization: package-classes are big and full of static methods\n        // building method hierarchies for such classes takes a very long time\n        if (method.isStatic()) return false;\n\n        if (hasRawTypesInSignature(method)) {\n            return true;\n        }\n\n        for (HierarchicalMethodSignature superSignature : method.getPsi().getHierarchicalMethodSignature().getSuperSignatures()) {\n            JavaMethod superMethod = new JavaMethod(superSignature.getMethod());\n            if (superSignature.isRaw() || typeParameterIsErased(method, superMethod) || hasRawTypesInSignature(superMethod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean isPartiallyRawType(@NotNull PsiType type) {\n        return type.accept(new PsiTypeVisitor<Boolean>() {\n            @Nullable\n            @Override\n            public Boolean visitPrimitiveType(PsiPrimitiveType primitiveType) {\n                return false;\n            }\n\n            @Nullable\n            @Override\n            public Boolean visitClassType(PsiClassType classType) {\n                if (classType.isRaw()) {\n                    return true;\n                }\n\n                for (PsiType argument : classType.getParameters()) {\n                    if (argument.accept(this)) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            @Nullable\n            @Override\n            public Boolean visitArrayType(PsiArrayType arrayType) {\n                return arrayType.getComponentType().accept(this);\n            }\n\n            @Nullable\n            @Override\n            public Boolean visitWildcardType(PsiWildcardType wildcardType) {\n                PsiType bound = wildcardType.getBound();\n                return bound == null ? false : bound.accept(this);\n            }\n\n            @Nullable\n            @Override\n            public Boolean visitType(PsiType type) {\n                throw new IllegalStateException(type.getClass().getSimpleName() + \" is unexpected\");\n            }\n        });\n    }","id":66690,"modified_method":"private static boolean isPartiallyRawType(@NotNull JavaType type) {\n        if (type instanceof JavaPrimitiveType) {\n            return false;\n        }\n        else if (type instanceof JavaClassifierType) {\n            JavaClassifierType classifierType = (JavaClassifierType) type;\n\n            if (classifierType.isRaw()) {\n                return true;\n            }\n\n            for (JavaType argument : classifierType.getTypeArguments()) {\n                if (isPartiallyRawType(argument)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n        else if (type instanceof JavaArrayType) {\n            return isPartiallyRawType(((JavaArrayType) type).getComponentType());\n        }\n        else if (type instanceof JavaWildcardType) {\n            JavaType bound = ((JavaWildcardType) type).getBound();\n            return bound != null && isPartiallyRawType(bound);\n        }\n        else {\n            throw new IllegalStateException(\"Unexpected type: \" + type);\n        }\n    }","commit_id":"34a552abfc39da47c264d691205268221e770e58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ExtractMethodInfoHelper(VariableInfo[] inputInfos,\n                                 VariableInfo outputInfo,\n                                 PsiElement[] innerElements,\n                                 GrStatement[] statements,\n                                 GrMemberOwner targetClass,\n                                 boolean isStatic,\n                                 boolean isReturnStatement) {\n    myInnerElements = innerElements;\n    myStatements = statements;\n    myTargetClass = targetClass;\n    myIsStatic = isStatic;\n    myIsReturnStatement = isReturnStatement;\n    myVisibility = PsiModifier.PRIVATE;\n    assert myStatements.length > 0;\n    myProject = myStatements[0].getProject();\n    int i = 0;\n    for (VariableInfo info : inputInfos) {\n      PsiType type = info.getType();\n      ParameterInfo pInfo = new ParameterInfo(info.getName(), i, type);\n      myInputNamesMap.put(info.getName(), pInfo);\n      i++;\n    }\n\n    if (outputInfo != null) {\n      myOutputName = outputInfo.getName();\n      PsiType type = outputInfo.getType();\n      if (type == null) myOutputType = PsiType.VOID;\n      else myOutputType = type;\n    } else {\n      myOutputName = null;\n      if (ExtractMethodUtil.isSingleExpression(statements) ||\n          statements.length == 1 && statements[0] instanceof GrExpression &&\n              !(statements[0] instanceof GrAssignmentExpression)) {\n        PsiType type = ((GrExpression) statements[0]).getType();\n        if (type != null) {\n          myOutputType = TypeConversionUtil.erasure(type);\n        } else {\n          myOutputType = PsiType.VOID;\n        }\n      } else {\n        PsiType returnType = referTypeFromContext(myStatements);\n        myOutputType = returnType == null ? PsiType.VOID : returnType;\n      }\n    }\n    mySpecifyType = !(PsiType.VOID.equals(myOutputType) || myOutputType.equalsToText(\"java.lang.Object\"));\n  }","id":66691,"modified_method":"public ExtractMethodInfoHelper(VariableInfo[] inputInfos,\n                                 VariableInfo outputInfo,\n                                 PsiElement[] innerElements,\n                                 GrStatement[] statements,\n                                 GrMemberOwner targetClass,\n                                 boolean isStatic,\n                                 boolean isReturnStatement) {\n    myInnerElements = innerElements;\n    myStatements = statements;\n    myTargetClass = targetClass;\n    myIsStatic = isStatic;\n    myIsReturnStatement = isReturnStatement;\n    myVisibility = PsiModifier.PRIVATE;\n    assert myStatements.length > 0;\n    myProject = myStatements[0].getProject();\n    int i = 0;\n    for (VariableInfo info : inputInfos) {\n      PsiType type = info.getType();\n      ParameterInfo pInfo = new ParameterInfo(info.getName(), i, type);\n      myInputNamesMap.put(info.getName(), pInfo);\n      i++;\n    }\n\n    PsiType outputType = PsiType.VOID;\n    if (outputInfo != null) {\n      myOutputName = outputInfo.getName();\n      outputType = outputInfo.getType();\n    }\n    else if (ExtractMethodUtil.isSingleExpression(statements)) {\n      final GrStatement lastExpr = statements[statements.length - 1];\n      if (!(lastExpr.getParent() instanceof GrCodeBlock)) {\n        outputType = ((GrExpression)lastExpr).getType();\n      }\n      myOutputName = null;\n    }\n    else {\n      myOutputName = null;\n      if (isReturnStatement) {\n        assert myStatements.length > 0;\n        GrStatement finalStatement = myStatements[myStatements.length - 1];\n        if (finalStatement instanceof GrExpression) {\n          outputType = ((GrExpression)finalStatement).getType();\n          if (outputType != null) {\n            outputType = TypeConversionUtil.erasure(outputType);\n          }\n        }\n      }\n    }\n    myOutputType = outputType != null ? outputType : PsiType.VOID;\n    mySpecifyType = !(PsiType.VOID.equals(outputType) || myOutputType.equalsToText(\"java.lang.Object\"));\n  }","commit_id":"f9677575f71ce36bbc1e66f733ca0433f2206504","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void execute(Context context) throws SQLException {\n    if (!getDatabase().getDialect().getId().equals(MsSql.ID)) {\n      return;\n    }\n\n    // characteristics\n    new UpdateTableCollation(context, db, \"characteristics\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"function_key\", 100)\n      .addVarcharColumn(\"factor_unit\", 100)\n      .addVarcharColumn(\"offset_unit\", 100)\n      .execute();\n\n    // rules_parameters\n    new UpdateTableCollation(context, db, \"rules_parameters\")\n      .addNotNullableVarcharColumn(\"name\", 128)\n      .addNotNullableVarcharColumn(\"param_type\", 512)\n      .addVarcharColumn(\"default_value\", 4000)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // rules_profiles\n    new UpdateTableCollation(context, db, \"rules_profiles\")\n      .addUniqueIndex(\"uniq_qprof_key\", \"kee\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"language\", 20)\n      .addNotNullableVarcharColumn(\"kee\", 255)\n      .addVarcharColumn(\"parent_kee\", 255)\n      .addVarcharColumn(\"rules_updated_at\", 100)\n      .execute();\n\n    // project_qprofiles\n    new UpdateTableCollation(context, db, \"project_qprofiles\")\n      .addUniqueIndex(\"uniq_project_qprofiles\", \"project_uuid\", \"profile_key\")\n      .addNotNullableVarcharColumn(\"project_uuid\", 50)\n      .addNotNullableVarcharColumn(\"profile_key\", 255)\n      .execute();\n\n    // widgets\n    new UpdateTableCollation(context, db, \"widgets\")\n      .addIndex(\"widgets_widgetkey\", \"widget_key\")\n      .addNotNullableVarcharColumn(\"widget_key\", 256)\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 1000)\n      .execute();\n\n    // groups\n    new UpdateTableCollation(context, db, \"groups\")\n      .addVarcharColumn(\"name\", 500)\n      .addVarcharColumn(\"description\", 200)\n      .execute();\n\n    // snapshots\n    new UpdateTableCollation(context, db, \"snapshots\")\n      .addIndex(\"snapshots_qualifier\", \"qualifier\")\n      .addVarcharColumn(\"scope\", 3)\n      .addVarcharColumn(\"qualifier\", 10)\n      .addVarcharColumn(\"version\", 500)\n      .addVarcharColumn(\"path\", 500)\n      .execute();\n\n    // schema_migrations\n    new UpdateTableCollation(context, db, \"schema_migrations\")\n      .addIndex(\"unique_schema_migrations\", \"version\")\n      .addNotNullableVarcharColumn(\"version\", 256)\n      .execute();\n\n    // group_roles\n    new UpdateTableCollation(context, db, \"group_roles\")\n      .addUniqueIndex(\"uniq_group_roles\", \"group_id\", \"resource_id\", \"role\")\n      .addIndex(\"group_roles_role\", \"role\")\n      .addNotNullableVarcharColumn(\"role\", 64)\n      .execute();\n\n    // Rules\n    new UpdateTableCollation(context, db, \"rules\")\n      .addUniqueIndex(\"rules_repo_key\", \"plugin_name\", \"plugin_rule_key\")\n      .addNotNullableVarcharColumn(\"plugin_rule_key\", 200)\n      .addNotNullableVarcharColumn(\"plugin_name\", 255)\n      .addClobColumn(\"description\")\n      .addVarcharColumn(\"description_format\", 20)\n      .addVarcharColumn(\"plugin_config_key\", 500)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"status\", 40)\n      .addVarcharColumn(\"language\", 20)\n      .addVarcharColumn(\"note_user_login\", 255)\n      .addVarcharColumn(\"remediation_function\", 20)\n      .addVarcharColumn(\"default_remediation_function\", 20)\n      .addVarcharColumn(\"remediation_coeff\", 20)\n      .addVarcharColumn(\"default_remediation_coeff\", 20)\n      .addVarcharColumn(\"remediation_offset\", 20)\n      .addVarcharColumn(\"default_remediation_offset\", 20)\n      .addVarcharColumn(\"effort_to_fix_description\", 4000)\n      .addVarcharColumn(\"tags\", 4000)\n      .addVarcharColumn(\"system_tags\", 4000)\n      .execute();\n\n    // widget_properties\n    new UpdateTableCollation(context, db, \"widget_properties\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"text_value\", 4000)\n      .execute();\n\n    // events\n    new UpdateTableCollation(context, db, \"events\")\n      .addIndex(\"events_component_uuid\", \"component_uuid\")\n      .addVarcharColumn(\"name\", 400)\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"category\", 50)\n      .addVarcharColumn(\"description\", 4000)\n      .addVarcharColumn(\"event_data\", 4000)\n      .execute();\n\n    // quality_gates\n    new UpdateTableCollation(context, db, \"quality_gates\")\n      .addUniqueIndex(\"uniq_quality_gates\", \"name\")\n      .addVarcharColumn(\"name\", 100)\n      .execute();\n\n    // quality_gate_conditions\n    new UpdateTableCollation(context, db, \"quality_gate_conditions\")\n      .addVarcharColumn(\"operator\", 3)\n      .addVarcharColumn(\"value_error\", 64)\n      .addVarcharColumn(\"value_warning\", 64)\n      .execute();\n\n    // properties\n    new UpdateTableCollation(context, db, \"properties\")\n      .addIndex(\"properties_key\", \"prop_key\")\n      .addVarcharColumn(\"prop_key\", 512)\n      .execute();\n\n    // project_links\n    new UpdateTableCollation(context, db, \"project_links\")\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"link_type\", 20)\n      .addVarcharColumn(\"name\", 128)\n      .addNotNullableVarcharColumn(\"href\", 2048)\n      .execute();\n\n    // duplications_index\n    new UpdateTableCollation(context, db, \"duplications_index\")\n      .addIndex(\"duplications_index_hash\", \"hash\")\n      .addNotNullableVarcharColumn(\"hash\", 50)\n      .execute();\n\n    // project_measures\n    new UpdateTableCollation(context, db, \"project_measures\")\n      .addVarcharColumn(\"text_value\", 4000)\n      .addVarcharColumn(\"alert_status\", 5)\n      .addVarcharColumn(\"alert_text\", 4000)\n      .addVarcharColumn(\"url\", 2000)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // projects\n    new UpdateTableCollation(context, db, \"projects\")\n      .addUniqueIndex(\"projects_kee\", \"kee\")\n      .addUniqueIndex(\"projects_uuid\", \"uuid\")\n      .addIndex(\"projects_project_uuid\", \"project_uuid\")\n      .addIndex(\"projects_module_uuid\", \"module_uuid\")\n      .addIndex(\"projects_qualifier\", \"qualifier\")\n      .addVarcharColumn(\"kee\", 400)\n      .addVarcharColumn(\"uuid\", 50)\n      .addVarcharColumn(\"project_uuid\", 50)\n      .addVarcharColumn(\"module_uuid\", 50)\n      .addVarcharColumn(\"module_uuid_path\", 4000)\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 2000)\n      .addVarcharColumn(\"scope\", 3)\n      .addVarcharColumn(\"qualifier\", 10)\n      .addVarcharColumn(\"deprecated_kee\", 400)\n      .addVarcharColumn(\"path\", 2000)\n      .addVarcharColumn(\"language\", 20)\n      .addVarcharColumn(\"long_name\", 256)\n      .execute();\n\n    // manual_measures\n    new UpdateTableCollation(context, db, \"manual_measures\")\n      .addIndex(\"manual_measures_component_uuid\", \"component_uuid\")\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"text_value\", 4000)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // active_rules\n    new UpdateTableCollation(context, db, \"active_rules\")\n      .addVarcharColumn(\"inheritance\", 10)\n      .execute();\n\n    // user_roles\n    new UpdateTableCollation(context, db, \"user_roles\")\n      .addNotNullableVarcharColumn(\"role\", 64)\n      .execute();\n\n    // active_rule_parameters\n    new UpdateTableCollation(context, db, \"active_rule_parameters\")\n      .addVarcharColumn(\"rules_parameter_key\", 128)\n      .addVarcharColumn(\"value\", 4000)\n      .execute();\n\n    // users\n    new UpdateTableCollation(context, db, \"users\")\n      .addUniqueIndex(\"users_login\", \"login\")\n      .addVarcharColumn(\"login\", 255)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"email\", 100)\n      .addVarcharColumn(\"crypted_password\", 40)\n      .addVarcharColumn(\"salt\", 40)\n      .addVarcharColumn(\"remember_token\", 500)\n      .addVarcharColumn(\"scm_accounts\", 4000)\n      .execute();\n\n    // dashboards\n    new UpdateTableCollation(context, db, \"dashboards\")\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 1000)\n      .addVarcharColumn(\"column_layout\", 20)\n      .execute();\n\n    // metrics\n    new UpdateTableCollation(context, db, \"metrics\")\n      .addUniqueIndex(\"metrics_unique_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 64)\n      .addVarcharColumn(\"description\", 255)\n      .addVarcharColumn(\"domain\", 64)\n      .addVarcharColumn(\"short_name\", 64)\n      .addVarcharColumn(\"val_type\", 8)\n      .execute();\n\n    // loaded_templates\n    new UpdateTableCollation(context, db, \"loaded_templates\")\n      .addVarcharColumn(\"kee\", 200)\n      .addVarcharColumn(\"template_type\", 15)\n      .execute();\n\n    // resource_index\n    new UpdateTableCollation(context, db, \"resource_index\")\n      .addIndex(\"resource_index_key\", \"kee\")\n      .addNotNullableVarcharColumn(\"kee\", 400)\n      .addNotNullableVarcharColumn(\"qualifier\", 10)\n      .execute();\n\n    // action_plans\n    new UpdateTableCollation(context, db, \"action_plans\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"description\", 1000)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"status\", 10)\n      .execute();\n\n    // authors\n    new UpdateTableCollation(context, db, \"authors\")\n      .addUniqueIndex(\"uniq_author_logins\", \"login\")\n      .addVarcharColumn(\"login\", 100)\n      .execute();\n\n    // measure_filters\n    new UpdateTableCollation(context, db, \"measure_filters\")\n      .addIndex(\"measure_filters_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // issues\n    new UpdateTableCollation(context, db, \"issues\")\n      .addUniqueIndex(\"issues_kee\", \"kee\")\n      .addIndex(\"issues_component_uuid\", \"component_uuid\")\n      .addIndex(\"issues_project_uuid\", \"project_uuid\")\n      .addIndex(\"issues_severity\", \"severity\")\n      .addIndex(\"issues_status\", \"status\")\n      .addIndex(\"issues_resolution\", \"resolution\")\n      .addIndex(\"issues_assignee\", \"assignee\")\n      .addIndex(\"issues_action_plan_key\", \"action_plan_key\")\n      .addNotNullableVarcharColumn(\"kee\", 50)\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"project_uuid\", 50)\n      .addVarcharColumn(\"severity\", 10)\n      .addVarcharColumn(\"message\", 4000)\n      .addVarcharColumn(\"status\", 20)\n      .addVarcharColumn(\"resolution\", 20)\n      .addVarcharColumn(\"checksum\", 1000)\n      .addVarcharColumn(\"reporter\", 255)\n      .addVarcharColumn(\"assignee\", 255)\n      .addVarcharColumn(\"author_login\", 255)\n      .addVarcharColumn(\"action_plan_key\", 50)\n      .addVarcharColumn(\"issue_attributes\", 4000)\n      .addVarcharColumn(\"tags\", 4000)\n      .execute();\n\n    // issue_changes\n    new UpdateTableCollation(context, db, \"issue_changes\")\n      .addIndex(\"issue_changes_kee\", \"kee\")\n      .addIndex(\"issue_changes_issue_key\", \"issue_key\")\n      .addVarcharColumn(\"kee\", 50)\n      .addNotNullableVarcharColumn(\"issue_key\", 50)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"change_type\", 40)\n      .addClobColumn(\"change_data\")\n      .execute();\n\n    // issue_filters\n    new UpdateTableCollation(context, db, \"issue_filters\")\n      .addIndex(\"issue_filters_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // issue_filter_favourites\n    new UpdateTableCollation(context, db, \"issue_filter_favourites\")\n      .addIndex(\"issue_filter_favs_user\", \"user_login\")\n      .addNotNullableVarcharColumn(\"user_login\", 255)\n      .execute();\n\n    // permission_templates\n    new UpdateTableCollation(context, db, \"permission_templates\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addNotNullableVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"description\", 4000)\n      .addVarcharColumn(\"key_pattern\", 500)\n      .execute();\n\n    // perm_templates_users\n    new UpdateTableCollation(context, db, \"perm_templates_users\")\n      .addNotNullableVarcharColumn(\"permission_reference\", 64)\n      .execute();\n\n    // perm_templates_groups\n    new UpdateTableCollation(context, db, \"perm_templates_groups\")\n      .addNotNullableVarcharColumn(\"permission_reference\", 64)\n      .execute();\n\n    // activities\n    new UpdateTableCollation(context, db, \"activities\")\n      .addUniqueIndex(\"activities_log_key\", \"log_key\")\n      .addVarcharColumn(\"log_key\", 250)\n      .addVarcharColumn(\"user_login\", 30)\n      .addVarcharColumn(\"log_type\", 250)\n      .addVarcharColumn(\"log_action\", 250)\n      .addVarcharColumn(\"log_message\", 250)\n      .execute();\n\n    // file_sources\n    new UpdateTableCollation(context, db, \"file_sources\")\n      .addIndex(\"file_sources_project_uuid\", \"project_uuid\")\n      .addUniqueIndex(\"file_sources_uuid_type\", \"file_uuid\", \"data_type\")\n      .addNotNullableVarcharColumn(\"project_uuid\", 50)\n      .addNotNullableVarcharColumn(\"file_uuid\", 50)\n      .addVarcharColumn(\"data_type\", 20)\n      .addVarcharColumn(\"data_hash\", 50)\n      .addVarcharColumn(\"src_hash\", 50)\n      .addVarcharColumn(\"revision\", 100)\n      .execute();\n\n    // ce_queue\n    new UpdateTableCollation(context, db, \"ce_queue\")\n      .addUniqueIndex(\"ce_queue_uuid\", \"uuid\")\n      .addNotNullableVarcharColumn(\"uuid\", 40)\n      .addNotNullableVarcharColumn(\"task_type\", 15)\n      .addVarcharColumn(\"component_uuid\", 40)\n      .addNotNullableVarcharColumn(\"status\", 15)\n      .addVarcharColumn(\"submitter_login\", 255)\n      .execute();\n\n    // ce_activity\n    new UpdateTableCollation(context, db, \"ce_activity\")\n      .addUniqueIndex(\"ce_activity_uuid\", \"uuid\")\n      .addIndex(\"ce_activity_component_uuid\", \"component_uuid\")\n      .addNotNullableVarcharColumn(\"uuid\", 40)\n      .addNotNullableVarcharColumn(\"task_type\", 15)\n      .addVarcharColumn(\"component_uuid\", 40)\n      .addNotNullableVarcharColumn(\"status\", 15)\n      .addNotNullableVarcharColumn(\"is_last_key\", 55)\n      .addVarcharColumn(\"submitter_login\", 255)\n      .execute();\n  }","id":66692,"modified_method":"@Override\n  public void execute(Context context) throws SQLException {\n    if (!getDatabase().getDialect().getId().equals(MsSql.ID)) {\n      return;\n    }\n\n    // characteristics\n    new UpdateTableCollation(context, db, \"characteristics\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"function_key\", 100)\n      .addVarcharColumn(\"factor_unit\", 100)\n      .addVarcharColumn(\"offset_unit\", 100)\n      .execute();\n\n    // rules_parameters\n    new UpdateTableCollation(context, db, \"rules_parameters\")\n      .addNotNullableVarcharColumn(\"name\", 128)\n      .addNotNullableVarcharColumn(\"param_type\", 512)\n      .addVarcharColumn(\"default_value\", 4000)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // rules_profiles\n    new UpdateTableCollation(context, db, \"rules_profiles\")\n      .addUniqueIndex(\"uniq_qprof_key\", \"kee\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"language\", 20)\n      .addNotNullableVarcharColumn(\"kee\", 255)\n      .addVarcharColumn(\"parent_kee\", 255)\n      .addVarcharColumn(\"rules_updated_at\", 100)\n      .execute();\n\n    // project_qprofiles\n    new UpdateTableCollation(context, db, \"project_qprofiles\")\n      .addUniqueIndex(\"uniq_project_qprofiles\", \"project_uuid\", \"profile_key\")\n      .addNotNullableVarcharColumn(\"project_uuid\", 50)\n      .addNotNullableVarcharColumn(\"profile_key\", 255)\n      .execute();\n\n    // widgets\n    new UpdateTableCollation(context, db, \"widgets\")\n      .addIndex(\"widgets_widgetkey\", \"widget_key\")\n      .addNotNullableVarcharColumn(\"widget_key\", 256)\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 1000)\n      .execute();\n\n    // groups\n    new UpdateTableCollation(context, db, \"groups\")\n      .addVarcharColumn(\"name\", 500)\n      .addVarcharColumn(\"description\", 200)\n      .execute();\n\n    // snapshots\n    new UpdateTableCollation(context, db, \"snapshots\")\n      .addIndex(\"snapshots_qualifier\", \"qualifier\")\n      .addVarcharColumn(\"scope\", 3)\n      .addVarcharColumn(\"qualifier\", 10)\n      .addVarcharColumn(\"version\", 500)\n      .addVarcharColumn(\"path\", 500)\n      .execute();\n\n    // schema_migrations\n    new UpdateTableCollation(context, db, \"schema_migrations\")\n      .addIndex(\"unique_schema_migrations\", \"version\")\n      .addNotNullableVarcharColumn(\"version\", 256)\n      .execute();\n\n    // group_roles\n    new UpdateTableCollation(context, db, \"group_roles\")\n      .addUniqueIndex(\"uniq_group_roles\", \"group_id\", \"resource_id\", \"role\")\n      .addIndex(\"group_roles_role\", \"role\")\n      .addNotNullableVarcharColumn(\"role\", 64)\n      .execute();\n\n    // Rules\n    new UpdateTableCollation(context, db, \"rules\")\n      .addUniqueIndex(\"rules_repo_key\", \"plugin_name\", \"plugin_rule_key\")\n      .addNotNullableVarcharColumn(\"plugin_rule_key\", 200)\n      .addNotNullableVarcharColumn(\"plugin_name\", 255)\n      .addClobColumn(\"description\")\n      .addVarcharColumn(\"description_format\", 20)\n      .addVarcharColumn(\"plugin_config_key\", 500)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"status\", 40)\n      .addVarcharColumn(\"language\", 20)\n      .addClobColumn(\"note_data\")\n      .addVarcharColumn(\"note_user_login\", 255)\n      .addVarcharColumn(\"remediation_function\", 20)\n      .addVarcharColumn(\"default_remediation_function\", 20)\n      .addVarcharColumn(\"remediation_coeff\", 20)\n      .addVarcharColumn(\"default_remediation_coeff\", 20)\n      .addVarcharColumn(\"remediation_offset\", 20)\n      .addVarcharColumn(\"default_remediation_offset\", 20)\n      .addVarcharColumn(\"effort_to_fix_description\", 4000)\n      .addVarcharColumn(\"tags\", 4000)\n      .addVarcharColumn(\"system_tags\", 4000)\n      .execute();\n\n    // widget_properties\n    new UpdateTableCollation(context, db, \"widget_properties\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"text_value\", 4000)\n      .execute();\n\n    // events\n    new UpdateTableCollation(context, db, \"events\")\n      .addIndex(\"events_component_uuid\", \"component_uuid\")\n      .addVarcharColumn(\"name\", 400)\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"category\", 50)\n      .addVarcharColumn(\"description\", 4000)\n      .addVarcharColumn(\"event_data\", 4000)\n      .execute();\n\n    // quality_gates\n    new UpdateTableCollation(context, db, \"quality_gates\")\n      .addUniqueIndex(\"uniq_quality_gates\", \"name\")\n      .addVarcharColumn(\"name\", 100)\n      .execute();\n\n    // quality_gate_conditions\n    new UpdateTableCollation(context, db, \"quality_gate_conditions\")\n      .addVarcharColumn(\"operator\", 3)\n      .addVarcharColumn(\"value_error\", 64)\n      .addVarcharColumn(\"value_warning\", 64)\n      .execute();\n\n    // properties\n    new UpdateTableCollation(context, db, \"properties\")\n      .addIndex(\"properties_key\", \"prop_key\")\n      .addVarcharColumn(\"prop_key\", 512)\n      .addClobColumn(\"text_value\")\n      .execute();\n\n    // project_links\n    new UpdateTableCollation(context, db, \"project_links\")\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"link_type\", 20)\n      .addVarcharColumn(\"name\", 128)\n      .addNotNullableVarcharColumn(\"href\", 2048)\n      .execute();\n\n    // duplications_index\n    new UpdateTableCollation(context, db, \"duplications_index\")\n      .addIndex(\"duplications_index_hash\", \"hash\")\n      .addNotNullableVarcharColumn(\"hash\", 50)\n      .execute();\n\n    // project_measures\n    new UpdateTableCollation(context, db, \"project_measures\")\n      .addVarcharColumn(\"text_value\", 4000)\n      .addVarcharColumn(\"alert_status\", 5)\n      .addVarcharColumn(\"alert_text\", 4000)\n      .addVarcharColumn(\"url\", 2000)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // projects\n    new UpdateTableCollation(context, db, \"projects\")\n      .addUniqueIndex(\"projects_kee\", \"kee\")\n      .addUniqueIndex(\"projects_uuid\", \"uuid\")\n      .addIndex(\"projects_project_uuid\", \"project_uuid\")\n      .addIndex(\"projects_module_uuid\", \"module_uuid\")\n      .addIndex(\"projects_qualifier\", \"qualifier\")\n      .addVarcharColumn(\"kee\", 400)\n      .addVarcharColumn(\"uuid\", 50)\n      .addVarcharColumn(\"project_uuid\", 50)\n      .addVarcharColumn(\"module_uuid\", 50)\n      .addVarcharColumn(\"module_uuid_path\", 4000)\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 2000)\n      .addVarcharColumn(\"scope\", 3)\n      .addVarcharColumn(\"qualifier\", 10)\n      .addVarcharColumn(\"deprecated_kee\", 400)\n      .addVarcharColumn(\"path\", 2000)\n      .addVarcharColumn(\"language\", 20)\n      .addVarcharColumn(\"long_name\", 256)\n      .execute();\n\n    // manual_measures\n    new UpdateTableCollation(context, db, \"manual_measures\")\n      .addIndex(\"manual_measures_component_uuid\", \"component_uuid\")\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"text_value\", 4000)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"description\", 4000)\n      .execute();\n\n    // active_rules\n    new UpdateTableCollation(context, db, \"active_rules\")\n      .addVarcharColumn(\"inheritance\", 10)\n      .execute();\n\n    // user_roles\n    new UpdateTableCollation(context, db, \"user_roles\")\n      .addNotNullableVarcharColumn(\"role\", 64)\n      .execute();\n\n    // active_rule_parameters\n    new UpdateTableCollation(context, db, \"active_rule_parameters\")\n      .addVarcharColumn(\"rules_parameter_key\", 128)\n      .addVarcharColumn(\"value\", 4000)\n      .execute();\n\n    // users\n    new UpdateTableCollation(context, db, \"users\")\n      .addUniqueIndex(\"users_login\", \"login\")\n      .addVarcharColumn(\"login\", 255)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"email\", 100)\n      .addVarcharColumn(\"crypted_password\", 40)\n      .addVarcharColumn(\"salt\", 40)\n      .addVarcharColumn(\"remember_token\", 500)\n      .addVarcharColumn(\"scm_accounts\", 4000)\n      .execute();\n\n    // dashboards\n    new UpdateTableCollation(context, db, \"dashboards\")\n      .addVarcharColumn(\"name\", 256)\n      .addVarcharColumn(\"description\", 1000)\n      .addVarcharColumn(\"column_layout\", 20)\n      .execute();\n\n    // metrics\n    new UpdateTableCollation(context, db, \"metrics\")\n      .addUniqueIndex(\"metrics_unique_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 64)\n      .addVarcharColumn(\"description\", 255)\n      .addVarcharColumn(\"domain\", 64)\n      .addVarcharColumn(\"short_name\", 64)\n      .addVarcharColumn(\"val_type\", 8)\n      .execute();\n\n    // loaded_templates\n    new UpdateTableCollation(context, db, \"loaded_templates\")\n      .addVarcharColumn(\"kee\", 200)\n      .addVarcharColumn(\"template_type\", 15)\n      .execute();\n\n    // resource_index\n    new UpdateTableCollation(context, db, \"resource_index\")\n      .addIndex(\"resource_index_key\", \"kee\")\n      .addNotNullableVarcharColumn(\"kee\", 400)\n      .addNotNullableVarcharColumn(\"qualifier\", 10)\n      .execute();\n\n    // action_plans\n    new UpdateTableCollation(context, db, \"action_plans\")\n      .addVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"name\", 200)\n      .addVarcharColumn(\"description\", 1000)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"status\", 10)\n      .execute();\n\n    // authors\n    new UpdateTableCollation(context, db, \"authors\")\n      .addUniqueIndex(\"uniq_author_logins\", \"login\")\n      .addVarcharColumn(\"login\", 100)\n      .execute();\n\n    // measure_filters\n    new UpdateTableCollation(context, db, \"measure_filters\")\n      .addIndex(\"measure_filters_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"description\", 4000)\n      .addClobColumn(\"data\")\n      .execute();\n\n    // issues\n    new UpdateTableCollation(context, db, \"issues\")\n      .addUniqueIndex(\"issues_kee\", \"kee\")\n      .addIndex(\"issues_component_uuid\", \"component_uuid\")\n      .addIndex(\"issues_project_uuid\", \"project_uuid\")\n      .addIndex(\"issues_severity\", \"severity\")\n      .addIndex(\"issues_status\", \"status\")\n      .addIndex(\"issues_resolution\", \"resolution\")\n      .addIndex(\"issues_assignee\", \"assignee\")\n      .addIndex(\"issues_action_plan_key\", \"action_plan_key\")\n      .addNotNullableVarcharColumn(\"kee\", 50)\n      .addVarcharColumn(\"component_uuid\", 50)\n      .addVarcharColumn(\"project_uuid\", 50)\n      .addVarcharColumn(\"severity\", 10)\n      .addVarcharColumn(\"message\", 4000)\n      .addVarcharColumn(\"status\", 20)\n      .addVarcharColumn(\"resolution\", 20)\n      .addVarcharColumn(\"checksum\", 1000)\n      .addVarcharColumn(\"reporter\", 255)\n      .addVarcharColumn(\"assignee\", 255)\n      .addVarcharColumn(\"author_login\", 255)\n      .addVarcharColumn(\"action_plan_key\", 50)\n      .addVarcharColumn(\"issue_attributes\", 4000)\n      .addVarcharColumn(\"tags\", 4000)\n      .execute();\n\n    // issue_changes\n    new UpdateTableCollation(context, db, \"issue_changes\")\n      .addIndex(\"issue_changes_kee\", \"kee\")\n      .addIndex(\"issue_changes_issue_key\", \"issue_key\")\n      .addVarcharColumn(\"kee\", 50)\n      .addNotNullableVarcharColumn(\"issue_key\", 50)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"change_type\", 40)\n      .addClobColumn(\"change_data\")\n      .execute();\n\n    // issue_filters\n    new UpdateTableCollation(context, db, \"issue_filters\")\n      .addIndex(\"issue_filters_name\", \"name\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addVarcharColumn(\"user_login\", 255)\n      .addVarcharColumn(\"description\", 4000)\n      .addClobColumn(\"data\")\n      .execute();\n\n    // issue_filter_favourites\n    new UpdateTableCollation(context, db, \"issue_filter_favourites\")\n      .addIndex(\"issue_filter_favs_user\", \"user_login\")\n      .addNotNullableVarcharColumn(\"user_login\", 255)\n      .execute();\n\n    // permission_templates\n    new UpdateTableCollation(context, db, \"permission_templates\")\n      .addNotNullableVarcharColumn(\"name\", 100)\n      .addNotNullableVarcharColumn(\"kee\", 100)\n      .addVarcharColumn(\"description\", 4000)\n      .addVarcharColumn(\"key_pattern\", 500)\n      .execute();\n\n    // perm_templates_users\n    new UpdateTableCollation(context, db, \"perm_templates_users\")\n      .addNotNullableVarcharColumn(\"permission_reference\", 64)\n      .execute();\n\n    // perm_templates_groups\n    new UpdateTableCollation(context, db, \"perm_templates_groups\")\n      .addNotNullableVarcharColumn(\"permission_reference\", 64)\n      .execute();\n\n    // activities\n    new UpdateTableCollation(context, db, \"activities\")\n      .addUniqueIndex(\"activities_log_key\", \"log_key\")\n      .addVarcharColumn(\"log_key\", 250)\n      .addVarcharColumn(\"user_login\", 30)\n      .addVarcharColumn(\"log_type\", 250)\n      .addVarcharColumn(\"log_action\", 250)\n      .addVarcharColumn(\"log_message\", 250)\n      .addClobColumn(\"data_field\")\n      .execute();\n\n    // file_sources\n    new UpdateTableCollation(context, db, \"file_sources\")\n      .addIndex(\"file_sources_project_uuid\", \"project_uuid\")\n      .addUniqueIndex(\"file_sources_uuid_type\", \"file_uuid\", \"data_type\")\n      .addNotNullableVarcharColumn(\"project_uuid\", 50)\n      .addNotNullableVarcharColumn(\"file_uuid\", 50)\n      .addClobColumn(\"line_hashes\")\n      .addVarcharColumn(\"data_type\", 20)\n      .addVarcharColumn(\"data_hash\", 50)\n      .addVarcharColumn(\"src_hash\", 50)\n      .addVarcharColumn(\"revision\", 100)\n      .execute();\n\n    // ce_queue\n    new UpdateTableCollation(context, db, \"ce_queue\")\n      .addUniqueIndex(\"ce_queue_uuid\", \"uuid\")\n      .addNotNullableVarcharColumn(\"uuid\", 40)\n      .addNotNullableVarcharColumn(\"task_type\", 15)\n      .addVarcharColumn(\"component_uuid\", 40)\n      .addNotNullableVarcharColumn(\"status\", 15)\n      .addVarcharColumn(\"submitter_login\", 255)\n      .execute();\n\n    // ce_activity\n    new UpdateTableCollation(context, db, \"ce_activity\")\n      .addUniqueIndex(\"ce_activity_uuid\", \"uuid\")\n      .addIndex(\"ce_activity_component_uuid\", \"component_uuid\")\n      .addNotNullableVarcharColumn(\"uuid\", 40)\n      .addNotNullableVarcharColumn(\"task_type\", 15)\n      .addVarcharColumn(\"component_uuid\", 40)\n      .addNotNullableVarcharColumn(\"status\", 15)\n      .addNotNullableVarcharColumn(\"is_last_key\", 55)\n      .addVarcharColumn(\"submitter_login\", 255)\n      .execute();\n  }","commit_id":"12f5b6d7a2b865d979e54b39b225afb88499af26","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong threadId = 0;\n\t\tlong parentMessageId = 0;\n\t\tString subject = String.valueOf(classPK);\n\t\tString body = subject;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn addDiscussionMessage(\n\t\t\tnull, userId, userName, groupId, className, classPK, threadId,\n\t\t\tparentMessageId, subject, body, serviceContext);\n\t}","id":66693,"modified_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong threadId = 0;\n\t\tlong parentMessageId = 0;\n\t\tString subject = String.valueOf(classPK);\n\t\tString body = subject;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\tboolean enabled = WorkflowThreadLocal.isEnabled();\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\tMBMessage message = addDiscussionMessage(\n\t\t\tnull, userId, userName, groupId, className, classPK, threadId,\n\t\t\tparentMessageId, subject, body, serviceContext);\n\n\t\tWorkflowThreadLocal.setEnabled(enabled);\n\n\t\treturn message;\n\t}","commit_id":"a906525b0d127cbf10cce55cd76bdd187dec7a4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tboolean enabled = WorkflowThreadLocal.isEnabled();\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\tsuper.processAction(\n\t\t\tmapping, form, portletConfig, actionRequest, actionResponse);\n\n\t\tWorkflowThreadLocal.setEnabled(enabled);\n\t}","id":66694,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\ttry {\n\t\t\tsuper.processAction(\n\t\t\t\tmapping, form, portletConfig, actionRequest, actionResponse);\n\t\t}\n\t\tfinally {\n\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t}\n\t}","commit_id":"8f59db09225f3f4629004f720683a1489f53c8aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessageDisplay getDiscussionMessageDisplay(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tint status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tMBMessage message = null;\n\n\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\tclassNameId, classPK);\n\n\t\tif (discussion != null) {\n\t\t\tList<MBMessage> messages = mbMessagePersistence.findByT_P(\n\t\t\t\tdiscussion.getThreadId(),\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\tmessage = messages.get(0);\n\t\t}\n\t\telse {\n\t\t\tString subject = String.valueOf(classPK);\n\t\t\t//String body = subject;\n\n\t\t\ttry {\n\t\t\t\tboolean enabled = WorkflowThreadLocal.isEnabled();\n\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\tmessage = addDiscussionMessage(\n\t\t\t\t\tnull, userId, null, groupId, className, classPK, 0,\n\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID, subject,\n\t\t\t\t\tsubject, new ServiceContext());\n\n\t\t\t\tWorkflowThreadLocal.setEnabled(enabled);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Add failed, fetch {threadId=0, parentMessageId=\" +\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID + \"}\");\n\t\t\t\t}\n\n\t\t\t\tList<MBMessage> messages = mbMessagePersistence.findByT_P(\n\t\t\t\t\t0, MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\tif (messages.isEmpty()) {\n\t\t\t\t\tthrow se;\n\t\t\t\t}\n\n\t\t\t\tmessage = messages.get(0);\n\t\t\t}\n\t\t}\n\n\t\treturn getMessageDisplay(message, status, threadView, false);\n\t}","id":66695,"modified_method":"public MBMessageDisplay getDiscussionMessageDisplay(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tint status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tMBMessage message = null;\n\n\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\tclassNameId, classPK);\n\n\t\tif (discussion != null) {\n\t\t\tList<MBMessage> messages = mbMessagePersistence.findByT_P(\n\t\t\t\tdiscussion.getThreadId(),\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\tmessage = messages.get(0);\n\t\t}\n\t\telse {\n\t\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tString subject = String.valueOf(classPK);\n\t\t\t\t//String body = subject;\n\n\t\t\t\tmessage = addDiscussionMessage(\n\t\t\t\t\tnull, userId, null, groupId, className, classPK, 0,\n\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID, subject,\n\t\t\t\t\tsubject, new ServiceContext());\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Add failed, fetch {threadId=0, parentMessageId=\" +\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID + \"}\");\n\t\t\t\t}\n\n\t\t\t\tList<MBMessage> messages = mbMessagePersistence.findByT_P(\n\t\t\t\t\t0, MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\tif (messages.isEmpty()) {\n\t\t\t\t\tthrow se;\n\t\t\t\t}\n\n\t\t\t\tmessage = messages.get(0);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t}\n\t\t}\n\n\t\treturn getMessageDisplay(message, status, threadView, false);\n\t}","commit_id":"8f59db09225f3f4629004f720683a1489f53c8aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong threadId = 0;\n\t\tlong parentMessageId = 0;\n\t\tString subject = String.valueOf(classPK);\n\t\tString body = subject;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\tboolean enabled = WorkflowThreadLocal.isEnabled();\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\tMBMessage message = addDiscussionMessage(\n\t\t\tnull, userId, userName, groupId, className, classPK, threadId,\n\t\t\tparentMessageId, subject, body, serviceContext);\n\n\t\tWorkflowThreadLocal.setEnabled(enabled);\n\n\t\treturn message;\n\t}","id":66696,"modified_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong threadId = 0;\n\t\tlong parentMessageId = 0;\n\t\tString subject = String.valueOf(classPK);\n\t\tString body = subject;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\n\t\ttry {\n\t\t\treturn addDiscussionMessage(\n\t\t\t\tnull, userId, userName, groupId, className, classPK, threadId,\n\t\t\t\tparentMessageId, subject, body, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t}\n\t}","commit_id":"8f59db09225f3f4629004f720683a1489f53c8aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public TasksProposal addProposal(\n\t\t\tlong userId, long groupId, String className, String classPK,\n\t\t\tString name, String description, long reviewUserId,\n\t\t\tBoolean addCommunityPermissions, Boolean addGuestPermissions,\n\t\t\tString[] communityPermissions, String[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Proposal\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tlong proposalId = counterLocalService.increment();\n\n\t\tTasksProposal proposal = tasksProposalPersistence.create(proposalId);\n\n\t\tproposal.setGroupId(groupId);\n\t\tproposal.setCompanyId(user.getCompanyId());\n\t\tproposal.setUserId(user.getUserId());\n\t\tproposal.setUserName(user.getFullName());\n\t\tproposal.setCreateDate(now);\n\t\tproposal.setModifiedDate(now);\n\t\tproposal.setClassNameId(classNameId);\n\t\tproposal.setClassPK(classPK);\n\t\tproposal.setName(name);\n\t\tproposal.setDescription(description);\n\n\t\tproposal = tasksProposalPersistence.update(proposal, false);\n\n\t\t// Resources\n\n\t\tif ((addCommunityPermissions != null) &&\n\t\t\t(addGuestPermissions != null)) {\n\n\t\t\taddProposalResources(\n\t\t\t\tproposal, addCommunityPermissions.booleanValue(),\n\t\t\t\taddGuestPermissions.booleanValue());\n\t\t}\n\t\telse {\n\t\t\taddProposalResources(\n\t\t\t\tproposal, communityPermissions, guestPermissions);\n\t\t}\n\n\t\t// Review\n\n\t\tlong assignedByUserId = userId;\n\t\tint stage = 1;\n\n\t\ttasksReviewLocalService.addReview(\n\t\t\treviewUserId, proposal.getProposalId(), assignedByUserId, stage);\n\n\t\t// Message boards\n\n\t\tboolean enabled = WorkflowThreadLocal.isEnabled();\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\tuserId, proposal.getUserName(), groupId,\n\t\t\tTasksProposal.class.getName(), proposalId,\n\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\n\t\tWorkflowThreadLocal.setEnabled(enabled);\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, TasksProposal.class.getName(), proposalId,\n\t\t\tTasksActivityKeys.ADD_PROPOSAL, StringPool.BLANK, 0);\n\n\t\treturn proposal;\n\t}","id":66697,"modified_method":"public TasksProposal addProposal(\n\t\t\tlong userId, long groupId, String className, String classPK,\n\t\t\tString name, String description, long reviewUserId,\n\t\t\tBoolean addCommunityPermissions, Boolean addGuestPermissions,\n\t\t\tString[] communityPermissions, String[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Proposal\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tlong proposalId = counterLocalService.increment();\n\n\t\tTasksProposal proposal = tasksProposalPersistence.create(proposalId);\n\n\t\tproposal.setGroupId(groupId);\n\t\tproposal.setCompanyId(user.getCompanyId());\n\t\tproposal.setUserId(user.getUserId());\n\t\tproposal.setUserName(user.getFullName());\n\t\tproposal.setCreateDate(now);\n\t\tproposal.setModifiedDate(now);\n\t\tproposal.setClassNameId(classNameId);\n\t\tproposal.setClassPK(classPK);\n\t\tproposal.setName(name);\n\t\tproposal.setDescription(description);\n\n\t\tproposal = tasksProposalPersistence.update(proposal, false);\n\n\t\t// Resources\n\n\t\tif ((addCommunityPermissions != null) &&\n\t\t\t(addGuestPermissions != null)) {\n\n\t\t\taddProposalResources(\n\t\t\t\tproposal, addCommunityPermissions.booleanValue(),\n\t\t\t\taddGuestPermissions.booleanValue());\n\t\t}\n\t\telse {\n\t\t\taddProposalResources(\n\t\t\t\tproposal, communityPermissions, guestPermissions);\n\t\t}\n\n\t\t// Review\n\n\t\tlong assignedByUserId = userId;\n\t\tint stage = 1;\n\n\t\ttasksReviewLocalService.addReview(\n\t\t\treviewUserId, proposal.getProposalId(), assignedByUserId, stage);\n\n\t\t// Message boards\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\ttry {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, proposal.getUserName(), groupId,\n\t\t\t\tTasksProposal.class.getName(), proposalId,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\t\tfinally {\n\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t}\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, TasksProposal.class.getName(), proposalId,\n\t\t\tTasksActivityKeys.ADD_PROPOSAL, StringPool.BLANK, 0);\n\n\t\treturn proposal;\n\t}","commit_id":"8f59db09225f3f4629004f720683a1489f53c8aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void visit(Tree.ClassOrInterface decl) {\n        if(hasClassErrors(decl))\n            return;\n        boolean annots = gen.checkCompilerAnnotations(decl);\n        \n        if (Decl.withinClassOrInterface(decl)) {\n            if (Decl.withinInterface(decl)\n                    && !Decl.isToplevel(decl)) {\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).defs(gen.classGen().transform(decl));\n            } else {\n                classBuilder.defs(gen.classGen().transform(decl));\n            }\n        } else {\n            appendList(gen.classGen().transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","id":66698,"modified_method":"public void visit(Tree.ClassOrInterface decl) {\n        if(hasClassErrors(decl))\n            return;\n        boolean annots = gen.checkCompilerAnnotations(decl);\n        \n        if (Decl.withinClassOrInterface(decl)) {\n            if (Decl.withinInterface(decl)) {\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).defs(gen.classGen().transform(decl));\n            } else {\n                classBuilder.defs(gen.classGen().transform(decl));\n            }\n        } else {\n            appendList(gen.classGen().transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","commit_id":"026abb40cf578eeb3a27e42ab4a8236364dcde27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void transform(AttributeDeclaration decl, ClassDefinitionBuilder classBuilder) {\n        final Value model = decl.getDeclarationModel();\n        boolean lazy = decl.getSpecifierOrInitializerExpression() instanceof LazySpecifierExpression;\n        boolean useField = Strategy.useField(model) && !lazy;\n        String attrName = decl.getIdentifier().getText();\n\n        // Only a non-formal or a concrete-non-lazy attribute has a corresponding field\n        // and if a captured class parameter exists with the same name we skip this part as well\n        Parameter parameter = CodegenUtil.findParamForDecl(decl);\n        boolean createField = Strategy.createField(parameter, model) && !lazy;\n        boolean concrete = Decl.withinInterface(decl)\n                && decl.getSpecifierOrInitializerExpression() != null;\n        if (!lazy && (concrete || (!Decl.isFormal(decl) && createField))) {\n            ProducedTypedReference typedRef = getTypedReference(model);\n            ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n            ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n            \n            JCExpression initialValue = null;\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = model;\n                initialValue = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        nonWideningType);\n            }\n\n            int flags = 0;\n            \n            if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n                flags |= JT_NO_PRIMITIVES;\n            }\n            JCExpression type = makeJavaType(nonWideningType, flags);\n\n            int modifiers = (useField) ? transformAttributeFieldDeclFlags(decl) : transformLocalDeclFlags(decl);\n            \n            // If the attribute is really from a parameter then don't generate a field\n            // (The ClassDefinitionBuilder does it in that case)\n            if (parameter == null\n                    || ((parameter instanceof ValueParameter) \n                            && ((ValueParameter)parameter).isHidden())) {\n                if (concrete) {\n                    classBuilder.getCompanionBuilder((TypeDeclaration)model.getContainer()).field(modifiers, attrName, type, initialValue, !useField);\n                } else {\n                    classBuilder.field(modifiers, attrName, type, initialValue, !useField);\n                }        \n            }\n        }\n\n        if (useField || Decl.withinInterface(decl) || lazy) {\n            boolean generateCodeAsIfForCompanion = lazy && !Decl.withinInterface(decl);\n            if (!Decl.withinInterface(decl) || model.isShared()) {\n                // Generate getter in main class or interface (when shared)\n                classBuilder.attribute(makeGetter(decl, generateCodeAsIfForCompanion));\n            }\n            if (Decl.withinInterface(decl)) {\n                // Generate getter in companion class\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeGetter(decl, true));\n            }\n            if (Decl.isMutable(decl)) {\n                if (!Decl.withinInterface(decl) || model.isShared()) {\n                    // Generate setter in main class or interface (when shared)\n                    classBuilder.attribute(makeSetter(decl, generateCodeAsIfForCompanion));\n                }\n                if (Decl.withinInterface(decl)) {\n                    // Generate setter in companion class\n                    classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeSetter(decl, true));\n                }\n            }\n        }\n    }","id":66699,"modified_method":"public void transform(AttributeDeclaration decl, ClassDefinitionBuilder classBuilder) {\n        final Value model = decl.getDeclarationModel();\n        boolean lazy = decl.getSpecifierOrInitializerExpression() instanceof LazySpecifierExpression;\n        boolean useField = Strategy.useField(model) && !lazy;\n        String attrName = decl.getIdentifier().getText();\n\n        // Only a non-formal or a concrete-non-lazy attribute has a corresponding field\n        // and if a captured class parameter exists with the same name we skip this part as well\n        Parameter parameter = CodegenUtil.findParamForDecl(decl);\n        boolean createField = Strategy.createField(parameter, model) && !lazy;\n        boolean concrete = Decl.withinInterface(decl)\n                && decl.getSpecifierOrInitializerExpression() != null;\n        if (!lazy && (concrete || (!Decl.isFormal(decl) && createField))) {\n            ProducedTypedReference typedRef = getTypedReference(model);\n            ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n            ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n            \n            JCExpression initialValue = null;\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = model;\n                initialValue = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        nonWideningType);\n            }\n\n            int flags = 0;\n            \n            if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n                flags |= JT_NO_PRIMITIVES;\n            }\n            JCExpression type = makeJavaType(nonWideningType, flags);\n\n            int modifiers = (useField) ? transformAttributeFieldDeclFlags(decl) : transformLocalDeclFlags(decl);\n            \n            // If the attribute is really from a parameter then don't generate a field\n            // (The ClassDefinitionBuilder does it in that case)\n            if (parameter == null\n                    || ((parameter instanceof ValueParameter) \n                            && ((ValueParameter)parameter).isHidden())) {\n                if (concrete) {\n                    classBuilder.getCompanionBuilder((TypeDeclaration)model.getContainer()).field(modifiers, attrName, type, initialValue, !useField);\n                } else {\n                    classBuilder.field(modifiers, attrName, type, initialValue, !useField);\n                }        \n            }\n        }\n\n        boolean withinInterface = Decl.withinInterface(decl);\n        if (useField || withinInterface || lazy) {\n            if (!withinInterface || model.isShared()) {\n                // Generate getter in main class or interface (when shared)\n                classBuilder.attribute(makeGetter(decl, false, lazy));\n            }\n            if (withinInterface && lazy) {\n                // Generate getter in companion class\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeGetter(decl, true, lazy));\n            }\n            if (Decl.isMutable(decl)) {\n                if (!withinInterface || model.isShared()) {\n                    // Generate setter in main class or interface (when shared)\n                    classBuilder.attribute(makeSetter(decl, false, lazy));\n                }\n                if (withinInterface) {\n                    // Generate setter in companion class\n                    classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeSetter(decl, true, lazy));\n                }\n            }\n        }\n    }","commit_id":"14d5ba803980bed3db9c92144941e5ae80c0992d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder makeGetter(Tree.AttributeDeclaration decl, boolean forCompanion) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        AttributeDefinitionBuilder getter = AttributeDefinitionBuilder\n            .getter(this, attrName, decl.getDeclarationModel());\n        return makeGetterOrSetter(decl, forCompanion, getter, true);\n    }","id":66700,"modified_method":"private AttributeDefinitionBuilder makeGetter(Tree.AttributeDeclaration decl, boolean forCompanion, boolean lazy) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        AttributeDefinitionBuilder getter = AttributeDefinitionBuilder\n            .getter(this, attrName, decl.getDeclarationModel());\n        return makeGetterOrSetter(decl, forCompanion, lazy, getter, true);\n    }","commit_id":"14d5ba803980bed3db9c92144941e5ae80c0992d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = decl.getDeclarationModel();\n                ProducedTypedReference typedRef = getTypedReference(declarationModel);\n                ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n                ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n                \n                JCExpression expr = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        nonWideningType);\n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(expr))));\n            } else {\n                JCExpression accessor = naming.makeQualifiedName(\n                        naming.makeQuotedThis(), \n                        decl.getDeclarationModel(), \n                        Naming.NA_MEMBER | (isGetter ? Naming.NA_GETTER : Naming.NA_SETTER));\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(naming.makeName(decl.getDeclarationModel(), Naming.NA_MEMBER | Naming.NA_IDENT));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    args)))));\n                }\n                \n            }\n        }\n        if(forCompanion)\n            builder.notActual();\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isFormal((Decl.isFormal(decl) || Decl.withinInterface(decl)) && !forCompanion);\n    }","id":66701,"modified_method":"private AttributeDefinitionBuilder makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, boolean lazy, \n                                                          AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion || lazy) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = decl.getDeclarationModel();\n                ProducedTypedReference typedRef = getTypedReference(declarationModel);\n                ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n                ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n                \n                JCExpression expr = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        nonWideningType);\n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(expr))));\n            } else {\n                JCExpression accessor = naming.makeQualifiedName(\n                        naming.makeQuotedThis(), \n                        decl.getDeclarationModel(), \n                        Naming.NA_MEMBER | (isGetter ? Naming.NA_GETTER : Naming.NA_SETTER));\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(naming.makeName(decl.getDeclarationModel(), Naming.NA_MEMBER | Naming.NA_IDENT));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    args)))));\n                }\n                \n            }\n        }\n        if(forCompanion)\n            builder.notActual();\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isFormal((Decl.isFormal(decl) || Decl.withinInterface(decl)) && !forCompanion);\n    }","commit_id":"14d5ba803980bed3db9c92144941e5ae80c0992d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder makeSetter(Tree.AttributeDeclaration decl, boolean forCompanion) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        AttributeDefinitionBuilder setter = AttributeDefinitionBuilder.setter(this, attrName, decl.getDeclarationModel());\n        return makeGetterOrSetter(decl, forCompanion, setter, false);\n    }","id":66702,"modified_method":"private AttributeDefinitionBuilder makeSetter(Tree.AttributeDeclaration decl, boolean forCompanion, boolean lazy) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        AttributeDefinitionBuilder setter = AttributeDefinitionBuilder.setter(this, attrName, decl.getDeclarationModel());\n        return makeGetterOrSetter(decl, forCompanion, lazy, setter, false);\n    }","commit_id":"14d5ba803980bed3db9c92144941e5ae80c0992d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(final Tree.AttributeSetterDefinition decl) {\n        if(hasErrors(decl))\n            return;\n        int annots = gen.checkCompilerAnnotations(decl);\n        if (Decl.withinClass(decl) && !Decl.isLocalToInitializer(decl)) {\n            classBuilder.attribute(gen.classGen().transform(decl, false));\n        } else if (Decl.withinInterface(decl) && !Decl.isLocalToInitializer(decl)) {\n            classBuilder.attribute(gen.classGen().transform(decl, false));\n            AttributeDefinitionBuilder adb = gen.classGen().transform(decl, true);\n            if (decl.getDeclarationModel().isShared()) {\n                adb.noAnnotations();\n            }\n            classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(adb);\n        } else if (Decl.isToplevel(decl)) {\n        \tif (!Decl.isNative(decl)) {\n        \t\ttopattrBuilder.add(decl);\n        \t}\n        } else {\n            appendList(gen.transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","id":66703,"modified_method":"public void visit(final Tree.AttributeSetterDefinition decl) {\n        if(hasErrors(decl))\n            return;\n        int annots = gen.checkCompilerAnnotations(decl);\n        if (Decl.withinClass(decl) && !Decl.isLocalToInitializer(decl)) {\n            classBuilder.attribute(gen.classGen().transform(decl, false));\n        } else if (Decl.withinInterface(decl)) {\n            classBuilder.attribute(gen.classGen().transform(decl, false));\n            AttributeDefinitionBuilder adb = gen.classGen().transform(decl, true);\n            if (decl.getDeclarationModel().isShared()) {\n                adb.noAnnotations();\n            }\n            classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(adb);\n        } else if (Decl.isToplevel(decl)) {\n        \tif (!Decl.isNative(decl)) {\n        \t\ttopattrBuilder.add(decl);\n        \t}\n        } else {\n            appendList(gen.transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","commit_id":"092449593d2dbfac7b67ef226f515eb2ff523962","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            Address dest = msg.getDest();\n            if(dest == null || dest.isMulticastAddress()){\n                //mcasts\n                FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n                if(fh != null && fh.type == FlushHeader.FLUSH_BYPASS){\n                    return down_prot.down(evt);\n                }\n                else{                   \n                    blockMessageDuringFlush();  \n                }                                     \n            }else{   \n                //unicasts are irrelevant in virtual synchrony, let them through\n                return down_prot.down(evt);\n            }\n            break;\n            \n        case Event.CONNECT:\n        case Event.CONNECT_WITH_STATE_TRANSFER:    \n            sendBlockUpToChannel();\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt, 3, false);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n        }\n        return down_prot.down(evt);\n    }","id":66704,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            Address dest = msg.getDest();\n            if(dest == null || dest.isMulticastAddress()){\n                //mcasts\n                FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n                if(fh != null && fh.type == FlushHeader.FLUSH_BYPASS){\n                    return down_prot.down(evt);\n                }\n                else{                   \n                    blockMessageDuringFlush();  \n                }                                     \n            }else{   \n                //unicasts are irrelevant in virtual synchrony, let them through\n                return down_prot.down(evt);\n            }\n            break;\n            \n        case Event.CONNECT:\n        case Event.CONNECT_WITH_STATE_TRANSFER:    \n            sendBlockUpToChannel();\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n        }\n        return down_prot.down(evt);\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean startFlush() {        \n        return startFlush(new Event(Event.SUSPEND), 3, false);\n    }","id":66705,"modified_method":"public boolean startFlush() {        \n        return startFlush(new Event(Event.SUSPEND));\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if(fh != null){\n                switch(fh.type){\n                    case FlushHeader.FLUSH_BYPASS:\n                        return up_prot.up(evt);                     \n                    case FlushHeader.START_FLUSH:\n                        handleStartFlush(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE:\n                        handleFlushReconcile(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE_OK:\n                        onFlushReconcileOK(msg);\n                        break;\n                    case FlushHeader.STOP_FLUSH:\n                        onStopFlush();\n                        break;\n                    case FlushHeader.ABORT_FLUSH:\n                        synchronized(sharedLock){\n                            flushCompletedMap.clear();\n                        }\n                        flush_promise.setResult(Boolean.FALSE);\n                        break;                               \n                    case FlushHeader.FLUSH_COMPLETED:\n                        if(isCurrentFlushMessage(fh))\n                            onFlushCompleted(msg.getSrc(), fh.digest);\n                        break;\n                }\n                return null; // do not pass FLUSH msg up\n            }else{               \n                // http://jira.jboss.com/jira/browse/JGRP-575\n                // for processing of application messages after we join, \n                // lets wait for STOP_FLUSH to complete\n                // before we start allowing message up.\n                if(!allowMessagesToPassUp)\n                    return null;\n            }\n            break;\n\n        case Event.VIEW_CHANGE:                       \n            /*\n             * [JGRP-618] - FLUSH coordinator transfer reorders\n             * block/unblock/view events in applications (TCP stack only)\n             *                          \n             */\n            up_prot.up(evt);            \n            View newView = (View) evt.getArg();\n            boolean coordinatorLeft = onViewChange(newView);\n            boolean singletonMember = newView.size() == 1 && newView.containsMember(localAddress);\n            boolean isThisOurFirstView = viewCounter.addAndGet(1) == 1;\n            // if this is channel's first view and its the only member of the group - no flush was run\n            // but the channel application should still receive BLOCK,VIEW,UNBLOCK \n            \n            //also if coordinator of flush left each member should run stopFlush individually.\n            if((isThisOurFirstView && singletonMember) || coordinatorLeft){                \n                onStopFlush();              \n            }\n            return null;            \n\n        case Event.TMP_VIEW:\n            /*\n             * April 25, 2007\n             * \n             * Accommodating current NAKACK (1.127)\n             * \n             * Updates field currentView of a leaving coordinator. Leaving\n             * coordinator, after it sends out the view, does not need to\n             * participate in second flush phase.\n             * \n             * see onStopFlush();\n             * \n             * TODO: revisit if still needed post NAKACK 1.127\n             * \n             */\n            View tmpView = (View) evt.getArg();\n            if(!tmpView.containsMember(localAddress)){\n                onViewChange(tmpView);\n            }\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            localAddress = (Address) evt.getArg();\n            break;\n\n        case Event.SUSPECT:\n            onSuspect((Address) evt.getArg());\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt, 3, false);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n\n        }\n\n        return up_prot.up(evt);\n    }","id":66706,"modified_method":"public Object up(Event evt) {\n\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if(fh != null){\n                switch(fh.type){\n                    case FlushHeader.FLUSH_BYPASS:\n                        return up_prot.up(evt);                     \n                    case FlushHeader.START_FLUSH:\n                        handleStartFlush(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE:\n                        handleFlushReconcile(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE_OK:\n                        onFlushReconcileOK(msg);\n                        break;\n                    case FlushHeader.STOP_FLUSH:\n                        onStopFlush();\n                        break;\n                    case FlushHeader.ABORT_FLUSH:\n                        synchronized(sharedLock){\n                            flushCompletedMap.clear();\n                        }\n                        flush_promise.setResult(Boolean.FALSE);\n                        break;                               \n                    case FlushHeader.FLUSH_COMPLETED:\n                        if(isCurrentFlushMessage(fh))\n                            onFlushCompleted(msg.getSrc(), fh.digest);\n                        break;\n                }\n                return null; // do not pass FLUSH msg up\n            }else{               \n                // http://jira.jboss.com/jira/browse/JGRP-575\n                // for processing of application messages after we join, \n                // lets wait for STOP_FLUSH to complete\n                // before we start allowing message up.\n                if(!allowMessagesToPassUp)\n                    return null;\n            }\n            break;\n\n        case Event.VIEW_CHANGE:                       \n            /*\n             * [JGRP-618] - FLUSH coordinator transfer reorders\n             * block/unblock/view events in applications (TCP stack only)\n             *                          \n             */\n            up_prot.up(evt);            \n            View newView = (View) evt.getArg();\n            boolean coordinatorLeft = onViewChange(newView);\n            boolean singletonMember = newView.size() == 1 && newView.containsMember(localAddress);\n            boolean isThisOurFirstView = viewCounter.addAndGet(1) == 1;\n            // if this is channel's first view and its the only member of the group - no flush was run\n            // but the channel application should still receive BLOCK,VIEW,UNBLOCK \n            \n            //also if coordinator of flush left each member should run stopFlush individually.\n            if((isThisOurFirstView && singletonMember) || coordinatorLeft){                \n                onStopFlush();              \n            }\n            return null;            \n\n        case Event.TMP_VIEW:\n            /*\n             * April 25, 2007\n             * \n             * Accommodating current NAKACK (1.127)\n             * \n             * Updates field currentView of a leaving coordinator. Leaving\n             * coordinator, after it sends out the view, does not need to\n             * participate in second flush phase.\n             * \n             * see onStopFlush();\n             * \n             * TODO: revisit if still needed post NAKACK 1.127\n             * \n             */\n            View tmpView = (View) evt.getArg();\n            if(!tmpView.containsMember(localAddress)){\n                onViewChange(tmpView);\n            }\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            localAddress = (Address) evt.getArg();\n            break;\n\n        case Event.SUSPECT:\n            onSuspect((Address) evt.getArg());\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStartFlush(boolean switchedflushCoordinator, Address flushStarter, FlushHeader fh) {             \n        synchronized(blockMutex){\n            isBlockingFlushDown = true;\n        }       \n        if(stats){\n            startFlushTime = System.currentTimeMillis();\n            numberOfFlushes += 1;\n        }\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            flushCoordinator = flushStarter;\n            flushMembers.clear();\n            if(fh.flushParticipants != null){\n                flushMembers.addAll(fh.flushParticipants);\n            }\n            flushMembers.removeAll(suspected);\n            amIParticipant = flushMembers.contains(localAddress);\n        }\n        \n        if(amIParticipant && !switchedflushCoordinator){\n            //ensures that we do not repeat block event\n            //and that we do not send block event to non participants\n            sendBlockUpToChannel();\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but not sending UNBLOCK up\");\n        }\n        if(amIParticipant){                      \n            \n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fhr = new FlushHeader(FlushHeader.FLUSH_COMPLETED, fh.viewID);\n            fhr.addDigest(digest);            \n            \n            Message msg = new Message(flushStarter);\n            msg.putHeader(getName(), fhr);\n            down_prot.down(new Event(Event.MSG, msg));\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but I am not participant, not responding\");\n        }\n    }","id":66707,"modified_method":"private void onStartFlush(boolean switchedflushCoordinator, Address flushStarter, FlushHeader fh) {             \n        synchronized(blockMutex){\n            isBlockingFlushDown = true;\n        }       \n        if(stats){\n            startFlushTime = System.currentTimeMillis();\n            numberOfFlushes += 1;\n        }\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            flushCoordinator = flushStarter;\n            flushMembers.clear();\n            if(fh.flushParticipants != null){\n                flushMembers.addAll(fh.flushParticipants);\n            }\n            flushMembers.removeAll(suspected);\n            amIParticipant = flushMembers.contains(localAddress);\n        }\n        \n        if(amIParticipant && !switchedflushCoordinator){\n            //ensures that we do not repeat block event\n            //and that we do not send block event to non participants\n            sendBlockUpToChannel();\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but not sending UNBLOCK up\");\n        }\n        if(amIParticipant){                      \n            \n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fhr = new FlushHeader(FlushHeader.FLUSH_COMPLETED, fh.viewID);\n            fhr.addDigest(digest);            \n            \n            Message msg = new Message(flushStarter);\n            msg.putHeader(getName(), fhr);\n            down_prot.down(new Event(Event.MSG, msg));\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_COMPLETED\");\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but I am not participant, not responding\");\n        }\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n        Address coordinator = null;\n        boolean proceed = false;\n        Address flushRequester = msg.getSrc();\n        synchronized (sharedLock) {\n            proceed = flushInProgress.compareAndSet(false, true);                     \n            if(proceed){\n                flushCoordinator = flushRequester;\n            }else{                              \n                if(flushCoordinator != null)\n                    coordinator = flushCoordinator;\n                else\n                    coordinator = flushRequester;       \n            }\n        }\n        if(proceed){          \n            onStartFlush(false,flushRequester, fh);\n        } else{           \n            if(flushRequester.compareTo(coordinator) < 0){\n                rejectFlush(fh.viewID, coordinator);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress\n                              + \" to current flush coordinator \"\n                              + coordinator\n                              + \" and switching flush coordinator to \"\n                              + flushRequester);\n                }              \n                onStartFlush(true,flushRequester, fh);\n            }else if(flushRequester.compareTo(coordinator) > 0){\n                rejectFlush(fh.viewID, flushRequester);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress\n                              + \" to flush requester \"\n                              + flushRequester\n                              + \" coordinator is \"\n                              + coordinator);\n                }                \n            }else if(flushRequester.equals(coordinator)){\n                rejectFlush(fh.viewID, flushRequester);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress + \", previous flush has to finish first\");\n                }                \n            }\n        }\n    }","id":66708,"modified_method":"private void handleStartFlush(Message msg, FlushHeader fh) {        \n        boolean proceed = false;\n        Address flushRequester = msg.getSrc();\n        Address abortFlushCoordinator = null;\n        Address proceedFlushCoordinator = null;        \n        \n        synchronized (sharedLock) {\n            proceed = flushInProgress.compareAndSet(false, true);                     \n            if(proceed){\n                flushCoordinator = flushRequester;\n            }else{                                                                                             \n                if(flushRequester.compareTo(flushCoordinator) < 0){                                                           \n                    abortFlushCoordinator = flushCoordinator;\n                    flushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushRequester;                    \n                }else if(flushRequester.compareTo(flushCoordinator) > 0){                                        \n                    abortFlushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushCoordinator;\n                }else{                    \n                    if(log.isDebugEnabled()){\n                        log.debug(\"Rejecting flush at \" + localAddress + \", previous flush has to finish first\");\n                    } \n                    abortFlushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushCoordinator;\n                }\n            }\n        }\n        if(proceed){          \n            onStartFlush(false,flushRequester, fh);\n        } else{  \n            if(log.isDebugEnabled()){\n                log.debug(\"Rejecting flush at \" + localAddress\n                          + \" to flush requester \"\n                          + abortFlushCoordinator\n                          + \" coordinator is \"\n                          + proceedFlushCoordinator);\n            }\n            rejectFlush(fh.viewID, abortFlushCoordinator);\n            onStartFlush(true,proceedFlushCoordinator, fh);\n        }\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Event evt, int numberOfAttempts, boolean isRetry) {\n        boolean successfulFlush = false;\n        if(!flushInProgress.get() || isRetry){\n            flush_promise.reset();                     \n            if(log.isDebugEnabled()){\n                if(isRetry)\n                    log.debug(\"Retrying FLUSH at \" + localAddress\n                              + \", \"\n                              + evt\n                              + \". Attempts left \"\n                              + numberOfAttempts);\n                else\n                    log.debug(\"Received \" + evt + \" at \" + localAddress + \". Running FLUSH...\");\n            }\n\n            onSuspend((View) evt.getArg());\n            try{\n                Boolean r = flush_promise.getResultWithTimeout(start_flush_timeout);\n                successfulFlush = r.booleanValue();\n            }catch(TimeoutException e){\n                if(log.isDebugEnabled())\n                    log.debug(\"At \" + localAddress\n                              + \" timed out waiting for flush responses after \"\n                              + start_flush_timeout\n                            + \" msec\");\n            }\n        }\n\n        if(!successfulFlush && numberOfAttempts > 0){\n            long backOffSleepTime = Util.random(5);\n            backOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2 : backOffSleepTime;\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \". Backing off for \"\n                          + backOffSleepTime\n                          + \" sec. Attempts left \"\n                          + numberOfAttempts);\n\n            Util.sleep(backOffSleepTime*1000);\n            successfulFlush = startFlush(evt, --numberOfAttempts, true);\n        }\n        return successfulFlush;\n    }","id":66709,"modified_method":"private boolean startFlush(Event evt, int numberOfAttempts) {\n        boolean successfulFlush = false;\n        if(!flushInProgress.get()){\n            flush_promise.reset();                                 \n            if(log.isDebugEnabled())\n                log.debug(\"Received \" + evt + \" at \" + localAddress + \". Running FLUSH...\");           \n\n            onSuspend((View) evt.getArg());\n            try{\n                Boolean r = flush_promise.getResultWithTimeout(start_flush_timeout);\n                successfulFlush = r.booleanValue();\n            }catch(TimeoutException e){\n                if(log.isDebugEnabled())\n                    log.debug(\"At \" + localAddress\n                              + \" timed out waiting for flush responses after \"\n                              + start_flush_timeout\n                            + \" msec\");\n            }\n        }\n\n        if(!successfulFlush && numberOfAttempts > 0){                  \n            //we sleep for at most start_flush_timeout and\n            //at least until current flush ends \n            long start_time = System.currentTimeMillis(), backofftime = start_flush_timeout;\n            while (backofftime > 0 && flushInProgress.get()) {\n                Util.sleep(Util.random(5)*1000);\n                backofftime = start_flush_timeout - (System.currentTimeMillis() - start_time);\n            }      \n            if(log.isDebugEnabled()){               \n                log.debug(\"Retrying FLUSH at \" + localAddress\n                          + \", \"\n                          + evt\n                          + \". Attempts left \"\n                          + numberOfAttempts);\n            }\n            successfulFlush = startFlush(evt, --numberOfAttempts);\n        }\n        return successfulFlush;\n    }","commit_id":"cde058ce0765493f81e0886b87ca288371a7172c","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            Address dest = msg.getDest();\n            if(dest == null || dest.isMulticastAddress()){\n                //mcasts\n                FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n                if(fh != null && fh.type == FlushHeader.FLUSH_BYPASS){\n                    return down_prot.down(evt);\n                }\n                else{                   \n                    blockMessageDuringFlush();  \n                }                                     \n            }else{   \n                //unicasts are irrelevant in virtual synchrony, let them through\n                return down_prot.down(evt);\n            }\n            break;\n            \n        case Event.CONNECT:\n        case Event.CONNECT_WITH_STATE_TRANSFER:    \n            sendBlockUpToChannel();\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt, 3, false);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n        }\n        return down_prot.down(evt);\n    }","id":66710,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            Address dest = msg.getDest();\n            if(dest == null || dest.isMulticastAddress()){\n                //mcasts\n                FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n                if(fh != null && fh.type == FlushHeader.FLUSH_BYPASS){\n                    return down_prot.down(evt);\n                }\n                else{                   \n                    blockMessageDuringFlush();  \n                }                                     \n            }else{   \n                //unicasts are irrelevant in virtual synchrony, let them through\n                return down_prot.down(evt);\n            }\n            break;\n            \n        case Event.CONNECT:\n        case Event.CONNECT_WITH_STATE_TRANSFER:    \n            sendBlockUpToChannel();\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n        }\n        return down_prot.down(evt);\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStartFlush(boolean switchedflushCoordinator, Address flushStarter, FlushHeader fh) {             \n        synchronized(blockMutex){\n            isBlockingFlushDown = true;\n        }       \n        if(stats){\n            startFlushTime = System.currentTimeMillis();\n            numberOfFlushes += 1;\n        }\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            flushCoordinator = flushStarter;\n            flushMembers.clear();\n            if(fh.flushParticipants != null){\n                flushMembers.addAll(fh.flushParticipants);\n            }\n            flushMembers.removeAll(suspected);\n            amIParticipant = flushMembers.contains(localAddress);\n        }\n        \n        if(amIParticipant && !switchedflushCoordinator){\n            //ensures that we do not repeat block event\n            //and that we do not send block event to non participants\n            sendBlockUpToChannel();\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but not sending UNBLOCK up\");\n        }\n        if(amIParticipant){                      \n            \n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fhr = new FlushHeader(FlushHeader.FLUSH_COMPLETED, fh.viewID);\n            fhr.addDigest(digest);            \n            \n            Message msg = new Message(flushStarter);\n            msg.putHeader(getName(), fhr);\n            down_prot.down(new Event(Event.MSG, msg));\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but I am not participant, not responding\");\n        }\n    }","id":66711,"modified_method":"private void onStartFlush(boolean switchedflushCoordinator, Address flushStarter, FlushHeader fh) {             \n        synchronized(blockMutex){\n            isBlockingFlushDown = true;\n        }       \n        if(stats){\n            startFlushTime = System.currentTimeMillis();\n            numberOfFlushes += 1;\n        }\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            flushCoordinator = flushStarter;\n            flushMembers.clear();\n            if(fh.flushParticipants != null){\n                flushMembers.addAll(fh.flushParticipants);\n            }\n            flushMembers.removeAll(suspected);\n            amIParticipant = flushMembers.contains(localAddress);\n        }\n        \n        if(amIParticipant && !switchedflushCoordinator){\n            //ensures that we do not repeat block event\n            //and that we do not send block event to non participants\n            sendBlockUpToChannel();\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but not sending UNBLOCK up\");\n        }\n        if(amIParticipant){                      \n            \n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fhr = new FlushHeader(FlushHeader.FLUSH_COMPLETED, fh.viewID);\n            fhr.addDigest(digest);            \n            \n            Message msg = new Message(flushStarter);\n            msg.putHeader(getName(), fhr);\n            down_prot.down(new Event(Event.MSG, msg));\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_COMPLETED\");\n        }\n        else{\n            if(log.isDebugEnabled())\n                log.debug(\"Received START_FLUSH at \" + localAddress + \" but I am not participant, not responding\");\n        }\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n        Address coordinator = null;\n        boolean proceed = false;\n        Address flushRequester = msg.getSrc();\n        synchronized (sharedLock) {\n            proceed = flushInProgress.compareAndSet(false, true);                     \n            if(proceed){\n                flushCoordinator = flushRequester;\n            }else{                              \n                if(flushCoordinator != null)\n                    coordinator = flushCoordinator;\n                else\n                    coordinator = flushRequester;       \n            }\n        }\n        if(proceed){          \n            onStartFlush(false,flushRequester, fh);\n        } else{           \n            if(flushRequester.compareTo(coordinator) < 0){\n                rejectFlush(fh.viewID, coordinator);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress\n                              + \" to current flush coordinator \"\n                              + coordinator\n                              + \" and switching flush coordinator to \"\n                              + flushRequester);\n                }              \n                onStartFlush(true,flushRequester, fh);\n            }else if(flushRequester.compareTo(coordinator) > 0){\n                rejectFlush(fh.viewID, flushRequester);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress\n                              + \" to flush requester \"\n                              + flushRequester\n                              + \" coordinator is \"\n                              + coordinator);\n                }                \n            }else if(flushRequester.equals(coordinator)){\n                rejectFlush(fh.viewID, flushRequester);\n                if(log.isDebugEnabled()){\n                    log.debug(\"Rejecting flush at \" + localAddress + \", previous flush has to finish first\");\n                }                \n            }\n        }\n    }","id":66712,"modified_method":"private void handleStartFlush(Message msg, FlushHeader fh) {        \n        boolean proceed = false;\n        Address flushRequester = msg.getSrc();\n        Address abortFlushCoordinator = null;\n        Address proceedFlushCoordinator = null;        \n        \n        synchronized (sharedLock) {\n            proceed = flushInProgress.compareAndSet(false, true);                     \n            if(proceed){\n                flushCoordinator = flushRequester;\n            }else{                                                                                             \n                if(flushRequester.compareTo(flushCoordinator) < 0){                                                           \n                    abortFlushCoordinator = flushCoordinator;\n                    flushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushRequester;                    \n                }else if(flushRequester.compareTo(flushCoordinator) > 0){                                        \n                    abortFlushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushCoordinator;\n                }else{                    \n                    if(log.isDebugEnabled()){\n                        log.debug(\"Rejecting flush at \" + localAddress + \", previous flush has to finish first\");\n                    } \n                    abortFlushCoordinator = flushRequester;\n                    proceedFlushCoordinator = flushCoordinator;\n                }\n            }\n        }\n        if(proceed){          \n            onStartFlush(false,flushRequester, fh);\n        } else{  \n            if(log.isDebugEnabled()){\n                log.debug(\"Rejecting flush at \" + localAddress\n                          + \" to flush requester \"\n                          + abortFlushCoordinator\n                          + \" coordinator is \"\n                          + proceedFlushCoordinator);\n            }\n            rejectFlush(fh.viewID, abortFlushCoordinator);\n            onStartFlush(true,proceedFlushCoordinator, fh);\n        }\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean startFlush() {        \n        return startFlush(new Event(Event.SUSPEND), 3, false);\n    }","id":66713,"modified_method":"public boolean startFlush() {        \n        return startFlush(new Event(Event.SUSPEND));\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Event evt, int numberOfAttempts, boolean isRetry) {\n        boolean successfulFlush = false;\n        if(!flushInProgress.get() || isRetry){\n            flush_promise.reset();                     \n            if(log.isDebugEnabled()){\n                if(isRetry)\n                    log.debug(\"Retrying FLUSH at \" + localAddress\n                              + \", \"\n                              + evt\n                              + \". Attempts left \"\n                              + numberOfAttempts);\n                else\n                    log.debug(\"Received \" + evt + \" at \" + localAddress + \". Running FLUSH...\");\n            }\n\n            onSuspend((View) evt.getArg());\n            try{\n                Boolean r = flush_promise.getResultWithTimeout(start_flush_timeout);\n                successfulFlush = r.booleanValue();\n            }catch(TimeoutException e){\n                if(log.isDebugEnabled())\n                    log.debug(\"At \" + localAddress\n                              + \" timed out waiting for flush responses after \"\n                              + start_flush_timeout\n                            + \" msec\");\n            }\n        }\n\n        if(!successfulFlush && numberOfAttempts > 0){\n            long backOffSleepTime = Util.random(5);\n            backOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2 : backOffSleepTime;\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \". Backing off for \"\n                          + backOffSleepTime\n                          + \" sec. Attempts left \"\n                          + numberOfAttempts);\n\n            Util.sleep(backOffSleepTime*1000);\n            successfulFlush = startFlush(evt, --numberOfAttempts, true);\n        }\n        return successfulFlush;\n    }","id":66714,"modified_method":"private boolean startFlush(Event evt, int numberOfAttempts) {\n        boolean successfulFlush = false;\n        if(!flushInProgress.get()){\n            flush_promise.reset();                                 \n            if(log.isDebugEnabled())\n                log.debug(\"Received \" + evt + \" at \" + localAddress + \". Running FLUSH...\");           \n\n            onSuspend((View) evt.getArg());\n            try{\n                Boolean r = flush_promise.getResultWithTimeout(start_flush_timeout);\n                successfulFlush = r.booleanValue();\n            }catch(TimeoutException e){\n                if(log.isDebugEnabled())\n                    log.debug(\"At \" + localAddress\n                              + \" timed out waiting for flush responses after \"\n                              + start_flush_timeout\n                            + \" msec\");\n            }\n        }\n\n        if(!successfulFlush && numberOfAttempts > 0){                  \n            //we sleep for at most start_flush_timeout and\n            //at least until current flush ends \n            long start_time = System.currentTimeMillis(), backofftime = start_flush_timeout;\n            while (backofftime > 0 && flushInProgress.get()) {\n                Util.sleep(Util.random(5)*1000);\n                backofftime = start_flush_timeout - (System.currentTimeMillis() - start_time);\n            }      \n            if(log.isDebugEnabled()){               \n                log.debug(\"Retrying FLUSH at \" + localAddress\n                          + \", \"\n                          + evt\n                          + \". Attempts left \"\n                          + numberOfAttempts);\n            }\n            successfulFlush = startFlush(evt, --numberOfAttempts);\n        }\n        return successfulFlush;\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if(fh != null){\n                switch(fh.type){\n                    case FlushHeader.FLUSH_BYPASS:\n                        return up_prot.up(evt);                     \n                    case FlushHeader.START_FLUSH:\n                        handleStartFlush(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE:\n                        handleFlushReconcile(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE_OK:\n                        onFlushReconcileOK(msg);\n                        break;\n                    case FlushHeader.STOP_FLUSH:\n                        onStopFlush();\n                        break;\n                    case FlushHeader.ABORT_FLUSH:\n                        synchronized(sharedLock){\n                            flushCompletedMap.clear();\n                        }\n                        flush_promise.setResult(Boolean.FALSE);\n                        break;                               \n                    case FlushHeader.FLUSH_COMPLETED:\n                        if(isCurrentFlushMessage(fh))\n                            onFlushCompleted(msg.getSrc(), fh.digest);\n                        break;\n                }\n                return null; // do not pass FLUSH msg up\n            }else{               \n                // http://jira.jboss.com/jira/browse/JGRP-575\n                // for processing of application messages after we join, \n                // lets wait for STOP_FLUSH to complete\n                // before we start allowing message up.\n                if(!allowMessagesToPassUp)\n                    return null;\n            }\n            break;\n\n        case Event.VIEW_CHANGE:                       \n            /*\n             * [JGRP-618] - FLUSH coordinator transfer reorders\n             * block/unblock/view events in applications (TCP stack only)\n             *                          \n             */\n            up_prot.up(evt);            \n            View newView = (View) evt.getArg();\n            boolean coordinatorLeft = onViewChange(newView);\n            boolean singletonMember = newView.size() == 1 && newView.containsMember(localAddress);\n            boolean isThisOurFirstView = viewCounter.addAndGet(1) == 1;\n            // if this is channel's first view and its the only member of the group - no flush was run\n            // but the channel application should still receive BLOCK,VIEW,UNBLOCK \n            \n            //also if coordinator of flush left each member should run stopFlush individually.\n            if((isThisOurFirstView && singletonMember) || coordinatorLeft){                \n                onStopFlush();              \n            }\n            return null;            \n\n        case Event.TMP_VIEW:\n            /*\n             * April 25, 2007\n             * \n             * Accommodating current NAKACK (1.127)\n             * \n             * Updates field currentView of a leaving coordinator. Leaving\n             * coordinator, after it sends out the view, does not need to\n             * participate in second flush phase.\n             * \n             * see onStopFlush();\n             * \n             * TODO: revisit if still needed post NAKACK 1.127\n             * \n             */\n            View tmpView = (View) evt.getArg();\n            if(!tmpView.containsMember(localAddress)){\n                onViewChange(tmpView);\n            }\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            localAddress = (Address) evt.getArg();\n            break;\n\n        case Event.SUSPECT:\n            onSuspect((Address) evt.getArg());\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt, 3, false);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n\n        }\n\n        return up_prot.up(evt);\n    }","id":66715,"modified_method":"public Object up(Event evt) {\n\n        switch(evt.getType()){\n        case Event.MSG:\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if(fh != null){\n                switch(fh.type){\n                    case FlushHeader.FLUSH_BYPASS:\n                        return up_prot.up(evt);                     \n                    case FlushHeader.START_FLUSH:\n                        handleStartFlush(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE:\n                        handleFlushReconcile(msg, fh);\n                        break;\n                    case FlushHeader.FLUSH_RECONCILE_OK:\n                        onFlushReconcileOK(msg);\n                        break;\n                    case FlushHeader.STOP_FLUSH:\n                        onStopFlush();\n                        break;\n                    case FlushHeader.ABORT_FLUSH:\n                        synchronized(sharedLock){\n                            flushCompletedMap.clear();\n                        }\n                        flush_promise.setResult(Boolean.FALSE);\n                        break;                               \n                    case FlushHeader.FLUSH_COMPLETED:\n                        if(isCurrentFlushMessage(fh))\n                            onFlushCompleted(msg.getSrc(), fh.digest);\n                        break;\n                }\n                return null; // do not pass FLUSH msg up\n            }else{               \n                // http://jira.jboss.com/jira/browse/JGRP-575\n                // for processing of application messages after we join, \n                // lets wait for STOP_FLUSH to complete\n                // before we start allowing message up.\n                if(!allowMessagesToPassUp)\n                    return null;\n            }\n            break;\n\n        case Event.VIEW_CHANGE:                       \n            /*\n             * [JGRP-618] - FLUSH coordinator transfer reorders\n             * block/unblock/view events in applications (TCP stack only)\n             *                          \n             */\n            up_prot.up(evt);            \n            View newView = (View) evt.getArg();\n            boolean coordinatorLeft = onViewChange(newView);\n            boolean singletonMember = newView.size() == 1 && newView.containsMember(localAddress);\n            boolean isThisOurFirstView = viewCounter.addAndGet(1) == 1;\n            // if this is channel's first view and its the only member of the group - no flush was run\n            // but the channel application should still receive BLOCK,VIEW,UNBLOCK \n            \n            //also if coordinator of flush left each member should run stopFlush individually.\n            if((isThisOurFirstView && singletonMember) || coordinatorLeft){                \n                onStopFlush();              \n            }\n            return null;            \n\n        case Event.TMP_VIEW:\n            /*\n             * April 25, 2007\n             * \n             * Accommodating current NAKACK (1.127)\n             * \n             * Updates field currentView of a leaving coordinator. Leaving\n             * coordinator, after it sends out the view, does not need to\n             * participate in second flush phase.\n             * \n             * see onStopFlush();\n             * \n             * TODO: revisit if still needed post NAKACK 1.127\n             * \n             */\n            View tmpView = (View) evt.getArg();\n            if(!tmpView.containsMember(localAddress)){\n                onViewChange(tmpView);\n            }\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            localAddress = (Address) evt.getArg();\n            break;\n\n        case Event.SUSPECT:\n            onSuspect((Address) evt.getArg());\n            break;\n\n        case Event.SUSPEND:\n            return startFlush(evt);\n\n        case Event.RESUME:\n            onResume();\n            return null;\n\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"17c4ac0a76cbc76cba0f7773018fbe75935fb257","url":"https://github.com/belaban/JGroups"},{"original_method":"public Expression transform(Interpolation interpolation, MarkupContext markupContext, ExpressionContext expressionContext) {\n        ArrayList<ExpressionNode> nodes = new ArrayList<ExpressionNode>();\n        HashMap<String, ExpressionNode> options = new HashMap<String, ExpressionNode>();\n        for (Fragment fragment : interpolation.getFragments()) {\n            if (fragment.isString()) {\n                nodes.add(new StringConstant(fragment.getText()));\n            } else {\n                Expression expression = fragment.getExpression();\n                nodes.add(adjustToContext(expression, markupContext, expressionContext).getRoot());\n                options.putAll(expression.getOptions());\n            }\n        }\n        ExpressionNode root = join(nodes);\n        if (interpolation.size() > 1 && options.containsKey(Syntax.CONTEXT_OPTION)) {\n            //context must not be calculated by merging\n            options.remove(Syntax.CONTEXT_OPTION);\n        }\n        return new Expression(root, options);\n    }","id":66716,"modified_method":"public Expression transform(Interpolation interpolation, MarkupContext markupContext, ExpressionContext expressionContext) {\n        ArrayList<ExpressionNode> nodes = new ArrayList<ExpressionNode>();\n        HashMap<String, ExpressionNode> options = new HashMap<String, ExpressionNode>();\n        for (Fragment fragment : interpolation.getFragments()) {\n            if (fragment.isString()) {\n                nodes.add(new StringConstant(fragment.getText()));\n            } else {\n                Expression expression = fragment.getExpression();\n                Expression transformed = adjustToContext(expression, markupContext, expressionContext);\n                nodes.add(transformed.getRoot());\n                options.putAll(transformed.getOptions());\n            }\n        }\n        ExpressionNode root = join(nodes);\n        if (interpolation.size() > 1 && options.containsKey(Syntax.CONTEXT_OPTION)) {\n            //context must not be calculated by merging\n            options.remove(Syntax.CONTEXT_OPTION);\n        }\n        return new Expression(root, options);\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        //todo: if the expression is a string constant, we can produce the transformation at\n        //compile time, with no need of a runtime function\n        if (!expression.containsOption(FORMAT_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode argNode = expression.getOption(FORMAT_OPTION);\n        ExpressionNode formattedNode = new RuntimeCall(FORMAT_FUNCTION, expression.getRoot(), argNode);\n        return expression.withNode(formattedNode).withRemovedOptions(FORMAT_OPTION);\n    }","id":66717,"modified_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        //todo: if the expression is a string constant, we can produce the transformation at\n        //compile time, with no need of a runtime function\n        if (!expression.containsOption(FORMAT_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode translation = new RuntimeCall(FORMAT_FUNCTION, expression.getRoot(), expression.removeOption(FORMAT_OPTION));\n        return expression.withNode(translation);\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (!expression.containsOption(I18N_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode translation = new RuntimeCall(FUNCTION, expression.getRoot(), new MapLiteral(expression.getOptions()));\n        return expression.withNode(translation).withRemovedOptions(HINT_OPTION, LOCALE_OPTION);\n    }","id":66718,"modified_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (!expression.containsOption(I18N_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode translation = new RuntimeCall(FUNCTION, expression.getRoot(), new MapLiteral(getFilterOptions(expression,\n                HINT_OPTION, LOCALE_OPTION)));\n        expression.removeOption(I18N_OPTION);\n        return expression.withNode(translation);\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (!expression.containsOption(JOIN_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode argumentNode = expression.getOption(JOIN_OPTION);\n        ExpressionNode joinResult = new RuntimeCall(JOIN_FUNCTION, expression.getRoot(), argumentNode);\n        return expression.withNode(joinResult).withRemovedOptions(JOIN_OPTION);\n    }","id":66719,"modified_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (!expression.containsOption(JOIN_OPTION) || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext\n                == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode translation = new RuntimeCall(JOIN_FUNCTION, expression.getRoot(), expression.removeOption(JOIN_OPTION));\n        return expression.withNode(translation);\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Object call(final RenderContext renderContext, Object... arguments) {\n        if (arguments.length != 2) {\n            throw new SightlyException(\"Join function must be called with two arguments.\");\n        }\n        Object joinArgument = arguments[0];\n        Collection<?> collection = RenderUtils.toCollection(joinArgument);\n        if (joinArgument != null && collection.isEmpty()) {\n            collection = Arrays.asList(new Object[] {\n                joinArgument\n            });\n        }\n        String joinString = RenderUtils.toString(arguments[1]);\n        return join(collection, joinString);\n    }","id":66720,"modified_method":"@Override\n    public Object call(final RenderContext renderContext, Object... arguments) {\n        if (arguments.length != 2) {\n            throw new SightlyException(\"Join function must be called with two arguments.\");\n        }\n        Object joinArgument = arguments[0];\n        Collection<?> collection = RenderUtils.toCollection(joinArgument);\n        String joinString = RenderUtils.toString(arguments[1]);\n        return join(collection, joinString);\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if ((expression.containsOption(SCHEME) || expression.containsOption(DOMAIN) || expression.containsOption(PATH) || expression\n                .containsOption(APPEND_PATH) || expression.containsOption(PREPEND_PATH) || expression.containsOption(SELECTORS) ||\n                expression.containsOption(ADD_SELECTORS) || expression.containsOption(REMOVE_SELECTORS) || expression.containsOption\n                (EXTENSION) || expression.containsOption(SUFFIX) || expression.containsOption(PREPEND_SUFFIX) || expression\n                .containsOption(APPEND_SUFFIX) || expression.containsOption(FRAGMENT) || expression.containsOption(QUERY) || expression\n                .containsOption(ADD_QUERY) || expression.containsOption(REMOVE_QUERY)) && expressionContext != ExpressionContext\n                .PLUGIN_DATA_SLY_USE && expressionContext\n                != ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE && expressionContext != ExpressionContext.PLUGIN_DATA_SLY_CALL &&\n                expressionContext != ExpressionContext.PLUGIN_DATA_SLY_RESOURCE) {\n            Map<String, ExpressionNode> uriOptions = new HashMap<String, ExpressionNode>();\n            collectOptions(expression, uriOptions, SCHEME, DOMAIN, PATH, APPEND_PATH, PREPEND_PATH, SELECTORS, ADD_SELECTORS,\n                    REMOVE_SELECTORS, EXTENSION, SUFFIX, PREPEND_SUFFIX, APPEND_SUFFIX, FRAGMENT, QUERY, ADD_QUERY, REMOVE_QUERY);\n            if (uriOptions.size() > 0) {\n                ExpressionNode translation = new RuntimeCall(URI_MANIPULATION_FUNCTION, expression.getRoot(), new MapLiteral(uriOptions));\n                return expression.withNode(translation);\n            }\n        }\n        return expression;\n    }","id":66721,"modified_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if ((expression.containsOption(SCHEME) || expression.containsOption(DOMAIN) || expression.containsOption(PATH) || expression\n                .containsOption(APPEND_PATH) || expression.containsOption(PREPEND_PATH) || expression.containsOption(SELECTORS) ||\n                expression.containsOption(ADD_SELECTORS) || expression.containsOption(REMOVE_SELECTORS) || expression.containsOption\n                (EXTENSION) || expression.containsOption(SUFFIX) || expression.containsOption(PREPEND_SUFFIX) || expression\n                .containsOption(APPEND_SUFFIX) || expression.containsOption(FRAGMENT) || expression.containsOption(QUERY) || expression\n                .containsOption(ADD_QUERY) || expression.containsOption(REMOVE_QUERY)) && expressionContext != ExpressionContext\n                .PLUGIN_DATA_SLY_USE && expressionContext\n                != ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE && expressionContext != ExpressionContext.PLUGIN_DATA_SLY_CALL &&\n                expressionContext != ExpressionContext.PLUGIN_DATA_SLY_RESOURCE) {\n            Map<String, ExpressionNode> uriOptions = getFilterOptions(expression, SCHEME, DOMAIN, PATH, APPEND_PATH, PREPEND_PATH,\n                    SELECTORS, ADD_SELECTORS, REMOVE_SELECTORS, EXTENSION, SUFFIX, PREPEND_SUFFIX, APPEND_SUFFIX, FRAGMENT, QUERY,\n                    ADD_QUERY, REMOVE_QUERY);\n            if (uriOptions.size() > 0) {\n                ExpressionNode translation = new RuntimeCall(URI_MANIPULATION_FUNCTION, expression.getRoot(), new MapLiteral(uriOptions));\n                return expression.withNode(translation);\n            }\n        }\n        return expression;\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE\n                || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode node = expression.getRoot();\n        Map<String, ExpressionNode> options = expression.getOptions();\n        ExpressionNode context = options.get(Syntax.CONTEXT_OPTION);\n        if (context != null) {\n            return new Expression(new RuntimeCall(FUNCTION_NAME, node, context), options);\n        }\n        return expression;\n    }","id":66722,"modified_method":"@Override\n    public Expression apply(Expression expression, ExpressionContext expressionContext) {\n        if (expressionContext == ExpressionContext.PLUGIN_DATA_SLY_USE || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_TEMPLATE\n                || expressionContext == ExpressionContext.PLUGIN_DATA_SLY_CALL) {\n            return expression;\n        }\n        ExpressionNode context = expression.removeOption(Syntax.CONTEXT_OPTION);\n        if (context != null) {\n            return expression.withNode(new RuntimeCall(FUNCTION_NAME, expression.getRoot(), context));\n        }\n        return expression;\n    }","commit_id":"dda29856f90cc4f86c88dc6ac86a6e8161133e40","url":"https://github.com/apache/sling"},{"original_method":"RecoveryEnvironmentElement parseRecoveryEnvironmentElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final RecoveryEnvironmentElement element = new RecoveryEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        element.setBindingRef(value);\n                        break;\n                    case STATUS_BINDING:\n                        element.setStatusBindingRef(value);\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(element.getBindingRef() == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(Attribute.BINDING));\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","id":66723,"modified_method":"void parseRecoveryEnvironmentElement(XMLExtendedStreamReader reader, final TransactionSubsystemAdd add) throws XMLStreamException {\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        add.setRecoveryBindingName(value);\n                        break;\n                    case STATUS_BINDING:\n                        add.setRecoveryStatusBindingName(value);\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(add.getBindingName() == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(Attribute.BINDING));\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"ObjectStoreEnvironmentElement parseObjectStoreEnvironmentElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ObjectStoreEnvironmentElement element = new ObjectStoreEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case DIRECTORY:\n                        element.setDirectory(value);\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","id":66724,"modified_method":"ObjectStoreEnvironmentElement parseObjectStoreEnvironmentElement(XMLExtendedStreamReader reader, final TransactionSubsystemAdd add) throws XMLStreamException {\n        final ObjectStoreEnvironmentElement element = new ObjectStoreEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case DIRECTORY:\n                        element.setDirectory(value);\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"CoordinatorEnvironmentElement parseCoordinatorEnvironmentElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final CoordinatorEnvironmentElement element = new CoordinatorEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        element.setEnableStatistics(Boolean.parseBoolean(value));\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        element.setDefaultTimeout(Integer.parseInt(value));\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","id":66725,"modified_method":"CoordinatorEnvironmentElement parseCoordinatorEnvironmentElement(XMLExtendedStreamReader reader, final TransactionSubsystemAdd add) throws XMLStreamException {\n        final CoordinatorEnvironmentElement element = new CoordinatorEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        element.setEnableStatistics(Boolean.parseBoolean(value));\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        element.setDefaultTimeout(Integer.parseInt(value));\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"CoreEnvironmentElement parseCoreEnvironmentElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final CoreEnvironmentElement element = new CoreEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        element.setBindingRef(value);\n                        break;\n                    case NODE_IDENTIFIER:\n                        element.setNodeIdentifier(value);\n                        break;\n                    case SOCKET_PROCESS_ID_MAX_PORTS:\n                        element.setMaxPorts(Integer.parseInt(value));\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(element.getBindingRef() == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(Attribute.BINDING));\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","id":66726,"modified_method":"CoreEnvironmentElement parseCoreEnvironmentElement(XMLExtendedStreamReader reader, final TransactionSubsystemAdd add) throws XMLStreamException {\n        final CoreEnvironmentElement element = new CoreEnvironmentElement();\n        final int count = reader.getAttributeCount();\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.BINDING);\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case BINDING:\n                        add.setBindingName(value);\n                        break;\n                    case NODE_IDENTIFIER:\n                        add.setNodeIdentifier(value);\n                        break;\n                    case SOCKET_PROCESS_ID_MAX_PORTS:\n                        add.setMaxPorts(Integer.parseInt(value));\n                        break;\n                    default:\n                        ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if (! required.isEmpty()) {\n            ParseUtils.missingRequired(reader, required);\n        }\n        // Handle elements\n        ParseUtils.requireNoContent(reader);\n        return element;\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void readElement(XMLExtendedStreamReader reader, List<? super AbstractSubsystemUpdate<TransactionsSubsystemElement, ?>> updates)\n            throws XMLStreamException {\n        // no attributes\n        if (reader.getAttributeCount() > 0) {\n            throw ParseUtils.unexpectedAttribute(reader, 0);\n        }\n\n        RecoveryEnvironmentElement recoveryEnvironmentElement = null;\n        CoreEnvironmentElement coreEnvironmentElement = null;\n        CoordinatorEnvironmentElement coordinatorEnvironmentElement = null;\n        ObjectStoreEnvironmentElement objectStoreEnvironmentElement = null;\n\n        // elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case TRANSACTIONS_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case RECOVERY_ENVIRONMENT: {\n                            recoveryEnvironmentElement = parseRecoveryEnvironmentElement(reader);\n                            break;\n                        }\n                        case CORE_ENVIRONMENT: {\n                            coreEnvironmentElement = parseCoreEnvironmentElement(reader);\n                            break;\n                        }\n                        case COORDINATOR_ENVIRONMENT: {\n                            coordinatorEnvironmentElement = parseCoordinatorEnvironmentElement(reader);\n                            break;\n                        }\n                        case OBJECT_STORE: {\n                            objectStoreEnvironmentElement = parseObjectStoreEnvironmentElement(reader);\n                            break;\n                        }\n                        default: {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        if(recoveryEnvironmentElement == null) {\n            throw ParseUtils.missingRequiredElement(reader, Collections.singleton(Element.RECOVERY_ENVIRONMENT.getLocalName()));\n        }\n        if(coreEnvironmentElement == null) {\n            throw ParseUtils.missingRequiredElement(reader, Collections.singleton(Element.CORE_ENVIRONMENT.getLocalName()));\n        }\n        if(coordinatorEnvironmentElement == null) {\n            coordinatorEnvironmentElement = new CoordinatorEnvironmentElement();\n        }\n        if(objectStoreEnvironmentElement == null) {\n            objectStoreEnvironmentElement = new ObjectStoreEnvironmentElement();\n        }\n\n        final TransactionSubsystemElementUpdate update = new TransactionSubsystemElementUpdate();\n        update.setRecoveryEnvironmentElement(recoveryEnvironmentElement);\n        update.setCoreEnvironmentElement(coreEnvironmentElement);\n        update.setCoordinatorEnvironmentElement(coordinatorEnvironmentElement);\n        update.setObjectStoreEnvironmentElement(objectStoreEnvironmentElement);\n        // Add the transtaction subsystem update\n        updates.add(update);\n    }","id":66727,"modified_method":"/** {@inheritDoc} */\n    public void readElement(final XMLExtendedStreamReader reader, final ParseResult<ExtensionContext.SubsystemConfiguration<TransactionsSubsystemElement>> result) throws XMLStreamException {\n\n        List<AbstractSubsystemUpdate<TransactionsSubsystemElement, ?>> updates = new ArrayList<AbstractSubsystemUpdate<TransactionsSubsystemElement,?>>();\n\n        // no attributes\n        if (reader.getAttributeCount() > 0) {\n            throw ParseUtils.unexpectedAttribute(reader, 0);\n        }\n        final TransactionSubsystemAdd add = new TransactionSubsystemAdd();\n\n        // elements\n        final EnumSet<Element> required = EnumSet.of(Element.RECOVERY_ENVIRONMENT, Element.CORE_ENVIRONMENT);\n        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case TRANSACTIONS_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    required.remove(element);\n                    if (! encountered.add(element)) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case RECOVERY_ENVIRONMENT: {\n                            parseRecoveryEnvironmentElement(reader, add);\n                            break;\n                        }\n                        case CORE_ENVIRONMENT: {\n                            parseCoreEnvironmentElement(reader, add);\n                            break;\n                        }\n                        case COORDINATOR_ENVIRONMENT: {\n                            parseCoordinatorEnvironmentElement(reader, add);\n                            break;\n                        }\n                        case OBJECT_STORE: {\n                            parseObjectStoreEnvironmentElement(reader, add);\n                            break;\n                        }\n                        default: {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        if (! required.isEmpty()) {\n            throw ParseUtils.missingRequiredElement(reader, required);\n        }\n\n        result.setResult(new ExtensionContext.SubsystemConfiguration<TransactionsSubsystemElement>(add, updates));\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    protected boolean isEmpty() {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":66728,"modified_method":"/** {@inheritDoc} */\n    protected boolean isEmpty() {\n        return true;\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyRemove(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> resultHandler, final P param) {\n    }","id":66729,"modified_method":"protected <P> void applyRemove(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> resultHandler, final P param) {\n        final ServiceContainer container = updateContext.getServiceContainer();\n        final ServiceController<?> tmController = container.getService(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER);\n        tmController.setMode(ServiceController.Mode.REMOVE);\n        final ServiceController<?> xaController = container.getService(TxnServices.JBOSS_TXN_XA_TERMINATOR);\n        xaController.setMode(ServiceController.Mode.REMOVE);\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected AbstractSubsystemAdd<TransactionsSubsystemElement> getAdd() {\n        return null;\n    }","id":66730,"modified_method":"protected TransactionSubsystemAdd getAdd() {\n        final TransactionSubsystemAdd add = new TransactionSubsystemAdd();\n        add.setBindingName(coreEnvironmentElement.getBindingRef());\n        return add;\n    }","commit_id":"b2e9d9d385bb1f89756e25d3206f8c6e7668b04d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        final boolean coordinatorEnableStatistics = operation.get(ENABLE_STATISTICS).asBoolean(true);\n        final boolean transactionStatusManagerEnable = operation.get(ENABLE_TSM_STATUS).asBoolean(false);\n        final int coordinatorDefaultTimeout = operation.get(DEFAULT_TIMEOUT).asInt(300);\n\n        final ArjunaTransactionManagerService transactionManagerService = new ArjunaTransactionManagerService(coordinatorEnableStatistics, coordinatorDefaultTimeout, transactionStatusManagerEnable);\n        controllers.add(context.getServiceTarget().addService(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER, transactionManagerService)\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"iiop\", \"orb\"), ORB.class, transactionManagerService.getOrbInjector())\n                .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class, transactionManagerService.getXaTerminatorInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT)\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER)\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n\n\n    }","id":66731,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode coordEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        final boolean coordinatorEnableStatistics = ENABLE_STATISTICS.validateResolvedOperation(coordEnvModel).asBoolean();\n        final boolean transactionStatusManagerEnable = ENABLE_TSM_STATUS.validateResolvedOperation(coordEnvModel).asBoolean();\n        final int coordinatorDefaultTimeout = DEFAULT_TIMEOUT.validateResolvedOperation(coordEnvModel).asInt();\n\n        final ArjunaTransactionManagerService transactionManagerService = new ArjunaTransactionManagerService(coordinatorEnableStatistics, coordinatorDefaultTimeout, transactionStatusManagerEnable);\n        controllers.add(context.getServiceTarget().addService(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER, transactionManagerService)\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"iiop\", \"orb\"), ORB.class, transactionManagerService.getOrbInjector())\n                .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class, transactionManagerService.getXaTerminatorInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT)\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER)\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n\n\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        return Descriptions.getRecoveryEnvironmentAddDescription(locale);\n    }","id":66732,"modified_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        return Descriptions.getCoordinatorEnvironmentAddDescription(locale);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode coreEnvModel) throws OperationFailedException {\n        final boolean coordinatorEnableStatistics = operation.get(ENABLE_STATISTICS).asBoolean(true);\n        final boolean transactionStatusManagerEnable = operation.get(ENABLE_TSM_STATUS).asBoolean(false);\n        final int coordinatorDefaultTimeout = operation.get(DEFAULT_TIMEOUT).asInt(300);\n\n\n        coreEnvModel.get(ENABLE_STATISTICS).set(coordinatorEnableStatistics);\n        coreEnvModel.get(ENABLE_TSM_STATUS).set(transactionStatusManagerEnable);\n        coreEnvModel.get(DEFAULT_TIMEOUT).set(coordinatorDefaultTimeout);  // store the default so we write it -- TODO store all the defaults\n\n\n    }","id":66733,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode coordEnvModel) throws OperationFailedException {\n        ENABLE_STATISTICS.validateAndSet(operation, coordEnvModel);\n        ENABLE_TSM_STATUS.validateAndSet(operation, coordEnvModel);\n        DEFAULT_TIMEOUT.validateAndSet(operation, coordEnvModel);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        return Descriptions.getRecoveryEnvironmentAddDescription(locale);\n    }","id":66734,"modified_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        return Descriptions.getCoreEnvironmentAddDescription(locale);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode coreEnvModel) throws OperationFailedException {\n        final String nodeIdentifier = operation.hasDefined(NODE_IDENTIFIER) ? operation.get(NODE_IDENTIFIER).asString() : \"1\";\n        final ModelNode processId = operation.require(PROCESS_ID);\n\n        coreEnvModel.get(PROCESS_ID).set(operation.get(PROCESS_ID));\n        coreEnvModel.get(NODE_IDENTIFIER).set(nodeIdentifier);\n\n\n    }","id":66735,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode coreEnvModel) throws OperationFailedException {\n\n        NODE_IDENTIFIER.validateAndSet(operation, coreEnvModel);\n        PATH.validateAndSet(operation, coreEnvModel);\n        RELATIVE_TO.validateAndSet(operation, coreEnvModel);\n\n        // We have some complex logic for the 'process-id' stuff because of the alternatives\n        if (operation.hasDefined(PROCESS_ID_UUID.getName()) && operation.get(PROCESS_ID_UUID.getName()).asBoolean()) {\n            PROCESS_ID_UUID.validateAndSet(operation, coreEnvModel);\n            if (operation.hasDefined(PROCESS_ID_SOCKET_BINDING.getName())) {\n                throw new OperationFailedException(new ModelNode().set(String.format(\"%s must be undefined if %s is 'true'.\",\n                        PROCESS_ID_SOCKET_BINDING.getName(), PROCESS_ID_UUID.getName())));\n            } else if (operation.hasDefined(PROCESS_ID_SOCKET_MAX_PORTS.getName())) {\n                throw new OperationFailedException(new ModelNode().set(String.format(\"%s must be undefined if %s is 'true'.\",\n                        PROCESS_ID_SOCKET_MAX_PORTS.getName(), PROCESS_ID_UUID.getName())));\n            }\n            coreEnvModel.get(PROCESS_ID_SOCKET_BINDING.getName());\n            coreEnvModel.get(PROCESS_ID_SOCKET_MAX_PORTS.getName());\n        } else if (operation.hasDefined(PROCESS_ID_SOCKET_BINDING.getName())) {\n            PROCESS_ID_SOCKET_BINDING.validateAndSet(operation, coreEnvModel);\n            PROCESS_ID_SOCKET_MAX_PORTS.validateAndSet(operation, coreEnvModel);\n            coreEnvModel.get(PROCESS_ID_UUID.getName()).set(false);\n        } else if (operation.hasDefined(PROCESS_ID_SOCKET_MAX_PORTS.getName())) {\n            throw new OperationFailedException(new ModelNode().set(String.format(\"%s must be defined if %s is defined.\",\n                    PROCESS_ID_SOCKET_BINDING.getName(), PROCESS_ID_SOCKET_MAX_PORTS.getName())));\n        } else {\n            // not uuid and also not sockets!\n            throw new OperationFailedException(new ModelNode().set(String.format(\"Either %s must be 'true' or  %s must be defined.\",\n                    PROCESS_ID_UUID.getName(), PROCESS_ID_SOCKET_BINDING.getName())));\n        }\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        final String nodeIdentifier = operation.hasDefined(NODE_IDENTIFIER) ? operation.get(NODE_IDENTIFIER).asString() : \"1\";\n        final ModelNode processId = operation.hasDefined(PROCESS_ID) ? operation.get(PROCESS_ID) : new ModelNode();\n        final String varDirPathRef = operation.hasDefined(RELATIVE_TO) ? operation.get(RELATIVE_TO).asString() : \"jboss.server.data.dir\";\n        final String varDirPath = operation.hasDefined(PATH) ? operation.get(PATH).asString() : \"var\";\n        final int maxPorts = 10;\n\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", nodeIdentifier);\n            ROOT_LOGGER.debugf(\"varDirPathRef=%s, varDirPath=%s\\n\", varDirPathRef, varDirPath);\n\n        }\n\n        // Configure the core configuration.\n        String socketBindingName = null;\n        final CoreEnvironmentService coreEnvironmentService = new CoreEnvironmentService(nodeIdentifier, varDirPath);\n        if (processId.hasDefined(ProcessIdType.UUID.getName())) {\n            // Use the UUID based id\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        } else if (processId.hasDefined(ProcessIdType.SOCKET.getName())) {\n            // Use the socket process id\n            coreEnvironmentService.setProcessImplementationClassName(ProcessIdType.SOCKET.getClazz());\n            ModelNode socket = processId.get(ProcessIdType.SOCKET.getName());\n            socketBindingName = socket.require(BINDING).asString();\n            if (socket.hasDefined(SOCKET_PROCESS_ID_MAX_PORTS)) {\n                int ports = socket.get(SOCKET_PROCESS_ID_MAX_PORTS).asInt(maxPorts);\n                coreEnvironmentService.setSocketProcessIdMaxPorts(ports);\n            }\n        } else {\n            // Default to UUID implementation\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        }\n        ServiceBuilder<?> coreEnvBuilder = context.getServiceTarget().addService(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, coreEnvironmentService);\n        if (socketBindingName != null) {\n            // Add a dependency on the socket id binding\n            ServiceName bindingName = SocketBinding.JBOSS_BINDING_NAME.append(socketBindingName);\n            coreEnvBuilder.addDependency(bindingName, SocketBinding.class, coreEnvironmentService.getSocketProcessBindingInjector());\n        }\n        ServiceController<String> varDirRPS = RelativePathService.addService(INTERNAL_CORE_ENV_VAR_PATH, varDirPath, varDirPathRef, context.getServiceTarget());\n        controllers.add(varDirRPS);\n        controllers.add(coreEnvBuilder.addDependency(varDirRPS.getName(), String.class, coreEnvironmentService.getPathInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n    }","id":66736,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode coreEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        // Configure the core configuration.\n        final String nodeIdentifier = NODE_IDENTIFIER.validateResolvedOperation(coreEnvModel).asString();\n        final CoreEnvironmentService coreEnvironmentService = new CoreEnvironmentService(nodeIdentifier);\n\n        String socketBindingName = null;\n        if (PROCESS_ID_UUID.validateResolvedOperation(coreEnvModel).asBoolean()) {\n            // Use the UUID based id\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        } else {\n            // Use the socket process id\n            coreEnvironmentService.setProcessImplementationClassName(ProcessIdType.SOCKET.getClazz());\n            socketBindingName = PROCESS_ID_SOCKET_BINDING.validateResolvedOperation(coreEnvModel).asString();\n            int ports = PROCESS_ID_SOCKET_MAX_PORTS.validateResolvedOperation(coreEnvModel).asInt();\n            coreEnvironmentService.setSocketProcessIdMaxPorts(ports);\n        }\n\n        String varDirPathRef = null;\n        // Check for empty string value for relative-to, which disables the default\n        final ModelNode relativePathNode = coreEnvModel.get(RELATIVE_TO.getName());\n        if (!relativePathNode.isDefined() || relativePathNode.asString().length() > 0) {\n            varDirPathRef = RELATIVE_TO.validateResolvedOperation(coreEnvModel).asString();\n        }\n        final String varDirPath = PATH.validateResolvedOperation(coreEnvModel).asString();\n\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", nodeIdentifier);\n            ROOT_LOGGER.debugf(\"varDirPathRef=%s, varDirPath=%s\\n\", varDirPathRef, varDirPath);\n        }\n\n        ServiceTarget target = context.getServiceTarget();\n        ServiceController<String> varDirRPS = varDirPathRef != null\n                ? RelativePathService.addService(INTERNAL_CORE_ENV_VAR_PATH, varDirPath, varDirPathRef, target)\n                : AbsolutePathService.addService(INTERNAL_CORE_ENV_VAR_PATH, varDirPath, target);\n        controllers.add(varDirRPS);\n\n        ServiceBuilder<?> coreEnvBuilder = context.getServiceTarget().addService(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, coreEnvironmentService);\n        if (socketBindingName != null) {\n            // Add a dependency on the socket id binding\n            ServiceName bindingName = SocketBinding.JBOSS_BINDING_NAME.append(socketBindingName);\n            coreEnvBuilder.addDependency(bindingName, SocketBinding.class, coreEnvironmentService.getSocketProcessBindingInjector());\n        }\n        controllers.add(coreEnvBuilder.addDependency(INTERNAL_CORE_ENV_VAR_PATH, String.class, coreEnvironmentService.getPathInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"public CoreEnvironmentService(String nodeIdentifier, String varPath) {\n        this.nodeIdentifier = nodeIdentifier;\n        this.varPath = varPath;\n    }","id":66737,"modified_method":"public CoreEnvironmentService(String nodeIdentifier) {\n        this.nodeIdentifier = nodeIdentifier;\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode getSubsystemAdd(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode op = new ModelNode();\n        op.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"txn.add\"));\n        op.get(OPERATION_NAME).set(ADD);\n\n        op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.CORE_ENVIRONMENT, MIN_OCCURS).set(1);\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.CORE_ENVIRONMENT).set(getCoreEnvironmentAddDescription(locale));\n\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.RECOVERY_ENVIRONMENT, MIN_OCCURS).set(1);\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.RECOVERY_ENVIRONMENT).set(getRecoveryEnvironmentAddDescription(locale));\n\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.COORDINATOR_ENVIRONMENT, MIN_OCCURS).set(1);\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.COORDINATOR_ENVIRONMENT).set(getCoordinatorEnvironmentAddDescription(locale));\n\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.OBJECT_STORE, MIN_OCCURS).set(1);\n                op.get(REQUEST_PROPERTIES, CommonAttributes.CONFIGURATION, CommonAttributes.OBJECT_STORE).set(getObjectStoreAddDescription(locale));\n\n           op.get(ModelDescriptionConstants.REPLY_PROPERTIES).setEmptyObject();\n\n        return op;\n    }","id":66738,"modified_method":"static ModelNode getSubsystemAdd(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode op = new ModelNode();\n        op.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"txn.add\"));\n        op.get(OPERATION_NAME).set(ADD);\n\n        op.get(REQUEST_PROPERTIES).setEmptyObject();\n\n        op.get(REPLY_PROPERTIES).setEmptyObject();\n\n        return op;\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode getCoreEnvironmentAddDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode op = new ModelNode();\n\n        op.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.add\"));\n        op.get(OPERATION_NAME).set(ADD);\n\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.node-identifier\"));\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.DEFAULT).set(1);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.REQUIRED).set(false);\n        // core-environment/process-id\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.process-id\"));\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.MIN_LENGTH).set(1);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.REQUIRED).set(true);\n        // core-environment/process-id/uuid\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.UUID, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.process-id.uuid\"));\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.UUID, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.UUID, ModelDescriptionConstants.MIN_LENGTH).set(0);\n        op.get(ModelDescriptionConstants.REQUEST_PROPERTIES, CommonAttributes.UUID, ModelDescriptionConstants.REQUIRED).set(false);\n\n        op.get(ModelDescriptionConstants.REPLY_PROPERTIES).setEmptyObject();\n\n        return op;\n    }","id":66739,"modified_method":"static ModelNode getCoreEnvironmentAddDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode op = new ModelNode();\n\n        op.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.add\"));\n        op.get(OPERATION_NAME).set(ADD);\n\n        CoreEnvironmentAdd.NODE_IDENTIFIER.addOperationParameterDescription(bundle, \"core-environment\", op);\n        CoreEnvironmentAdd.PROCESS_ID_UUID.addOperationParameterDescription(bundle, \"core-environment\", op);\n        CoreEnvironmentAdd.PROCESS_ID_SOCKET_BINDING.addOperationParameterDescription(bundle, \"core-environment\", op);\n        CoreEnvironmentAdd.PROCESS_ID_SOCKET_MAX_PORTS.addOperationParameterDescription(bundle, \"core-environment\", op);\n        CoreEnvironmentAdd.RELATIVE_TO.addOperationParameterDescription(bundle, \"core-environment\", op);\n        CoreEnvironmentAdd.PATH.addOperationParameterDescription(bundle, \"core-environment\", op);\n\n        op.get(ModelDescriptionConstants.REPLY_PROPERTIES).setEmptyObject();\n\n        return op;\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode getCoreEnvironmentDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode coreEnvModelNode = new ModelNode();\n\n        coreEnvModelNode.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment\"));\n        coreEnvModelNode.get(ModelDescriptionConstants.HEAD_COMMENT_ALLOWED).set(true);\n        coreEnvModelNode.get(ModelDescriptionConstants.TAIL_COMMENT_ALLOWED).set(true);\n        coreEnvModelNode.get(ModelDescriptionConstants.NAMESPACE).set(Namespace.TRANSACTIONS_1_0.getUriString());\n\n        // core-environment.node-identifier\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.node-identifier\"));\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.DEFAULT).set(1);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.NODE_IDENTIFIER, ModelDescriptionConstants.REQUIRED).set(false);\n        // core-environment/process-id\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.process-id\"));\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.MIN_LENGTH).set(1);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.PROCESS_ID, ModelDescriptionConstants.REQUIRED).set(true);\n        // core-environment/process-id/uuid\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.UUID, ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment.process-id.uuid\"));\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.UUID, ModelDescriptionConstants.TYPE).set(ModelType.STRING);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.UUID, ModelDescriptionConstants.MIN_LENGTH).set(0);\n        coreEnvModelNode.get(ModelDescriptionConstants.ATTRIBUTES, CommonAttributes.UUID, ModelDescriptionConstants.REQUIRED).set(false);\n\n\n        /* Not currently used\n        coreEnvModelNode.get(ATTRIBUTES, CORE_ENVIRONMENT, VALUE_TYPE, SOCKET_PROCESS_ID_MAX_PORTS, DESCRIPTION).set(bundle.getString(\"core-environment.socket-process-id-max-ports\"));\n        coreEnvModelNode.get(ATTRIBUTES, CORE_ENVIRONMENT, VALUE_TYPE, SOCKET_PROCESS_ID_MAX_PORTS, TYPE).set(ModelType.INT);\n        coreEnvModelNode.get(ATTRIBUTES, CORE_ENVIRONMENT, VALUE_TYPE, SOCKET_PROCESS_ID_MAX_PORTS, DEFAULT).set(10);\n        coreEnvModelNode.get(ATTRIBUTES, CORE_ENVIRONMENT, VALUE_TYPE, SOCKET_PROCESS_ID_MAX_PORTS, REQUIRED).set(false);\n        */\n\n        return coreEnvModelNode;\n\n    }","id":66740,"modified_method":"static ModelNode getCoreEnvironmentDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode coreEnvModelNode = new ModelNode();\n\n        coreEnvModelNode.get(ModelDescriptionConstants.DESCRIPTION).set(bundle.getString(\"core-environment\"));\n        coreEnvModelNode.get(ModelDescriptionConstants.HEAD_COMMENT_ALLOWED).set(true);\n        coreEnvModelNode.get(ModelDescriptionConstants.TAIL_COMMENT_ALLOWED).set(true);\n        coreEnvModelNode.get(ModelDescriptionConstants.NAMESPACE).set(Namespace.TRANSACTIONS_1_0.getUriString());\n\n        CoreEnvironmentAdd.NODE_IDENTIFIER.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n        CoreEnvironmentAdd.PROCESS_ID_UUID.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n        CoreEnvironmentAdd.PROCESS_ID_SOCKET_BINDING.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n        CoreEnvironmentAdd.PROCESS_ID_SOCKET_MAX_PORTS.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n        CoreEnvironmentAdd.RELATIVE_TO.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n        CoreEnvironmentAdd.PATH.addResourceAttributeDescription(bundle, \"core-environment\", coreEnvModelNode);\n\n        return coreEnvModelNode;\n\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode getCoordiantorEnvironmentRemoveDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n        final ModelNode description = new ModelNode();\n        description.get(OPERATION_NAME).set(REMOVE);\n        // setup the description\n        description.get(DESCRIPTION).set(bundle.getString(\"coordinator-environment.remove\"));\n\n        return description;\n    }","id":66741,"modified_method":"static ModelNode getCoordinatorEnvironmentRemoveDescription(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n        final ModelNode description = new ModelNode();\n        description.get(OPERATION_NAME).set(REMOVE);\n        // setup the description\n        description.get(DESCRIPTION).set(bundle.getString(\"coordinator-environment.remove\"));\n\n        return description;\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final ModelNode address = PathAddress.pathAddress(PathAddress.pathAddress(operation.require(OP_ADDR)).getLastElement()).toModelNode();\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        final ModelNode result = context.getResult();\n        describe(resource, address, result, context.getResourceRegistration());\n    }","id":66742,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final ModelNode address = PathAddress.pathAddress(PathAddress.pathAddress(operation.require(OP_ADDR)).getLastElement()).toModelNode();\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        final ModelNode result = context.getResult();\n        describe(resource, address, result, context.getResourceRegistration());\n        context.completeStep();\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode createAddOperation(final ModelNode address, final ModelNode subModel, final Set<PathElement> children) {\n        final ModelNode operation = subModel.clone();\n        if(children != null && ! children.isEmpty()) {\n            for(final PathElement path : children) {\n                if(subModel.hasDefined(path.getKey())) {\n                    subModel.remove(path.getKey());\n                }\n            }\n        }\n        operation.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        operation.get(ModelDescriptionConstants.OP_ADDR).set(address);\n        return operation;\n    }","id":66743,"modified_method":"protected ModelNode createAddOperation(final ModelNode address, final ModelNode subModel, final Set<PathElement> children) {\n        final ModelNode operation = subModel.clone();\n        operation.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        operation.get(ModelDescriptionConstants.OP_ADDR).set(address);\n        if(children != null && ! children.isEmpty()) {\n            for(final PathElement path : children) {\n                if(subModel.hasDefined(path.getKey())) {\n                    subModel.remove(path.getKey());\n                }\n            }\n        }\n        return operation;\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode objectStoreModel) throws OperationFailedException {\n\n        objectStoreModel.get(RELATIVE_TO).set(operation.get(RELATIVE_TO));\n        objectStoreModel.get(PATH).set(operation.get(PATH));\n\n    }","id":66744,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode objectStoreModel) throws OperationFailedException {\n\n        RELATIVE_TO.validateAndSet(operation, objectStoreModel);\n        PATH.validateAndSet(operation, objectStoreModel);\n\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        return Descriptions.getRecoveryEnvironmentAddDescription(locale);\n    }","id":66745,"modified_method":"/**\n     * Description provider for the strict-max-pool add operation\n     */\n    @Override\n    public ModelNode getModelDescription(Locale locale) {\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        return Descriptions.getObjectStoreAddDescription(locale);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ModelNode objectStore = operation.get(OBJECT_STORE);\n        final String objectStorePathRef = objectStore.hasDefined(RELATIVE_TO) ? objectStore.get(RELATIVE_TO).asString() : \"jboss.server.data.dir\";\n        final String objectStorePath = objectStore.hasDefined(PATH) ? objectStore.get(PATH).asString() : \"tx-object-store\";\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"objectStorePathRef=%s, objectStorePathRef=%s\\n\", objectStorePathRef, objectStorePath);\n        }\n\n        ServiceTarget target = context.getServiceTarget();\n        // Configure the ObjectStoreEnvironmentBeans\n        ServiceController<String> objectStoreRPS = RelativePathService.addService(INTERNAL_OBJECTSTORE_PATH, objectStorePath, objectStorePathRef, target);\n        controllers.add(objectStoreRPS);\n\n        final boolean useHornetqJournalStore = \"true\".equals(System.getProperty(\"usehornetqstore\")); // TODO wire to domain model instead.\n\n        final ArjunaObjectStoreEnvironmentService objStoreEnvironmentService = new ArjunaObjectStoreEnvironmentService(useHornetqJournalStore);\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT, objStoreEnvironmentService)\n                .addDependency(objectStoreRPS.getName(), String.class, objStoreEnvironmentService.getPathInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        controllers.add(TransactionManagerService.addService(target, verificationHandler));\n        controllers.add(UserTransactionService.addService(target, verificationHandler));\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY, new UserTransactionRegistryService())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n        controllers.add(TransactionSynchronizationRegistryService.addService(target, verificationHandler));\n\n    }","id":66746,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        String objectStorePathRef = null;\n        // Check for empty string value for relative-to, which disables the default\n        final ModelNode relativePathNode = recoveryEnvModel.get(RELATIVE_TO.getName());\n        if (!relativePathNode.isDefined() || relativePathNode.asString().length() > 0) {\n            objectStorePathRef = RELATIVE_TO.validateResolvedOperation(recoveryEnvModel).asString();\n        }\n        final String objectStorePath = PATH.validateResolvedOperation(recoveryEnvModel).asString();\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"objectStorePathRef=%s, objectStorePath=%s\\n\", objectStorePathRef, objectStorePath);\n        }\n\n        ServiceTarget target = context.getServiceTarget();\n        // Configure the ObjectStoreEnvironmentBeans\n        ServiceController<String> objectStorePS = objectStorePathRef != null\n                ? RelativePathService.addService(INTERNAL_OBJECTSTORE_PATH, objectStorePath, objectStorePathRef, target)\n                : AbsolutePathService.addService(INTERNAL_OBJECTSTORE_PATH, objectStorePath, target);\n        controllers.add(objectStorePS);\n\n        final boolean useHornetqJournalStore = \"true\".equals(System.getProperty(\"usehornetqstore\")); // TODO wire to domain model instead.\n\n        final ArjunaObjectStoreEnvironmentService objStoreEnvironmentService = new ArjunaObjectStoreEnvironmentService(useHornetqJournalStore);\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT, objStoreEnvironmentService)\n                .addDependency(INTERNAL_OBJECTSTORE_PATH, String.class, objStoreEnvironmentService.getPathInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        controllers.add(TransactionManagerService.addService(target, verificationHandler));\n        controllers.add(UserTransactionService.addService(target, verificationHandler));\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY, new UserTransactionRegistryService())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n        controllers.add(TransactionSynchronizationRegistryService.addService(target, verificationHandler));\n\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode recoveryEnvModel) throws OperationFailedException {\n        final String recoveryBindingName = operation.require(BINDING).asString();\n        final String recoveryStatusBindingName = operation.require(STATUS_BINDING).asString();\n        final boolean recoveryListener = operation.get(RECOVERY_LISTENER).asBoolean(false);\n\n        recoveryEnvModel.get(BINDING).set(recoveryBindingName);\n        recoveryEnvModel.get(STATUS_BINDING).set(recoveryStatusBindingName);\n        recoveryEnvModel.get(RECOVERY_LISTENER).set(operation.get(RECOVERY_LISTENER));\n\n    }","id":66747,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode recoveryEnvModel) throws OperationFailedException {\n\n        BINDING.validateAndSet(operation, recoveryEnvModel);\n        STATUS_BINDING.validateAndSet(operation, recoveryEnvModel);\n        RECOVERY_LISTENER.validateAndSet(operation, recoveryEnvModel);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final String recoveryBindingName = recoveryEnvModel.require(BINDING).asString();\n        final String recoveryStatusBindingName = recoveryEnvModel.require(STATUS_BINDING).asString();\n        final boolean recoveryListener = recoveryEnvModel.get(RECOVERY_LISTENER).asBoolean(false);\n\n        final ArjunaRecoveryManagerService recoveryManagerService = new ArjunaRecoveryManagerService(recoveryListener);\n                                   serviceControllers.add(context.getServiceTarget().addService(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, recoveryManagerService)\n                                           .addDependency(ServiceBuilder.DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"iiop\", \"orb\"), ORB.class, recoveryManagerService.getOrbInjector())\n                                           .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(recoveryBindingName), SocketBinding.class, recoveryManagerService.getRecoveryBindingInjector())\n                                           .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(recoveryStatusBindingName), SocketBinding.class, recoveryManagerService.getStatusBindingInjector())\n                                           .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                                           .addDependency(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT)\n                                           .addListener(verificationHandler)\n                                           .setInitialMode(ServiceController.Mode.ACTIVE)\n                                           .install());\n\n    }","id":66748,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final String recoveryBindingName = BINDING.validateResolvedOperation(recoveryEnvModel).asString();\n        final String recoveryStatusBindingName = STATUS_BINDING.validateResolvedOperation(recoveryEnvModel).asString();\n        final boolean recoveryListener = RECOVERY_LISTENER.validateResolvedOperation(recoveryEnvModel).asBoolean();\n\n        final ArjunaRecoveryManagerService recoveryManagerService = new ArjunaRecoveryManagerService(recoveryListener);\n        serviceControllers.add(context.getServiceTarget().addService(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, recoveryManagerService)\n               .addDependency(ServiceBuilder.DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"iiop\", \"orb\"), ORB.class, recoveryManagerService.getOrbInjector())\n               .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(recoveryBindingName), SocketBinding.class, recoveryManagerService.getRecoveryBindingInjector())\n               .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(recoveryStatusBindingName), SocketBinding.class, recoveryManagerService.getStatusBindingInjector())\n               .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n               .addDependency(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT)\n               .addListener(verificationHandler)\n               .setInitialMode(ServiceController.Mode.ACTIVE)\n               .install());\n\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(TransactionSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, TransactionSubsystemAdd.INSTANCE, TransactionSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(DESCRIBE, TransactionDescribeHandler.INSTANCE, TransactionDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        final ManagementResourceRegistration recoveryEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, RECOVERY_ENVIRONMENT),\n                TransactionSubsystemProviders.RECOVERY_ENVIRONMENT_DESC);\n        recoveryEnv.registerOperationHandler(ADD, RecoveryEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_RECOVERY_ENVIRONMENT_DESC, false);\n        recoveryEnv.registerOperationHandler(REMOVE, RecoveryEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_RECOVERY_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coreEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, CORE_ENVIRONMENT),\n                TransactionSubsystemProviders.CORE_ENVIRONMENT_DESC);\n        coreEnv.registerOperationHandler(ADD, CoreEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_CORE_ENVIRONMENT_DESC, false);\n        coreEnv.registerOperationHandler(REMOVE, CoreEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_CORE_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coordinatorEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, COORDINATOR_ENVIRONMENT),\n                TransactionSubsystemProviders.COORDINATOR_ENVIRONMENT_DESC);\n        coordinatorEnv.registerOperationHandler(ADD, CoordinatorEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_COORDINATOR_ENVIRONMENT_DESC, false);\n        coordinatorEnv.registerOperationHandler(REMOVE, CoordinatorEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_COORDINATOR_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration objectStore = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, OBJECT_STORE),\n                TransactionSubsystemProviders.OBJECT_STORE_DESC);\n        objectStore.registerOperationHandler(ADD, ObjectStoreAdd.INSTANCE, TransactionSubsystemProviders.ADD_OBJECT_STORE_DESC, false);\n        objectStore.registerOperationHandler(REMOVE, ObjectStoreRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_OBJECT_STORE_DESC, false);\n\n        for (TxStatsHandler.TxStat stat : EnumSet.allOf(TxStatsHandler.TxStat.class)) {\n            registration.registerMetric(stat.toString(), TxStatsHandler.INSTANCE);\n        }\n        subsystem.registerXMLElementWriter(parser);\n    }","id":66749,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n\n        final EnumSet<OperationEntry.Flag> reloadFlags = EnumSet.of(OperationEntry.Flag.RESTART_ALL_SERVICES);\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(TransactionSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, TransactionSubsystemAdd.INSTANCE, TransactionSubsystemProviders.SUBSYSTEM_ADD, reloadFlags);\n        registration.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, TransactionSubsystemProviders.SUBSYSTEM_REMOVE, reloadFlags);\n        registration.registerOperationHandler(DESCRIBE, GenericSubsystemDescribeHandler.INSTANCE, GenericSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        for (TxStatsHandler.TxStat stat : EnumSet.allOf(TxStatsHandler.TxStat.class)) {\n            registration.registerMetric(stat.toString(), TxStatsHandler.INSTANCE);\n        }\n\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        final ManagementResourceRegistration recoveryEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, RECOVERY_ENVIRONMENT),\n                TransactionSubsystemProviders.RECOVERY_ENVIRONMENT_DESC);\n        recoveryEnv.registerOperationHandler(ADD, RecoveryEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_RECOVERY_ENVIRONMENT_DESC, reloadFlags);\n        recoveryEnv.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, TransactionSubsystemProviders.REMOVE_RECOVERY_ENVIRONMENT_DESC, reloadFlags);\n\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        final ManagementResourceRegistration coreEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, CORE_ENVIRONMENT),\n                TransactionSubsystemProviders.CORE_ENVIRONMENT_DESC);\n        coreEnv.registerOperationHandler(ADD, CoreEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_CORE_ENVIRONMENT_DESC, reloadFlags);\n        coreEnv.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, TransactionSubsystemProviders.REMOVE_CORE_ENVIRONMENT_DESC, reloadFlags);\n\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        final ManagementResourceRegistration coordinatorEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, COORDINATOR_ENVIRONMENT),\n                TransactionSubsystemProviders.COORDINATOR_ENVIRONMENT_DESC);\n        coordinatorEnv.registerOperationHandler(ADD, CoordinatorEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_COORDINATOR_ENVIRONMENT_DESC, reloadFlags);\n        coordinatorEnv.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, TransactionSubsystemProviders.REMOVE_COORDINATOR_ENVIRONMENT_DESC, reloadFlags);\n\n        // TODO use a ResourceDefinition and StandardResourceDescriptionResolver for this resource\n        final ManagementResourceRegistration objectStore = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, OBJECT_STORE),\n                TransactionSubsystemProviders.OBJECT_STORE_DESC);\n        objectStore.registerOperationHandler(ADD, ObjectStoreAdd.INSTANCE, TransactionSubsystemProviders.ADD_OBJECT_STORE_DESC, reloadFlags);\n        objectStore.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, TransactionSubsystemProviders.REMOVE_OBJECT_STORE_DESC, reloadFlags);\n\n        subsystem.registerXMLElementWriter(parser);\n    }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode parseSocketProcessIdElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n\n            final ModelNode socketId = new ModelNode();\n            final int count = reader.getAttributeCount();\n            final EnumSet<Attribute> required = EnumSet.of(Attribute.BINDING);\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case BINDING:\n                        socketId.get(BINDING).set(value);\n                        break;\n                    case SOCKET_PROCESS_ID_MAX_PORTS:\n                        socketId.get(SOCKET_PROCESS_ID_MAX_PORTS).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            // Handle elements\n            requireNoContent(reader);\n            return socketId;\n        }","id":66750,"modified_method":"static void parseSocketProcessIdElement(XMLExtendedStreamReader reader, ModelNode coreEnvironmentAdd) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            final EnumSet<Attribute> required = EnumSet.of(Attribute.BINDING);\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case BINDING:\n                        CoreEnvironmentAdd.PROCESS_ID_SOCKET_BINDING.parseAndSetParameter(value, coreEnvironmentAdd, reader.getLocation());\n                        break;\n                    case SOCKET_PROCESS_ID_MAX_PORTS:\n                        CoreEnvironmentAdd.PROCESS_ID_SOCKET_MAX_PORTS.parseAndSetParameter(value, coreEnvironmentAdd, reader.getLocation());\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            // Handle elements\n            requireNoContent(reader);\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseCoordinatorEnvironmentElement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        operation.get(ENABLE_STATISTICS).set(value);\n                        break;\n                    case ENABLE_TSM_STATUS:\n                        operation.get(ENABLE_TSM_STATUS).set(value);\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        operation.get(DEFAULT_TIMEOUT).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n\n        }","id":66751,"modified_method":"static void parseCoordinatorEnvironmentElement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Location location = reader.getLocation();\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        CoordinatorEnvironmentAdd.ENABLE_STATISTICS.parseAndSetParameter(value, operation, location);\n                        break;\n                    case ENABLE_TSM_STATUS:\n                        CoordinatorEnvironmentAdd.ENABLE_TSM_STATUS.parseAndSetParameter(value, operation, location);\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        CoordinatorEnvironmentAdd.DEFAULT_TIMEOUT.parseAndSetParameter(value, operation, location);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeProcessId(final XMLExtendedStreamWriter writer, final ModelNode value) throws XMLStreamException {\n            writer.writeStartElement(Element.PROCESS_ID.getLocalName());\n            if(hasDefined(value, Element.UUID.getLocalName())) {\n                writer.writeEmptyElement(Element.UUID.getLocalName());\n            }\n            else if(hasDefined(value, Element.SOCKET.getLocalName())) {\n                writer.writeStartElement(Element.SOCKET.getLocalName());\n                if (hasDefined(value, BINDING)) {\n                    writeAttribute(writer, Attribute.BINDING, value.get(BINDING));\n                }\n                if (hasDefined(value, SOCKET_PROCESS_ID_MAX_PORTS)) {\n                    writeAttribute(writer, Attribute.SOCKET_PROCESS_ID_MAX_PORTS, value.get(SOCKET_PROCESS_ID_MAX_PORTS));\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }","id":66752,"modified_method":"private void writeProcessId(final XMLExtendedStreamWriter writer, final ModelNode value) throws XMLStreamException {\n            writer.writeStartElement(Element.PROCESS_ID.getLocalName());\n            if(value.get(CoreEnvironmentAdd.PROCESS_ID_UUID.getName()).asBoolean()) {\n                writer.writeEmptyElement(Element.UUID.getLocalName());\n            } else {\n                writer.writeStartElement(Element.SOCKET.getLocalName());\n                CoreEnvironmentAdd.PROCESS_ID_SOCKET_BINDING.marshallAsAttribute(value, writer);\n                CoreEnvironmentAdd.PROCESS_ID_SOCKET_MAX_PORTS.marshallAsAttribute(value, writer);\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n            context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n            ModelNode node = context.getModelNode();\n\n            if (hasDefined(node, CONFIGURATION)) {\n                List<Property> configurations = node.get(CONFIGURATION).asPropertyList();\n                for (Property config : configurations) {\n                    if (config.getName().equals(CORE_ENVIRONMENT) &&\n                            config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());\n                        final ModelNode core = config.getValue();\n                        if (hasDefined(core, NODE_IDENTIFIER)) {\n                            writeAttribute(writer, Attribute.NODE_IDENTIFIER, core.get(NODE_IDENTIFIER));\n                        }\n                        if (hasDefined(core, PROCESS_ID)) {\n                            writeProcessId(writer, core.get(PROCESS_ID));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(RECOVERY_ENVIRONMENT) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, BINDING)) {\n                            writeAttribute(writer, Attribute.BINDING, env.get(BINDING));\n                        }\n                        if (hasDefined(env, STATUS_BINDING)) {\n                            writeAttribute(writer, Attribute.STATUS_BINDING, env.get(STATUS_BINDING));\n                        }\n                        if (hasDefined(env, RECOVERY_LISTENER)) {\n                            writeAttribute(writer, Attribute.RECOVERY_LISTENER, env.get(RECOVERY_LISTENER));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(COORDINATOR_ENVIRONMENT) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, ENABLE_STATISTICS)) {\n                            writeAttribute(writer, Attribute.ENABLE_STATISTICS, env.get(ENABLE_STATISTICS));\n                        }\n                        if (hasDefined(env, ENABLE_TSM_STATUS)) {\n                            writeAttribute(writer, Attribute.ENABLE_TSM_STATUS, env.get(ENABLE_TSM_STATUS));\n                        }\n                        if (hasDefined(env, DEFAULT_TIMEOUT)) {\n                            writeAttribute(writer, Attribute.DEFAULT_TIMEOUT, env.get(DEFAULT_TIMEOUT));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(OBJECT_STORE) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.OBJECT_STORE.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, RELATIVE_TO)) {\n                            writeAttribute(writer, Attribute.RELATIVE_TO, env.get(RELATIVE_TO));\n                        }\n                        if (hasDefined(env, PATH)) {\n                            writeAttribute(writer, Attribute.PATH, env.get(PATH));\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n            }\n\n            writer.writeEndElement();\n        }","id":66753,"modified_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n            context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n            ModelNode node = context.getModelNode();\n\n            if (hasDefined(node, CONFIGURATION)) {\n                List<Property> configurations = node.get(CONFIGURATION).asPropertyList();\n                for (Property config : configurations) {\n                    if (config.getName().equals(CORE_ENVIRONMENT)) {\n                        writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());\n\n                        final ModelNode core = config.getValue();\n                        CoreEnvironmentAdd.NODE_IDENTIFIER.marshallAsAttribute(core, writer);\n                        CoreEnvironmentAdd.PATH.marshallAsAttribute(core, writer);\n                        CoreEnvironmentAdd.RELATIVE_TO.marshallAsAttribute(core, writer);\n\n                        writeProcessId(writer, core);\n\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(RECOVERY_ENVIRONMENT) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, BINDING)) {\n                            writeAttribute(writer, Attribute.BINDING, env.get(BINDING));\n                        }\n                        if (hasDefined(env, STATUS_BINDING)) {\n                            writeAttribute(writer, Attribute.STATUS_BINDING, env.get(STATUS_BINDING));\n                        }\n                        if (hasDefined(env, RECOVERY_LISTENER)) {\n                            writeAttribute(writer, Attribute.RECOVERY_LISTENER, env.get(RECOVERY_LISTENER));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(COORDINATOR_ENVIRONMENT)) {\n                        final ModelNode env = config.getValue();\n                        if (CoordinatorEnvironmentAdd.ENABLE_STATISTICS.isMarshallable(env)\n                                || CoordinatorEnvironmentAdd.ENABLE_TSM_STATUS.isMarshallable(env)\n                                || CoordinatorEnvironmentAdd.DEFAULT_TIMEOUT.isMarshallable(env)) {\n\n                            writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());\n\n                            CoordinatorEnvironmentAdd.ENABLE_STATISTICS.marshallAsAttribute(env, writer);\n                            CoordinatorEnvironmentAdd.ENABLE_TSM_STATUS.marshallAsAttribute(env, writer);\n                            CoordinatorEnvironmentAdd.DEFAULT_TIMEOUT.marshallAsAttribute(env, writer);\n\n                            writer.writeEndElement();\n                        }\n                    }\n                    if (config.getName().equals(OBJECT_STORE)) {\n                        final ModelNode env = config.getValue();\n                        if (ObjectStoreAdd.RELATIVE_TO.isMarshallable(env)\n                                || ObjectStoreAdd.PATH.isMarshallable(env)) {\n                            writer.writeStartElement(Element.OBJECT_STORE.getLocalName());\n                            ObjectStoreAdd.PATH.marshallAsAttribute(env, writer);\n                            ObjectStoreAdd.RELATIVE_TO.marshallAsAttribute(env, writer);\n                            writer.writeEndElement();\n                        }\n                    }\n                }\n            }\n\n            writer.writeEndElement();\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Handle the process-id child elements\n         * @param reader\n         * @return\n         * @throws XMLStreamException\n         */\n        static ModelNode parseProcessIdEnvironmentElement(XMLExtendedStreamReader reader) throws XMLStreamException {\n\n            final ModelNode processId = new ModelNode();\n\n            // elements\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                  case UUID:\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                      processId.get(CommonAttributes.UUID).set(element.getLocalName());\n                      requireNoContent(reader);\n                      break;\n                  case SOCKET: {\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                    ModelNode socketId = parseSocketProcessIdElement(reader);\n                    processId.get(CommonAttributes.SOCKET).set(socketId);\n                    break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n               }\n            }\n\n            return processId;\n        }","id":66754,"modified_method":"/**\n         * Handle the process-id child elements\n         *\n         * @param reader\n         * @param coreEnvironmentAdd\n         * @return\n         * @throws XMLStreamException\n         */\n        static void parseProcessIdEnvironmentElement(XMLExtendedStreamReader reader, ModelNode coreEnvironmentAdd) throws XMLStreamException {\n\n            // elements\n            boolean encountered = false;\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                  case UUID:\n                      if (encountered) {\n                          throw unexpectedElement(reader);\n                      }\n                      encountered = true;\n                      coreEnvironmentAdd.get(CoreEnvironmentAdd.PROCESS_ID_UUID.getName()).set(true);\n                      requireNoContent(reader);\n                      break;\n                  case SOCKET: {\n                      if (encountered) {\n                          throw unexpectedElement(reader);\n                      }\n                      encountered = true;\n                      parseSocketProcessIdElement(reader, coreEnvironmentAdd);\n                      break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n               }\n            }\n\n            if (!encountered) {\n                throw missingOneOf(reader, EnumSet.of(Element.UUID, Element.SOCKET));\n            }\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseObjectStoreEnvironmentElementAndEnrichOperation(final XMLExtendedStreamReader reader, ModelNode operation) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case RELATIVE_TO:\n                        operation.get(RELATIVE_TO).set(value);\n                        break;\n                    case PATH:\n                        operation.get(PATH).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n\n        }","id":66755,"modified_method":"static void parseObjectStoreEnvironmentElementAndEnrichOperation(final XMLExtendedStreamReader reader, ModelNode operation) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Location location = reader.getLocation();\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case RELATIVE_TO:\n                        ObjectStoreAdd.RELATIVE_TO.parseAndSetParameter(value, operation, location);\n                        break;\n                    case PATH:\n                        ObjectStoreAdd.PATH.parseAndSetParameter(value, operation, location);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseRecoveryEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode recoveryEnvAddress = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            recoveryEnvAddress.add(CONFIGURATION, RECOVERY_ENVIRONMENT);\n            recoveryEnvAddress.protect();\n\n            operation.get(OP_ADDR).set(recoveryEnvAddress);\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        operation.get(BINDING).set(value);\n                        break;\n                    case STATUS_BINDING:\n                        operation.get(STATUS_BINDING).set(value);\n                        break;\n                    case RECOVERY_LISTENER:\n                        operation.get(RECOVERY_LISTENER).set(value);\n                        break;\n                    default:\n                        unexpectedAttribute(reader, i);\n                }\n            }\n            if(! operation.hasDefined(BINDING)) {\n                throw missingRequired(reader, Collections.singleton(Attribute.BINDING));\n            }\n            // Handle elements\n            requireNoContent(reader);\n            list.add(operation);\n        }","id":66756,"modified_method":"static void parseRecoveryEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode recoveryEnvAddress = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            recoveryEnvAddress.add(CONFIGURATION, RECOVERY_ENVIRONMENT);\n            recoveryEnvAddress.protect();\n\n            operation.get(OP_ADDR).set(recoveryEnvAddress);\n\n            Set<Attribute> required = EnumSet.of(Attribute.BINDING, Attribute.STATUS_BINDING);\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Location location = reader.getLocation();\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case BINDING:\n                        RecoveryEnvironmentAdd.BINDING.parseAndSetParameter(value, operation, location);\n                        break;\n                    case STATUS_BINDING:\n                        RecoveryEnvironmentAdd.STATUS_BINDING.parseAndSetParameter(value, operation, location);\n                        break;\n                    case RECOVERY_LISTENER:\n                        RecoveryEnvironmentAdd.RECOVERY_LISTENER.parseAndSetParameter(value, operation, location);\n                        break;\n                    default:\n                        unexpectedAttribute(reader, i);\n                }\n            }\n\n            if(! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            // Handle elements\n            requireNoContent(reader);\n            list.add(operation);\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Handle the core-environment element and children\n         * @param reader\n         * @return ModelNode for the core-environment\n         * @throws XMLStreamException\n         */\n        static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode env = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            env.add(CONFIGURATION, CORE_ENVIRONMENT);\n            env.protect();\n\n            operation.get(OP_ADDR).set(env);\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NODE_IDENTIFIER:\n                        operation.get(NODE_IDENTIFIER).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                required.remove(element);\n                switch (element) {\n                  case PROCESS_ID : {\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                    ModelNode processId = parseProcessIdEnvironmentElement(reader);\n                    operation.get(CommonAttributes.PROCESS_ID).set(processId);\n\n                    break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            list.add(operation);\n        }","id":66757,"modified_method":"/**\n         * Handle the core-environment element and children\n         * @param reader\n         * @return ModelNode for the core-environment\n         * @throws XMLStreamException\n         */\n        static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n\n            final ModelNode env = parentAddress.clone();\n            env.add(CONFIGURATION, CORE_ENVIRONMENT);\n            env.protect();\n\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            operation.get(OP_ADDR).set(env);\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NODE_IDENTIFIER:\n                        CoreEnvironmentAdd.NODE_IDENTIFIER.parseAndSetParameter(value, operation, reader.getLocation());\n                        break;\n                    case PATH:\n                        CoreEnvironmentAdd.PATH.parseAndSetParameter(value, operation, reader.getLocation());\n                        break;\n                    case RELATIVE_TO:\n                        CoreEnvironmentAdd.RELATIVE_TO.parseAndSetParameter(value, operation, reader.getLocation());\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                required.remove(element);\n                switch (element) {\n                  case PROCESS_ID : {\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                      parseProcessIdEnvironmentElement(reader, operation);\n                      break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequiredElement(reader, required);\n            }\n            list.add(operation);\n        }","commit_id":"12a5d72fdd17aba49f4324ea51bba7d8bfd5be02","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public QueryEngine getQueryEngine() {\n        checkLive();\n        return new QueryEngineImpl() {\n            @Override\n            protected ExecutionContext getExecutionContext() {\n                QueryIndexProvider provider = indexProvider;\n                if (hasPendingChanges()) {\n                    provider = new UUIDDiffIndexProviderWrapper(\n                            provider, getBaseState(), getRootState());\n                }\n                return new ExecutionContext(getBaseState(), rootTree, provider);\n            }\n        };\n    }","id":66758,"modified_method":"/**\n     * Build a read only subject for the {@link #commit(String, CommitHook)} call that makes the\n     * principals, auth info and the permission provider available to the commit hooks.\n     *\n     * @return a new read only subject.\n     */\n    private Subject getCommitSubject(ContentSession session) {\n        Set<Object> publicCreds = ImmutableSet.of(\n                permissionProvider.get(),\n                session.getAuthInfo()\n        );\n        return new Subject(true, subject.getPrincipals(), publicCreds, Collections.<Object>emptySet());\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void commit(@Nullable String message, @Nullable CommitHook hook)\n            throws CommitFailedException {\n        checkLive();\n        ContentSession session = getContentSession();\n        CommitInfo info = new CommitInfo(\n                session.toString(),\n                session.getAuthInfo().getUserID(),\n                message);\n        base = store.merge(builder, getCommitHook(hook), info);\n        secureBuilder.baseChanged();\n        modCount = 0;\n        if (permissionProvider.hasValue()) {\n            permissionProvider.get().refresh();\n        }\n    }","id":66759,"modified_method":"@Override\n    public void commit(@Nullable String message, @Nullable CommitHook hook)\n            throws CommitFailedException {\n        checkLive();\n        ContentSession session = getContentSession();\n        CommitInfo info = new CommitInfo(\n                session.toString(),\n                getCommitSubject(session),\n                moveInfo, message);\n        base = store.merge(builder, getCommitHook(hook, info), info);\n        secureBuilder.baseChanged();\n        modCount = 0;\n        if (permissionProvider.hasValue()) {\n            permissionProvider.get().refresh();\n        }\n        moveInfo.clear();\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Combine the passed {@code hook}, the globally defined commit hook(s)\n     * and the hooks and validators defined by the various security related\n     * configurations.\n     *\n     * @param hook extra hook to be used for just this commit, or {@code null}\n     * @return A commit hook combining repository global commit hook(s) with the pluggable hooks\n     *         defined with the security modules and the padded {@code hooks}.\n     */\n    private CommitHook getCommitHook(@Nullable CommitHook extraHook) {\n        List<CommitHook> hooks = newArrayList();\n\n        if (extraHook != null) {\n            hooks.add(extraHook);\n        }\n\n        hooks.add(hook);\n\n        List<CommitHook> postValidationHooks = new ArrayList<CommitHook>();\n        for (SecurityConfiguration sc : securityProvider.getConfigurations()) {\n            for (CommitHook ch : sc.getCommitHooks(workspaceName)) {\n                if (ch instanceof PostValidationHook) {\n                    postValidationHooks.add(ch);\n                } else if (ch != EmptyHook.INSTANCE) {\n                    hooks.add(ch);\n                }\n            }\n\n            List<? extends ValidatorProvider> validators =\n                    sc.getValidators(workspaceName, getCommitSubject());\n            if (!validators.isEmpty()) {\n                hooks.add(new EditorHook(CompositeEditorProvider.compose(validators)));\n            }\n        }\n        hooks.addAll(postValidationHooks);\n\n        return CompositeHook.compose(hooks);\n    }","id":66760,"modified_method":"/**\n     * Combine the passed {@code hook}, the globally defined commit hook(s)\n     * and the hooks and validators defined by the various security related\n     * configurations.\n     *\n     * @param extraHook extra hook to be used for just this commit, or {@code null}\n     * @return A commit hook combining repository global commit hook(s) with the pluggable hooks\n     *         defined with the security modules and the padded {@code hooks}.\n     */\n    private CommitHook getCommitHook(@Nullable CommitHook extraHook, @Nonnull CommitInfo commitInfo) {\n        List<CommitHook> hooks = newArrayList();\n\n        if (extraHook != null) {\n            hooks.add(extraHook);\n        }\n\n        hooks.add(hook);\n\n        List<CommitHook> postValidationHooks = new ArrayList<CommitHook>();\n        for (SecurityConfiguration sc : securityProvider.getConfigurations()) {\n            for (CommitHook ch : sc.getCommitHooks(workspaceName)) {\n                if (ch instanceof PostValidationHook) {\n                    postValidationHooks.add(ch);\n                } else if (ch != EmptyHook.INSTANCE) {\n                    hooks.add(ch);\n                }\n            }\n\n            List<? extends ValidatorProvider> validators = sc.getValidators(workspaceName, commitInfo);\n            if (!validators.isEmpty()) {\n                hooks.add(new EditorHook(CompositeEditorProvider.compose(validators)));\n            }\n        }\n        hooks.addAll(postValidationHooks);\n\n        return CompositeHook.compose(hooks);\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean move(String sourcePath, String destPath) {\n        if (isAncestor(checkNotNull(sourcePath), checkNotNull(destPath))) {\n            return false;\n        } else if (sourcePath.equals(destPath)) {\n            return true;\n        }\n\n        checkLive();\n        MutableTree source = rootTree.getTree(sourcePath);\n        if (!source.exists()) {\n            return false;\n        }\n\n        String newName = getName(destPath);\n        MutableTree newParent = rootTree.getTree(getParentPath(destPath));\n        if (!newParent.exists() || newParent.hasChild(newName)) {\n            return false;\n        }\n\n        boolean success = source.moveTo(newParent, newName);\n        if (success) {\n            getTree(getParentPath(sourcePath)).updateChildOrder();\n            getTree(getParentPath(destPath)).updateChildOrder();\n            lastMove = lastMove.setMove(sourcePath, newParent, newName);\n            updated();\n        }\n        return success;\n    }","id":66761,"modified_method":"@Override\n    public boolean move(String sourcePath, String destPath) {\n        if (isAncestor(checkNotNull(sourcePath), checkNotNull(destPath))) {\n            return false;\n        } else if (sourcePath.equals(destPath)) {\n            return true;\n        }\n\n        checkLive();\n        MutableTree source = rootTree.getTree(sourcePath);\n        if (!source.exists()) {\n            return false;\n        }\n\n        String newName = getName(destPath);\n        MutableTree newParent = rootTree.getTree(getParentPath(destPath));\n        if (!newParent.exists() || newParent.hasChild(newName)) {\n            return false;\n        }\n\n        boolean success = source.moveTo(newParent, newName);\n        if (success) {\n            getTree(getParentPath(sourcePath)).updateChildOrder();\n            getTree(getParentPath(destPath)).updateChildOrder();\n            lastMove = lastMove.setMove(sourcePath, newParent, newName);\n            updated();\n        }\n\n        // remember all move operations for further processing in the commit hooks.\n        moveInfo.addMove(sourcePath, destPath);\n\n        return success;\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public List<ValidatorProvider> getValidators(\n            String workspaceName, Subject subject) {\n        return ImmutableList.of(\n                new PermissionStoreValidatorProvider(),\n                new PermissionValidatorProvider(getSecurityProvider(), subject),\n                new AccessControlValidatorProvider(getSecurityProvider()));\n    }","id":66762,"modified_method":"@Override\n    public List<ValidatorProvider> getValidators(String workspaceName, CommitInfo commitInfo) {\n        return ImmutableList.of(\n                new PermissionStoreValidatorProvider(),\n                new PermissionValidatorProvider(getSecurityProvider(), commitInfo),\n                new AccessControlValidatorProvider(getSecurityProvider()));\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Clears the change queue and signals the background thread to stop\n     * without making any further {@link #contentChanged(NodeState, CommitInfo)}\n     * calls to the background observer. If the thread is currently in the\n     * middle of such a call, then that call is allowed to complete; i.e.\n     * the thread is not forcibly interrupted. This method returns immediately\n     * without blocking to wait for the thread to finish.\n     */\n    public synchronized void stop() {\n        queue.clear();\n        queue.add(STOP);\n        // no need to join the thread; it will stop when encountering the STOP\n    }","id":66763,"modified_method":"/**\n     * Clears the change queue and signals the background thread to stop\n     * without making any further {@link #contentChanged(NodeState, CommitInfo)}\n     * calls to the background observer. If the thread is currently in the\n     * middle of such a call, then that call is allowed to complete; i.e.\n     * the thread is not forcibly interrupted. This method returns immediately\n     * without blocking to wait for the thread to finish.\n     */\n    public synchronized void stop() {\n        queue.clear();\n        queue.add(STOP);\n        try {\n            if (thread != Thread.currentThread()) {\n                thread.join();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.warn(\"Thread interrupted while joining observation thread.\", e);\n        }\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @return  user id of the committing user\n     */\n    @Nonnull\n    public String getUserId() {\n        return userId;\n    }","id":66764,"modified_method":"/**\n     * @return  user id of the committing user\n     */\n    @Nonnull\n    public String getUserId() {\n        Iterator<AuthInfo> it = subject.getPublicCredentials(AuthInfo.class).iterator();\n        String userId = null;\n        if (it.hasNext()) {\n            userId = it.next().getUserID();\n        }\n        return (userId == null) ? OAK_UNKNOWN : userId;\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String toString() {\n        return toStringHelper(this)\n                .add(\"sessionId\", sessionId)\n                .add(\"userId\", userId)\n                .add(\"userData\", message)\n                .add(\"date\", date)\n                .toString();\n    }","id":66765,"modified_method":"@Override\n    public String toString() {\n        return toStringHelper(this)\n                .add(\"sessionId\", sessionId)\n                .add(\"userId\", getUserId())\n                .add(\"userData\", message)\n                .add(\"date\", date)\n                .add(\"moveInfo\", moveInfo)\n                .toString();\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a commit info for the given session and user.\n     *\n     * @param sessionId session identifier\n     * @param userId user identifier, or {@code null} for an unknown user\n     * @param message message attached to this commit, or {@code null}\n     */\n    public CommitInfo(\n            @Nonnull String sessionId, @Nullable String userId,\n            @Nullable String message) {\n        this.sessionId = checkNotNull(sessionId);\n        if (userId != null) {\n            this.userId = userId;\n        } else {\n            this.userId = OAK_UNKNOWN;\n        }\n        this.message = message;\n    }","id":66766,"modified_method":"/**\n     * Creates a commit info for the given session and user.\n     *\n     * @param sessionId session identifier\n     * @param subject Subject identifying the user\n     * @param moveInfo Information regarding move operations associated with this commit.\n     * @param message message attached to this commit, or {@code null}\n     */\n    public CommitInfo(@Nonnull String sessionId, @Nonnull Subject subject,\n                      @Nonnull MoveInfo moveInfo, @Nullable String message) {\n        this.sessionId = sessionId;\n        this.subject = subject;\n        this.message = message;\n        this.moveInfo = moveInfo;\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testSessionMove() throws Exception {\n        String destPath = path + '/' + nodeName1;\n\n        // give 'add_child_nodes' and 'nt-management' privilege\n        // -> not sufficient privileges for a move\n        allow(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES, Privilege.JCR_NODE_TYPE_MANAGEMENT}));\n        try {\n            testSession.move(childNPath, destPath);\n            testSession.save();\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // add 'remove_child_nodes' at 'path\n        // -> not sufficient for a move since 'remove_node' privilege is missing\n        //    on the move-target\n        allow(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES));\n        try {\n            testSession.move(childNPath, destPath);\n            testSession.save();\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // allow 'remove_node' at childNPath\n        // -> now move must succeed\n        allow(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE));\n        testSession.move(childNPath, destPath);\n        testSession.save();\n\n        // withdraw  'add_child_nodes' privilege on former src-parent\n        // -> moving child-node back must fail\n        deny(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES));\n        try {\n            testSession.move(destPath, childNPath);\n            testSession.save();\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n    }","id":66767,"modified_method":"@Test\n    public void testSessionMove() throws Exception {\n        String destPath = path + '/' + nodeName1;\n\n        // give 'add_child_nodes' and 'nt-management' privilege\n        // -> not sufficient privileges for a move\n        allow(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES, Privilege.JCR_NODE_TYPE_MANAGEMENT}));\n        try {\n            testSession.move(childNPath, destPath);\n            testSession.save();\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // add 'remove_child_nodes' at 'path\n        // -> not sufficient for a move since 'remove_node' privilege is missing\n        //    on the move-target\n        allow(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES));\n        try {\n            testSession.move(childNPath, destPath);\n            testSession.save();\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // allow 'remove_node' at childNPath\n        // -> now move must succeed\n        allow(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE));\n        testSession.move(childNPath, destPath);\n        testSession.save();\n\n        // withdraw  'add_child_nodes' privilege on former src-parent\n        // -> moving child-node back must fail\n        deny(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES));\n        try {\n            testSession.move(destPath, childNPath);\n            testSession.save();\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testWorkspaceMove() throws Exception {\n        String destPath = path + '/' + nodeName1;\n\n        // give 'add_child_nodes', 'nt-mgmt' privilege\n        // -> not sufficient privileges for a move.\n        allow(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES,\n                Privilege.JCR_NODE_TYPE_MANAGEMENT}));\n        try {\n            testSession.getWorkspace().move(childNPath, destPath);\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // add 'remove_child_nodes' at 'path\n        // -> no sufficient for a move since 'remove_node' privilege is missing\n        //    on the move-target\n        allow(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES));\n        try {\n            testSession.getWorkspace().move(childNPath, destPath);\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // allow 'remove_node' at childNPath\n        // -> now move must succeed\n        allow(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE));\n        testSession.getWorkspace().move(childNPath, destPath);\n\n        // withdraw  'add_child_nodes' privilege on former src-parent\n        // -> moving child-node back must fail\n        deny(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES));\n        try {\n            testSession.getWorkspace().move(destPath, childNPath);\n            fail(\"Move requires add and remove permission.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n    }","id":66768,"modified_method":"@Test\n    public void testWorkspaceMove() throws Exception {\n        String destPath = path + '/' + nodeName1;\n\n        // give 'add_child_nodes', 'nt-mgmt' privilege\n        // -> not sufficient privileges for a move.\n        allow(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES,\n                Privilege.JCR_NODE_TYPE_MANAGEMENT}));\n        try {\n            testSession.getWorkspace().move(childNPath, destPath);\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // add 'remove_child_nodes' at 'path\n        // -> no sufficient for a move since 'remove_node' privilege is missing\n        //    on the move-target\n        allow(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES));\n        try {\n            testSession.getWorkspace().move(childNPath, destPath);\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n\n        // allow 'remove_node' at childNPath\n        // -> now move must succeed\n        allow(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE));\n        testSession.getWorkspace().move(childNPath, destPath);\n\n        // withdraw  'add_child_nodes' privilege on former src-parent\n        // -> moving child-node back must fail\n        deny(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES));\n        try {\n            testSession.getWorkspace().move(destPath, childNPath);\n            fail(\"Move requires addChildNodes and removeChildNodes privilege.\");\n        } catch (AccessDeniedException e) {\n            // success.\n        }\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public PermissionValidatorProvider(\n            SecurityProvider securityProvider, Subject subject) {\n        this.securityProvider = securityProvider;\n        this.acConfig = securityProvider.getConfiguration(AuthorizationConfiguration.class);\n\n        ConfigurationParameters params = acConfig.getParameters();\n        String compatValue = params.getConfigValue(PermissionConstants.PARAM_PERMISSIONS_JR2, null, String.class);\n        jr2Permissions = Permissions.getPermissions(compatValue);\n\n        this.subject = subject;\n    }","id":66769,"modified_method":"public PermissionValidatorProvider(SecurityProvider securityProvider, CommitInfo commitInfo) {\n        this.securityProvider = securityProvider;\n        this.acConfig = securityProvider.getConfiguration(AuthorizationConfiguration.class);\n\n        ConfigurationParameters params = acConfig.getParameters();\n        String compatValue = params.getConfigValue(PermissionConstants.PARAM_PERMISSIONS_JR2, null, String.class);\n        jr2Permissions = Permissions.getPermissions(compatValue);\n\n        this.commitInfo = commitInfo;\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private PermissionProvider getPermissionProvider() {\n        if (subject == null || subject.getPublicCredentials(PermissionProvider.class).isEmpty()) {\n            throw new IllegalStateException(\"Unable to validate permissions; no permission provider associated with the commit call.\");\n        } else {\n            return subject.getPublicCredentials(PermissionProvider.class).iterator().next();\n        }\n    }","id":66770,"modified_method":"private PermissionProvider getPermissionProvider() {\n        Subject subject = commitInfo.getSubject();\n        Set<PermissionProvider> pps = subject.getPublicCredentials(PermissionProvider.class);\n        if (pps.isEmpty()) {\n            throw new IllegalStateException(\"Unable to validate permissions; no permission provider associated with the commit call.\");\n        } else {\n            return pps.iterator().next();\n        }\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public Validator getRootValidator(NodeState before, NodeState after) {\n        ntMgr = ReadOnlyNodeTypeManager.getInstance(after);\n        PermissionProvider pp = getPermissionProvider();\n        return new PermissionValidator(createTree(before), createTree(after), pp, this);\n    }","id":66771,"modified_method":"@Nonnull\n    @Override\n    public Validator getRootValidator(NodeState before, NodeState after) {\n        ntMgr = ReadOnlyNodeTypeManager.getInstance(after);\n\n        PermissionProvider pp = getPermissionProvider();\n        // TODO\n        MoveInfo moveInfo = commitInfo.getMoveInfo();\n\n        return new PermissionValidator(createTree(before), createTree(after), pp, this);\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public List<? extends ValidatorProvider> getValidators(\n            String workspaceName, Subject subject) {\n        return Collections.singletonList(new PrivilegeValidatorProvider());\n    }","id":66772,"modified_method":"@Nonnull\n    @Override\n    public List<? extends ValidatorProvider> getValidators(String workspaceName, CommitInfo commitInfo) {\n        return Collections.singletonList(new PrivilegeValidatorProvider());\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public List<? extends ValidatorProvider> getValidators(\n            String workspaceName, Subject subject) {\n        return Collections.singletonList(new UserValidatorProvider(getParameters()));\n    }","id":66773,"modified_method":"@Nonnull\n    @Override\n    public List<? extends ValidatorProvider> getValidators(String workspaceName, CommitInfo commitInfo) {\n        return Collections.singletonList(new UserValidatorProvider(getParameters()));\n    }","commit_id":"0e6de90750497396ec9ab6c4307a14d593ded716","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n   public void addRightCommandSeparator()\n   {\n      headerBarPanel_.add(createCommandSeparator());\n   }","id":66774,"modified_method":"@Override\n   public Widget addRightCommandSeparator()\n   {\n      Widget separator = createCommandSeparator();\n      headerBarPanel_.add(separator);\n      return separator;\n   }","commit_id":"55e7ca38be2bca3161637deca71d6721ae7fe1c3","url":"https://github.com/rstudio/rstudio"},{"original_method":"void addRightCommandSeparator();","id":66775,"modified_method":"Widget addRightCommandSeparator();","commit_id":"55e7ca38be2bca3161637deca71d6721ae7fe1c3","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void addCommandSeparator()\n   {\n      headerBarCommandsPanel_.add(createCommandSeparator());\n   }","id":66776,"modified_method":"@Override\n   public Widget addCommandSeparator()\n   {\n      Widget separator = createCommandSeparator();\n      headerBarCommandsPanel_.add(separator);\n      return separator;\n   }","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void addProjectRightCommandSeparator()\n   {\n      toolbar_.addRightSeparator();\n   }","id":66777,"modified_method":"@Override\n   public Widget addProjectRightCommandSeparator()\n   {\n      return toolbar_.addRightSeparator();\n   }","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void addProjectCommandSeparator()\n   {\n      projectBarCommandsPanel_.add(createCommandSeparator());\n   }","id":66778,"modified_method":"@Override\n   public Widget addProjectCommandSeparator()\n   {\n      Widget separator = createCommandSeparator();\n      projectBarCommandsPanel_.add(separator);\n      return separator;\n   }","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"void addProjectCommandSeparator();","id":66779,"modified_method":"Widget addProjectCommandSeparator();","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"void addCommandSeparator();","id":66780,"modified_method":"Widget addCommandSeparator();","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"void addProjectRightCommandSeparator();","id":66781,"modified_method":"Widget addProjectRightCommandSeparator();","commit_id":"dde8a2c25d1284e94acea219ad9cd6b85ff1cee8","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n    public boolean isUp() {\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SERVER_STATUS, null))\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized for this operation\", Entitlements.getEntitlementContext().user());\n\n        Maybe<ManagementContext> mm = mgmtMaybe();\n        if (mm.isAbsent()) return false;\n        ManagementContext m = mm.get();\n        if (!m.isStartupComplete()) return false;\n        if (!m.isRunning()) return false;\n        return true;\n    }","id":66782,"modified_method":"@Override\n    public boolean isUp() {\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SERVER_STATUS, null))\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized for this operation\", Entitlements.getEntitlementContext().user());\n\n        Maybe<ManagementContext> mm = mgmtMaybe();\n        return !mm.isAbsent() && mm.get().isStartupComplete() && mm.get().isRunning();\n    }","commit_id":"f18707395b85601a3023e003b5af1757508a52bc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean isShuttingDown() {\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SERVER_STATUS, null))\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized for this operation\", Entitlements.getEntitlementContext().user());\n        Maybe<ManagementContext> mm = mgmtMaybe();\n        if (mm.isAbsent()) return false;\n        ManagementContext m = mm.get();\n        return (m.isStartupComplete() && !m.isRunning());\n    }","id":66783,"modified_method":"@Override\n    public boolean isShuttingDown() {\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SERVER_STATUS, null))\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized for this operation\", Entitlements.getEntitlementContext().user());\n        Maybe<ManagementContext> mm = mgmtMaybe();\n        return !mm.isAbsent() && mm.get().isStartupComplete() && !mm.get().isRunning();\n    }","commit_id":"f18707395b85601a3023e003b5af1757508a52bc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean isHealthy() {\n        if (!isUp()) return false;\n        if (!((ManagementContextInternal)mgmt()).errors().isEmpty()) return false;\n        return true;\n    }","id":66784,"modified_method":"@Override\n    public boolean isHealthy() {\n        return isUp() && ((ManagementContextInternal) mgmt()).errors().isEmpty();\n    }","commit_id":"f18707395b85601a3023e003b5af1757508a52bc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public Maybe<String> getTypeName() {\n            Maybe<Object> result = data.getStringKeyMaybe(getPreferredKeyName());\n            if (result.isAbsent() && typeKeyPrefix!=null) {\n                // try alternatives if a prefix was specified\n                result = data.getStringKeyMaybe(typeKeyPrefix+\"Type\");\n                if (result.isAbsent()) result = data.getStringKeyMaybe(\"type\");\n            }\n            \n            if (result.isAbsent()) return Maybe.absent(\"Missing key '\"+getPreferredKeyName()+\"'\");\n            \n            if (result.get() instanceof String) return Maybe.of((String)result.get());\n            \n            throw new IllegalArgumentException(\"Invalid value \"+result.get().getClass()+\" for \"+getPreferredKeyName()+\"; \"\n                + \"expected String, got \"+result.get());\n        }","id":66785,"modified_method":"public Maybe<String> getTypeName() {\n            Maybe<Object> result = data.getStringKeyMaybe(getPreferredKeyName());\n            if (result.isAbsent() && typeKeyPrefix!=null) {\n                // try alternatives if a prefix was specified\n                result = data.getStringKeyMaybe(typeKeyPrefix+\"Type\");\n                if (result.isAbsent()) result = data.getStringKeyMaybe(\"type\");\n            }\n            \n            if (result.isAbsent() || result.get()==null) \n                return Maybe.absent(\"Missing key '\"+getPreferredKeyName()+\"'\");\n            \n            if (result.get() instanceof String) return Maybe.of((String)result.get());\n            \n            throw new IllegalArgumentException(\"Invalid value \"+result.get().getClass()+\" for \"+getPreferredKeyName()+\"; \"\n                + \"expected String, got \"+result.get());\n        }","commit_id":"e75dc3031cc80958ae574697e12814d04f5b6681","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Maps a throwable to a response.\n     * <p/>\n     * Returns {@link WebApplicationException#getResponse} if the exception is an instance of\n     * {@link WebApplicationException}. Otherwise maps known exceptions to responses. If no\n     * mapping is found a {@link Status#INTERNAL_SERVER_ERROR} is assumed.\n     */\n    @Override\n    public Response toResponse(Throwable throwable) {\n\n        LOG.debug(\"REST request running as {} threw: {}\", Entitlements.getEntitlementContext(), throwable);\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Full details of \"+Entitlements.getEntitlementContext()+\" \"+throwable, throwable);\n        }\n\n        // Some methods will throw this, which gets converted automatically\n        if (throwable instanceof WebApplicationException) {\n            WebApplicationException wae = (WebApplicationException) throwable;\n            return wae.getResponse();\n        }\n\n        // The nicest way for methods to provide errors, wrap as this, and the stack trace will be suppressed\n        if (throwable instanceof UserFacingException) {\n            return ApiError.of(throwable.getMessage()).asBadRequestResponseJson();\n        }\n\n        // For everything else, a trace is supplied\n        \n        // Assume ClassCoercionExceptions are caused by TypeCoercions from input parameters gone wrong\n        // And IllegalArgumentException for malformed input parameters.\n        if (throwable instanceof ClassCoercionException || throwable instanceof IllegalArgumentException) {\n            return ApiError.of(throwable).asBadRequestResponseJson();\n        }\n\n        // YAML exception \n        if (throwable instanceof YAMLException) {\n            return ApiError.builder().message(throwable.getMessage()).prefixMessage(\"Invalid YAML\").build().asBadRequestResponseJson();\n        }\n\n        if (!Exceptions.isPrefixBoring(throwable)) {\n            if ( warnedUnknownExceptions.add( throwable.getClass() )) {\n                LOG.warn(\"REST call generated exception type \"+throwable.getClass()+\" unrecognized in \"+getClass()+\" (subsequent occurrences will be logged debug only): \" + throwable, throwable);\n            }\n        }\n        \n        Builder rb = ApiError.builderFromThrowable(throwable);\n        if (Strings.isBlank(rb.getMessage()))\n            rb.message(\"Internal error. Contact server administrator to consult logs for more details.\");\n        return rb.build().asResponse(Status.INTERNAL_SERVER_ERROR, MediaType.APPLICATION_JSON_TYPE);\n    }","id":66786,"modified_method":"/**\n     * Maps a throwable to a response.\n     * <p/>\n     * Returns {@link WebApplicationException#getResponse} if the exception is an instance of\n     * {@link WebApplicationException}. Otherwise maps known exceptions to responses. If no\n     * mapping is found a {@link Status#INTERNAL_SERVER_ERROR} is assumed.\n     */\n    @Override\n    public Response toResponse(Throwable throwable1) {\n\n        LOG.debug(\"REST request running as {} threw: {}\", Entitlements.getEntitlementContext(), \n            Exceptions.collapse(throwable1));\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Full details of \"+Entitlements.getEntitlementContext()+\" \"+throwable1, throwable1);\n        }\n\n        Throwable throwable2 = Exceptions.getFirstInteresting(throwable1);\n        // Some methods will throw this, which gets converted automatically\n        if (throwable2 instanceof WebApplicationException) {\n            WebApplicationException wae = (WebApplicationException) throwable2;\n            return wae.getResponse();\n        }\n\n        // The nicest way for methods to provide errors, wrap as this, and the stack trace will be suppressed\n        if (throwable2 instanceof UserFacingException) {\n            return ApiError.of(throwable2.getMessage()).asBadRequestResponseJson();\n        }\n\n        // For everything else, a trace is supplied\n        \n        // Assume ClassCoercionExceptions are caused by TypeCoercions from input parameters gone wrong\n        // And IllegalArgumentException for malformed input parameters.\n        if (throwable2 instanceof ClassCoercionException || throwable2 instanceof IllegalArgumentException) {\n            return ApiError.of(throwable2).asBadRequestResponseJson();\n        }\n\n        // YAML exception \n        if (throwable2 instanceof YAMLException) {\n            return ApiError.builder().message(throwable2.getMessage()).prefixMessage(\"Invalid YAML\").build().asBadRequestResponseJson();\n        }\n\n        if (!Exceptions.isPrefixBoring(throwable2)) {\n            if ( warnedUnknownExceptions.add( throwable2.getClass() )) {\n                LOG.warn(\"REST call generated exception type \"+throwable2.getClass()+\" unrecognized in \"+getClass()+\" (subsequent occurrences will be logged debug only): \" + throwable2, throwable2);\n            }\n        }\n        \n        Builder rb = ApiError.builderFromThrowable(Exceptions.collapse(throwable2));\n        if (Strings.isBlank(rb.getMessage()))\n            rb.message(\"Internal error. Contact server administrator to consult logs for more details.\");\n        return rb.build().asResponse(Status.INTERNAL_SERVER_ERROR, MediaType.APPLICATION_JSON_TYPE);\n    }","commit_id":"e75dc3031cc80958ae574697e12814d04f5b6681","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  public Response addChildren(String applicationToken, String entityToken, Boolean start, String timeoutS, String yaml) {\n        final EntityLocal parent = brooklyn().getEntity(applicationToken, entityToken);\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, parent)) {\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized to modify entity '%s'\",\n                Entitlements.getEntitlementContext().user(), entityToken);\n        }\n        Duration timeout = timeoutS==null ? Duration.millis(20) : Duration.of(timeoutS);\n        \n        log.debug(\"Creating child of \"+parent+\" from yaml:\\n{}\", yaml);\n        Reader input = new StringReader(yaml);\n        AssemblyTemplate at = camp().pdp().registerDeploymentPlan(input);\n\n        AssemblyTemplateInstantiator instantiator;\n        try {\n            instantiator = at.getInstantiator().newInstance();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n        if (instantiator instanceof AssemblyTemplateSpecInstantiator) {\n            BrooklynClassLoadingContext loader = JavaBrooklynClassLoadingContext.newDefault(mgmt());\n            EntitySpec<?> specA = ((AssemblyTemplateSpecInstantiator) instantiator).createSpec(at, camp(), loader, false);\n            \n            boolean promoted;\n            \n            // see whether we can promote children\n            List<EntitySpec<?>> specs = MutableList.of();\n            if (BrooklynAssemblyTemplateInstantiator.hasNoNameOrCustomKeysOrRoot(at, specA)) {\n                // we can promote\n                promoted = true;\n                for (EntitySpec<?> specC: specA.getChildren()) {\n                    if (!specA.getLocations().isEmpty())\n                        specC.locations(specA.getLocations());\n                    specs.add(specC);\n                }\n            } else {\n                // if not promoting, set a nice name if needed\n                if (Strings.isEmpty(specA.getDisplayName())) {\n                    int size = specA.getChildren().size();\n                    String childrenCountString = size+\" \"+(size!=1 ? \"children\" : \"child\");\n                    specA.displayName(\"Dynamically added \"+childrenCountString);\n                }\n                promoted = false;\n                specs.add(specA);\n            }\n            \n            final List<Entity> children = MutableList.of();\n            for (EntitySpec<?> spec: specs) {\n                Entity child = (Entity)parent.addChild(spec);\n                Entities.manage(child);\n                children.add(child);\n            }\n\n            String childrenCountString;\n            if (promoted) {\n                int size = children.size();\n                childrenCountString = size+\" \"+(size!=1 ? \"children\" : \"child\"); \n            } else {\n                int size = specA.getChildren().size();\n                childrenCountString = \"entity with \"+size+\" \"+(size!=1 ? \"children\" : \"child\");\n            }\n\n            TaskBuilder<List<String>> taskM = Tasks.<List<String>>builder().name(\"add children\")\n                .dynamic(true)\n                .tag(BrooklynTaskTags.NON_TRANSIENT_TASK_TAG)\n                .body(new Callable<List<String>>() {\n                    @Override public List<String> call() throws Exception {\n                        return ImmutableList.copyOf(Iterables.transform(children, EntityFunctions.id()));\n                    }})\n                .description(\"Add\" + (start==null ? \" and potentially start\" : start ? \" and start\" : \"\") + \" \"+childrenCountString);\n            TaskBuilder<?> taskS = Tasks.builder().parallel(true).name(\"add (parallel)\")\n                .description(\n                    (start==null ? \"Add or start\" : start ? \"Start\" : \"Add\")+\" each new entity\");\n\n            // should we autostart?\n            for (Entity child: children) {\n                if (Boolean.TRUE.equals(start) || (start==null && child instanceof Startable)) {\n                    taskS.add(Effectors.invocation(child, Startable.START, ImmutableMap.of(\"locations\", ImmutableList.of())));\n                } else {\n                    taskS.add(Tasks.builder().name(\"create\").description(\"Created and added as child of \"+parent)\n                        .body(new Runnable() { public void run() {} })\n                        .tag(BrooklynTaskTags.tagForTargetEntity(child))\n                        .build());\n                }\n            }\n            taskM.add(taskS.build());\n            Task<List<String>> task = Entities.submit(parent, taskM.build());\n            \n            // wait a few ms in case start is trivially simple, save the client a call to get the task result\n            task.blockUntilEnded(timeout);\n\n            if (children.size()==1) {\n                Entity child = Iterables.getOnlyElement(children);\n                URI ref = uriInfo.getBaseUriBuilder()\n                    .path(EntityApi.class)\n                    .path(EntityApi.class, \"get\")\n                    .build(child.getApplicationId(), child.getId());\n                return created(ref).entity(TaskTransformer.taskSummary(task)).build();\n            } else {\n                return Response.status(Status.CREATED).entity(TaskTransformer.taskSummary(task)).build();\n            }\n        } else {\n            throw new IllegalStateException(\"Add children only supported for spec instantiator instances\");\n        }\n  }","id":66787,"modified_method":"@Override\n  public Response addChildren(String applicationToken, String entityToken, Boolean start, String timeoutS, String yaml) {\n        final EntityLocal parent = brooklyn().getEntity(applicationToken, entityToken);\n        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, parent)) {\n            throw WebResourceUtils.unauthorized(\"User '%s' is not authorized to modify entity '%s'\",\n                Entitlements.getEntitlementContext().user(), entityToken);\n        }\n        Duration timeout = timeoutS==null ? Duration.millis(20) : Duration.of(timeoutS);\n        \n        log.debug(\"Creating child of \"+parent+\" from yaml:\\n{}\", yaml);\n        Reader input = new StringReader(yaml);\n        AssemblyTemplate at = camp().pdp().registerDeploymentPlan(input);\n\n        AssemblyTemplateInstantiator instantiator;\n        try {\n            instantiator = at.getInstantiator().newInstance();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n        if (instantiator instanceof AssemblyTemplateSpecInstantiator) {\n            BrooklynClassLoadingContext loader = JavaBrooklynClassLoadingContext.newDefault(mgmt());\n            EntitySpec<?> specA = ((AssemblyTemplateSpecInstantiator) instantiator).createSpec(at, camp(), loader, false);\n            \n            boolean promoted;\n            \n            // see whether we can promote children\n            List<EntitySpec<?>> specs = MutableList.of();\n            if (BrooklynAssemblyTemplateInstantiator.hasNoNameOrCustomKeysOrRoot(at, specA)) {\n                // we can promote\n                promoted = true;\n                for (EntitySpec<?> specC: specA.getChildren()) {\n                    if (!specA.getLocations().isEmpty())\n                        specC.locations(specA.getLocations());\n                    specs.add(specC);\n                }\n            } else {\n                // if not promoting, set a nice name if needed\n                if (Strings.isEmpty(specA.getDisplayName())) {\n                    int size = specA.getChildren().size();\n                    String childrenCountString = size+\" \"+(size!=1 ? \"children\" : \"child\");\n                    specA.displayName(\"Dynamically added \"+childrenCountString);\n                }\n                promoted = false;\n                specs.add(specA);\n            }\n            \n            final List<Entity> children = MutableList.of();\n            for (EntitySpec<?> spec: specs) {\n                Entity child = (Entity)parent.addChild(spec);\n                Entities.manage(child);\n                children.add(child);\n            }\n\n            String childrenCountString;\n            if (promoted) {\n                int size = children.size();\n                childrenCountString = size+\" \"+(size!=1 ? \"children\" : \"child\"); \n            } else {\n                int size = specA.getChildren().size();\n                childrenCountString = \"entity with \"+size+\" \"+(size!=1 ? \"children\" : \"child\");\n            }\n\n            TaskBuilder<List<String>> taskM = Tasks.<List<String>>builder().name(\"add children\")\n                .dynamic(true)\n                .tag(BrooklynTaskTags.NON_TRANSIENT_TASK_TAG)\n                .body(new Callable<List<String>>() {\n                    @Override public List<String> call() throws Exception {\n                        return ImmutableList.copyOf(Iterables.transform(children, EntityFunctions.id()));\n                    }})\n                .description(\"Add\" + (start==null ? \" and potentially start\" : start ? \" and start\" : \"\") + \" \"+childrenCountString);\n            TaskBuilder<?> taskS = Tasks.builder().parallel(true).name(\"add (parallel)\")\n                .description(\n                    (start==null ? \"Add or start\" : start ? \"Start\" : \"Add\")+\" each new entity\");\n\n            // should we autostart?\n            for (Entity child: children) {\n                if (Boolean.TRUE.equals(start) || (start==null && child instanceof Startable)) {\n                    taskS.add(Effectors.invocation(child, Startable.START, ImmutableMap.of(\"locations\", ImmutableList.of())));\n                } else {\n                    taskS.add(Tasks.builder().name(\"create\").description(\"Created and added as child of \"+parent)\n                        .body(new Runnable() { public void run() {} })\n                        .tag(BrooklynTaskTags.tagForTargetEntity(child))\n                        .build());\n                }\n            }\n            taskM.add(taskS.build());\n            Task<List<String>> task = Entities.submit(parent, taskM.build());\n            \n            // wait a few ms in case start is trivially simple, save the client a call to get the task result\n            task.blockUntilEnded(timeout);\n\n            if (children.size()==1) {\n                Entity child = Iterables.getOnlyElement(children);\n                URI ref = uriInfo.getBaseUriBuilder()\n                    .path(EntityApi.class)\n                    .path(EntityApi.class, \"get\")\n                    .build(child.getApplicationId(), child.getId());\n                return created(ref).entity(TaskTransformer.taskSummary(task)).build();\n            } else {\n                return Response.status(Status.CREATED).entity(TaskTransformer.taskSummary(task)).build();\n            }\n        } else {\n            throw new IllegalStateException(\"Spec could not be parsed to supply a compatible instantiator\");\n        }\n  }","commit_id":"e75dc3031cc80958ae574697e12814d04f5b6681","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected int getNextLineIndent() {\n    int indent = super.getNextLineIndent();\n    if (!ourIgnoreSet.contains(getBaseTokenType()))\n      return indent;\n\n    indent = 0;\n    while (getBaseTokenType() != null && ourIgnoreSet.contains(getBaseTokenType()))\n      advanceBase();\n    while (getBaseTokenType() != null && PyTokenTypes.WHITESPACE.contains(getBaseTokenType())) {\n      if (getBaseTokenType() == PyTokenTypes.TAB) {\n        indent = ((indent / 8) + 1) * 8;\n      }\n      else if (getBaseTokenType() == PyTokenTypes.SPACE) {\n        indent++;\n      }\n      advanceBase();\n    }\n    if (getBaseTokenType() == null) {\n      return 0;\n    }\n    return indent > 0? indent - 1 : indent;\n  }","id":66788,"modified_method":"@Override\n  protected int getNextLineIndent() {\n    int indent = super.getNextLineIndent();\n    if (!ourIgnoreSet.contains(getBaseTokenType()))\n      return indent;\n\n    indent = 0;\n    while (getBaseTokenType() != null && ourIgnoreSet.contains(getBaseTokenType()))\n      advanceBase();\n    while (getBaseTokenType() != null && PyTokenTypes.WHITESPACE.contains(getBaseTokenType())) {\n      if (getBaseTokenType() == PyTokenTypes.TAB) {\n        indent = ((indent / 8) + 1) * 8;\n      }\n      else if (getBaseTokenType() == PyTokenTypes.SPACE) {\n        indent++;\n      }\n      advanceBase();\n    }\n    if (getBaseTokenType() == PyTokenTypes.LINE_BREAK) {\n      advanceBase();\n      return 0;\n    }\n\n    if (getBaseTokenType() == null) {\n      return 0;\n    }\n    return indent > 0? indent - 1 : indent;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initErrorValidation() {\n    final FacetErrorPanel facetErrorPanel = new FacetErrorPanel();\n    myErrorPanel.add(facetErrorPanel.getComponent(), BorderLayout.CENTER);\n\n    facetErrorPanel.getValidatorsManager().registerValidator(new FacetEditorValidator() {\n      @Override\n      public ValidationResult check() {\n        Module[] modules = ModuleManager.getInstance(myProject).getModules();\n        if (modules.length == 0) return ValidationResult.OK;\n        final Sdk sdk = PythonSdkType.findPythonSdk(modules[0]);\n        if (sdk != null) {\n          final Object selectedItem = myTestRunnerComboBox.getSelectedItem();\n          if (PythonTestConfigurationsModel.PY_TEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isPyTestInstalled(sdk.getHomePath())) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"py.test\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.PY_TEST));\n            }\n          }\n          else if (PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isNoseTestInstalled(sdk.getHomePath())) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"nosetest\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.NOSE_TEST));\n            }\n          }\n          else if (PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isAtTestInstalled(sdk.getHomePath())) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"attest\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.AT_TEST));\n            }\n          }\n        }\n        return ValidationResult.OK;\n      }\n    }, myTestRunnerComboBox);\n\n    facetErrorPanel.getValidatorsManager().validate();\n  }","id":66789,"modified_method":"private void initErrorValidation() {\n    final FacetErrorPanel facetErrorPanel = new FacetErrorPanel();\n    myErrorPanel.add(facetErrorPanel.getComponent(), BorderLayout.CENTER);\n\n    facetErrorPanel.getValidatorsManager().registerValidator(new FacetEditorValidator() {\n      @Override\n      public ValidationResult check() {\n        Module[] modules = ModuleManager.getInstance(myProject).getModules();\n        if (modules.length == 0) return ValidationResult.OK;\n        final Sdk sdk = PythonSdkType.findPythonSdk(modules[0]);\n        if (sdk != null) {\n          final Object selectedItem = myTestRunnerComboBox.getSelectedItem();\n          if (PythonTestConfigurationsModel.PY_TEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isPyTestInstalled(sdk)) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"py.test\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.PY_TEST));\n            }\n          }\n          else if (PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isNoseTestInstalled(sdk)) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"nosetest\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.NOSE_TEST));\n            }\n          }\n          else if (PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME.equals(selectedItem)) {\n            if (!VFSTestFrameworkListener.getInstance().isAtTestInstalled(sdk)) {\n              return new ValidationResult(PyBundle.message(\"runcfg.testing.no.test.framework\", \"attest\"),\n                                          createQuickFix(sdk, facetErrorPanel, PyNames.AT_TEST));\n            }\n          }\n        }\n        return ValidationResult.OK;\n      }\n    }, myTestRunnerComboBox);\n\n    facetErrorPanel.getValidatorsManager().validate();\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    if (StringUtil.isEmptyOrSpaces(myTestToRun)) {\n      throw new RuntimeConfigurationError(\"Please specify target folder or script\");\n    }\n    if (!VFSTestFrameworkListener.getInstance().isPyTestInstalled(getInterpreterPath()))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"py.test\"));\n  }","id":66790,"modified_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    if (StringUtil.isEmptyOrSpaces(myTestToRun)) {\n      throw new RuntimeConfigurationError(\"Please specify target folder or script\");\n    }\n    if (!VFSTestFrameworkListener.getInstance().isPyTestInstalled(PythonSdkType.findSdkByPath(getInterpreterPath())))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"py.test\"));\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isPyTestInstalled(Module module) {\n    // TODO[yole] add caching to avoid disk I/O in findPyTestRunner()?\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    return sdk != null && VFSTestFrameworkListener.getInstance().isPyTestInstalled(sdk.getHomePath());\n  }","id":66791,"modified_method":"private static boolean isPyTestInstalled(Module module) {\n    // TODO[yole] add caching to avoid disk I/O in findPyTestRunner()?\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    return sdk != null && VFSTestFrameworkListener.getInstance().isPyTestInstalled(sdk);\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String detectTestRunnerFromSetupPy(Project project) {\n    String testRunner = \"\";\n    final Module[] modules = ModuleManager.getInstance(project).getModules();\n    for (Module module : modules) {\n      if (!testRunner.isEmpty()) break;\n      final PyFile setupPy = PyPackageUtil.findSetupPy(module);\n      if (setupPy == null)\n        continue;\n      final PyCallExpression setupCall = PyPackageUtil.findSetupCall(setupPy);\n      if (setupCall == null)\n        continue;\n      for (PyExpression arg : setupCall.getArguments()) {\n        if (arg instanceof PyKeywordArgument) {\n          final PyKeywordArgument kwarg = (PyKeywordArgument)arg;\n          if (\"test_loader\".equals(kwarg.getKeyword()) || \"test_suite\".equals(kwarg.getKeyword())) {\n            final PyExpression value = kwarg.getValueExpression();\n            if (value instanceof PyStringLiteralExpression) {\n              final String stringValue = ((PyStringLiteralExpression)value).getStringValue();\n              if (stringValue.contains(PyNames.NOSE_TEST)) {\n                testRunner = PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n                break;\n              }\n              if (stringValue.contains(PyNames.PY_TEST)) {\n                testRunner = PythonTestConfigurationsModel.PY_TEST_NAME;\n                break;\n              }\n              if (stringValue.contains(PyNames.AT_TEST)) {\n                testRunner = PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return testRunner;\n  }","id":66792,"modified_method":"private static String detectTestRunnerFromSetupPy(Project project) {\n    String testRunner = \"\";\n    final Module[] modules = ModuleManager.getInstance(project).getModules();\n    for (Module module : modules) {\n      if (!testRunner.isEmpty()) break;\n      final PyFile setupPy = PyPackageUtil.findSetupPy(module);\n      if (setupPy == null)\n        continue;\n      final PyCallExpression setupCall = PyPackageUtil.findSetupCall(setupPy);\n      if (setupCall == null)\n        continue;\n      for (PyExpression arg : setupCall.getArguments()) {\n        if (arg instanceof PyKeywordArgument) {\n          final PyKeywordArgument kwarg = (PyKeywordArgument)arg;\n          if (\"test_loader\".equals(kwarg.getKeyword()) || \"test_suite\".equals(kwarg.getKeyword())) {\n            final PyExpression value = kwarg.getValueExpression();\n            if (value instanceof PyStringLiteralExpression) {\n              final String stringValue = ((PyStringLiteralExpression)value).getStringValue();\n              if (stringValue.contains(PyNames.NOSE_TEST)) {\n                testRunner = PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n                break;\n              }\n              if (stringValue.contains(PyNames.PY_TEST)) {\n                testRunner = PythonTestConfigurationsModel.PY_TEST_NAME;\n                break;\n              }\n              if (stringValue.contains(PyNames.AT_TEST_IMPORT)) {\n                testRunner = PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return testRunner;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void updateIntegratedTools(final Project project, final int delay) {\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      public void run() {\n        if (delay > 0) {\n          try {\n            Thread.sleep(delay); // wait until all short-term disk-hitting activity ceases\n          }\n          catch (InterruptedException ignore) {\n          }\n        }\n\n\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (!TestRunnerService.getInstance(project).getProjectConfiguration().isEmpty())\n              return;\n\n            //check setup.py\n            String testRunner = detectTestRunnerFromSetupPy(project);\n\n            //try to find test_runner import\n            final Collection<VirtualFile> filenames = FilenameIndex.getAllFilesByExt(project, PythonFileType.INSTANCE.getDefaultExtension(),\n                                                                                     GlobalSearchScope.projectScope(project));\n\n            for (VirtualFile file : filenames){\n              if (file.getName().startsWith(\"test\")) {\n                if (testRunner.isEmpty()) testRunner = checkImports(file, project);   //find test runner import\n              }\n              else {\n                if (PyDocumentationSettings.getInstance(project).getFormat().isEmpty()) {\n                  checkDocstring(file, project);    // detect docstring type\n                }\n              }\n              if (!testRunner.isEmpty() && !PyDocumentationSettings.getInstance(project).getFormat().isEmpty()) {\n                break;\n              }\n            }\n            if (testRunner.isEmpty()) {\n              //check if installed in sdk\n              for (Module module : ModuleManager.getInstance(project).getModules()) {\n                final Sdk sdk = PythonSdkType.findPythonSdk(module);\n                if (sdk != null && sdk.getSdkType() instanceof PythonSdkType && testRunner.isEmpty()) {\n                  String sdkHome = sdk.getHomePath();\n                  if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdkHome, VFSTestFrameworkListener.NOSETESTSEARCHER))\n                    testRunner = PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n                  else if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdkHome, VFSTestFrameworkListener.PYTESTSEARCHER))\n                    testRunner = PythonTestConfigurationsModel.PY_TEST_NAME;\n                  else if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdkHome, VFSTestFrameworkListener.ATTESTSEARCHER))\n                    testRunner = PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n                }\n\n              }\n            }\n\n            if (testRunner.isEmpty()) testRunner = PythonTestConfigurationsModel.PYTHONS_UNITTEST_NAME;\n\n            TestRunnerService.getInstance(project).setProjectConfiguration(testRunner);\n            if (PyDocumentationSettings.getInstance(project).getFormat().isEmpty())\n              PyDocumentationSettings.getInstance(project).setFormat(DocStringFormat.PLAIN);\n          }\n        }, ModalityState.any(), project.getDisposed());\n      }\n    });\n  }","id":66793,"modified_method":"private static void updateIntegratedTools(final Project project, final int delay) {\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      public void run() {\n        if (delay > 0) {\n          try {\n            Thread.sleep(delay); // wait until all short-term disk-hitting activity ceases\n          }\n          catch (InterruptedException ignore) {\n          }\n        }\n\n\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (!TestRunnerService.getInstance(project).getProjectConfiguration().isEmpty())\n              return;\n\n            //check setup.py\n            String testRunner = detectTestRunnerFromSetupPy(project);\n\n            //try to find test_runner import\n            final Collection<VirtualFile> filenames = FilenameIndex.getAllFilesByExt(project, PythonFileType.INSTANCE.getDefaultExtension(),\n                                                                                     GlobalSearchScope.projectScope(project));\n\n            for (VirtualFile file : filenames){\n              if (file.getName().startsWith(\"test\")) {\n                if (testRunner.isEmpty()) testRunner = checkImports(file, project);   //find test runner import\n              }\n              else {\n                if (PyDocumentationSettings.getInstance(project).getFormat().isEmpty()) {\n                  checkDocstring(file, project);    // detect docstring type\n                }\n              }\n              if (!testRunner.isEmpty() && !PyDocumentationSettings.getInstance(project).getFormat().isEmpty()) {\n                break;\n              }\n            }\n            if (testRunner.isEmpty()) {\n              //check if installed in sdk\n              for (Module module : ModuleManager.getInstance(project).getModules()) {\n                final Sdk sdk = PythonSdkType.findPythonSdk(module);\n                if (sdk != null && sdk.getSdkType() instanceof PythonSdkType && testRunner.isEmpty()) {\n                  String sdkHome = sdk.getHomePath();\n                  if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdk, PyNames.NOSE_TEST))\n                    testRunner = PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n                  else if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdk, PyNames.PY_TEST))\n                    testRunner = PythonTestConfigurationsModel.PY_TEST_NAME;\n                  else if (VFSTestFrameworkListener.isTestFrameworkInstalled(sdk, PyNames.AT_TEST))\n                    testRunner = PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n                }\n\n              }\n            }\n\n            if (testRunner.isEmpty()) testRunner = PythonTestConfigurationsModel.PYTHONS_UNITTEST_NAME;\n\n            TestRunnerService.getInstance(project).setProjectConfiguration(testRunner);\n            if (PyDocumentationSettings.getInstance(project).getFormat().isEmpty())\n              PyDocumentationSettings.getInstance(project).setFormat(DocStringFormat.PLAIN);\n          }\n        }, ModalityState.any(), project.getDisposed());\n      }\n    });\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String checkImports(VirtualFile file, Project project) {\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (psiFile instanceof PyFile) {\n      final List<PyImportElement> importTargets = ((PyFile)psiFile).getImportTargets();\n      for (PyImportElement importElement : importTargets) {\n        if (PyNames.NOSE_TEST.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n        }\n        if (PyNames.PY_TEST.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PY_TEST_NAME;\n        }\n        if (PyNames.AT_TEST.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n        }\n      }\n    }\n    return \"\";\n  }","id":66794,"modified_method":"private static String checkImports(VirtualFile file, Project project) {\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (psiFile instanceof PyFile) {\n      final List<PyImportElement> importTargets = ((PyFile)psiFile).getImportTargets();\n      for (PyImportElement importElement : importTargets) {\n        if (PyNames.NOSE_TEST.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME;\n        }\n        if (PyNames.PY_TEST.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PY_TEST_NAME;\n        }\n        if (PyNames.AT_TEST_IMPORT.equals(importElement.getVisibleName())) {\n          return PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME;\n        }\n      }\n    }\n    return \"\";\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    if (!VFSTestFrameworkListener.getInstance().isAtTestInstalled(getInterpreterPath()))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"attest\"));\n  }","id":66795,"modified_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    if (!VFSTestFrameworkListener.getInstance().isAtTestInstalled(PythonSdkType.findSdkByPath(getInterpreterPath())))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"attest\"));\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    if (!VFSTestFrameworkListener.getInstance().isNoseTestInstalled(getInterpreterPath()))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"nosetest\"));\n  }","id":66796,"modified_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    if (!VFSTestFrameworkListener.getInstance().isNoseTestInstalled(PythonSdkType.findSdkByPath(getInterpreterPath())))\n      throw new RuntimeConfigurationWarning(PyBundle.message(\"runcfg.testing.no.test.framework\", \"nosetest\"));\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateAllTestFrameworks(final String sdkHome) {\n    updateTestFrameworks(sdkHome, PYTESTSEARCHER, PyNames.PY_TEST);\n    updateTestFrameworks(sdkHome, NOSETESTSEARCHER, PyNames.NOSE_TEST);\n    updateTestFrameworks(sdkHome, ATTESTSEARCHER, PyNames.AT_TEST);\n    myQueue.flush();\n  }","id":66797,"modified_method":"public void updateAllTestFrameworks(final Sdk sdk) {\n    updateTestFrameworks(sdk, PyNames.PY_TEST);\n    updateTestFrameworks(sdk, PyNames.NOSE_TEST);\n    updateTestFrameworks(sdk, PyNames.AT_TEST);\n    myQueue.flush();\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VFSTestFrameworkListener() {\n    MessageBus messageBus = ApplicationManager.getApplication().getMessageBus();\n    messageBus.connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        for (VFileEvent event : events) {\n          String path = event.getPath();\n          boolean containsNose = path.contains(PyNames.NOSE_TEST);\n          boolean containsPy = path.contains(\"py-1\") || path.contains(PyNames.PY_TEST);\n          boolean containsAt = path.contains(PyNames.AT_TEST);\n          if (!containsAt && !containsNose && !containsPy) continue;\n          SDKLOOP:\n          for (Sdk sdk : PythonSdkType.getAllSdks()) {\n            for (String root : sdk.getRootProvider().getUrls(OrderRootType.CLASSES)) {\n              if (path.contains(root)) {\n                if (containsNose) {\n                  updateTestFrameworks(sdk.getHomePath(), NOSETESTSEARCHER, PyNames.NOSE_TEST);\n                  break SDKLOOP;\n                }\n                else if (containsPy) {\n                  updateTestFrameworks(sdk.getHomePath(), PYTESTSEARCHER, PyNames.PY_TEST);\n                  break SDKLOOP;\n                } else {\n                  updateTestFrameworks(sdk.getHomePath(), ATTESTSEARCHER, PyNames.AT_TEST);\n                  break SDKLOOP;\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n  }","id":66798,"modified_method":"public VFSTestFrameworkListener() {\n    MessageBus messageBus = ApplicationManager.getApplication().getMessageBus();\n    messageBus.connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        for (VFileEvent event : events) {\n          String path = event.getPath();\n          boolean containsNose = path.contains(PyNames.NOSE_TEST);\n          boolean containsPy = path.contains(\"py-1\") || path.contains(PyNames.PY_TEST);\n          boolean containsAt = path.contains(PyNames.AT_TEST);\n          if (!containsAt && !containsNose && !containsPy) continue;\n          SDKLOOP:\n          for (Sdk sdk : PythonSdkType.getAllSdks()) {\n            for (String root : sdk.getRootProvider().getUrls(OrderRootType.CLASSES)) {\n              if (path.contains(root)) {\n                if (containsNose) {\n                  updateTestFrameworks(sdk, PyNames.NOSE_TEST);\n                  break SDKLOOP;\n                }\n                else if (containsPy) {\n                  updateTestFrameworks(sdk, PyNames.PY_TEST);\n                  break SDKLOOP;\n                } else {\n                  updateTestFrameworks(sdk, PyNames.AT_TEST);\n                  break SDKLOOP;\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isNoseTestInstalled(final String sdkHome) {\n    Boolean isInstalled = SDK_TO_NOSETEST.get(sdkHome);\n    if (isInstalled == null) {\n      updateTestFrameworks(sdkHome, NOSETESTSEARCHER, PyNames.NOSE_TEST);\n      return true;\n    }\n    return isInstalled;\n  }","id":66799,"modified_method":"public boolean isNoseTestInstalled(final Sdk sdk) {\n    Boolean isInstalled = SDK_TO_NOSETEST.get(sdk.getHomePath());\n    if (isInstalled == null) {\n      updateTestFrameworks(sdk, PyNames.NOSE_TEST);\n      return true;\n    }\n    return isInstalled;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pyTestInstalled(boolean installed, String sdkHome) {\n    SDK_TO_PYTEST.put(sdkHome, installed);\n  }","id":66800,"modified_method":"public boolean isAtTestInstalled(final Sdk sdk) {\n    Boolean isInstalled = SDK_TO_ATTEST.get(sdk.getHomePath());\n    if (isInstalled == null) {\n      updateTestFrameworks(sdk, PyNames.AT_TEST);\n      return true;\n    }\n    return isInstalled;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateTestFrameworks(final String sdkHome, final String searcher, final String sdkType) {\n    myQueue.queue(new Update(Pair.create(sdkHome, searcher)) {\n      @Override\n      public void run() {\n        testInstalled(isTestFrameworkInstalled(sdkHome, searcher), sdkHome, sdkType);\n      }\n    });\n  }","id":66801,"modified_method":"public static boolean isTestFrameworkInstalled(Sdk sdk, String testPackageName) {\n    if (sdk == null || StringUtil.isEmptyOrSpaces(sdk.getHomePath())) {\n      LOG.info(\"Searching test runner in empty sdk\");\n      return false;\n    }\n    final PyPackageManagerImpl packageManager = (PyPackageManagerImpl)PyPackageManager.getInstance(sdk);\n    try {\n      return packageManager.findPackage(testPackageName) != null;\n    }\n    catch (PyExternalProcessException e) {\n      LOG.info(\"Can't load package list \" + e.getMessage());\n    }\n    return true;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTestFrameworkInstalled(String sdkHome, String searcher) {\n    if (StringUtil.isEmptyOrSpaces(sdkHome)) {\n      LOG.info(\"Searching test runner in empty sdkHome\");\n      return false;\n    }\n    final String formatter = new File(PythonHelpersLocator.getHelpersRoot(), searcher).getAbsolutePath();\n    ProcessOutput\n      output = PySdkUtil.getProcessOutput(new File(sdkHome).getParent(),\n                                          new String[]{\n                                            sdkHome,\n                                            formatter\n                                          },\n                                          null,\n                                          2000);\n    if (output.getExitCode() != 0 || !output.getStderr().isEmpty()) {\n      LOG.info(\"Cannot find test runner in \" + sdkHome + \". Use searcher \" + formatter + \".\\nGot exit code: \" + output.getExitCode() +\n      \".\\nError output: \" + output.getStderr());\n      return false;\n    }\n    return true;\n  }","id":66802,"modified_method":"public boolean isPyTestInstalled(final Sdk sdk) {\n    Boolean isInstalled = SDK_TO_PYTEST.get(sdk.getHomePath());\n    if (isInstalled == null) {\n      updateTestFrameworks(sdk, PyNames.PY_TEST);\n      return true;\n    }\n    return isInstalled;\n  }","commit_id":"065fe2ac018687c19850d6d07ac52feb0183a266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JSONObject getJSONObject(\n\t\t\tlong mbMessageIdOrMicroblogsEntryId, String body, Date modifiedDate,\n\t\t\tlong userId, String userName, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tjsonObject.put(\"body\", HtmlUtil.escape(body));\n\n\t\tif ((userId <= 0) || (userId != themeDisplay.getUserId())) {\n\t\t\tjsonObject.put(\"commentControlsClass\", \"hide\");\n\t\t}\n\n\t\tjsonObject.put(\n\t\t\t\"mbMessageIdOrMicroblogsEntryId\", mbMessageIdOrMicroblogsEntryId);\n\t\tjsonObject.put(\n\t\t\t\"modifiedDate\",\n\t\t\tTime.getRelativeTimeDescription(\n\t\t\t\tmodifiedDate, themeDisplay.getLocale(),\n\t\t\t\tthemeDisplay.getTimeZone()));\n\n\t\tUser user = UserLocalServiceUtil.fetchUser(userId);\n\n\t\tif (user != null) {\n\t\t\tjsonObject.put(\"userDisplayURL\", user.getDisplayURL(themeDisplay));\n\t\t\tjsonObject.put(\n\t\t\t\t\"userPortraitURL\",\n\t\t\t\tHtmlUtil.escape(user.getPortraitURL(themeDisplay)));\n\t\t}\n\n\t\tjsonObject.put(\"userName\", HtmlUtil.escape(userName));\n\n\t\treturn jsonObject;\n\t}","id":66803,"modified_method":"protected JSONObject getJSONObject(\n\t\t\tlong mbMessageIdOrMicroblogsEntryId, String body, Date modifiedDate,\n\t\t\tlong userId, String userName, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tjsonObject.put(\"body\", HtmlUtil.escape(body));\n\n\t\tif ((userId <= 0) || (userId != themeDisplay.getUserId())) {\n\t\t\tjsonObject.put(\"commentControlsClass\", \"hide\");\n\t\t}\n\n\t\tjsonObject.put(\n\t\t\t\"mbMessageIdOrMicroblogsEntryId\", mbMessageIdOrMicroblogsEntryId);\n\n\t\tFormat dateFormat =\n\t\t\tFastDateFormatFactoryUtil.getDate(\n\t\t\t\tDateFormat.FULL, themeDisplay.getLocale(),\n\t\t\t\tthemeDisplay.getTimeZone());\n\n\t\tjsonObject.put(\n\t\t\t\"modifiedDate\",\n\t\t\tTime.getRelativeTimeDescription(\n\t\t\t\tmodifiedDate.getTime(), themeDisplay.getLocale(),\n\t\t\t\tthemeDisplay.getTimeZone(), dateFormat));\n\n\t\tUser user = UserLocalServiceUtil.fetchUser(userId);\n\n\t\tif (user != null) {\n\t\t\tjsonObject.put(\"userDisplayURL\", user.getDisplayURL(themeDisplay));\n\t\t\tjsonObject.put(\n\t\t\t\t\"userPortraitURL\",\n\t\t\t\tHtmlUtil.escape(user.getPortraitURL(themeDisplay)));\n\t\t}\n\n\t\tjsonObject.put(\"userName\", HtmlUtil.escape(userName));\n\n\t\treturn jsonObject;\n\t}","commit_id":"b1ca4d9336138d766b4a67d4b1054e5f70d9e8da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(15);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(classPK);\n\n\t\tsb.append(dateFormatDate.format(calendarBooking.getStartTime()));\n\n\t\tsb.append(\"<\/div><div class=\\\"location\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"location\"));\n\t\tsb.append(\": <\/strong>\");\n\t\tsb.append(calendarBooking.getLocation());\n\t\tsb.append(\"<\/div><div class=\\\"description\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"description\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tHtmlUtil.escape(assetRenderer.getSummary(), 200)));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":66804,"modified_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(15);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tFormat dateFormatDate = FastDateFormatFactoryUtil.getDateTime(\n\t\t\tDateFormat.FULL, DateFormat.SHORT, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(classPK);\n\n\t\tsb.append(dateFormatDate.format(calendarBooking.getStartTime()));\n\n\t\tsb.append(\"<\/div><div class=\\\"location\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"location\"));\n\t\tsb.append(\": <\/strong>\");\n\t\tsb.append(calendarBooking.getLocation());\n\t\tsb.append(\"<\/div><div class=\\\"description\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"description\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tHtmlUtil.escape(assetRenderer.getSummary(), 200)));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"b1ca4d9336138d766b4a67d4b1054e5f70d9e8da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getTitle(\n\t\t\tlong activitySetId, long groupId, long userId, long displayDate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<div class=\\\"activity-header\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-user-name\\\">\");\n\n\t\tString userName = getUserName(userId, serviceContext);\n\n\t\tint otherUsersCount = 0;\n\n\t\tif (activitySetId > 0) {\n\t\t\tList<Long> userIds = getActivitySetUserIds(activitySetId);\n\n\t\t\totherUsersCount = userIds.size() - 1;\n\t\t}\n\n\t\tif ((groupId != serviceContext.getScopeGroupId()) && (groupId > 0)) {\n\t\t\tString groupName = getGroupName(groupId, serviceContext);\n\n\t\t\tif (otherUsersCount > 0) {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-and-x-others-in-x\",\n\t\t\t\t\t\tnew Object[] {userName, otherUsersCount, groupName}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-in-x\", new Object[] {userName, groupName}));\n\t\t\t}\n\t\t}\n\t\telse if (otherUsersCount > 0) {\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\"x-and-x-others\",\n\t\t\t\t\tnew Object[] {userName, otherUsersCount}));\n\t\t}\n\t\telse {\n\t\t\tsb.append(userName);\n\t\t}\n\n\t\tsb.append(\"<\/div><div class=\\\"activity-time\\\" title=\\\"\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tDate activityDate = new Date(displayDate);\n\n\t\tsb.append(dateFormatDate.format(activityDate));\n\n\t\tsb.append(\"\\\">\");\n\n\t\tString relativeTimeDescription = Time.getRelativeTimeDescription(\n\t\t\tdisplayDate, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tsb.append(relativeTimeDescription);\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":66805,"modified_method":"protected String getTitle(\n\t\t\tlong activitySetId, long groupId, long userId, long displayDate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<div class=\\\"activity-header\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-user-name\\\">\");\n\n\t\tString userName = getUserName(userId, serviceContext);\n\n\t\tint otherUsersCount = 0;\n\n\t\tif (activitySetId > 0) {\n\t\t\tList<Long> userIds = getActivitySetUserIds(activitySetId);\n\n\t\t\totherUsersCount = userIds.size() - 1;\n\t\t}\n\n\t\tif ((groupId != serviceContext.getScopeGroupId()) && (groupId > 0)) {\n\t\t\tString groupName = getGroupName(groupId, serviceContext);\n\n\t\t\tif (otherUsersCount > 0) {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-and-x-others-in-x\",\n\t\t\t\t\t\tnew Object[] {userName, otherUsersCount, groupName}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-in-x\", new Object[] {userName, groupName}));\n\t\t\t}\n\t\t}\n\t\telse if (otherUsersCount > 0) {\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\"x-and-x-others\",\n\t\t\t\t\tnew Object[] {userName, otherUsersCount}));\n\t\t}\n\t\telse {\n\t\t\tsb.append(userName);\n\t\t}\n\n\t\tsb.append(\"<\/div><div class=\\\"activity-time\\\" title=\\\"\");\n\n\t\tFormat dateFormatDate = FastDateFormatFactoryUtil.getDateTime(\n\t\t\tDateFormat.FULL, DateFormat.SHORT, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tDate activityDate = new Date(displayDate);\n\n\t\tsb.append(dateFormatDate.format(activityDate));\n\n\t\tsb.append(\"\\\">\");\n\n\t\tFormat dateFormat = FastDateFormatFactoryUtil.getDate(\n\t\t\tDateFormat.FULL, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tString relativeTimeDescription = Time.getRelativeTimeDescription(\n\t\t\tdisplayDate, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone(), dateFormat);\n\n\t\tsb.append(relativeTimeDescription);\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"b1ca4d9336138d766b4a67d4b1054e5f70d9e8da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected CalendarBooking updateCalendarBooking(\n\t\t\tlong calendarBookingId, Calendar calendar, long[] childCalendarIds,\n\t\t\tMap<Locale, String> titleMap, Map<Locale, String> descriptionMap,\n\t\t\tString location, long startTime, long endTime, boolean allDay,\n\t\t\tRecurrence recurrence, long[] reminders, String[] remindersType,\n\t\t\tint instanceIndex, boolean updateInstance, boolean allFollowing,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tCalendarBooking calendarBooking = null;\n\n\t\tTimeZone timeZone = TimeZoneUtil.getTimeZone(StringPool.UTC);\n\n\t\tif (!allDay) {\n\t\t\ttimeZone = calendar.getTimeZone();\n\t\t}\n\n\t\tif (recurrence != null) {\n\t\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\t\tstartTime, timeZone);\n\n\t\t\trecurrence = RecurrenceUtil.inTimeZone(\n\t\t\t\trecurrence, startTimeJCalendar, timeZone);\n\t\t}\n\n\t\tif (calendarBookingId <= 0) {\n\t\t\tcalendarBooking = _calendarBookingService.addCalendarBooking(\n\t\t\t\tcalendar.getCalendarId(), childCalendarIds,\n\t\t\t\tCalendarBookingConstants.PARENT_CALENDAR_BOOKING_ID_DEFAULT,\n\t\t\t\ttitleMap, descriptionMap, location, startTime, endTime, allDay,\n\t\t\t\tRecurrenceSerializer.serialize(recurrence), reminders[0],\n\t\t\t\tremindersType[0], reminders[1], remindersType[1],\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tif (updateInstance) {\n\t\t\t\tcalendarBooking =\n\t\t\t\t\t_calendarBookingService.updateCalendarBookingInstance(\n\t\t\t\t\t\tcalendarBookingId, instanceIndex,\n\t\t\t\t\t\tcalendar.getCalendarId(), childCalendarIds, titleMap,\n\t\t\t\t\t\tdescriptionMap, location, startTime, endTime, allDay,\n\t\t\t\t\t\tRecurrenceSerializer.serialize(recurrence),\n\t\t\t\t\t\tallFollowing, reminders[0], remindersType[0],\n\t\t\t\t\t\treminders[1], remindersType[1], serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcalendarBooking =\n\t\t\t\t\t_calendarBookingService.getCalendarBookingInstance(\n\t\t\t\t\t\tcalendarBookingId, instanceIndex);\n\n\t\t\t\tlong duration = endTime - startTime;\n\t\t\t\tlong offset = getOffset(calendarBooking, startTime, recurrence);\n\n\t\t\t\tcalendarBooking = CalendarUtil.getNewStartTimeCalendarBooking(\n\t\t\t\t\tcalendarBooking, offset);\n\n\t\t\t\tcalendarBooking = CalendarUtil.getNewDurationCalendarBooking(\n\t\t\t\t\tcalendarBooking, duration);\n\n\t\t\t\tcalendarBooking = getFirstCalendarBookingInstance(\n\t\t\t\t\tcalendarBooking, recurrence, timeZone);\n\n\t\t\t\tcalendarBooking = _calendarBookingService.updateCalendarBooking(\n\t\t\t\t\tcalendarBookingId, calendar.getCalendarId(),\n\t\t\t\t\tchildCalendarIds, titleMap, descriptionMap, location,\n\t\t\t\t\tcalendarBooking.getStartTime(),\n\t\t\t\t\tcalendarBooking.getEndTime(), allDay,\n\t\t\t\t\tRecurrenceSerializer.serialize(recurrence), reminders[0],\n\t\t\t\t\tremindersType[0], reminders[1], remindersType[1],\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\treturn calendarBooking;\n\t}","id":66806,"modified_method":"protected CalendarBooking updateCalendarBooking(\n\t\t\tlong calendarBookingId, Calendar calendar, long[] childCalendarIds,\n\t\t\tMap<Locale, String> titleMap, Map<Locale, String> descriptionMap,\n\t\t\tString location, long startTime, long endTime, boolean allDay,\n\t\t\tRecurrence recurrence, long[] reminders, String[] remindersType,\n\t\t\tint instanceIndex, boolean updateInstance, boolean allFollowing,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tCalendarBooking calendarBooking = null;\n\n\t\tTimeZone timeZone = TimeZoneUtil.getTimeZone(StringPool.UTC);\n\n\t\tif (!allDay) {\n\t\t\ttimeZone = calendar.getTimeZone();\n\t\t}\n\n\t\tif (recurrence != null) {\n\t\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\t\tstartTime, timeZone);\n\n\t\t\trecurrence = RecurrenceUtil.inTimeZone(\n\t\t\t\trecurrence, startTimeJCalendar, timeZone);\n\t\t}\n\n\t\tif (calendarBookingId <= 0) {\n\t\t\tcalendarBooking = _calendarBookingService.addCalendarBooking(\n\t\t\t\tcalendar.getCalendarId(), childCalendarIds,\n\t\t\t\tCalendarBookingConstants.PARENT_CALENDAR_BOOKING_ID_DEFAULT,\n\t\t\t\ttitleMap, descriptionMap, location, startTime, endTime, allDay,\n\t\t\t\tRecurrenceSerializer.serialize(recurrence), reminders[0],\n\t\t\t\tremindersType[0], reminders[1], remindersType[1],\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tif (updateInstance) {\n\t\t\t\tcalendarBooking =\n\t\t\t\t\t_calendarBookingService.updateCalendarBookingInstance(\n\t\t\t\t\t\tcalendarBookingId, instanceIndex,\n\t\t\t\t\t\tcalendar.getCalendarId(), childCalendarIds, titleMap,\n\t\t\t\t\t\tdescriptionMap, location, startTime, endTime, allDay,\n\t\t\t\t\t\tRecurrenceSerializer.serialize(recurrence),\n\t\t\t\t\t\tallFollowing, reminders[0], remindersType[0],\n\t\t\t\t\t\treminders[1], remindersType[1], serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcalendarBooking =\n\t\t\t\t\t_calendarBookingService.getCalendarBookingInstance(\n\t\t\t\t\t\tcalendarBookingId, instanceIndex);\n\n\t\t\t\tlong duration = endTime - startTime;\n\t\t\t\tlong offset = getOffset(calendarBooking, startTime, recurrence);\n\n\t\t\t\tcalendarBooking =\n\t\t\t\t\t_calendarBookingService.\n\t\t\t\t\t\tgetNewStartTimeAndDurationCalendarBooking(\n\t\t\t\t\t\t\tcalendarBookingId, offset, duration);\n\n\t\t\t\tcalendarBooking = getFirstCalendarBookingInstance(\n\t\t\t\t\tcalendarBooking, recurrence, timeZone);\n\n\t\t\t\tcalendarBooking = _calendarBookingService.updateCalendarBooking(\n\t\t\t\t\tcalendarBookingId, calendar.getCalendarId(),\n\t\t\t\t\tchildCalendarIds, titleMap, descriptionMap, location,\n\t\t\t\t\tcalendarBooking.getStartTime(),\n\t\t\t\t\tcalendarBooking.getEndTime(), allDay,\n\t\t\t\t\tRecurrenceSerializer.serialize(recurrence), reminders[0],\n\t\t\t\t\tremindersType[0], reminders[1], remindersType[1],\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\treturn calendarBooking;\n\t}","commit_id":"a09a73cdadbbe789fa14e7472fa9cc1a6d2e46c8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long getOffset(\n\t\t\tCalendarBooking calendarBooking, long startTime,\n\t\t\tRecurrence recurrence)\n\t\tthrows PortalException {\n\n\t\tFrequency frequency = null;\n\n\t\tif (recurrence != null) {\n\t\t\tfrequency = recurrence.getFrequency();\n\t\t}\n\n\t\tif (frequency == Frequency.WEEKLY) {\n\t\t\tCalendarBooking firstInstance =\n\t\t\t\t_calendarBookingService.getCalendarBookingInstance(\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(), 0);\n\n\t\t\tjava.util.Calendar startTimeJCalendar =\n\t\t\t\tCalendarFactoryUtil.getCalendar(\n\t\t\t\t\tstartTime, calendarBooking.getTimeZone());\n\n\t\t\tjava.util.Calendar firstInstanceJCalendar =\n\t\t\t\tCalendarFactoryUtil.getCalendar(\n\t\t\t\t\tfirstInstance.getStartTime(),\n\t\t\t\t\tcalendarBooking.getTimeZone());\n\n\t\t\tif (!JCalendarUtil.isSameDayOfWeek(\n\t\t\t\t\tstartTimeJCalendar, firstInstanceJCalendar)) {\n\n\t\t\t\tstartTimeJCalendar = JCalendarUtil.mergeJCalendar(\n\t\t\t\t\tfirstInstanceJCalendar, startTimeJCalendar,\n\t\t\t\t\tcalendarBooking.getTimeZone());\n\n\t\t\t\tstartTime = startTimeJCalendar.getTimeInMillis();\n\t\t\t}\n\t\t}\n\n\t\treturn startTime - calendarBooking.getStartTime();\n\t}","id":66807,"modified_method":"protected long getOffset(\n\t\t\tCalendarBooking calendarBooking, long startTime,\n\t\t\tRecurrence recurrence)\n\t\tthrows PortalException {\n\n\t\tFrequency frequency = null;\n\n\t\tif (recurrence != null) {\n\t\t\tfrequency = recurrence.getFrequency();\n\t\t}\n\n\t\tif (frequency == Frequency.WEEKLY) {\n\t\t\tCalendarBooking firstInstance =\n\t\t\t\t_calendarBookingService.getCalendarBookingInstance(\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(), 0);\n\n\t\t\tjava.util.Calendar startTimeJCalendar =\n\t\t\t\tCalendarFactoryUtil.getCalendar(\n\t\t\t\t\tstartTime, calendarBooking.getTimeZone());\n\n\t\t\tjava.util.Calendar firstInstanceJCalendar =\n\t\t\t\tCalendarFactoryUtil.getCalendar(\n\t\t\t\t\tfirstInstance.getStartTime(),\n\t\t\t\t\tcalendarBooking.getTimeZone());\n\n\t\t\tif (!JCalendarUtil.isSameDayOfWeek(\n\t\t\t\t\tstartTimeJCalendar, firstInstanceJCalendar)) {\n\n\t\t\t\tjava.util.Calendar currentInstanceJCalendar =\n\t\t\t\t\tCalendarFactoryUtil.getCalendar(\n\t\t\t\t\t\tcalendarBooking.getStartTime(),\n\t\t\t\t\t\tcalendarBooking.getTimeZone());\n\n\t\t\t\tstartTimeJCalendar = JCalendarUtil.mergeJCalendar(\n\t\t\t\t\tcurrentInstanceJCalendar, startTimeJCalendar,\n\t\t\t\t\tcalendarBooking.getTimeZone());\n\n\t\t\t\tstartTime = startTimeJCalendar.getTimeInMillis();\n\t\t\t}\n\t\t}\n\n\t\treturn startTime - calendarBooking.getStartTime();\n\t}","commit_id":"a09a73cdadbbe789fa14e7472fa9cc1a6d2e46c8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Get a new {@code DateTimeFormatter} using this factory. If no specific\n\t * {@link #setStyle(String) style}, {@link #setIso(ISO) ISO}, or\n\t * {@link #setPattern(String) pattern} have been defined the supplied\n\t * {@code fallbackFormatter} will be used.\n\t * @param fallbackFormatter the fall-back formatter to use when no specific factory\n\t *        properties have been set (can be {@code null}).\n\t * @return a new date time formatter\n\t */\n\tpublic DateTimeFormatter getDateTimeFormatter(DateTimeFormatter fallbackFormatter) {\n\t\tDateTimeFormatter dateTimeFormatter = createDateTimeFormatter();\n\t\tif(dateTimeFormatter != null && this.timeZone != null) {\n\t\t\tdateTimeFormatter.withZone(DateTimeZone.forTimeZone(this.timeZone));\n\t\t}\n\t\treturn (dateTimeFormatter != null ? dateTimeFormatter : fallbackFormatter);\n\t}","id":66808,"modified_method":"/**\n\t * Get a new {@code DateTimeFormatter} using this factory. If no specific\n\t * {@link #setStyle(String) style}, {@link #setIso(ISO) ISO}, or\n\t * {@link #setPattern(String) pattern} have been defined the supplied\n\t * {@code fallbackFormatter} will be used.\n\t * @param fallbackFormatter the fall-back formatter to use when no specific factory\n\t *        properties have been set (can be {@code null}).\n\t * @return a new date time formatter\n\t */\n\tpublic DateTimeFormatter getDateTimeFormatter(DateTimeFormatter fallbackFormatter) {\n\t\tDateTimeFormatter dateTimeFormatter = createDateTimeFormatter();\n\t\tif(dateTimeFormatter != null && this.timeZone != null) {\n\t\t\tdateTimeFormatter = dateTimeFormatter.withZone(DateTimeZone.forTimeZone(this.timeZone));\n\t\t}\n\t\treturn (dateTimeFormatter != null ? dateTimeFormatter : fallbackFormatter);\n\t}","commit_id":"93c01e071098bb2e07e127c3b091d89ce73de983","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void shouldGetWithTimeZone() throws Exception {\n\t\tfactory.setPattern(\"yyyyMMddHHmmss Z\");\n\t\tfactory.setTimeZone(TimeZone.getTimeZone(\"-0700\"));\n\t\tassertThat(factory.getDateTimeFormatter().print(dateTime), is(\"20091021121000 -0700\"));\n\t}","id":66809,"modified_method":"@Test\n\tpublic void shouldGetWithTimeZone() throws Exception {\n\n\t\tTimeZone zurich = TimeZone.getTimeZone(\"Europe/Zurich\");\n\t\tTimeZone newYork = TimeZone.getTimeZone(\"America/New_York\");\n\n\t\t// Ensure that we are testing against a timezone other than the default.\n\t\tTimeZone testTimeZone;\n\t\tString offset;\n\n\t\tif (zurich.equals(TimeZone.getDefault())) {\n\t\t\ttestTimeZone = newYork;\n\t\t\toffset = \"-0400\"; // Daylight savings on October 21st\n\t\t}\n\t\telse {\n\t\t\ttestTimeZone = zurich;\n\t\t\toffset = \"+0200\"; // Daylight savings on October 21st\n\t\t}\n\n\t\tfactory.setPattern(\"yyyyMMddHHmmss Z\");\n\t\tfactory.setTimeZone(testTimeZone);\n\n\t\tDateTimeZone dateTimeZone = DateTimeZone.forTimeZone(testTimeZone);\n\t\tDateTime dateTime = new DateTime(2009, 10, 21, 12, 10, 00, 00, dateTimeZone);\n\n\t\tassertThat(factory.getDateTimeFormatter().print(dateTime), is(\"20091021121000 \" + offset));\n\t}","commit_id":"93c01e071098bb2e07e127c3b091d89ce73de983","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tElement articleEl)\n\t\tthrows Exception {\n\n\t\tString path = articleEl.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalArticle article = (JournalArticle)context.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = context.getUserId(article.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\n\t\tString articleId = article.getArticleId();\n\t\tboolean autoArticleId = false;\n\n\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\tgroupId, articleId,\n\t\t\t\t\tJournalArticleImpl.DEFAULT_VERSION) != null)) {\n\n\t\t\tautoArticleId = true;\n\t\t}\n\n\t\tString newArticleId = articleIds.get(articleId);\n\n\t\tif (Validator.isNotNull(newArticleId)) {\n\n\t\t\t// A sibling of a different version was already assigned a new\n\t\t\t// article id\n\n\t\t\tarticleId = newArticleId;\n\t\t\tautoArticleId = false;\n\t\t}\n\n\t\tboolean incrementVersion = false;\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, article.getStructureId(), article.getStructureId());\n\t\tString parentTemplateId = MapUtil.getString(\n\t\t\ttemplateIds, article.getTemplateId(), article.getTemplateId());\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tDate displayDate = article.getDisplayDate();\n\n\t\tint displayDateMonth = 0;\n\t\tint displayDateDay = 0;\n\t\tint displayDateYear = 0;\n\t\tint displayDateHour = 0;\n\t\tint displayDateMinute = 0;\n\n\t\tif (displayDate != null) {\n\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar(timeZone);\n\n\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tdisplayDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate expirationDate = article.getExpirationDate();\n\n\t\tint expirationDateMonth = 0;\n\t\tint expirationDateDay = 0;\n\t\tint expirationDateYear = 0;\n\t\tint expirationDateHour = 0;\n\t\tint expirationDateMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar(timeZone);\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate reviewDate = article.getReviewDate();\n\n\t\tint reviewDateMonth = 0;\n\t\tint reviewDateDay = 0;\n\t\tint reviewDateYear = 0;\n\t\tint reviewDateHour = 0;\n\t\tint reviewDateMinute = 0;\n\t\tboolean neverReview = true;\n\n\t\tif (reviewDate != null) {\n\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar(timeZone);\n\n\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\tneverReview = false;\n\n\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\treviewDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tFile smallFile = null;\n\n\t\tif (article.isSmallImage()) {\n\t\t\tString smallImagePath = articleEl.attributeValue(\n\t\t\t\t\"small-image-path\");\n\n\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(smallImagePath);\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, bytes);\n\t\t}\n\n\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = articleEl.attributeValue(\"image-path\");\n\n\t\t\tList<ObjectValuePair<String, byte[]>> imageFiles =\n\t\t\t\tcontext.getZipFolderEntries(imagePath);\n\n\t\t\tif (imageFiles != null) {\n\t\t\t\tfor (ObjectValuePair<String, byte[]> imageFile : imageFiles) {\n\t\t\t\t\tString fileName = imageFile.getKey();\n\n\t\t\t\t\tif (fileName.endsWith(\".xml\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t\t}\n\n\t\t\t\t\timages.put(fileName, imageFile.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString articleURL = null;\n\n\t\tPortletPreferences preferences = null;\n\n\t\tString[] tagsCategories = null;\n\t\tString[] tagsEntries = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\ttagsCategories = context.getTagsCategories(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\tcontext, article);\n\n\t\tif (newContent != JournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\tarticle.setContent(newContent);\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, article);\n\n\t\tJournalArticle existingArticle = null;\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = JournalStructureUtil.fetchByG_S(\n\t\t\t\tcontext.getGroupId(), article.getStructureId());\n\n\t\t\tif (structure == null) {\n\t\t\t\tString structurePath = getImportStructurePath(\n\t\t\t\t\tcontext, article.getStructureId());\n\n\t\t\t\timportStructure(context, structureIds, structurePath);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = JournalTemplateUtil.fetchByG_T(\n\t\t\t\tcontext.getGroupId(), article.getTemplateId());\n\n\t\t\tif (template == null) {\n\t\t\t\tString templatePath = getImportTemplatePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\tString smallImagePath = templatePath.replace(\n\t\t\t\t\tarticle.getTemplateId() + \".xml\", StringPool.BLANK);\n\n\t\t\t\timportTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, smallImagePath,\n\t\t\t\t\ttemplatePath);\n\t\t\t}\n\t\t}\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\tarticle.getUuid(), groupId);\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tarticle.getUuid(), userId, groupId, articleId,\n\t\t\t\t\tautoArticleId, article.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, preferences, tagsCategories,\n\t\t\t\t\ttagsEntries, addCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingArticle = JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\texistingArticle.getStructureId(),\n\t\t\t\t\texistingArticle.getTemplateId(), displayDateMonth,\n\t\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\t\tdisplayDateMinute, expirationDateMonth, expirationDateDay,\n\t\t\t\t\texpirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, preferences, tagsCategories,\n\t\t\t\t\ttagsEntries);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\tuserId, groupId, articleId, autoArticleId, article.getVersion(),\n\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(), smallFile,\n\t\t\t\timages, articleURL, preferences, tagsCategories, tagsEntries,\n\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t}\n\n\t\tlong strategyApprovalUserId = creationStrategy.getApprovalUserId(\n\t\t\tcontext, article);\n\n\t\tif ((strategyApprovalUserId !=\n\t\t\t\tJournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) ||\n\t\t\t(article.isApproved() && !existingArticle.isApproved())) {\n\n\t\t\tlong approvedByUserId = strategyApprovalUserId;\n\n\t\t\tif (approvedByUserId == 0) {\n\t\t\t\tapprovedByUserId = context.getUserId(\n\t\t\t\t\tarticle.getApprovedByUserUuid());\n\t\t\t}\n\n\t\t\tJournalArticleLocalServiceUtil.approveArticle(\n\t\t\t\tapprovedByUserId, groupId, existingArticle.getArticleId(),\n\t\t\t\texistingArticle.getVersion(), articleURL, preferences);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\texistingArticle.getResourcePrimKey(), groupId);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\texistingArticle.getResourcePrimKey());\n\t\t}\n\n\t\tarticleIds.put(articleId, existingArticle.getArticleId());\n\n\t\tif (!articleId.equals(existingArticle.getArticleId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingArticle.getArticleId());\n\t\t\t}\n\t\t}\n\t}","id":66810,"modified_method":"public static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tElement articleEl)\n\t\tthrows Exception {\n\n\t\tString path = articleEl.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalArticle article = (JournalArticle)context.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = context.getUserId(article.getUserUuid());\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString articleId = article.getArticleId();\n\t\tboolean autoArticleId = false;\n\n\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\tgroupId, articleId,\n\t\t\t\t\tJournalArticleImpl.DEFAULT_VERSION) != null)) {\n\n\t\t\tautoArticleId = true;\n\t\t}\n\n\t\tString newArticleId = articleIds.get(articleId);\n\n\t\tif (Validator.isNotNull(newArticleId)) {\n\n\t\t\t// A sibling of a different version was already assigned a new\n\t\t\t// article id\n\n\t\t\tarticleId = newArticleId;\n\t\t\tautoArticleId = false;\n\t\t}\n\n\t\tboolean incrementVersion = false;\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, article.getStructureId(), article.getStructureId());\n\t\tString parentTemplateId = MapUtil.getString(\n\t\t\ttemplateIds, article.getTemplateId(), article.getTemplateId());\n\n\t\tDate displayDate = article.getDisplayDate();\n\n\t\tint displayDateMonth = 0;\n\t\tint displayDateDay = 0;\n\t\tint displayDateYear = 0;\n\t\tint displayDateHour = 0;\n\t\tint displayDateMinute = 0;\n\n\t\tif (displayDate != null) {\n\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tdisplayDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate expirationDate = article.getExpirationDate();\n\n\t\tint expirationDateMonth = 0;\n\t\tint expirationDateDay = 0;\n\t\tint expirationDateYear = 0;\n\t\tint expirationDateHour = 0;\n\t\tint expirationDateMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate reviewDate = article.getReviewDate();\n\n\t\tint reviewDateMonth = 0;\n\t\tint reviewDateDay = 0;\n\t\tint reviewDateYear = 0;\n\t\tint reviewDateHour = 0;\n\t\tint reviewDateMinute = 0;\n\t\tboolean neverReview = true;\n\n\t\tif (reviewDate != null) {\n\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\tneverReview = false;\n\n\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\treviewDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tFile smallFile = null;\n\n\t\tif (article.isSmallImage()) {\n\t\t\tString smallImagePath = articleEl.attributeValue(\n\t\t\t\t\"small-image-path\");\n\n\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(smallImagePath);\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, bytes);\n\t\t}\n\n\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = articleEl.attributeValue(\"image-path\");\n\n\t\t\tList<ObjectValuePair<String, byte[]>> imageFiles =\n\t\t\t\tcontext.getZipFolderEntries(imagePath);\n\n\t\t\tif (imageFiles != null) {\n\t\t\t\tfor (ObjectValuePair<String, byte[]> imageFile : imageFiles) {\n\t\t\t\t\tString fileName = imageFile.getKey();\n\n\t\t\t\t\tif (fileName.endsWith(\".xml\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t\t}\n\n\t\t\t\t\timages.put(fileName, imageFile.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString articleURL = null;\n\n\t\tPortletPreferences preferences = null;\n\n\t\tString[] tagsCategories = null;\n\t\tString[] tagsEntries = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\ttagsCategories = context.getTagsCategories(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\tcontext, article);\n\n\t\tif (newContent != JournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\tarticle.setContent(newContent);\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, article);\n\n\t\tJournalArticle existingArticle = null;\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = JournalStructureUtil.fetchByG_S(\n\t\t\t\tcontext.getGroupId(), article.getStructureId());\n\n\t\t\tif (structure == null) {\n\t\t\t\tString structurePath = getImportStructurePath(\n\t\t\t\t\tcontext, article.getStructureId());\n\n\t\t\t\timportStructure(context, structureIds, structurePath);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = JournalTemplateUtil.fetchByG_T(\n\t\t\t\tcontext.getGroupId(), article.getTemplateId());\n\n\t\t\tif (template == null) {\n\t\t\t\tString templatePath = getImportTemplatePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\tString smallImagePath = templatePath.replace(\n\t\t\t\t\tarticle.getTemplateId() + \".xml\", StringPool.BLANK);\n\n\t\t\t\timportTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, smallImagePath,\n\t\t\t\t\ttemplatePath);\n\t\t\t}\n\t\t}\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\tarticle.getUuid(), groupId);\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tarticle.getUuid(), userId, groupId, articleId,\n\t\t\t\t\tautoArticleId, article.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, preferences, tagsCategories,\n\t\t\t\t\ttagsEntries, addCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingArticle = JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\texistingArticle.getStructureId(),\n\t\t\t\t\texistingArticle.getTemplateId(), displayDateMonth,\n\t\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\t\tdisplayDateMinute, expirationDateMonth, expirationDateDay,\n\t\t\t\t\texpirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, preferences, tagsCategories,\n\t\t\t\t\ttagsEntries);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\tuserId, groupId, articleId, autoArticleId, article.getVersion(),\n\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(), smallFile,\n\t\t\t\timages, articleURL, preferences, tagsCategories, tagsEntries,\n\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t}\n\n\t\tlong strategyApprovalUserId = creationStrategy.getApprovalUserId(\n\t\t\tcontext, article);\n\n\t\tif ((strategyApprovalUserId !=\n\t\t\t\tJournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) ||\n\t\t\t(article.isApproved() && !existingArticle.isApproved())) {\n\n\t\t\tlong approvedByUserId = strategyApprovalUserId;\n\n\t\t\tif (approvedByUserId == 0) {\n\t\t\t\tapprovedByUserId = context.getUserId(\n\t\t\t\t\tarticle.getApprovedByUserUuid());\n\t\t\t}\n\n\t\t\tJournalArticleLocalServiceUtil.approveArticle(\n\t\t\t\tapprovedByUserId, groupId, existingArticle.getArticleId(),\n\t\t\t\texistingArticle.getVersion(), articleURL, preferences);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\texistingArticle.getResourcePrimKey(), groupId);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\texistingArticle.getResourcePrimKey());\n\t\t}\n\n\t\tarticleIds.put(articleId, existingArticle.getArticleId());\n\n\t\tif (!articleId.equals(existingArticle.getArticleId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingArticle.getArticleId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"349bcf89d61d0fd2970d39e738967acf54774bc3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void publishLayouts(\n\t\t\tPortletRequest portletRequest, long sourceGroupId,\n\t\t\tlong targetGroupId, Map<String, String[]> parameterMap,\n\t\t\tboolean schedule)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong userId = themeDisplay.getUserId();\n\n\t\tString tabs1 = ParamUtil.getString(portletRequest, \"tabs1\");\n\n\t\tboolean privateLayout = true;\n\n\t\tif (tabs1.equals(\"public-pages\")) {\n\t\t\tprivateLayout = false;\n\t\t}\n\n\t\tString scope = ParamUtil.getString(portletRequest, \"scope\");\n\n\t\tMap<Long, Boolean> layoutIdMap = new LinkedHashMap<Long, Boolean>();\n\n\t\tif (scope.equals(\"selected-pages\")) {\n\t\t\tlong[] rowIds = ParamUtil.getLongValues(portletRequest, \"rowIds\");\n\n\t\t\tfor (long selPlid : rowIds) {\n\t\t\t\tboolean includeChildren = ParamUtil.getBoolean(\n\t\t\t\t\tportletRequest, \"includeChildren_\" + selPlid);\n\n\t\t\t\tlayoutIdMap.put(selPlid, includeChildren);\n\t\t\t}\n\t\t}\n\n\t\tString range = ParamUtil.getString(portletRequest, \"range\");\n\n\t\tDate startDate = null;\n\t\tDate endDate = null;\n\n\t\tif (range.equals(\"dateRange\")) {\n\t\t\tstartDate = getDate(portletRequest, \"startDate\", true).getTime();\n\n\t\t\tendDate = getDate(portletRequest, \"endDate\", true).getTime();\n\t\t}\n\t\telse if (range.equals(\"fromLastPublishDate\")) {\n\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\tsourceGroupId, privateLayout);\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tlong lastPublishDate = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(\"last-publish-date\"));\n\n\t\t\tif (lastPublishDate > 0) {\n\t\t\t\tCalendar cal = Calendar.getInstance(\n\t\t\t\t\tthemeDisplay.getTimeZone(), themeDisplay.getLocale());\n\n\t\t\t\tendDate = cal.getTime();\n\n\t\t\t\tcal.setTimeInMillis(lastPublishDate);\n\n\t\t\t\tstartDate = cal.getTime();\n\t\t\t}\n\t\t}\n\t\telse if (range.equals(\"last\")) {\n\t\t\tint rangeLast = ParamUtil.getInteger(portletRequest, \"last\");\n\n\t\t\tDate now = new Date();\n\n\t\t\tstartDate = new Date(now.getTime() - (rangeLast * Time.HOUR));\n\n\t\t\tendDate = now;\n\t\t}\n\n\t\tif (schedule) {\n\t\t\tString groupName = getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, targetGroupId);\n\n\t\t\tint recurrenceType = ParamUtil.getInteger(\n\t\t\t\tportletRequest, \"recurrenceType\");\n\n\t\t\tCalendar startCal = getDate(\n\t\t\t\tportletRequest, \"schedulerStartDate\", true);\n\n\t\t\tString cronText = getCronText(\n\t\t\t\tportletRequest, startCal, true, recurrenceType);\n\n\t\t\tDate schedulerEndDate = null;\n\n\t\t\tint endDateType = ParamUtil.getInteger(\n\t\t\t\tportletRequest, \"endDateType\");\n\n\t\t\tif (endDateType == 1) {\n\t\t\t\tCalendar endCal = getDate(\n\t\t\t\t\tportletRequest, \"schedulerEndDate\", true);\n\n\t\t\t\tschedulerEndDate = endCal.getTime();\n\t\t\t}\n\n\t\t\tString description = ParamUtil.getString(\n\t\t\t\tportletRequest, \"description\");\n\n\t\t\tLayoutServiceUtil.schedulePublishToLive(\n\t\t\t\tsourceGroupId, targetGroupId, privateLayout, layoutIdMap,\n\t\t\t\tparameterMap, scope, startDate, endDate, groupName, cronText,\n\t\t\t\tstartCal.getTime(), schedulerEndDate, description);\n\t\t}\n\t\telse {\n\t\t\tMessageStatus messageStatus = new MessageStatus();\n\n\t\t\tmessageStatus.startTimer();\n\n\t\t\tString command =\n\t\t\t\tLayoutsLocalPublisherRequest.COMMAND_SELECTED_PAGES;\n\n\t\t\ttry {\n\t\t\t\tif (scope.equals(\"all-pages\")) {\n\t\t\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_ALL_PAGES;\n\n\t\t\t\t\tpublishLayouts(\n\t\t\t\t\t\tuserId, sourceGroupId, targetGroupId, privateLayout,\n\t\t\t\t\t\tparameterMap, startDate, endDate);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpublishLayouts(\n\t\t\t\t\t\tuserId, sourceGroupId, targetGroupId, privateLayout,\n\t\t\t\t\t\tlayoutIdMap, parameterMap, startDate, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tmessageStatus.setException(e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tmessageStatus.stopTimer();\n\n\t\t\t\tLayoutsLocalPublisherRequest publisherRequest =\n\t\t\t\t\tnew LayoutsLocalPublisherRequest(\n\t\t\t\t\t\tcommand, themeDisplay.getUserId(), sourceGroupId,\n\t\t\t\t\t\ttargetGroupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\t\t\t\tstartDate, endDate);\n\n\t\t\t\tmessageStatus.setPayload(publisherRequest);\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.MESSAGE_BUS_MESSAGE_STATUS, messageStatus);\n\t\t\t}\n\t\t}\n\t}","id":66811,"modified_method":"protected void publishLayouts(\n\t\t\tPortletRequest portletRequest, long sourceGroupId,\n\t\t\tlong targetGroupId, Map<String, String[]> parameterMap,\n\t\t\tboolean schedule)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString tabs1 = ParamUtil.getString(portletRequest, \"tabs1\");\n\n\t\tboolean privateLayout = true;\n\n\t\tif (tabs1.equals(\"public-pages\")) {\n\t\t\tprivateLayout = false;\n\t\t}\n\n\t\tString scope = ParamUtil.getString(portletRequest, \"scope\");\n\n\t\tMap<Long, Boolean> layoutIdMap = new LinkedHashMap<Long, Boolean>();\n\n\t\tif (scope.equals(\"selected-pages\")) {\n\t\t\tlong[] rowIds = ParamUtil.getLongValues(portletRequest, \"rowIds\");\n\n\t\t\tfor (long selPlid : rowIds) {\n\t\t\t\tboolean includeChildren = ParamUtil.getBoolean(\n\t\t\t\t\tportletRequest, \"includeChildren_\" + selPlid);\n\n\t\t\t\tlayoutIdMap.put(selPlid, includeChildren);\n\t\t\t}\n\t\t}\n\n\t\tString range = ParamUtil.getString(portletRequest, \"range\");\n\n\t\tDate startDate = null;\n\t\tDate endDate = null;\n\n\t\tif (range.equals(\"dateRange\")) {\n\t\t\tstartDate = getDate(portletRequest, \"startDate\", true).getTime();\n\n\t\t\tendDate = getDate(portletRequest, \"endDate\", true).getTime();\n\t\t}\n\t\telse if (range.equals(\"fromLastPublishDate\")) {\n\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\tsourceGroupId, privateLayout);\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tlong lastPublishDate = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(\"last-publish-date\"));\n\n\t\t\tif (lastPublishDate > 0) {\n\t\t\t\tCalendar cal = Calendar.getInstance(\n\t\t\t\t\tthemeDisplay.getTimeZone(), themeDisplay.getLocale());\n\n\t\t\t\tendDate = cal.getTime();\n\n\t\t\t\tcal.setTimeInMillis(lastPublishDate);\n\n\t\t\t\tstartDate = cal.getTime();\n\t\t\t}\n\t\t}\n\t\telse if (range.equals(\"last\")) {\n\t\t\tint rangeLast = ParamUtil.getInteger(portletRequest, \"last\");\n\n\t\t\tDate now = new Date();\n\n\t\t\tstartDate = new Date(now.getTime() - (rangeLast * Time.HOUR));\n\n\t\t\tendDate = now;\n\t\t}\n\n\t\tif (schedule) {\n\t\t\tString groupName = getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, targetGroupId);\n\n\t\t\tint recurrenceType = ParamUtil.getInteger(\n\t\t\t\tportletRequest, \"recurrenceType\");\n\n\t\t\tCalendar startCal = getDate(\n\t\t\t\tportletRequest, \"schedulerStartDate\", true);\n\n\t\t\tString cronText = getCronText(\n\t\t\t\tportletRequest, startCal, true, recurrenceType);\n\n\t\t\tDate schedulerEndDate = null;\n\n\t\t\tint endDateType = ParamUtil.getInteger(\n\t\t\t\tportletRequest, \"endDateType\");\n\n\t\t\tif (endDateType == 1) {\n\t\t\t\tCalendar endCal = getDate(\n\t\t\t\t\tportletRequest, \"schedulerEndDate\", true);\n\n\t\t\t\tschedulerEndDate = endCal.getTime();\n\t\t\t}\n\n\t\t\tString description = ParamUtil.getString(\n\t\t\t\tportletRequest, \"description\");\n\n\t\t\tLayoutServiceUtil.schedulePublishToLive(\n\t\t\t\tsourceGroupId, targetGroupId, privateLayout, layoutIdMap,\n\t\t\t\tparameterMap, scope, startDate, endDate, groupName, cronText,\n\t\t\t\tstartCal.getTime(), schedulerEndDate, description);\n\t\t}\n\t\telse {\n\t\t\tMessageStatus messageStatus = new MessageStatus();\n\n\t\t\tmessageStatus.startTimer();\n\n\t\t\tString command =\n\t\t\t\tLayoutsLocalPublisherRequest.COMMAND_SELECTED_PAGES;\n\n\t\t\ttry {\n\t\t\t\tif (scope.equals(\"all-pages\")) {\n\t\t\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_ALL_PAGES;\n\n\t\t\t\t\tpublishLayouts(\n\t\t\t\t\t\tthemeDisplay.getUserId(), sourceGroupId, targetGroupId,\n\t\t\t\t\t\tprivateLayout, parameterMap, startDate, endDate);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpublishLayouts(\n\t\t\t\t\t\tthemeDisplay.getUserId(), sourceGroupId, targetGroupId,\n\t\t\t\t\t\tprivateLayout, layoutIdMap, parameterMap, startDate,\n\t\t\t\t\t\tendDate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tmessageStatus.setException(e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tmessageStatus.stopTimer();\n\n\t\t\t\tLayoutsLocalPublisherRequest publisherRequest =\n\t\t\t\t\tnew LayoutsLocalPublisherRequest(\n\t\t\t\t\t\tcommand, themeDisplay.getUserId(), sourceGroupId,\n\t\t\t\t\t\ttargetGroupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\t\t\t\tstartDate, endDate);\n\n\t\t\t\tmessageStatus.setPayload(publisherRequest);\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.MESSAGE_BUS_MESSAGE_STATUS, messageStatus);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5e4ab40f7d42d48646d13d1e7848cfa1671ecc82","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateStaging(PortletRequest portletRequest) throws Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tlong userId = permissionChecker.getUserId();\n\n\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\tlong liveGroupId = ParamUtil.getLong(portletRequest, \"liveGroupId\");\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, liveGroupId, ActionKeys.MANAGE_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\n\t\tint stagingType = ParamUtil.getInteger(portletRequest, \"stagingType\");\n\n\t\tboolean branchingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPublic\", false);\n\t\tboolean branchingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPrivate\", false);\n\t\tboolean lockingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"lockingPublic\", false);\n\t\tboolean lockingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"lockingPrivate\", false);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (stagingType == StagingConstants.TYPE_NOT_STAGED) {\n\t\t\tdisableStaging(\n\t\t\t\tportletRequest, scopeGroupId, liveGroupId, serviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_LOCAL_STAGING) {\n\t\t\tenableLocalStaging(\n\t\t\t\tuserId, scopeGroupId, liveGroupId, branchingPublic,\n\t\t\t\tbranchingPrivate, lockingPublic, lockingPrivate,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_REMOTE_STAGING) {\n\t\t\tString remoteAddress = ParamUtil.getString(\n\t\t\t\tportletRequest, \"remoteAddress\");\n\t\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\t\tportletRequest, \"remoteGroupId\");\n\t\t\tint remotePort = ParamUtil.getInteger(portletRequest, \"remotePort\");\n\t\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"secureConnection\");\n\n\t\t\tenableRemoteStaging(\n\t\t\t\tuserId, scopeGroupId, liveGroupId, branchingPublic,\n\t\t\t\tbranchingPrivate, lockingPublic, lockingPrivate,\n\t\t\t\tremoteAddress, remoteGroupId, remotePort, secureConnection,\n\t\t\t\tserviceContext);\n\t\t}\n\t}","id":66812,"modified_method":"public void updateStaging(PortletRequest portletRequest) throws Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tlong userId = permissionChecker.getUserId();\n\n\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\tlong liveGroupId = ParamUtil.getLong(portletRequest, \"liveGroupId\");\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, liveGroupId, ActionKeys.MANAGE_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\n\t\tint stagingType = ParamUtil.getInteger(portletRequest, \"stagingType\");\n\n\t\tboolean branchingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPublic\");\n\t\tboolean branchingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPrivate\");\n\t\tboolean lockingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"lockingPublic\");\n\t\tboolean lockingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"lockingPrivate\");\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (stagingType == StagingConstants.TYPE_NOT_STAGED) {\n\t\t\tdisableStaging(\n\t\t\t\tportletRequest, scopeGroupId, liveGroupId, serviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_LOCAL_STAGING) {\n\t\t\tenableLocalStaging(\n\t\t\t\tuserId, scopeGroupId, liveGroupId, branchingPublic,\n\t\t\t\tbranchingPrivate, lockingPublic, lockingPrivate,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_REMOTE_STAGING) {\n\t\t\tString remoteAddress = ParamUtil.getString(\n\t\t\t\tportletRequest, \"remoteAddress\");\n\t\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\t\tportletRequest, \"remoteGroupId\");\n\t\t\tint remotePort = ParamUtil.getInteger(portletRequest, \"remotePort\");\n\t\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"secureConnection\");\n\n\t\t\tenableRemoteStaging(\n\t\t\t\tuserId, scopeGroupId, liveGroupId, branchingPublic,\n\t\t\t\tbranchingPrivate, lockingPublic, lockingPrivate,\n\t\t\t\tremoteAddress, remoteGroupId, remotePort, secureConnection,\n\t\t\t\tserviceContext);\n\t\t}\n\t}","commit_id":"5e4ab40f7d42d48646d13d1e7848cfa1671ecc82","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Calendar getDate(\n\t\t\tPortletRequest portletRequest, String paramPrefix,\n\t\t\tboolean timeZoneSensitive)\n\t\tthrows Exception {\n\n\t\tint dateMonth = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Month\");\n\t\tint dateDay = ParamUtil.getInteger(portletRequest, paramPrefix + \"Day\");\n\t\tint dateYear = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Year\");\n\t\tint dateHour = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Hour\");\n\t\tint dateMinute = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Minute\");\n\t\tint dateAmPm = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"AmPm\");\n\n\t\tif (dateAmPm == Calendar.PM) {\n\t\t\tdateHour += 12;\n\t\t}\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)portletRequest.getAttribute(\n\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlocale = themeDisplay.getLocale();\n\t\t\ttimeZone = themeDisplay.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar cal = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tcal.set(Calendar.MONTH, dateMonth);\n\t\tcal.set(Calendar.DATE, dateDay);\n\t\tcal.set(Calendar.YEAR, dateYear);\n\t\tcal.set(Calendar.HOUR_OF_DAY, dateHour);\n\t\tcal.set(Calendar.MINUTE, dateMinute);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\n\t\treturn cal;\n\t}","id":66813,"modified_method":"protected Calendar getDate(\n\t\t\tPortletRequest portletRequest, String paramPrefix,\n\t\t\tboolean timeZoneSensitive)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tint dateMonth = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Month\");\n\t\tint dateDay = ParamUtil.getInteger(portletRequest, paramPrefix + \"Day\");\n\t\tint dateYear = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Year\");\n\t\tint dateHour = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Hour\");\n\t\tint dateMinute = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"Minute\");\n\t\tint dateAmPm = ParamUtil.getInteger(\n\t\t\tportletRequest, paramPrefix + \"AmPm\");\n\n\t\tif (dateAmPm == Calendar.PM) {\n\t\t\tdateHour += 12;\n\t\t}\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = themeDisplay.getLocale();\n\t\t\ttimeZone = themeDisplay.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar cal = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tcal.set(Calendar.MONTH, dateMonth);\n\t\tcal.set(Calendar.DATE, dateDay);\n\t\tcal.set(Calendar.YEAR, dateYear);\n\t\tcal.set(Calendar.HOUR_OF_DAY, dateHour);\n\t\tcal.set(Calendar.MINUTE, dateMinute);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\n\t\treturn cal;\n\t}","commit_id":"5e4ab40f7d42d48646d13d1e7848cfa1671ecc82","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void enableLocalStaging(\n\t\t\tlong userId, long scopeGroupId, long liveGroupId,\n\t\t\tboolean branchingPublic, boolean branchingPrivate,\n\t\t\tboolean lockingPublic, boolean lockingPrivate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tGroup liveGroup = GroupLocalServiceUtil.getGroup(liveGroupId);\n\n\t\tif (liveGroup.isStagedRemotely()) {\n\t\t\tdisableStaging(scopeGroupId, liveGroupId, serviceContext);\n\t\t}\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branching-public\", String.valueOf(branchingPublic));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branching-private\", String.valueOf(branchingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"locking-public\", String.valueOf(lockingPublic));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"locking-private\", String.valueOf(lockingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"staged\", Boolean.TRUE.toString());\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"stagedRemotely\", String.valueOf(false));\n\n\t\tsetCommonStagingOptions(\n\t\t\tliveGroup, typeSettingsProperties, serviceContext);\n\n\t\tif (!liveGroup.hasStagingGroup()) {\n\t\t\tserviceContext.setAttribute(\"staging\", String.valueOf(true));\n\n\t\t\tGroup stagingGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\tuserId, liveGroup.getClassName(), liveGroup.getClassPK(),\n\t\t\t\tliveGroup.getGroupId(), liveGroup.getDescriptiveName(),\n\t\t\t\tliveGroup.getDescription(), liveGroup.getType(),\n\t\t\t\tliveGroup.getFriendlyURL(), liveGroup.isActive(),\n\t\t\t\tserviceContext);\n\n\t\t\tGroupLocalServiceUtil.updateGroup(\n\t\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t\tif (liveGroup.hasPrivateLayouts()) {\n\t\t\t\tMap<String, String[]> parameterMap = getStagingParameters();\n\n\t\t\t\tpublishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\ttrue, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (liveGroup.hasPublicLayouts()) {\n\t\t\t\tMap<String, String[]> parameterMap = getStagingParameters();\n\n\t\t\t\tpublishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\tfalse, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (branchingPublic) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.addLayoutSetBranch(\n\t\t\t\t\tuserId, stagingGroup.getGroupId(), false,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME.concat(\n\t\t\t\t\t\t\" branch of \").concat(\n\t\t\t\t\t\t\tstagingGroup.getDescriptiveName()), serviceContext);\n\t\t\t}\n\n\t\t\tif (branchingPrivate) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.addLayoutSetBranch(\n\t\t\t\t\tuserId, stagingGroup.getGroupId(), true,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME.concat(\n\t\t\t\t\t\t\" branch of \").concat(\n\t\t\t\t\t\t\tstagingGroup.getDescriptiveName()), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tGroupLocalServiceUtil.updateGroup(\n\t\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t\tif (!branchingPublic) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.deleteLayoutSetBranches(\n\t\t\t\t\tliveGroup.getStagingGroup().getGroupId(), true);\n\t\t\t}\n\t\t}\n\t}","id":66814,"modified_method":"public void enableLocalStaging(\n\t\t\tlong userId, long scopeGroupId, long liveGroupId,\n\t\t\tboolean branchingPublic, boolean branchingPrivate,\n\t\t\tboolean lockingPublic, boolean lockingPrivate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tGroup liveGroup = GroupLocalServiceUtil.getGroup(liveGroupId);\n\n\t\tif (liveGroup.isStagedRemotely()) {\n\t\t\tdisableStaging(scopeGroupId, liveGroupId, serviceContext);\n\t\t}\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branching-private\", String.valueOf(branchingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branching-public\", String.valueOf(branchingPublic));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"locking-private\", String.valueOf(lockingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"locking-public\", String.valueOf(lockingPublic));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"staged\", Boolean.TRUE.toString());\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"stagedRemotely\", String.valueOf(false));\n\n\t\tsetCommonStagingOptions(\n\t\t\tliveGroup, typeSettingsProperties, serviceContext);\n\n\t\tif (!liveGroup.hasStagingGroup()) {\n\t\t\tserviceContext.setAttribute(\"staging\", String.valueOf(true));\n\n\t\t\tGroup stagingGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\tuserId, liveGroup.getClassName(), liveGroup.getClassPK(),\n\t\t\t\tliveGroup.getGroupId(), liveGroup.getDescriptiveName(),\n\t\t\t\tliveGroup.getDescription(), liveGroup.getType(),\n\t\t\t\tliveGroup.getFriendlyURL(), liveGroup.isActive(),\n\t\t\t\tserviceContext);\n\n\t\t\tGroupLocalServiceUtil.updateGroup(\n\t\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t\tif (liveGroup.hasPrivateLayouts()) {\n\t\t\t\tMap<String, String[]> parameterMap = getStagingParameters();\n\n\t\t\t\tpublishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\ttrue, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (liveGroup.hasPublicLayouts()) {\n\t\t\t\tMap<String, String[]> parameterMap = getStagingParameters();\n\n\t\t\t\tpublishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\tfalse, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (branchingPublic) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.addLayoutSetBranch(\n\t\t\t\t\tuserId, stagingGroup.getGroupId(), false,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME.concat(\n\t\t\t\t\t\t\" branch of \").concat(\n\t\t\t\t\t\t\tstagingGroup.getDescriptiveName()), serviceContext);\n\t\t\t}\n\n\t\t\tif (branchingPrivate) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.addLayoutSetBranch(\n\t\t\t\t\tuserId, stagingGroup.getGroupId(), true,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\tLayoutSetBranchConstants.MASTER_BRANCH_NAME.concat(\n\t\t\t\t\t\t\" branch of \").concat(\n\t\t\t\t\t\t\tstagingGroup.getDescriptiveName()), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tGroupLocalServiceUtil.updateGroup(\n\t\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t\tif (!branchingPublic) {\n\t\t\t\tLayoutSetBranchLocalServiceUtil.deleteLayoutSetBranches(\n\t\t\t\t\tliveGroup.getStagingGroup().getGroupId(), true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5e4ab40f7d42d48646d13d1e7848cfa1671ecc82","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static AssetCategory addCategory(\n\t\t\tlong groupId, long vocabularyId, long parentCategoryId)\n\t\tthrows Exception {\n\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tLocale locale = LocaleUtil.getSiteDefault();\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\ttitleMap.put(locale, ServiceTestUtil.randomString());\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(locale, ServiceTestUtil.randomString());\n\n\t\tString[] categoryProperties = null;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroupId, userId);\n\n\t\treturn AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tuserId, parentCategoryId, titleMap, descriptionMap, vocabularyId,\n\t\t\tcategoryProperties, serviceContext);\n\t}","id":66815,"modified_method":"public static AssetCategory addCategory(\n\t\t\tlong groupId, long vocabularyId, long parentCategoryId)\n\t\tthrows Exception {\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\tLocale locale = LocaleUtil.getSiteDefault();\n\n\t\ttitleMap.put(locale, ServiceTestUtil.randomString());\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(locale, ServiceTestUtil.randomString());\n\n\t\tString[] categoryProperties = null;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroupId, TestPropsValues.getUserId());\n\n\t\treturn AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tTestPropsValues.getUserId(), parentCategoryId, titleMap,\n\t\t\tdescriptionMap, vocabularyId, categoryProperties, serviceContext);\n\t}","commit_id":"c9171da156079bf97fa0a14d12a01114b559eac7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static AssetVocabulary addVocabulary(long groupId) throws Exception {\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tString title = ServiceTestUtil.randomString();\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroupId, userId);\n\n\t\treturn AssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\tuserId, title, serviceContext);\n\t}","id":66816,"modified_method":"public static AssetVocabulary addVocabulary(long groupId) throws Exception {\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroupId, userId);\n\n\t\treturn AssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\tuserId, ServiceTestUtil.randomString(), serviceContext);\n\t}","commit_id":"c9171da156079bf97fa0a14d12a01114b559eac7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getSearchByUserRoles(\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery)\n\t\tthrows Exception {\n\n\t\tBoolean searchByUserRoles =\n\t\t\tkaleoTaskInstanceTokenQuery.isSearchByUserRoles();\n\n\t\tif (searchByUserRoles == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (searchByUserRoles) {\n\t\t\tList<Long> roleIds = getSearchByUserRoleIds(\n\t\t\t\tkaleoTaskInstanceTokenQuery);\n\n\t\t\tlong userId = kaleoTaskInstanceTokenQuery.getUserId();\n\n\t\t\tList<UserGroupRole> userGroupRoles =\n\t\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRoles(userId);\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\tlong[] userGroupIds = user.getUserGroupIds();\n\n\t\t\tList<UserGroupGroupRole> userGroupGroupRoles =\n\t\t\t\tnew ArrayList<UserGroupGroupRole>();\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tList<UserGroupGroupRole> roles =\n\t\t\t\t\tUserGroupGroupRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserGroupId);\n\n\t\t\t\tuserGroupGroupRoles.addAll(roles);\n\t\t\t}\n\n\t\t\tif (roleIds.isEmpty() && userGroupRoles.isEmpty() &&\n\t\t\t\tuserGroupGroupRoles.isEmpty()) {\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(\"AND ((\");\n\t\t\tsb.append(\"KaleoTaskAssignmentInstance.assigneeClassName = ?) \");\n\t\t\tsb.append(\"AND (\");\n\n\t\t\tfor (int i = 0; i < roleIds.size(); i++) {\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?)\");\n\n\t\t\t\tif ((i + 1) < roleIds.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!roleIds.isEmpty() && !userGroupRoles.isEmpty()) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupRoles.size(); i++) {\n\t\t\t\tsb.append(\"((KaleoTaskAssignmentInstance.groupId = ?) AND \");\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\t\tif ((i + 1) < userGroupRoles.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((!roleIds.isEmpty() || !userGroupRoles.isEmpty()) &&\n\t\t\t\t!userGroupGroupRoles.isEmpty()) {\n\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupGroupRoles.size(); i++) {\n\t\t\t\tsb.append(\"((KaleoTaskAssignmentInstance.groupId = ?) AND \");\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\t\tif ((i + 1) < userGroupGroupRoles.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(\"))\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(\"AND ((\");\n\t\t\tsb.append(\"KaleoTaskAssignmentInstance.assigneeClassName = ?) \");\n\t\t\tsb.append(\"AND (KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\t}","id":66817,"modified_method":"protected String getSearchByUserRoles(\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery)\n\t\tthrows Exception {\n\n\t\tBoolean searchByUserRoles =\n\t\t\tkaleoTaskInstanceTokenQuery.isSearchByUserRoles();\n\n\t\tif (searchByUserRoles == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (searchByUserRoles) {\n\t\t\tList<Long> roleIds = getSearchByUserRoleIds(\n\t\t\t\tkaleoTaskInstanceTokenQuery);\n\n\t\t\tList<UserGroupRole> userGroupRoles =\n\t\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRoles(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getUserId());\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(\n\t\t\t\tkaleoTaskInstanceTokenQuery.getUserId());\n\n\t\t\tlong[] userGroupIds = user.getUserGroupIds();\n\n\t\t\tList<UserGroupGroupRole> userGroupGroupRoles =\n\t\t\t\tnew ArrayList<UserGroupGroupRole>();\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tList<UserGroupGroupRole> roles =\n\t\t\t\t\tUserGroupGroupRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserGroupId);\n\n\t\t\t\tuserGroupGroupRoles.addAll(roles);\n\t\t\t}\n\n\t\t\tif (roleIds.isEmpty() && userGroupRoles.isEmpty() &&\n\t\t\t\tuserGroupGroupRoles.isEmpty()) {\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(\"AND ((\");\n\t\t\tsb.append(\"KaleoTaskAssignmentInstance.assigneeClassName = ?) \");\n\t\t\tsb.append(\"AND (\");\n\n\t\t\tfor (int i = 0; i < roleIds.size(); i++) {\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?)\");\n\n\t\t\t\tif ((i + 1) < roleIds.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!roleIds.isEmpty() && !userGroupRoles.isEmpty()) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupRoles.size(); i++) {\n\t\t\t\tsb.append(\"((KaleoTaskAssignmentInstance.groupId = ?) AND \");\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\t\tif ((i + 1) < userGroupRoles.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((!roleIds.isEmpty() || !userGroupRoles.isEmpty()) &&\n\t\t\t\t!userGroupGroupRoles.isEmpty()) {\n\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupGroupRoles.size(); i++) {\n\t\t\t\tsb.append(\"((KaleoTaskAssignmentInstance.groupId = ?) AND \");\n\t\t\t\tsb.append(\"(KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\t\tif ((i + 1) < userGroupGroupRoles.size()) {\n\t\t\t\t\tsb.append(\" OR \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(\"))\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(\"AND ((\");\n\t\t\tsb.append(\"KaleoTaskAssignmentInstance.assigneeClassName = ?) \");\n\t\t\tsb.append(\"AND (KaleoTaskAssignmentInstance.assigneeClassPK = ?))\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\t}","commit_id":"0961eea5b814de401ff2c8b1028f82fe19abb475","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setSearchByUserRoles(\n\t\t\tQueryPos qPos,\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery)\n\t\tthrows Exception {\n\n\t\tBoolean searchByUserRoles =\n\t\t\tkaleoTaskInstanceTokenQuery.isSearchByUserRoles();\n\n\t\tif (searchByUserRoles == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (searchByUserRoles) {\n\t\t\tqPos.add(Role.class.getName());\n\n\t\t\tList<Long> roleIds = getSearchByUserRoleIds(\n\t\t\t\tkaleoTaskInstanceTokenQuery);\n\n\t\t\tlong userId = kaleoTaskInstanceTokenQuery.getUserId();\n\n\t\t\tList<UserGroupRole> userGroupRoles =\n\t\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRoles(userId);\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\tlong[] userGroupIds = user.getUserGroupIds();\n\n\t\t\tList<UserGroupGroupRole> userGroupGroupRoles =\n\t\t\t\tnew ArrayList<UserGroupGroupRole>();\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tList<UserGroupGroupRole> roles =\n\t\t\t\t\tUserGroupGroupRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserGroupId);\n\n\t\t\t\tuserGroupGroupRoles.addAll(roles);\n\t\t\t}\n\n\t\t\tif (roleIds.isEmpty() && userGroupRoles.isEmpty() &&\n\t\t\t\tuserGroupGroupRoles.isEmpty()) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (Long roleId : roleIds) {\n\t\t\t\tqPos.add(roleId);\n\t\t\t}\n\n\t\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\t\tqPos.add(userGroupRole.getGroupId());\n\t\t\t\tqPos.add(userGroupRole.getRoleId());\n\t\t\t}\n\n\t\t\tfor (UserGroupGroupRole userGroupGroupRole : userGroupGroupRoles) {\n\t\t\t\tqPos.add(userGroupGroupRole.getGroupId());\n\t\t\t\tqPos.add(userGroupGroupRole.getRoleId());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tqPos.add(User.class.getName());\n\t\t\tqPos.add(kaleoTaskInstanceTokenQuery.getUserId());\n\t\t}\n\t}","id":66818,"modified_method":"protected void setSearchByUserRoles(\n\t\t\tQueryPos qPos,\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery)\n\t\tthrows Exception {\n\n\t\tBoolean searchByUserRoles =\n\t\t\tkaleoTaskInstanceTokenQuery.isSearchByUserRoles();\n\n\t\tif (searchByUserRoles == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (searchByUserRoles) {\n\t\t\tqPos.add(Role.class.getName());\n\n\t\t\tList<Long> roleIds = getSearchByUserRoleIds(\n\t\t\t\tkaleoTaskInstanceTokenQuery);\n\n\t\t\tList<UserGroupRole> userGroupRoles =\n\t\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRoles(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getUserId());\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(\n\t\t\t\tkaleoTaskInstanceTokenQuery.getUserId());\n\n\t\t\tlong[] userGroupIds = user.getUserGroupIds();\n\n\t\t\tList<UserGroupGroupRole> userGroupGroupRoles =\n\t\t\t\tnew ArrayList<UserGroupGroupRole>();\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tList<UserGroupGroupRole> roles =\n\t\t\t\t\tUserGroupGroupRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserGroupId);\n\n\t\t\t\tuserGroupGroupRoles.addAll(roles);\n\t\t\t}\n\n\t\t\tif (roleIds.isEmpty() && userGroupRoles.isEmpty() &&\n\t\t\t\tuserGroupGroupRoles.isEmpty()) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (Long roleId : roleIds) {\n\t\t\t\tqPos.add(roleId);\n\t\t\t}\n\n\t\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\t\tqPos.add(userGroupRole.getGroupId());\n\t\t\t\tqPos.add(userGroupRole.getRoleId());\n\t\t\t}\n\n\t\t\tfor (UserGroupGroupRole userGroupGroupRole : userGroupGroupRoles) {\n\t\t\t\tqPos.add(userGroupGroupRole.getGroupId());\n\t\t\t\tqPos.add(userGroupGroupRole.getRoleId());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tqPos.add(User.class.getName());\n\t\t\tqPos.add(kaleoTaskInstanceTokenQuery.getUserId());\n\t\t}\n\t}","commit_id":"0961eea5b814de401ff2c8b1028f82fe19abb475","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Test\n\tpublic void testTrashVersionCreationWhenMovingToTrash() throws Exception {\n\t\tint initialTrashVersionsCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tWikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false, false);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionsCount + 3,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","id":66819,"modified_method":"@Test\n\tpublic void testTrashVersionCreationWhenMovingToTrash() throws Exception {\n\t\tint initialTrashVersionsCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionsCount + 3,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMovePageWithRedirectPageToTrash() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false);\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(redirectPage.getRedirectTitle(), page.getTitle());\n\t}","id":66820,"modified_method":"@Test\n\tpublic void testMovePageWithRedirectPageToTrash() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageAndParentPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\trestoreTrashEntry(parentPage);\n\t\trestoreTrashEntry(childPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t}","id":66821,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageAndParentPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\t\trestoreFromTrash(_relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageWithTrashedParentFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\trestoreTrashEntry(childPage);\n\n\t\tparentPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tparentPage.getPrimaryKey());\n\t\tchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tchildPage.getPrimaryKey());\n\t\tgrandchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tgrandchildPage.getPrimaryKey());\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(StringPool.BLANK, childPage.getParentTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 2,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66822,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageWithTrashedParentFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(StringPool.BLANK, childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 2,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\trestoreTrashEntry(page);\n\t\trestoreTrashEntry(childPage);\n\n\t\tpage = WikiPageLocalServiceUtil.getPageByPageId(page.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(childPage.getParentTitle(), page.getTitle());\n\t}","id":66823,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\t\trestoreFromTrash(_relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPagePageWithChildToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), false, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(parentPage.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66824,"modified_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPagePageWithChildToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\n\t\trestoreTrashEntry(page);\n\n\t\tpage = WikiPageLocalServiceUtil.getPageByPageId(page.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(redirectPage.getRedirectTitle(), page.getTitle());\n\t}","id":66825,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveInitialParentPageToTrash() throws Exception {\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages = WikiTestUtil.addPageWithChangedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage finalParentPage = pages[1];\n\t\tWikiPage initialParentPage = pages[2];\n\n\t\tWikiPageLocalServiceUtil.movePageToTrash(\n\t\t\tTestPropsValues.getUserId(), initialParentPage);\n\n\t\tpage = WikiPageLocalServiceUtil.getPageByPageId(page.getPageId());\n\t\tfinalParentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tfinalParentPage.getPageId());\n\t\tinitialParentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tinitialParentPage.getPageId());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(finalParentPage.isInTrash());\n\t\tAssert.assertTrue(initialParentPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(finalParentPage.getTitle(), page.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 2,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(page.getParentTitle(), finalParentPage.getTitle());\n\t}","id":66826,"modified_method":"@Test\n\tpublic void testMoveInitialParentPageToTrash() throws Exception {\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tWikiPage initialParentPage = _relatedPages.getParentPage();\n\t\tWikiPage page = _relatedPages.getPage();\n\n\t\tWikiPage newParentPage =  WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), true);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tWikiPageLocalServiceUtil.changeParent(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), page.getTitle(),\n\t\t\tnewParentPage.getTitle(), serviceContext);\n\n\t\tmovePageToTrash(initialParentPage);\n\n\t\tnewParentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tnewParentPage.getResourcePrimKey());\n\t\tpage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(newParentPage.isInTrash());\n\t\tAssert.assertTrue(initialParentPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getParentTitle(), newParentPage.getTitle());\n\t\tAssert.assertEquals(newParentPage.getTitle(), page.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 2,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testTrashVersionDeletionWhenRestoringFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialTrashVersionCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false, false);\n\n\t\tWikiPage parentPage = pages[0];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionCount,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","id":66827,"modified_method":"@Test\n\tpublic void testTrashVersionDeletionWhenRestoringFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialTrashVersionCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tpopulateRelatedPages();\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.movePageToTrash(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), \"RenamedPage\");\n\n\t\trestoreFromTrash(page);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionCount,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestMoveParentPageWithRedirectAndChildPageAndgrandchildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addRenamedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\t\tWikiPage childPage = pages[2];\n\t\tWikiPage grandchildPage = pages[3];\n\n\t\tWikiPageTrashHandlerTestUtil.moveBaseModelToTrash(redirectPage.getPrimaryKey());\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tgrandchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tgrandchildPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tparentPage.getTitle(), redirectPage.getRedirectTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(parentPage.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66828,"modified_method":"@Test\n\tpublic void\n\t\t\ttestMoveParentPageWithRedirectAndChildPageAndgrandchildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreRedirectPageWithParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addRenamedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\t\tWikiPage childPage = pages[2];\n\t\tWikiPage grandchildPage = pages[3];\n\n\t\tWikiPageTrashHandlerTestUtil.moveBaseModelToTrash(\n\t\t\tredirectPage.getPrimaryKey());\n\n\t\trestoreTrashEntry(redirectPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tgrandchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tgrandchildPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertFalse(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tparentPage.getTitle(), redirectPage.getRedirectTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(parentPage.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 4,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66829,"modified_method":"@Test\n\tpublic void testRestoreRedirectPageWithParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\n\t\trestoreFromTrash(_relatedPages.getRedirectPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertFalse(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 4,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyChildPageWithChildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), true, false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66830,"modified_method":"@Test\n\tpublic void testMoveExplicitlyChildPageWithChildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedRedirectPageWithRestoredPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\n\t\trestoreTrashEntry(page);\n\t\trestoreTrashEntry(redirectPage);\n\n\t\tpage = WikiPageLocalServiceUtil.getPageByPageId(page.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(redirectPage.getRedirectTitle(), page.getTitle());\n\t}","id":66831,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedRedirectPageWithRestoredPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\t\trestoreFromTrash(_relatedPages.getRedirectPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreParentPageToADifferentNode() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addPageWithChildPageAndRedirectPage(\n\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\t_group.getGroupId(), newNode.getNodeId(), true);\n\n\t\tmoveTrashEntry(\n\t\t\tchildPage.getResourcePrimKey(), newParentPage.getResourcePrimKey());\n\n\t\tpage = WikiPageLocalServiceUtil.getPage(page.getResourcePrimKey());\n\t\tchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tchildPage.getResourcePrimKey());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tredirectPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectPage.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\tnewParentPage.getTitle(), childPage.getParentTitle());\n\t}","id":66832,"modified_method":"@Test\n\tpublic void testRestoreParentPageToADifferentNode() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\t_group.getGroupId(), newNode.getNodeId(), true);\n\n\t\tmoveTrashEntry(\n\t\t\t_relatedPages.getChildPageResourcePrimKey(),\n\t\t\tnewParentPage.getResourcePrimKey());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectPage.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\tnewParentPage.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage redirectPage = pages[1];\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(redirectPage.getRedirectTitle(), page.getTitle());\n\t}","id":66833,"modified_method":"@Test\n\tpublic void testMoveExplicitlyPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWitExplicitlyTrashedChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t}","id":66834,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWitExplicitlyTrashedChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyChildPageWithChildPageAndParentPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 2,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66835,"modified_method":"@Test\n\tpublic void testMoveExplicitlyChildPageWithChildPageAndParentPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(grandchildPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 2,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreParentPageWithExplicitlyTrashedRrdirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66836,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreParentPageWithExplicitlyTrashedRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), false, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66837,"modified_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestorePageToADifferentNode() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addPageWithChildPageAndRedirectPage(\n\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage page = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tmoveTrashEntry(childPage.getResourcePrimKey(), newNode.getNodeId());\n\n\t\tpage = WikiPageLocalServiceUtil.getPage(page.getResourcePrimKey());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tredirectPage.getResourcePrimKey());\n\t\tchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tchildPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectPage.getNodeId());\n\n\t\tAssert.assertNull(childPage.getParentPage());\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tpage.getResourcePrimKey());\n\t\tWikiPageResource childPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tchildPage.getResourcePrimKey());\n\t\tWikiPageResource redirectPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tredirectPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), pageResource.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPageResource.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\t_node.getNodeId(), redirectPageResource.getNodeId());\n\t}","id":66838,"modified_method":"@Test\n\tpublic void testRestorePageToADifferentNode() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tmoveTrashEntry(\n\t\t\t_relatedPages.getChildPageResourcePrimKey(), newNode.getNodeId());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectPage.getNodeId());\n\t\tAssert.assertNull(childPage.getParentPage());\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tpage.getResourcePrimKey());\n\t\tWikiPageResource childPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tchildPage.getResourcePrimKey());\n\t\tWikiPageResource redirectPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tredirectPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), pageResource.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPageResource.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\t_node.getNodeId(), redirectPageResource.getNodeId());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageAndChildPageAndRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\t\trestoreTrashEntry(childPage);\n\t\trestoreTrashEntry(redirectPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66839,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageAndChildPageAndRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\t\trestoreFromTrash(_relatedPages.getChildPage());\n\t\trestoreFromTrash(_relatedPages.getRedirectPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageWithRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66840,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageWithRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\n\t\trestoreTrashEntry(redirectPage);\n\t}","id":66841,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\n\t\trestoreFromTrash(_relatedPages.getRedirectPage());\n\n\t\tredirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndRedirectFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\t\trestoreTrashEntry(redirectPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tredirectPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tredirectPage.getPageId());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66842,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndRedirectFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\t\trestoreFromTrash(_relatedPages.getRedirectPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveParentPageToTrash() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t}","id":66843,"modified_method":"@Test\n\tpublic void testMoveParentPageToTrash() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestMoveExplicitlyChildPageAndParentPageWithRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66844,"modified_method":"@Test\n\tpublic void\n\t\t\ttestMoveExplicitlyChildPageAndParentPageWithRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getRedirectPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedChildPageWithChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), true, false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\trestoreTrashEntry(childPage);\n\n\t\tparentPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tparentPage.getPrimaryKey());\n\t\tchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tchildPage.getPrimaryKey());\n\t\tgrandchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tgrandchildPage.getPrimaryKey());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(parentPage.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66845,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedChildPageWithChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\n\t\trestoreFromTrash(_relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveParentPageWithRedirectPageToTrash() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false, false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66846,"modified_method":"@Test\n\tpublic void testMoveParentPageWithRedirectPageToTrash() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashImplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddPageWithSameTitleAsImplicitlyDeletedPageVersion()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addPageWithChangedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId());\n\n\t\tWikiPage childPage = pages[0];\n\t\tWikiPage parentPage = pages[1];\n\n\t\tString childPageTitle = childPage.getTitle();\n\n\t\tWikiPageLocalServiceUtil.movePageToTrash(\n\t\t\tTestPropsValues.getUserId(), parentPage);\n\n\t\tWikiPage page = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tchildPageTitle, true);\n\n\t\tAssert.assertNotNull(page);\n\t}","id":66847,"modified_method":"@Test\n\tpublic void testAddPageWithSameTitleAsImplicitlyDeletedPageVersion()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tWikiPage childPage = _relatedPages.getChildPage();\n\n\t\tString childPageOriginalTitle = childPage.getTitle();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertNotEquals(childPageOriginalTitle, childPage.getTitle());\n\n\t\tWikiPage newPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tchildPageOriginalTitle, true);\n\n\t\tAssert.assertNotNull(newPage);\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addRenamedTrashedParentPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage redirectPage = pages[2];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t\tAssert.assertTrue(redirectPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tredirectPage.getRedirectTitle(), parentPage.getTitle());\n\t}","id":66848,"modified_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPageAndRedirectPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getRedirectPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectPage.isInTrashImplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectPage.getRedirectTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestorePageWithParentPageInTrash() throws Exception {\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false);\n\n\t\tWikiPage childPage = pages[1];\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tWikiPage.class.getName());\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\ttrashHandler.moveEntry(\n\t\t\tTestPropsValues.getUserId(), childPage.getResourcePrimKey(),\n\t\t\tnewParentPage.getResourcePrimKey(), serviceContext);\n\n\t\tchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tchildPage.getResourcePrimKey());\n\n\t\tAssert.assertTrue(childPage.isApproved());\n\t\tAssert.assertEquals(\n\t\t\tnewParentPage.getTitle(), childPage.getParentTitle());\n\t}","id":66849,"modified_method":"@Test\n\tpublic void testRestorePageWithParentPageInTrash() throws Exception {\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getParentPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tmovePage(page, newParentPage);\n\n\t\tpage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(newParentPage.getTitle(), page.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithChildPageAndgrandchildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tWikiPage[] pages =\n\t\t\tWikiTestUtil.addTrashedParentPageWithChildPageAndGrandchildPage(\n\t\t\t\t_group.getGroupId(), _node.getNodeId(), false, true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\t\tWikiPage grandchildPage = pages[2];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tparentPage.getPrimaryKey());\n\t\tchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tchildPage.getPrimaryKey());\n\t\tgrandchildPage = (WikiPage)WikiPageTrashHandlerTestUtil.getBaseModel(\n\t\t\tgrandchildPage.getPrimaryKey());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(parentPage.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":66850,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithChildPageAndgrandchildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(childPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPageToTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), true);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t}","id":66851,"modified_method":"@Test\n\tpublic void testMoveExplicitlyParentPageAndChildPageToTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getChildPage());\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tWikiPage[] pages = WikiTestUtil.addTrashedPageWithChildPage(\n\t\t\t_group.getGroupId(), _node.getNodeId(), false);\n\n\t\tWikiPage parentPage = pages[0];\n\t\tWikiPage childPage = pages[1];\n\n\t\trestoreTrashEntry(parentPage);\n\n\t\tparentPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tparentPage.getPageId());\n\t\tchildPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\tchildPage.getPageId());\n\n\t\tAssert.assertFalse(parentPage.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(childPage.getParentTitle(), parentPage.getTitle());\n\t}","id":66852,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tpopulateRelatedPages();\n\n\t\tmovePageToTrash(_relatedPages.getPage());\n\n\t\trestoreFromTrash(_relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_relatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void restoreTrashEntry(WikiPage page) throws Exception {\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tWikiPage.class.getName());\n\n\t\ttrashHandler.restoreTrashEntry(\n\t\t\tTestPropsValues.getUserId(),\n\t\t\tWikiPageTrashHandlerTestUtil.getTrashEntryClassPK(page));\n\t}","id":66853,"modified_method":"protected void restoreFromTrash(WikiPage page) throws Exception {\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tWikiPage.class.getName());\n\n\t\ttrashHandler.restoreTrashEntry(\n\t\t\tTestPropsValues.getUserId(), page.getResourcePrimKey());\n\t}","commit_id":"3473debc6ab6eb2f9d65a3037e1e111972cbb60d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendNotificationEvent(\n\t\t\tTasksEntry tasksEntry, int previousStatus,\n\t\t\tlong previousAssigneeUserId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tint status = tasksEntry.getStatus();\n\n\t\tif ((status != TasksEntryConstants.STATUS_OPEN) &&\n\t\t\t(status != TasksEntryConstants.STATUS_RESOLVED) &&\n\t\t\t(status != TasksEntryConstants.STATUS_REOPENED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong userId = serviceContext.getUserId();\n\t\tlong assigneeUserId = tasksEntry.getAssigneeUserId();\n\t\tlong creatorUserId = tasksEntry.getUserId();\n\n\t\tList<Long> receiverUserIds = new ArrayList<Long>();\n\n\t\tif (creatorUserId != userId ) {\n\t\t\treceiverUserIds.add(creatorUserId);\n\t\t}\n\n\t\tif (assigneeUserId != userId &&\n\t\t\t!receiverUserIds.contains(assigneeUserId)) {\n\n\t\t\treceiverUserIds.add(assigneeUserId);\n\t\t}\n\n\t\tif (previousAssigneeUserId != 0 &&\n\t\t\tpreviousAssigneeUserId != userId &&\n\t\t\t!receiverUserIds.contains(assigneeUserId)) {\n\n\t\t\treceiverUserIds.add(previousAssigneeUserId);\n\t\t}\n\n\t\tJSONObject notificationEventJSON = JSONFactoryUtil.createJSONObject();\n\n\t\tnotificationEventJSON.put(\"body\", tasksEntry.getTitle());\n\t\tnotificationEventJSON.put(\"entryId\", tasksEntry.getTasksEntryId());\n\t\tnotificationEventJSON.put(\"portletId\", \"1_WAR_tasksportlet\");\n\t\tnotificationEventJSON.put(\"userId\", userId);\n\n\t\tfor (long receiverUserId : receiverUserIds) {\n\t\t\tString title = StringPool.BLANK;\n\n\t\t\tif (assigneeUserId != previousAssigneeUserId) {\n\t\t\t\tif (receiverUserId == previousAssigneeUserId) {\n\t\t\t\t\ttitle = \"reassigned-your-task\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitle = \"assigned-you-a-task\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (status != previousStatus) {\n\t\t\t\tString statusLabel = TasksEntryConstants.getStatusLabel(\n\t\t\t\t\ttasksEntry.getStatus());\n\n\t\t\t\ttitle = statusLabel + \"-the-task\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = \"modified-the-task\";\n\t\t\t}\n\n\t\t\tnotificationEventJSON.put(\"title\", title);\n\n\t\t\tNotificationEvent notificationEvent =\n\t\t\t\tNotificationEventFactoryUtil.createNotificationEvent(\n\t\t\t\t\tSystem.currentTimeMillis(), \"6_WAR_soportlet\",\n\t\t\t\t\tnotificationEventJSON);\n\n\t\t\tnotificationEvent.setDeliveryRequired(0);\n\n\t\t\tChannelHubManagerUtil.sendNotificationEvent(\n\t\t\t\ttasksEntry.getCompanyId(), receiverUserId, notificationEvent);\n\t\t}\n\t}","id":66854,"modified_method":"protected void sendNotificationEvent(\n\t\t\tTasksEntry tasksEntry, int previousStatus,\n\t\t\tlong previousAssigneeUserId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tint status = tasksEntry.getStatus();\n\n\t\tif ((status != TasksEntryConstants.STATUS_OPEN) &&\n\t\t\t(status != TasksEntryConstants.STATUS_RESOLVED) &&\n\t\t\t(status != TasksEntryConstants.STATUS_REOPENED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tHashSet<Long> receiverUserIds = new HashSet<Long>(3);\n\n\t\treceiverUserIds.add(tasksEntry.getUserId());\n\t\treceiverUserIds.add(previousAssigneeUserId);\n\t\treceiverUserIds.add(tasksEntry.getAssigneeUserId());\n\n\t\treceiverUserIds.remove(serviceContext.getUserId());\n\n\t\tJSONObject notificationEventJSON = JSONFactoryUtil.createJSONObject();\n\n\t\tnotificationEventJSON.put(\"body\", tasksEntry.getTitle());\n\t\tnotificationEventJSON.put(\"entryId\", tasksEntry.getTasksEntryId());\n\t\tnotificationEventJSON.put(\"portletId\", \"1_WAR_tasksportlet\");\n\t\tnotificationEventJSON.put(\"userId\", serviceContext.getUserId());\n\n\t\tfor (long receiverUserId : receiverUserIds) {\n\t\t\tString title = StringPool.BLANK;\n\n\t\t\tif (tasksEntry.getAssigneeUserId() != previousAssigneeUserId) {\n\t\t\t\tif (receiverUserId == previousAssigneeUserId) {\n\t\t\t\t\ttitle = \"reassigned-your-task\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitle = \"assigned-you-a-task\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (status != previousStatus) {\n\t\t\t\tString statusLabel = TasksEntryConstants.getStatusLabel(\n\t\t\t\t\ttasksEntry.getStatus());\n\n\t\t\t\ttitle = statusLabel + \"-the-task\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = \"modified-the-task\";\n\t\t\t}\n\n\t\t\tnotificationEventJSON.put(\"title\", title);\n\n\t\t\tNotificationEvent notificationEvent =\n\t\t\t\tNotificationEventFactoryUtil.createNotificationEvent(\n\t\t\t\t\tSystem.currentTimeMillis(), \"6_WAR_soportlet\",\n\t\t\t\t\tnotificationEventJSON);\n\n\t\t\tnotificationEvent.setDeliveryRequired(0);\n\n\t\t\tChannelHubManagerUtil.sendNotificationEvent(\n\t\t\t\ttasksEntry.getCompanyId(), receiverUserId, notificationEvent);\n\t\t}\n\t}","commit_id":"83839096f0afe672add8728ee90b8db9de7e8646","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public TasksEntry addTasksEntry(\n\t\t\tlong userId, String title, int priority, long assigneeUserId,\n\t\t\tint dueDateMonth, int dueDateDay, int dueDateYear, int dueDateHour,\n\t\t\tint dueDateMinute, boolean neverDue, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Tasks entry\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tDate dueDate = null;\n\n\t\tif (!neverDue) {\n\t\t\tdueDate = PortalUtil.getDate(\n\t\t\t\tdueDateMonth, dueDateDay, dueDateYear, dueDateHour,\n\t\t\t\tdueDateMinute, user.getTimeZone(),\n\t\t\t\tnew TasksEntryDueDateException());\n\t\t}\n\n\t\tlong tasksEntryId = CounterLocalServiceUtil.increment();\n\n\t\tTasksEntry tasksEntry = tasksEntryPersistence.create(tasksEntryId);\n\n\t\ttasksEntry.setGroupId(groupId);\n\t\ttasksEntry.setCompanyId(user.getCompanyId());\n\t\ttasksEntry.setUserId(user.getUserId());\n\t\ttasksEntry.setUserName(user.getFullName());\n\t\ttasksEntry.setCreateDate(now);\n\t\ttasksEntry.setModifiedDate(now);\n\t\ttasksEntry.setTitle(title);\n\t\ttasksEntry.setPriority(priority);\n\t\ttasksEntry.setAssigneeUserId(assigneeUserId);\n\t\ttasksEntry.setDueDate(dueDate);\n\t\ttasksEntry.setStatus(TasksEntryConstants.STATUS_OPEN);\n\n\t\ttasksEntryPersistence.update(tasksEntry, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(tasksEntry, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, tasksEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Social\n\n\t\tSocialActivityLocalServiceUtil.addActivity(\n\t\t\tuserId, groupId, TasksEntry.class.getName(), tasksEntryId,\n\t\t\tTasksActivityKeys.ADD_ENTRY, StringPool.BLANK, assigneeUserId);\n\n\t\t// Notification\n\n\t\tsendNotificationEvent(\n\t\t\ttasksEntry, TasksEntryConstants.STATUS_ALL, 0, serviceContext);\n\n\t\treturn tasksEntry;\n\t}","id":66855,"modified_method":"public TasksEntry addTasksEntry(\n\t\t\tlong userId, String title, int priority, long assigneeUserId,\n\t\t\tint dueDateMonth, int dueDateDay, int dueDateYear, int dueDateHour,\n\t\t\tint dueDateMinute, boolean neverDue, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Tasks entry\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tDate dueDate = null;\n\n\t\tif (!neverDue) {\n\t\t\tdueDate = PortalUtil.getDate(\n\t\t\t\tdueDateMonth, dueDateDay, dueDateYear, dueDateHour,\n\t\t\t\tdueDateMinute, user.getTimeZone(),\n\t\t\t\tnew TasksEntryDueDateException());\n\t\t}\n\n\t\tlong tasksEntryId = CounterLocalServiceUtil.increment();\n\n\t\tTasksEntry tasksEntry = tasksEntryPersistence.create(tasksEntryId);\n\n\t\ttasksEntry.setGroupId(groupId);\n\t\ttasksEntry.setCompanyId(user.getCompanyId());\n\t\ttasksEntry.setUserId(user.getUserId());\n\t\ttasksEntry.setUserName(user.getFullName());\n\t\ttasksEntry.setCreateDate(now);\n\t\ttasksEntry.setModifiedDate(now);\n\t\ttasksEntry.setTitle(title);\n\t\ttasksEntry.setPriority(priority);\n\t\ttasksEntry.setAssigneeUserId(assigneeUserId);\n\t\ttasksEntry.setDueDate(dueDate);\n\t\ttasksEntry.setStatus(TasksEntryConstants.STATUS_OPEN);\n\n\t\ttasksEntryPersistence.update(tasksEntry, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(tasksEntry, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, tasksEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Social\n\n\t\tSocialActivityLocalServiceUtil.addActivity(\n\t\t\tuserId, groupId, TasksEntry.class.getName(), tasksEntryId,\n\t\t\tTasksActivityKeys.ADD_ENTRY, StringPool.BLANK, assigneeUserId);\n\n\t\t// Notification\n\n\t\tsendNotificationEvent(\n\t\t\ttasksEntry, TasksEntryConstants.STATUS_ALL, assigneeUserId,\n\t\t\tserviceContext);\n\n\t\treturn tasksEntry;\n\t}","commit_id":"83839096f0afe672add8728ee90b8db9de7e8646","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void updateMBComment(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tlong mbMessageId = ParamUtil.getLong(actionRequest, \"entryId\");\n\t\tlong mbThreadId = ParamUtil.getLong(actionRequest, \"mbThreadId\");\n\t\tlong parentMBMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMBMessageId\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\ttry {\n\t\t\tMBMessage mbMessage = null;\n\n\t\t\tlong groupId = themeDisplay.getScopeGroupId();\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\t\tif (cmd.equals(Constants.DELETE)) {\n\t\t\t\tMBMessageServiceUtil.deleteDiscussionMessage(\n\t\t\t\t\tgroupId, className, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), mbMessageId);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.EDIT) && (mbMessageId > 0)) {\n\t\t\t\tmbMessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\t\tclassName, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), mbMessageId, StringPool.BLANK,\n\t\t\t\t\tbody, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbMessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\t\tgroupId, className, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), mbThreadId, parentMBMessageId,\n\t\t\t\t\tStringPool.BLANK, body, serviceContext);\n\t\t\t}\n\n\t\t\tif (mbMessage != null) {\n\t\t\t\tjsonObject = getJSONObject(\n\t\t\t\t\tmbMessage.getMessageId(), mbMessage.getBody(),\n\t\t\t\t\tmbMessage.getModifiedDate(), mbMessage.getUserId(),\n\t\t\t\t\tmbMessage.getUserName(), themeDisplay);\n\t\t\t}\n\n\t\t\tjsonObject.put(\"success\", Boolean.TRUE);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tjsonObject.put(\"success\", Boolean.FALSE);\n\t\t}\n\n\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t}","id":66856,"modified_method":"public void updateMBComment(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tlong mbMessageId = ParamUtil.getLong(actionRequest, \"entryId\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\ttry {\n\t\t\tMBMessage mbMessage = null;\n\n\t\t\tlong groupId = themeDisplay.getScopeGroupId();\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\t\tif (cmd.equals(Constants.DELETE)) {\n\t\t\t\tMBMessageServiceUtil.deleteDiscussionMessage(\n\t\t\t\t\tgroupId, className, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), mbMessageId);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.EDIT) && (mbMessageId > 0)) {\n\t\t\t\tmbMessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\t\tclassName, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), mbMessageId, StringPool.BLANK,\n\t\t\t\t\tbody, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMBMessageDisplay mbMessageDisplay =\n\t\t\t\t\tMBMessageLocalServiceUtil.getDiscussionMessageDisplay(\n\t\t\t\t\t\tthemeDisplay.getUserId(), groupId, className, classPK,\n\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tMBThread thread = mbMessageDisplay.getThread();\n\n\t\t\t\tMBTreeWalker mbTreeWalker = mbMessageDisplay.getTreeWalker();\n\n\t\t\t\tMBMessage rootMessage = mbTreeWalker.getRoot();\n\n\t\t\t\tmbMessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\t\tgroupId, className, classPK, className, classPK,\n\t\t\t\t\tthemeDisplay.getUserId(), thread.getThreadId(),\n\t\t\t\t\trootMessage.getMessageId(), StringPool.BLANK, body,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tif (mbMessage != null) {\n\t\t\t\tjsonObject = getJSONObject(\n\t\t\t\t\tmbMessage.getMessageId(), mbMessage.getBody(),\n\t\t\t\t\tmbMessage.getModifiedDate(), mbMessage.getUserId(),\n\t\t\t\t\tmbMessage.getUserName(), themeDisplay);\n\t\t\t}\n\n\t\t\tjsonObject.put(\"success\", Boolean.TRUE);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tjsonObject.put(\"success\", Boolean.FALSE);\n\t\t}\n\n\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t}","commit_id":"4e9e3a916813f9f2d37bc7dc4ecd1fb18a0b3b33","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String fileUpload(\n\t\tCommandArgument arg, String fileName, File file, String extension) {\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\targ.getCompanyId(), arg.getCurrentGroupName());\n\n\t\t\tDLFolder folder = _getFolder(\n\t\t\t\tgroup.getGroupId(), arg.getCurrentFolder());\n\n\t\t\tString userId = arg.getUserId();\n\n\t\t\tString folderId = folder.getFolderId();\n\t\t\t\n\t\t\tDLFolderPermission.check(\n\t\t\t\tPermissionThreadLocal.getPermissionChecker(), folderId, \n\t\t\t\tActionKeys.ADD_DOCUMENT);\n\n\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\tuserId, folderId, fileName, fileName, StringPool.BLANK, \n\t\t\t\tStringPool.BLANK, file, true, true);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new FCKException(e);\n\t\t}\n\n\t\treturn \"0\";\n\t}","id":66857,"modified_method":"protected String fileUpload(\n\t\tCommandArgument arg, String fileName, File file, String extension) {\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\targ.getCompanyId(), arg.getCurrentGroupName());\n\n\t\t\tDLFolder folder = _getFolder(\n\t\t\t\tgroup.getGroupId(), arg.getCurrentFolder());\n\n\t\t\tDLFolderPermission.check(\n\t\t\t\tPermissionThreadLocal.getPermissionChecker(), folder,\n\t\t\t\tActionKeys.ADD_DOCUMENT);\n\n\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\targ.getUserId(), folder.getFolderId(), fileName, fileName,\n\t\t\t\tStringPool.BLANK, StringPool.BLANK, file, true, true);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new FCKException(e);\n\t\t}\n\n\t\treturn \"0\";\n\t}","commit_id":"309523f3bc7e2805943caeac13c8f0bb9f5e8a48","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFileEntry(\n\t\t\tFileEntryForm fileEntryForm, ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadReq =\n\t\t\tPortalUtil.getUploadPortletRequest(req);\n\n\t\tString cmd = ParamUtil.getString(uploadReq, Constants.CMD);\n\n\t\tString folderId = ParamUtil.getString(uploadReq, \"folderId\");\n\t\tString newFolderId = ParamUtil.getString(uploadReq, \"newFolderId\");\n\t\tString name = ParamUtil.getString(uploadReq, \"name\");\n\t\tString sourceFileName = uploadReq.getFileName(\"file\");\n\n\t\tString title = ParamUtil.getString(uploadReq, \"title\");\n\t\tString description = ParamUtil.getString(uploadReq, \"description\");\n\n\t\tString extraSettings = PropertiesUtil.toString(\n\t\t\tfileEntryForm.getExtraSettingsProperties());\n\n\t\tFile file = uploadReq.getFile(\"file\");\n\n\t\tString[] communityPermissions = req.getParameterValues(\n\t\t\t\"communityPermissions\");\n\t\tString[] guestPermissions = req.getParameterValues(\n\t\t\t\"guestPermissions\");\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tString userId = themeDisplay.getUserId();\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\n\t\t\t// Add file entry\n\t\t\tDLFolderPermission.check(\n\t\t\t\tthemeDisplay.getPermissionChecker(), folderId, \n\t\t\t\tActionKeys.ADD_DOCUMENT);\n\n\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\tuserId, folderId, sourceFileName, title, description, \n\t\t\t\textraSettings, file, communityPermissions, guestPermissions);\n\t\t}\n\t\telse {\n\n\t\t\t// Update file entry\n\n\t\t\tDLFileEntryPermission.check(\n\t\t\t\tthemeDisplay.getPermissionChecker(), folderId, name,\n\t\t\t\tActionKeys.VIEW);\n\n\t\t\tDLFileEntryLocalServiceUtil.updateFileEntry(\n\t\t\t\tuserId, folderId, newFolderId, name, sourceFileName, title, \n\t\t\t\tdescription, extraSettings, file);\n\t\t}\n\t}","id":66858,"modified_method":"protected void updateFileEntry(\n\t\t\tFileEntryForm fileEntryForm, ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadReq =\n\t\t\tPortalUtil.getUploadPortletRequest(req);\n\n\t\tString cmd = ParamUtil.getString(uploadReq, Constants.CMD);\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tString folderId = ParamUtil.getString(uploadReq, \"folderId\");\n\t\tString newFolderId = ParamUtil.getString(uploadReq, \"newFolderId\");\n\t\tString name = ParamUtil.getString(uploadReq, \"name\");\n\t\tString sourceFileName = uploadReq.getFileName(\"file\");\n\n\t\tString title = ParamUtil.getString(uploadReq, \"title\");\n\t\tString description = ParamUtil.getString(uploadReq, \"description\");\n\n\t\tString extraSettings = PropertiesUtil.toString(\n\t\t\tfileEntryForm.getExtraSettingsProperties());\n\n\t\tFile file = uploadReq.getFile(\"file\");\n\n\t\tString[] communityPermissions = req.getParameterValues(\n\t\t\t\"communityPermissions\");\n\t\tString[] guestPermissions = req.getParameterValues(\n\t\t\t\"guestPermissions\");\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\n\t\t\t// Add file entry\n\n\t\t\tDLFolderPermission.check(\n\t\t\t\tthemeDisplay.getPermissionChecker(), folderId,\n\t\t\t\tActionKeys.ADD_DOCUMENT);\n\n\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\tthemeDisplay.getUserId(), folderId, sourceFileName, title,\n\t\t\t\tdescription, extraSettings, file, communityPermissions,\n\t\t\t\tguestPermissions);\n\t\t}\n\t\telse {\n\n\t\t\t// Update file entry\n\n\t\t\tDLFileEntryPermission.check(\n\t\t\t\tthemeDisplay.getPermissionChecker(), folderId, name,\n\t\t\t\tActionKeys.UPDATE);\n\n\t\t\tDLFileEntryLocalServiceUtil.updateFileEntry(\n\t\t\t\tthemeDisplay.getUserId(), folderId, newFolderId, name,\n\t\t\t\tsourceFileName, title, description, extraSettings, file);\n\t\t}\n\t}","commit_id":"309523f3bc7e2805943caeac13c8f0bb9f5e8a48","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkEquityLogs() throws SystemException {\n\t\tint validity = getEquityDate();\n\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_ASSET_ENTRY_IQ_1, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_ASSET_ENTRY_IQ_2, validity);\n\t\trunCheckSQL(_CHECK_ASSET_ENTRY, validity);\n\n\t\tassetEntryPersistence.clearCache();\n\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_CQ, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PQ_1, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PQ_2, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PEQ, validity);\n\t\trunCheckSQL(_CHECK_USER, validity);\n\n\t\tuserPersistence.clearCache();\n\t}","id":66859,"modified_method":"public void checkEquityLogs() throws SystemException {\n\t\tint validity = getEquityDate();\n\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_ASSET_ENTRY_IQ_1, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_ASSET_ENTRY_IQ_2, validity);\n\t\trunCheckSQL(_CHECK_ASSET_ENTRY, validity);\n\n\t\tassetEntryPersistence.clearCache();\n\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_CQ, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PQ_1, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PQ_2, validity);\n\t\trunCheckSQL(_CHECK_SOCIAL_EQUITY_USER_PEQ, validity);\n\t\trunCheckSQL(_CHECK_USER_CQPQ, validity);\n\t\trunCheckSQL(_CHECK_USER_PEQ, validity);\n\n\t\tuserPersistence.clearCache();\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deactivateEquityLogs(long assetEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialEquityLog> equityLogs =\n\t\t\tsocialEquityLogPersistence.findByAEI_A(assetEntryId, true);\n\n\t\tfor (SocialEquityLog equityLog : equityLogs) {\n\t\t\tdeactivateEquityLog(equityLog);\n\t\t}\n\t}","id":66860,"modified_method":"public void deactivateEquityLogs(long assetEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialEquityLog> equityLogs =\n\t\t\tsocialEquityLogPersistence.findByAEI_T_A(\n\t\t\t\tassetEntryId,SocialEquitySettingConstants.TYPE_INFORMATION,\n\t\t\t\ttrue);\n\n\t\tSocialEquityAssetEntry socialEquityAssetEntry =\n\t\t\tsocialEquityAssetEntryPersistence.findByAssetEntryId(assetEntryId);\n\n\t\tsocialEquityAssetEntryPersistence.removeByAssetEntryId(assetEntryId);\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = userPersistence.findByPrimaryKey(\n\t\t\t\tsocialEquityAssetEntry.getUserId());\n\n\t\t\tif (!user.isDefaultUser()) {\n\t\t\t\tupdateSocialEquityUser_CQ(\n\t\t\t\t\tsocialEquityAssetEntry.getGroupId(), user.getUserId());\n\n\t\t\t\tupdateSocialEquityUser_PEQ(\n\t\t\t\t\tsocialEquityAssetEntry.getGroupId(), user.getUserId());\n\n\t\t\t\tupdateUser_CQPQ(user.getUserId());\n\n\t\t\t\tupdateUser_PEQ(user.getUserId());\n\n\t\t\t\tuserPersistence.clearCache(user);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tfor (SocialEquityLog equityLog : equityLogs) {\n\t\t\tequityLog.setActive(false);\n\n\t\t\tsocialEquityLogPersistence.update(equityLog, false);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateUser(long userId) throws SystemException {\n\t\tString sql = CustomSQLUtil.get(_UPDATE_USER);\n\n\t\tsql = StringUtil.replace(sql, \"[$USER_ID$]\", String.valueOf(userId));\n\n\t\trunSQL(sql);\n\t}","id":66861,"modified_method":"protected void updateUser_PEQ(long userId) throws SystemException {\n\t\tString sql = CustomSQLUtil.get(_UPDATE_USER_PEQ);\n\n\t\tsql = StringUtil.replace(sql, \"[$USER_ID$]\", String.valueOf(userId));\n\n\t\trunSQL(sql);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEquityLogs(\n\t\t\tlong userId, long assetEntryId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialEquityLog> equityLogs =\n\t\t\tsocialEquityLogPersistence.findByU_AEI_A_A(\n\t\t\t\tuserId, assetEntryId, actionId, true);\n\n\t\tif (!equityLogs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tAssetEntry assetEntry = assetEntryPersistence.findByPrimaryKey(\n\t\t\tassetEntryId);\n\n\t\tList<SocialEquitySetting> equitySettings =\n\t\t\tsocialEquitySettingPersistence.findByC_A(\n\t\t\t\tassetEntry.getClassNameId(), actionId);\n\n\t\tfor (SocialEquitySetting equitySetting : equitySettings) {\n\t\t\taddEquityLog(user, assetEntry, equitySetting);\n\t\t}\n\t}","id":66862,"modified_method":"public void addEquityLogs(\n\t\t\tlong userId, long assetEntryId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialEquityLog> equityLogs =\n\t\t\tsocialEquityLogPersistence.findByU_AEI_A_A(\n\t\t\t\tuserId, assetEntryId, actionId, true);\n\n\t\tif (!equityLogs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tAssetEntry assetEntry = assetEntryPersistence.findByPrimaryKey(\n\t\t\tassetEntryId);\n\n\t\tUser assetEntryOwner = null;\n\n\t\ttry {\n\n\t\t\tassetEntryOwner = userPersistence.findByPrimaryKey(\n\t\t\t\tassetEntry.getUserId());\n\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tassetEntryOwner = user;\n\t\t}\n\n\t\tList<SocialEquitySetting> equitySettings = getEquitySettings(\n\t\t\tassetEntry, actionId);\n\n\t\tfor (SocialEquitySetting equitySetting : equitySettings) {\n\t\t\taddEquityLog(user, assetEntry, assetEntryOwner, equitySetting);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addEquityLog(\n\t\t\tUser user, AssetEntry assetEntry, SocialEquitySetting equitySetting)\n\t\tthrows SystemException {\n\n\t\tint actionDate = getEquityDate();\n\n\t\tdouble k = getK(\n\t\t\tequitySetting.getValue(), equitySetting.getValidity());\n\t\tdouble b = getB(\n\t\t\tactionDate, equitySetting.getValue(), equitySetting.getValidity());\n\n\t\tif (equitySetting.getType() ==\n\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION) {\n\n\t\t\tint count = socialEquityAssetEntryPersistence.countByAssetEntryId(\n\t\t\t\tassetEntry.getEntryId());\n\n\t\t\tif (count == 0) {\n\t\t\t\taddSocialEquityAssetEntry(assetEntry);\n\t\t\t}\n\n\t\t\tupdateSocialEquityAssetEntry_IQ(\n\t\t\t\tassetEntry.getEntryId(), actionDate, k, b);\n\n\t\t\tupdateAssetEntry(assetEntry.getEntryId());\n\n\t\t\tassetEntryPersistence.clearCache(assetEntry);\n\n\t\t\tupdateSocialEquityUser_CQ(\n\t\t\t\tassetEntry.getGroupId(), user.getUserId());\n\t\t}\n\t\telse if (equitySetting.getType() ==\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION) {\n\n\t\t\tint count = socialEquityUserPersistence.countByUserId(\n\t\t\t\tuser.getUserId());\n\n\t\t\tif (count == 0) {\n\t\t\t\taddSocialEquityUser(assetEntry.getGroupId(), user);\n\t\t\t}\n\n\t\t\tupdateSocialEquityUser_PQ(\n\t\t\t\tassetEntry.getGroupId(), user.getUserId(), actionDate, k, b);\n\t\t}\n\n\t\tupdateUser(user.getUserId());\n\n\t\tuserPersistence.clearCache(user);\n\n\t\tlong equityLogId = counterLocalService.increment();\n\n\t\tSocialEquityLog equityLog = socialEquityLogPersistence.create(\n\t\t\tequityLogId);\n\n\t\tequityLog.setGroupId(assetEntry.getGroupId());\n\t\tequityLog.setCompanyId(user.getCompanyId());\n\t\tequityLog.setUserId(user.getUserId());\n\t\tequityLog.setAssetEntryId(assetEntry.getEntryId());\n\t\tequityLog.setActionId(equitySetting.getActionId());\n\t\tequityLog.setActionDate(actionDate);\n\t\tequityLog.setType(equitySetting.getType());\n\t\tequityLog.setValue(equitySetting.getValue());\n\t\tequityLog.setValidity(actionDate + equitySetting.getValidity());\n\t\tequityLog.setActive(true);\n\n\t\tsocialEquityLogPersistence.update(equityLog, false);\n\t}","id":66863,"modified_method":"protected void addEquityLog(\n\t\t\tUser user, AssetEntry assetEntry, User assetEntryOwner,\n\t\t\tSocialEquitySetting equitySetting)\n\t\tthrows SystemException {\n\n\t\tint actionDate = getEquityDate();\n\n\t\tdouble k = getK(\n\t\t\tequitySetting.getValue(), equitySetting.getValidity());\n\t\tdouble b = getB(\n\t\t\tactionDate, equitySetting.getValue(), equitySetting.getValidity());\n\n\t\tif (equitySetting.getType() ==\n\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION) {\n\n\t\t\tint count = socialEquityAssetEntryPersistence.countByAssetEntryId(\n\t\t\t\tassetEntry.getEntryId());\n\n\t\t\tif (count == 0) {\n\t\t\t\taddSocialEquityAssetEntry(assetEntry);\n\t\t\t}\n\n\t\t\tupdateSocialEquityAssetEntry_IQ(\n\t\t\t\tassetEntry.getEntryId(), actionDate, k, b);\n\n\t\t\tupdateAssetEntry(assetEntry.getEntryId());\n\n\t\t\tassetEntryPersistence.clearCache(assetEntry);\n\n\t\t\tif (!assetEntryOwner.isDefaultUser()) {\n\n\t\t\t\tupdateSocialEquityUser_CQ(assetEntry.getGroupId(),\n\t\t\t\t\tassetEntryOwner.getUserId());\n\n\t\t\t\tupdateSocialEquityUser_PEQ(assetEntry.getGroupId(),\n\t\t\t\t\tassetEntryOwner.getUserId());\n\n\t\t\t\tupdateUser_CQPQ(assetEntryOwner.getUserId());\n\n\t\t\t\tupdateUser_PEQ(assetEntryOwner.getUserId());\n\n\t\t\t\tuserPersistence.clearCache(assetEntryOwner);\n\t\t\t}\n\t\t}\n\t\telse if (equitySetting.getType() ==\n\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION) {\n\n\t\t\tint count = socialEquityUserPersistence.countByUserId(\n\t\t\t\tuser.getUserId());\n\n\t\t\tif (count == 0) {\n\t\t\t\taddSocialEquityUser(assetEntry.getGroupId(), user);\n\t\t\t}\n\n\t\t\tif (!user.isDefaultUser()) {\n\n\t\t\t\tupdateSocialEquityUser_PQ(assetEntry.getGroupId(),\n\t\t\t\t\tuser.getUserId(), actionDate, k, b);\n\n\t\t\t\tupdateSocialEquityUser_PEQ(assetEntry.getGroupId(),\n\t\t\t\t\tuser.getUserId());\n\n\t\t\t\tupdateUser_CQPQ(user.getUserId());\n\n\t\t\t\tupdateUser_PEQ(user.getUserId());\n\n\t\t\t\tuserPersistence.clearCache(user);\n\t\t\t}\n\t\t}\n\n\t\tlong equityLogId = counterLocalService.increment();\n\n\t\tSocialEquityLog equityLog = socialEquityLogPersistence.create(\n\t\t\tequityLogId);\n\n\t\tequityLog.setGroupId(assetEntry.getGroupId());\n\t\tequityLog.setCompanyId(user.getCompanyId());\n\t\tequityLog.setUserId(user.getUserId());\n\t\tequityLog.setAssetEntryId(assetEntry.getEntryId());\n\t\tequityLog.setActionId(equitySetting.getActionId());\n\t\tequityLog.setActionDate(actionDate);\n\t\tequityLog.setType(equitySetting.getType());\n\t\tequityLog.setValue(equitySetting.getValue());\n\t\tequityLog.setValidity(actionDate + equitySetting.getValidity());\n\t\tequityLog.setActive(true);\n\n\t\tsocialEquityLogPersistence.update(equityLog, false);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SocialEquityLog> findByAEI_A(long assetEntryId, boolean active,\n\t\tint start, int end, OrderByComparator orderByComparator)\n\t\tthrows SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), Boolean.valueOf(active),\n\t\t\t\t\n\t\t\t\tString.valueOf(start), String.valueOf(end),\n\t\t\t\tString.valueOf(orderByComparator)\n\t\t\t};\n\n\t\tList<SocialEquityLog> list = (List<SocialEquityLog>)FinderCacheUtil.getResult(FINDER_PATH_FIND_BY_OBC_AEI_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = null;\n\n\t\t\t\tif (orderByComparator != null) {\n\t\t\t\t\tquery = new StringBundler(4 +\n\t\t\t\t\t\t\t(orderByComparator.getOrderByFields().length * 3));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery = new StringBundler(3);\n\t\t\t\t}\n\n\t\t\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ACTIVE_2);\n\n\t\t\t\tif (orderByComparator != null) {\n\t\t\t\t\tappendOrderByComparator(query, _ORDER_BY_ENTITY_ALIAS,\n\t\t\t\t\t\torderByComparator);\n\t\t\t\t}\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tlist = (List<SocialEquityLog>)QueryUtil.list(q, getDialect(),\n\t\t\t\t\t\tstart, end);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<SocialEquityLog>();\n\t\t\t\t}\n\n\t\t\t\tcacheResult(list);\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_FIND_BY_OBC_AEI_A,\n\t\t\t\t\tfinderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","id":66864,"modified_method":"public List<SocialEquityLog> findByAEI_T_A(long assetEntryId, int type,\n\t\tboolean active, int start, int end, OrderByComparator orderByComparator)\n\t\tthrows SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), new Integer(type),\n\t\t\t\tBoolean.valueOf(active),\n\t\t\t\t\n\t\t\t\tString.valueOf(start), String.valueOf(end),\n\t\t\t\tString.valueOf(orderByComparator)\n\t\t\t};\n\n\t\tList<SocialEquityLog> list = (List<SocialEquityLog>)FinderCacheUtil.getResult(FINDER_PATH_FIND_BY_OBC_AEI_T_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = null;\n\n\t\t\t\tif (orderByComparator != null) {\n\t\t\t\t\tquery = new StringBundler(5 +\n\t\t\t\t\t\t\t(orderByComparator.getOrderByFields().length * 3));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery = new StringBundler(4);\n\t\t\t\t}\n\n\t\t\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_TYPE_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ACTIVE_2);\n\n\t\t\t\tif (orderByComparator != null) {\n\t\t\t\t\tappendOrderByComparator(query, _ORDER_BY_ENTITY_ALIAS,\n\t\t\t\t\t\torderByComparator);\n\t\t\t\t}\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(type);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tlist = (List<SocialEquityLog>)QueryUtil.list(q, getDialect(),\n\t\t\t\t\t\tstart, end);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<SocialEquityLog>();\n\t\t\t\t}\n\n\t\t\t\tcacheResult(list);\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_FIND_BY_OBC_AEI_T_A,\n\t\t\t\t\tfinderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SocialEquityLog> findByAEI_A(long assetEntryId, boolean active,\n\t\tint start, int end) throws SystemException {\n\t\treturn findByAEI_A(assetEntryId, active, start, end, null);\n\t}","id":66865,"modified_method":"public List<SocialEquityLog> findByAEI_T_A(long assetEntryId, int type,\n\t\tboolean active, int start, int end) throws SystemException {\n\t\treturn findByAEI_T_A(assetEntryId, type, active, start, end, null);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SocialEquityLog> findByAEI_A(long assetEntryId, boolean active)\n\t\tthrows SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), Boolean.valueOf(active)\n\t\t\t};\n\n\t\tList<SocialEquityLog> list = (List<SocialEquityLog>)FinderCacheUtil.getResult(FINDER_PATH_FIND_BY_AEI_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = new StringBundler(3);\n\n\t\t\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ACTIVE_2);\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tlist = q.list();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<SocialEquityLog>();\n\t\t\t\t}\n\n\t\t\t\tcacheResult(list);\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_FIND_BY_AEI_A,\n\t\t\t\t\tfinderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","id":66866,"modified_method":"public List<SocialEquityLog> findByAEI_T_A(long assetEntryId, int type,\n\t\tboolean active) throws SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), new Integer(type),\n\t\t\t\tBoolean.valueOf(active)\n\t\t\t};\n\n\t\tList<SocialEquityLog> list = (List<SocialEquityLog>)FinderCacheUtil.getResult(FINDER_PATH_FIND_BY_AEI_T_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = new StringBundler(4);\n\n\t\t\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_TYPE_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ACTIVE_2);\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(type);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tlist = q.list();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<SocialEquityLog>();\n\t\t\t\t}\n\n\t\t\t\tcacheResult(list);\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_FIND_BY_AEI_T_A,\n\t\t\t\t\tfinderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialEquityLog[] findByAEI_A_PrevAndNext(long equityLogId,\n\t\tlong assetEntryId, boolean active, OrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tSocialEquityLog socialEquityLog = findByPrimaryKey(equityLogId);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tSocialEquityLog[] array = new SocialEquityLogImpl[3];\n\n\t\t\tarray[0] = getByAEI_A_PrevAndNext(session, socialEquityLog,\n\t\t\t\t\tassetEntryId, active, orderByComparator, true);\n\n\t\t\tarray[1] = socialEquityLog;\n\n\t\t\tarray[2] = getByAEI_A_PrevAndNext(session, socialEquityLog,\n\t\t\t\t\tassetEntryId, active, orderByComparator, false);\n\n\t\t\treturn array;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":66867,"modified_method":"public SocialEquityLog[] findByAEI_T_A_PrevAndNext(long equityLogId,\n\t\tlong assetEntryId, int type, boolean active,\n\t\tOrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tSocialEquityLog socialEquityLog = findByPrimaryKey(equityLogId);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tSocialEquityLog[] array = new SocialEquityLogImpl[3];\n\n\t\t\tarray[0] = getByAEI_T_A_PrevAndNext(session, socialEquityLog,\n\t\t\t\t\tassetEntryId, type, active, orderByComparator, true);\n\n\t\t\tarray[1] = socialEquityLog;\n\n\t\t\tarray[2] = getByAEI_T_A_PrevAndNext(session, socialEquityLog,\n\t\t\t\t\tassetEntryId, type, active, orderByComparator, false);\n\n\t\t\treturn array;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialEquityLog getByAEI_A_PrevAndNext(Session session,\n\t\tSocialEquityLog socialEquityLog, long assetEntryId, boolean active,\n\t\tOrderByComparator orderByComparator, boolean previous) {\n\t\tStringBundler query = null;\n\n\t\tif (orderByComparator != null) {\n\t\t\tquery = new StringBundler(6 +\n\t\t\t\t\t(orderByComparator.getOrderByFields().length * 6));\n\t\t}\n\t\telse {\n\t\t\tquery = new StringBundler(3);\n\t\t}\n\n\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\tquery.append(_FINDER_COLUMN_AEI_A_ASSETENTRYID_2);\n\n\t\tquery.append(_FINDER_COLUMN_AEI_A_ACTIVE_2);\n\n\t\tif (orderByComparator != null) {\n\t\t\tString[] orderByFields = orderByComparator.getOrderByFields();\n\n\t\t\tif (orderByFields.length > 0) {\n\t\t\t\tquery.append(WHERE_AND);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < orderByFields.length; i++) {\n\t\t\t\tquery.append(_ORDER_BY_ENTITY_ALIAS);\n\t\t\t\tquery.append(orderByFields[i]);\n\n\t\t\t\tif ((i + 1) < orderByFields.length) {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(WHERE_GREATER_THAN_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(WHERE_LESSER_THAN_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(WHERE_GREATER_THAN);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(WHERE_LESSER_THAN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery.append(ORDER_BY_CLAUSE);\n\n\t\t\tfor (int i = 0; i < orderByFields.length; i++) {\n\t\t\t\tquery.append(_ORDER_BY_ENTITY_ALIAS);\n\t\t\t\tquery.append(orderByFields[i]);\n\n\t\t\t\tif ((i + 1) < orderByFields.length) {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(ORDER_BY_ASC_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(ORDER_BY_DESC_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(ORDER_BY_ASC);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(ORDER_BY_DESC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery.append(WHERE_LIMIT_2);\n\t\t}\n\n\t\tString sql = query.toString();\n\n\t\tQuery q = session.createQuery(sql);\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tqPos.add(assetEntryId);\n\n\t\tqPos.add(active);\n\n\t\tif (orderByComparator != null) {\n\t\t\tObject[] values = orderByComparator.getOrderByValues(socialEquityLog);\n\n\t\t\tfor (Object value : values) {\n\t\t\t\tqPos.add(value);\n\t\t\t}\n\t\t}\n\n\t\tList<SocialEquityLog> list = q.list();\n\n\t\tif (list.size() == 2) {\n\t\t\treturn list.get(1);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":66868,"modified_method":"protected SocialEquityLog getByAEI_T_A_PrevAndNext(Session session,\n\t\tSocialEquityLog socialEquityLog, long assetEntryId, int type,\n\t\tboolean active, OrderByComparator orderByComparator, boolean previous) {\n\t\tStringBundler query = null;\n\n\t\tif (orderByComparator != null) {\n\t\t\tquery = new StringBundler(6 +\n\t\t\t\t\t(orderByComparator.getOrderByFields().length * 6));\n\t\t}\n\t\telse {\n\t\t\tquery = new StringBundler(3);\n\t\t}\n\n\t\tquery.append(_SQL_SELECT_SOCIALEQUITYLOG_WHERE);\n\n\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ASSETENTRYID_2);\n\n\t\tquery.append(_FINDER_COLUMN_AEI_T_A_TYPE_2);\n\n\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ACTIVE_2);\n\n\t\tif (orderByComparator != null) {\n\t\t\tString[] orderByFields = orderByComparator.getOrderByFields();\n\n\t\t\tif (orderByFields.length > 0) {\n\t\t\t\tquery.append(WHERE_AND);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < orderByFields.length; i++) {\n\t\t\t\tquery.append(_ORDER_BY_ENTITY_ALIAS);\n\t\t\t\tquery.append(orderByFields[i]);\n\n\t\t\t\tif ((i + 1) < orderByFields.length) {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(WHERE_GREATER_THAN_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(WHERE_LESSER_THAN_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(WHERE_GREATER_THAN);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(WHERE_LESSER_THAN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery.append(ORDER_BY_CLAUSE);\n\n\t\t\tfor (int i = 0; i < orderByFields.length; i++) {\n\t\t\t\tquery.append(_ORDER_BY_ENTITY_ALIAS);\n\t\t\t\tquery.append(orderByFields[i]);\n\n\t\t\t\tif ((i + 1) < orderByFields.length) {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(ORDER_BY_ASC_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(ORDER_BY_DESC_HAS_NEXT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (orderByComparator.isAscending() ^ previous) {\n\t\t\t\t\t\tquery.append(ORDER_BY_ASC);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.append(ORDER_BY_DESC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery.append(WHERE_LIMIT_2);\n\t\t}\n\n\t\tString sql = query.toString();\n\n\t\tQuery q = session.createQuery(sql);\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tqPos.add(assetEntryId);\n\n\t\tqPos.add(type);\n\n\t\tqPos.add(active);\n\n\t\tif (orderByComparator != null) {\n\t\t\tObject[] values = orderByComparator.getOrderByValues(socialEquityLog);\n\n\t\t\tfor (Object value : values) {\n\t\t\t\tqPos.add(value);\n\t\t\t}\n\t\t}\n\n\t\tList<SocialEquityLog> list = q.list();\n\n\t\tif (list.size() == 2) {\n\t\t\treturn list.get(1);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int countByAEI_A(long assetEntryId, boolean active)\n\t\tthrows SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), Boolean.valueOf(active)\n\t\t\t};\n\n\t\tLong count = (Long)FinderCacheUtil.getResult(FINDER_PATH_COUNT_BY_AEI_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (count == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = new StringBundler(3);\n\n\t\t\t\tquery.append(_SQL_COUNT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_A_ACTIVE_2);\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tcount = (Long)q.uniqueResult();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (count == null) {\n\t\t\t\t\tcount = Long.valueOf(0);\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_COUNT_BY_AEI_A,\n\t\t\t\t\tfinderArgs, count);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn count.intValue();\n\t}","id":66869,"modified_method":"public int countByAEI_T_A(long assetEntryId, int type, boolean active)\n\t\tthrows SystemException {\n\t\tObject[] finderArgs = new Object[] {\n\t\t\t\tnew Long(assetEntryId), new Integer(type),\n\t\t\t\tBoolean.valueOf(active)\n\t\t\t};\n\n\t\tLong count = (Long)FinderCacheUtil.getResult(FINDER_PATH_COUNT_BY_AEI_T_A,\n\t\t\t\tfinderArgs, this);\n\n\t\tif (count == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tStringBundler query = new StringBundler(4);\n\n\t\t\t\tquery.append(_SQL_COUNT_SOCIALEQUITYLOG_WHERE);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ASSETENTRYID_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_TYPE_2);\n\n\t\t\t\tquery.append(_FINDER_COLUMN_AEI_T_A_ACTIVE_2);\n\n\t\t\t\tString sql = query.toString();\n\n\t\t\t\tQuery q = session.createQuery(sql);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(assetEntryId);\n\n\t\t\t\tqPos.add(type);\n\n\t\t\t\tqPos.add(active);\n\n\t\t\t\tcount = (Long)q.uniqueResult();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (count == null) {\n\t\t\t\t\tcount = Long.valueOf(0);\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(FINDER_PATH_COUNT_BY_AEI_T_A,\n\t\t\t\t\tfinderArgs, count);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn count.intValue();\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialEquityLog findByAEI_A_Last(long assetEntryId, boolean active,\n\t\tOrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tint count = countByAEI_A(assetEntryId, active);\n\n\t\tList<SocialEquityLog> list = findByAEI_A(assetEntryId, active,\n\t\t\t\tcount - 1, count, orderByComparator);\n\n\t\tif (list.isEmpty()) {\n\t\t\tStringBundler msg = new StringBundler(6);\n\n\t\t\tmsg.append(_NO_SUCH_ENTITY_WITH_KEY);\n\n\t\t\tmsg.append(\"assetEntryId=\");\n\t\t\tmsg.append(assetEntryId);\n\n\t\t\tmsg.append(\", active=\");\n\t\t\tmsg.append(active);\n\n\t\t\tmsg.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tthrow new NoSuchEquityLogException(msg.toString());\n\t\t}\n\t\telse {\n\t\t\treturn list.get(0);\n\t\t}\n\t}","id":66870,"modified_method":"public SocialEquityLog findByAEI_T_A_Last(long assetEntryId, int type,\n\t\tboolean active, OrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tint count = countByAEI_T_A(assetEntryId, type, active);\n\n\t\tList<SocialEquityLog> list = findByAEI_T_A(assetEntryId, type, active,\n\t\t\t\tcount - 1, count, orderByComparator);\n\n\t\tif (list.isEmpty()) {\n\t\t\tStringBundler msg = new StringBundler(8);\n\n\t\t\tmsg.append(_NO_SUCH_ENTITY_WITH_KEY);\n\n\t\t\tmsg.append(\"assetEntryId=\");\n\t\t\tmsg.append(assetEntryId);\n\n\t\t\tmsg.append(\", type=\");\n\t\t\tmsg.append(type);\n\n\t\t\tmsg.append(\", active=\");\n\t\t\tmsg.append(active);\n\n\t\t\tmsg.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tthrow new NoSuchEquityLogException(msg.toString());\n\t\t}\n\t\telse {\n\t\t\treturn list.get(0);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialEquityLog findByAEI_A_First(long assetEntryId, boolean active,\n\t\tOrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tList<SocialEquityLog> list = findByAEI_A(assetEntryId, active, 0, 1,\n\t\t\t\torderByComparator);\n\n\t\tif (list.isEmpty()) {\n\t\t\tStringBundler msg = new StringBundler(6);\n\n\t\t\tmsg.append(_NO_SUCH_ENTITY_WITH_KEY);\n\n\t\t\tmsg.append(\"assetEntryId=\");\n\t\t\tmsg.append(assetEntryId);\n\n\t\t\tmsg.append(\", active=\");\n\t\t\tmsg.append(active);\n\n\t\t\tmsg.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tthrow new NoSuchEquityLogException(msg.toString());\n\t\t}\n\t\telse {\n\t\t\treturn list.get(0);\n\t\t}\n\t}","id":66871,"modified_method":"public SocialEquityLog findByAEI_T_A_First(long assetEntryId, int type,\n\t\tboolean active, OrderByComparator orderByComparator)\n\t\tthrows NoSuchEquityLogException, SystemException {\n\t\tList<SocialEquityLog> list = findByAEI_T_A(assetEntryId, type, active,\n\t\t\t\t0, 1, orderByComparator);\n\n\t\tif (list.isEmpty()) {\n\t\t\tStringBundler msg = new StringBundler(8);\n\n\t\t\tmsg.append(_NO_SUCH_ENTITY_WITH_KEY);\n\n\t\t\tmsg.append(\"assetEntryId=\");\n\t\t\tmsg.append(assetEntryId);\n\n\t\t\tmsg.append(\", type=\");\n\t\t\tmsg.append(type);\n\n\t\t\tmsg.append(\", active=\");\n\t\t\tmsg.append(active);\n\n\t\t\tmsg.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tthrow new NoSuchEquityLogException(msg.toString());\n\t\t}\n\t\telse {\n\t\t\treturn list.get(0);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeByAEI_A(long assetEntryId, boolean active)\n\t\tthrows SystemException {\n\t\tfor (SocialEquityLog socialEquityLog : findByAEI_A(assetEntryId, active)) {\n\t\t\tremove(socialEquityLog);\n\t\t}\n\t}","id":66872,"modified_method":"public void removeByAEI_T_A(long assetEntryId, int type, boolean active)\n\t\tthrows SystemException {\n\t\tfor (SocialEquityLog socialEquityLog : findByAEI_T_A(assetEntryId,\n\t\t\t\ttype, active)) {\n\t\t\tremove(socialEquityLog);\n\t\t}\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removeByAEI_A(long assetEntryId, boolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\tgetPersistence().removeByAEI_A(assetEntryId, active);\n\t}","id":66873,"modified_method":"public static void removeByAEI_T_A(long assetEntryId, int type,\n\t\tboolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\tgetPersistence().removeByAEI_T_A(assetEntryId, type, active);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_A(\n\t\tlong assetEntryId, boolean active, int start, int end,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_A(assetEntryId, active, start, end,\n\t\t\torderByComparator);\n\t}","id":66874,"modified_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_T_A(\n\t\tlong assetEntryId, int type, boolean active, int start, int end,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_T_A(assetEntryId, type, active, start, end,\n\t\t\torderByComparator);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portlet.social.model.SocialEquityLog findByAEI_A_First(\n\t\tlong assetEntryId, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_A_First(assetEntryId, active, orderByComparator);\n\t}","id":66875,"modified_method":"public static com.liferay.portlet.social.model.SocialEquityLog findByAEI_T_A_First(\n\t\tlong assetEntryId, int type, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_T_A_First(assetEntryId, type, active,\n\t\t\torderByComparator);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portlet.social.model.SocialEquityLog[] findByAEI_A_PrevAndNext(\n\t\tlong equityLogId, long assetEntryId, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_A_PrevAndNext(equityLogId, assetEntryId, active,\n\t\t\torderByComparator);\n\t}","id":66876,"modified_method":"public static com.liferay.portlet.social.model.SocialEquityLog[] findByAEI_T_A_PrevAndNext(\n\t\tlong equityLogId, long assetEntryId, int type, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_T_A_PrevAndNext(equityLogId, assetEntryId, type,\n\t\t\tactive, orderByComparator);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portlet.social.model.SocialEquityLog findByAEI_A_Last(\n\t\tlong assetEntryId, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_A_Last(assetEntryId, active, orderByComparator);\n\t}","id":66877,"modified_method":"public static com.liferay.portlet.social.model.SocialEquityLog findByAEI_T_A_Last(\n\t\tlong assetEntryId, int type, boolean active,\n\t\tcom.liferay.portal.kernel.util.OrderByComparator orderByComparator)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.social.NoSuchEquityLogException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_T_A_Last(assetEntryId, type, active,\n\t\t\torderByComparator);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_A(\n\t\tlong assetEntryId, boolean active, int start, int end)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence().findByAEI_A(assetEntryId, active, start, end);\n\t}","id":66878,"modified_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_T_A(\n\t\tlong assetEntryId, int type, boolean active, int start, int end)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence()\n\t\t\t\t   .findByAEI_T_A(assetEntryId, type, active, start, end);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_A(\n\t\tlong assetEntryId, boolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence().findByAEI_A(assetEntryId, active);\n\t}","id":66879,"modified_method":"public static java.util.List<com.liferay.portlet.social.model.SocialEquityLog> findByAEI_T_A(\n\t\tlong assetEntryId, int type, boolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence().findByAEI_T_A(assetEntryId, type, active);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int countByAEI_A(long assetEntryId, boolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence().countByAEI_A(assetEntryId, active);\n\t}","id":66880,"modified_method":"public static int countByAEI_T_A(long assetEntryId, int type, boolean active)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getPersistence().countByAEI_T_A(assetEntryId, type, active);\n\t}","commit_id":"67fe6bebc9777e130af63e451c4007519f9e9597","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_group.getGroupId(), userId);\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\ttitleMap.put(_LOCALE, _TITLE);\n\n\t\t_vocabulary =\n\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\tuserId, _TITLE, titleMap, null, null, serviceContext);\n\n\t\tCompany company = CompanyLocalServiceUtil.getCompany(\n\t\t\t_group.getCompanyId());\n\n\t\t_globalGroup = company.getGroup();\n\n\t\tserviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_globalGroup.getGroupId(), userId);\n\n\t\t_globalVocabulary =\n\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\tuserId, _TITLE, titleMap, null, null, serviceContext);\n\t}","id":66881,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\ttitleMap.put(_LOCALE, _TITLE);\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_group.getGroupId(), TestPropsValues.getUserId());\n\n\t\t_vocabulary = AssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\tTestPropsValues.getUserId(), _TITLE, titleMap, null, null,\n\t\t\tserviceContext);\n\n\t\tCompany company = CompanyLocalServiceUtil.getCompany(\n\t\t\t_group.getCompanyId());\n\n\t\t_companyGroup = company.getGroup();\n\n\t\tserviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_companyGroup.getGroupId(), TestPropsValues.getUserId());\n\n\t\t_companyVocabulary = AssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\tTestPropsValues.getUserId(), _TITLE, titleMap, null, null,\n\t\t\tserviceContext);\n\t}","commit_id":"d01b0555f350040c36309cc71be332eddfd0741b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetUnambiguousVocabularyTitleWithAmbiguity()\n\t\tthrows Exception {\n\n\t\tList<AssetVocabulary> vocabularies = new ArrayList<AssetVocabulary>();\n\n\t\tvocabularies.add(_globalVocabulary);\n\t\tvocabularies.add(_vocabulary);\n\n\t\tString unambiguousGlobalVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _globalVocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertTrue(\n\t\t\tunambiguousGlobalVocabularyTitle.contains(\n\t\t\t\t_globalGroup.getDescriptiveName(_LOCALE)));\n\n\t\tString unambiguousVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _vocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertEquals(_TITLE, unambiguousVocabularyTitle);\n\t}","id":66882,"modified_method":"@Test\n\tpublic void testGetUnambiguousVocabularyTitleWithAmbiguity()\n\t\tthrows Exception {\n\n\t\tList<AssetVocabulary> vocabularies = new ArrayList<AssetVocabulary>();\n\n\t\tvocabularies.add(_companyVocabulary);\n\t\tvocabularies.add(_vocabulary);\n\n\t\tString unambiguousCompanyVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _companyVocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertTrue(\n\t\t\tunambiguousCompanyVocabularyTitle.contains(\n\t\t\t\t_companyGroup.getDescriptiveName(_LOCALE)));\n\n\t\tString unambiguousVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _vocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertEquals(_TITLE, unambiguousVocabularyTitle);\n\t}","commit_id":"d01b0555f350040c36309cc71be332eddfd0741b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetUnambiguousVocabularyTitleWithoutAmbiguity()\n\t\tthrows Exception {\n\n\t\tList<AssetVocabulary> vocabularies = new ArrayList<AssetVocabulary>();\n\n\t\tvocabularies.add(_globalVocabulary);\n\n\t\tString unambiguousGlobalVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _globalVocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertEquals(_TITLE, unambiguousGlobalVocabularyTitle);\n\t}","id":66883,"modified_method":"@Test\n\tpublic void testGetUnambiguousVocabularyTitleWithoutAmbiguity()\n\t\tthrows Exception {\n\n\t\tList<AssetVocabulary> vocabularies = new ArrayList<AssetVocabulary>();\n\n\t\tvocabularies.add(_companyVocabulary);\n\n\t\tString unambiguousCompanyVocabularyTitle =\n\t\t\tAssetVocabularyUtil.getUnambiguousVocabularyTitle(\n\t\t\t\tvocabularies, _companyVocabulary, _group.getGroupId(), _LOCALE);\n\n\t\tAssert.assertEquals(_TITLE, unambiguousCompanyVocabularyTitle);\n\t}","commit_id":"d01b0555f350040c36309cc71be332eddfd0741b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void getRole(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tlong roleId = ParamUtil.getLong(request, \"roleId\");\n\n\t\tGroup group = (Group)request.getAttribute(WebKeys.GROUP);\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong userId = themeDisplay.getUserId();\n\n\t\tRole role = null;\n\n\t\tif (group.isCommunity()) {\n\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tuserId, group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_ADMINISTRATOR, true) ||\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tuserId, group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_OWNER, true)) {\n\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\tlong organizationId = group.getOrganizationId();\n\n\t\t\twhile (organizationId !=\n\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) {\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\tlong organizationGroupId = organizationGroup.getGroupId();\n\n\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tuserId, organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR, true) ||\n\t\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tuserId, organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\tif (roleId > 0) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\torganizationId = organization.getParentOrganizationId();\n\t\t\t}\n\n\t\t\tif (roleId > 0 && role == null) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (roleId > 0) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.ROLE, role);\n\t}","id":66884,"modified_method":"public static void getRole(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(request, \"roleId\");\n\n\t\tRole role = null;\n\n\t\tGroup group = (Group)request.getAttribute(WebKeys.GROUP);\n\n\t\tif (group.isCommunity()) {\n\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_ADMINISTRATOR, true) ||\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_OWNER, true)) {\n\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\tlong organizationId = group.getOrganizationId();\n\n\t\t\twhile (organizationId !=\n\t\t\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) {\n\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\tlong organizationGroupId = organizationGroup.getGroupId();\n\n\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR, true) ||\n\t\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\tif (roleId > 0) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\torganizationId = organization.getParentOrganizationId();\n\t\t\t}\n\n\t\t\tif (roleId > 0 && (role == null)) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (roleId > 0) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.ROLE, role);\n\t}","commit_id":"c77c2fca7f52ea49091182800a6fb0326a499aaa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static ExportImportConfiguration addExportImportConfiguration(\n\t\t\tPortletRequest portletRequest, int configurationType)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong userId = themeDisplay.getUserId();\n\t\tlong groupId = ParamUtil.getLong(portletRequest, \"groupId\");\n\n\t\tMap<String, Serializable> configurationContextMap = null;\n\n\t\tif (configurationType ==\n\t\t\t\tExportImportConfigurationConstants.TYPE_EXPORT_LAYOUT) {\n\n\t\t\tconfigurationContextMap = doCreateConfigurationContextMap(\n\t\t\t\tportletRequest, userId, groupId, true,\n\t\t\t\tExportImportDateUtil.RANGE_ALL);\n\t\t}\n\t\telse {\n\t\t\tconfigurationContextMap = doCreateConfigurationContextMap(\n\t\t\t\tportletRequest, userId, groupId, false,\n\t\t\t\tExportImportDateUtil.RANGE_FROM_LAST_PUBLISH_DATE);\n\t\t}\n\n\t\tString exportImportConfigurationName = ParamUtil.getString(\n\t\t\tportletRequest, \"exportImportConfigurationName\");\n\n\t\tString exportImportConfigurationDescription = ParamUtil.getString(\n\t\t\tportletRequest, \"exportImportConfigurationDescription\");\n\n\t\treturn ExportImportConfigurationLocalServiceUtil.\n\t\t\taddExportImportConfiguration(\n\t\t\t\tuserId, groupId, exportImportConfigurationName,\n\t\t\t\texportImportConfigurationDescription, configurationType,\n\t\t\t\tconfigurationContextMap, new ServiceContext());\n\t}","id":66885,"modified_method":"protected static ExportImportConfiguration addExportImportConfiguration(\n\t\t\tPortletRequest portletRequest, int configurationType)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(portletRequest, \"groupId\");\n\n\t\tMap<String, Serializable> settingsMap = null;\n\n\t\tif (configurationType ==\n\t\t\t\tExportImportConfigurationConstants.TYPE_EXPORT_LAYOUT) {\n\n\t\t\tsettingsMap = buildSettingsMap(\n\t\t\t\tportletRequest, themeDisplay.getUserId(), groupId, true,\n\t\t\t\tExportImportDateUtil.RANGE_ALL);\n\t\t}\n\t\telse {\n\t\t\tsettingsMap = buildSettingsMap(\n\t\t\t\tportletRequest, themeDisplay.getUserId(), groupId, false,\n\t\t\t\tExportImportDateUtil.RANGE_FROM_LAST_PUBLISH_DATE);\n\t\t}\n\n\t\tString exportImportConfigurationName = ParamUtil.getString(\n\t\t\tportletRequest, \"exportImportConfigurationName\");\n\t\tString exportImportConfigurationDescription = ParamUtil.getString(\n\t\t\tportletRequest, \"exportImportConfigurationDescription\");\n\n\t\treturn ExportImportConfigurationLocalServiceUtil.\n\t\t\taddExportImportConfiguration(\n\t\t\t\tthemeDisplay.getUserId(), groupId,\n\t\t\t\texportImportConfigurationName,\n\t\t\t\texportImportConfigurationDescription, configurationType,\n\t\t\t\tsettingsMap, new ServiceContext());\n\t}","commit_id":"f33e2e367a889dc5a29cb672db478508acf83b11","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static Map<String, Serializable> doCreateConfigurationContextMap(\n\t\t\tPortletRequest portletRequest, long userId, long groupId,\n\t\t\tboolean exportConfiguration, String defaultDateRange)\n\t\tthrows Exception {\n\n\t\tboolean privateLayout = true;\n\n\t\tString tabs1 = ParamUtil.getString(portletRequest, \"tabs1\");\n\n\t\tif (tabs1.equals(\"public-pages\")) {\n\t\t\tprivateLayout = false;\n\t\t}\n\t\telse {\n\t\t\tprivateLayout = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"privateLayout\");\n\t\t}\n\n\t\tDateRange dateRange = ExportImportDateUtil.getDateRange(\n\t\t\tportletRequest, groupId, privateLayout, 0, null, defaultDateRange);\n\n\t\tif (exportConfiguration) {\n\t\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\t\tuserId, groupId, privateLayout, null,\n\t\t\t\tportletRequest.getParameterMap(), dateRange.getStartDate(),\n\t\t\t\tdateRange.getEndDate());\n\t\t}\n\n\t\tString scope = ParamUtil.getString(portletRequest, \"scope\");\n\n\t\tif (Validator.isNull(scope)) {\n\t\t\tscope = \"all-pages\";\n\t\t}\n\n\t\tMap<Long, Boolean> layoutIdMap = null;\n\n\t\tif (scope.equals(\"selected-pages\")) {\n\t\t\tlayoutIdMap = ExportImportHelperUtil.getLayoutIdMap(portletRequest);\n\t\t}\n\n\t\tGroup stagingGroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\tGroup liveGroup = stagingGroup.getLiveGroup();\n\n\t\tMap<String, String[]> parameterMap = StagingUtil.getStagingParameters(\n\t\t\tportletRequest);\n\n\t\tif (liveGroup != null) {\n\t\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\t\tuserId, stagingGroup.getGroupId(), liveGroup.getGroupId(),\n\t\t\t\tprivateLayout, layoutIdMap, parameterMap,\n\t\t\t\tdateRange.getStartDate(), dateRange.getEndDate());\n\t\t}\n\n\t\tif (liveGroup == null) {\n\t\t\tparameterMap.put(\n\t\t\t\tPortletDataHandlerKeys.PUBLISH_TO_REMOTE,\n\t\t\t\tnew String[] {Boolean.TRUE.toString()});\n\t\t}\n\n\t\tUnicodeProperties groupTypeSettingsProperties =\n\t\t\tstagingGroup.getTypeSettingsProperties();\n\n\t\tString remoteAddress = ParamUtil.getString(\n\t\t\tportletRequest, \"remoteAddress\",\n\t\t\tgroupTypeSettingsProperties.getProperty(\"remoteAddress\"));\n\n\t\tremoteAddress = StagingUtil.stripProtocolFromRemoteAddress(\n\t\t\tremoteAddress);\n\n\t\tint remotePort = ParamUtil.getInteger(\n\t\t\tportletRequest, \"remotePort\",\n\t\t\tGetterUtil.getInteger(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"remotePort\")));\n\n\t\tString remotePathContext = ParamUtil.getString(\n\t\t\tportletRequest, \"remotePathContext\",\n\t\t\tgroupTypeSettingsProperties.getProperty(\"remotePathContext\"));\n\n\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"secureConnection\",\n\t\t\tGetterUtil.getBoolean(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"secureConnection\")));\n\n\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\tportletRequest, \"remoteGroupId\",\n\t\t\tGetterUtil.getLong(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"remoteGroupId\")));\n\n\t\tboolean remotePrivateLayout = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"remotePrivateLayout\");\n\n\t\tStagingUtil.validateRemote(\n\t\t\tremoteAddress, remotePort, remotePathContext, secureConnection,\n\t\t\tremoteGroupId);\n\n\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\tuserId, groupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\tremoteAddress, remotePort, remotePathContext, secureConnection,\n\t\t\tremoteGroupId, remotePrivateLayout, dateRange.getStartDate(),\n\t\t\tdateRange.getEndDate());\n\t}","id":66886,"modified_method":"protected static Map<String, Serializable> buildSettingsMap(\n\t\t\tPortletRequest portletRequest, long userId, long groupId,\n\t\t\tboolean exportConfiguration, String defaultDateRange)\n\t\tthrows Exception {\n\n\t\tboolean privateLayout = true;\n\n\t\tString tabs1 = ParamUtil.getString(portletRequest, \"tabs1\");\n\n\t\tif (tabs1.equals(\"public-pages\")) {\n\t\t\tprivateLayout = false;\n\t\t}\n\t\telse {\n\t\t\tprivateLayout = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"privateLayout\");\n\t\t}\n\n\t\tDateRange dateRange = ExportImportDateUtil.getDateRange(\n\t\t\tportletRequest, groupId, privateLayout, 0, null, defaultDateRange);\n\n\t\tif (exportConfiguration) {\n\t\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\t\tuserId, groupId, privateLayout, null,\n\t\t\t\tportletRequest.getParameterMap(), dateRange.getStartDate(),\n\t\t\t\tdateRange.getEndDate());\n\t\t}\n\n\t\tString scope = ParamUtil.getString(portletRequest, \"scope\");\n\n\t\tif (Validator.isNull(scope)) {\n\t\t\tscope = \"all-pages\";\n\t\t}\n\n\t\tMap<Long, Boolean> layoutIdMap = null;\n\n\t\tif (scope.equals(\"selected-pages\")) {\n\t\t\tlayoutIdMap = ExportImportHelperUtil.getLayoutIdMap(portletRequest);\n\t\t}\n\n\t\tGroup stagingGroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\tGroup liveGroup = stagingGroup.getLiveGroup();\n\n\t\tMap<String, String[]> parameterMap = StagingUtil.getStagingParameters(\n\t\t\tportletRequest);\n\n\t\tif (liveGroup != null) {\n\t\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\t\tuserId, stagingGroup.getGroupId(), liveGroup.getGroupId(),\n\t\t\t\tprivateLayout, layoutIdMap, parameterMap,\n\t\t\t\tdateRange.getStartDate(), dateRange.getEndDate());\n\t\t}\n\n\t\tif (liveGroup == null) {\n\t\t\tparameterMap.put(\n\t\t\t\tPortletDataHandlerKeys.PUBLISH_TO_REMOTE,\n\t\t\t\tnew String[] {Boolean.TRUE.toString()});\n\t\t}\n\n\t\tUnicodeProperties groupTypeSettingsProperties =\n\t\t\tstagingGroup.getTypeSettingsProperties();\n\n\t\tString remoteAddress = ParamUtil.getString(\n\t\t\tportletRequest, \"remoteAddress\",\n\t\t\tgroupTypeSettingsProperties.getProperty(\"remoteAddress\"));\n\n\t\tremoteAddress = StagingUtil.stripProtocolFromRemoteAddress(\n\t\t\tremoteAddress);\n\n\t\tint remotePort = ParamUtil.getInteger(\n\t\t\tportletRequest, \"remotePort\",\n\t\t\tGetterUtil.getInteger(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"remotePort\")));\n\n\t\tString remotePathContext = ParamUtil.getString(\n\t\t\tportletRequest, \"remotePathContext\",\n\t\t\tgroupTypeSettingsProperties.getProperty(\"remotePathContext\"));\n\n\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"secureConnection\",\n\t\t\tGetterUtil.getBoolean(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"secureConnection\")));\n\n\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\tportletRequest, \"remoteGroupId\",\n\t\t\tGetterUtil.getLong(\n\t\t\t\tgroupTypeSettingsProperties.getProperty(\"remoteGroupId\")));\n\n\t\tboolean remotePrivateLayout = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"remotePrivateLayout\");\n\n\t\tStagingUtil.validateRemote(\n\t\t\tremoteAddress, remotePort, remotePathContext, secureConnection,\n\t\t\tremoteGroupId);\n\n\t\treturn ExportImportConfigurationSettingsMapFactory.buildSettingsMap(\n\t\t\tuserId, groupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\tremoteAddress, remotePort, remotePathContext, secureConnection,\n\t\t\tremoteGroupId, remotePrivateLayout, dateRange.getStartDate(),\n\t\t\tdateRange.getEndDate());\n\t}","commit_id":"f33e2e367a889dc5a29cb672db478508acf83b11","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static User addOrganizationUser(\n\t\t\tOrganization organization, String roleName)\n\t\tthrows Exception {\n\n\t\tUser organizationUser = addUser(organization.getGroupId());\n\n\t\tlong[] userIds = {organizationUser.getUserId()};\n\n\t\tUserLocalServiceUtil.addOrganizationUsers(\n\t\t\torganization.getOrganizationId(), userIds);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), roleName);\n\n\t\tUserGroupRoleLocalServiceUtil.addUserGroupRoles(\n\t\t\tuserIds, organization.getGroupId(), role.getRoleId());\n\n\t\treturn organizationUser;\n\t}","id":66887,"modified_method":"public static User addOrganizationUser(\n\t\t\tOrganization organization, String roleName)\n\t\tthrows Exception {\n\n\t\tUser organizationUser = addUser(organization.getGroupId());\n\n\t\tUserLocalServiceUtil.addOrganizationUser(\n\t\t\torganization.getOrganizationId(), organizationUser.getUserId());\n\n\t\taddUserGroupRole(\n\t\t\torganizationUser.getUserId(), organization.getGroupId(), roleName);\n\n\t\treturn organizationUser;\n\t}","commit_id":"f5eeee80bc95ef9b6f8152538b227f5b0b79effe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_BLOGS_DATA, _enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"blogs-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Entries\n\n\t\t\tList entries = BlogsEntryUtil.findByGroupId(context.getGroupId());\n\n\t\t\tIterator itr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\tBlogsEntry.class, entry.getPrimaryKeyObj());\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBlogsEntry.class, new Long(entry.getEntryId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(entries);\n\n\t\t\tElement el = root.addElement(\"blog-entries\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Stats users\n\n\t\t\tList statsUsers = BlogsStatsUserUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\titr = statsUsers.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsStatsUser statsUser = (BlogsStatsUser)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBlogsStatsUser.class, new Long(\n\t\t\t\t\t\t\tstatsUser.getStatsUserId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(statsUsers);\n\n\t\t\tel = root.addElement(\"blog-stats-users\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66888,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_BLOGS_DATA, _enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"blogs-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Entries\n\n\t\t\tList entries = BlogsEntryUtil.findByGroupId(context.getGroupId());\n\n\t\t\tIterator itr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBlogsEntry.class, new Long(entry.getEntryId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\t\tBlogsEntry.class, entry.getPrimaryKeyObj());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(entries);\n\n\t\t\tElement el = root.addElement(\"blog-entries\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Stats users\n\n\t\t\tList statsUsers = BlogsStatsUserUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\titr = statsUsers.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsStatsUser statsUser = (BlogsStatsUser)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBlogsStatsUser.class, new Long(\n\t\t\t\t\t\t\tstatsUser.getStatsUserId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(statsUsers);\n\n\t\t\tel = root.addElement(\"blog-stats-users\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_BLOGS_DATA, _enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Entries\n\n\t\t\tElement el = root.element(\"blog-entries\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList entries = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\t\tString[] entryNames = context.getTagsEntries(\n\t\t\t\t\tBlogsEntry.class, entry.getPrimaryKeyObj());\n\n\t\t\t\tBlogsEntry existingEntry = BlogsEntryUtil.fetchByPrimaryKey(\n\t\t\t\t\tentry.getPrimaryKey());\n\n\t\t\t\tif ((existingEntry == null) ||\n\t\t\t\t\t(existingEntry.getGroupId() != context.getGroupId())) {\n\n\t\t\t\t\tlong plid = context.getPlid();\n\n\t\t\t\t\tThemeDisplay themeDisplay = null;\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tDate displayDate = entry.getDisplayDate();\n\n\t\t\t\t\tBlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUserId(), plid, entry.getCategoryId(),\n\t\t\t\t\t\tentry.getTitle(), entry.getContent(),\n\t\t\t\t\t\tdisplayDate.getMonth(), displayDate.getDay(),\n\t\t\t\t\t\tdisplayDate.getYear(), displayDate.getHours(),\n\t\t\t\t\t\tdisplayDate.getMinutes(), themeDisplay, entryNames,\n\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tentry.getUserId(), BlogsEntry.class.getName(),\n\t\t\t\t\t\t\tentry.getPrimaryKey(), entryNames);\n\n\t\t\t\t\tBlogsEntryUtil.update(entry, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Stats users\n\n\t\t\tel = root.element(\"blog-stats-users\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList statsUsers = (List) xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = statsUsers.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsStatsUser statsUser = (BlogsStatsUser)itr.next();\n\n\t\t\t\tBlogsStatsUser existingStatsUser =\n\t\t\t\t\tBlogsStatsUserUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tstatsUser.getPrimaryKey());\n\n\t\t\t\tif ((existingStatsUser == null) ||\n\t\t\t\t\t(existingStatsUser.getGroupId() != context.getGroupId())) {\n\n\t\t\t\t\tlong groupId = context.getGroupId();\n\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tBlogsStatsUserLocalServiceUtil.updateStatsUser(\n\t\t\t\t\t\tgroupId, statsUser.getUserId(),\n\t\t\t\t\t\tstatsUser.getLastPostDate());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tBlogsStatsUserUtil.update(statsUser, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66889,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_BLOGS_DATA, _enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Entries\n\n\t\t\tElement el = root.element(\"blog-entries\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList entries = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\t\tString[] tagsEntries = context.getTagsEntries(\n\t\t\t\t\tBlogsEntry.class, entry.getPrimaryKeyObj());\n\n\t\t\t\tBlogsEntry existingEntry = BlogsEntryUtil.fetchByPrimaryKey(\n\t\t\t\t\tentry.getPrimaryKey());\n\n\t\t\t\tif ((existingEntry == null) ||\n\t\t\t\t\t(existingEntry.getGroupId() != context.getGroupId())) {\n\n\t\t\t\t\tlong plid = context.getPlid();\n\n\t\t\t\t\tThemeDisplay themeDisplay = null;\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tDate displayDate = entry.getDisplayDate();\n\n\t\t\t\t\tBlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUserId(), plid, entry.getCategoryId(),\n\t\t\t\t\t\tentry.getTitle(), entry.getContent(),\n\t\t\t\t\t\tdisplayDate.getMonth(), displayDate.getDay(),\n\t\t\t\t\t\tdisplayDate.getYear(), displayDate.getHours(),\n\t\t\t\t\t\tdisplayDate.getMinutes(), themeDisplay, tagsEntries,\n\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tentry.getUserId(), BlogsEntry.class.getName(),\n\t\t\t\t\t\t\tentry.getPrimaryKey(), tagsEntries);\n\n\t\t\t\t\tBlogsEntryUtil.update(entry, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Stats users\n\n\t\t\tel = root.element(\"blog-stats-users\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList statsUsers = (List) xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = statsUsers.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBlogsStatsUser statsUser = (BlogsStatsUser)itr.next();\n\n\t\t\t\tBlogsStatsUser existingStatsUser =\n\t\t\t\t\tBlogsStatsUserUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tstatsUser.getPrimaryKey());\n\n\t\t\t\tif ((existingStatsUser == null) ||\n\t\t\t\t\t(existingStatsUser.getGroupId() != context.getGroupId())) {\n\n\t\t\t\t\tlong groupId = context.getGroupId();\n\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tBlogsStatsUserLocalServiceUtil.updateStatsUser(\n\t\t\t\t\t\tgroupId, statsUser.getUserId(),\n\t\t\t\t\t\tstatsUser.getLastPostDate());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tBlogsStatsUserUtil.update(statsUser, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_BOOKMARKS_DATA,\n\t\t\t_enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Folders\n\n\t\t\tElement el = root.element(\"bookmark-folders\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap folderPKs = CollectionFactory.getHashMap();\n\n\t\t\tList folders = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksFolder folder = (BookmarksFolder)itr.next();\n\n\t\t\t\timportFolder(context, folderPKs, folder);\n\t\t\t}\n\n\t\t\t// Entries\n\n\t\t\tel = root.element(\"bookmark-entries\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList entries = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksEntry entry = (BookmarksEntry)itr.next();\n\n\t\t\t\timportEntry(folderPKs, entry);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66890,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_BOOKMARKS_DATA,\n\t\t\t_enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Folders\n\n\t\t\tElement el = root.element(\"bookmark-folders\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap folderPKs = CollectionFactory.getHashMap();\n\n\t\t\tList folders = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksFolder folder = (BookmarksFolder)itr.next();\n\n\t\t\t\timportFolder(context, folderPKs, folder);\n\t\t\t}\n\n\t\t\t// Entries\n\n\t\t\tel = root.element(\"bookmark-entries\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList entries = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksEntry entry = (BookmarksEntry)itr.next();\n\n\t\t\t\timportEntry(context, folderPKs, entry);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importEntry(Map folderPKs, BookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tLong folderId = (Long)folderPKs.get(new Long(entry.getFolderId()));\n\n\t\tboolean newParentFolder = false;\n\n\t\tif (folderId == null) {\n\t\t\tfolderId = new Long(entry.getFolderId());\n\t\t}\n\t\telse {\n\t\t\tnewParentFolder = true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (folderId.longValue() !=\n\t\t\t\t\tBookmarksFolderImpl.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\tBookmarksFolderUtil.findByPrimaryKey(folderId.longValue());\n\t\t\t}\n\n\t\t\tif ((BookmarksEntryUtil.fetchByPrimaryKey(\n\t\t\t\t\tentry.getPrimaryKey()) == null) ||\n\t\t\t\tnewParentFolder) {\n\n\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tentry.getUserId(), folderId.longValue(), entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), new String[0],\n\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tentry.setFolderId(folderId.longValue());\n\n\t\t\t\tBookmarksEntryUtil.update(entry, true);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","id":66891,"modified_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map folderPKs, BookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tString[] tagsEntries = context.getTagsEntries(\n\t\t\tBookmarksEntry.class, entry.getPrimaryKeyObj());\n\n\t\tLong folderId = (Long)folderPKs.get(new Long(entry.getFolderId()));\n\n\t\tboolean newParentFolder = false;\n\n\t\tif (folderId == null) {\n\t\t\tfolderId = new Long(entry.getFolderId());\n\t\t}\n\t\telse {\n\t\t\tnewParentFolder = true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (folderId.longValue() !=\n\t\t\t\t\tBookmarksFolderImpl.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\tBookmarksFolderUtil.findByPrimaryKey(folderId.longValue());\n\t\t\t}\n\n\t\t\tif ((BookmarksEntryUtil.fetchByPrimaryKey(\n\t\t\t\t\tentry.getPrimaryKey()) == null) ||\n\t\t\t\tnewParentFolder) {\n\n\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tentry.getUserId(), folderId.longValue(), entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), tagsEntries,\n\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\t\tentry.getUserId(), BookmarksEntry.class.getName(),\n\t\t\t\t\tentry.getPrimaryKey(), tagsEntries);\n\n\t\t\t\tentry.setFolderId(folderId.longValue());\n\n\t\t\t\tBookmarksEntryUtil.update(entry, true);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_BOOKMARKS_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"bookmarks-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Folders\n\n\t\t\tList folders = BookmarksFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tList entries = new ArrayList();\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksFolder folder = (BookmarksFolder)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBookmarksFolder.class,\n\t\t\t\t\t\tnew Long(folder.getFolderId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList folderEntries = BookmarksEntryUtil.findByFolderId(\n\t\t\t\t\t\tfolder.getFolderId());\n\n\t\t\t\t\tentries.addAll(folderEntries);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(folders);\n\n\t\t\tElement el = root.addElement(\"bookmark-folders\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Entries\n\n\t\t\titr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksEntry entry = (BookmarksEntry)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBookmarksEntry.class, new Long(entry.getEntryId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(entries);\n\n\t\t\tel = root.addElement(\"bookmark-entries\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66892,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_BOOKMARKS_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"bookmarks-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Folders\n\n\t\t\tList folders = BookmarksFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tList entries = new ArrayList();\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksFolder folder = (BookmarksFolder)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBookmarksFolder.class,\n\t\t\t\t\t\tnew Long(folder.getFolderId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList folderEntries = BookmarksEntryUtil.findByFolderId(\n\t\t\t\t\t\tfolder.getFolderId());\n\n\t\t\t\t\tentries.addAll(folderEntries);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(folders);\n\n\t\t\tElement el = root.addElement(\"bookmark-folders\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Entries\n\n\t\t\titr = entries.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tBookmarksEntry entry = (BookmarksEntry)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tBookmarksEntry.class, new Long(entry.getEntryId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\t\tBookmarksEntry.class, entry.getPrimaryKeyObj());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(entries);\n\n\t\t\tel = root.addElement(\"bookmark-entries\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_IG_DATA, _enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Folders\n\n\t\t\tElement el = root.element(\"ig-folders\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap folderPKs = CollectionFactory.getHashMap();\n\n\t\t\tList folders = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGFolder folder = (IGFolder)itr.next();\n\n\t\t\t\timportFolder(context, folderPKs, folder);\n\t\t\t}\n\n\t\t\t// Images\n\n\t\t\tel = root.element(\"images\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap imagesPKs = CollectionFactory.getHashMap();\n\n\t\t\tList images = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = images.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tImage image = (Image)itr.next();\n\n\t\t\t\timagesPKs.put(image.getPrimaryKeyObj(), image);\n\t\t\t}\n\n\t\t\t// IGImages\n\n\t\t\tel = root.element(\"ig-images\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList igImages = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = igImages.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGImage igImage = (IGImage)itr.next();\n\n\t\t\t\timportIGImage(folderPKs, imagesPKs, igImage);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66893,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_IG_DATA, _enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Folders\n\n\t\t\tElement el = root.element(\"ig-folders\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap folderPKs = CollectionFactory.getHashMap();\n\n\t\t\tList folders = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGFolder folder = (IGFolder)itr.next();\n\n\t\t\t\timportFolder(context, folderPKs, folder);\n\t\t\t}\n\n\t\t\t// Images\n\n\t\t\tel = root.element(\"images\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap imagesPKs = CollectionFactory.getHashMap();\n\n\t\t\tList images = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = images.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tImage image = (Image)itr.next();\n\n\t\t\t\timagesPKs.put(image.getPrimaryKeyObj(), image);\n\t\t\t}\n\n\t\t\t// IGImages\n\n\t\t\tel = root.element(\"ig-images\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList igImages = (List)xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\titr = igImages.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGImage igImage = (IGImage)itr.next();\n\n\t\t\t\timportIGImage(context, folderPKs, imagesPKs, igImage);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importIGImage(\n\t\t\tMap folderPKs, Map imagesPKs, IGImage igImage)\n\t\tthrows Exception {\n\n\t\tLong folderId = (Long)folderPKs.get(new Long(igImage.getFolderId()));\n\n\t\tboolean newParentFolder = false;\n\n\t\tif (folderId == null) {\n\t\t\tfolderId = new Long(igImage.getFolderId());\n\t\t}\n\t\telse {\n\t\t\tnewParentFolder = true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (folderId.longValue() != IGFolderImpl.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tIGFolderUtil.findByPrimaryKey(folderId.longValue());\n\t\t\t}\n\n\t\t\tif ((IGImageUtil.fetchByPrimaryKey(\n\t\t\t\t\tigImage.getPrimaryKey()) == null) ||\n\t\t\t\tnewParentFolder) {\n\n\t\t\t\tImage image = (Image)imagesPKs.get(\n\t\t\t\t\tnew Long(igImage.getLargeImageId()));\n\n\t\t\t\tif (image != null) {\n\t\t\t\t\tFile file = new File(\n\t\t\t\t\t\tigImage.getDescription() + \".\" + image.getType());\n\n\t\t\t\t\tFileUtil.write(file, image.getTextObj());\n\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\tigImage.getUserId(), folderId.longValue(),\n\t\t\t\t\t\tigImage.getDescription(), file, image.getType(), null,\n\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Could not find image for IG image \" +\n\t\t\t\t\t\t\tigImage.getImageId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tigImage.setFolderId(folderId.longValue());\n\n\t\t\t\tIGImageUtil.update(igImage, true);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for IG image \" +\n\t\t\t\t\tigImage.getImageId());\n\t\t}\n\t}","id":66894,"modified_method":"protected void importIGImage(\n\t\t\tPortletDataContext context, Map folderPKs, Map imagesPKs,\n\t\t\tIGImage igImage)\n\t\tthrows Exception {\n\n\t\tString[] tagsEntries = context.getTagsEntries(\n\t\t\tIGImage.class, igImage.getPrimaryKeyObj());\n\n\t\tLong folderId = (Long)folderPKs.get(new Long(igImage.getFolderId()));\n\n\t\tboolean newParentFolder = false;\n\n\t\tif (folderId == null) {\n\t\t\tfolderId = new Long(igImage.getFolderId());\n\t\t}\n\t\telse {\n\t\t\tnewParentFolder = true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (folderId.longValue() != IGFolderImpl.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tIGFolderUtil.findByPrimaryKey(folderId.longValue());\n\t\t\t}\n\n\t\t\tif ((IGImageUtil.fetchByPrimaryKey(\n\t\t\t\t\tigImage.getPrimaryKey()) == null) ||\n\t\t\t\tnewParentFolder) {\n\n\t\t\t\tImage image = (Image)imagesPKs.get(\n\t\t\t\t\tnew Long(igImage.getLargeImageId()));\n\n\t\t\t\tif (image != null) {\n\t\t\t\t\tFile file = new File(\n\t\t\t\t\t\tigImage.getDescription() + \".\" + image.getType());\n\n\t\t\t\t\tFileUtil.write(file, image.getTextObj());\n\n\t\t\t\t\tboolean addCommunityPermissions = true;\n\t\t\t\t\tboolean addGuestPermissions = true;\n\n\t\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\tigImage.getUserId(), folderId.longValue(),\n\t\t\t\t\t\tigImage.getDescription(), file, image.getType(),\n\t\t\t\t\t    tagsEntries, addCommunityPermissions,\n\t\t\t\t\t    addGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Could not find image for IG image \" +\n\t\t\t\t\t\t\tigImage.getImageId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\t\tigImage.getUserId(), IGImage.class.getName(),\n\t\t\t\t\tigImage.getPrimaryKey(), tagsEntries);\n\n\t\t\t\tigImage.setFolderId(folderId.longValue());\n\n\t\t\t\tIGImageUtil.update(igImage, true);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for IG image \" +\n\t\t\t\t\tigImage.getImageId());\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_IG_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"image-gallery\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Folders\n\n\t\t\tList folders = IGFolderUtil.findByGroupId(context.getGroupId());\n\n\t\t\tList igImages = new ArrayList();\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGFolder folder = (IGFolder)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tIGFolder.class, new Long(folder.getFolderId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList folderIGImages = IGImageUtil.findByFolderId(\n\t\t\t\t\t\tfolder.getFolderId());\n\n\t\t\t\t\tigImages.addAll(folderIGImages);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(folders);\n\n\t\t\tElement el = root.addElement(\"ig-folders\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// IGImages\n\n\t\t\tList images = new ArrayList();\n\n\t\t\titr = igImages.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGImage igImage = (IGImage)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tIGImage.class, new Long(igImage.getImageId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tImage largeImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tigImage.getLargeImageId());\n\n\t\t\t\t\timages.add(largeImage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(igImages);\n\n\t\t\tel = root.addElement(\"ig-images\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Images\n\n\t\t\titr = images.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tImage image = (Image)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tImage.class, new Long(image.getImageId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(images);\n\n\t\t\tel = root.addElement(\"images\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":66895,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_IG_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"image-gallery\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Folders\n\n\t\t\tList folders = IGFolderUtil.findByGroupId(context.getGroupId());\n\n\t\t\tList igImages = new ArrayList();\n\n\t\t\tIterator itr = folders.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGFolder folder = (IGFolder)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tIGFolder.class, new Long(folder.getFolderId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList folderIGImages = IGImageUtil.findByFolderId(\n\t\t\t\t\t\tfolder.getFolderId());\n\n\t\t\t\t\tigImages.addAll(folderIGImages);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(folders);\n\n\t\t\tElement el = root.addElement(\"ig-folders\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// IGImages\n\n\t\t\tList images = new ArrayList();\n\n\t\t\titr = igImages.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIGImage igImage = (IGImage)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tIGImage.class, new Long(igImage.getImageId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tImage largeImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tigImage.getLargeImageId());\n\n\t\t\t\t\timages.add(largeImage);\n\n\t\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\t\tIGImage.class, igImage.getPrimaryKeyObj());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(igImages);\n\n\t\t\tel = root.addElement(\"ig-images\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Images\n\n\t\t\titr = images.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tImage image = (Image)itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tImage.class, new Long(image.getImageId()))) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(images);\n\n\t\t\tel = root.addElement(\"images\");\n\n\t\t\ttempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportTags(PortletDataContext context, Element root) {\n\t\tElement el = root.addElement(\"tags\");\n\n\t\tMap tagsEntries = context.getTagsEntries();\n\n\t\tIterator itr = tagsEntries.keySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tString key = (String)itr.next();\n\n\t\t\tString[] tagsEntry = key.split(StringPool.POUND);\n\n\t\t\tel.addAttribute(\"class-name\", tagsEntry[0]);\n\t\t\tel.addAttribute(\"class-pk\", tagsEntry[1]);\n\t\t\tel.addAttribute(\n\t\t\t\t\"entries\",\n\t\t\t\tStringUtil.merge(\n\t\t\t\t\tcontext.getTagsEntries(tagsEntry[0], tagsEntry[1]), \",\"));\n\t\t}\n\t}","id":66896,"modified_method":"protected void exportTags(PortletDataContext context, Element root) {\n\t\tMap tagsEntries = context.getTagsEntries();\n\n\t\tIterator itr = tagsEntries.keySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement el = root.addElement(\"tags\");\n\n\t\t\tString key = (String)itr.next();\n\t\t\tString[] tagsEntry = key.split(StringPool.POUND);\n\n\t\t\tel.addAttribute(\"class-name\", tagsEntry[0]);\n\t\t\tel.addAttribute(\"class-pk\", tagsEntry[1]);\n\t\t\tel.addAttribute(\n\t\t\t\t\"entries\",\n\t\t\t\tStringUtil.merge(\n\t\t\t\t\tcontext.getTagsEntries(tagsEntry[0], tagsEntry[1]), \",\"));\n\t\t}\n\t}","commit_id":"e6f8dea5321c3b6a48906e2253173a9da8c75a39","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Resource> getResources(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tLinkedHashMap<String, Object> groupParams =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tgroupParams.put(\"usersGroups\", new Long(webDavRequest.getUserId()));\n\n\t\t\tList<Resource> resources = new ArrayList<Resource>();\n\n\t\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\t\twebDavRequest.getCompanyId(), null, null, groupParams,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tResource resource = getResource(group);\n\n\t\t\t\tresources.add(resource);\n\t\t\t}\n\n\t\t\tGroup group = GroupLocalServiceUtil.getUserGroup(\n\t\t\t\twebDavRequest.getCompanyId(), webDavRequest.getUserId());\n\n\t\t\tResource resource = getResource(group);\n\n\t\t\tresources.add(resource);\n\n\t\t\treturn resources;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":66897,"modified_method":"public List<Resource> getResources(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tLinkedHashMap<String, Object> params =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tparams.put(\"userGroup\", webDavRequest.getUserId());\n\t\t\tparams.put(\"usersGroups\", webDavRequest.getUserId());\n\t\t\tparams.put(\"usersOrgs\", webDavRequest.getUserId());\n\n\t\t\tList<Resource> resources = new ArrayList<Resource>();\n\n\t\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\t\twebDavRequest.getCompanyId(), null, null, params,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tResource resource = getResource(group);\n\n\t\t\t\tresources.add(resource);\n\t\t\t}\n\n\t\t\tGroup group = GroupLocalServiceUtil.getUserGroup(\n\t\t\t\twebDavRequest.getCompanyId(), webDavRequest.getUserId());\n\n\t\t\tResource resource = getResource(group);\n\n\t\t\tresources.add(resource);\n\n\t\t\treturn resources;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"242dff293c6eb224db2ebaabc6e807c0df778175","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isValidFriendlyURL(String friendlyURL) {\n\t\tfriendlyURL = friendlyURL.toLowerCase();\n\n\t\tif (PortalInstances.isVirtualHostsIgnorePath(friendlyURL) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup() +\n\t\t\t\t\tStringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPublic() + StringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateUser() +\n\t\t\t\t\tStringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(_PATH_C) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DELEGATE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DISPLAY_CHART) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DOCUMENT) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DTD) ||\n\t\t\tfriendlyURL.startsWith(_PATH_FACEBOOK) ||\n\t\t\tfriendlyURL.startsWith(_PATH_GOOGLE_GADGET) ||\n\t\t\tfriendlyURL.startsWith(_PATH_HTML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_IMAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_LANGUAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_NETVIBES) ||\n\t\t\tfriendlyURL.startsWith(_PATH_PBHS) ||\n\t\t\tfriendlyURL.startsWith(_PATH_POLLER) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SHAREPOINT) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SITEMAP_XML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SOFTWARE_CATALOG) ||\n\t\t\tfriendlyURL.startsWith(_PATH_VTI) ||\n\t\t\tfriendlyURL.startsWith(_PATH_VLS) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WAP) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WIDGET) ||\n\t\t\tfriendlyURL.startsWith(_PATH_XMLRPC)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint code = LayoutImpl.validateFriendlyURL(friendlyURL);\n\n\t\tif ((code > -1) &&\n\t\t\t(code != LayoutFriendlyURLException.ENDS_WITH_SLASH)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":66898,"modified_method":"protected boolean isValidFriendlyURL(String friendlyURL) {\n\t\tfriendlyURL = friendlyURL.toLowerCase();\n\n\t\tif (PortalInstances.isVirtualHostsIgnorePath(friendlyURL) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup() +\n\t\t\t\t\tStringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPublic() + StringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateUser() +\n\t\t\t\t\tStringPool.SLASH) ||\n\t\t\tfriendlyURL.startsWith(_PATH_C) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DELEGATE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DISPLAY_CHART) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DOCUMENTS) ||\n\t\t\tfriendlyURL.startsWith(_PATH_DTD) ||\n\t\t\tfriendlyURL.startsWith(_PATH_FACEBOOK) ||\n\t\t\tfriendlyURL.startsWith(_PATH_GOOGLE_GADGET) ||\n\t\t\tfriendlyURL.startsWith(_PATH_HTML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_IMAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_LANGUAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_NETVIBES) ||\n\t\t\tfriendlyURL.startsWith(_PATH_PBHS) ||\n\t\t\tfriendlyURL.startsWith(_PATH_POLLER) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SHAREPOINT) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SITEMAP_XML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_SOFTWARE_CATALOG) ||\n\t\t\tfriendlyURL.startsWith(_PATH_VTI) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WAP) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WIDGET) ||\n\t\t\tfriendlyURL.startsWith(_PATH_XMLRPC)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint code = LayoutImpl.validateFriendlyURL(friendlyURL);\n\n\t\tif ((code > -1) &&\n\t\t\t(code != LayoutFriendlyURLException.ENDS_WITH_SLASH)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"242dff293c6eb224db2ebaabc6e807c0df778175","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tString fullGroupDN, User user, Properties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userGroupIdKey = null;\n\n\t\tLong userGroupId = null;\n\n\t\tif (PropsValues.LDAP_IMPORT_GROUP_CACHE_ENABLED) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(ldapServerId);\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(companyId);\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(fullGroupDN);\n\n\t\t\tuserGroupIdKey = sb.toString();\n\n\t\t\tuserGroupId = (Long)_userGroupIds.get(userGroupIdKey);\n\t\t}\n\n\t\tif (userGroupId != null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Skipping reimport of full group DN \" + fullGroupDN);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Importing full group DN \" + fullGroupDN);\n\t\t\t}\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with full group DN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tuserGroupId = userGroup.getUserGroupId();\n\n\t\t\tif (PropsValues.LDAP_IMPORT_GROUP_CACHE_ENABLED) {\n\t\t\t\t_userGroupIds.put(userGroupIdKey, userGroupId);\n\t\t\t}\n\t\t}\n\n\t\tif (userGroupId != null) {\n\t\t\tlong userId = user.getUserId();\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Adding \" + userId + \" to group \" + userGroupId);\n\t\t\t}\n\n\t\t\tUserGroupLocalServiceUtil.addUserUserGroups(\n\t\t\t\tuserId, new long[] {userGroupId});\n\t\t}\n\t}","id":66899,"modified_method":"protected void importGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tString fullGroupDN, User user, Properties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userGroupIdKey = null;\n\n\t\tLong userGroupId = null;\n\n\t\tif (PropsValues.LDAP_IMPORT_GROUP_CACHE_ENABLED) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(ldapServerId);\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(companyId);\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(fullGroupDN);\n\n\t\t\tuserGroupIdKey = sb.toString();\n\n\t\t\tuserGroupId = (Long)_userGroupIds.get(userGroupIdKey);\n\t\t}\n\n\t\tif (userGroupId != null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Skipping reimport of full group DN \" + fullGroupDN);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Importing full group DN \" + fullGroupDN);\n\t\t\t}\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with full group DN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tuserGroupId = userGroup.getUserGroupId();\n\n\t\t\tif (PropsValues.LDAP_IMPORT_GROUP_CACHE_ENABLED) {\n\t\t\t\t_userGroupIds.put(userGroupIdKey, userGroupId);\n\t\t\t}\n\t\t}\n\n\t\tif (userGroupId != null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" + userGroupId);\n\t\t\t}\n\n\t\t\tUserGroupLocalServiceUtil.addUserUserGroups(\n\t\t\t\tuser.getUserId(), new long[] {userGroupId});\n\t\t}\n\t}","commit_id":"6995b0956dcec616e76b62e62ae45f0485cbf30e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tlong userId = user.getUserId();\n\n\t\tif (!LDAPSettingsUtil.isExportEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportGroupEnabled(companyId)) {\n\n\t\t\tList<UserGroup> userGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(userId);\n\n\t\t\tUserGroupLocalServiceUtil.clearUserUserGroups(userId);\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\tif (!userGroup.isAddedByLDAPImport()) {\n\n\t\t\t\t\tUserGroupLocalServiceUtil.addUserUserGroups(\n\t\t\t\t\t\tuserId, new long[] {userGroup.getUserGroupId()});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER_ENABLED)) {\n\n\t\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, companyId, user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\tldapServerId, companyId, binding);\n\n\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\tsb.append(\n\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\t\tsb.append(StringPool.EQUAL);\n\t\t\tsb.append(escapeValue(fullUserDN));\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\tbyte[] cookie = new byte[0];\n\n\t\t\twhile (cookie != null) {\n\t\t\t\tList<SearchResult> searchResults =\n\t\t\t\t\tnew ArrayList<SearchResult>();\n\n\t\t\t\tString groupMappingsGroupName = GetterUtil.getString(\n\t\t\t\t\tgroupMappings.getProperty(\"groupName\")).toLowerCase();\n\n\t\t\t\tcookie = PortalLDAPUtil.searchLDAP(\n\t\t\t\t\tcompanyId, ldapContext, cookie, 0, baseDN, sb.toString(),\n\t\t\t\t\tnew String[] {groupMappingsGroupName}, searchResults);\n\n\t\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\t\t\timportGroup(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN, user,\n\t\t\t\t\t\tgroupMappings);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAttribute userGroupAttribute = attributes.get(userMappingsGroup);\n\n\t\t\tif (userGroupAttribute == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupAttribute.size(); i++) {\n\t\t\t\tString fullGroupDN = (String)userGroupAttribute.get(i);\n\n\t\t\t\timportGroup(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN, user,\n\t\t\t\t\tgroupMappings);\n\t\t\t}\n\t\t}\n\t}","id":66900,"modified_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tif (!LDAPSettingsUtil.isExportEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportGroupEnabled(companyId)) {\n\n\t\t\tList<UserGroup> userGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(user.getUserId());\n\n\t\t\tUserGroupLocalServiceUtil.clearUserUserGroups(user.getUserId());\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\tif (!userGroup.isAddedByLDAPImport()) {\n\n\t\t\t\t\tUserGroupLocalServiceUtil.addUserUserGroups(\n\t\t\t\t\t\tuser.getUserId(),\n\t\t\t\t\t\tnew long[] {userGroup.getUserGroupId()});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER_ENABLED)) {\n\n\t\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, companyId, user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\tldapServerId, companyId, binding);\n\n\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\tsb.append(\n\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\t\tsb.append(StringPool.EQUAL);\n\t\t\tsb.append(escapeValue(fullUserDN));\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\tbyte[] cookie = new byte[0];\n\n\t\t\twhile (cookie != null) {\n\t\t\t\tList<SearchResult> searchResults =\n\t\t\t\t\tnew ArrayList<SearchResult>();\n\n\t\t\t\tString groupMappingsGroupName = GetterUtil.getString(\n\t\t\t\t\tgroupMappings.getProperty(\"groupName\")).toLowerCase();\n\n\t\t\t\tcookie = PortalLDAPUtil.searchLDAP(\n\t\t\t\t\tcompanyId, ldapContext, cookie, 0, baseDN, sb.toString(),\n\t\t\t\t\tnew String[] {groupMappingsGroupName}, searchResults);\n\n\t\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\t\t\timportGroup(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN, user,\n\t\t\t\t\t\tgroupMappings);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAttribute userGroupAttribute = attributes.get(userMappingsGroup);\n\n\t\t\tif (userGroupAttribute == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < userGroupAttribute.size(); i++) {\n\t\t\t\tString fullGroupDN = (String)userGroupAttribute.get(i);\n\n\t\t\t\timportGroup(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN, user,\n\t\t\t\t\tgroupMappings);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6995b0956dcec616e76b62e62ae45f0485cbf30e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSubscriptionMBDiscussionWhenUpdatingMBMessage()\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), TestPropsValues.getUserId());\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.addDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\t_group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId(), 0,\n\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID,\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\n\t\tMBDiscussionLocalServiceUtil.subscribeDiscussion(\n\t\t\t_user.getUserId(), _group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.UPDATE);\n\n\t\tMBMessageLocalServiceUtil.updateDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), message.getMessageId(),\n\t\t\tBlogsEntry.class.getName(), blogsEntry.getEntryId(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(1, MailServiceTestUtil.getInboxSize());\n\t}","id":66901,"modified_method":"@Test\n\tpublic void testSubscriptionMBDiscussionWhenUpdatingMBMessage()\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), TestPropsValues.getUserId());\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\tMBMessage message = addDiscussionMessage(serviceContext, blogsEntry);\n\n\t\tMBDiscussionLocalServiceUtil.subscribeDiscussion(\n\t\t\t_user.getUserId(), _group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.UPDATE);\n\n\t\tMBMessageLocalServiceUtil.updateDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), message.getMessageId(),\n\t\t\tBlogsEntry.class.getName(), blogsEntry.getEntryId(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(1, MailServiceTestUtil.getInboxSize());\n\t}","commit_id":"e4591294bc0994f0bceb9e0ecf2b955ca3dd5c78","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSubscriptionMBDiscussionWhenAddingMBMessage()\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), TestPropsValues.getUserId());\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tMBDiscussionLocalServiceUtil.subscribeDiscussion(\n\t\t\t_user.getUserId(), _group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\tMBMessageLocalServiceUtil.addDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\t_group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId(), 0,\n\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID,\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(1, MailServiceTestUtil.getInboxSize());\n\t}","id":66902,"modified_method":"@Test\n\tpublic void testSubscriptionMBDiscussionWhenAddingMBMessage()\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), TestPropsValues.getUserId());\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tMBDiscussionLocalServiceUtil.subscribeDiscussion(\n\t\t\t_user.getUserId(), _group.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tblogsEntry.getEntryId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\taddDiscussionMessage(serviceContext, blogsEntry);\n\n\t\tAssert.assertEquals(1, MailServiceTestUtil.getInboxSize());\n\t}","commit_id":"e4591294bc0994f0bceb9e0ecf2b955ca3dd5c78","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModel() throws Exception {\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroup.getGroupId(), TestPropsValues.getUserId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\treturn MBMessageLocalServiceUtil.addDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tgroup.getGroupId(), BlogsEntry.class.getName(), _entry.getEntryId(),\n\t\t\t0, MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID,\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\t}","id":66903,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModel() throws Exception {\n\t\tMBMessageDisplay messageDisplay =\n\t\t\tMBMessageLocalServiceUtil.getDiscussionMessageDisplay(\n\t\t\t\tTestPropsValues.getUserId(), group.getGroupId(),\n\t\t\t\tBlogsEntry.class.getName(), _entry.getEntryId(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\tMBThread thread =  messageDisplay.getThread();\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroup.getGroupId(), TestPropsValues.getUserId());\n\n\t\tMBTestUtil.populateNotificationsServiceContext(\n\t\t\tserviceContext, Constants.ADD);\n\n\t\treturn MBMessageLocalServiceUtil.addDiscussionMessage(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tgroup.getGroupId(), BlogsEntry.class.getName(), _entry.getEntryId(),\n\t\t\tthread.getThreadId(), MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID,\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(50),\n\t\t\tserviceContext);\n\t}","commit_id":"e4591294bc0994f0bceb9e0ecf2b955ca3dd5c78","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDeleteOrganizationSiteOnlyRemovesSiteRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tGroup organizationSite = GroupLocalServiceUtil.getOrganizationGroup(\n\t\t\tTestPropsValues.getCompanyId(), organization.getOrganizationId());\n\n\t\torganizationSite.setManualMembership(true);\n\n\t\tUser user = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\tlong userId = user.getUserId();\n\t\tRole siteRole = RoleTestUtil.addRole(2);\n\n\t\tlong[] userIds = new long[] {userId};\n\t\tlong[] roleIds = new long[] {siteRole.getRoleId()};\n\n\t\tUserLocalServiceUtil.addOrganizationUsers(\n\t\t\torganization.getOrganizationId(), userIds);\n\n\t\tUserLocalServiceUtil.addGroupUser(\n\t\t\torganizationSite.getGroupId(), userId);\n\n\t\tUserGroupRoleLocalServiceUtil.addUserGroupRoles(\n\t\t\tuserId, organizationSite.getGroupId(), roleIds);\n\n\t\tGroupLocalServiceUtil.deleteGroup(organizationSite);\n\n\t\tAssert.assertEquals(\n\t\t\t1,\n\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRolesCount(\n\t\t\t\tuserId, organizationSite.getGroupId()));\n\t}","id":66904,"modified_method":"@Test\n\tpublic void testDeleteOrganizationSiteOnlyRemovesSiteRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tGroup organizationSite = GroupLocalServiceUtil.getOrganizationGroup(\n\t\t\tTestPropsValues.getCompanyId(), organization.getOrganizationId());\n\n\t\torganizationSite.setManualMembership(true);\n\n\t\tUser user = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\tUserLocalServiceUtil.addGroupUser(\n\t\t\torganizationSite.getGroupId(), user.getUserId());\n\t\tUserLocalServiceUtil.addOrganizationUsers(\n\t\t\torganization.getOrganizationId(), new long[] {user.getUserId()});\n\n\t\tRole siteRole = RoleTestUtil.addRole(2);\n\n\t\tUserGroupRoleLocalServiceUtil.addUserGroupRoles(\n\t\t\tuser.getUserId(), organizationSite.getGroupId(),\n\t\t\tnew long[] {siteRole.getRoleId()});\n\n\t\tGroupLocalServiceUtil.deleteGroup(organizationSite);\n\n\t\tAssert.assertEquals(\n\t\t\t1,\n\t\t\tUserGroupRoleLocalServiceUtil.getUserGroupRolesCount(\n\t\t\t\tuser.getUserId(), organizationSite.getGroupId()));\n\t}","commit_id":"6b65bd02bd936da7220c960fdfc434af999b8138","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Set<EditorMessage> createMessages(SNode rootNode, IOperationContext operationContext, List<SModelEvent> events, boolean wasCheckedOnce) {\n    Set<EditorMessage> messages = new LinkedHashSet<EditorMessage>();\n    // disable for transient models\n    if (rootNode.getModel().getModelDescriptor().isTransient()) {\n      return messages;\n    }\n    List<SReference> yetBadReferences = new ArrayList<SReference>();\n\n    SReference.disableLogging();\n    final ArrayList<ResolveResult> resolveResultArrayList = new ArrayList<ResolveResult>();\n    try {\n      // resolve references\n      Set<SReference> badReferences = collectBadReferences(rootNode);\n      if (!badReferences.isEmpty()) {\n        yetBadReferences = Resolver.resolveReferences(badReferences, operationContext, resolveResultArrayList, false);\n      }\n    } finally {\n      SReference.enableLogging();\n    }\n\n    ThreadUtils.runInUIThreadNoWait(new Runnable() {\n      public void run() {\n        if (resolveResultArrayList.isEmpty()) return;\n\n        ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n          public void run() {\n            for (ResolveResult resolveResult : resolveResultArrayList) {\n              resolveResult.setTarget();\n            }\n          }\n        });\n      }\n    });\n\n    // highlight nodes with errors\n    for (SReference ref : yetBadReferences) {\n      EditorMessage message = createHighlighterMessage(ref.getSourceNode(), \"unresolved reference\");\n      messages.add(message);\n    }\n    return messages;\n  }","id":66905,"modified_method":"public Set<EditorMessage> createMessages(SNode rootNode, IOperationContext operationContext, List<SModelEvent> events, boolean wasCheckedOnce) {\n    Set<EditorMessage> messages = new LinkedHashSet<EditorMessage>();\n    // disable for transient models\n    if (rootNode.getModel().getModelDescriptor().isTransient()) {\n      return messages;\n    }\n    List<SReference> yetBadReferences = new ArrayList<SReference>();\n\n    SReference.disableLogging();\n    final ArrayList<ResolveResult> resolveResultArrayList = new ArrayList<ResolveResult>();\n    try {\n      // resolve references\n      Set<SReference> badReferences = collectBadReferences(rootNode);\n      if (!badReferences.isEmpty()) {\n        yetBadReferences = Resolver.resolveReferences(badReferences, operationContext, resolveResultArrayList, false);\n      }\n    } finally {\n      SReference.enableLogging();\n    }\n\n    ThreadUtils.runInUIThreadNoWait(new Runnable() {\n      public void run() {\n        if (resolveResultArrayList.isEmpty()) return;\n\n        ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n          public void run() {\n            CommandProcessor.getInstance().runUndoTransparentAction(new Runnable() {\n              public void run() {\n                for (ResolveResult resolveResult : resolveResultArrayList) {\n                  resolveResult.setTarget();\n                }\n              }\n            });\n          }\n        });\n      }\n    });\n\n    // highlight nodes with errors\n    for (SReference ref : yetBadReferences) {\n      EditorMessage message = createHighlighterMessage(ref.getSourceNode(), \"unresolved reference\");\n      messages.add(message);\n    }\n    return messages;\n  }","commit_id":"4361bdb1b397496d394f14914aa27f13f48f8098","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<EditorMessage> createMessages(final SNode node, IOperationContext operationContext, List<SModelEvent> events, boolean wasCheckedOnce) {\n    Set<EditorMessage> messages = new LinkedHashSet<EditorMessage>();\n    if (!wasCheckedOnce || hasNonPropertyDramaticalEvent(events)) {\n      if (!TypeChecker.getInstance().isCheckedRoot(node.getContainingRoot())) {\n        try {\n          TypeChecker.getInstance().checkRoot(node.getContainingRoot());\n        } catch (Throwable t) {\n          LOG.error(t);\n          TypeChecker.getInstance().markAsChecked(node.getContainingRoot()); // for not to check again until the node will be changed\n          return messages;\n        }\n      }\n    }\n\n\n    NodeTypesComponent typesComponent = getNodeTypesComponent(node);\n    if (typesComponent != null)  {\n      //non-typesystem checks\n      if (!wasCheckedOnce || hasDramaticalEvent(events)) {\n        try {\n          typesComponent.applyNonTypesystemRulesToRoot(events);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n      }\n\n      // highlight nodes with errors\n      for (Pair<SNode, IErrorReporter> errorNode : typesComponent.getNodesWithErrorStrings()) {\n        MessageStatus status = errorNode.o2.getMessageStatus();\n        String errorString = errorNode.o2.reportError();\n        HighlighterMessage message = createHighlighterMessage(errorNode.o1, \"Semantic \" + status.getPresentation() + \": \" + errorString, errorNode.o2);\n        IntentionProvider intentionProvider = errorNode.o2.getIntentionProvider();\n\n        if (intentionProvider != null && intentionProvider.isExecutedImmediately()) {\n          final QuickFix_Runtime intention = intentionProvider.getQuickFix();\n          if (intention != null) {\n            if (!myOnceExecutedQuickFixes.contains(intention)) {\n              myOnceExecutedQuickFixes.add(intention);\n              ThreadUtils.runInUIThreadNoWait(new Runnable() {\n                public void run() {\n                  ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                    public void run() {\n                      intention.execute(node);\n                    }\n                  });\n                }\n              });\n            }\n          }\n        } else {\n          if (intentionProvider != null) {\n            intentionProvider.setIsError(status == MessageStatus.ERROR);\n          }\n          message.setIntentionProvider(intentionProvider);\n        }\n        messages.add(message);\n      }\n\n    }\n    return messages;\n  }","id":66906,"modified_method":"public Set<EditorMessage> createMessages(final SNode node, IOperationContext operationContext, List<SModelEvent> events, boolean wasCheckedOnce) {\n    Set<EditorMessage> messages = new LinkedHashSet<EditorMessage>();\n    if (!wasCheckedOnce || hasNonPropertyDramaticalEvent(events)) {\n      if (!TypeChecker.getInstance().isCheckedRoot(node.getContainingRoot())) {\n        try {\n          TypeChecker.getInstance().checkRoot(node.getContainingRoot());\n        } catch (Throwable t) {\n          LOG.error(t);\n          TypeChecker.getInstance().markAsChecked(node.getContainingRoot()); // for not to check again until the node will be changed\n          return messages;\n        }\n      }\n    }\n\n\n    NodeTypesComponent typesComponent = getNodeTypesComponent(node);\n    if (typesComponent != null)  {\n      //non-typesystem checks\n      if (!wasCheckedOnce || hasDramaticalEvent(events)) {\n        try {\n          typesComponent.applyNonTypesystemRulesToRoot(events);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n      }\n\n      // highlight nodes with errors\n      for (Pair<SNode, IErrorReporter> errorNode : typesComponent.getNodesWithErrorStrings()) {\n        MessageStatus status = errorNode.o2.getMessageStatus();\n        String errorString = errorNode.o2.reportError();\n        HighlighterMessage message = createHighlighterMessage(errorNode.o1, \"Semantic \" + status.getPresentation() + \": \" + errorString, errorNode.o2);\n        IntentionProvider intentionProvider = errorNode.o2.getIntentionProvider();\n\n        if (intentionProvider != null && intentionProvider.isExecutedImmediately()) {\n          final QuickFix_Runtime intention = intentionProvider.getQuickFix();\n          if (intention != null) {\n            if (!myOnceExecutedQuickFixes.contains(intention)) {\n              myOnceExecutedQuickFixes.add(intention);\n              ThreadUtils.runInUIThreadNoWait(new Runnable() {\n                public void run() {\n                  ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                    public void run() {\n                      CommandProcessor.getInstance().runUndoTransparentAction(new Runnable() {\n                        public void run() {\n                          intention.execute(node);\n                        }\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          }\n        } else {\n          if (intentionProvider != null) {\n            intentionProvider.setIsError(status == MessageStatus.ERROR);\n          }\n          message.setIntentionProvider(intentionProvider);\n        }\n        messages.add(message);\n      }\n\n    }\n    return messages;\n  }","commit_id":"4361bdb1b397496d394f14914aa27f13f48f8098","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public SModel loadModel(final @NotNull SModelDescriptor modelDescriptor) {\n\n    if (!modelDescriptor.getModelFile().isReadOnly()) {\n      final File file = FileSystem.toFile(modelDescriptor.getModelFile());\n\n      File mineFile = new File(file.getPath() + \".mine\");\n\n      if (mineFile.exists()) {\n        FileUtil.copyFile(mineFile, file);\n        ThreadUtils.runInUIThreadNoWait(new Runnable() {\n          public void run() {\n            NodeReadAccessCaster.blockEvents();\n            try {\n              Merger.merge(file);\n            } finally {\n              NodeReadAccessCaster.unblockEvents();\n            }\n\n            ReloadUtils.rebuildProjectPanes();            \n            modelDescriptor.reloadFromDisk();\n          }\n        });\n      }\n\n      if (!file.exists()) {\n        return new SModel(modelDescriptor.getModelUID());\n      }\n    }\n\n    SModel model = ModelPersistence.readModel(modelDescriptor.getModelFile());\n    LOG.assertLog(model.getUID().equals(modelDescriptor.getModelUID()),\n            \"\\nError loading model from file: \\\"\" + modelDescriptor.getModelFile() + \"\\\"\\n\" +\n                    \"expected model UID     : \\\"\" + modelDescriptor.getModelUID() + \"\\\"\\n\" +\n                    \"but was UID            : \\\"\" + model.getUID() + \"\\\"\\n\" +\n                    \"the model will not be available.\\n\" +\n                    \"Make sure that all project's roots and/or the model namespace is correct\");\n    return model;\n  }","id":66907,"modified_method":"@NotNull\n  public SModel loadModel(final @NotNull SModelDescriptor modelDescriptor) {\n\n    if (!modelDescriptor.getModelFile().isReadOnly()) {\n      final File file = FileSystem.toFile(modelDescriptor.getModelFile());\n\n      File mineFile = new File(file.getPath() + \".mine\");\n\n      if (mineFile.exists()) {\n        FileUtil.copyFile(mineFile, file);\n        ThreadUtils.runInUIThreadNoWait(new Runnable() {\n          public void run() {\n            CommandProcessor.instance().executeCommand(new Runnable() {\n              public void run() {\n                NodeReadAccessCaster.blockEvents();\n                try {\n                  Merger.merge(file);\n                } finally {\n                  NodeReadAccessCaster.unblockEvents();\n                }\n\n                ReloadUtils.rebuildProjectPanes();\n                modelDescriptor.reloadFromDisk();\n              }\n            });\n          }\n        });\n      }\n\n      if (!file.exists()) {\n        return new SModel(modelDescriptor.getModelUID());\n      }\n    }\n\n    SModel model = ModelPersistence.readModel(modelDescriptor.getModelFile());\n    LOG.assertLog(model.getUID().equals(modelDescriptor.getModelUID()),\n            \"\\nError loading model from file: \\\"\" + modelDescriptor.getModelFile() + \"\\\"\\n\" +\n                    \"expected model UID     : \\\"\" + modelDescriptor.getModelUID() + \"\\\"\\n\" +\n                    \"but was UID            : \\\"\" + model.getUID() + \"\\\"\\n\" +\n                    \"the model will not be available.\\n\" +\n                    \"Make sure that all project's roots and/or the model namespace is correct\");\n    return model;\n  }","commit_id":"cecca3b522f1bb4a1da99f1dfd5d8da0fa277264","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void showRefactoring(final RefactoringContext refactoringContext) {\n    ThreadUtils.runInUIThreadNoWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            RefactoringView refactorintView = refactoringContext.getCurrentOperationContext().getComponent(RefactoringView.class);\n            RefactoringViewAction okAction = new RefactoringViewAction() {\n              public void performAction(final RefactoringViewItem refactoringViewItem) {\n                new Thread() {\n                  public void run() {\n                    refactoringViewItem.close();\n                    doExecute(refactoringContext);\n                  }\n                }.start();\n              }\n            };\n            List<SModel> modelsToGenerate = getModelsToGenerate(refactoringContext.getRefactoring(), refactoringContext);\n            refactorintView.showRefactoringView(refactoringContext, okAction, refactoringContext.getUsages(), !modelsToGenerate.isEmpty());\n          }\n        });\n      }\n    });\n  }","id":66908,"modified_method":"private void showRefactoring(final RefactoringContext refactoringContext) {\n    ThreadUtils.runInUIThreadNoWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            RefactoringView refactorintView = refactoringContext.getCurrentOperationContext().getComponent(RefactoringView.class);\n            RefactoringViewAction okAction = new RefactoringViewAction() {\n              public void performAction(final RefactoringViewItem refactoringViewItem) {\n                new Thread() {\n                  public void run() {\n                    doExecute(refactoringContext);\n                    SwingUtilities.invokeLater(new Runnable() {\n                      public void run() {\n                        refactoringViewItem.close();\n                      }\n                    });\n                  }\n                }.start();\n              }\n            };\n            List<SModel> modelsToGenerate = getModelsToGenerate(refactoringContext.getRefactoring(), refactoringContext);\n            refactorintView.showRefactoringView(refactoringContext, okAction, refactoringContext.getUsages(), !modelsToGenerate.isEmpty());\n          }\n        });\n      }\n    });\n  }","commit_id":"704209f7973467ebd65dafeaa2743f97f5975fc7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * <p>The default {@link BaseFuture} implementation throws {@code\n     * InterruptedException} if the current thread is interrupted before or during\n     * the call, even if the value is already available.\n     *\n     * @throws InterruptedException  if the current thread was interrupted before\n     *                               or during the call (optional but recommended).\n     * @throws CancellationException {@inheritDoc}\n     */\n    @Override\n    public V get() throws InterruptedException, ExecutionException {\n        return sync.get();\n    }","id":66909,"modified_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * <p>The default {@link BaseFuture} implementation throws {@code\n     * InterruptedException} if the current thread is interrupted before or during\n     * the call, even if the value is already available.\n     *\n     * @throws InterruptedException  if the current thread was interrupted before\n     *                               or during the call (optional but recommended).\n     * @throws CancellationException {@inheritDoc}\n     */\n    @Override\n    public V get() throws InterruptedException, ExecutionException {\n        Transports.assertNotTransportThread(\"Blocking operation\");\n        return sync.get();\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * <p>The default {@link BaseFuture} implementation throws {@code\n     * InterruptedException} if the current thread is interrupted before or during\n     * the call, even if the value is already available.\n     *\n     * @throws InterruptedException  if the current thread was interrupted before\n     *                               or during the call (optional but recommended).\n     * @throws CancellationException {@inheritDoc}\n     */\n    @Override\n    public V get(long timeout, TimeUnit unit) throws InterruptedException,\n            TimeoutException, ExecutionException {\n        return sync.get(unit.toNanos(timeout));\n    }","id":66910,"modified_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * <p>The default {@link BaseFuture} implementation throws {@code\n     * InterruptedException} if the current thread is interrupted before or during\n     * the call, even if the value is already available.\n     *\n     * @throws InterruptedException  if the current thread was interrupted before\n     *                               or during the call (optional but recommended).\n     * @throws CancellationException {@inheritDoc}\n     */\n    @Override\n    public V get(long timeout, TimeUnit unit) throws InterruptedException,\n            TimeoutException, ExecutionException {\n        Transports.assertNotTransportThread(\"Blocking operation\");\n        return sync.get(unit.toNanos(timeout));\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void messageReceived(byte[] data, String action, LocalTransport sourceTransport, Version version, @Nullable final Long sendRequestId) {\n        try {\n            transportServiceAdapter.received(data.length);\n            StreamInput stream = new BytesStreamInput(data, false);\n            stream = CachedStreamInput.cachedHandles(stream);\n            stream.setVersion(version);\n\n            long requestId = stream.readLong();\n            byte status = stream.readByte();\n            boolean isRequest = TransportStatus.isRequest(status);\n\n            if (isRequest) {\n                handleRequest(stream, requestId, sourceTransport, version);\n            } else {\n                final TransportResponseHandler handler = transportServiceAdapter.remove(requestId);\n                // ignore if its null, the adapter logs it\n                if (handler != null) {\n                    if (TransportStatus.isError(status)) {\n                        handlerResponseError(stream, handler);\n                    } else {\n                        handleResponse(stream, sourceTransport, handler);\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            if (sendRequestId != null) {\n                TransportResponseHandler handler = transportServiceAdapter.remove(sendRequestId);\n                if (handler != null) {\n                    handleException(handler, new RemoteTransportException(nodeName(), localAddress, action, e));\n                }\n            } else {\n                logger.warn(\"Failed to receive message for action [\" + action + \"]\", e);\n            }\n        }\n    }","id":66911,"modified_method":"protected void messageReceived(byte[] data, String action, LocalTransport sourceTransport, Version version, @Nullable final Long sendRequestId) {\n        Transports.assertTransportThread();\n        try {\n            transportServiceAdapter.received(data.length);\n            StreamInput stream = new BytesStreamInput(data, false);\n            stream = CachedStreamInput.cachedHandles(stream);\n            stream.setVersion(version);\n\n            long requestId = stream.readLong();\n            byte status = stream.readByte();\n            boolean isRequest = TransportStatus.isRequest(status);\n\n            if (isRequest) {\n                handleRequest(stream, requestId, sourceTransport, version);\n            } else {\n                final TransportResponseHandler handler = transportServiceAdapter.remove(requestId);\n                // ignore if its null, the adapter logs it\n                if (handler != null) {\n                    if (TransportStatus.isError(status)) {\n                        handlerResponseError(stream, handler);\n                    } else {\n                        handleResponse(stream, sourceTransport, handler);\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            if (sendRequestId != null) {\n                TransportResponseHandler handler = transportServiceAdapter.remove(sendRequestId);\n                if (handler != null) {\n                    handleException(handler, new RemoteTransportException(nodeName(), localAddress, action, e));\n                }\n            } else {\n                logger.warn(\"Failed to receive message for action [\" + action + \"]\", e);\n            }\n        }\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public LocalTransport(Settings settings, ThreadPool threadPool, Version version) {\n        super(settings);\n        this.threadPool = threadPool;\n        this.version = version;\n\n        int workerCount = this.settings.getAsInt(TRANSPORT_LOCAL_WORKERS, EsExecutors.boundedNumberOfProcessors(settings));\n        int queueSize = this.settings.getAsInt(TRANSPORT_LOCAL_QUEUE, -1);\n        logger.debug(\"creating [{}] workers, queue_size [{}]\", workerCount, queueSize);\n        this.workers = EsExecutors.newFixed(workerCount, queueSize, EsExecutors.daemonThreadFactory(this.settings, \"local_transport\"));\n    }","id":66912,"modified_method":"@Inject\n    public LocalTransport(Settings settings, ThreadPool threadPool, Version version) {\n        super(settings);\n        this.threadPool = threadPool;\n        this.version = version;\n\n        int workerCount = this.settings.getAsInt(TRANSPORT_LOCAL_WORKERS, EsExecutors.boundedNumberOfProcessors(settings));\n        int queueSize = this.settings.getAsInt(TRANSPORT_LOCAL_QUEUE, -1);\n        logger.debug(\"creating [{}] workers, queue_size [{}]\", workerCount, queueSize);\n        final ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(this.settings, LOCAL_TRANSPORT_THREAD_NAME_PREFIX);\n        this.workers = EsExecutors.newFixed(workerCount, queueSize, threadFactory);\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        Object m = e.getMessage();\n        if (!(m instanceof ChannelBuffer)) {\n            ctx.sendUpstream(e);\n            return;\n        }\n        ChannelBuffer buffer = (ChannelBuffer) m;\n        int size = buffer.getInt(buffer.readerIndex() - 4);\n        transportServiceAdapter.received(size + 6);\n\n        // we have additional bytes to read, outside of the header\n        boolean hasMessageBytesToRead = (size - (NettyHeader.HEADER_SIZE - 6)) != 0;\n\n        int markedReaderIndex = buffer.readerIndex();\n        int expectedIndexReader = markedReaderIndex + size;\n\n        // netty always copies a buffer, either in NioWorker in its read handler, where it copies to a fresh\n        // buffer, or in the cumlation buffer, which is cleaned each time\n        StreamInput streamIn = ChannelBufferStreamInputFactory.create(buffer, size);\n\n        long requestId = buffer.readLong();\n        byte status = buffer.readByte();\n        Version version = Version.fromId(buffer.readInt());\n\n        StreamInput wrappedStream;\n        if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable()) {\n            Compressor compressor = CompressorFactory.compressor(buffer);\n            if (compressor == null) {\n                int maxToRead = Math.min(buffer.readableBytes(), 10);\n                int offset = buffer.readerIndex();\n                StringBuilder sb = new StringBuilder(\"stream marked as compressed, but no compressor found, first [\").append(maxToRead).append(\"] content bytes out of [\").append(buffer.readableBytes()).append(\"] readable bytes with message size [\").append(size).append(\"] \").append(\"] are [\");\n                for (int i = 0; i < maxToRead; i++) {\n                    sb.append(buffer.getByte(offset + i)).append(\",\");\n                }\n                sb.append(\"]\");\n                throw new ElasticsearchIllegalStateException(sb.toString());\n            }\n            wrappedStream = CachedStreamInput.cachedHandlesCompressed(compressor, streamIn);\n        } else {\n            wrappedStream = CachedStreamInput.cachedHandles(streamIn);\n        }\n        wrappedStream.setVersion(version);\n\n        if (TransportStatus.isRequest(status)) {\n            String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);\n            if (buffer.readerIndex() != expectedIndexReader) {\n                if (buffer.readerIndex() < expectedIndexReader) {\n                    logger.warn(\"Message not fully read (request) for [{}] and action [{}], resetting\", requestId, action);\n                } else {\n                    logger.warn(\"Message read past expected size (request) for [{}] and action [{}], resetting\", requestId, action);\n                }\n                buffer.readerIndex(expectedIndexReader);\n            }\n        } else {\n            TransportResponseHandler handler = transportServiceAdapter.remove(requestId);\n            // ignore if its null, the adapter logs it\n            if (handler != null) {\n                if (TransportStatus.isError(status)) {\n                    handlerResponseError(wrappedStream, handler);\n                } else {\n                    handleResponse(ctx.getChannel(), wrappedStream, handler);\n                }\n            } else {\n                // if its null, skip those bytes\n                buffer.readerIndex(markedReaderIndex + size);\n            }\n            if (buffer.readerIndex() != expectedIndexReader) {\n                if (buffer.readerIndex() < expectedIndexReader) {\n                    logger.warn(\"Message not fully read (response) for [{}] handler {}, error [{}], resetting\", requestId, handler, TransportStatus.isError(status));\n                } else {\n                    logger.warn(\"Message read past expected size (response) for [{}] handler {}, error [{}], resetting\", requestId, handler, TransportStatus.isError(status));\n                }\n                buffer.readerIndex(expectedIndexReader);\n            }\n        }\n        wrappedStream.close();\n    }","id":66913,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        Transports.assertTransportThread();\n        Object m = e.getMessage();\n        if (!(m instanceof ChannelBuffer)) {\n            ctx.sendUpstream(e);\n            return;\n        }\n        ChannelBuffer buffer = (ChannelBuffer) m;\n        int size = buffer.getInt(buffer.readerIndex() - 4);\n        transportServiceAdapter.received(size + 6);\n\n        // we have additional bytes to read, outside of the header\n        boolean hasMessageBytesToRead = (size - (NettyHeader.HEADER_SIZE - 6)) != 0;\n\n        int markedReaderIndex = buffer.readerIndex();\n        int expectedIndexReader = markedReaderIndex + size;\n\n        // netty always copies a buffer, either in NioWorker in its read handler, where it copies to a fresh\n        // buffer, or in the cumlation buffer, which is cleaned each time\n        StreamInput streamIn = ChannelBufferStreamInputFactory.create(buffer, size);\n\n        long requestId = buffer.readLong();\n        byte status = buffer.readByte();\n        Version version = Version.fromId(buffer.readInt());\n\n        StreamInput wrappedStream;\n        if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable()) {\n            Compressor compressor = CompressorFactory.compressor(buffer);\n            if (compressor == null) {\n                int maxToRead = Math.min(buffer.readableBytes(), 10);\n                int offset = buffer.readerIndex();\n                StringBuilder sb = new StringBuilder(\"stream marked as compressed, but no compressor found, first [\").append(maxToRead).append(\"] content bytes out of [\").append(buffer.readableBytes()).append(\"] readable bytes with message size [\").append(size).append(\"] \").append(\"] are [\");\n                for (int i = 0; i < maxToRead; i++) {\n                    sb.append(buffer.getByte(offset + i)).append(\",\");\n                }\n                sb.append(\"]\");\n                throw new ElasticsearchIllegalStateException(sb.toString());\n            }\n            wrappedStream = CachedStreamInput.cachedHandlesCompressed(compressor, streamIn);\n        } else {\n            wrappedStream = CachedStreamInput.cachedHandles(streamIn);\n        }\n        wrappedStream.setVersion(version);\n\n        if (TransportStatus.isRequest(status)) {\n            String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);\n            if (buffer.readerIndex() != expectedIndexReader) {\n                if (buffer.readerIndex() < expectedIndexReader) {\n                    logger.warn(\"Message not fully read (request) for [{}] and action [{}], resetting\", requestId, action);\n                } else {\n                    logger.warn(\"Message read past expected size (request) for [{}] and action [{}], resetting\", requestId, action);\n                }\n                buffer.readerIndex(expectedIndexReader);\n            }\n        } else {\n            TransportResponseHandler handler = transportServiceAdapter.remove(requestId);\n            // ignore if its null, the adapter logs it\n            if (handler != null) {\n                if (TransportStatus.isError(status)) {\n                    handlerResponseError(wrappedStream, handler);\n                } else {\n                    handleResponse(ctx.getChannel(), wrappedStream, handler);\n                }\n            } else {\n                // if its null, skip those bytes\n                buffer.readerIndex(markedReaderIndex + size);\n            }\n            if (buffer.readerIndex() != expectedIndexReader) {\n                if (buffer.readerIndex() < expectedIndexReader) {\n                    logger.warn(\"Message not fully read (response) for [{}] handler {}, error [{}], resetting\", requestId, handler, TransportStatus.isError(status));\n                } else {\n                    logger.warn(\"Message read past expected size (response) for [{}] handler {}, error [{}], resetting\", requestId, handler, TransportStatus.isError(status));\n                }\n                buffer.readerIndex(expectedIndexReader);\n            }\n        }\n        wrappedStream.close();\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ClientBootstrap createClientBootstrap() {\n\n        if (blockingClient) {\n            clientBootstrap = new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings, \"transport_client_worker\"))));\n        } else {\n            int bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n            clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"transport_client_boss\")),\n                    bossCount,\n                    new NioWorkerPool(Executors.newCachedThreadPool(daemonThreadFactory(settings, \"transport_client_worker\")), workerCount),\n                    new HashedWheelTimer(daemonThreadFactory(settings, \"transport_client_timer\"))));\n        }\n        clientBootstrap.setPipelineFactory(configureClientChannelPipelineFactory());\n        clientBootstrap.setOption(\"connectTimeoutMillis\", connectTimeout.millis());\n\n        String tcpNoDelay = componentSettings.get(\"tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (!\"default\".equals(tcpNoDelay)) {\n            clientBootstrap.setOption(\"tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n\n        String tcpKeepAlive = componentSettings.get(\"tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (!\"default\".equals(tcpKeepAlive)) {\n            clientBootstrap.setOption(\"keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n\n        ByteSizeValue tcpSendBufferSize = componentSettings.getAsBytesSize(\"tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n\n        ByteSizeValue tcpReceiveBufferSize = componentSettings.getAsBytesSize(\"tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n\n        clientBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n\n        Boolean reuseAddress = componentSettings.getAsBoolean(\"reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        if (reuseAddress != null) {\n            clientBootstrap.setOption(\"reuseAddress\", reuseAddress);\n        }\n\n        return clientBootstrap;\n    }","id":66914,"modified_method":"private ClientBootstrap createClientBootstrap() {\n\n        if (blockingClient) {\n            clientBootstrap = new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX))));\n        } else {\n            int bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n            clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)),\n                    bossCount,\n                    new NioWorkerPool(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX)), workerCount),\n                    new HashedWheelTimer(daemonThreadFactory(settings, \"transport_client_timer\"))));\n        }\n        clientBootstrap.setPipelineFactory(configureClientChannelPipelineFactory());\n        clientBootstrap.setOption(\"connectTimeoutMillis\", connectTimeout.millis());\n\n        String tcpNoDelay = componentSettings.get(\"tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (!\"default\".equals(tcpNoDelay)) {\n            clientBootstrap.setOption(\"tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n\n        String tcpKeepAlive = componentSettings.get(\"tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (!\"default\".equals(tcpKeepAlive)) {\n            clientBootstrap.setOption(\"keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n\n        ByteSizeValue tcpSendBufferSize = componentSettings.getAsBytesSize(\"tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n\n        ByteSizeValue tcpReceiveBufferSize = componentSettings.getAsBytesSize(\"tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n\n        clientBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n\n        Boolean reuseAddress = componentSettings.getAsBoolean(\"reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        if (reuseAddress != null) {\n            clientBootstrap.setOption(\"reuseAddress\", reuseAddress);\n        }\n\n        return clientBootstrap;\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void createServerBootstrap(String name, Settings settings) {\n        boolean blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", this.settings.getAsBoolean(TCP_BLOCKING_SERVER, this.settings.getAsBoolean(TCP_BLOCKING, false)));\n        String port = settings.get(\"port\");\n        String bindHost = settings.get(\"bind_host\");\n        String publishHost = settings.get(\"publish_host\");\n        String tcpNoDelay = settings.get(\"tcp_no_delay\");\n        String tcpKeepAlive = settings.get(\"tcp_keep_alive\");\n        Boolean reuseAddress = settings.getAsBoolean(\"reuse_address\", NetworkUtils.defaultReuseAddress());\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"tcp_send_buffer_size\", TCP_DEFAULT_SEND_BUFFER_SIZE);\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"tcp_receive_buffer_size\", TCP_DEFAULT_RECEIVE_BUFFER_SIZE);\n\n        logger.debug(\"using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                name, workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeRecovery, connectionsPerNodeBulk, connectionsPerNodeReg, connectionsPerNodeState, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n\n        ServerBootstrap serverBootstrap;\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(this.settings, \"transport_server_boss\", name)),\n                    Executors.newCachedThreadPool(daemonThreadFactory(this.settings, \"transport_server_worker\", name))\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(this.settings, \"transport_server_boss\", name)),\n                    Executors.newCachedThreadPool(daemonThreadFactory(this.settings, \"transport_server_worker\", name)),\n                    workerCount));\n        }\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory(name, settings));\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        if (reuseAddress != null) {\n            serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n            serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n        }\n\n        serverBootstraps.put(name, serverBootstrap);\n    }","id":66915,"modified_method":"private void createServerBootstrap(String name, Settings settings) {\n        boolean blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", this.settings.getAsBoolean(TCP_BLOCKING_SERVER, this.settings.getAsBoolean(TCP_BLOCKING, false)));\n        String port = settings.get(\"port\");\n        String bindHost = settings.get(\"bind_host\");\n        String publishHost = settings.get(\"publish_host\");\n        String tcpNoDelay = settings.get(\"tcp_no_delay\");\n        String tcpKeepAlive = settings.get(\"tcp_keep_alive\");\n        Boolean reuseAddress = settings.getAsBoolean(\"reuse_address\", NetworkUtils.defaultReuseAddress());\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"tcp_send_buffer_size\", TCP_DEFAULT_SEND_BUFFER_SIZE);\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"tcp_receive_buffer_size\", TCP_DEFAULT_RECEIVE_BUFFER_SIZE);\n\n        logger.debug(\"using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                name, workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeRecovery, connectionsPerNodeBulk, connectionsPerNodeReg, connectionsPerNodeState, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n\n        final ThreadFactory bossFactory = daemonThreadFactory(this.settings, HTTP_SERVER_BOSS_THREAD_NAME_PREFIX, name);\n        final ThreadFactory workerFactory = daemonThreadFactory(this.settings, HTTP_SERVER_WORKER_THREAD_NAME_PREFIX, name);\n        ServerBootstrap serverBootstrap;\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory)\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory),\n                    workerCount));\n        }\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory(name, settings));\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        if (reuseAddress != null) {\n            serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n            serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n        }\n\n        serverBootstraps.put(name, serverBootstrap);\n    }","commit_id":"fda727e20c0b487791513aa3bacf77a6aa35f32f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected OrderByComparator<WorkflowDefinition> getOrderByComparator() {\n\t\tHttpServletRequest request =\n\t\t\t_workflowDefinitionRequestHelper.getRequest();\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t_workflowDefinitionRequestHelper.getThemeDisplay();\n\n\t\tString orderByCol = ParamUtil.getString(request, \"orderByCol\", \"name\");\n\n\t\tString orderByType = ParamUtil.getString(request, \"orderByType\", \"asc\");\n\n\t\treturn WorkflowDefinitionPortletUtil.\n\t\t\tgetWorkflowDefitionOrderByComparator(\n\t\t\t\tthemeDisplay.getLanguageId(), orderByCol, orderByType);\n\t}","id":66916,"modified_method":"protected OrderByComparator<WorkflowDefinition>\n\t\tgetWorkflowDefinitionOrderByComparator() {\n\n\t\tString orderByCol = ParamUtil.getString(\n\t\t\t_workflowDefinitionRequestHelper.getRequest(), \"orderByCol\",\n\t\t\t\"name\");\n\n\t\tString orderByType = ParamUtil.getString(\n\t\t\t_workflowDefinitionRequestHelper.getRequest(), \"orderByType\",\n\t\t\t\"asc\");\n\n\t\treturn WorkflowDefinitionPortletUtil.\n\t\t\tgetWorkflowDefitionOrderByComparator(\n\t\t\t\torderByCol, orderByType,\n\t\t\t\t_workflowDefinitionRequestHelper.getLocale());\n\t}","commit_id":"9d668af6867bb4df8cd98e027fbd4b8ff06d10ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<WorkflowDefinition> getSearchContainerResults(\n\t\t\tSearchContainer<WorkflowDefinition> searchContainer)\n\t\tthrows PortalException {\n\n\t\tList<WorkflowDefinition> workflowDefinitions =\n\t\t\tWorkflowDefinitionManagerUtil.getWorkflowDefinitions(\n\t\t\t\t_workflowDefinitionRequestHelper.getCompanyId(),\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS, getOrderByComparator());\n\n\t\tWorkflowDefinitionSearchTerms searchTerms =\n\t\t\t(WorkflowDefinitionSearchTerms)searchContainer.getSearchTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\tfilter(workflowDefinitions, searchTerms);\n\t\t}\n\t\telse {\n\t\t\tfilter(\n\t\t\t\tworkflowDefinitions,\n\t\t\t\tStringUtil.toLowerCase(searchTerms.getKeywords()));\n\t\t}\n\n\t\tsearchContainer.setTotal(workflowDefinitions.size());\n\n\t\treturn workflowDefinitions;\n\t}","id":66917,"modified_method":"public List<WorkflowDefinition> getSearchContainerResults(\n\t\t\tSearchContainer<WorkflowDefinition> searchContainer)\n\t\tthrows PortalException {\n\n\t\tList<WorkflowDefinition> workflowDefinitions =\n\t\t\tWorkflowDefinitionManagerUtil.getWorkflowDefinitions(\n\t\t\t\t_workflowDefinitionRequestHelper.getCompanyId(),\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\tgetWorkflowDefinitionOrderByComparator());\n\n\t\tWorkflowDefinitionSearchTerms searchTerms =\n\t\t\t(WorkflowDefinitionSearchTerms)searchContainer.getSearchTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\tworkflowDefinitions = filter(\n\t\t\t\tworkflowDefinitions, searchTerms.getName(),\n\t\t\t\tsearchTerms.getTitle(), searchTerms.isAndOperator());\n\t\t}\n\t\telse {\n\t\t\tworkflowDefinitions = filter(\n\t\t\t\tworkflowDefinitions, searchTerms.getKeywords(),\n\t\t\t\tsearchTerms.getKeywords(), false);\n\t\t}\n\n\t\tsearchContainer.setTotal(workflowDefinitions.size());\n\n\t\treturn workflowDefinitions;\n\t}","commit_id":"9d668af6867bb4df8cd98e027fbd4b8ff06d10ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void filter(\n\t\tList<WorkflowDefinition> workflowDefinitions, String keyword) {\n\n\t\tIterator<WorkflowDefinition> iterator = workflowDefinitions.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tWorkflowDefinition entry = iterator.next();\n\n\t\t\tString name = StringUtil.toLowerCase(entry.getName());\n\t\t\tString title = StringUtil.toLowerCase(entry.getTitle());\n\n\t\t\tif (!name.contains(keyword) && !title.contains(keyword)) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t}","id":66918,"modified_method":"protected List<WorkflowDefinition> filter(\n\t\tList<WorkflowDefinition> workflowDefinitions, String name, String title,\n\t\tboolean andOperator) {\n\n\t\tif (Validator.isNull(name) && Validator.isNull(title)) {\n\t\t\treturn workflowDefinitions;\n\t\t}\n\n\t\tPredicateFilter<WorkflowDefinition> predicateFilter =\n\t\t\tcreatePredicateFilter(name, title, andOperator);\n\n\t\treturn ListUtil.filter(workflowDefinitions, predicateFilter);\n\t}","commit_id":"9d668af6867bb4df8cd98e027fbd4b8ff06d10ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static BaseModelSearchResult<AssetEntry> getAssetEntries(\n\t\t\tAssetEntryQuery assetEntryQuery, Layout layout,\n\t\t\tPortletPreferences portletPreferences, String portletName,\n\t\t\tLocale locale, TimeZone timeZone, long companyId, long scopeGroupId,\n\t\t\tlong userId, Map<String, Serializable> attributes, int start,\n\t\t\tint end)\n\t\tthrows Exception {\n\n\t\tif (isSearchWithIndex(portletName, assetEntryQuery)) {\n\t\t\tlong[] assetCategoryIds = getAssetCategoryIds(portletPreferences);\n\n\t\t\tString[] assetTagNames = getAssetTagNames(portletPreferences);\n\n\t\t\tString keywords = assetEntryQuery.getKeywords();\n\n\t\t\treturn AssetUtil.searchAssetEntries(\n\t\t\t\tassetCategoryIds, assetTagNames, keywords, locale,\n\t\t\t\tassetEntryQuery, companyId, scopeGroupId, layout, timeZone,\n\t\t\t\tuserId, start, end, attributes);\n\t\t}\n\n\t\tint total = _assetEntryService.getEntriesCount(assetEntryQuery);\n\n\t\tassetEntryQuery.setEnd(end);\n\t\tassetEntryQuery.setStart(start);\n\n\t\tList<AssetEntry> results = _assetEntryService.getEntries(\n\t\t\tassetEntryQuery);\n\n\t\treturn new BaseModelSearchResult<>(results, total);\n\t}","id":66919,"modified_method":"public static BaseModelSearchResult<AssetEntry> getAssetEntries(\n\t\t\tAssetEntryQuery assetEntryQuery, Layout layout,\n\t\t\tPortletPreferences portletPreferences, String portletName,\n\t\t\tLocale locale, TimeZone timeZone, long companyId, long scopeGroupId,\n\t\t\tlong userId, Map<String, Serializable> attributes, int start,\n\t\t\tint end)\n\t\tthrows Exception {\n\n\t\tif (isSearchWithIndex(portletName, assetEntryQuery)) {\n\t\t\treturn AssetUtil.searchAssetEntries(\n\t\t\t\tassetEntryQuery, getAssetCategoryIds(portletPreferences),\n\t\t\t\tgetAssetTagNames(portletPreferences), attributes, companyId,\n\t\t\t\tassetEntryQuery.getKeywords(), layout, locale, scopeGroupId,\n\t\t\t\ttimeZone, userId, start, end);\n\t\t}\n\n\t\tint total = _assetEntryService.getEntriesCount(assetEntryQuery);\n\n\t\tassetEntryQuery.setEnd(end);\n\t\tassetEntryQuery.setStart(start);\n\n\t\tList<AssetEntry> results = _assetEntryService.getEntries(\n\t\t\tassetEntryQuery);\n\n\t\treturn new BaseModelSearchResult<>(results, total);\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static BaseModelSearchResult<AssetEntry> searchAssetEntries(\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames, String keywords,\n\t\t\tLocale locale, AssetEntryQuery assetEntryQuery, long companyId,\n\t\t\tlong scopeGroupId, Layout layout, TimeZone timeZone, long userId,\n\t\t\tint start, int end, Map<String, Serializable> attributes)\n\t\tthrows Exception {\n\n\t\tSearchContext searchContext = SearchContextFactory.getInstance(\n\t\t\tassetCategoryIds, assetTagNames, keywords, locale, companyId,\n\t\t\tscopeGroupId, layout, timeZone, userId, attributes);\n\n\t\treturn searchAssetEntries(searchContext, assetEntryQuery, start, end);\n\t}","id":66920,"modified_method":"public static BaseModelSearchResult<AssetEntry> searchAssetEntries(\n\t\t\tAssetEntryQuery assetEntryQuery, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, Map<String, Serializable> attributes,\n\t\t\tlong companyId, String keywords, Layout layout, Locale locale,\n\t\t\tlong scopeGroupId, TimeZone timeZone, long userId, int start,\n\t\t\tint end)\n\t\tthrows Exception {\n\n\t\tSearchContext searchContext = SearchContextFactory.getInstance(\n\t\t\tassetCategoryIds, assetTagNames, attributes, companyId, keywords,\n\t\t\tlayout, locale, scopeGroupId, timeZone, userId);\n\n\t\treturn searchAssetEntries(searchContext, assetEntryQuery, start, end);\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\t_vocabulary = AssetTestUtil.addVocabulary(_group.getGroupId());\n\n\t\t_category = AssetTestUtil.addCategory(\n\t\t\t_group.getGroupId(), _vocabulary.getVocabularyId());\n\n\t\t_tag = AssetTestUtil.addTag(_group.getGroupId());\n\t}","id":66921,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\t_assetVocabulary = AssetTestUtil.addVocabulary(_group.getGroupId());\n\n\t\t_assetCategory = AssetTestUtil.addCategory(\n\t\t\t_group.getGroupId(), _assetVocabulary.getVocabularyId());\n\n\t\t_assetTag = AssetTestUtil.addTag(_group.getGroupId());\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchAssetEntries() throws Exception {\n\t\tlong[] categoryIds = new long[] {_category.getCategoryId()};\n\t\tString[] tagNames = new String[] {_tag.getName()};\n\n\t\tAssetEntryQuery assetEntryQuery = new AssetEntryQuery();\n\n\t\tassetEntryQuery.setGroupIds(new long[] {_group.getGroupId()});\n\n\t\tassertCount(\n\t\t\t0, categoryIds, tagNames, StringPool.BLANK, null, assetEntryQuery,\n\t\t\t_group.getCompanyId(), _group.getGroupId(), null, null,\n\t\t\t_group.getCreatorUserId(), null);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tserviceContext.setAssetCategoryIds(categoryIds);\n\t\tserviceContext.setAssetTagNames(tagNames);\n\n\t\tBlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tStringPool.BLANK, StringPool.BLANK, RandomTestUtil.randomString(),\n\t\t\t1, 1, 1965, 0, 0, true, true, null, StringPool.BLANK, null, null,\n\t\t\tserviceContext);\n\n\t\tassertCount(\n\t\t\t1, categoryIds, tagNames, StringPool.BLANK, null, assetEntryQuery,\n\t\t\t_group.getCompanyId(), _group.getGroupId(), null, null,\n\t\t\t_group.getCreatorUserId(), null);\n\t}","id":66922,"modified_method":"@Test\n\tpublic void testSearchAssetEntries() throws Exception {\n\t\tAssetEntryQuery assetEntryQuery = new AssetEntryQuery();\n\n\t\tassetEntryQuery.setGroupIds(new long[] {_group.getGroupId()});\n\n\t\tlong[] assetCategoryIds = new long[] {_assetCategory.getCategoryId()};\n\t\tString[] assetTagNames = new String[] {_assetTag.getName()};\n\n\t\tassertCount(\n\t\t\t0, assetEntryQuery, assetCategoryIds, assetTagNames, null,\n\t\t\t_group.getCompanyId(), StringPool.BLANK, null, null,\n\t\t\t_group.getGroupId(), null, _group.getCreatorUserId());\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tBlogsEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\tStringPool.BLANK, StringPool.BLANK, RandomTestUtil.randomString(),\n\t\t\t1, 1, 1965, 0, 0, true, true, null, StringPool.BLANK, null, null,\n\t\t\tserviceContext);\n\n\t\tassertCount(\n\t\t\t1, assetEntryQuery, assetCategoryIds, assetTagNames, null,\n\t\t\t_group.getCompanyId(), StringPool.BLANK, null, null,\n\t\t\t_group.getGroupId(), null, _group.getCreatorUserId());\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void assertCount(\n\t\t\tfinal int expectedCount, final long[] assetCategoryIds,\n\t\t\tfinal String[] assetTagNames, final String keywords,\n\t\t\tfinal Locale locale, final AssetEntryQuery assetEntryQuery,\n\t\t\tfinal long companyId, final long scopeGroupId, final Layout layout,\n\t\t\tfinal TimeZone timezone, final long userId,\n\t\t\tfinal Map<String, Serializable> attributes)\n\t\tthrows Exception {\n\n\t\tIdempotentRetryAssert.retryAssert(\n\t\t\t10, TimeUnit.SECONDS, 1, TimeUnit.SECONDS,\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tBaseModelSearchResult<AssetEntry> searchResult =\n\t\t\t\t\t\tAssetUtil.searchAssetEntries(\n\t\t\t\t\t\t\tassetCategoryIds, assetTagNames, keywords, locale,\n\t\t\t\t\t\t\tassetEntryQuery, companyId, scopeGroupId, layout,\n\t\t\t\t\t\t\ttimezone, userId, QueryUtil.ALL_POS,\n\t\t\t\t\t\t\tQueryUtil.ALL_POS, attributes);\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\texpectedCount, searchResult.getLength());\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":66923,"modified_method":"protected void assertCount(\n\t\t\tfinal int expectedCount, final AssetEntryQuery assetEntryQuery,\n\t\t\tfinal long[] assetCategoryIds, final String[] assetTagNames,\n\t\t\tfinal Map<String, Serializable> attributes, final long companyId,\n\t\t\tfinal String keywords, final Layout layout, final Locale locale,\n\t\t\tfinal long scopeGroupId, final TimeZone timezone, final long userId)\n\t\tthrows Exception {\n\n\t\tIdempotentRetryAssert.retryAssert(\n\t\t\t10, TimeUnit.SECONDS, 1, TimeUnit.SECONDS,\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tBaseModelSearchResult<AssetEntry> baseModelSearchResult =\n\t\t\t\t\t\tAssetUtil.searchAssetEntries(\n\t\t\t\t\t\t\tassetEntryQuery, assetCategoryIds, assetTagNames,\n\t\t\t\t\t\t\tattributes, companyId, keywords, layout, locale,\n\t\t\t\t\t\t\tscopeGroupId, timezone, userId, QueryUtil.ALL_POS,\n\t\t\t\t\t\t\tQueryUtil.ALL_POS);\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\texpectedCount, baseModelSearchResult.getLength());\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SearchContext getInstance(\n\t\tlong[] assetCategoryIds, String[] assetTagNames, String keywords,\n\t\tLocale locale, long companyId, long scopeGroupId, Layout layout,\n\t\tTimeZone timeZone, long userId, Map<String, Serializable> attributes) {\n\n\t\tSearchContext searchContext = new SearchContext();\n\n\t\t// Theme display\n\n\t\tsearchContext.setCompanyId(companyId);\n\t\tsearchContext.setGroupIds(new long[] {scopeGroupId});\n\t\tsearchContext.setLayout(layout);\n\t\tsearchContext.setLocale(locale);\n\t\tsearchContext.setTimeZone(timeZone);\n\t\tsearchContext.setUserId(userId);\n\n\t\t// Attributes\n\n\t\tif (attributes != null) {\n\t\t\tsearchContext.setAttributes(attributes);\n\t\t}\n\t\telse {\n\t\t\tsearchContext.setAttributes(new HashMap<String, Serializable>());\n\t\t}\n\n\t\t// Asset\n\n\t\tsearchContext.setAssetCategoryIds(assetCategoryIds);\n\t\tsearchContext.setAssetTagNames(assetTagNames);\n\n\t\t// Keywords\n\n\t\tsearchContext.setKeywords(keywords);\n\n\t\t// Query config\n\n\t\tQueryConfig queryConfig = searchContext.getQueryConfig();\n\n\t\tqueryConfig.setLocale(locale);\n\n\t\treturn searchContext;\n\t}","id":66924,"modified_method":"public static SearchContext getInstance(\n\t\tlong[] assetCategoryIds, String[] assetTagNames,\n\t\tMap<String, Serializable> attributes, long companyId, String keywords,\n\t\tLayout layout, Locale locale, long scopeGroupId, TimeZone timeZone,\n\t\tlong userId) {\n\n\t\tSearchContext searchContext = new SearchContext();\n\n\t\t// Theme display\n\n\t\tsearchContext.setCompanyId(companyId);\n\t\tsearchContext.setGroupIds(new long[] {scopeGroupId});\n\t\tsearchContext.setLayout(layout);\n\t\tsearchContext.setLocale(locale);\n\t\tsearchContext.setTimeZone(timeZone);\n\t\tsearchContext.setUserId(userId);\n\n\t\t// Attributes\n\n\t\tif (attributes != null) {\n\t\t\tsearchContext.setAttributes(attributes);\n\t\t}\n\t\telse {\n\t\t\tsearchContext.setAttributes(new HashMap<String, Serializable>());\n\t\t}\n\n\t\t// Asset\n\n\t\tsearchContext.setAssetCategoryIds(assetCategoryIds);\n\t\tsearchContext.setAssetTagNames(assetTagNames);\n\n\t\t// Keywords\n\n\t\tsearchContext.setKeywords(keywords);\n\n\t\t// Query config\n\n\t\tQueryConfig queryConfig = searchContext.getQueryConfig();\n\n\t\tqueryConfig.setLocale(locale);\n\n\t\treturn searchContext;\n\t}","commit_id":"8d67d65d5493811be6d6be5c91e6a52c5543c4a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<WorkflowHandler<?>> getWorkflowHandlers() {\n\t\tList<WorkflowHandler<?>> workflowHandlers = null;\n\n\t\tif (isControlPanelPortlet()) {\n\t\t\tworkflowHandlers =\n\t\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandlers();\n\t\t}\n\t\telse {\n\t\t\tworkflowHandlers =\n\t\t\t\tWorkflowHandlerRegistryUtil.getScopeableWorkflowHandlers();\n\t\t}\n\n\t\tIterator<WorkflowHandler<?>> itr = workflowHandlers.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tWorkflowHandler<?> workflowHandler = itr.next();\n\n\t\t\tif (!workflowHandler.isVisible()) {\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn workflowHandlers;\n\t}","id":66925,"modified_method":"protected List<WorkflowHandler<?>> getWorkflowHandlers() {\n\t\tList<WorkflowHandler<?>> workflowHandlers = null;\n\n\t\tif (isControlPanelPortlet()) {\n\t\t\tworkflowHandlers =\n\t\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandlers();\n\t\t}\n\t\telse {\n\t\t\tworkflowHandlers =\n\t\t\t\tWorkflowHandlerRegistryUtil.getScopeableWorkflowHandlers();\n\t\t}\n\n\t\tPredicateFilter<WorkflowHandler<?>> predicateFilter =\n\t\t\tnew PredicateFilter<WorkflowHandler<?>>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean filter(WorkflowHandler<?> workflowHandler) {\n\t\t\t\treturn workflowHandler.isVisible();\n\t\t\t}\n\n\t\t};\n\n\t\treturn ListUtil.filter(workflowHandlers, predicateFilter);\n\t}","commit_id":"10630462f1eaa02d475fb01cfe47ee1534d577fb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<WorkflowDefinitionLinkSearchEntry> getSearchContainerResults(\n\t\t\tSearchContainer<WorkflowDefinitionLinkSearchEntry> searchContainer)\n\t\tthrows PortalException {\n\n\t\tWorkflowDefinitionLinkSearchTerms searchTerms =\n\t\t\t(WorkflowDefinitionLinkSearchTerms)searchContainer.getSearchTerms();\n\n\t\tList<WorkflowDefinitionLinkSearchEntry>\n\t\t\tworkflowDefinitionLinkSearchEntries =\n\t\t\t\tcreateWorkflowDefinitionLinkSearchEntryList();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\tfilter(workflowDefinitionLinkSearchEntries, searchTerms);\n\t\t}\n\t\telse {\n\t\t\tfilter(\n\t\t\t\tworkflowDefinitionLinkSearchEntries,\n\t\t\t\tStringUtil.toLowerCase(searchTerms.getKeywords()));\n\t\t}\n\n\t\tsearchContainer.setTotal(workflowDefinitionLinkSearchEntries.size());\n\n\t\tsort(workflowDefinitionLinkSearchEntries);\n\n\t\treturn workflowDefinitionLinkSearchEntries;\n\t}","id":66926,"modified_method":"public List<WorkflowDefinitionLinkSearchEntry> getSearchContainerResults(\n\t\t\tSearchContainer<WorkflowDefinitionLinkSearchEntry> searchContainer)\n\t\tthrows PortalException {\n\n\t\tWorkflowDefinitionLinkSearchTerms searchTerms =\n\t\t\t(WorkflowDefinitionLinkSearchTerms)searchContainer.getSearchTerms();\n\n\t\tList<WorkflowDefinitionLinkSearchEntry>\n\t\t\tworkflowDefinitionLinkSearchEntries =\n\t\t\t\tcreateWorkflowDefinitionLinkSearchEntryList();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\tworkflowDefinitionLinkSearchEntries = filter(\n\t\t\t\tworkflowDefinitionLinkSearchEntries, searchTerms.getResource(),\n\t\t\t\tsearchTerms.getWorkflow(), searchTerms.isAndOperator());\n\t\t}\n\t\telse {\n\t\t\tworkflowDefinitionLinkSearchEntries = filter(\n\t\t\t\tworkflowDefinitionLinkSearchEntries, searchTerms.getKeywords(),\n\t\t\t\tsearchTerms.getKeywords(), false);\n\t\t}\n\n\t\tsearchContainer.setTotal(workflowDefinitionLinkSearchEntries.size());\n\n\t\tComparator<WorkflowDefinitionLinkSearchEntry> orderByComparator =\n\t\t\tgetWorkflowDefinitionLinkOrderByComparator();\n\n\t\tCollections.sort(\n\t\t\tworkflowDefinitionLinkSearchEntries, orderByComparator);\n\n\t\treturn workflowDefinitionLinkSearchEntries;\n\t}","commit_id":"10630462f1eaa02d475fb01cfe47ee1534d577fb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void filter(\n\t\tList<WorkflowDefinitionLinkSearchEntry>\n\t\t\tworkflowDefinitionLinkSearchEntries, String keyword) {\n\n\t\tIterator<WorkflowDefinitionLinkSearchEntry> iterator =\n\t\t\tworkflowDefinitionLinkSearchEntries.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tWorkflowDefinitionLinkSearchEntry entry = iterator.next();\n\n\t\t\tString resource = StringUtil.toLowerCase(entry.getResource());\n\t\t\tString workflowDefinitionName = StringUtil.toLowerCase(\n\t\t\t\tentry.getWorkflowDefinitionLabel());\n\n\t\t\tif (!resource.contains(keyword) &&\n\t\t\t\t!workflowDefinitionName.contains(keyword)) {\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t}","id":66927,"modified_method":"protected List<WorkflowDefinitionLinkSearchEntry> filter(\n\t\tList<WorkflowDefinitionLinkSearchEntry>\n\t\t\tworkflowDefinitionLinkSearchEntries, String resource,\n\t\tString workflowDefinitionLabel, boolean andOperator) {\n\n\t\tif (Validator.isNull(resource) &&\n\t\t\tValidator.isNull(workflowDefinitionLabel)) {\n\n\t\t\treturn workflowDefinitionLinkSearchEntries;\n\t\t}\n\n\t\tPredicateFilter<WorkflowDefinitionLinkSearchEntry> predicateFilter =\n\t\t\tcreatePredicateFilter(\n\t\t\t\tresource, workflowDefinitionLabel, andOperator);\n\n\t\treturn ListUtil.filter(\n\t\t\tworkflowDefinitionLinkSearchEntries, predicateFilter);\n\t}","commit_id":"10630462f1eaa02d475fb01cfe47ee1534d577fb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long getConsumerChangeCount() {\n        long result = -1;\n        try {\n            final ServiceReference[] refs = this.bc.getServiceReferences(PropertyProvider.class.getName(), \"(changeCount=*)\");\n            if ( refs != null && refs.length > 0 ) {\n                result = (Long)refs[0].getProperty(\"changeCount\");\n            }\n        } catch ( final InvalidSyntaxException ignore ) {\n            // ignore\n        }\n        return result;\n    }","id":66928,"modified_method":"protected long getConsumerChangeCount() {\n        long result = -1;\n        try {\n            final Collection<ServiceReference<PropertyProvider>> refs = this.bc.getServiceReferences(PropertyProvider.class, \"(changeCount=*)\");\n            if ( !refs.isEmpty() ) {\n                result = (Long)refs.iterator().next().getProperty(\"changeCount\");\n            }\n        } catch ( final InvalidSyntaxException ignore ) {\n            // ignore\n        }\n        return result;\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"public void cleanup() {\n        final ServiceReference<ResourceResolverFactory> ref = this.bc.getServiceReference(ResourceResolverFactory.class);\n        final ResourceResolverFactory factory = this.bc.getService(ref);\n        ResourceResolver resolver = null;\n        try {\n            resolver = factory.getAdministrativeResourceResolver(null);\n            final Resource rsrc = resolver.getResource(JobManagerConfiguration.DEFAULT_REPOSITORY_PATH);\n            if ( rsrc != null ) {\n                delete(rsrc);\n                resolver.commit();\n            }\n        } catch ( final LoginException le ) {\n            // ignore\n        } catch (final PersistenceException e) {\n            // ignore\n        } finally {\n            if ( resolver != null ) {\n                resolver.close();\n            }\n        }\n        // remove all configurations and clean content\n        try {\n            final org.osgi.service.cm.Configuration[] cfgs = this.configAdmin.listConfigurations(null);\n            if ( cfgs != null ) {\n                for(final org.osgi.service.cm.Configuration c : cfgs) {\n                    try {\n                        c.delete();\n                    } catch (final IOException io) {\n                        // ignore\n                    }\n                }\n            }\n        } catch (final IOException io) {\n            // ignore\n        } catch (final InvalidSyntaxException e) {\n            // ignore\n        }\n        this.sleep(1000);\n    }","id":66929,"modified_method":"public void cleanup() {\n        // clean job area\n        final ServiceReference<ResourceResolverFactory> ref = this.bc.getServiceReference(ResourceResolverFactory.class);\n        final ResourceResolverFactory factory = this.bc.getService(ref);\n        ResourceResolver resolver = null;\n        try {\n            resolver = factory.getAdministrativeResourceResolver(null);\n            final Resource rsrc = resolver.getResource(\"/var/eventing\");\n            if ( rsrc != null ) {\n                delete(rsrc);\n                resolver.commit();\n            }\n        } catch ( final LoginException le ) {\n            // ignore\n        } catch (final PersistenceException e) {\n            // ignore\n        } finally {\n            if ( resolver != null ) {\n                resolver.close();\n            }\n        }\n        // unregister all services\n        for(final ServiceRegistration<?> reg : this.registrations) {\n            reg.unregister();\n        }\n        this.registrations.clear();\n\n        // remove all configurations\n        try {\n            final org.osgi.service.cm.Configuration[] cfgs = this.configAdmin.listConfigurations(null);\n            if ( cfgs != null ) {\n                for(final org.osgi.service.cm.Configuration c : cfgs) {\n                    try {\n                        c.delete();\n                    } catch (final IOException io) {\n                        // ignore\n                    }\n                }\n            }\n        } catch (final IOException io) {\n            // ignore\n        } catch (final InvalidSyntaxException e) {\n            // ignore\n        }\n        this.sleep(1000);\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Helper method to register an event handler\n     */\n    protected ServiceRegistration<EventHandler> registerEventHandler(final String topic,\n            final EventHandler handler) {\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(EventConstants.EVENT_TOPIC, topic);\n        final ServiceRegistration<EventHandler> reg = this.bc.registerService(EventHandler.class,\n                handler, props);\n        return reg;\n    }","id":66930,"modified_method":"/**\n     * Helper method to register an event handler\n     */\n    protected ServiceRegistration<EventHandler> registerEventHandler(final String topic,\n            final EventHandler handler) {\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(EventConstants.EVENT_TOPIC, topic);\n        final ServiceRegistration<EventHandler> reg = this.bc.registerService(EventHandler.class,\n                handler, props);\n        this.registrations.add(reg);\n        return reg;\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Helper method to register a job executor\n     */\n    protected ServiceRegistration<JobExecutor> registerJobExecutor(final String topic,\n            final JobExecutor handler) {\n        long cc = this.getConsumerChangeCount();\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(JobConsumer.PROPERTY_TOPICS, topic);\n        final ServiceRegistration<JobExecutor> reg = this.bc.registerService(JobExecutor.class,\n                handler, props);\n        this.waitConsumerChangeCount(cc + 1);\n        return reg;\n    }","id":66931,"modified_method":"/**\n     * Helper method to register a job executor\n     */\n    protected ServiceRegistration<JobExecutor> registerJobExecutor(final String topic,\n            final JobExecutor handler) {\n        long cc = this.getConsumerChangeCount();\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(JobConsumer.PROPERTY_TOPICS, topic);\n        final ServiceRegistration<JobExecutor> reg = this.bc.registerService(JobExecutor.class,\n                handler, props);\n        this.registrations.add(reg);\n        this.waitConsumerChangeCount(cc + 1);\n        return reg;\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Helper method to register a job consumer\n     */\n    protected ServiceRegistration<JobConsumer> registerJobConsumer(final String topic,\n            final JobConsumer handler) {\n        long cc = this.getConsumerChangeCount();\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(JobConsumer.PROPERTY_TOPICS, topic);\n        final ServiceRegistration<JobConsumer> reg = this.bc.registerService(JobConsumer.class,\n                handler, props);\n        this.waitConsumerChangeCount(cc + 1);\n        return reg;\n    }","id":66932,"modified_method":"/**\n     * Helper method to register a job consumer\n     */\n    protected ServiceRegistration<JobConsumer> registerJobConsumer(final String topic,\n            final JobConsumer handler) {\n        long cc = this.getConsumerChangeCount();\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(JobConsumer.PROPERTY_TOPICS, topic);\n        final ServiceRegistration<JobConsumer> reg = this.bc.registerService(JobConsumer.class,\n                handler, props);\n        this.registrations.add(reg);\n        this.waitConsumerChangeCount(cc + 1);\n        return reg;\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout=DURATION * 4000)\n    public void testDoChaos() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        // setup added, created and finished map\n        // added and finished are filled by notifications\n        // created is filled by the threads starting jobs\n        final Map<String, AtomicLong> added = new HashMap<String, AtomicLong>();\n        final Map<String, AtomicLong> created = new HashMap<String, AtomicLong>();\n        final Map<String, AtomicLong> finished = new HashMap<String, AtomicLong>();\n        final List<String> topics = new ArrayList<String>();\n        for(int i=0;i<NUM_ORDERED_TOPICS;i++) {\n            added.put(ORDERED_TOPICS[i], new AtomicLong());\n            created.put(ORDERED_TOPICS[i], new AtomicLong());\n            finished.put(ORDERED_TOPICS[i], new AtomicLong());\n            topics.add(ORDERED_TOPICS[i]);\n        }\n        for(int i=0;i<NUM_PARALLEL_TOPICS;i++) {\n            added.put(PARALLEL_TOPICS[i], new AtomicLong());\n            created.put(PARALLEL_TOPICS[i], new AtomicLong());\n            finished.put(PARALLEL_TOPICS[i], new AtomicLong());\n            topics.add(PARALLEL_TOPICS[i]);\n        }\n        for(int i=0;i<NUM_ROUND_TOPICS;i++) {\n            added.put(ROUND_TOPICS[i], new AtomicLong());\n            created.put(ROUND_TOPICS[i], new AtomicLong());\n            finished.put(ROUND_TOPICS[i], new AtomicLong());\n            topics.add(ROUND_TOPICS[i]);\n        }\n\n        final List<ServiceRegistration<?>> registrations = new ArrayList<ServiceRegistration<?>>();\n        final List<Thread> threads = new ArrayList<Thread>();\n        final AtomicLong finishedThreads = new AtomicLong();\n\n        final ServiceRegistration<EventHandler> eventHandler = this.registerEventHandler(\"org/apache/sling/event/notification/job/*\",\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        final String topic = (String) event.getProperty(NotificationConstants.NOTIFICATION_PROPERTY_JOB_TOPIC);\n                        if ( NotificationConstants.TOPIC_JOB_FINISHED.equals(event.getTopic())) {\n                            finished.get(topic).incrementAndGet();\n                        } else if ( NotificationConstants.TOPIC_JOB_ADDED.equals(event.getTopic())) {\n                            added.get(topic).incrementAndGet();\n                        }\n                    }\n                });\n        try {\n            // setup job consumers\n            this.setupJobConsumers(registrations);\n\n            // setup job creation tests\n            this.setupJobCreationThreads(threads, jobManager, created, finishedThreads);\n\n            this.setupChaosThreads(threads, finishedThreads);\n\n            System.out.println(\"Starting threads...\");\n            // start threads\n            for(final Thread t : threads) {\n                t.setDaemon(true);\n                t.start();\n            }\n\n            System.out.println(\"Sleeping for \" + DURATION + \" seconds to wait for threads to finish...\");\n            // for sure we can sleep for the duration\n            this.sleep(DURATION * 1000);\n\n            System.out.println(\"Polling for threads to finish...\");\n            // wait until threads are finished\n            while ( finishedThreads.get() < threads.size() ) {\n                this.sleep(100);\n            }\n\n            System.out.println(\"Waiting for job handling to finish...\");\n            final Set<String> allTopics = new HashSet<String>(topics);\n            while ( !allTopics.isEmpty() ) {\n                final Iterator<String> iter = allTopics.iterator();\n                while ( iter.hasNext() ) {\n                    final String topic = iter.next();\n                    if ( finished.get(topic).get() == created.get(topic).get() ) {\n                        iter.remove();\n                    }\n                }\n                this.sleep(100);\n            }\n/* We could try to enable this with Oak again - but right now JR observation handler is too\n * slow.\n            System.out.println(\"Checking notifications...\");\n            for(final String topic : topics) {\n                assertEquals(\"Checking topic \" + topic, created.get(topic).get(), added.get(topic).get());\n            }\n */\n\n        } finally {\n            eventHandler.unregister();\n            for(final ServiceRegistration<?> reg : registrations) {\n                reg.unregister();\n            }\n        }\n\n    }","id":66933,"modified_method":"@Test(timeout=DURATION * 4000)\n    public void testDoChaos() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        // setup added, created and finished map\n        // added and finished are filled by notifications\n        // created is filled by the threads starting jobs\n        final Map<String, AtomicLong> added = new HashMap<String, AtomicLong>();\n        final Map<String, AtomicLong> created = new HashMap<String, AtomicLong>();\n        final Map<String, AtomicLong> finished = new HashMap<String, AtomicLong>();\n        final List<String> topics = new ArrayList<String>();\n        for(int i=0;i<NUM_ORDERED_TOPICS;i++) {\n            added.put(ORDERED_TOPICS[i], new AtomicLong());\n            created.put(ORDERED_TOPICS[i], new AtomicLong());\n            finished.put(ORDERED_TOPICS[i], new AtomicLong());\n            topics.add(ORDERED_TOPICS[i]);\n        }\n        for(int i=0;i<NUM_PARALLEL_TOPICS;i++) {\n            added.put(PARALLEL_TOPICS[i], new AtomicLong());\n            created.put(PARALLEL_TOPICS[i], new AtomicLong());\n            finished.put(PARALLEL_TOPICS[i], new AtomicLong());\n            topics.add(PARALLEL_TOPICS[i]);\n        }\n        for(int i=0;i<NUM_ROUND_TOPICS;i++) {\n            added.put(ROUND_TOPICS[i], new AtomicLong());\n            created.put(ROUND_TOPICS[i], new AtomicLong());\n            finished.put(ROUND_TOPICS[i], new AtomicLong());\n            topics.add(ROUND_TOPICS[i]);\n        }\n\n        final List<Thread> threads = new ArrayList<Thread>();\n        final AtomicLong finishedThreads = new AtomicLong();\n\n        this.registerEventHandler(\"org/apache/sling/event/notification/job/*\",\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        final String topic = (String) event.getProperty(NotificationConstants.NOTIFICATION_PROPERTY_JOB_TOPIC);\n                        if ( NotificationConstants.TOPIC_JOB_FINISHED.equals(event.getTopic())) {\n                            finished.get(topic).incrementAndGet();\n                        } else if ( NotificationConstants.TOPIC_JOB_ADDED.equals(event.getTopic())) {\n                            added.get(topic).incrementAndGet();\n                        }\n                    }\n                });\n\n        // setup job consumers\n        this.setupJobConsumers();\n\n        // setup job creation tests\n        this.setupJobCreationThreads(threads, jobManager, created, finishedThreads);\n\n        this.setupChaosThreads(threads, finishedThreads);\n\n        System.out.println(\"Starting threads...\");\n        // start threads\n        for(final Thread t : threads) {\n            t.setDaemon(true);\n            t.start();\n        }\n\n        System.out.println(\"Sleeping for \" + DURATION + \" seconds to wait for threads to finish...\");\n        // for sure we can sleep for the duration\n        this.sleep(DURATION * 1000);\n\n        System.out.println(\"Polling for threads to finish...\");\n        // wait until threads are finished\n        while ( finishedThreads.get() < threads.size() ) {\n            this.sleep(100);\n        }\n\n        System.out.println(\"Waiting for job handling to finish...\");\n        final Set<String> allTopics = new HashSet<String>(topics);\n        while ( !allTopics.isEmpty() ) {\n            final Iterator<String> iter = allTopics.iterator();\n            while ( iter.hasNext() ) {\n                final String topic = iter.next();\n                if ( finished.get(topic).get() == created.get(topic).get() ) {\n                    iter.remove();\n                }\n            }\n            this.sleep(100);\n        }\n/* We could try to enable this with Oak again - but right now JR observation handler is too\n * slow.\n            System.out.println(\"Checking notifications...\");\n            for(final String topic : topics) {\n                assertEquals(\"Checking topic \" + topic, created.get(topic).get(), added.get(topic).get());\n            }\n */\n\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testFailedClassloading() throws Exception {\n        final AtomicInteger failedJobsCount = new AtomicInteger(0);\n        final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());\n        final ServiceRegistration<JobConsumer> jcReg = this.registerJobConsumer(TOPIC + \"/failed\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        failedJobsCount.incrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        final ServiceRegistration<EventHandler> ehReg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        finishedEvents.add(event);\n                    }\n                });\n        try {\n            final JobManager jobManager = this.getJobManager();\n\n            // dao is an invisible class for the dynamic class loader as it is not public\n            // therefore scheduling this job should fail!\n            final DataObject dao = new DataObject();\n\n            // we start a single job\n            final Map<String, Object> props = new HashMap<String, Object>();\n            props.put(\"dao\", dao);\n\n            final String id = jobManager.addJob(TOPIC + \"/failed\", props).getId();\n\n            // wait until the conditions are met\n            new RetryLoop(new RetryLoop.Condition() {\n\n                @Override\n                public boolean isTrue() throws Exception {\n                    return failedJobsCount.get() == 0\n                            && finishedEvents.size() == 0\n                            && jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1,\n                                    (Map<String, Object>[]) null).size() == 1\n                            && jobManager.getStatistics().getNumberOfQueuedJobs() == 0\n                            && jobManager.getStatistics().getNumberOfActiveJobs() == 0;\n                }\n\n                @Override\n                public String getDescription() {\n                    return \"Waiting for job failure to be recorded. Conditions \" +\n                           \"faildJobsCount=\" + failedJobsCount.get() +\n                           \", finishedEvents=\" + finishedEvents.size() +\n                           \", findJobs= \" + jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1,\n                                   (Map<String, Object>[]) null).size()\n                           +\", queuedJobs=\" + jobManager.getStatistics().getNumberOfQueuedJobs()\n                           +\", activeJobs=\" + jobManager.getStatistics().getNumberOfActiveJobs();\n                }\n            }, CONDITION_TIMEOUT_SECONDS, CONDITION_INTERVAL_MILLIS);\n\n            jobManager.removeJobById(id); // moves the job to the history section\n            assertEquals(0, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1, (Map<String, Object>[])null).size());\n\n            jobManager.removeJobById(id); // removes the job permanently\n        } finally {\n            jcReg.unregister();\n            ehReg.unregister();\n        }\n    }","id":66934,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testFailedClassloading() throws Exception {\n        final AtomicInteger failedJobsCount = new AtomicInteger(0);\n        final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());\n        this.registerJobConsumer(TOPIC + \"/failed\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        failedJobsCount.incrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        finishedEvents.add(event);\n                    }\n                });\n        final JobManager jobManager = this.getJobManager();\n\n        // dao is an invisible class for the dynamic class loader as it is not public\n        // therefore scheduling this job should fail!\n        final DataObject dao = new DataObject();\n\n        // we start a single job\n        final Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"dao\", dao);\n\n        final String id = jobManager.addJob(TOPIC + \"/failed\", props).getId();\n\n        // wait until the conditions are met\n        new RetryLoop(new RetryLoop.Condition() {\n\n            @Override\n            public boolean isTrue() throws Exception {\n                return failedJobsCount.get() == 0\n                        && finishedEvents.size() == 0\n                        && jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1,\n                                (Map<String, Object>[]) null).size() == 1\n                        && jobManager.getStatistics().getNumberOfQueuedJobs() == 0\n                        && jobManager.getStatistics().getNumberOfActiveJobs() == 0;\n            }\n\n            @Override\n            public String getDescription() {\n                return \"Waiting for job failure to be recorded. Conditions \" +\n                       \"faildJobsCount=\" + failedJobsCount.get() +\n                       \", finishedEvents=\" + finishedEvents.size() +\n                       \", findJobs= \" + jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1,\n                               (Map<String, Object>[]) null).size()\n                       +\", queuedJobs=\" + jobManager.getStatistics().getNumberOfQueuedJobs()\n                       +\", activeJobs=\" + jobManager.getStatistics().getNumberOfActiveJobs();\n            }\n        }, CONDITION_TIMEOUT_SECONDS, CONDITION_INTERVAL_MILLIS);\n\n        jobManager.removeJobById(id); // moves the job to the history section\n        assertEquals(0, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"/failed\", -1, (Map<String, Object>[])null).size());\n\n        jobManager.removeJobById(id); // removes the job permanently\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleClassloading() throws Exception {\n        final AtomicInteger processedJobsCount = new AtomicInteger(0);\n        final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());\n        final ServiceRegistration<JobConsumer> jcReg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n                    @Override\n                    public JobResult process(Job job) {\n                        processedJobsCount.incrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        final ServiceRegistration<EventHandler> ehReg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        finishedEvents.add(event);\n                    }\n                });\n        try {\n            final JobManager jobManager = this.getJobManager();\n\n            final List<String> list = new ArrayList<String>();\n            list.add(\"1\");\n            list.add(\"2\");\n\n            final Map<String, String> map = new HashMap<String, String>();\n            map.put(\"a\", \"a1\");\n            map.put(\"b\", \"b2\");\n\n            // we start a single job\n            final Map<String, Object> props = new HashMap<String, Object>();\n            props.put(\"string\", \"Hello\");\n            props.put(\"int\", new Integer(5));\n            props.put(\"long\", new Long(7));\n            props.put(\"list\", list);\n            props.put(\"map\", map);\n\n            final String jobId = jobManager.addJob(TOPIC, props).getId();\n\n            new RetryLoop(Conditions.collectionIsNotEmptyCondition(finishedEvents,\n                    \"Waiting for finishedEvents to have at least one element\"), 5, 50);\n\n            // no jobs queued, none processed and no available\n            new RetryLoop(new RetryLoop.Condition() {\n\n                @Override\n                public String getDescription() {\n                    return \"Waiting for job to be processed. Conditions: queuedJobs=\" + jobManager.getStatistics().getNumberOfQueuedJobs() +\n                            \", jobsCount=\" + processedJobsCount + \", findJobs=\" +\n                            jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[]) null)\n                            .size();\n                }\n\n                @Override\n                public boolean isTrue() throws Exception {\n                    return jobManager.getStatistics().getNumberOfQueuedJobs() == 0\n                            && processedJobsCount.get() == 1\n                            && jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[]) null)\n                                    .size() == 0;\n                }\n            }, CONDITION_TIMEOUT_SECONDS, CONDITION_INTERVAL_MILLIS);\n\n            final String jobTopic = (String)finishedEvents.get(0).getProperty(NotificationConstants.NOTIFICATION_PROPERTY_JOB_TOPIC);\n            assertNotNull(jobTopic);\n            assertEquals(\"Hello\", finishedEvents.get(0).getProperty(\"string\"));\n            assertEquals(new Integer(5), Integer.valueOf(finishedEvents.get(0).getProperty(\"int\").toString()));\n            assertEquals(new Long(7), Long.valueOf(finishedEvents.get(0).getProperty(\"long\").toString()));\n            assertEquals(list, finishedEvents.get(0).getProperty(\"list\"));\n            assertEquals(map, finishedEvents.get(0).getProperty(\"map\"));\n\n            jobManager.removeJobById(jobId);\n        } finally {\n            jcReg.unregister();\n            ehReg.unregister();\n        }\n    }","id":66935,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleClassloading() throws Exception {\n        final AtomicInteger processedJobsCount = new AtomicInteger(0);\n        final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n                    @Override\n                    public JobResult process(Job job) {\n                        processedJobsCount.incrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        finishedEvents.add(event);\n                    }\n                });\n        final JobManager jobManager = this.getJobManager();\n\n        final List<String> list = new ArrayList<String>();\n        list.add(\"1\");\n        list.add(\"2\");\n\n        final Map<String, String> map = new HashMap<String, String>();\n        map.put(\"a\", \"a1\");\n        map.put(\"b\", \"b2\");\n\n        // we start a single job\n        final Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"string\", \"Hello\");\n        props.put(\"int\", new Integer(5));\n        props.put(\"long\", new Long(7));\n        props.put(\"list\", list);\n        props.put(\"map\", map);\n\n        final String jobId = jobManager.addJob(TOPIC, props).getId();\n\n        new RetryLoop(Conditions.collectionIsNotEmptyCondition(finishedEvents,\n                \"Waiting for finishedEvents to have at least one element\"), 5, 50);\n\n        // no jobs queued, none processed and no available\n        new RetryLoop(new RetryLoop.Condition() {\n\n            @Override\n            public String getDescription() {\n                return \"Waiting for job to be processed. Conditions: queuedJobs=\" + jobManager.getStatistics().getNumberOfQueuedJobs() +\n                        \", jobsCount=\" + processedJobsCount + \", findJobs=\" +\n                        jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[]) null)\n                        .size();\n            }\n\n            @Override\n            public boolean isTrue() throws Exception {\n                return jobManager.getStatistics().getNumberOfQueuedJobs() == 0\n                        && processedJobsCount.get() == 1\n                        && jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[]) null)\n                                .size() == 0;\n            }\n        }, CONDITION_TIMEOUT_SECONDS, CONDITION_INTERVAL_MILLIS);\n\n        final String jobTopic = (String)finishedEvents.get(0).getProperty(NotificationConstants.NOTIFICATION_PROPERTY_JOB_TOPIC);\n        assertNotNull(jobTopic);\n        assertEquals(\"Hello\", finishedEvents.get(0).getProperty(\"string\"));\n        assertEquals(new Integer(5), Integer.valueOf(finishedEvents.get(0).getProperty(\"int\").toString()));\n        assertEquals(new Long(7), Long.valueOf(finishedEvents.get(0).getProperty(\"long\").toString()));\n        assertEquals(list, finishedEvents.get(0).getProperty(\"list\"));\n        assertEquals(map, finishedEvents.get(0).getProperty(\"map\"));\n\n        jobManager.removeJobById(jobId);\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test history.\n     * Start 10 jobs and cancel some of them and succeed others\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testHistory() throws Exception {\n        final ServiceRegistration reg = this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        sleep(5L);\n                        final long count = job.getProperty(PROP_COUNTER, Long.class);\n                        if ( count == 2 || count == 5 || count == 7 ) {\n                            return context.result().message(Job.JobState.ERROR.name()).cancelled();\n                        }\n                        return context.result().message(Job.JobState.SUCCEEDED.name()).succeeded();\n                    }\n\n                });\n        Collection<Job> col = null;\n        try {\n            for(int i = 0; i< 10; i++) {\n                this.addJob(i);\n            }\n            this.sleep(200L);\n            while ( this.getJobManager().findJobs(JobManager.QueryType.HISTORY, TOPIC, -1, (Map<String, Object>[])null).size() < 10 ) {\n                this.sleep(20L);\n            }\n            col = this.getJobManager().findJobs(JobManager.QueryType.HISTORY, TOPIC, -1, (Map<String, Object>[])null);\n            assertEquals(10, col.size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.ACTIVE, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.QUEUED, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(3, this.getJobManager().findJobs(JobManager.QueryType.CANCELLED, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.DROPPED, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(3, this.getJobManager().findJobs(JobManager.QueryType.ERROR, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.GIVEN_UP, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.STOPPED, TOPIC, -1, (Map<String, Object>[])null).size());\n            assertEquals(7, this.getJobManager().findJobs(JobManager.QueryType.SUCCEEDED, TOPIC, -1, (Map<String, Object>[])null).size());\n\n            // find all topics\n            assertEquals(7, this.getJobManager().findJobs(JobManager.QueryType.SUCCEEDED, null, -1, (Map<String, Object>[])null).size());\n\n            // verify order, message and state\n            long last = 9;\n            for(final Job j : col) {\n                assertNotNull(j.getFinishedDate());\n                final long count = j.getProperty(PROP_COUNTER, Long.class);\n                assertEquals(last, count);\n                if ( count == 2 || count == 5 || count == 7 ) {\n                    assertEquals(Job.JobState.ERROR, j.getJobState());\n                } else {\n                    assertEquals(Job.JobState.SUCCEEDED, j.getJobState());\n                }\n                assertEquals(j.getJobState().name(), j.getResultMessage());\n                last--;\n            }\n        } finally {\n            if ( col != null ) {\n                for(final Job j : col) {\n                    this.getJobManager().removeJobById(j.getId());\n                }\n            }\n            reg.unregister();\n        }\n    }","id":66936,"modified_method":"/**\n     * Test history.\n     * Start 10 jobs and cancel some of them and succeed others\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testHistory() throws Exception {\n        this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        sleep(5L);\n                        final long count = job.getProperty(PROP_COUNTER, Long.class);\n                        if ( count == 2 || count == 5 || count == 7 ) {\n                            return context.result().message(Job.JobState.ERROR.name()).cancelled();\n                        }\n                        return context.result().message(Job.JobState.SUCCEEDED.name()).succeeded();\n                    }\n\n                });\n        for(int i = 0; i< 10; i++) {\n            this.addJob(i);\n        }\n        this.sleep(200L);\n        while ( this.getJobManager().findJobs(JobManager.QueryType.HISTORY, TOPIC, -1, (Map<String, Object>[])null).size() < 10 ) {\n            this.sleep(20L);\n        }\n        Collection<Job> col = this.getJobManager().findJobs(JobManager.QueryType.HISTORY, TOPIC, -1, (Map<String, Object>[])null);\n        assertEquals(10, col.size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.ACTIVE, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.QUEUED, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.ALL, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(3, this.getJobManager().findJobs(JobManager.QueryType.CANCELLED, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.DROPPED, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(3, this.getJobManager().findJobs(JobManager.QueryType.ERROR, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.GIVEN_UP, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(0, this.getJobManager().findJobs(JobManager.QueryType.STOPPED, TOPIC, -1, (Map<String, Object>[])null).size());\n        assertEquals(7, this.getJobManager().findJobs(JobManager.QueryType.SUCCEEDED, TOPIC, -1, (Map<String, Object>[])null).size());\n\n        // find all topics\n        assertEquals(7, this.getJobManager().findJobs(JobManager.QueryType.SUCCEEDED, null, -1, (Map<String, Object>[])null).size());\n\n        // verify order, message and state\n        long last = 9;\n        for(final Job j : col) {\n            assertNotNull(j.getFinishedDate());\n            final long count = j.getProperty(PROP_COUNTER, Long.class);\n            assertEquals(last, count);\n            if ( count == 2 || count == 5 || count == 7 ) {\n                assertEquals(Job.JobState.ERROR, j.getJobState());\n            } else {\n                assertEquals(Job.JobState.SUCCEEDED, j.getJobState());\n            }\n            assertEquals(j.getJobState().name(), j.getResultMessage());\n            last--;\n        }\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test simple job execution.\n     * The job is executed once and finished successfully.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleJobExecutionUsingJobExecutor() throws Exception {\n        final Barrier cb = new Barrier(2);\n\n        final ServiceRegistration reg = this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        cb.block();\n                        return context.result().succeeded();\n                    }\n                });\n\n        try {\n            this.getJobManager().addJob(TOPIC, null);\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n            assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n        } finally {\n            reg.unregister();\n        }\n    }","id":66937,"modified_method":"/**\n     * Test simple job execution.\n     * The job is executed once and finished successfully.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleJobExecutionUsingJobExecutor() throws Exception {\n        final Barrier cb = new Barrier(2);\n\n        this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        cb.block();\n                        return context.result().succeeded();\n                    }\n                });\n\n        this.getJobManager().addJob(TOPIC, null);\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n        assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test simple job execution.\n     * The job is executed once and finished successfully.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleJobExecutionUsingJobConsumer() throws Exception {\n        final Barrier cb = new Barrier(2);\n\n        final ServiceRegistration reg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n            @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                 });\n\n        try {\n            this.getJobManager().addJob(TOPIC, null);\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n            assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n        } finally {\n            reg.unregister();\n        }\n    }","id":66938,"modified_method":"/**\n     * Test simple job execution.\n     * The job is executed once and finished successfully.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleJobExecutionUsingJobConsumer() throws Exception {\n        final Barrier cb = new Barrier(2);\n\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n            @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                 });\n\n        this.getJobManager().addJob(TOPIC, null);\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n        assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test canceling a job\n     * The job execution always fails\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testCancelJob() throws Exception {\n        final Barrier cb = new Barrier(2);\n        final Barrier cb2 = new Barrier(2);\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        cb.block();\n                        cb2.block();\n                        return JobResult.FAILED;\n                    }\n                });\n        try {\n            final Map<String, Object> jobProperties = Collections.singletonMap(\"id\", (Object)\"cancelJobId\");\n            @SuppressWarnings(\"unchecked\")\n            final Map<String, Object>[] jobPropertiesAsArray = new Map[1];\n            jobPropertiesAsArray[0] = jobProperties;\n\n            // create job\n            final JobManager jobManager = this.getJobManager();\n            jobManager.addJob(TOPIC, jobProperties);\n            cb.block();\n\n            assertEquals(1, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, jobPropertiesAsArray).size());\n            // job is currently waiting, therefore cancel fails\n            final Job e1 = jobManager.getJob(TOPIC, jobProperties);\n            assertNotNull(e1);\n            cb2.block(); // and continue job\n\n            sleep(200);\n\n            // the job is now in the queue again\n            final Job e2 = jobManager.getJob(TOPIC, jobProperties);\n            assertNotNull(e2);\n            assertTrue(jobManager.removeJobById(e2.getId()));\n            assertEquals(0, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, jobPropertiesAsArray).size());\n            final Collection<Job> col = jobManager.findJobs(JobManager.QueryType.HISTORY, TOPIC, -1,\n                    jobPropertiesAsArray);\n            try {\n                assertEquals(1, col.size());\n            } finally {\n                for(final Job j : col) {\n                    jobManager.removeJobById(j.getId());\n                }\n            }\n        } finally {\n            jcReg.unregister();\n        }\n   }","id":66939,"modified_method":"/**\n     * Test canceling a job\n     * The job execution always fails\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testCancelJob() throws Exception {\n        final Barrier cb = new Barrier(2);\n        final Barrier cb2 = new Barrier(2);\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        cb.block();\n                        cb2.block();\n                        return JobResult.FAILED;\n                    }\n                });\n\n        final Map<String, Object> jobProperties = Collections.singletonMap(\"id\", (Object)\"cancelJobId\");\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, Object>[] jobPropertiesAsArray = new Map[1];\n        jobPropertiesAsArray[0] = jobProperties;\n\n        // create job\n        final JobManager jobManager = this.getJobManager();\n        jobManager.addJob(TOPIC, jobProperties);\n        cb.block();\n\n        assertEquals(1, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, jobPropertiesAsArray).size());\n        // job is currently waiting, therefore cancel fails\n        final Job e1 = jobManager.getJob(TOPIC, jobProperties);\n        assertNotNull(e1);\n        cb2.block(); // and continue job\n\n        sleep(200);\n\n        // the job is now in the queue again\n        final Job e2 = jobManager.getJob(TOPIC, jobProperties);\n        assertNotNull(e2);\n        assertTrue(jobManager.removeJobById(e2.getId()));\n        assertEquals(0, jobManager.findJobs(JobManager.QueryType.ALL, TOPIC, -1, jobPropertiesAsArray).size());\n        final Collection<Job> col = jobManager.findJobs(JobManager.QueryType.HISTORY, TOPIC, -1,\n                jobPropertiesAsArray);\n        try {\n            assertEquals(1, col.size());\n        } finally {\n            for(final Job j : col) {\n                jobManager.removeJobById(j.getId());\n            }\n        }\n   }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Notifications.\n     * We send several jobs which are treated different and then see\n     * how many invocations have been sent.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testNotifications() throws Exception {\n        final List<String> cancelled = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> failed = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> finished = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> started = Collections.synchronizedList(new ArrayList<String>());\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        // events 1 and 4 finish the first time\n                        final String id = (String)job.getProperty(\"id\");\n                        if ( \"1\".equals(id) || \"4\".equals(id) ) {\n                            return JobResult.OK;\n\n                        // 5 fails always\n                        } else if ( \"5\".equals(id) ) {\n                            return JobResult.FAILED;\n                        } else {\n                            int retry = 0;\n                            if ( job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                                retry = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                            }\n                            // 2 fails the first time\n                            if ( \"2\".equals(id) ) {\n                                if ( retry == 0 ) {\n                                    return JobResult.FAILED;\n                                } else {\n                                    return JobResult.OK;\n                                }\n                            }\n                            // 3 fails the first and second time\n                            if ( \"3\".equals(id) ) {\n                                if ( retry == 0 || retry == 1 ) {\n                                    return JobResult.FAILED;\n                                } else {\n                                    return JobResult.OK;\n                                }\n                            }\n                        }\n                        return JobResult.FAILED;\n                    }\n                });\n        final ServiceRegistration eh1Reg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_CANCELLED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        cancelled.add(id);\n                    }\n                });\n        final ServiceRegistration eh2Reg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FAILED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        failed.add(id);\n                    }\n                });\n        final ServiceRegistration eh3Reg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        finished.add(id);\n                    }\n                });\n        final ServiceRegistration eh4Reg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_STARTED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        started.add(id);\n                    }\n                });\n\n        final JobManager jobManager = this.getJobManager();\n        try {\n            jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"1\"));\n            jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"2\"));\n            jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"3\"));\n            jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"4\"));\n            jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"5\"));\n\n            int count = 0;\n            final long startTime = System.currentTimeMillis();\n            do {\n                count = finished.size() + cancelled.size();\n                // after 25 seconds we cancel the test\n                if ( System.currentTimeMillis() - startTime > 25000 ) {\n                    throw new Exception(\"Timeout during notification test.\");\n                }\n            } while ( count < 5 || started.size() < 10 );\n            assertEquals(\"Finished count\", 4, finished.size());\n            assertEquals(\"Cancelled count\", 1, cancelled.size());\n            assertEquals(\"Started count\", 10, started.size());\n            assertEquals(\"Failed count\", 5, failed.size());\n        } finally {\n            final Collection<Job> col = jobManager.findJobs(JobManager.QueryType.HISTORY, \"sling/test\", -1, (Map<String, Object>[])null);\n            for(final Job j : col) {\n                jobManager.removeJobById(j.getId());\n            }\n            jcReg.unregister();\n            eh1Reg.unregister();\n            eh2Reg.unregister();\n            eh3Reg.unregister();\n            eh4Reg.unregister();\n        }\n    }","id":66940,"modified_method":"/**\n     * Notifications.\n     * We send several jobs which are treated different and then see\n     * how many invocations have been sent.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testNotifications() throws Exception {\n        final List<String> cancelled = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> failed = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> finished = Collections.synchronizedList(new ArrayList<String>());\n        final List<String> started = Collections.synchronizedList(new ArrayList<String>());\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        // events 1 and 4 finish the first time\n                        final String id = (String)job.getProperty(\"id\");\n                        if ( \"1\".equals(id) || \"4\".equals(id) ) {\n                            return JobResult.OK;\n\n                        // 5 fails always\n                        } else if ( \"5\".equals(id) ) {\n                            return JobResult.FAILED;\n                        } else {\n                            int retry = 0;\n                            if ( job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                                retry = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                            }\n                            // 2 fails the first time\n                            if ( \"2\".equals(id) ) {\n                                if ( retry == 0 ) {\n                                    return JobResult.FAILED;\n                                } else {\n                                    return JobResult.OK;\n                                }\n                            }\n                            // 3 fails the first and second time\n                            if ( \"3\".equals(id) ) {\n                                if ( retry == 0 || retry == 1 ) {\n                                    return JobResult.FAILED;\n                                } else {\n                                    return JobResult.OK;\n                                }\n                            }\n                        }\n                        return JobResult.FAILED;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_CANCELLED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        cancelled.add(id);\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FAILED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        failed.add(id);\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        finished.add(id);\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_STARTED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(Event event) {\n                        final String id = (String)event.getProperty(\"id\");\n                        started.add(id);\n                    }\n                });\n\n        final JobManager jobManager = this.getJobManager();\n\n        jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"1\"));\n        jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"2\"));\n        jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"3\"));\n        jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"4\"));\n        jobManager.addJob(TOPIC, Collections.singletonMap(\"id\", (Object)\"5\"));\n\n        int count = 0;\n        final long startTime = System.currentTimeMillis();\n        do {\n            count = finished.size() + cancelled.size();\n            // after 25 seconds we cancel the test\n            if ( System.currentTimeMillis() - startTime > 25000 ) {\n                throw new Exception(\"Timeout during notification test.\");\n            }\n        } while ( count < 5 || started.size() < 10 );\n        assertEquals(\"Finished count\", 4, finished.size());\n        assertEquals(\"Cancelled count\", 1, cancelled.size());\n        assertEquals(\"Started count\", 10, started.size());\n        assertEquals(\"Failed count\", 5, failed.size());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Reschedule test.\n     * The job is rescheduled two times before it fails.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testStartJobAndReschedule() throws Exception {\n        final List<Integer> retryCountList = new ArrayList<Integer>();\n        final Barrier cb = new Barrier(2);\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n                    int retryCount;\n\n                    @Override\n                    public JobResult process(Job job) {\n                        int retry = 0;\n                        if ( job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                            retry = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                        }\n                        if ( retry == retryCount ) {\n                            retryCountList.add(retry);\n                        }\n                        retryCount++;\n                        cb.block();\n                        return JobResult.FAILED;\n                    }\n                });\n        try {\n            final JobManager jobManager = this.getJobManager();\n            final Job job = jobManager.addJob(TOPIC, null);\n\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n            // the job is retried after two seconds, so we wait again\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n            // the job is retried after two seconds, so we wait again\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            // we have reached the retry so we expect to not get an event\n            cb.reset();\n            assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n            assertEquals(\"Unexpected number of retries\", 3, retryCountList.size());\n\n            jobManager.removeJobById(job.getId());\n        } finally {\n            jcReg.unregister();\n        }\n    }","id":66941,"modified_method":"/**\n     * Reschedule test.\n     * The job is rescheduled two times before it fails.\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testStartJobAndReschedule() throws Exception {\n        final List<Integer> retryCountList = new ArrayList<Integer>();\n        final Barrier cb = new Barrier(2);\n\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n                    int retryCount;\n\n                    @Override\n                    public JobResult process(Job job) {\n                        int retry = 0;\n                        if ( job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                            retry = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                        }\n                        if ( retry == retryCount ) {\n                            retryCountList.add(retry);\n                        }\n                        retryCount++;\n                        cb.block();\n                        return JobResult.FAILED;\n                    }\n                });\n\n        final JobManager jobManager = this.getJobManager();\n        final Job job = jobManager.addJob(TOPIC, null);\n\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n        // the job is retried after two seconds, so we wait again\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n        // the job is retried after two seconds, so we wait again\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        // we have reached the retry so we expect to not get an event\n        cb.reset();\n        assertFalse(\"Unexpected event received in the given time.\", cb.block(5));\n        assertEquals(\"Unexpected number of retries\", 3, retryCountList.size());\n\n        jobManager.removeJobById(job.getId());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testManyJobs() throws Exception {\n        final ServiceRegistration reg1 = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        return JobResult.OK;\n                    }\n\n                 });\n        final AtomicInteger count = new AtomicInteger(0);\n        final ServiceRegistration reg2 = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                 });\n\n        try {\n            // we start \"some\" jobs\n            final int COUNT = 300;\n            for(int i = 0; i < COUNT; i++ ) {\n                this.getJobManager().addJob(TOPIC, null);\n            }\n            while ( count.get() < COUNT ) {\n                this.sleep(50);\n            }\n            assertEquals(\"Finished count\", COUNT, count.get());\n            assertEquals(\"Finished count\", COUNT, this.getJobManager().getStatistics().getNumberOfFinishedJobs());\n        } finally {\n            reg1.unregister();\n            reg2.unregister();\n        }\n        // we put an extra sleep to see whether this fixes the test problems on Java 8\n        this.sleep(5000);\n    }","id":66942,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testManyJobs() throws Exception {\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        return JobResult.OK;\n                    }\n\n                 });\n        final AtomicInteger count = new AtomicInteger(0);\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                 });\n\n        // we start \"some\" jobs\n        final int COUNT = 300;\n        for(int i = 0; i < COUNT; i++ ) {\n            this.getJobManager().addJob(TOPIC, null);\n        }\n        while ( count.get() < COUNT ) {\n            this.sleep(50);\n        }\n        assertEquals(\"Finished count\", COUNT, count.get());\n        assertEquals(\"Finished count\", COUNT, this.getJobManager().getStatistics().getNumberOfFinishedJobs());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test sending of jobs with and without a processor\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testNoJobProcessor() throws Exception {\n        final AtomicInteger count = new AtomicInteger(0);\n\n        final ServiceRegistration eh1 = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                count.incrementAndGet();\n\n                return JobResult.OK;\n            }\n         });\n\n        try {\n            final JobManager jobManager = this.getJobManager();\n\n            // we start 20 jobs, every second job has no processor\n            final int COUNT = 20;\n            for(int i = 0; i < COUNT; i++ ) {\n                final String jobTopic = (i % 2 == 0 ? TOPIC : TOPIC + \"2\");\n\n                jobManager.addJob(jobTopic, null);\n            }\n            while ( jobManager.getStatistics().getNumberOfFinishedJobs() < COUNT / 2) {\n                this.sleep(50);\n            }\n\n            assertEquals(\"Finished count\", COUNT / 2, count.get());\n            // unprocessed count should be 0 as there is no job consumer for this job\n            assertEquals(\"Unprocessed count\", 0, jobManager.getStatistics().getNumberOfJobs());\n            assertEquals(\"Finished count\", COUNT / 2, jobManager.getStatistics().getNumberOfFinishedJobs());\n\n            // now remove jobs\n            for(final Job j : jobManager.findJobs(JobManager.QueryType.ALL, TOPIC + \"2\", -1, (Map<String, Object>[])null)) {\n                jobManager.removeJobById(j.getId());\n            }\n        } finally {\n            eh1.unregister();\n        }\n    }","id":66943,"modified_method":"/**\n     * Test sending of jobs with and without a processor\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testNoJobProcessor() throws Exception {\n        final AtomicInteger count = new AtomicInteger(0);\n\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                count.incrementAndGet();\n\n                return JobResult.OK;\n            }\n         });\n\n        final JobManager jobManager = this.getJobManager();\n\n        // we start 20 jobs, every second job has no processor\n        final int COUNT = 20;\n        for(int i = 0; i < COUNT; i++ ) {\n            final String jobTopic = (i % 2 == 0 ? TOPIC : TOPIC + \"2\");\n\n            jobManager.addJob(jobTopic, null);\n        }\n        while ( jobManager.getStatistics().getNumberOfFinishedJobs() < COUNT / 2) {\n            this.sleep(50);\n        }\n\n        assertEquals(\"Finished count\", COUNT / 2, count.get());\n        // unprocessed count should be 0 as there is no job consumer for this job\n        assertEquals(\"Unprocessed count\", 0, jobManager.getStatistics().getNumberOfJobs());\n        assertEquals(\"Finished count\", COUNT / 2, jobManager.getStatistics().getNumberOfFinishedJobs());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test get a job\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testGetJob() throws Exception {\n        final Barrier cb = new Barrier(2);\n        final Barrier cb2 = new Barrier(2);\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        cb.block();\n                        cb2.block();\n                        return JobResult.OK;\n                    }\n                });\n        try {\n            final JobManager jobManager = this.getJobManager();\n            final Job j = jobManager.addJob(TOPIC, null);\n            cb.block();\n\n            assertNotNull(jobManager.getJob(TOPIC, null));\n\n            cb2.block(); // and continue job\n\n            jobManager.removeJobById(j.getId());\n        } finally {\n            jcReg.unregister();\n        }\n    }","id":66944,"modified_method":"/**\n     * Test get a job\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testGetJob() throws Exception {\n        final Barrier cb = new Barrier(2);\n        final Barrier cb2 = new Barrier(2);\n        this.registerJobConsumer(TOPIC,\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(Job job) {\n                        cb.block();\n                        cb2.block();\n                        return JobResult.OK;\n                    }\n                });\n        final JobManager jobManager = this.getJobManager();\n        final Job j = jobManager.addJob(TOPIC, null);\n        cb.block();\n\n        assertNotNull(jobManager.getJob(TOPIC, null));\n\n        cb2.block(); // and continue job\n\n        jobManager.removeJobById(j.getId());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Ordered Queue Test\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testOrderedQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        // register consumer and event handler\n        final Barrier cb = new Barrier(2);\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        final ServiceRegistration<JobConsumer> jcReg = this.registerJobConsumer(\"sling/orderedtest/*\",\n                new JobConsumer() {\n\n                    private volatile int lastCounter = -1;\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int counter = job.getProperty(\"counter\", -10);\n                        assertNotEquals(\"Counter property is missing\", -10, counter);\n                        assertTrue(\"Counter should only increment by max of 1 \" + counter + \" - \" + lastCounter,\n                                counter == lastCounter || counter == lastCounter +1);\n                        lastCounter = counter;\n                        if (\"sling/orderedtest/start\".equals(job.getTopic()) ) {\n                            cb.block();\n                            return JobResult.OK;\n                        }\n                        if ( parallelCount.incrementAndGet() > 1 ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        final String topic = job.getTopic();\n                        if ( topic.endsWith(\"sub1\") ) {\n                            final int i = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                            if ( i == 0 ) {\n                                parallelCount.decrementAndGet();\n                                return JobResult.FAILED;\n                            }\n                        }\n                        try {\n                            Thread.sleep(30);\n                        } catch (InterruptedException ie) {\n                            // ignore\n                        }\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        final ServiceRegistration<EventHandler> ehReg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        try {\n            // we first sent one event to get the queue started\n            final Map<String, Object> properties = new HashMap<String, Object>();\n            properties.put(\"counter\", -1);\n            jobManager.addJob(\"sling/orderedtest/start\", properties);\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n\n            // get the queue\n            final Queue q = jobManager.getQueue(\"orderedtest\");\n            assertNotNull(\"Queue 'orderedtest' should exist!\", q);\n\n            // suspend it\n            q.suspend();\n\n            final int NUM_JOBS = 30;\n\n            // we start \"some\" jobs:\n            for(int i = 0; i < NUM_JOBS; i++ ) {\n                final String subTopic = \"sling/orderedtest/sub\" + (i % 10);\n                properties.clear();\n                properties.put(\"counter\", i);\n                jobManager.addJob(subTopic, properties);\n            }\n            // start the queue\n            q.resume();\n            while ( count.get() < NUM_JOBS +1 ) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    // ignore\n                }\n            }\n            // we started one event before the test, so add one\n            assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Failed count\", NUM_JOBS / 10, q.getStatistics().getNumberOfFailedJobs());\n            assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n        } finally {\n            jcReg.unregister();\n            ehReg.unregister();\n        }\n    }","id":66945,"modified_method":"/**\n     * Ordered Queue Test\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testOrderedQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        // register consumer and event handler\n        final Barrier cb = new Barrier(2);\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        this.registerJobConsumer(\"sling/orderedtest/*\",\n                new JobConsumer() {\n\n                    private volatile int lastCounter = -1;\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int counter = job.getProperty(\"counter\", -10);\n                        assertNotEquals(\"Counter property is missing\", -10, counter);\n                        assertTrue(\"Counter should only increment by max of 1 \" + counter + \" - \" + lastCounter,\n                                counter == lastCounter || counter == lastCounter +1);\n                        lastCounter = counter;\n                        if (\"sling/orderedtest/start\".equals(job.getTopic()) ) {\n                            cb.block();\n                            return JobResult.OK;\n                        }\n                        if ( parallelCount.incrementAndGet() > 1 ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        final String topic = job.getTopic();\n                        if ( topic.endsWith(\"sub1\") ) {\n                            final int i = (Integer)job.getProperty(Job.PROPERTY_JOB_RETRY_COUNT);\n                            if ( i == 0 ) {\n                                parallelCount.decrementAndGet();\n                                return JobResult.FAILED;\n                            }\n                        }\n                        try {\n                            Thread.sleep(30);\n                        } catch (InterruptedException ie) {\n                            // ignore\n                        }\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        // we first sent one event to get the queue started\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"counter\", -1);\n        jobManager.addJob(\"sling/orderedtest/start\", properties);\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n\n        // get the queue\n        final Queue q = jobManager.getQueue(\"orderedtest\");\n        assertNotNull(\"Queue 'orderedtest' should exist!\", q);\n\n        // suspend it\n        q.suspend();\n\n        final int NUM_JOBS = 30;\n\n        // we start \"some\" jobs:\n        for(int i = 0; i < NUM_JOBS; i++ ) {\n            final String subTopic = \"sling/orderedtest/sub\" + (i % 10);\n            properties.clear();\n            properties.put(\"counter\", i);\n            jobManager.addJob(subTopic, properties);\n        }\n        // start the queue\n        q.resume();\n        while ( count.get() < NUM_JOBS +1 ) {\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException ie) {\n                // ignore\n            }\n        }\n        // we started one event before the test, so add one\n        assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Failed count\", NUM_JOBS / 10, q.getStatistics().getNumberOfFailedJobs());\n        assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testRoundRobinQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        final Barrier cb = new Barrier(2);\n\n        final ServiceRegistration jc1Reg = this.registerJobConsumer(TOPIC + \"/start\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                });\n\n        // register new consumer and event handle\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        final Set<Integer> maxParticipants = new HashSet<Integer>();\n\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC + \"/*\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int max = parallelCount.incrementAndGet();\n                        if ( max > MAX_PAR ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        synchronized ( maxParticipants ) {\n                            maxParticipants.add(max);\n                        }\n                        sleep(job.getProperty(\"sleep\", 30));\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        final ServiceRegistration ehReg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        try {\n            // we first sent one event to get the queue started\n            jobManager.addJob(TOPIC + \"/start\", null);\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n\n            // get the queue\n            final Queue q = jobManager.getQueue(QUEUE_NAME);\n            assertNotNull(\"Queue '\" + QUEUE_NAME + \"' should exist!\", q);\n\n            // suspend it\n            q.suspend();\n\n            // we start \"some\" jobs:\n            for(int i = 0; i < NUM_JOBS; i++ ) {\n                final String subTopic = TOPIC + \"/sub\" + (i % 10);\n                final Map<String, Object> props = new HashMap<String, Object>();\n                if ( i < 10 ) {\n                    props.put(\"sleep\", 300);\n                } else {\n                    props.put(\"sleep\", 30);\n                }\n                jobManager.addJob(subTopic, props);\n            }\n            // start the queue\n            q.resume();\n            while ( count.get() < NUM_JOBS  + 1 ) {\n                assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n                assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n                sleep(300);\n            }\n            // we started one event before the test, so add one\n            assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n            assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n            for(int i=1; i <= MAX_PAR; i++) {\n                assertTrue(\"# Participants \" + String.valueOf(i) + \" not in \" + maxParticipants,\n                        maxParticipants.contains(i));\n            }\n        } finally {\n            jc1Reg.unregister();\n            jcReg.unregister();\n            ehReg.unregister();\n        }\n    }","id":66946,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testRoundRobinQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        final Barrier cb = new Barrier(2);\n\n        this.registerJobConsumer(TOPIC + \"/start\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                });\n\n        // register new consumer and event handle\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        final Set<Integer> maxParticipants = new HashSet<Integer>();\n\n        this.registerJobConsumer(TOPIC + \"/*\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int max = parallelCount.incrementAndGet();\n                        if ( max > MAX_PAR ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        synchronized ( maxParticipants ) {\n                            maxParticipants.add(max);\n                        }\n                        sleep(job.getProperty(\"sleep\", 30));\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        // we first sent one event to get the queue started\n        jobManager.addJob(TOPIC + \"/start\", null);\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n\n        // get the queue\n        final Queue q = jobManager.getQueue(QUEUE_NAME);\n        assertNotNull(\"Queue '\" + QUEUE_NAME + \"' should exist!\", q);\n\n        // suspend it\n        q.suspend();\n\n        // we start \"some\" jobs:\n        for(int i = 0; i < NUM_JOBS; i++ ) {\n            final String subTopic = TOPIC + \"/sub\" + (i % 10);\n            final Map<String, Object> props = new HashMap<String, Object>();\n            if ( i < 10 ) {\n                props.put(\"sleep\", 300);\n            } else {\n                props.put(\"sleep\", 30);\n            }\n            jobManager.addJob(subTopic, props);\n        }\n        // start the queue\n        q.resume();\n        while ( count.get() < NUM_JOBS  + 1 ) {\n            assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n            assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n            sleep(300);\n        }\n        // we started one event before the test, so add one\n        assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n        assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n        for(int i=1; i <= MAX_PAR; i++) {\n            assertTrue(\"# Participants \" + String.valueOf(i) + \" not in \" + maxParticipants,\n                    maxParticipants.contains(i));\n        }\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testScheduling() throws Exception {\n        final AtomicInteger counter = new AtomicInteger();\n\n        final ServiceRegistration ehReg = this.registerJobConsumer(TOPIC, new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                if ( job.getTopic().equals(TOPIC) ) {\n                    counter.incrementAndGet();\n                }\n                return JobResult.OK;\n            }\n\n        });\n        try {\n\n            // we schedule three jobs\n            final ScheduledJobInfo info1 = this.getJobManager().createJob(TOPIC).schedule().hourly(5).add();\n            assertNotNull(info1);\n            final ScheduledJobInfo info2 = this.getJobManager().createJob(TOPIC).schedule().daily(10, 5).add();\n            assertNotNull(info2);\n            final ScheduledJobInfo info3 = this.getJobManager().createJob(TOPIC).schedule().weekly(3, 19, 12).add();\n            assertNotNull(info3);\n\n            assertEquals(3, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n            info3.unschedule();\n            assertEquals(2, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n            info1.unschedule();\n            assertEquals(1, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n            info2.unschedule();\n            assertEquals(0, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n        } finally {\n            ehReg.unregister();\n        }\n    }","id":66947,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testScheduling() throws Exception {\n        final AtomicInteger counter = new AtomicInteger();\n\n        this.registerJobConsumer(TOPIC, new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                if ( job.getTopic().equals(TOPIC) ) {\n                    counter.incrementAndGet();\n                }\n                return JobResult.OK;\n            }\n\n        });\n\n        // we schedule three jobs\n        final ScheduledJobInfo info1 = this.getJobManager().createJob(TOPIC).schedule().hourly(5).add();\n        assertNotNull(info1);\n        final ScheduledJobInfo info2 = this.getJobManager().createJob(TOPIC).schedule().daily(10, 5).add();\n        assertNotNull(info2);\n        final ScheduledJobInfo info3 = this.getJobManager().createJob(TOPIC).schedule().weekly(3, 19, 12).add();\n        assertNotNull(info3);\n\n        assertEquals(3, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n        info3.unschedule();\n        assertEquals(2, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n        info1.unschedule();\n        assertEquals(1, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n        info2.unschedule();\n        assertEquals(0, this.getJobManager().getScheduledJobs().size()); // scheduled jobs\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testTimedJob() throws Exception {\n        final AtomicInteger counter = new AtomicInteger();\n\n        final ServiceRegistration ehReg = this.registerJobConsumer(TOPIC, new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                if ( job.getTopic().equals(TOPIC) ) {\n                    counter.incrementAndGet();\n                }\n                return JobResult.OK;\n            }\n\n        });\n        try {\n            final Date d = new Date();\n            d.setTime(System.currentTimeMillis() + 3000); // run in 3 seconds\n\n            // create scheduled job\n            final ScheduledJobInfo info = this.getJobManager().createJob(TOPIC).schedule().at(d).add();\n            assertNotNull(info);\n\n            while ( counter.get() == 0 ) {\n                this.sleep(1000);\n            }\n            assertEquals(0, this.getJobManager().getScheduledJobs().size()); // job is not scheduled anymore\n            info.unschedule();\n        } finally {\n            ehReg.unregister();\n        }\n    }","id":66948,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testTimedJob() throws Exception {\n        final AtomicInteger counter = new AtomicInteger();\n\n        this.registerJobConsumer(TOPIC, new JobConsumer() {\n\n            @Override\n            public JobResult process(final Job job) {\n                if ( job.getTopic().equals(TOPIC) ) {\n                    counter.incrementAndGet();\n                }\n                return JobResult.OK;\n            }\n\n        });\n\n        final Date d = new Date();\n        d.setTime(System.currentTimeMillis() + 3000); // run in 3 seconds\n\n        // create scheduled job\n        final ScheduledJobInfo info = this.getJobManager().createJob(TOPIC).schedule().at(d).add();\n        assertNotNull(info);\n\n        while ( counter.get() == 0 ) {\n            this.sleep(1000);\n        }\n        assertEquals(0, this.getJobManager().getScheduledJobs().size()); // job is not scheduled anymore\n        info.unschedule();\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test ordering of matchers\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testOrdering() throws Exception {\n        final Barrier barrier1 = new Barrier(2);\n        final Barrier barrier2 = new Barrier(2);\n        final Barrier barrier3 = new Barrier(2);\n\n        final ServiceRegistration<JobExecutor> reg1 = this.registerJobExecutor(\"sling/**\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier1.block();\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<JobExecutor> reg2 = this.registerJobExecutor(\"sling/test/*\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier2.block();\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<JobExecutor> reg3 = this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier3.block();\n                        return context.result().succeeded();\n                    }\n                });\n\n        // first test, all three registered, reg3 should get the precedence\n        this.getJobManager().addJob(TOPIC, null);\n        barrier3.block();\n\n        // second test, unregister reg3, now it should be reg2\n        long cc = this.getConsumerChangeCount();\n        reg3.unregister();\n        this.waitConsumerChangeCount(cc + 1);\n        this.getJobManager().addJob(TOPIC, null);\n        barrier2.block();\n\n        // third test, unregister reg2, reg1 is now the only one\n        cc = this.getConsumerChangeCount();\n        reg2.unregister();\n        this.waitConsumerChangeCount(cc + 1);\n        this.getJobManager().addJob(TOPIC, null);\n        barrier1.block();\n        reg1.unregister();\n    }","id":66949,"modified_method":"/**\n     * Test ordering of matchers\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testOrdering() throws Exception {\n        final Barrier barrier1 = new Barrier(2);\n        final Barrier barrier2 = new Barrier(2);\n        final Barrier barrier3 = new Barrier(2);\n\n        this.registerJobExecutor(\"sling/**\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier1.block();\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<JobExecutor> reg2 = this.registerJobExecutor(\"sling/test/*\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier2.block();\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<JobExecutor> reg3 = this.registerJobExecutor(TOPIC,\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        barrier3.block();\n                        return context.result().succeeded();\n                    }\n                });\n\n        // first test, all three registered, reg3 should get the precedence\n        this.getJobManager().addJob(TOPIC, null);\n        barrier3.block();\n\n        // second test, unregister reg3, now it should be reg2\n        long cc = this.getConsumerChangeCount();\n        this.unregister(reg3);\n        this.waitConsumerChangeCount(cc + 1);\n        this.getJobManager().addJob(TOPIC, null);\n        barrier2.block();\n\n        // third test, unregister reg2, reg1 is now the only one\n        cc = this.getConsumerChangeCount();\n        this.unregister(reg2);\n        this.waitConsumerChangeCount(cc + 1);\n        this.getJobManager().addJob(TOPIC, null);\n        barrier1.block();\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test simple pattern matching /*\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleMatching() throws Exception {\n        final Barrier barrier = new Barrier(2);\n\n        final ServiceRegistration<JobExecutor> reg = this.registerJobExecutor(\"sling/test/*\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<EventHandler> eventHandler = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        barrier.block();\n                    }\n                });\n\n        try {\n            this.getJobManager().addJob(TOPIC, null);\n            barrier.block();\n        } finally {\n            reg.unregister();\n            eventHandler.unregister();\n        }\n    }","id":66950,"modified_method":"/**\n     * Test simple pattern matching /*\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testSimpleMatching() throws Exception {\n        final Barrier barrier = new Barrier(2);\n\n        this.registerJobExecutor(\"sling/test/*\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        return context.result().succeeded();\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        barrier.block();\n                    }\n                });\n\n        this.getJobManager().addJob(TOPIC, null);\n        barrier.block();\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test deep pattern matching /**\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testDeepMatching() throws Exception {\n        final Barrier barrier = new Barrier(2);\n\n        final ServiceRegistration<JobExecutor> reg = this.registerJobExecutor(\"sling/**\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        return context.result().succeeded();\n                    }\n                });\n        final ServiceRegistration<EventHandler> eventHandler = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        barrier.block();\n                    }\n                });\n\n        try {\n            this.getJobManager().addJob(TOPIC, null);\n            barrier.block();\n        } finally {\n            reg.unregister();\n            eventHandler.unregister();\n        }\n    }","id":66951,"modified_method":"/**\n     * Test deep pattern matching /**\n     */\n    @Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testDeepMatching() throws Exception {\n        final Barrier barrier = new Barrier(2);\n\n        this.registerJobExecutor(\"sling/**\",\n                new JobExecutor() {\n\n                    @Override\n                    public JobExecutionResult process(final Job job, final JobExecutionContext context) {\n                        return context.result().succeeded();\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        barrier.block();\n                    }\n                });\n\n        this.getJobManager().addJob(TOPIC, null);\n        barrier.block();\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testUnorderedQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        final Barrier cb = new Barrier(2);\n\n        final ServiceRegistration jc1Reg = this.registerJobConsumer(TOPIC + \"/start\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                });\n\n        // register new consumer and event handle\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        final Set<Integer> maxParticipants = new HashSet<Integer>();\n\n        final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC + \"/*\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int max = parallelCount.incrementAndGet();\n                        if ( max > MAX_PAR ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        synchronized ( maxParticipants ) {\n                            maxParticipants.add(max);\n                        }\n                        sleep(job.getProperty(\"sleep\", 30));\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        final ServiceRegistration ehReg = this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        try {\n            // we first sent one event to get the queue started\n            jobManager.addJob(TOPIC + \"/start\", null);\n            assertTrue(\"No event received in the given time.\", cb.block(5));\n            cb.reset();\n\n            // get the queue\n            final Queue q = jobManager.getQueue(QUEUE_NAME);\n            assertNotNull(\"Queue '\" + QUEUE_NAME + \"' should exist!\", q);\n\n            // suspend it\n            q.suspend();\n\n            // we start \"some\" jobs:\n            for(int i = 0; i < NUM_JOBS; i++ ) {\n                final String subTopic = TOPIC + \"/sub\" + (i % 10);\n                final Map<String, Object> props = new HashMap<String, Object>();\n                if ( i < 10 ) {\n                    props.put(\"sleep\", 300);\n                } else {\n                    props.put(\"sleep\", 30);\n                }\n                jobManager.addJob(subTopic, props);\n            }\n            // start the queue\n            q.resume();\n            while ( count.get() < NUM_JOBS  + 1 ) {\n                assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n                assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n                sleep(300);\n            }\n            // we started one event before the test, so add one\n            assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n            assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n            assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n            for(int i=1; i <= MAX_PAR; i++) {\n                assertTrue(\"# Participants \" + String.valueOf(i) + \" not in \" + maxParticipants,\n                        maxParticipants.contains(i));\n            }\n        } finally {\n            jc1Reg.unregister();\n            jcReg.unregister();\n            ehReg.unregister();\n        }\n    }","id":66952,"modified_method":"@Test(timeout = DEFAULT_TEST_TIMEOUT)\n    public void testUnorderedQueue() throws Exception {\n        final JobManager jobManager = this.getJobManager();\n\n        final Barrier cb = new Barrier(2);\n\n        this.registerJobConsumer(TOPIC + \"/start\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        cb.block();\n                        return JobResult.OK;\n                    }\n                });\n\n        // register new consumer and event handle\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger parallelCount = new AtomicInteger(0);\n        final Set<Integer> maxParticipants = new HashSet<Integer>();\n\n        this.registerJobConsumer(TOPIC + \"/*\",\n                new JobConsumer() {\n\n                    @Override\n                    public JobResult process(final Job job) {\n                        final int max = parallelCount.incrementAndGet();\n                        if ( max > MAX_PAR ) {\n                            parallelCount.decrementAndGet();\n                            return JobResult.FAILED;\n                        }\n                        synchronized ( maxParticipants ) {\n                            maxParticipants.add(max);\n                        }\n                        sleep(job.getProperty(\"sleep\", 30));\n                        parallelCount.decrementAndGet();\n                        return JobResult.OK;\n                    }\n                });\n        this.registerEventHandler(NotificationConstants.TOPIC_JOB_FINISHED,\n                new EventHandler() {\n\n                    @Override\n                    public void handleEvent(final Event event) {\n                        count.incrementAndGet();\n                    }\n                });\n\n        // we first sent one event to get the queue started\n        jobManager.addJob(TOPIC + \"/start\", null);\n        assertTrue(\"No event received in the given time.\", cb.block(5));\n        cb.reset();\n\n        // get the queue\n        final Queue q = jobManager.getQueue(QUEUE_NAME);\n        assertNotNull(\"Queue '\" + QUEUE_NAME + \"' should exist!\", q);\n\n        // suspend it\n        q.suspend();\n\n        // we start \"some\" jobs:\n        for(int i = 0; i < NUM_JOBS; i++ ) {\n            final String subTopic = TOPIC + \"/sub\" + (i % 10);\n            final Map<String, Object> props = new HashMap<String, Object>();\n            if ( i < 10 ) {\n                props.put(\"sleep\", 300);\n            } else {\n                props.put(\"sleep\", 30);\n            }\n            jobManager.addJob(subTopic, props);\n        }\n        // start the queue\n        q.resume();\n        while ( count.get() < NUM_JOBS  + 1 ) {\n            assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n            assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n            sleep(300);\n        }\n        // we started one event before the test, so add one\n        assertEquals(\"Finished count\", NUM_JOBS + 1, count.get());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, jobManager.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Finished count\", NUM_JOBS + 1, q.getStatistics().getNumberOfFinishedJobs());\n        assertEquals(\"Failed count\", 0, q.getStatistics().getNumberOfFailedJobs());\n        assertEquals(\"Cancelled count\", 0, q.getStatistics().getNumberOfCancelledJobs());\n        for(int i=1; i <= MAX_PAR; i++) {\n            assertTrue(\"# Participants \" + String.valueOf(i) + \" not in \" + maxParticipants,\n                    maxParticipants.contains(i));\n        }\n    }","commit_id":"14419ff132007b531391dd18b9f24d30a9764dae","url":"https://github.com/apache/sling"},{"original_method":"public static ContentName getLatestVersion(ContentName baseName, byte[] metaName, PublisherPublicKeyDigest publisher, \n\t\t\t long timeout, ContentVerifier verifier, CCNHandle handle) throws IOException {\n\t\tContentObject baseVersion = VersioningProfile.getLatestVersion(baseName, publisher, timeout, verifier, handle);\n\t\tContentObject meta = VersioningProfile.getLatestVersion(new ContentName(baseVersion.name(), METADATA_MARKER, metaName), publisher, timeout, verifier, handle);\n\t\treturn meta.name();\n\t}","id":66953,"modified_method":"public static ContentName getLatestVersion(ContentName baseName, byte[] metaDir, byte[] metaName, PublisherPublicKeyDigest publisher, \n\t\t\t long timeout, ContentVerifier verifier, CCNHandle handle) throws IOException {\n\t\tContentName baseVersion = baseName;\n\t\tif (!VersioningProfile.containsVersion(baseVersion)) {\n\t\t\tbaseVersion = VersioningProfile.getLatestVersion(baseName, publisher, timeout, verifier, handle).name();\n\t\t\tbaseVersion = SegmentationProfile.segmentRoot(baseVersion);\n\t\t}\n\t\tbyte[][] newComponents = new byte[3][];\n\t\tnewComponents[0] = METADATA_MARKER;\n\t\tnewComponents[1] = metaDir;\n\t\tnewComponents[2] = metaName;\n\t\tContentName unversionedName = new ContentName(baseVersion, newComponents);\n\t\tContentObject meta = VersioningProfile.getLatestVersion(unversionedName, publisher, timeout, verifier, handle);\n\t\tif (null == meta)\n\t\t\treturn VersioningProfile.addVersion(unversionedName);\n\t\treturn meta.name();\n\t}","commit_id":"b64ef10de913345d65e3bdedaa472f3aa09d940f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static ContentName getLatestVersion(ContentName baseName, ContentName metaName, PublisherPublicKeyDigest publisher,\n\t\t\tlong timeout, ContentVerifier verifier, CCNHandle handle) throws IOException {\n\t\treturn getLatestVersion(baseName, new LocalMetaNamer(), metaName.components(), publisher, timeout, verifier, handle);\n\t}","id":66954,"modified_method":"public static ContentName getLatestVersion(ContentName baseName, ContentName metaName, \n\t\t\tlong timeout, CCNHandle handle) throws IOException {\n\t\treturn getLatestVersion(baseName, new LocalMetaNamer(), metaName.components(), timeout, handle);\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static ContentName getLatestVersion(ContentName baseName, MetaNamer namer, ArrayList<byte[]> metaName, PublisherPublicKeyDigest publisher, \n\t\t\t long timeout, ContentVerifier verifier, CCNHandle handle) throws IOException {\n\t\tContentName baseVersion = baseName;\n\t\tif (!VersioningProfile.containsVersion(baseVersion)) {\n\t\t\tbaseVersion = VersioningProfile.getLatestVersion(baseName, publisher, timeout, verifier, handle).name();\n\t\t\tbaseVersion = SegmentationProfile.segmentRoot(baseVersion);\n\t\t}\n\t\tContentName unversionedName = namer.getMetaName(baseVersion, metaName);\n\t\tContentObject meta = VersioningProfile.getLatestVersion(unversionedName, publisher, timeout, verifier, handle);\n\t\tif (null == meta)\n\t\t\treturn VersioningProfile.addVersion(unversionedName);\n\t\treturn meta.name();\n\t}","id":66955,"modified_method":"public static ContentName getLatestVersion(ContentName baseName, MetaNamer namer, ArrayList<byte[]> metaName,\n\t\t\t long timeout, CCNHandle handle) throws IOException {\n\t\tContentName baseVersion = baseName;\n\t\tCCNInputStream checker = new CCNInputStream(baseName, handle);\n\t\tif (null == checker)\n\t\t\treturn null;\n\t\tif (!VersioningProfile.containsVersion(baseVersion)) {\n\t\t\tContentObject co = VersioningProfile.getFirstBlockOfLatestVersion(baseName, null, checker.publisher(), timeout, checker, handle);\n\t\t\tif (null == co)\n\t\t\t\treturn null;\n\t\t\tbaseVersion = co.name();\n\t\t\tbaseVersion = SegmentationProfile.segmentRoot(baseVersion);\n\t\t}\n\t\tContentName unversionedName = namer.getMetaName(baseVersion, metaName);\n\t\tContentObject meta = VersioningProfile.getFirstBlockOfLatestVersion(unversionedName, null, checker.publisher(), timeout, checker, handle);\n\t\tif (null == meta)\n\t\t\treturn VersioningProfile.addVersion(unversionedName);\n\t\treturn meta.name();\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static ContentName getLatestVersion(ContentName baseName, byte[] metaName, PublisherPublicKeyDigest publisher, \n\t\t\t long timeout, ContentVerifier verifier, CCNHandle handle) throws IOException {\n\t\tArrayList<byte[]> list = new ArrayList<byte[]>();\n\t\tlist.add(metaName);\n\t\treturn MetadataProfile.getLatestVersion(baseName, new ThumbnailNamer(), list, publisher, timeout, verifier, handle);\n\t}","id":66956,"modified_method":"public static ContentName getLatestVersion(ContentName baseName, byte[] metaName, long timeout, CCNHandle handle) throws IOException {\n\t\tArrayList<byte[]> list = new ArrayList<byte[]>();\n\t\tlist.add(metaName);\n\t\treturn MetadataProfile.getLatestVersion(baseName, new ThumbnailNamer(), list, timeout, handle);\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Test\n\tpublic void testThumbnails() throws Exception {\n\t\tbyte [] fakeImageData1 = \"xxx\".getBytes();\n\t\tContentName thumbNailBase = ContentName.fromNative(testHelper.getTestNamespace(\"testThumbnails\"), \"thumbnailBaseFile\");\n\t\tCCNStringObject cso = new CCNStringObject(thumbNailBase, \"thumbNailBase\", CCNFlowControl.SaveType.REPOSITORY, putHandle);\n\t\tcso.save();\n\t\tcso.close();\n\t\tContentVerifier putVerifier = new ContentObject.SimpleVerifier(putHandle.getDefaultPublisher());\n\t\tContentName thumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a simple thumbnail\");\n\t\tRepositoryFileOutputStream thumbImage1 = new RepositoryFileOutputStream(thumbName, putHandle);\n\t\tthumbImage1.write(fakeImageData1, 0, fakeImageData1.length);\n\t\tthumbImage1.close();\n\t\tContentName origVersion = SegmentationProfile.segmentRoot(VersioningProfile.getLatestVersion(thumbNailBase, cso.getContentPublisher(), SystemConfiguration.LONG_TIMEOUT, \n\t\t\t\tputVerifier, getHandle).name());\n\t\tContentName checkThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData1);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a second version of a thumbnail\");\n\t\tbyte [] fakeImageData2 = \"yyy\".getBytes();\n\t\tContentName thumbName2 = VersioningProfile.updateVersion(checkThumbName);\n\t\tRepositoryFileOutputStream thumbImage2 = new RepositoryFileOutputStream(thumbName2, putHandle);\n\t\tthumbImage2.write(fakeImageData2, 0, fakeImageData2.length);\n\t\tthumbImage2.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData2);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a thumbnail associated with a second version of a file\");\n\t\tcso = new CCNStringObject(thumbNailBase, \"thumbNailBase\", CCNFlowControl.SaveType.REPOSITORY, putHandle);\n\t\tcso.save();\n\t\tcso.close();\n\t\tbyte [] fakeImageData3 = \"zzz\".getBytes();\n\t\tthumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tRepositoryFileOutputStream thumbImage3 = new RepositoryFileOutputStream(thumbName, putHandle);\n\t\tthumbImage3.write(fakeImageData3, 0, fakeImageData3.length);\n\t\tthumbImage3.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData3);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a second thumbnail associated with a second version of a file\");\n\t\tbyte [] fakeImageData4 = \"fff\".getBytes();\n\t\tthumbName2 = VersioningProfile.updateVersion(checkThumbName);\n\t\tRepositoryFileOutputStream thumbImage4 = new RepositoryFileOutputStream(thumbName2, putHandle);\n\t\tthumbImage4.write(fakeImageData4, 0, fakeImageData4.length);\n\t\tthumbImage4.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData4);\n\n\t\tSystem.out.println(\"Check that we can retrieve the correct thumbnail associated with an arbitrary version of a file\");\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(origVersion, \"image.png\".getBytes(), cso.getContentPublisher(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putVerifier, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData2);\t\n\t}","id":66957,"modified_method":"@Test\n\tpublic void testThumbnails() throws Exception {\n\t\tbyte [] fakeImageData1 = \"xxx\".getBytes();\n\t\tContentName thumbNailBase = ContentName.fromNative(testHelper.getTestNamespace(\"testThumbnails\"), \"thumbnailBaseFile\");\n\t\tCCNStringObject cso = new CCNStringObject(thumbNailBase, \"thumbNailBase\", CCNFlowControl.SaveType.REPOSITORY, putHandle);\n\t\tcso.save();\n\t\tcso.close();\n\t\tContentName origVersion = SegmentationProfile.segmentRoot(VersioningProfile.getLatestVersion(thumbNailBase, cso.getContentPublisher(), \n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putHandle.defaultVerifier(), getHandle).name());\t\t\n\t\tContentName thumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(),\n\t\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a simple thumbnail\");\n\t\tRepositoryFileOutputStream thumbImage1 = new RepositoryFileOutputStream(thumbName, putHandle);\n\t\tthumbImage1.write(fakeImageData1, 0, fakeImageData1.length);\n\t\tthumbImage1.close();\n\t\tContentName checkThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData1);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a second version of a thumbnail\");\n\t\tbyte [] fakeImageData2 = \"yyy\".getBytes();\n\t\tContentName thumbName2 = VersioningProfile.updateVersion(checkThumbName);\n\t\tRepositoryFileOutputStream thumbImage2 = new RepositoryFileOutputStream(thumbName2, putHandle);\n\t\tthumbImage2.write(fakeImageData2, 0, fakeImageData2.length);\n\t\tthumbImage2.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(),\n\t\t\t\tSystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData2);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a thumbnail associated with a second version of a file\");\n\t\tcso = new CCNStringObject(thumbNailBase, \"thumbNailBase\", CCNFlowControl.SaveType.REPOSITORY, putHandle);\n\t\tcso.save();\n\t\tcso.close();\n\t\tbyte [] fakeImageData3 = \"zzz\".getBytes();\n\t\tthumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), SystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tRepositoryFileOutputStream thumbImage3 = new RepositoryFileOutputStream(thumbName, putHandle);\n\t\tthumbImage3.write(fakeImageData3, 0, fakeImageData3.length);\n\t\tthumbImage3.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), SystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData3);\n\t\t\n\t\tSystem.out.println(\"Check that we can retrieve a second thumbnail associated with a second version of a file\");\n\t\tbyte [] fakeImageData4 = \"fff\".getBytes();\n\t\tthumbName2 = VersioningProfile.updateVersion(checkThumbName);\n\t\tRepositoryFileOutputStream thumbImage4 = new RepositoryFileOutputStream(thumbName2, putHandle);\n\t\tthumbImage4.write(fakeImageData4, 0, fakeImageData4.length);\n\t\tthumbImage4.close();\n\t\t\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(thumbNailBase, \"image.png\".getBytes(), SystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData4);\n\n\t\tSystem.out.println(\"Check that we can retrieve the correct thumbnail associated with an arbitrary version of a file\");\n\t\tcheckThumbName = ThumbnailProfile.getLatestVersion(origVersion, \"image.png\".getBytes(), SystemConfiguration.LONG_TIMEOUT, putHandle);\n\t\tcheckData(checkThumbName, fakeImageData2);\t\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tint startArg = 0;\n\t\t\n\t\tfor (int i = 0; i < args.length - 2; i++) {\n\t\t\tif (args[i].equals(\"-unversioned\")) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tunversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\ttimeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tLog.setLevel(level);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage();\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (args.length != startArg + 3) {\n\t\t\tusage();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\t\t\t\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tContentName argName = MetadataProfile.getLatestVersion(ContentName.fromURI(args[startArg]), \n\t\t\t\t\tContentName.fromNative(args[startArg + 1]), null, timeout, new ContentObject.SimpleVerifier(null), handle);\n\t\t\n\t\t\tFile theFile = new File(args[startArg + 1]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\t\t\t\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (unversioned)\n\t\t\t\tinput = new CCNInputStream(argName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(argName, handle);\n\t\t\tif (timeout != null) {\n\t\t\t\tinput.setTimeout(timeout); \n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\t\t\t\n\t\t\tint readcount = 0;\n\t\t\tint readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[0] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","id":66958,"modified_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tint startArg = 0;\n\t\t\n\t\tfor (int i = 0; i < args.length - 3; i++) {\n\t\t\tif (args[i].equals(\"-unversioned\")) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tunversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\ttimeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tLog.setLevel(level);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage();\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (args.length != startArg + 3) {\n\t\t\tusage();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\t\t\t\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tString metaArg = args[startArg + 1];\n\t\t\tif (!metaArg.startsWith(\"/\"))\n\t\t\t\tmetaArg = \"/\" + metaArg;\n\t\t\tContentName argName = MetadataProfile.getLatestVersion(ContentName.fromURI(args[startArg]), \n\t\t\t\t\tContentName.fromNative(metaArg), timeout, handle);\n\t\t\n\t\t\tFile theFile = new File(args[startArg + 1]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\t\t\t\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (unversioned)\n\t\t\t\tinput = new CCNInputStream(argName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(argName, handle);\n\t\t\tif (timeout != null) {\n\t\t\t\tinput.setTimeout(timeout); \n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\t\t\t\n\t\t\tint readcount = 0;\n\t\t\tint readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[0] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * @param args\n\t */\n\tpublic void write(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\t\tint startArg = 0;\n\t\t\n\t\tfor (int i = 0; i < args.length - 2; i++) {\n\t\t\tif (args[i].equals((\"-raw\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tCommonParameters.rawMode = true;\n\t\t\t} else if (args[i].equals(\"-unversioned\")) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tCommonParameters.unversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tCommonParameters.timeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tLog.setLevel(level);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-v\")) {\n\t\t\t\tCommonParameters.verbose = true;\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\tif (args.length != startArg + 3) {\n\t\t\tusage();\n\t\t}\n\t\t\n\t\tlong starttime = System.currentTimeMillis();\n\t\ttry {\n\t\t\t// If we get one file name, put as the specific name given.\n\t\t\t// If we get more than one, put underneath the first as parent.\n\t\t\t// Ideally want to use newVersion to get latest version. Start\n\t\t\t// with random version.\n\t\t\t\n\t\t\tContentName baseName = ContentName.fromURI(args[startArg]);\n\t\t\tContentName metaPath = ContentName.fromURI(args[startArg + 1]);\n\t\t\tCCNHandle handle = CCNHandle.open();\n\t\t\tContentName fileName = MetadataProfile.getLatestVersion(baseName, metaPath, null, CommonParameters.timeout, \n\t\t\t\t\tnew ContentObject.SimpleVerifier(null), handle);\n\t\t\t\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tLog.info(\"ccnputmeta: putting metadata file \" + args[startArg + 1]);\n\t\t\t\n\t\t\tdoPut(handle, args[startArg + 2], fileName);\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccnputmeta took: \"+(System.currentTimeMillis() - starttime)+\" ms\");\n\t\t\tSystem.exit(0);\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in put: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot read file. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tSystem.out.println(\"Cannot publish invalid key: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\n\t}","id":66959,"modified_method":"/**\n\t * @param args\n\t */\n\tpublic void write(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\t\tint startArg = 0;\n\t\t\n\t\tfor (int i = 0; i < args.length - 3; i++) {\n\t\t\tif (args[i].equals((\"-raw\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tCommonParameters.rawMode = true;\n\t\t\t} else if (args[i].equals(\"-unversioned\")) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tCommonParameters.unversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tCommonParameters.timeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tLog.setLevel(level);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-v\")) {\n\t\t\t\tCommonParameters.verbose = true;\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\tif (args.length != startArg + 3) {\n\t\t\tusage();\n\t\t}\n\t\t\n\t\tlong starttime = System.currentTimeMillis();\n\t\ttry {\n\t\t\t// If we get one file name, put as the specific name given.\n\t\t\t// If we get more than one, put underneath the first as parent.\n\t\t\t// Ideally want to use newVersion to get latest version. Start\n\t\t\t// with random version.\n\t\t\t\n\t\t\tContentName baseName = ContentName.fromURI(args[startArg]);\n\t\t\tString metaArg = args[startArg + 1];\n\t\t\tif (!metaArg.startsWith(\"/\"))\n\t\t\t\tmetaArg = \"/\" + metaArg;\n\t\t\tContentName metaPath = ContentName.fromURI(metaArg);\n\t\t\tCCNHandle handle = CCNHandle.open();\n\t\t\tContentName prevFileName = MetadataProfile.getLatestVersion(baseName, metaPath, CommonParameters.timeout, handle);\n\t\t\tif (null == prevFileName) {\n\t\t\t\tSystem.out.println(\"File: \" + baseName + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tContentName fileName = VersioningProfile.updateVersion(prevFileName);\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tLog.info(\"ccnputmeta: putting metadata file \" + args[startArg + 1]);\n\t\t\t\n\t\t\tdoPut(handle, args[startArg + 2], fileName);\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccnputmeta took: \"+(System.currentTimeMillis() - starttime)+\" ms\");\n\t\t\tSystem.exit(0);\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in put: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot read file. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tSystem.out.println(\"Cannot publish invalid key: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\n\t}","commit_id":"7c07862c844ea89da0598203dd6feceadf05329b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n    public void register(ExtensionBuilder builder) {\n        builder.observer(Configuration.class)\n                .observer(Configurer.class)\n                .observer(getClientCreator())\n                .observer(ControllerCreator.class)\n                .observer(LoggerFactory.class)\n                .observer(SuiteListener.class)\n                .observer(SessionListener.class);\n\n        builder.service(ResourceProvider.class, ClientResourceProvider.class)\n                .service(ResourceProvider.class, ControllerResourceProvider.class)\n                .service(ResourceProvider.class, JolokiaClientsProvider.class)\n                .service(ResourceProvider.class, PodListResourceProvider.class)\n                .service(ResourceProvider.class, ReplicationControllerListResourceProvider.class)\n                .service(ResourceProvider.class, ReplicationControllerResourceProvider.class)\n                .service(ResourceProvider.class, ServiceListResourceProvider.class)\n                .service(ResourceProvider.class, ServiceResourceProvider.class)\n                .service(ResourceProvider.class, SessionResourceProvider.class);\n    }","id":66960,"modified_method":"@Override\n    public void register(ExtensionBuilder builder) {\n        builder.observer(Configuration.class)\n                .observer(Configurer.class)\n                .observer(getClientCreator())\n                .observer(ControllerCreator.class)\n                .observer(LoggerFactory.class)\n                .observer(SuiteListener.class)\n                .observer(SessionListener.class);\n\n        builder.service(ResourceProvider.class, ClientResourceProvider.class)\n                .service(ResourceProvider.class, ControllerResourceProvider.class)\n                .service(ResourceProvider.class, JolokiaClientsProvider.class)\n                .service(ResourceProvider.class, PodListResourceProvider.class)\n                .service(ResourceProvider.class, PodResourceProvider.class)\n                .service(ResourceProvider.class, ReplicationControllerListResourceProvider.class)\n                .service(ResourceProvider.class, ReplicationControllerResourceProvider.class)\n                .service(ResourceProvider.class, ServiceListResourceProvider.class)\n                .service(ResourceProvider.class, ServiceResourceProvider.class)\n                .service(ResourceProvider.class, SessionResourceProvider.class);\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void createClient(@Observes Configuration config) throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n        Namespace namespace = new NamespaceBuilder()\n                .withNewMetadata()\n                .withName(\"arquillian\")\n                .endMetadata()\n                .build();\n\n        mock.getMasterUrl().andReturn(new URL(\"http://mock.client:80\")).anyTimes();\n\n        mock.namespaces().withName(\"arquillian\").get().andReturn(namespace).anyTimes();\n        mock.namespaces().withName(\"arquillian\").edit().done().andReturn(namespace).anyTimes();\n\n        mock.replicationControllers().inNamespace(\"arquillian\").list().andReturn(new ReplicationControllerListBuilder().build()).once();\n        mock.pods().inNamespace(\"arquillian\").list().andReturn(new PodListBuilder().build()).once();\n        mock.services().inNamespace(\"arquillian\").list().andReturn(new ServiceListBuilder().build()).once();\n\n        Pod testPod = new PodBuilder()\n                .withNewMetadata()\n                    .withName(\"test-pod\")\n                .endMetadata()\n                .withNewSpec()\n                    .addNewContainer()\n                        .withName(\"test-container\")\n                        .withImage(\"test/image1\")\n                    .endContainer()\n                .endSpec()\n                .withNewStatus()\n                    .withPhase(\"run\")\n                .endStatus()\n                .build();\n\n        mock.pods().inNamespace(\"arquillian\").withName(\"test-pod\").get().andReturn(null).once();\n        mock.pods().inNamespace(\"arquillian\").create(EasyMock.<Pod>anyObject()).andReturn(testPod).once();\n        mock.pods().inNamespace(\"arquillian\").list().andReturn(new PodListBuilder().addToItems(testPod).build()).anyTimes();\n\n        kubernetes.set(mock.replay());\n    }","id":66961,"modified_method":"public void createClient(@Observes Configuration config) throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n        Namespace namespace = new NamespaceBuilder()\n                .withNewMetadata()\n                .withName(\"arquillian\")\n                .endMetadata()\n                .build();\n\n        mock.getMasterUrl().andReturn(new URL(\"http://mock.client:80\")).anyTimes();\n\n        mock.namespaces().withName(\"arquillian\").get().andReturn(namespace).anyTimes();\n        mock.namespaces().withName(\"arquillian\").edit().done().andReturn(namespace).anyTimes();\n\n        mock.replicationControllers().inNamespace(\"arquillian\").list().andReturn(new ReplicationControllerListBuilder().build()).once();\n        mock.pods().inNamespace(\"arquillian\").list().andReturn(new PodListBuilder().build()).once();\n        mock.services().inNamespace(\"arquillian\").list().andReturn(new ServiceListBuilder().build()).once();\n\n        Pod testPod = new PodBuilder()\n                .withNewMetadata()\n                    .withName(\"test-pod\")\n                .endMetadata()\n                .withNewSpec()\n                    .addNewContainer()\n                        .withName(\"test-container\")\n                        .withImage(\"test/image1\")\n                    .endContainer()\n                .endSpec()\n                .withNewStatus()\n                    .withPhase(\"run\")\n                .endStatus()\n                .build();\n\n        mock.pods().inNamespace(\"arquillian\").withName(\"test-pod\").get().andReturn(null).once();\n        mock.pods().inNamespace(\"arquillian\").create(EasyMock.<Pod>anyObject()).andReturn(testPod).once();\n        mock.pods().inNamespace(\"arquillian\").withName(\"test-pod\").get().andReturn(testPod).anyTimes();\n        mock.pods().inNamespace(\"arquillian\").list().andReturn(new PodListBuilder().addToItems(testPod).build()).anyTimes();\n\n        kubernetes.set(mock.replay());\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testPodListInjection() {\n        assertNotNull(podList);\n        assertEquals(1, podList.getItems().size());\n        assertEquals(\"test-pod\", podList.getItems().get(0).getMetadata().getName());\n    }","id":66962,"modified_method":"@Test\n    public void testPodListInjection() {\n        assertNotNull(podList);\n        assertEquals(1, podList.getItems().size());\n        assertEquals(\"test-pod\", podList.getItems().get(0).getMetadata().getName());\n\n        assertNotNull(pod);\n        assertEquals(\"test-pod\", pod.getMetadata().getName());\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (ReplicationController replicationController : client.replicationControllers().inNamespace(session.getNamespace()).list().getItems()) {\n            if (qualifies(replicationController, qualifiers)) {\n                return replicationController;\n            }\n        }\n        return null;\n    }","id":66963,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        String name = getReplicationControllerName(qualifiers);\n        return client.pods().inNamespace(session.getNamespace()).withName(name).get();\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private boolean qualifies(ReplicationController r, Annotation... qualifiers) {\n        for (Annotation annotation : qualifiers) {\n            if (annotation instanceof ReplicationControllerName) {\n                String id = ((ReplicationControllerName) annotation).value();\n                String rid = getName(r);\n                return id.equals(rid);\n            }\n        }\n        return false;\n    }","id":66964,"modified_method":"private String getReplicationControllerName(Annotation... qualifiers) {\n        for (Annotation annotation : qualifiers) {\n            if (annotation instanceof ReplicationControllerName) {\n                return ((ReplicationControllerName) annotation).value();\n            }\n        }\n        return null;\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private boolean qualifies(Service s, Annotation... qualifiers) {\n        for (Annotation annotation : qualifiers) {\n            if (annotation instanceof ServiceName) {\n                String id = ((ServiceName) annotation).value();\n                return id.equals(getName(s));\n            }\n        }\n        return false;\n    }","id":66965,"modified_method":"private String getServiceName(Annotation... qualifiers) {\n        for (Annotation annotation : qualifiers) {\n            if (annotation instanceof ServiceName) {\n                return ((ServiceName) annotation).value();\n            }\n        }\n        return null;\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (Service service : client.services().inNamespace(session.getNamespace()).list().getItems()) {\n            if ( qualifies(service, qualifiers) ) {\n                return service;\n            }\n        }\n        return null;\n    }","id":66966,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        String name = getServiceName(qualifiers);\n        return client.pods().inNamespace(session.getNamespace()).withName(name).get();\n    }","commit_id":"f8bed456ceb04549a55bf30c1c868204b6cf31ae","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Produces\n    @Alternative\n    public KubernetesClient getKubernetesClient() throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service1\").endMetadata()\n                        .withNewSpec()\n                            .addNewPort()\n                                .withProtocol(\"TCP\")\n                                .withPort(80)\n                                .withNewTargetPort(9090)\n                            .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                .build()\n        ).anyTimes();\n\n        //Services\n        mock.services().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service2\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(80)\n                        .withNewTargetPort(8080)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service3\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service3\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(443)\n                        .withNewTargetPort(443)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n\n        mock.services().inNamespace(\"default\").withName(\"multiport\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"multiport\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                            .withName(\"port1\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8081)\n                            .withNewTargetPort(8081)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8082)\n                            .withNewTargetPort(8082)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port3\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8083)\n                            .withNewTargetPort(8083)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        //Endpoints\n        Endpoints service1Endpoints = new EndpointsBuilder()\n                .withNewMetadata()\n                    .withName(\"service1\")\n                    .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                    .addNewPort()\n                        .withName(\"port\")\n                        .withPort(8080)\n                    .endPort()\n                    .addNewAddresse()\n                        .withIp(\"10.0.0.1\")\n                    .endAddresse()\n                .endSubset()\n                .addNewSubset()\n                    .addNewPort()\n                        .withName(\"port\")\n                        .withPort(8080)\n                    .endPort()\n                .addNewAddresse()\n                    .withIp(\"10.0.0.2\")\n                .endAddresse()\n                .endSubset()\n                .build();\n\n        Endpoints multiPortEndpoint = new EndpointsBuilder()\n                .withNewMetadata()\n                    .withName(\"multiport\")\n                .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                    .addNewAddresse()\n                        .withIp(\"172.30.17.2\")\n                    .endAddresse()\n                    .addNewPort(\"port1\", 8081, \"TCP\")\n                    .addNewPort(\"port2\", 8082, \"TCP\")\n                    .addNewPort(\"port3\", 8083, \"TCP\")\n                    .endSubset()\n                .build();\n\n\n        mock.endpoints().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                service1Endpoints\n        ).anyTimes();\n\n        mock.endpoints().inNamespace(\"default\").list().andReturn(new EndpointsListBuilder().addToItems(multiPortEndpoint, service1Endpoints).build()).anyTimes();\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenShiftClient()).anyTimes();\n\n        mock.getNamespace().andAnswer(new IAnswer<String>() {\n            @Override\n            public String answer() throws Throwable {\n                return Utils.getEnvVar(\"KUBERNETES_NAMESPACE\", null);\n            }\n        }).anyTimes();\n\n        return mock.replay();\n    }","id":66967,"modified_method":"@Produces\n    @Alternative\n    public KubernetesClient getKubernetesClient() throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service1\").endMetadata()\n                        .withNewSpec()\n                            .addNewPort()\n                                .withProtocol(\"TCP\")\n                                .withPort(80)\n                                .withNewTargetPort(9090)\n                            .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                .build()\n        ).anyTimes();\n\n        //Services\n        mock.services().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service2\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(80)\n                        .withNewTargetPort(8080)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service3\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service3\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(443)\n                        .withNewTargetPort(443)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n\n        mock.services().inNamespace(\"default\").withName(\"multiport\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"multiport\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                            .withName(\"port1\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8081)\n                            .withNewTargetPort(8081)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8082)\n                            .withNewTargetPort(8082)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port3\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8083)\n                            .withNewTargetPort(8083)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        //Endpoints\n        Endpoints service1Endpoints = new EndpointsBuilder()\n                .withNewMetadata()\n                    .withName(\"service1\")\n                    .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                    .addNewPort()\n                        .withName(\"port\")\n                        .withPort(8080)\n                    .endPort()\n                    .addNewAddresse()\n                        .withIp(\"10.0.0.1\")\n                    .endAddresse()\n                .endSubset()\n                .addNewSubset()\n                    .addNewPort()\n                        .withName(\"port\")\n                        .withPort(8080)\n                    .endPort()\n                .addNewAddresse()\n                    .withIp(\"10.0.0.2\")\n                .endAddresse()\n                .endSubset()\n                .build();\n\n        Endpoints service2EndpointsA = new EndpointsBuilder()\n                .withNewMetadata()\n                .withName(\"service2\")\n                .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                .addNewPort()\n                .withName(\"port\")\n                .withPort(8080)\n                .endPort()\n                .addNewAddresse()\n                .withIp(\"10.0.0.1\")\n                .endAddresse()\n                .endSubset()\n                .addNewSubset()\n                .addNewPort()\n                .withName(\"port\")\n                .withPort(8080)\n                .endPort()\n                .addNewAddresse()\n                .withIp(\"10.0.0.2\")\n                .endAddresse()\n                .endSubset()\n                .build();\n\n        Endpoints service2EndpointsB = new EndpointsBuilder()\n                .withNewMetadata()\n                .withName(\"service2\")\n                .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                .addNewPort()\n                .withName(\"port\")\n                .withPort(8080)\n                .endPort()\n                .addNewAddresse()\n                .withIp(\"10.0.0.1\")\n                .endAddresse()\n                .endSubset()\n                .build();\n\n        Endpoints multiPortEndpoint = new EndpointsBuilder()\n                .withNewMetadata()\n                    .withName(\"multiport\")\n                .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                    .addNewAddresse()\n                        .withIp(\"172.30.17.2\")\n                    .endAddresse()\n                    .addNewPort(\"port1\", 8081, \"TCP\")\n                    .addNewPort(\"port2\", 8082, \"TCP\")\n                    .addNewPort(\"port3\", 8083, \"TCP\")\n                    .endSubset()\n                .build();\n\n\n        mock.endpoints().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                service1Endpoints\n        ).anyTimes();\n\n        mock.endpoints().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                service2EndpointsA\n        ).once();\n\n        mock.endpoints().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                service2EndpointsB\n        ).anyTimes();\n\n        mock.endpoints().inNamespace(\"default\").withName(\"multiport\").get().andReturn(\n                multiPortEndpoint\n        ).anyTimes();\n\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenShiftClient()).anyTimes();\n\n        mock.getNamespace().andAnswer(new IAnswer<String>() {\n            @Override\n            public String answer() throws Throwable {\n                return Utils.getEnvVar(\"KUBERNETES_NAMESPACE\", null);\n            }\n        }).anyTimes();\n\n        return mock.replay();\n    }","commit_id":"a8c3f5692631818aa04a5f037a047bed9a3dd5b9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public String produce(CreationalContext<String> ctx) {\n        if (serviceId == null) {\n            throw new IllegalArgumentException(\"No service id has been specified.\");\n        }\n        return Services.toServiceEndpointUrl(serviceId, serviceProtocol, servicePort).iterator().next();\n    }","id":66968,"modified_method":"@Override\n    public String produce(CreationalContext<String> ctx) {\n        if (serviceId == null) {\n            throw new IllegalArgumentException(\"No service id has been specified.\");\n        }\n\n        List<String> endpoints = Services.toServiceEndpointUrl(serviceId, serviceProtocol, servicePort);\n        if (endpoints == null || endpoints.isEmpty()) {\n            return null;\n        } else {\n            return endpoints.get(0);\n        }\n    }","commit_id":"a8c3f5692631818aa04a5f037a047bed9a3dd5b9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Class<? extends Annotation> getScope() {\n        return Singleton.class;\n    }","id":66969,"modified_method":"@Override\n    public Class<? extends Annotation> getScope() {\n        return Dependent.class;\n    }","commit_id":"a8c3f5692631818aa04a5f037a047bed9a3dd5b9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static List<String> toServiceEndpointUrl(String serviceId, String serviceProtocol, String servicePort) {\n        List<String> endpoints = new ArrayList<>();\n        KubernetesClient client = KubernetesHolder.getClient();\n        String namespace = client.getNamespace();\n        String actualProtocol = serviceProtocol != null ? serviceProtocol : DEFAULT_PROTO;\n        \n        for (io.fabric8.kubernetes.api.model.Endpoints item : KubernetesHolder.getClient().endpoints().inNamespace(namespace).list().getItems()) {\n            if (item.getMetadata().getName().equals(serviceId) && (namespace == null || namespace.equals(item.getMetadata().getNamespace()))) {\n                for (EndpointSubset subset : item.getSubsets()) {\n                    for (EndpointAddress address : subset.getAddresses()) {\n                        for (EndpointPort endpointPort : subset.getPorts()) {\n                            if (servicePort == null || servicePort.equals(endpointPort.getName())) {\n                                endpoints.add(actualProtocol + \"://\" + address.getIp() + \":\" + endpointPort.getPort());\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        return endpoints;\n    }","id":66970,"modified_method":"public static List<String> toServiceEndpointUrl(String serviceId, String serviceProtocol, String servicePort) {\n        List<String> endpoints = new ArrayList<>();\n        KubernetesClient client = KubernetesHolder.getClient();\n        String namespace = client.getNamespace();\n        String actualProtocol = serviceProtocol != null ? serviceProtocol : DEFAULT_PROTO;\n\n        Endpoints item = KubernetesHolder.getClient().endpoints().inNamespace(namespace).withName(serviceId).get();\n        if (item != null) {\n            for (EndpointSubset subset : item.getSubsets()) {\n                for (EndpointAddress address : subset.getAddresses()) {\n                    for (EndpointPort endpointPort : subset.getPorts()) {\n                        if (servicePort == null || servicePort.equals(endpointPort.getName())) {\n                            endpoints.add(actualProtocol + \"://\" + address.getIp() + \":\" + endpointPort.getPort());\n                        }\n                    }\n                }\n            }\n        }\n        return endpoints;\n    }","commit_id":"a8c3f5692631818aa04a5f037a047bed9a3dd5b9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public boolean processPropertiesFiles(@NotNull final GlobalSearchScope searchScope,\n                                        @NotNull final PropertiesFileProcessor processor,\n                                        @NotNull final BundleNameEvaluator evaluator) {\n\n    boolean result = FileBasedIndex.getInstance()\n      .processValues(FileTypeIndex.NAME, PropertiesFileType.INSTANCE, null, new FileBasedIndex.ValueProcessor<Void>() {\n        public boolean process(VirtualFile file, Void value) {\n          return processFile(file, evaluator, processor);\n        }\n      }, searchScope);\n    if (!result) return false;\n\n    return myDumbService.isDumb() || FileBasedIndex.getInstance()\n      .processValues(XmlPropertiesIndex.NAME, XmlPropertiesIndex.MARKER_KEY, null, new FileBasedIndex.ValueProcessor<String>() {\n        public boolean process(VirtualFile file, String value) {\n          return processFile(file, evaluator, processor);\n        }\n      }, searchScope);\n  }","id":66971,"modified_method":"public boolean processPropertiesFiles(@NotNull final GlobalSearchScope searchScope,\n                                        @NotNull final PropertiesFileProcessor processor,\n                                        @NotNull final BundleNameEvaluator evaluator) {\n    for(VirtualFile file:FileBasedIndex.getInstance().getContainingFiles(FileTypeIndex.NAME, PropertiesFileType.INSTANCE, searchScope)) {\n      if (!processFile(file, evaluator, processor)) return false;\n    }\n    if (!myDumbService.isDumb()) {\n      for(VirtualFile file:FileBasedIndex.getInstance().getContainingFiles(XmlPropertiesIndex.NAME, XmlPropertiesIndex.MARKER_KEY, searchScope)) {\n        if (!processFile(file, evaluator, processor)) return false;\n      }\n    }\n\n    return true;\n  }","commit_id":"75da42e45c00d3a015484f601655ce28fca32b49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static NavigationItem[] getSymbolsByName(final String name, Project project, boolean includeNonProjectItems) {\n    final GlobalSearchScope scope = includeNonProjectItems ? GlobalSearchScope.allScope(project) : GlobalSearchScope.projectScope(project);\n    final SymbolCollector processor = new SymbolCollector(name, project, scope);\n    FileBasedIndex.getInstance().processValues(NAME, name, null, processor, scope);\n    return processor.getResult();\n  }","id":66972,"modified_method":"public static NavigationItem[] getSymbolsByName(final String name, Project project, boolean includeNonProjectItems) {\n    final GlobalSearchScope scope = includeNonProjectItems ? GlobalSearchScope.allScope(project) : GlobalSearchScope.projectScope(project);\n    final Collection<NavigationItem> result = new ArrayList<NavigationItem>();\n    PsiManager psiManager = PsiManager.getInstance(project);\n\n    for(VirtualFile file:FileBasedIndex.getInstance().getContainingFiles(NAME, name, scope)) {\n      final PsiFile psiFile = psiManager.findFile(file);\n\n      if (psiFile instanceof XmlFile) {\n        final Grammar grammar = GrammarFactory.getGrammar((XmlFile)psiFile);\n\n        if (grammar != null) {\n          grammar.acceptChildren(new CommonElement.Visitor() {\n            @Override\n            public void visitDefine(Define define) {\n              if (name.equals(define.getName())) {\n                final PsiElement psi = define.getPsiElement();\n                if (psi != null) {\n                  MyNavigationItem.add((NavigationItem)define.getPsiElement(), result);\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    return result.toArray(new NavigationItem[result.size()]);\n  }","commit_id":"3f49692fdf985e9d95356d4177be21a44d4d9326","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tgetExpandoBridge().setAttributes(serviceContext);\n\t}","id":66973,"modified_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}","commit_id":"44b1b6a60bdf1ea0c427e555ad4c89f567cabe4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\tif (_expandoBridge == null) {\n\t\t\t_expandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(getCompanyId(),\n\t\t\t\t\tRatingsEntry.class.getName(), getPrimaryKey());\n\t\t}\n\n\t\treturn _expandoBridge;\n\t}","id":66974,"modified_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(getCompanyId(),\n\t\t\tRatingsEntry.class.getName(), getPrimaryKey());\n\t}","commit_id":"44b1b6a60bdf1ea0c427e555ad4c89f567cabe4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tgetExpandoBridge().setAttributes(serviceContext);\n\t}","id":66975,"modified_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}","commit_id":"44b1b6a60bdf1ea0c427e555ad4c89f567cabe4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\tif (_expandoBridge == null) {\n\t\t\t_expandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(0,\n\t\t\t\t\tRatingsStats.class.getName(), getPrimaryKey());\n\t\t}\n\n\t\treturn _expandoBridge;\n\t}","id":66976,"modified_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(0,\n\t\t\tRatingsStats.class.getName(), getPrimaryKey());\n\t}","commit_id":"44b1b6a60bdf1ea0c427e555ad4c89f567cabe4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(getCompanyId(),\n\t\t\tRatingsEntry.class.getName(), getPrimaryKey());\n\t}","id":66977,"modified_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\tif (_expandoBridge == null) {\n\t\t\t_expandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(getCompanyId(),\n\t\t\t\t\tRatingsEntry.class.getName(), getPrimaryKey());\n\t\t}\n\n\t\treturn _expandoBridge;\n\t}","commit_id":"db0e2cc9d31e33c4735d41adf08208b256ff416d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}","id":66978,"modified_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tgetExpandoBridge().setAttributes(serviceContext);\n\t}","commit_id":"db0e2cc9d31e33c4735d41adf08208b256ff416d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}","id":66979,"modified_method":"@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tgetExpandoBridge().setAttributes(serviceContext);\n\t}","commit_id":"db0e2cc9d31e33c4735d41adf08208b256ff416d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(0,\n\t\t\tRatingsStats.class.getName(), getPrimaryKey());\n\t}","id":66980,"modified_method":"@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\tif (_expandoBridge == null) {\n\t\t\t_expandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(0,\n\t\t\t\t\tRatingsStats.class.getName(), getPrimaryKey());\n\t\t}\n\n\t\treturn _expandoBridge;\n\t}","commit_id":"db0e2cc9d31e33c4735d41adf08208b256ff416d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_XmlContent_1622293396948974643(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.xml.structure.XmlElement\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            Matcher _matcher_x583g4_a1a0a0a0a0a2a0a1a3;\n            SNode element = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.xml.structure.XmlElement\", null);\n            if ((_matcher_x583g4_a1a0a0a0a0a2a0a1a3 = REGEXP_x583g4_a0a0a2a0a0a0a0a2a0a1a3.matcher(pattern)).find()) {\n              SPropertyOperations.set(element, \"tagName\", _matcher_x583g4_a1a0a0a0a0a2a0a1a3.group(1));\n            }\n            return element;\n          }\n\n          public String getMatchingText(String pattern) {\n            Matcher _matcher_x583g4_a0a1a0a0a0a2a0a1a3;\n            if ((_matcher_x583g4_a0a1a0a0a0a2a0a1a3 = REGEXP_x583g4_a0a0a1a1a0a0a0a2a0a1a3.matcher(pattern)).find()) {\n              return \"<\" + _matcher_x583g4_a0a1a0a0a0a2a0a1a3.group(1) + \">\";\n            }\n            return \"<element/>\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.xml.structure.XmlText\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode val = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.xml.structure.XmlText\", null);\n            SPropertyOperations.set(val, \"value\", pattern);\n            return val;\n          }\n\n          public String getMatchingText(String pattern) {\n            if (StringUtils.isEmpty(pattern)) {\n              return \"text\";\n            }\n            if (XmlNameUtil.isCharData(pattern)) {\n              return pattern;\n            }\n            return (pattern.startsWith(\"?\") ?\n              \":\" :\n              \"?\"\n            );\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","id":66981,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_XmlContent_1622293396948974643(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.xml.structure.XmlElement\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            Matcher _matcher_x583g4_a1a0a0a0a0a2a0a1a5;\n            SNode element = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.xml.structure.XmlElement\", null);\n            if ((_matcher_x583g4_a1a0a0a0a0a2a0a1a5 = REGEXP_x583g4_a0a0a2a0a0a0a0a2a0a1a5.matcher(pattern)).find()) {\n              SPropertyOperations.set(element, \"tagName\", _matcher_x583g4_a1a0a0a0a0a2a0a1a5.group(1));\n            }\n            return element;\n          }\n\n          public String getMatchingText(String pattern) {\n            Matcher _matcher_x583g4_a0a1a0a0a0a2a0a1a5;\n            if ((_matcher_x583g4_a0a1a0a0a0a2a0a1a5 = REGEXP_x583g4_a0a0a1a1a0a0a0a2a0a1a5.matcher(pattern)).find()) {\n              return \"<\" + _matcher_x583g4_a0a1a0a0a0a2a0a1a5.group(1) + \">\";\n            }\n            return \"<element/>\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.xml.structure.XmlText\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode val = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.xml.structure.XmlText\", null);\n            SPropertyOperations.set(val, \"value\", pattern);\n            return val;\n          }\n\n          public String getMatchingText(String pattern) {\n            if (StringUtils.isEmpty(pattern)) {\n              return \"text\";\n            }\n            if (XmlNameUtil.isCharData(pattern)) {\n              return pattern;\n            }\n            return (pattern.startsWith(\"?\") ?\n              \":\" :\n              \"?\"\n            );\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlAttribute\", \"jetbrains.mps.core.xml.structure.XmlBaseAttribute\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlBaseAttribute\"}, new String[]{\"attrName\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlBaseAttribute\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlBaseElement\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlCDATA\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"content\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlComment\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlCommentLine\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"text\"}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlContent\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlDocument\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlElement\", \"jetbrains.mps.core.xml.structure.XmlBaseElement\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlBaseElement\"}, new String[]{\"tagName\"}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlEntityRef\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"entityName\"}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlEntityRefValue\", \"jetbrains.mps.core.xml.structure.XmlValuePart\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlValuePart\"}, new String[]{\"entityName\"}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlFile\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlProcessingInstruction\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"target\", \"rawData\"}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlProlog\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"xmlVersion\"}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlText\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"value\"}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlTextValue\", \"jetbrains.mps.core.xml.structure.XmlValuePart\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlValuePart\"}, new String[]{\"text\"}, new String[]{});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlValuePart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":66982,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlAttribute\", \"jetbrains.mps.core.xml.structure.XmlBaseAttribute\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlBaseAttribute\"}, new String[]{\"attrName\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlBaseAttribute\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlBaseElement\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlCDATA\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"content\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlComment\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlCommentLine\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"text\"}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlContent\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlDocument\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlElement\", \"jetbrains.mps.core.xml.structure.XmlBaseElement\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlBaseElement\"}, new String[]{\"tagName\", \"shortEmptyNotation\"}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlEntityRef\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"entityName\"}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlEntityRefValue\", \"jetbrains.mps.core.xml.structure.XmlValuePart\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlValuePart\"}, new String[]{\"entityName\"}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlFile\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlProcessingInstruction\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"target\", \"rawData\"}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlProlog\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"xmlVersion\"}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlText\", \"jetbrains.mps.core.xml.structure.XmlContent\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlContent\"}, new String[]{\"value\"}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlTextValue\", \"jetbrains.mps.core.xml.structure.XmlValuePart\", false, new String[]{\"jetbrains.mps.core.xml.structure.XmlValuePart\"}, new String[]{\"text\"}, new String[]{});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.core.xml.structure.XmlValuePart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_isLastPositionAllowed_6999033275467334895(SNode thisNode) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getNextSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\")) {\n      SNode right = SNodeOperations.cast(SNodeOperations.getNextSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\");\n      return !(SConceptPropertyOperations.getBoolean(right, \"textLike\") || XmlContent_Behavior.call_isOneLineBlock_1622293396949044231(right));\n    }\n    return true;\n  }","id":66983,"modified_method":"public static boolean virtual_isLastPositionAllowed_6999033275467334895(SNode thisNode) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getNextSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\")) {\n      SNode right = SNodeOperations.cast(SNodeOperations.getNextSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\");\n      if (SNodeOperations.isInstanceOf(right, \"jetbrains.mps.core.xml.structure.XmlText\")) {\n        return XmlContent_Behavior.call_onNewLine_6999033275467469862(SNodeOperations.cast(right, \"jetbrains.mps.core.xml.structure.XmlText\"));\n      }\n      return !(SConceptPropertyOperations.getBoolean(right, \"textLike\"));\n    }\n    return true;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_isFirstPositionAllowed_6999033275467334890(SNode thisNode) {\n    SNode prevSibling = SNodeOperations.getPrevSibling(thisNode);\n    if (SNodeOperations.isInstanceOf(prevSibling, \"jetbrains.mps.core.xml.structure.XmlText\")) {\n      return XmlContent_Behavior.call_hasNewLineAfter_6999033275467469870(SNodeOperations.cast(prevSibling, \"jetbrains.mps.core.xml.structure.XmlText\"));\n    }\n    return !(SNodeOperations.isInstanceOf(prevSibling, \"jetbrains.mps.core.xml.structure.XmlContent\") && SConceptPropertyOperations.getBoolean(SNodeOperations.cast(prevSibling, \"jetbrains.mps.core.xml.structure.XmlContent\"), \"textLike\"));\n  }","id":66984,"modified_method":"public static boolean virtual_isFirstPositionAllowed_6999033275467334890(SNode thisNode) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getPrevSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\")) {\n      SNode left = SNodeOperations.cast(SNodeOperations.getPrevSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\");\n      if (SNodeOperations.isInstanceOf(left, \"jetbrains.mps.core.xml.structure.XmlText\")) {\n        return XmlContent_Behavior.call_hasNewLineAfter_6999033275467469870(SNodeOperations.cast(left, \"jetbrains.mps.core.xml.structure.XmlText\"));\n      }\n      return !(SConceptPropertyOperations.getBoolean(left, \"textLike\") || XmlContent_Behavior.call_isOneLineBlock_1622293396949044231(left));\n    }\n    return true;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition_91idit_a0(SNode node, EditorContext editorContext, IScope scope) {\n    return SNodeOperations.isInstanceOf(SNodeOperations.getPrevSibling(node), \"jetbrains.mps.core.xml.structure.XmlContent\") && SConceptPropertyOperations.getBoolean(SNodeOperations.cast(SNodeOperations.getPrevSibling(node), \"jetbrains.mps.core.xml.structure.XmlContent\"), \"textLike\");\n  }","id":66985,"modified_method":"private static boolean renderingCondition_91idit_a0a(SNode node, EditorContext editorContext, IScope scope) {\n    return XmlContent_Behavior.call_onNewLine_6999033275467469862(node);\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createEditorCell(EditorContext editorContext, SNode node) {\n    return this.createAlternation_91idit_a(editorContext, node);\n  }","id":66986,"modified_method":"public EditorCell createEditorCell(EditorContext editorContext, SNode node) {\n    return this.createCollection_91idit_a(editorContext, node);\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createAlternation_91idit_a(EditorContext editorContext, SNode node) {\n    boolean alternationCondition = true;\n    alternationCondition = XmlContent_Editor.renderingCondition_91idit_a0(node, editorContext, editorContext.getOperationContext().getScope());\n    EditorCell editorCell = null;\n    if (alternationCondition) {\n      editorCell = this.createCustom_91idit_a0(editorContext, node);\n    } else {\n      editorCell = this.createCustom_91idit_a0_0(editorContext, node);\n    }\n    return editorCell;\n  }","id":66987,"modified_method":"private EditorCell createAlternation_91idit_a0(EditorContext editorContext, SNode node) {\n    boolean alternationCondition = true;\n    alternationCondition = XmlContent_Editor.renderingCondition_91idit_a0a(node, editorContext, editorContext.getOperationContext().getScope());\n    EditorCell editorCell = null;\n    if (alternationCondition) {\n      editorCell = this.createCustom_91idit_a0a(editorContext, node);\n    } else {\n      editorCell = this.createCustom_91idit_a0a_0(editorContext, node);\n    }\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCustom_91idit_a0_0(final EditorContext editorContext, final SNode node) {\n    AbstractCellProvider provider = new _FunctionTypes._return_P0_E0<AbstractCellProvider>() {\n      public AbstractCellProvider invoke() {\n        return new AbstractCellProvider() {\n          public EditorCell createEditorCell(EditorContext context) {\n            EditorCell_Error result = new EditorCell_Error(editorContext, node, \"<no content>\");\n            result.getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));\n            result.getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));\n            return result;\n          }\n        };\n      }\n    }.invoke();\n    EditorCell editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"Custom_91idit_a0_0\");\n    return editorCell;\n  }","id":66988,"modified_method":"private EditorCell createCustom_91idit_a0a_0(final EditorContext editorContext, final SNode node) {\n    AbstractCellProvider provider = new _FunctionTypes._return_P0_E0<AbstractCellProvider>() {\n      public AbstractCellProvider invoke() {\n        return new AbstractCellProvider() {\n          public EditorCell createEditorCell(EditorContext context) {\n            EditorCell_Error result = new EditorCell_Error(editorContext, node, \"<no content>\");\n            result.getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));\n            result.getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));\n            return result;\n          }\n        };\n      }\n    }.invoke();\n    EditorCell editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"Custom_91idit_a0a_0\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCustom_91idit_a0(final EditorContext editorContext, final SNode node) {\n    AbstractCellProvider provider = new _FunctionTypes._return_P0_E0<AbstractCellProvider>() {\n      public AbstractCellProvider invoke() {\n        return new AbstractCellProvider() {\n          public EditorCell createEditorCell(EditorContext context) {\n            EditorCell_Error result = new EditorCell_Error(editorContext, node, \"<no content>\");\n            result.getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));\n            result.getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));\n            return result;\n          }\n        };\n      }\n    }.invoke();\n    EditorCell editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"Custom_91idit_a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n    }\n    return editorCell;\n  }","id":66989,"modified_method":"private EditorCell createCustom_91idit_a0a(final EditorContext editorContext, final SNode node) {\n    AbstractCellProvider provider = new _FunctionTypes._return_P0_E0<AbstractCellProvider>() {\n      public AbstractCellProvider invoke() {\n        return new AbstractCellProvider() {\n          public EditorCell createEditorCell(EditorContext context) {\n            EditorCell_Error result = new EditorCell_Error(editorContext, node, \"<no content>\");\n            result.getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));\n            result.getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));\n            return result;\n          }\n        };\n      }\n    }.invoke();\n    EditorCell editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"Custom_91idit_a0a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n    }\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_vc3gub_b0d0(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new XmlElement_Editor.contentListHandler_vc3gub_b0d0(node, \"content\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_content\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":66990,"modified_method":"private EditorCell createRefNodeList_vc3gub_b0a0d0(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new XmlElement_Editor.contentListHandler_vc3gub_b0a0d0(node, \"content\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_content\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_vc3gub_b0a3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new XmlElement_Editor.contentListHandler_vc3gub_b0a3a(node, \"content\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_content_1\");\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":66991,"modified_method":"private EditorCell createRefNodeList_vc3gub_b0a0a3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new XmlElement_Editor.contentListHandler_vc3gub_b0a0a3a(node, \"content\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_content_1\");\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_vc3gub_a0a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_a0a3a\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":66992,"modified_method":"private EditorCell createConstant_vc3gub_a0a0a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_a0a0a3a\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_vc3gub_c0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"<\/\");\n    editorCell.setCellId(\"Constant_vc3gub_c0d0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":66993,"modified_method":"private EditorCell createConstant_vc3gub_c0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_c0d0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_vc3gub_a3a_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a3a_0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n    }\n    editorCell.addEditorCell(this.createCollection_vc3gub_a0d0(editorContext, node));\n    return editorCell;\n  }","id":66994,"modified_method":"private EditorCell createCollection_vc3gub_a3a_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a3a_0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.addEditorCell(this.createAlternation_vc3gub_a0d0(editorContext, node));\n    editorCell.addEditorCell(this.createReadOnlyModelAccessor_vc3gub_b0d0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_c0d0(editorContext, node));\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_vc3gub_a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a3a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0d0(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_vc3gub_b0d0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_c0d0(editorContext, node));\n    return editorCell;\n  }","id":66995,"modified_method":"private EditorCell createCollection_vc3gub_a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a3a\");\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0d0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_b0d0(editorContext, node));\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createReadOnlyModelAccessor_vc3gub_e0(final EditorContext editorContext, final SNode node) {\n    EditorCell_Property editorCell = EditorCell_Property.create(editorContext, new ModelAccessor() {\n      public String getText() {\n        return SPropertyOperations.getString(node, \"tagName\");\n      }\n\n      public void setText(String s) {\n      }\n\n      public boolean isValidText(String s) {\n        return EqualUtil.equals(s, this.getText());\n      }\n    }, node);\n    editorCell.setAction(CellActionType.DELETE, new CellAction_Empty());\n    editorCell.setCellId(\"ReadOnlyModelAccessor_vc3gub_e0\");\n    XmlSS_StyleSheet.getXmlTagName(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, false);\n      style.set(StyleAttributes.SELECTABLE, true);\n    }\n    return editorCell;\n  }","id":66996,"modified_method":"private EditorCell createReadOnlyModelAccessor_vc3gub_b0d0(final EditorContext editorContext, final SNode node) {\n    EditorCell_Property editorCell = EditorCell_Property.create(editorContext, new ModelAccessor() {\n      public String getText() {\n        return SPropertyOperations.getString(node, \"tagName\");\n      }\n\n      public void setText(String s) {\n      }\n\n      public boolean isValidText(String s) {\n        return EqualUtil.equals(s, this.getText());\n      }\n    }, node);\n    editorCell.setAction(CellActionType.DELETE, new CellAction_Empty());\n    editorCell.setCellId(\"ReadOnlyModelAccessor_vc3gub_b0d0\");\n    XmlSS_StyleSheet.getXmlTagName(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, false);\n      style.set(StyleAttributes.SELECTABLE, true);\n    }\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_vc3gub_a0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_a0d0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":66997,"modified_method":"private EditorCell createConstant_vc3gub_a0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"/\");\n    editorCell.setCellId(\"Constant_vc3gub_a0d0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    delete_XmlElement_shortNotation.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_vc3gub_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_vc3gub_b0(editorContext, node));\n    if (renderingCondition_vc3gub_a2a(node, editorContext, editorContext.getOperationContext().getScope())) {\n      editorCell.addEditorCell(this.createCollection_vc3gub_c0(editorContext, node));\n    }\n    editorCell.addEditorCell(this.createAlternation_vc3gub_d0(editorContext, node));\n    editorCell.addEditorCell(this.createReadOnlyModelAccessor_vc3gub_e0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_f0(editorContext, node));\n    return editorCell;\n  }","id":66998,"modified_method":"private EditorCell createCollection_vc3gub_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_vc3gub_b0(editorContext, node));\n    if (renderingCondition_vc3gub_a2a(node, editorContext, editorContext.getOperationContext().getScope())) {\n      editorCell.addEditorCell(this.createCollection_vc3gub_c0(editorContext, node));\n    }\n    editorCell.addEditorCell(this.createAlternation_vc3gub_d0(editorContext, node));\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_vc3gub_c0a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"<\/\");\n    editorCell.setCellId(\"Constant_vc3gub_c0a3a\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":66999,"modified_method":"private EditorCell createConstant_vc3gub_c0a0a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"<\/\");\n    editorCell.setCellId(\"Constant_vc3gub_c0a0a3a\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"}]