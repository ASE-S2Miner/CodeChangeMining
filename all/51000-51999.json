[{"original_method":"public static void paidOutAndIn(PosScreen pos, String type) {\n        if (!mgrLoggedIn) {\n            pos.showDialog(\"dialog/error/mgrnotloggedin\");\n            return;\n        }\n        \n        PosTransaction trans = PosTransaction.getCurrentTx(pos.getSession());\n        if (!trans.isOpen()) {\n            pos.showDialog(\"dialog/error/terminalclosed\");\n            return;\n        }\n        Output output = pos.getOutput();\n        Input input = pos.getInput(); \n        if (input.isFunctionSet(\"PAID_\" + type)) {\n            String[] func = input.getFunction(\"PAID_\" + type);\n            String lastValue = input.value();\n            if (UtilValidate.isNotEmpty(lastValue)) {\n                String[] paidInfo = new String[0];\n                switch (func[1].split(\"\\\\|\").length) {\n                    case 1:\n                        try {\n                            double dbl = Double.parseDouble(lastValue);\n                            dbl = dbl / 100;\n                            lastValue = UtilFormatOut.formatPrice(dbl);\n                        } catch (NumberFormatException e) {\n                            Debug.logError(e, module);\n                        }\n                        func[1] = func[1] + \"|\";\n                        func[1] = func[1] + lastValue;\n                        input.setFunction(\"PAID_\" + type, func[1]);\n                        output.print(UtilProperties.getMessage(\"pos\",\"ENT_COMM_\" + type, Locale.getDefault()));\n                        break;                        \n                    case 2:\n                        func[1] = func[1] + \"|\";\n                        func[1] = func[1] + lastValue;\n                        paidInfo = func[1].split(\"\\\\|\");            \n                        GenericValue internTx = pos.getSession().getDelegator().makeValue(\"PosTerminalInternTx\", null);\n                        internTx.set(\"posTerminalLogId\", trans.getTerminalLogId());                        \n                        try\n                        {\n                            internTx.set(\"paidAmount\", new Double(priceDecimalFormat.parse(paidInfo[1]).doubleValue()));\n                        }\n                        catch (ParseException pe)\n                        {\n                            Debug.logError(pe, module);\n                        }\n                        internTx.set(\"reasonComment\", paidInfo[2]);\n                        try {\n                            internTx.create();\n                        } catch (GenericEntityException e) {\n                            Debug.logError(e, module);\n                            pos.showDialog(\"dialog/error/exception\", e.getMessage());\n                        }                        \n                        //save the TX Log \n                        trans.paidInOut(type);               \n                        NavagationEvents.showPosScreen(pos);                        \n                        break;\n                }\n            }\n        } else {\n            trans.popDrawer();\n            input.clear();\n            input.setFunction(\"PAID_\" + type);\n            output.print(UtilProperties.getMessage(\"pos\",\"ENT_\" + type, Locale.getDefault()));\n        }\n    }","id":51000,"modified_method":"public static void paidOutAndIn(PosScreen pos, String type) {\n        if (!mgrLoggedIn) {\n            pos.showDialog(\"dialog/error/mgrnotloggedin\");\n            return;\n        }\n        \n        PosTransaction trans = PosTransaction.getCurrentTx(pos.getSession());\n        if (!trans.isOpen()) {\n            pos.showDialog(\"dialog/error/terminalclosed\");\n            return;\n        }\n        \n        PaidInOut PaidInOut = new PaidInOut(trans, pos, type);\n        Map mapInOut = PaidInOut.openDlg();\n        if (null != mapInOut.get(\"amount\")) {\n            String amount = (String) mapInOut.get(\"amount\");\n            try {\n                double dbl = Double.parseDouble(amount);\n            } catch (NumberFormatException e) {\n                Debug.logError(e, module);\n                return;\n            }\n\n            GenericValue internTx = pos.getSession().getDelegator().makeValue(\"PosTerminalInternTx\", null);\n            internTx.set(\"posTerminalLogId\", trans.getTerminalLogId());                        \n            try\n            {\n                internTx.set(\"paidAmount\", new Double(priceDecimalFormat.parse(amount).doubleValue() / 100));\n            }\n            catch (ParseException pe)\n            {\n                Debug.logError(pe, module);\n                return;\n            }\n            internTx.set(\"reasonComment\", mapInOut.get(\"reason\"));\n            try {\n                internTx.create();\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n                pos.showDialog(\"dialog/error/exception\", e.getMessage());\n                return;\n            }                        \n            //save the TX Log \n            trans.paidInOut(type);               \n            NavagationEvents.showPosScreen(pos);                                    \n        }    \n    }","commit_id":"58f204c36b43080ed8701e3d83b56f8da9e1be8f","url":"https://github.com/apache/ofbiz"},{"original_method":"public void openDlg() {\r\n        XDialog dlg = (XDialog) pageMgr.loadPage(m_pos.getScreenLocation() + \"/dialog/savesale\");\r\n        m_dialog = dlg;\r\n        dlg.setModal(true);\r\n        dlg.setCaption(UtilProperties.getMessage(\"pos\", \"SaveASale\", Locale.getDefault()));\r\n        m_saleName = (XEdit) dlg.findComponent(\"saleName\");\r\n        m_saleName.setText(m_pos.session.getUserId() + \" \" + sdf.format(new Date()));\r\n\r\n        m_cancel = (XButton) dlg.findComponent(\"BtnCancel\");\r\n        m_save = (XButton) dlg.findComponent(\"BtnSave\");\r\n        m_saveAndClear = (XButton) dlg.findComponent(\"BtnSaveAndClear\");\r\n\r\n        addMouseHandler(m_cancel, \"cancel\");\r\n        addMouseHandler(m_save, \"save\");\r\n        addMouseHandler(m_saveAndClear, \"saveAndClear\");\r\n\r\n        dlg.pack();\r\n        dlg.showDialog(this);\r\n    }","id":51001,"modified_method":"public void openDlg() {\r\n        m_dialog = (XDialog) pageMgr.loadPage(m_pos.getScreenLocation() + \"/dialog/savesale\");\r\n        m_saleName = (XEdit) m_dialog.findComponent(\"saleName\");        \r\n        //m_dialog.setM_focused(m_saleName); \r\n        m_saleName.setText(m_pos.session.getUserId() + \" \" + sdf.format(new Date()));\r\n        m_dialog.setCaption(UtilProperties.getMessage(\"pos\", \"SaveASale\", Locale.getDefault()));\r\n\r\n        m_cancel = (XButton) m_dialog.findComponent(\"BtnCancel\");\r\n        m_save = (XButton) m_dialog.findComponent(\"BtnSave\");\r\n        m_saveAndClear = (XButton) m_dialog.findComponent(\"BtnSaveAndClear\");\r\n\r\n        addMouseHandler(m_cancel, \"cancel\");\r\n        addMouseHandler(m_save, \"save\");\r\n        addMouseHandler(m_saveAndClear, \"saveAndClear\");\r\n\r\n        m_dialog.pack();\r\n        m_dialog.showDialog(this);\r\n    }","commit_id":"58f204c36b43080ed8701e3d83b56f8da9e1be8f","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Centers a panel in the middle of the browser window and returns the vertical layout used for the panel contents.<p>\n     *\n     * @param width width of the panel\n     * @param height height of the panel\n     * @param caption the caption\n     * @return the layout used for panel contents\n     */\n    public VerticalLayout setCenterPanel(int width, int height, String caption) {\n\n        Panel panel = new Panel();\n        panel.setCaption(caption);\n        VerticalLayout layout = new VerticalLayout();\n        panel.setWidth(\"\" + width + \"px\");\n        panel.setHeight(\"\" + height + \"px\");\n        layout.setSizeFull();\n        VerticalLayout panelContent = new VerticalLayout();\n        panel.setContent(panelContent);\n        panelContent.setMargin(true);\n        layout.addComponent(panel);\n        layout.setComponentAlignment(panel, Alignment.MIDDLE_CENTER);\n        setContent(layout);\n        return panelContent;\n    }","id":51002,"modified_method":"/**\n     * Centers a panel in the middle of the browser window and returns the vertical layout used for the panel contents.<p>\n     *\n     * @param width width of the panel\n     * @param height height of the panel\n     * @param caption the caption\n     * @return the layout used for panel contents\n     */\n    public VerticalLayout setCenterPanel(int width, int height, String caption) {\n\n        setContent(new Label());\n        Window window = CmsBasicDialog.prepareWindow(DialogWidth.narrow);\n        CmsBasicDialog dialog = new CmsBasicDialog();\n        VerticalLayout result = new VerticalLayout();\n        dialog.setContent(result);\n        window.setContent(dialog);\n        window.setCaption(caption);\n        window.setClosable(false);\n        addWindow(window);\n        window.center();\n        return result;\n    }","commit_id":"b1fe2720e1d3906f705031bf959743224b0d254f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void checkInFileEntry(\n\t\t\tlong userId, long fileEntryId, boolean majorVersion,\n\t\t\tString changeLog, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tboolean isCheckedOut = isFileEntryCheckedOut(fileEntryId);\n\n\t\tif (!isCheckedOut) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasLock) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tString version = getNextVersion(\n\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tdlFileVersion.setVersion(version);\n\t\tdlFileVersion.setChangeLog(changeLog);\n\n\t\tdlFileVersionPersistence.update(dlFileVersion, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.DOCUMENT_LIBRARY_FOLDER_LAST_POST_DATE,\n\t\t\t\tdlFileEntry);\n\t\t}\n\n\t\t// File\n\n\t\tDLStoreUtil.updateFileVersion(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\tdlFileEntry.getName(),\n\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION, version,\n\t\t\tdlFileEntry.getTitle(), serviceContext);\n\n\t\t// Index\n\n\t\tindex(dlFileEntry, serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getGroupId(), userId,\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId(),\n\t\t\t\tdlFileVersion, serviceContext);\n\t\t}\n\n\t\tlockLocalService.unlock(DLFileEntry.class.getName(), fileEntryId);\n\t}","id":51003,"modified_method":"public void checkInFileEntry(\n\t\t\tlong userId, long fileEntryId, boolean majorVersion,\n\t\t\tString changeLog, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tString version = getNextVersion(\n\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tdlFileVersion.setVersion(version);\n\t\tdlFileVersion.setChangeLog(changeLog);\n\n\t\tdlFileVersionPersistence.update(dlFileVersion, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.DOCUMENT_LIBRARY_FOLDER_LAST_POST_DATE,\n\t\t\t\tdlFileEntry);\n\t\t}\n\n\t\t// File\n\n\t\tDLStoreUtil.updateFileVersion(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\tdlFileEntry.getName(),\n\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION, version,\n\t\t\tdlFileEntry.getTitle(), serviceContext);\n\n\t\t// Index\n\n\t\tindex(dlFileEntry, serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getGroupId(), userId,\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId(),\n\t\t\t\tdlFileVersion, serviceContext);\n\t\t}\n\n\t\tlockLocalService.unlock(DLFileEntry.class.getName(), fileEntryId);\n\t}","commit_id":"4bad984e33e706320ae17f47e304c739e0271345","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFileEntry(long userId, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tif (!hasLock) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\tdeleteFileEntry(fileEntryId);\n\t\t}\n\t\tfinally {\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\t}","id":51004,"modified_method":"public void deleteFileEntry(long userId, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\tdeleteFileEntry(fileEntryId);\n\t\t}\n\t\tfinally {\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\t}","commit_id":"4bad984e33e706320ae17f47e304c739e0271345","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void cancelCheckOut(long userId, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tboolean isCheckedOut = isFileEntryCheckedOut(fileEntryId);\n\n\t\tif (!isCheckedOut) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasLock) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tlockLocalService.unlock(DLFileEntry.class.getName(), fileEntryId);\n\t}","id":51005,"modified_method":"public void cancelCheckOut(long userId, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tlockLocalService.unlock(DLFileEntry.class.getName(), fileEntryId);\n\t}","commit_id":"4bad984e33e706320ae17f47e304c739e0271345","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tif (!hasLock) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\treturn moveFileEntryImpl(\n\t\t\t\tuserId, fileEntryId, newFolderId, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\t\tunlockFileEntry(fileEntryId);\n\t\t\t}\n\t\t}\n\t}","id":51006,"modified_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\treturn moveFileEntryImpl(\n\t\t\t\tuserId, fileEntryId, newFolderId, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\t\tunlockFileEntry(fileEntryId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"4bad984e33e706320ae17f47e304c739e0271345","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doInvokeDeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tDocument document = SAXReaderUtil.read(xml, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\tgetServiceRegistrations(servletContextName);\n\n\t\tClassLoader portletClassLoader = hotDeployEvent.getContextClassLoader();\n\n\t\tinitPortalProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitLanguageProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitCustomJspDir(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\thotDeployEvent.getPluginPackage(), rootElement);\n\n\t\tinitIndexerPostProcessors(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitServices(servletContextName, portletClassLoader, rootElement);\n\n\t\tinitServletFilters(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\trootElement);\n\n\t\tinitStrutsActions(servletContextName, portletClassLoader, rootElement);\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerElements = rootElement.elements(\n\t\t\t\"model-listener\");\n\n\t\tfor (Element modelListenerElement : modelListenerElements) {\n\t\t\tString modelName = modelListenerElement.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerElement.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tservletContextName, portletClassLoader, modelName,\n\t\t\t\tmodelListenerClassName);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> eventElements = rootElement.elements(\"event\");\n\n\t\tfor (Element eventElement : eventElements) {\n\t\t\tString eventName = eventElement.elementText(\"event-type\");\n\t\t\tString eventClassName = eventElement.elementText(\"event-class\");\n\n\t\t\tinitEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader,\n\t\t\t\tserviceRegistrations);\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tDirectServletRegistryUtil.clearServlets();\n\t\tFileAvailabilityUtil.reset();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","id":51007,"modified_method":"protected void doInvokeDeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tDocument document = SAXReaderUtil.read(xml, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tClassLoader portletClassLoader = hotDeployEvent.getContextClassLoader();\n\n\t\tinitPortalProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitLanguageProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitCustomJspDir(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\thotDeployEvent.getPluginPackage(), rootElement);\n\n\t\tinitIndexerPostProcessors(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitServices(servletContextName, portletClassLoader, rootElement);\n\n\t\tinitServletFilters(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\trootElement);\n\n\t\tinitStrutsActions(servletContextName, portletClassLoader, rootElement);\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerElements = rootElement.elements(\n\t\t\t\"model-listener\");\n\n\t\tfor (Element modelListenerElement : modelListenerElements) {\n\t\t\tString modelName = modelListenerElement.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerElement.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tservletContextName, portletClassLoader, modelName,\n\t\t\t\tmodelListenerClassName);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.get(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer == null) {\n\t\t\teventsContainer = new EventsContainer();\n\n\t\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\t\t}\n\n\t\tList<Element> eventElements = rootElement.elements(\"event\");\n\n\t\tfor (Element eventElement : eventElements) {\n\t\t\tString eventName = eventElement.elementText(\"event-type\");\n\t\t\tString eventClassName = eventElement.elementText(\"event-class\");\n\n\t\t\tObject obj = initEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\tif (obj != null) {\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tDirectServletRegistryUtil.clearServlets();\n\t\tFileAvailabilityUtil.reset();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","commit_id":"a3167bef33073932cf98a51d15547bbeb932c779","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initEvents(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties)\n\t\tthrows Exception {\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\tgetServiceRegistrations(servletContextName);\n\n\t\tfor (Map.Entry<Object, Object> entry : portalProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\n\t\t\tif (!key.equals(APPLICATION_STARTUP_EVENTS) &&\n\t\t\t\t!_propsKeysEvents.contains(key) &&\n\t\t\t\t!_propsKeysSessionEvents.contains(key)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString eventName = key;\n\t\t\tString[] eventClassNames = StringUtil.split(\n\t\t\t\t(String)entry.getValue());\n\n\t\t\tfor (String eventClassName : eventClassNames) {\n\t\t\t\tinitEvent(\n\t\t\t\t\teventName, eventClassName, portletClassLoader,\n\t\t\t\t\tserviceRegistrations);\n\t\t\t}\n\t\t}\n\t}","id":51008,"modified_method":"protected void initEvents(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties)\n\t\tthrows Exception {\n\n\t\tEventsContainer eventsContainer = new EventsContainer();\n\n\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\n\t\tfor (Map.Entry<Object, Object> entry : portalProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\n\t\t\tif (!key.equals(APPLICATION_STARTUP_EVENTS) &&\n\t\t\t\t!_propsKeysEvents.contains(key) &&\n\t\t\t\t!_propsKeysSessionEvents.contains(key)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString eventName = key;\n\t\t\tString[] eventClassNames = StringUtil.split(\n\t\t\t\t(String)entry.getValue());\n\n\t\t\tfor (String eventClassName : eventClassNames) {\n\t\t\t\tObject obj = initEvent(\n\t\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\t\tif (obj == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a3167bef33073932cf98a51d15547bbeb932c779","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initEvent(\n\t\t\tString eventName, String eventClassName,\n\t\t\tClassLoader portletClassLoader,\n\t\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations)\n\t\tthrows Exception {\n\n\t\tif (eventName.equals(APPLICATION_STARTUP_EVENTS)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSimpleAction simpleAction = (SimpleAction)clazz.newInstance();\n\n\t\t\tsimpleAction = new InvokerSimpleAction(\n\t\t\t\tsimpleAction, portletClassLoader);\n\n\t\t\tLong companyId = CompanyThreadLocal.getCompanyId();\n\n\t\t\ttry {\n\t\t\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\t\t\tfor (long curCompanyId : companyIds) {\n\t\t\t\t\tCompanyThreadLocal.setCompanyId(curCompanyId);\n\n\t\t\t\t\tsimpleAction.run(\n\t\t\t\t\t\tnew String[] {String.valueOf(curCompanyId)});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCompanyThreadLocal.setCompanyId(companyId);\n\t\t\t}\n\t\t}\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tif (_propsKeysEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tAction action = (Action)clazz.newInstance();\n\n\t\t\taction = new InvokerAction(action, portletClassLoader);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(\"key\", eventName);\n\n\t\t\tServiceRegistration<LifecycleAction> serviceRegistration =\n\t\t\t\tregistry.registerService(\n\t\t\t\t\tLifecycleAction.class, action, properties);\n\n\t\t\tserviceRegistrations.put(eventClassName, serviceRegistration);\n\t\t}\n\n\t\tif (_propsKeysSessionEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSessionAction sessionAction = (SessionAction)clazz.newInstance();\n\n\t\t\tsessionAction = new InvokerSessionAction(\n\t\t\t\tsessionAction, portletClassLoader);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(\"key\", eventName);\n\n\t\t\tServiceRegistration<LifecycleAction> serviceRegistration =\n\t\t\t\tregistry.registerService(\n\t\t\t\t\tLifecycleAction.class, sessionAction, properties);\n\n\t\t\tserviceRegistrations.put(eventClassName, serviceRegistration);\n\t\t}\n\t}","id":51009,"modified_method":"protected Object initEvent(\n\t\t\tString eventName, String eventClassName,\n\t\t\tClassLoader portletClassLoader)\n\t\tthrows Exception {\n\n\t\tif (eventName.equals(APPLICATION_STARTUP_EVENTS)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSimpleAction simpleAction = (SimpleAction)clazz.newInstance();\n\n\t\t\tsimpleAction = new InvokerSimpleAction(\n\t\t\t\tsimpleAction, portletClassLoader);\n\n\t\t\tLong companyId = CompanyThreadLocal.getCompanyId();\n\n\t\t\ttry {\n\t\t\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\t\t\tfor (long curCompanyId : companyIds) {\n\t\t\t\t\tCompanyThreadLocal.setCompanyId(curCompanyId);\n\n\t\t\t\t\tsimpleAction.run(\n\t\t\t\t\t\tnew String[] {String.valueOf(curCompanyId)});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCompanyThreadLocal.setCompanyId(companyId);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_propsKeysEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tAction action = (Action)clazz.newInstance();\n\n\t\t\taction = new InvokerAction(action, portletClassLoader);\n\n\t\t\tEventsProcessorUtil.registerEvent(eventName, action);\n\n\t\t\treturn action;\n\t\t}\n\n\t\tif (_propsKeysSessionEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSessionAction sessionAction = (SessionAction)clazz.newInstance();\n\n\t\t\tsessionAction = new InvokerSessionAction(\n\t\t\t\tsessionAction, portletClassLoader);\n\n\t\t\tEventsProcessorUtil.registerEvent(eventName, sessionAction);\n\n\t\t\treturn sessionAction;\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"a3167bef33073932cf98a51d15547bbeb932c779","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doInvokeUndeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking undeploy for \" + servletContextName);\n\t\t}\n\n\t\tif (!_servletContextNames.remove(servletContextName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAuthPublicPathsContainer authPublicPathsContainer =\n\t\t\t_authPublicPathsContainerMap.remove(servletContextName);\n\n\t\tif (authPublicPathsContainer != null) {\n\t\t\tauthPublicPathsContainer.unregisterPaths();\n\t\t}\n\n\t\tAuthVerifierConfigurationContainer authVerifierConfigurationContainer =\n\t\t\t_authVerifierConfigurationContainerMap.remove(servletContextName);\n\n\t\tif (authVerifierConfigurationContainer != null) {\n\t\t\tauthVerifierConfigurationContainer.unregisterConfigurations();\n\t\t}\n\n\t\tCustomJspBag customJspBag = _customJspBagsMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (customJspBag != null) {\n\t\t\tdestroyCustomJspBag(servletContextName, customJspBag);\n\t\t}\n\n\t\tHotDeployListenersContainer hotDeployListenersContainer =\n\t\t\t_hotDeployListenersContainerMap.remove(servletContextName);\n\n\t\tif (hotDeployListenersContainer != null) {\n\t\t\thotDeployListenersContainer.unregisterHotDeployListeners();\n\t\t}\n\n\t\tIndexerPostProcessorContainer indexerPostProcessorContainer =\n\t\t\t_indexerPostProcessorContainerMap.remove(servletContextName);\n\n\t\tif (indexerPostProcessorContainer != null) {\n\t\t\tindexerPostProcessorContainer.unregisterIndexerPostProcessor();\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = _languagesContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (languagesContainer != null) {\n\t\t\tlanguagesContainer.unregisterLanguages();\n\t\t}\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.remove(servletContextName);\n\n\t\tif (modelListenersContainer != null) {\n\t\t\tmodelListenersContainer.unregisterModelListeners(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tProperties portalProperties = _portalPropertiesMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (portalProperties != null) {\n\t\t\tdestroyPortalProperties(servletContextName, portalProperties);\n\t\t}\n\n\t\tdestroyServices(servletContextName);\n\n\t\tServletFiltersContainer servletFiltersContainer =\n\t\t\t_servletFiltersContainerMap.remove(servletContextName);\n\n\t\tif (servletFiltersContainer != null) {\n\t\t\tservletFiltersContainer.unregisterFilterMappings();\n\t\t}\n\n\t\tStrutsActionsContainer strutsActionContainer =\n\t\t\t_strutsActionsContainerMap.remove(servletContextName);\n\n\t\tif (strutsActionContainer != null) {\n\t\t\tstrutsActionContainer.unregisterStrutsActions();\n\t\t}\n\n\t\tunregisterClpMessageListeners(servletContext);\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\t_serviceRegistrations.remove(servletContextName);\n\n\t\tif (serviceRegistrations != null) {\n\t\t\tfor (ServiceRegistration<?> serviceRegistration :\n\t\t\t\t\tserviceRegistrations.values()) {\n\n\t\t\t\tserviceRegistration.unregister();\n\t\t\t}\n\n\t\t\tserviceRegistrations.clear();\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Hook for \" + servletContextName + \" was unregistered\");\n\t\t}\n\t}","id":51010,"modified_method":"protected void doInvokeUndeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking undeploy for \" + servletContextName);\n\t\t}\n\n\t\tif (!_servletContextNames.remove(servletContextName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAuthPublicPathsContainer authPublicPathsContainer =\n\t\t\t_authPublicPathsContainerMap.remove(servletContextName);\n\n\t\tif (authPublicPathsContainer != null) {\n\t\t\tauthPublicPathsContainer.unregisterPaths();\n\t\t}\n\n\t\tAuthVerifierConfigurationContainer authVerifierConfigurationContainer =\n\t\t\t_authVerifierConfigurationContainerMap.remove(servletContextName);\n\n\t\tif (authVerifierConfigurationContainer != null) {\n\t\t\tauthVerifierConfigurationContainer.unregisterConfigurations();\n\t\t}\n\n\t\tCustomJspBag customJspBag = _customJspBagsMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (customJspBag != null) {\n\t\t\tdestroyCustomJspBag(servletContextName, customJspBag);\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer != null) {\n\t\t\teventsContainer.unregisterEvents();\n\t\t}\n\n\t\tHotDeployListenersContainer hotDeployListenersContainer =\n\t\t\t_hotDeployListenersContainerMap.remove(servletContextName);\n\n\t\tif (hotDeployListenersContainer != null) {\n\t\t\thotDeployListenersContainer.unregisterHotDeployListeners();\n\t\t}\n\n\t\tIndexerPostProcessorContainer indexerPostProcessorContainer =\n\t\t\t_indexerPostProcessorContainerMap.remove(servletContextName);\n\n\t\tif (indexerPostProcessorContainer != null) {\n\t\t\tindexerPostProcessorContainer.unregisterIndexerPostProcessor();\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = _languagesContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (languagesContainer != null) {\n\t\t\tlanguagesContainer.unregisterLanguages();\n\t\t}\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.remove(servletContextName);\n\n\t\tif (modelListenersContainer != null) {\n\t\t\tmodelListenersContainer.unregisterModelListeners(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tProperties portalProperties = _portalPropertiesMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (portalProperties != null) {\n\t\t\tdestroyPortalProperties(servletContextName, portalProperties);\n\t\t}\n\n\t\tdestroyServices(servletContextName);\n\n\t\tServletFiltersContainer servletFiltersContainer =\n\t\t\t_servletFiltersContainerMap.remove(servletContextName);\n\n\t\tif (servletFiltersContainer != null) {\n\t\t\tservletFiltersContainer.unregisterFilterMappings();\n\t\t}\n\n\t\tStrutsActionsContainer strutsActionContainer =\n\t\t\t_strutsActionsContainerMap.remove(servletContextName);\n\n\t\tif (strutsActionContainer != null) {\n\t\t\tstrutsActionContainer.unregisterStrutsActions();\n\t\t}\n\n\t\tunregisterClpMessageListeners(servletContext);\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\t_serviceRegistrations.remove(servletContextName);\n\n\t\tif (serviceRegistrations != null) {\n\t\t\tfor (ServiceRegistration<?> serviceRegistration :\n\t\t\t\t\tserviceRegistrations.values()) {\n\n\t\t\t\tserviceRegistration.unregister();\n\t\t\t}\n\n\t\t\tserviceRegistrations.clear();\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Hook for \" + servletContextName + \" was unregistered\");\n\t\t}\n\t}","commit_id":"a3167bef33073932cf98a51d15547bbeb932c779","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doInvokeDeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tDocument document = SAXReaderUtil.read(xml, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tClassLoader portletClassLoader = hotDeployEvent.getContextClassLoader();\n\n\t\tinitPortalProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitLanguageProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitCustomJspDir(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\thotDeployEvent.getPluginPackage(), rootElement);\n\n\t\tinitIndexerPostProcessors(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitServices(servletContextName, portletClassLoader, rootElement);\n\n\t\tinitServletFilters(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\trootElement);\n\n\t\tinitStrutsActions(servletContextName, portletClassLoader, rootElement);\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerElements = rootElement.elements(\n\t\t\t\"model-listener\");\n\n\t\tfor (Element modelListenerElement : modelListenerElements) {\n\t\t\tString modelName = modelListenerElement.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerElement.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tservletContextName, portletClassLoader, modelName,\n\t\t\t\tmodelListenerClassName);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.get(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer == null) {\n\t\t\teventsContainer = new EventsContainer();\n\n\t\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\t\t}\n\n\t\tList<Element> eventElements = rootElement.elements(\"event\");\n\n\t\tfor (Element eventElement : eventElements) {\n\t\t\tString eventName = eventElement.elementText(\"event-type\");\n\t\t\tString eventClassName = eventElement.elementText(\"event-class\");\n\n\t\t\tObject obj = initEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\tif (obj != null) {\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tDirectServletRegistryUtil.clearServlets();\n\t\tFileAvailabilityUtil.reset();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","id":51011,"modified_method":"protected void doInvokeDeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tDocument document = SAXReaderUtil.read(xml, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\tgetServiceRegistrations(servletContextName);\n\n\t\tClassLoader portletClassLoader = hotDeployEvent.getContextClassLoader();\n\n\t\tinitPortalProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitLanguageProperties(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitCustomJspDir(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\thotDeployEvent.getPluginPackage(), rootElement);\n\n\t\tinitIndexerPostProcessors(\n\t\t\tservletContextName, portletClassLoader, rootElement);\n\n\t\tinitServices(servletContextName, portletClassLoader, rootElement);\n\n\t\tinitServletFilters(\n\t\t\tservletContext, servletContextName, portletClassLoader,\n\t\t\trootElement);\n\n\t\tinitStrutsActions(servletContextName, portletClassLoader, rootElement);\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerElements = rootElement.elements(\n\t\t\t\"model-listener\");\n\n\t\tfor (Element modelListenerElement : modelListenerElements) {\n\t\t\tString modelName = modelListenerElement.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerElement.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tservletContextName, portletClassLoader, modelName,\n\t\t\t\tmodelListenerClassName);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> eventElements = rootElement.elements(\"event\");\n\n\t\tfor (Element eventElement : eventElements) {\n\t\t\tString eventName = eventElement.elementText(\"event-type\");\n\t\t\tString eventClassName = eventElement.elementText(\"event-class\");\n\n\t\t\tinitEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader,\n\t\t\t\tserviceRegistrations);\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tDirectServletRegistryUtil.clearServlets();\n\t\tFileAvailabilityUtil.reset();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","commit_id":"8e89c9d9eb02eb93033212d5fedfa80aecef5bc3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object initEvent(\n\t\t\tString eventName, String eventClassName,\n\t\t\tClassLoader portletClassLoader)\n\t\tthrows Exception {\n\n\t\tif (eventName.equals(APPLICATION_STARTUP_EVENTS)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSimpleAction simpleAction = (SimpleAction)clazz.newInstance();\n\n\t\t\tsimpleAction = new InvokerSimpleAction(\n\t\t\t\tsimpleAction, portletClassLoader);\n\n\t\t\tLong companyId = CompanyThreadLocal.getCompanyId();\n\n\t\t\ttry {\n\t\t\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\t\t\tfor (long curCompanyId : companyIds) {\n\t\t\t\t\tCompanyThreadLocal.setCompanyId(curCompanyId);\n\n\t\t\t\t\tsimpleAction.run(\n\t\t\t\t\t\tnew String[] {String.valueOf(curCompanyId)});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCompanyThreadLocal.setCompanyId(companyId);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_propsKeysEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tAction action = (Action)clazz.newInstance();\n\n\t\t\taction = new InvokerAction(action, portletClassLoader);\n\n\t\t\tEventsProcessorUtil.registerEvent(eventName, action);\n\n\t\t\treturn action;\n\t\t}\n\n\t\tif (_propsKeysSessionEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSessionAction sessionAction = (SessionAction)clazz.newInstance();\n\n\t\t\tsessionAction = new InvokerSessionAction(\n\t\t\t\tsessionAction, portletClassLoader);\n\n\t\t\tEventsProcessorUtil.registerEvent(eventName, sessionAction);\n\n\t\t\treturn sessionAction;\n\t\t}\n\n\t\treturn null;\n\t}","id":51012,"modified_method":"protected void initEvent(\n\t\t\tString eventName, String eventClassName,\n\t\t\tClassLoader portletClassLoader,\n\t\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations)\n\t\tthrows Exception {\n\n\t\tif (eventName.equals(APPLICATION_STARTUP_EVENTS)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSimpleAction simpleAction = (SimpleAction)clazz.newInstance();\n\n\t\t\tsimpleAction = new InvokerSimpleAction(\n\t\t\t\tsimpleAction, portletClassLoader);\n\n\t\t\tLong companyId = CompanyThreadLocal.getCompanyId();\n\n\t\t\ttry {\n\t\t\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\t\t\tfor (long curCompanyId : companyIds) {\n\t\t\t\t\tCompanyThreadLocal.setCompanyId(curCompanyId);\n\n\t\t\t\t\tsimpleAction.run(\n\t\t\t\t\t\tnew String[] {String.valueOf(curCompanyId)});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCompanyThreadLocal.setCompanyId(companyId);\n\t\t\t}\n\t\t}\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tif (_propsKeysEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tAction action = (Action)clazz.newInstance();\n\n\t\t\taction = new InvokerAction(action, portletClassLoader);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(\"key\", eventName);\n\n\t\t\tServiceRegistration<LifecycleAction> serviceRegistration =\n\t\t\t\tregistry.registerService(\n\t\t\t\t\tLifecycleAction.class, action, properties);\n\n\t\t\tserviceRegistrations.put(eventClassName, serviceRegistration);\n\t\t}\n\n\t\tif (_propsKeysSessionEvents.contains(eventName)) {\n\t\t\tClass<?> clazz = portletClassLoader.loadClass(eventClassName);\n\n\t\t\tSessionAction sessionAction = (SessionAction)clazz.newInstance();\n\n\t\t\tsessionAction = new InvokerSessionAction(\n\t\t\t\tsessionAction, portletClassLoader);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(\"key\", eventName);\n\n\t\t\tServiceRegistration<LifecycleAction> serviceRegistration =\n\t\t\t\tregistry.registerService(\n\t\t\t\t\tLifecycleAction.class, sessionAction, properties);\n\n\t\t\tserviceRegistrations.put(eventClassName, serviceRegistration);\n\t\t}\n\t}","commit_id":"8e89c9d9eb02eb93033212d5fedfa80aecef5bc3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doInvokeUndeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking undeploy for \" + servletContextName);\n\t\t}\n\n\t\tif (!_servletContextNames.remove(servletContextName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAuthPublicPathsContainer authPublicPathsContainer =\n\t\t\t_authPublicPathsContainerMap.remove(servletContextName);\n\n\t\tif (authPublicPathsContainer != null) {\n\t\t\tauthPublicPathsContainer.unregisterPaths();\n\t\t}\n\n\t\tAuthVerifierConfigurationContainer authVerifierConfigurationContainer =\n\t\t\t_authVerifierConfigurationContainerMap.remove(servletContextName);\n\n\t\tif (authVerifierConfigurationContainer != null) {\n\t\t\tauthVerifierConfigurationContainer.unregisterConfigurations();\n\t\t}\n\n\t\tCustomJspBag customJspBag = _customJspBagsMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (customJspBag != null) {\n\t\t\tdestroyCustomJspBag(servletContextName, customJspBag);\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer != null) {\n\t\t\teventsContainer.unregisterEvents();\n\t\t}\n\n\t\tHotDeployListenersContainer hotDeployListenersContainer =\n\t\t\t_hotDeployListenersContainerMap.remove(servletContextName);\n\n\t\tif (hotDeployListenersContainer != null) {\n\t\t\thotDeployListenersContainer.unregisterHotDeployListeners();\n\t\t}\n\n\t\tIndexerPostProcessorContainer indexerPostProcessorContainer =\n\t\t\t_indexerPostProcessorContainerMap.remove(servletContextName);\n\n\t\tif (indexerPostProcessorContainer != null) {\n\t\t\tindexerPostProcessorContainer.unregisterIndexerPostProcessor();\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = _languagesContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (languagesContainer != null) {\n\t\t\tlanguagesContainer.unregisterLanguages();\n\t\t}\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.remove(servletContextName);\n\n\t\tif (modelListenersContainer != null) {\n\t\t\tmodelListenersContainer.unregisterModelListeners(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tProperties portalProperties = _portalPropertiesMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (portalProperties != null) {\n\t\t\tdestroyPortalProperties(servletContextName, portalProperties);\n\t\t}\n\n\t\tdestroyServices(servletContextName);\n\n\t\tServletFiltersContainer servletFiltersContainer =\n\t\t\t_servletFiltersContainerMap.remove(servletContextName);\n\n\t\tif (servletFiltersContainer != null) {\n\t\t\tservletFiltersContainer.unregisterFilterMappings();\n\t\t}\n\n\t\tStrutsActionsContainer strutsActionContainer =\n\t\t\t_strutsActionsContainerMap.remove(servletContextName);\n\n\t\tif (strutsActionContainer != null) {\n\t\t\tstrutsActionContainer.unregisterStrutsActions();\n\t\t}\n\n\t\tunregisterClpMessageListeners(servletContext);\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\t_serviceRegistrations.remove(servletContextName);\n\n\t\tif (serviceRegistrations != null) {\n\t\t\tfor (ServiceRegistration<?> serviceRegistration :\n\t\t\t\t\tserviceRegistrations.values()) {\n\n\t\t\t\tserviceRegistration.unregister();\n\t\t\t}\n\n\t\t\tserviceRegistrations.clear();\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Hook for \" + servletContextName + \" was unregistered\");\n\t\t}\n\t}","id":51013,"modified_method":"protected void doInvokeUndeploy(HotDeployEvent hotDeployEvent)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext = hotDeployEvent.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking undeploy for \" + servletContextName);\n\t\t}\n\n\t\tif (!_servletContextNames.remove(servletContextName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAuthPublicPathsContainer authPublicPathsContainer =\n\t\t\t_authPublicPathsContainerMap.remove(servletContextName);\n\n\t\tif (authPublicPathsContainer != null) {\n\t\t\tauthPublicPathsContainer.unregisterPaths();\n\t\t}\n\n\t\tAuthVerifierConfigurationContainer authVerifierConfigurationContainer =\n\t\t\t_authVerifierConfigurationContainerMap.remove(servletContextName);\n\n\t\tif (authVerifierConfigurationContainer != null) {\n\t\t\tauthVerifierConfigurationContainer.unregisterConfigurations();\n\t\t}\n\n\t\tCustomJspBag customJspBag = _customJspBagsMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (customJspBag != null) {\n\t\t\tdestroyCustomJspBag(servletContextName, customJspBag);\n\t\t}\n\n\t\tHotDeployListenersContainer hotDeployListenersContainer =\n\t\t\t_hotDeployListenersContainerMap.remove(servletContextName);\n\n\t\tif (hotDeployListenersContainer != null) {\n\t\t\thotDeployListenersContainer.unregisterHotDeployListeners();\n\t\t}\n\n\t\tIndexerPostProcessorContainer indexerPostProcessorContainer =\n\t\t\t_indexerPostProcessorContainerMap.remove(servletContextName);\n\n\t\tif (indexerPostProcessorContainer != null) {\n\t\t\tindexerPostProcessorContainer.unregisterIndexerPostProcessor();\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = _languagesContainerMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (languagesContainer != null) {\n\t\t\tlanguagesContainer.unregisterLanguages();\n\t\t}\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.remove(servletContextName);\n\n\t\tif (modelListenersContainer != null) {\n\t\t\tmodelListenersContainer.unregisterModelListeners(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tProperties portalProperties = _portalPropertiesMap.remove(\n\t\t\tservletContextName);\n\n\t\tif (portalProperties != null) {\n\t\t\tdestroyPortalProperties(servletContextName, portalProperties);\n\t\t}\n\n\t\tdestroyServices(servletContextName);\n\n\t\tServletFiltersContainer servletFiltersContainer =\n\t\t\t_servletFiltersContainerMap.remove(servletContextName);\n\n\t\tif (servletFiltersContainer != null) {\n\t\t\tservletFiltersContainer.unregisterFilterMappings();\n\t\t}\n\n\t\tStrutsActionsContainer strutsActionContainer =\n\t\t\t_strutsActionsContainerMap.remove(servletContextName);\n\n\t\tif (strutsActionContainer != null) {\n\t\t\tstrutsActionContainer.unregisterStrutsActions();\n\t\t}\n\n\t\tunregisterClpMessageListeners(servletContext);\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\t_serviceRegistrations.remove(servletContextName);\n\n\t\tif (serviceRegistrations != null) {\n\t\t\tfor (ServiceRegistration<?> serviceRegistration :\n\t\t\t\t\tserviceRegistrations.values()) {\n\n\t\t\t\tserviceRegistration.unregister();\n\t\t\t}\n\n\t\t\tserviceRegistrations.clear();\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Hook for \" + servletContextName + \" was unregistered\");\n\t\t}\n\t}","commit_id":"8e89c9d9eb02eb93033212d5fedfa80aecef5bc3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initEvents(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties)\n\t\tthrows Exception {\n\n\t\tEventsContainer eventsContainer = new EventsContainer();\n\n\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\n\t\tfor (Map.Entry<Object, Object> entry : portalProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\n\t\t\tif (!key.equals(APPLICATION_STARTUP_EVENTS) &&\n\t\t\t\t!_propsKeysEvents.contains(key) &&\n\t\t\t\t!_propsKeysSessionEvents.contains(key)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString eventName = key;\n\t\t\tString[] eventClassNames = StringUtil.split(\n\t\t\t\t(String)entry.getValue());\n\n\t\t\tfor (String eventClassName : eventClassNames) {\n\t\t\t\tObject obj = initEvent(\n\t\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\t\tif (obj == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\t}","id":51014,"modified_method":"protected void initEvents(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties)\n\t\tthrows Exception {\n\n\t\tMap<Object, ServiceRegistration<?>> serviceRegistrations =\n\t\t\tgetServiceRegistrations(servletContextName);\n\n\t\tfor (Map.Entry<Object, Object> entry : portalProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\n\t\t\tif (!key.equals(APPLICATION_STARTUP_EVENTS) &&\n\t\t\t\t!_propsKeysEvents.contains(key) &&\n\t\t\t\t!_propsKeysSessionEvents.contains(key)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString eventName = key;\n\t\t\tString[] eventClassNames = StringUtil.split(\n\t\t\t\t(String)entry.getValue());\n\n\t\t\tfor (String eventClassName : eventClassNames) {\n\t\t\t\tinitEvent(\n\t\t\t\t\teventName, eventClassName, portletClassLoader,\n\t\t\t\t\tserviceRegistrations);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8e89c9d9eb02eb93033212d5fedfa80aecef5bc3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NotNull\n    @Override\n    protected List<? extends ThreesideDiffChangeBase> getChanges() {\n      return ThreesideTextDiffViewerEx.this.getChanges();\n    }","id":51015,"modified_method":"@NotNull\n    @Override\n    protected List<? extends ThreesideDiffChangeBase> getChanges() {\n      List<? extends ThreesideDiffChangeBase> changes = ThreesideTextDiffViewerEx.this.getChanges();\n      final ThreeSide currentSide = getCurrentSide();\n      if (currentSide == ThreeSide.BASE) return changes;\n      return ContainerUtil.filter(changes, new Condition<ThreesideDiffChangeBase>() {\n        @Override\n        public boolean value(ThreesideDiffChangeBase change) {\n          return change.isChange(currentSide);\n        }\n      });\n    }","commit_id":"473e1c2c9941c536d15e9cfd57f93804c76de5f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public List<Change> getCurrentDisplayedChanges() {\n    return myChangesToDisplay != null\n           ? sortChanges(ContainerUtil.newArrayList(myChangesToDisplay))\n           : super.getCurrentDisplayedChanges();\n  }","id":51016,"modified_method":"@NotNull\n  @Override\n  public List<Change> getCurrentDisplayedChanges() {\n    return myChangesToDisplay != null ? sortChanges(myChangesToDisplay) : super.getCurrentDisplayedChanges();\n  }","commit_id":"b0d66131e16aef305b95b319f7fef2d2f8e22570","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public abstract List<T> getCurrentDisplayedObjects();","id":51017,"modified_method":"@NotNull\n  protected List<Change> sortChanges(@NotNull Collection<Change> changes) {\n    List<Change> result;\n    try {\n      result = ContainerUtil.sorted(changes, ChangesComparator.getInstance(myViewer.isShowFlatten()));\n    }\n    catch (IllegalArgumentException e) {\n      result = ContainerUtil.newArrayList(changes);\n      LOG.error(\"Couldn't sort these changes: \" + changes, e);\n    }\n    return result;\n  }","commit_id":"b0d66131e16aef305b95b319f7fef2d2f8e22570","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<Change> getCurrentDisplayedChanges() {\n    final List<Change> list;\n    if (mySelectedChangeList != null) {\n      list = new ArrayList<Change>(mySelectedChangeList.getChanges());\n    }\n    else {\n      list = Collections.emptyList();\n    }\n    return sortChanges(list);\n  }","id":51018,"modified_method":"@NotNull\n  public List<Change> getCurrentDisplayedChanges() {\n    return mySelectedChangeList != null ? sortChanges(mySelectedChangeList.getChanges()) : Collections.<Change>emptyList();\n  }","commit_id":"b0d66131e16aef305b95b319f7fef2d2f8e22570","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doMove(final MPSProject project, final Map<SNodeReference, NodeLocation> moveMap, final Runnable callBack) {\n\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (IMapping<SNodeReference, NodeLocation> moving : MapSequence.fromMap(moveMap)) {\n          SNode node = resolveNode(moving.key(), project);\n          if (!(moving.value().canInsert(project.getRepository(), node))) {\n            throw new IllegalArgumentException();\n          }\n        }\n      }\n    });\n\n    Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> changes = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>());\n    for (MoveNodeRefactoringParticipant<?, ?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).toListSequence()) {\n      Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> participantChanges = MapSequence.fromMap(new HashMap<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>());\n      MapSequence.fromMap(changes).put(participant, participantChanges);\n      for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n        MapSequence.fromMap(participantChanges).put(nodeRef, getChangesFromModel(participant, resolveNode(nodeRef, project), project));\n      }\n    }\n\n    List<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>> changesAsList = MapSequence.fromMap(changes).where(new IWhereFilter<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>>() {\n      public boolean accept(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> it) {\n        return MapSequence.fromMap(it.value()).isNotEmpty();\n      }\n    }).toListSequence();\n    List<Integer> selectedOptions = SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project), ListSequence.fromList(changesAsList).select(new ISelector<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>, String>() {\n      public String select(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> it) {\n        return it.key().getDescription();\n      }\n    }).toListSequence(), \"Select Participants\");\n\n    final Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> selectedChanges = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>());\n    for (int i : selectedOptions) {\n      IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> mapping = ListSequence.fromList(changesAsList).getElement(i);\n      MapSequence.fromMap(selectedChanges).put(mapping.key(), mapping.value());\n    }\n\n    SearchResults searchResults = new SearchResults();\n    final Map<SNodeReference, Boolean> shouldKeep = MapSequence.fromMap(new HashMap<SNodeReference, Boolean>());\n\n    for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {\n      for (IMapping<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {\n        MapSequence.fromMap(shouldKeep).put(nodeChanges.key(), false);\n        for (MoveNodesDefault.ChangeWrapper<?, ?> change : ListSequence.fromList(nodeChanges.value())) {\n          MapSequence.fromMap(shouldKeep).putValue(nodeChanges.key(), MapSequence.fromMap(shouldKeep).get(nodeChanges.key()) || (change.myChange.needsToPreserveOldNode()));\n          searchResults.add(change.myChange.getSearchResult());\n        }\n      }\n    }\n\n    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {\n      public void performAction(RefactoringViewItem refactoringViewItem) {\n        if (callBack != null) {\n          callBack.run();\n        }\n\n        Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());\n        Map<SNodeReference, SNode> nodesToMove = MapSequence.fromMap(new HashMap<SNodeReference, SNode>());\n        for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n          MapSequence.fromMap(nodesToMove).put(nodeRef, resolveNode(nodeRef, project));\n        }\n        CopyUtil.copyAndPreserveId(Sequence.fromIterable(MapSequence.fromMap(nodesToMove).values()).toListSequence(), copyMap);\n\n        for (IMapping<SNodeReference, SNode> oldNode : MapSequence.fromMap(nodesToMove)) {\n          if (!(MapSequence.fromMap(shouldKeep).get(oldNode.key()))) {\n            SNodeOperations.detachNode(oldNode.value());\n          }\n        }\n\n        RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();\n\n        for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {\n          for (IMapping<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {\n            for (MoveNodesDefault.ChangeWrapper<?, ?> change : ListSequence.fromList(nodeChanges.value())) {\n              confirmChangeFromModel(change, MapSequence.fromMap(nodesToMove).get(nodeChanges.key()), project, refactoringSession);\n            }\n          }\n        }\n        refactoringSession.commit();\n        refactoringViewItem.close();\n      }\n    }, searchResults, false, \"Move nodes\");\n  }","id":51019,"modified_method":"public static void doMove(final MPSProject project, final Map<SNodeReference, NodeLocation> moveMap, final Runnable callBack) {\n\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (IMapping<SNodeReference, NodeLocation> moving : MapSequence.fromMap(moveMap)) {\n          SNode node = resolveNode(moving.key(), project);\n          if (!(moving.value().canInsert(project.getRepository(), node))) {\n            throw new IllegalArgumentException();\n          }\n        }\n      }\n    });\n\n    Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> changes = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>>());\n    for (MoveNodeRefactoringParticipant<?, ?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).toListSequence()) {\n      Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>> participantChanges = MapSequence.fromMap(new HashMap<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>());\n      MapSequence.fromMap(changes).put(participant, participantChanges);\n      for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n        MapSequence.fromMap(participantChanges).put(nodeRef, getChangesFromModel(participant, resolveNode(nodeRef, project), project));\n      }\n    }\n\n    List<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>>> changesAsList = MapSequence.fromMap(changes).where(new IWhereFilter<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>>>() {\n      public boolean accept(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> it) {\n        return MapSequence.fromMap(it.value()).isNotEmpty();\n      }\n    }).toListSequence();\n    List<Integer> selectedOptions = SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project), ListSequence.fromList(changesAsList).select(new ISelector<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>>, String>() {\n      public String select(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> it) {\n        return it.key().getDescription();\n      }\n    }).toListSequence(), \"Select Participants\");\n\n    final Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> selectedChanges = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>>());\n    for (int i : selectedOptions) {\n      IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> mapping = ListSequence.fromList(changesAsList).getElement(i);\n      MapSequence.fromMap(selectedChanges).put(mapping.key(), mapping.value());\n    }\n\n    SearchResults searchResults = new SearchResults();\n    final Map<SNodeReference, Boolean> shouldKeep = MapSequence.fromMap(new HashMap<SNodeReference, Boolean>());\n\n    for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {\n      for (IMapping<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {\n        MapSequence.fromMap(shouldKeep).put(nodeChanges.key(), false);\n        for (MoveNodeRefactoringParticipant.MoveNodeChange<?, ?> change : ListSequence.fromList(nodeChanges.value())) {\n          MapSequence.fromMap(shouldKeep).putValue(nodeChanges.key(), MapSequence.fromMap(shouldKeep).get(nodeChanges.key()) || (change.needsToPreserveOldNode()));\n          searchResults.add(change.getSearchResult());\n        }\n      }\n    }\n\n    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {\n      public void performAction(RefactoringViewItem refactoringViewItem) {\n        if (callBack != null) {\n          callBack.run();\n        }\n\n        Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());\n        Map<SNodeReference, SNode> nodesToMove = MapSequence.fromMap(new HashMap<SNodeReference, SNode>());\n        for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n          MapSequence.fromMap(nodesToMove).put(nodeRef, resolveNode(nodeRef, project));\n        }\n        CopyUtil.copyAndPreserveId(Sequence.fromIterable(MapSequence.fromMap(nodesToMove).values()).toListSequence(), copyMap);\n\n        for (IMapping<SNodeReference, SNode> oldNode : MapSequence.fromMap(nodesToMove)) {\n          if (!(MapSequence.fromMap(shouldKeep).get(oldNode.key()))) {\n            SNodeOperations.detachNode(oldNode.value());\n          }\n        }\n\n        RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();\n\n        for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {\n          for (IMapping<SNodeReference, List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {\n            for (MoveNodeRefactoringParticipant.MoveNodeChange<?, ?> change : ListSequence.fromList(nodeChanges.value())) {\n              confirmChangeFromModel(change, MapSequence.fromMap(nodesToMove).get(nodeChanges.key()), project, refactoringSession);\n            }\n          }\n        }\n        refactoringSession.commit();\n        refactoringViewItem.close();\n      }\n    }, searchResults, false, \"Move nodes\");\n  }","commit_id":"92c8885bb8fd9ffa9e76df266fb64b73b5e9ce94","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static <I, F> List<MoveNodesDefault.ChangeWrapper<I, F>> getChangesFromModel(final MoveNodeRefactoringParticipant<I, F> participant, SNode nodeToMove, Project project) {\n    I initialDataObject = participant.getDataCollector().beforeMove(nodeToMove);\n    return ListSequence.fromList(participant.getChanges(initialDataObject, project.getRepository(), project.getScope())).select(new ISelector<RefactoringParticipant.Change<F>, MoveNodesDefault.ChangeWrapper<I, F>>() {\n      public MoveNodesDefault.ChangeWrapper<I, F> select(RefactoringParticipant.Change<F> change) {\n        MoveNodesDefault.ChangeWrapper<I, F> wrapper = new MoveNodesDefault.ChangeWrapper<I, F>();\n        wrapper.myChange = change;\n        wrapper.myParticipant = participant;\n        return wrapper;\n      }\n    }).toListSequence();\n  }","id":51020,"modified_method":"public static <I, F> List<? extends MoveNodeRefactoringParticipant.MoveNodeChange<I, F>> getChangesFromModel(MoveNodeRefactoringParticipant<I, F> participant, SNode nodeToMove, Project project) {\n    I initialDataObject = participant.getDataCollector().beforeMove(nodeToMove);\n    return participant.getChanges(initialDataObject, project.getRepository(), project.getScope());\n  }","commit_id":"92c8885bb8fd9ffa9e76df266fb64b73b5e9ce94","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static <I, F> void confirmChangeFromModel(MoveNodesDefault.ChangeWrapper<I, F> changeWrapper, SNode movedNode, Project project, RefactoringSession refactoringSession) {\n    F finalDataObject = changeWrapper.myParticipant.getDataCollector().afterMove(movedNode);\n    changeWrapper.myChange.confirm(finalDataObject, project.getRepository(), refactoringSession);\n  }","id":51021,"modified_method":"public static <I, F> void confirmChangeFromModel(RefactoringParticipant.Change<I, F, MoveNodeRefactoringParticipant<I, F>> change, SNode movedNode, Project project, RefactoringSession refactoringSession) {\n    F finalDataObject = change.getParticipant().getDataCollector().afterMove(movedNode);\n    change.confirm(finalDataObject, project.getRepository(), refactoringSession);\n  }","commit_id":"92c8885bb8fd9ffa9e76df266fb64b73b5e9ce94","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<RefactoringParticipant.Change<NamedNodeReference>> getChanges(final NamedNodeReference initialState, SRepository repository, SearchScope searchScope) {\n    {\n      final SearchScope scope = CommandUtil.createScope(searchScope);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      SNode movedNode = initialState.reference().resolve(repository);\n      Collection<SReference> usages;\n      if (movedNode != null) {\n        usages = CommandUtil.usages(CommandUtil.createConsoleScope(null, false, context), movedNode);\n      } else {\n        usages = Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SReference>() {\n          public boolean accept(SReference it) {\n            return eq_k8iioh_a0a0a0a0a0a0a0a4a0a7(it.getTargetNodeReference(), initialState.reference());\n          }\n        }).toListSequence();\n      }\n      return CollectionSequence.fromCollection(usages).select(new ISelector<SReference, RefactoringParticipant.Change<NamedNodeReference>>() {\n        public RefactoringParticipant.Change<NamedNodeReference> select(SReference ref) {\n          final SNodeReference containingNode = ref.getSourceNode().getReference();\n          final SReferenceLink role = ref.getLink();\n          final String resolveInfo = SLinkOperations.getResolveInfo(ref);\n          final SearchResult<SNode> searchResult = new SearchResult<SNode>(ref.getSourceNode(), \"reference\");\n          RefactoringParticipant.Change<NamedNodeReference> change = new RefactoringParticipant.Change<NamedNodeReference>() {\n            public SearchResult getSearchResult() {\n              return searchResult;\n            }\n            public boolean needsToPreserveOldNode() {\n              return false;\n            }\n            public void confirm(final NamedNodeReference finalState, final SRepository repository, RefactoringSession refactoringSession) {\n              refactoringSession.registerChange(new Runnable() {\n                public void run() {\n                  SNode node = containingNode.resolve(repository);\n                  node.setReference(role, jetbrains.mps.smodel.SReference.create(role, node, finalState.reference().getModelReference(), finalState.reference().getNodeId(), resolveInfo));\n                }\n              });\n            }\n          };\n          return change;\n        }\n      }).toListSequence();\n    }\n  }","id":51022,"modified_method":"public List<MoveNodeRefactoringParticipant.MoveNodeChange<NamedNodeReference, NamedNodeReference>> getChanges(final NamedNodeReference initialState, SRepository repository, SearchScope searchScope) {\n    {\n      final SearchScope scope = CommandUtil.createScope(searchScope);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      SNode movedNode = initialState.reference().resolve(repository);\n      Collection<SReference> usages;\n      if (movedNode != null) {\n        usages = CommandUtil.usages(CommandUtil.createConsoleScope(null, false, context), movedNode);\n      } else {\n        usages = Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SReference>() {\n          public boolean accept(SReference it) {\n            return eq_k8iioh_a0a0a0a0a0a0a0a4a0a7(it.getTargetNodeReference(), initialState.reference());\n          }\n        }).toListSequence();\n      }\n      return CollectionSequence.fromCollection(usages).select(new ISelector<SReference, MoveNodeRefactoringParticipant.MoveNodeChange<NamedNodeReference, NamedNodeReference>>() {\n        public MoveNodeRefactoringParticipant.MoveNodeChange<NamedNodeReference, NamedNodeReference> select(SReference ref) {\n          final SNodeReference containingNode = ref.getSourceNode().getReference();\n          final SReferenceLink role = ref.getLink();\n          final String resolveInfo = SLinkOperations.getResolveInfo(ref);\n          final SearchResult<SNode> searchResult = new SearchResult<SNode>(ref.getSourceNode(), \"reference\");\n          MoveNodeRefactoringParticipant.MoveNodeChange<NamedNodeReference, NamedNodeReference> change = new MoveNodeRefactoringParticipant.MoveNodeChange<NamedNodeReference, NamedNodeReference>() {\n            public MoveNodeRefactoringParticipant<NamedNodeReference, NamedNodeReference> getParticipant() {\n              return UpdateReferencesParticipant.this;\n            }\n            public SearchResult getSearchResult() {\n              return searchResult;\n            }\n            public boolean needsToPreserveOldNode() {\n              return false;\n            }\n            public void confirm(final NamedNodeReference finalState, final SRepository repository, RefactoringSession refactoringSession) {\n              refactoringSession.registerChange(new Runnable() {\n                public void run() {\n                  SNode node = containingNode.resolve(repository);\n                  node.setReference(role, jetbrains.mps.smodel.SReference.create(role, node, finalState.reference().getModelReference(), finalState.reference().getNodeId(), resolveInfo));\n                }\n              });\n            }\n          };\n          return change;\n        }\n      }).toListSequence();\n    }\n  }","commit_id":"92c8885bb8fd9ffa9e76df266fb64b73b5e9ce94","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<Integer> selectAuthorizedRootProjectsIds(@Nullable Integer userId, String role) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectAuthorizedRootProjectsIds(userId, role, session);\n\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":51023,"modified_method":"public Collection<Integer> selectAuthorizedRootProjectsIds(@Nullable Integer userId, String role) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectAuthorizedRootProjectsIds(userId, role, session);\n\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Set<Integer> selectAuthorizedRootProjectsIds(@Nullable Integer userId, String role, SqlSession session) {\n    String sql;\n    Map<String, Object> params = newHashMap();\n    if (userId == null) {\n      sql = \"selectAuthorizedRootProjectsIdsForAnonymous\";\n      params.put(\"role\", role);\n    } else {\n      sql = \"selectAuthorizedRootProjectsIdsForUser\";\n      params.put(\"userId\", userId);\n      params.put(\"role\", role);\n    }\n\n    return Sets.newHashSet(session.<Integer>selectList(sql, params));\n  }","id":51024,"modified_method":"public Collection<Integer> selectAuthorizedRootProjectsIds(@Nullable Integer userId, String role, SqlSession session) {\n    String sql;\n    Map<String, Object> params = newHashMap();\n    sql = \"selectAuthorizedRootProjectsIds\";\n    params.put(\"userId\", userId);\n    params.put(\"role\", role);\n\n    return session.selectList(sql, params);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_return_root_project_ids_for_user() {\n    setupData(\"should_return_root_project_ids_for_user\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Set<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // user does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","id":51025,"modified_method":"@Test\n  public void should_return_root_project_ids_for_user() {\n    setupData(\"should_return_root_project_ids_for_user\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Collection<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // user does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_return_root_project_ids_for_group() {\n    // but user is not in an authorized group\n    setupData(\"should_return_root_project_ids_for_group\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Set<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // user does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","id":51026,"modified_method":"@Test\n  public void should_return_root_project_ids_for_group() {\n    // but user is not in an authorized group\n    setupData(\"should_return_root_project_ids_for_group\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Collection<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // user does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(USER, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_return_root_project_ids_for_anonymous() {\n    setupData(\"should_return_root_project_ids_for_anonymous\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Set<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(null, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // group does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(null, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","id":51027,"modified_method":"@Test\n  public void should_return_root_project_ids_for_anonymous() {\n    setupData(\"should_return_root_project_ids_for_anonymous\");\n\n    AuthorizationDao authorization = new AuthorizationDao(getMyBatis());\n    Collection<Integer> rootProjectIds = authorization.selectAuthorizedRootProjectsIds(null, \"user\");\n\n    assertThat(rootProjectIds).containsOnly(PROJECT);\n\n    // group does not have the role \"admin\"\n    rootProjectIds = authorization.selectAuthorizedRootProjectsIds(null, \"admin\");\n    assertThat(rootProjectIds).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public IssueQueryResult find(IssueQuery query) {\n    LOG.debug(\"IssueQuery : {}\", query);\n    SqlSession sqlSession = myBatis.openSession();\n    try {\n      // 1. Select all authorized root project ids for the user\n      Collection<Integer> rootProjectIds = authorizationDao.selectAuthorizedRootProjectsIds(UserSession.get().userId(), query.requiredRole(), sqlSession);\n\n      // 2. Select the authorized ids of all the issues that match the query\n      List<IssueDto> authorizedIssues = issueDao.selectIssues(query, rootProjectIds, sqlSession);\n\n      // 3. Sort all authorized issues\n      List<IssueDto> authorizedSortedIssues = sort(authorizedIssues, query, authorizedIssues.size());\n\n      // 4. Apply pagination\n      Paging paging = Paging.create(query.pageSize(), query.pageIndex(), authorizedSortedIssues.size());\n      Set<Long> pagedIssueIds = pagedIssueIds(authorizedSortedIssues, paging);\n\n      // 5. Load issues and their related data (rules, components, projects, comments, action plans, ...) and sort then again\n      List<IssueDto> pagedIssues = issueDao.selectByIds(pagedIssueIds, sqlSession);\n      List<IssueDto> pagedSortedIssues = sort(pagedIssues, query, authorizedIssues.size());\n\n      Map<String, DefaultIssue> issuesByKey = newHashMap();\n      List<Issue> issues = newArrayList();\n      Set<Integer> ruleIds = Sets.newHashSet();\n      Set<Integer> componentIds = Sets.newHashSet();\n      Set<Integer> projectIds = Sets.newHashSet();\n      Set<String> actionPlanKeys = Sets.newHashSet();\n      Set<String> users = Sets.newHashSet();\n      for (IssueDto dto : pagedSortedIssues) {\n        DefaultIssue defaultIssue = dto.toDefaultIssue();\n        issuesByKey.put(dto.getKee(), defaultIssue);\n        issues.add(defaultIssue);\n        ruleIds.add(dto.getRuleId());\n        componentIds.add(dto.getResourceId());\n        projectIds.add(dto.getProjectId());\n        actionPlanKeys.add(dto.getActionPlanKey());\n        if (dto.getReporter() != null) {\n          users.add(dto.getReporter());\n        }\n        if (dto.getAssignee() != null) {\n          users.add(dto.getAssignee());\n        }\n      }\n      List<DefaultIssueComment> comments = issueChangeDao.selectCommentsByIssues(sqlSession, issuesByKey.keySet());\n      for (DefaultIssueComment comment : comments) {\n        DefaultIssue issue = issuesByKey.get(comment.issueKey());\n        issue.addComment(comment);\n        if (comment.userLogin() != null) {\n          users.add(comment.userLogin());\n        }\n      }\n\n      DefaultIssueQueryResult defaultIssueQueryResult = new DefaultIssueQueryResult();\n      defaultIssueQueryResult.setMaxResultsReached(authorizedIssues.size() == query.maxResults());\n      defaultIssueQueryResult.setIssues(issues)\n        .addRules(findRules(ruleIds))\n        .addComponents(findComponents(componentIds))\n        .addProjects(findProjects(projectIds))\n        .addActionPlans(findActionPlans(actionPlanKeys))\n        .addUsers(findUsers(users))\n        .setPaging(paging);\n\n      return defaultIssueQueryResult;\n    } finally {\n      MyBatis.closeQuietly(sqlSession);\n    }\n  }","id":51028,"modified_method":"public IssueQueryResult find(IssueQuery query) {\n    LOG.debug(\"IssueQuery : {}\", query);\n    SqlSession sqlSession = myBatis.openSession();\n    try {\n      // 1. Select all authorized root project ids for the user\n      Collection<Integer> rootProjectIds = authorizationDao.selectAuthorizedRootProjectsIds(UserSession.get().userId(), query.requiredRole(), sqlSession);\n\n      // 2. Select the authorized ids of all the issues that match the query\n      List<IssueDto> authorizedIssues = issueDao.selectIssues(query, UserSession.get().userId(), sqlSession);\n\n      // 3. Sort all authorized issues\n      List<IssueDto> authorizedSortedIssues = sort(authorizedIssues, query, authorizedIssues.size());\n\n      // 4. Apply pagination\n      Paging paging = Paging.create(query.pageSize(), query.pageIndex(), authorizedSortedIssues.size());\n      Set<Long> pagedIssueIds = pagedIssueIds(authorizedSortedIssues, paging);\n\n      // 5. Load issues and their related data (rules, components, projects, comments, action plans, ...) and sort then again\n      List<IssueDto> pagedIssues = issueDao.selectByIds(pagedIssueIds, sqlSession);\n      List<IssueDto> pagedSortedIssues = sort(pagedIssues, query, authorizedIssues.size());\n\n      Map<String, DefaultIssue> issuesByKey = newHashMap();\n      List<Issue> issues = newArrayList();\n      Set<Integer> ruleIds = Sets.newHashSet();\n      Set<Integer> componentIds = Sets.newHashSet();\n      Set<Integer> projectIds = Sets.newHashSet();\n      Set<String> actionPlanKeys = Sets.newHashSet();\n      Set<String> users = Sets.newHashSet();\n      for (IssueDto dto : pagedSortedIssues) {\n        DefaultIssue defaultIssue = dto.toDefaultIssue();\n        issuesByKey.put(dto.getKee(), defaultIssue);\n        issues.add(defaultIssue);\n        ruleIds.add(dto.getRuleId());\n        componentIds.add(dto.getResourceId());\n        projectIds.add(dto.getProjectId());\n        actionPlanKeys.add(dto.getActionPlanKey());\n        if (dto.getReporter() != null) {\n          users.add(dto.getReporter());\n        }\n        if (dto.getAssignee() != null) {\n          users.add(dto.getAssignee());\n        }\n      }\n      List<DefaultIssueComment> comments = issueChangeDao.selectCommentsByIssues(sqlSession, issuesByKey.keySet());\n      for (DefaultIssueComment comment : comments) {\n        DefaultIssue issue = issuesByKey.get(comment.issueKey());\n        issue.addComment(comment);\n        if (comment.userLogin() != null) {\n          users.add(comment.userLogin());\n        }\n      }\n\n      DefaultIssueQueryResult defaultIssueQueryResult = new DefaultIssueQueryResult();\n      defaultIssueQueryResult.setMaxResultsReached(authorizedIssues.size() == query.maxResults());\n      defaultIssueQueryResult.setIssues(issues)\n        .addRules(findRules(ruleIds))\n        .addComponents(findComponents(componentIds))\n        .addProjects(findProjects(projectIds))\n        .addActionPlans(findActionPlans(actionPlanKeys))\n        .addUsers(findUsers(users))\n        .setPaging(paging);\n\n      return defaultIssueQueryResult;\n    } finally {\n      MyBatis.closeQuietly(sqlSession);\n    }\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_find_paginate_result() {\n    when(authorizationDao.selectAuthorizedRootProjectsIds(anyInt(), anyString(), any(SqlSession.class)))\n      .thenReturn(newHashSet(100));\n\n    IssueQuery query = IssueQuery.builder().pageSize(1).pageIndex(1).build();\n\n    IssueDto issue1 = new IssueDto().setId(1L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    IssueDto issue2 = new IssueDto().setId(2L).setRuleId(50).setResourceId(135).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Phases.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    List<IssueDto> dtoList = newArrayList(issue1, issue2);\n    when(issueDao.selectIssues(eq(query), eq(newHashSet(100)), any(SqlSession.class))).thenReturn(dtoList);\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(dtoList);\n\n    IssueQueryResult results = finder.find(query);\n    assertThat(results.paging().offset()).isEqualTo(0);\n    assertThat(results.paging().total()).isEqualTo(2);\n    assertThat(results.paging().pages()).isEqualTo(2);\n\n    // Only one result is expected because the limit is 1\n    verify(issueDao).selectByIds(eq(newHashSet(1L)), any(SqlSession.class));\n  }","id":51029,"modified_method":"@Test\n  public void should_find_paginate_result() {\n    when(authorizationDao.selectAuthorizedRootProjectsIds(anyInt(), anyString(), any(SqlSession.class)))\n      .thenReturn(newHashSet(100));\n\n    IssueQuery query = IssueQuery.builder().pageSize(1).pageIndex(1).build();\n\n    IssueDto issue1 = new IssueDto().setId(1L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    IssueDto issue2 = new IssueDto().setId(2L).setRuleId(50).setResourceId(135).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Phases.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    List<IssueDto> dtoList = newArrayList(issue1, issue2);\n    when(issueDao.selectIssues(eq(query), anyInt(), any(SqlSession.class))).thenReturn(dtoList);\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(dtoList);\n\n    IssueQueryResult results = finder.find(query);\n    assertThat(results.paging().offset()).isEqualTo(0);\n    assertThat(results.paging().total()).isEqualTo(2);\n    assertThat(results.paging().pages()).isEqualTo(2);\n\n    // Only one result is expected because the limit is 1\n    verify(issueDao).selectByIds(eq(newHashSet(1L)), any(SqlSession.class));\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_find_issues() {\n    when(authorizationDao.selectAuthorizedRootProjectsIds(anyInt(), anyString(), any(SqlSession.class)))\n      .thenReturn(newHashSet(100));\n    IssueQuery query = IssueQuery.builder().build();\n\n    IssueDto issue1 = new IssueDto().setId(1L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    IssueDto issue2 = new IssueDto().setId(2L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    List<IssueDto> dtoList = newArrayList(issue1, issue2);\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(dtoList);\n\n    IssueQueryResult results = finder.find(query);\n    verify(issueDao).selectIssues(eq(query), eq(newHashSet(100)), any(SqlSession.class));\n\n    assertThat(results.issues()).hasSize(2);\n    Issue issue = results.issues().iterator().next();\n    assertThat(issue.componentKey()).isEqualTo(\"Action.java\");\n    assertThat(issue.projectKey()).isEqualTo(\"struts\");\n    assertThat(issue.ruleKey().toString()).isEqualTo(\"squid:AvoidCycle\");\n    assertThat(results.securityExclusions()).isFalse();\n  }","id":51030,"modified_method":"@Test\n  public void should_find_issues() {\n    when(authorizationDao.selectAuthorizedRootProjectsIds(anyInt(), anyString(), any(SqlSession.class)))\n      .thenReturn(newHashSet(100));\n    IssueQuery query = IssueQuery.builder().build();\n\n    IssueDto issue1 = new IssueDto().setId(1L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    IssueDto issue2 = new IssueDto().setId(2L).setRuleId(50).setResourceId(123).setProjectId(100)\n      .setComponentKey_unit_test_only(\"Action.java\")\n      .setProjectKey_unit_test_only(\"struts\")\n      .setRuleKey_unit_test_only(\"squid\", \"AvoidCycle\")\n      .setStatus(\"OPEN\").setResolution(\"OPEN\");\n    List<IssueDto> dtoList = newArrayList(issue1, issue2);\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(dtoList);\n\n    IssueQueryResult results = finder.find(query);\n    verify(issueDao).selectIssues(eq(query), anyInt(), any(SqlSession.class));\n\n    assertThat(results.issues()).hasSize(2);\n    Issue issue = results.issues().iterator().next();\n    assertThat(issue.componentKey()).isEqualTo(\"Action.java\");\n    assertThat(issue.projectKey()).isEqualTo(\"struts\");\n    assertThat(issue.ruleKey().toString()).isEqualTo(\"squid:AvoidCycle\");\n    assertThat(results.securityExclusions()).isFalse();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_get_empty_result_when_no_issue() {\n    grantAccessRights();\n    IssueQuery query = IssueQuery.builder().build();\n    when(issueDao.selectIssues(eq(query), anyCollection(), any(SqlSession.class))).thenReturn(Collections.<IssueDto>emptyList());\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(Collections.<IssueDto>emptyList());\n\n    IssueQueryResult results = finder.find(query);\n    assertThat(results.issues()).isEmpty();\n    assertThat(results.rules()).isEmpty();\n    assertThat(results.components()).isEmpty();\n    assertThat(results.actionPlans()).isEmpty();\n  }","id":51031,"modified_method":"@Test\n  public void should_get_empty_result_when_no_issue() {\n    grantAccessRights();\n    IssueQuery query = IssueQuery.builder().build();\n    when(issueDao.selectIssues(eq(query), anyInt(), any(SqlSession.class))).thenReturn(Collections.<IssueDto>emptyList());\n    when(issueDao.selectByIds(anyCollection(), any(SqlSession.class))).thenReturn(Collections.<IssueDto>emptyList());\n\n    IssueQueryResult results = finder.find(query);\n    assertThat(results.issues()).isEmpty();\n    assertThat(results.rules()).isEmpty();\n    assertThat(results.components()).isEmpty();\n    assertThat(results.actionPlans()).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<IssueDto> selectIssues(IssueQuery query, Collection<Integer> authorizedRootProjectIds, Integer maxResults, SqlSession session){\n    if (authorizedRootProjectIds.isEmpty()) {\n      return Collections.emptyList();\n    }\n    IssueMapper mapper = session.getMapper(IssueMapper.class);\n    List<List<Integer>> idsPartition = Lists.partition(newArrayList(authorizedRootProjectIds), 1000);\n    return mapper.selectIssues(query, idsPartition, maxResults);\n  }","id":51032,"modified_method":"private List<IssueDto> selectIssues(IssueQuery query, @Nullable Integer userId, Integer maxResults, SqlSession session){\n    IssueMapper mapper = session.getMapper(IssueMapper.class);\n    return mapper.selectIssues(query, userId, query.requiredRole(), maxResults);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * The returned IssueDto list contains only the issue id, the project id and the sort column\n   */\n  public List<IssueDto> selectIssues(IssueQuery query, Collection<Integer> authorizedRootProjectIds, SqlSession session){\n    return selectIssues(query, authorizedRootProjectIds, query.maxResults(), session);\n  }","id":51033,"modified_method":"/**\n   * The returned IssueDto list contains only the issue id and the sort column\n   */\n  public List<IssueDto> selectIssues(IssueQuery query, @Nullable Integer userId, SqlSession session){\n    return selectIssues(query, userId, query.maxResults(), session);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  List<IssueDto> selectIssues(IssueQuery query, Collection<Integer> authorizedRootProjectIds, Integer maxResult) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectIssues(query, authorizedRootProjectIds, maxResult, session);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":51034,"modified_method":"@VisibleForTesting\n  List<IssueDto> selectIssues(IssueQuery query, @Nullable Integer userId, Integer maxResult) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectIssues(query, userId, maxResult, session);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  List<IssueDto> selectIssues(IssueQuery query, Collection<Integer> authorizedRootProjectIds) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectIssues(query, authorizedRootProjectIds, Integer.MAX_VALUE, session);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":51035,"modified_method":"@VisibleForTesting\n  List<IssueDto> selectIssues(IssueQuery query) {\n    SqlSession session = mybatis.openSession();\n    try {\n      return selectIssues(query, null, Integer.MAX_VALUE, session);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_planned() {\n    setupData(\"shared\", \"should_select_by_planned\");\n\n    IssueQuery query = IssueQuery.builder().planned(true).build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().planned(false).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().planned(null).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(3);\n  }","id":51036,"modified_method":"@Test\n  public void should_select_by_planned() {\n    setupData(\"shared\", \"should_select_by_planned\");\n\n    IssueQuery query = IssueQuery.builder().planned(true).requiredRole(\"user\").build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().planned(false).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().planned(null).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(3);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_assigned() {\n    setupData(\"shared\", \"should_select_by_assigned\");\n\n    IssueQuery query = IssueQuery.builder().assigned(true).build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().assigned(false).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().assigned(null).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(3);\n  }","id":51037,"modified_method":"@Test\n  public void should_select_by_assigned() {\n    setupData(\"shared\", \"should_select_by_assigned\");\n\n    IssueQuery query = IssueQuery.builder().assigned(true).requiredRole(\"user\").build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().assigned(false).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().assigned(null).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(3);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_resolved() {\n    setupData(\"shared\", \"should_select_by_resolved\");\n\n    IssueQuery query = IssueQuery.builder().resolved(true).build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().resolved(false).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().resolved(null).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(3);\n  }","id":51038,"modified_method":"@Test\n  public void should_select_by_resolved() {\n    setupData(\"shared\", \"should_select_by_resolved\");\n\n    IssueQuery query = IssueQuery.builder().resolved(true).requiredRole(\"user\").build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(2);\n\n    query = IssueQuery.builder().resolved(false).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(1);\n\n    query = IssueQuery.builder().resolved(null).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(3);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_rules() {\n    setupData(\"shared\", \"should_select_by_rules\");\n\n    IssueQuery query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"AvoidCycle\"))).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(2);\n\n    query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"AvoidCycle\"), RuleKey.of(\"squid\", \"NullRef\"))).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(3);\n\n    query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"Other\"))).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).isEmpty();\n  }","id":51039,"modified_method":"@Test\n  public void should_select_by_rules() {\n    setupData(\"shared\", \"should_select_by_rules\");\n\n    IssueQuery query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"AvoidCycle\"))).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(2);\n\n    query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"AvoidCycle\"), RuleKey.of(\"squid\", \"NullRef\"))).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(3);\n\n    query = IssueQuery.builder().rules(newArrayList(RuleKey.of(\"squid\", \"Other\"))).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_all() {\n    setupData(\"shared\", \"should_select_all\");\n\n    IssueQuery query = IssueQuery.builder().build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(3);\n  }","id":51040,"modified_method":"@Test\n  public void should_select_all() {\n    setupData(\"shared\", \"should_select_all\");\n\n    IssueQuery query = IssueQuery.builder().requiredRole(\"user\").build();\n\n    List<IssueDto> results = dao.selectIssues(query);\n    assertThat(results).hasSize(3);\n    IssueDto issue = results.get(0);\n    assertThat(issue.getId()).isNotNull();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_issues_with_sort_column() {\n    setupData(\"shared\", \"should_select_issue_and_project_ids\");\n\n    IssueQuery query = IssueQuery.builder().sort(IssueQuery.Sort.ASSIGNEE).build();\n    List<IssueDto> results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getAssignee()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.SEVERITY).build();\n    results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getSeverity()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.STATUS).build();\n    results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getStatus()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.CREATION_DATE).build();\n    results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getIssueCreationDate()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.UPDATE_DATE).build();\n    results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getIssueUpdateDate()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.CLOSE_DATE).build();\n    results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results.get(0).getIssueCloseDate()).isNotNull();\n  }","id":51041,"modified_method":"@Test\n  public void should_select_issues_with_sort_column() {\n    setupData(\"shared\", \"should_select_issues_with_sort_column\");\n\n    IssueQuery query = IssueQuery.builder().sort(IssueQuery.Sort.ASSIGNEE).requiredRole(\"user\").build();\n    List<IssueDto> results = dao.selectIssues(query);\n    assertThat(results.get(0).getAssignee()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.SEVERITY).requiredRole(\"user\").build();\n    results = dao.selectIssues(query);\n    assertThat(results.get(0).getSeverity()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.STATUS).requiredRole(\"user\").build();\n    results = dao.selectIssues(query);\n    assertThat(results.get(0).getStatus()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.CREATION_DATE).requiredRole(\"user\").build();\n    results = dao.selectIssues(query);\n    assertThat(results.get(0).getIssueCreationDate()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.UPDATE_DATE).requiredRole(\"user\").build();\n    results = dao.selectIssues(query);\n    assertThat(results.get(0).getIssueUpdateDate()).isNotNull();\n\n    query = IssueQuery.builder().sort(IssueQuery.Sort.CLOSE_DATE).requiredRole(\"user\").build();\n    results = dao.selectIssues(query);\n    assertThat(results.get(0).getIssueCloseDate()).isNotNull();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_component_root() {\n    setupData(\"shared\", \"should_select_by_component_root\");\n\n    IssueQuery query = IssueQuery.builder().componentRoots(newArrayList(\"struts\")).build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(2);\n    assertThat(issues.get(0).getId()).isEqualTo(100);\n    assertThat(issues.get(1).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"struts-core\")).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(2);\n    assertThat(issues.get(0).getId()).isEqualTo(100);\n    assertThat(issues.get(1).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"Filter.java\")).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).hasSize(1);\n    assertThat(issues.get(0).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"not-found\")).build();\n    issues = newArrayList(dao.selectIssues(query, newArrayList(399)));\n    assertThat(issues).isEmpty();\n  }","id":51042,"modified_method":"@Test\n  public void should_select_by_component_root() {\n    setupData(\"shared\", \"should_select_by_component_root\");\n\n    IssueQuery query = IssueQuery.builder().componentRoots(newArrayList(\"struts\")).requiredRole(\"user\").build();\n    List<IssueDto> issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(2);\n    assertThat(issues.get(0).getId()).isEqualTo(100);\n    assertThat(issues.get(1).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"struts-core\")).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(2);\n    assertThat(issues.get(0).getId()).isEqualTo(100);\n    assertThat(issues.get(1).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"Filter.java\")).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).hasSize(1);\n    assertThat(issues.get(0).getId()).isEqualTo(101);\n\n    query = IssueQuery.builder().componentRoots(newArrayList(\"not-found\")).requiredRole(\"user\").build();\n    issues = newArrayList(dao.selectIssues(query));\n    assertThat(issues).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_action_plans() {\n    setupData(\"shared\", \"should_select_by_action_plans\");\n\n    IssueQuery query = IssueQuery.builder().actionPlans(newArrayList(\"ABC\")).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(2);\n\n    query = IssueQuery.builder().actionPlans(newArrayList(\"ABC\", \"DEF\")).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(3);\n\n    query = IssueQuery.builder().actionPlans(newArrayList(\"<Unkown>\")).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).isEmpty();\n  }","id":51043,"modified_method":"@Test\n  public void should_select_by_action_plans() {\n    setupData(\"shared\", \"should_select_by_action_plans\");\n\n    IssueQuery query = IssueQuery.builder().actionPlans(newArrayList(\"ABC\")).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(2);\n\n    query = IssueQuery.builder().actionPlans(newArrayList(\"ABC\", \"DEF\")).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(3);\n\n    query = IssueQuery.builder().actionPlans(newArrayList(\"<Unkown>\")).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).isEmpty();\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_by_date_creation() {\n    setupData(\"shared\", \"should_select_by_date_creation\");\n\n    IssueQuery query = IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2013-04-15\")).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(1);\n\n    query = IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2013-04-17\")).build();\n    assertThat(dao.selectIssues(query, newArrayList(399))).hasSize(2);\n  }","id":51044,"modified_method":"@Test\n  public void should_select_by_date_creation() {\n    setupData(\"shared\", \"should_select_by_date_creation\");\n\n    IssueQuery query = IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2013-04-15\")).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(1);\n\n    query = IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2013-04-17\")).requiredRole(\"user\").build();\n    assertThat(dao.selectIssues(query)).hasSize(2);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_select_issues() {\n    setupData(\"shared\", \"should_select_issue_and_project_ids\");\n\n    IssueQuery query = IssueQuery.builder().build();\n    List<IssueDto> results = dao.selectIssues(query, newArrayList(399));\n    assertThat(results).hasSize(3);\n\n    IssueDto issueDto = results.get(0);\n    assertThat(issueDto.getId()).isNotNull();\n\n    results = dao.selectIssues(query, Collections.<Integer>emptyList());\n    assertThat(results).isEmpty();\n\n    results = dao.selectIssues(query, newArrayList(399), 2);\n    assertThat(results).hasSize(2);\n  }","id":51045,"modified_method":"@Test\n  public void should_select_issues_return_limited_results() {\n    setupData(\"shared\", \"should_select_issues_return_limited_results\");\n\n    IssueQuery query = IssueQuery.builder().requiredRole(\"user\").build();\n    List<IssueDto> results = dao.selectIssues(query, null, 2);\n    assertThat(results).hasSize(2);\n  }","commit_id":"ff5894d8599987d227cb73242112a6d2e9369476","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void putNext(Tuple t) throws ExecException, IOException\n    {\n        ByteBuffer key = objToBB(t.get(0));\n        DefaultDataBag pairs = (DefaultDataBag) t.get(1);\n        ArrayList<Mutation> mutationList = new ArrayList<Mutation>();\n        CfDef cfDef = getCfDef(storeSignature);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n        try\n        {\n            for (Tuple pair : pairs)\n            {\n               Mutation mutation = new Mutation();\n               if (DataType.findType(pair.get(1)) == DataType.BAG) // supercolumn\n               {\n                   org.apache.cassandra.thrift.SuperColumn sc = new org.apache.cassandra.thrift.SuperColumn();\n                   sc.name = objToBB(pair.get(0));\n                   ArrayList<org.apache.cassandra.thrift.Column> columns = new ArrayList<org.apache.cassandra.thrift.Column>();\n                   for (Tuple subcol : (DefaultDataBag) pair.get(1))\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(subcol.get(0));\n                       column.value = objToBB(subcol.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       columns.add(column);\n                   }\n                   if (columns.isEmpty()) // a deletion\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.super_column = objToBB(pair.get(0));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       sc.columns = columns;\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.super_column = sc;\n                   }\n               }\n               else // assume column since it couldn't be anything else\n               {\n                   if (pair.get(1) == null)\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.predicate = new org.apache.cassandra.thrift.SlicePredicate();\n                       mutation.deletion.predicate.column_names = Arrays.asList(objToBB(pair.get(0)));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = marshallers.get(0).decompose((pair.get(0)));\n                       if (validators.get(column.name) == null)\n                           // Have to special case BytesType to convert DataByteArray into ByteBuffer\n                           if (marshallers.get(1) instanceof BytesType)\n                               column.value = objToBB(pair.get(1));\n                           else\n                               column.value = marshallers.get(1).decompose(pair.get(1));\n                       else\n                           column.value = validators.get(column.name).decompose(pair.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.column = column;\n                   }\n               }\n               mutationList.add(mutation);\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(e + \" Output must be (key, {(column,value)...}) for ColumnFamily or (key, {supercolumn:{(column,value)...}...}) for SuperColumnFamily\", e);\n        }\n        try\n        {\n            writer.write(key, mutationList);\n        }\n        catch (InterruptedException e)\n        {\n           throw new IOException(e);\n        }\n    }","id":51046,"modified_method":"public void putNext(Tuple t) throws ExecException, IOException\n    {\n        ByteBuffer key = objToBB(t.get(0));\n        DefaultDataBag pairs = (DefaultDataBag) t.get(1);\n        ArrayList<Mutation> mutationList = new ArrayList<Mutation>();\n        CfDef cfDef = getCfDef(storeSignature);\n        try\n        {\n            for (Tuple pair : pairs)\n            {\n               Mutation mutation = new Mutation();\n               if (DataType.findType(pair.get(1)) == DataType.BAG) // supercolumn\n               {\n                   org.apache.cassandra.thrift.SuperColumn sc = new org.apache.cassandra.thrift.SuperColumn();\n                   sc.name = objToBB(pair.get(0));\n                   ArrayList<org.apache.cassandra.thrift.Column> columns = new ArrayList<org.apache.cassandra.thrift.Column>();\n                   for (Tuple subcol : (DefaultDataBag) pair.get(1))\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(subcol.get(0));\n                       column.value = objToBB(subcol.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       columns.add(column);\n                   }\n                   if (columns.isEmpty()) // a deletion\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.super_column = objToBB(pair.get(0));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       sc.columns = columns;\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.super_column = sc;\n                   }\n               }\n               else // assume column since it couldn't be anything else\n               {\n                   if (pair.get(1) == null)\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.predicate = new org.apache.cassandra.thrift.SlicePredicate();\n                       mutation.deletion.predicate.column_names = Arrays.asList(objToBB(pair.get(0)));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(pair.get(0));\n                       column.value = objToBB(pair.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.column = column;\n                   }\n               }\n               mutationList.add(mutation);\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(e + \" Output must be (key, {(column,value)...}) for ColumnFamily or (key, {supercolumn:{(column,value)...}...}) for SuperColumnFamily\", e);\n        }\n        try\n        {\n            writer.write(key, mutationList);\n        }\n        catch (InterruptedException e)\n        {\n           throw new IOException(e);\n        }\n    }","commit_id":"9e04de6ac093925402a9e42f7cbb239c92f949ab","url":"https://github.com/apache/cassandra"},{"original_method":"private Tuple columnToTuple(ByteBuffer name, IColumn col, CfDef cfDef) throws IOException\n    {\n        Tuple pair = TupleFactory.getInstance().newTuple(2);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n\n        if (col instanceof Column)\n        {\n            // standard\n            pair.set(0, marshallers.get(0).compose(name));\n            if (validators.get(name) == null)\n                // Have to special case BytesType because compose returns a ByteBuffer\n                if (marshallers.get(1) instanceof BytesType)\n                    pair.set(1, new DataByteArray(ByteBufferUtil.getArray(col.value())));\n                else\n                    pair.set(1, marshallers.get(1).compose(col.value()));\n            else\n                pair.set(1, validators.get(name).compose(col.value()));\n            return pair;\n        }\n\n        // super\n        ArrayList<Tuple> subcols = new ArrayList<Tuple>();\n        for (IColumn subcol : col.getSubColumns())\n            subcols.add(columnToTuple(subcol.name(), subcol, cfDef));\n        \n        pair.set(1, new DefaultDataBag(subcols));\n        return pair;\n    }","id":51047,"modified_method":"private Tuple columnToTuple(ByteBuffer name, IColumn col, CfDef cfDef) throws IOException\n    {\n        Tuple pair = TupleFactory.getInstance().newTuple(2);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n\n        setTupleValue(pair, 0, marshallers.get(0).compose(name));\n        if (col instanceof Column)\n        {\n            // standard\n            if (validators.get(name) == null)\n                setTupleValue(pair, 1, marshallers.get(1).compose(col.value()));\n            else\n                setTupleValue(pair, 1, validators.get(name).compose(col.value()));\n            return pair;\n        }\n\n        // super\n        ArrayList<Tuple> subcols = new ArrayList<Tuple>();\n        for (IColumn subcol : col.getSubColumns())\n            subcols.add(columnToTuple(subcol.name(), subcol, cfDef));\n        \n        pair.set(1, new DefaultDataBag(subcols));\n        return pair;\n    }","commit_id":"9e04de6ac093925402a9e42f7cbb239c92f949ab","url":"https://github.com/apache/cassandra"},{"original_method":"private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable) throws IOException\n    {\n        logger.info(\"Scrubbing \" + sstable);\n        CompactionController controller = new CompactionController(cfs, Collections.singletonList(sstable), getDefaultGcBefore(cfs), true);\n        boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();\n\n        // Calculate the expected compacted filesize\n        String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());\n        if (compactionFileLocation == null)\n            throw new IOException(\"disk full\");\n        int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(),\n                                               (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));\n\n        // loop through each row, deserializing to check for damage.\n        // we'll also loop through the index at the same time, using the position from the index to recover if the\n        // row header (key or data size) is corrupt. (This means our position in the index file will be one row\n        // \"ahead\" of the data file.)\n        final RandomAccessReader dataFile = sstable.openDataReader(true);\n\n        String indexFilename = sstable.descriptor.filenameFor(Component.PRIMARY_INDEX);\n        RandomAccessReader indexFile = RandomAccessReader.open(new File(indexFilename), true);\n        try\n        {\n            ByteBuffer nextIndexKey = ByteBufferUtil.readWithShortLength(indexFile);\n            {\n                // throw away variable so we don't have a side effect in the assert\n                long firstRowPositionFromIndex = indexFile.readLong();\n                assert firstRowPositionFromIndex == 0 : firstRowPositionFromIndex;\n            }\n\n            // errors when creating the writer may leave empty temp files.\n            SSTableWriter writer = maybeCreateWriter(cfs, compactionFileLocation, expectedBloomFilterSize, null, Collections.singletonList(sstable));\n            SSTableReader newSstable = null;\n            executor.beginCompaction(new ScrubInfo(dataFile, sstable));\n            int goodRows = 0, badRows = 0, emptyRows = 0;\n\n            try\n            {\n                while (!dataFile.isEOF())\n                {\n                    long rowStart = dataFile.getFilePointer();\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Reading row at \" + rowStart);\n\n                    DecoratedKey key = null;\n                    long dataSize = -1;\n                    try\n                    {\n                        key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, ByteBufferUtil.readWithShortLength(dataFile));\n                        dataSize = sstable.descriptor.hasIntRowSize ? dataFile.readInt() : dataFile.readLong();\n                        if (logger.isDebugEnabled())\n                            logger.debug(String.format(\"row %s is %s bytes\", ByteBufferUtil.bytesToHex(key.key), dataSize));\n                    }\n                    catch (Throwable th)\n                    {\n                        throwIfFatal(th);\n                        // check for null key below\n                    }\n\n                    ByteBuffer currentIndexKey = nextIndexKey;\n                    long nextRowPositionFromIndex;\n                    try\n                    {\n                        nextIndexKey = indexFile.isEOF() ? null : ByteBufferUtil.readWithShortLength(indexFile);\n                        nextRowPositionFromIndex = indexFile.isEOF() ? dataFile.length() : indexFile.readLong();\n                    }\n                    catch (Throwable th)\n                    {\n                        logger.warn(\"Error reading index file\", th);\n                        nextIndexKey = null;\n                        nextRowPositionFromIndex = dataFile.length();\n                    }\n\n                    long dataStart = dataFile.getFilePointer();\n                    long dataStartFromIndex = currentIndexKey == null\n                                            ? -1\n                                            : rowStart + 2 + currentIndexKey.remaining() + (sstable.descriptor.hasIntRowSize ? 4 : 8);\n                    long dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex;\n                    assert currentIndexKey != null || indexFile.isEOF();\n                    if (logger.isDebugEnabled() && currentIndexKey != null)\n                        logger.debug(String.format(\"Index doublecheck: row %s is %s bytes\", ByteBufferUtil.bytesToHex(currentIndexKey),  dataSizeFromIndex));\n\n                    writer.mark();\n                    try\n                    {\n                        if (key == null)\n                            throw new IOError(new IOException(\"Unable to read row key from data file\"));\n                        if (dataSize > dataFile.length())\n                            throw new IOError(new IOException(\"Impossible row size \" + dataSize));\n                        SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStart, dataSize, true);\n                        AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                        if (compactedRow.isEmpty())\n                        {\n                            emptyRows++;\n                        }\n                        else\n                        {\n                            writer.append(compactedRow);\n                            goodRows++;\n                        }\n                        if (!key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex)\n                            logger.warn(\"Index file contained a different key or row size; using key from data file\");\n                    }\n                    catch (Throwable th)\n                    {\n                        throwIfFatal(th);\n                        logger.warn(\"Non-fatal error reading row (stacktrace follows)\", th);\n                        writer.resetAndTruncate();\n\n                        if (currentIndexKey != null\n                            && (key == null || !key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex || dataSize != dataSizeFromIndex))\n                        {\n                            logger.info(String.format(\"Retrying from row index; data is %s bytes starting at %s\",\n                                                      dataSizeFromIndex, dataStartFromIndex));\n                            key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, currentIndexKey);\n                            try\n                            {\n                                SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStartFromIndex, dataSizeFromIndex, true);\n                                AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                                if (compactedRow.isEmpty())\n                                {\n                                    emptyRows++;\n                                }\n                                else\n                                {\n                                    writer.append(compactedRow);\n                                    goodRows++;\n                                }\n                            }\n                            catch (Throwable th2)\n                            {\n                                throwIfFatal(th2);\n                                // Skipping rows is dangerous for counters (see CASSANDRA-2759)\n                                if (isCommutative)\n                                    throw new IOError(th2);\n\n                                logger.warn(\"Retry failed too.  Skipping to next row (retry's stacktrace follows)\", th2);\n                                writer.resetAndTruncate();\n                                dataFile.seek(nextRowPositionFromIndex);\n                                badRows++;\n                            }\n                        }\n                        else\n                        {\n                            // Skipping rows is dangerous for counters (see CASSANDRA-2759)\n                            if (isCommutative)\n                                throw new IOError(th);\n\n                            logger.warn(\"Row at \" + dataStart + \" is unreadable; skipping to next\");\n                            if (currentIndexKey != null)\n                                dataFile.seek(nextRowPositionFromIndex);\n                            badRows++;\n                        }\n                    }\n                }\n\n                if (writer.getFilePointer() > 0)\n                    newSstable = writer.closeAndOpenReader(sstable.maxDataAge);\n            }\n            finally\n            {\n                writer.cleanupIfNecessary();\n            }\n\n            if (newSstable != null)\n            {\n                cfs.replaceCompactedSSTables(Arrays.asList(sstable), Arrays.asList(newSstable));\n                logger.info(\"Scrub of \" + sstable + \" complete: \" + goodRows + \" rows in new sstable and \" + emptyRows + \" empty (tombstoned) rows dropped\");\n                if (badRows > 0)\n                    logger.warn(\"Unable to recover \" + badRows + \" rows that were skipped.  You can attempt manual recovery from the pre-scrub snapshot.  You can also run nodetool repair to transfer the data from a healthy replica, if any\");\n            }\n            else\n            {\n                cfs.markCompacted(Arrays.asList(sstable));\n                if (badRows > 0)\n                    logger.warn(\"No valid rows found while scrubbing \" + sstable + \"; it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot\");\n                else\n                    logger.info(\"Scrub of \" + sstable + \" complete; looks like all \" + emptyRows + \" rows were tombstoned\");\n            }\n        }\n        finally\n        {\n            FileUtils.closeQuietly(dataFile);\n            FileUtils.closeQuietly(indexFile);\n        }\n    }","id":51048,"modified_method":"private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable) throws IOException\n    {\n        logger.info(\"Scrubbing \" + sstable);\n        CompactionController controller = new CompactionController(cfs, Collections.singletonList(sstable), getDefaultGcBefore(cfs), true);\n        boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();\n\n        // Calculate the expected compacted filesize\n        String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());\n        if (compactionFileLocation == null)\n            throw new IOException(\"disk full\");\n        int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(),\n                                               (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));\n\n        // loop through each row, deserializing to check for damage.\n        // we'll also loop through the index at the same time, using the position from the index to recover if the\n        // row header (key or data size) is corrupt. (This means our position in the index file will be one row\n        // \"ahead\" of the data file.)\n        final RandomAccessReader dataFile = sstable.openDataReader(true);\n\n        String indexFilename = sstable.descriptor.filenameFor(Component.PRIMARY_INDEX);\n        RandomAccessReader indexFile = RandomAccessReader.open(new File(indexFilename), true);\n        ScrubInfo scrubInfo = new ScrubInfo(dataFile, sstable);\n\n        try\n        {\n            ByteBuffer nextIndexKey = ByteBufferUtil.readWithShortLength(indexFile);\n            {\n                // throw away variable so we don't have a side effect in the assert\n                long firstRowPositionFromIndex = indexFile.readLong();\n                assert firstRowPositionFromIndex == 0 : firstRowPositionFromIndex;\n            }\n\n            SSTableReader newSstable = null;\n\n            // errors when creating the writer may leave empty temp files.\n            SSTableWriter writer = maybeCreateWriter(cfs,\n                                                     compactionFileLocation,\n                                                     expectedBloomFilterSize,\n                                                     null,\n                                                     Collections.singletonList(sstable));\n\n            int goodRows = 0, badRows = 0, emptyRows = 0;\n\n            executor.beginCompaction(scrubInfo);\n\n            try\n            {\n                while (!dataFile.isEOF())\n                {\n                    long rowStart = dataFile.getFilePointer();\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Reading row at \" + rowStart);\n\n                    DecoratedKey key = null;\n                    long dataSize = -1;\n                    try\n                    {\n                        key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, ByteBufferUtil.readWithShortLength(dataFile));\n                        dataSize = sstable.descriptor.hasIntRowSize ? dataFile.readInt() : dataFile.readLong();\n                        if (logger.isDebugEnabled())\n                            logger.debug(String.format(\"row %s is %s bytes\", ByteBufferUtil.bytesToHex(key.key), dataSize));\n                    }\n                    catch (Throwable th)\n                    {\n                        throwIfFatal(th);\n                        // check for null key below\n                    }\n\n                    ByteBuffer currentIndexKey = nextIndexKey;\n                    long nextRowPositionFromIndex;\n                    try\n                    {\n                        nextIndexKey = indexFile.isEOF() ? null : ByteBufferUtil.readWithShortLength(indexFile);\n                        nextRowPositionFromIndex = indexFile.isEOF() ? dataFile.length() : indexFile.readLong();\n                    }\n                    catch (Throwable th)\n                    {\n                        logger.warn(\"Error reading index file\", th);\n                        nextIndexKey = null;\n                        nextRowPositionFromIndex = dataFile.length();\n                    }\n\n                    long dataStart = dataFile.getFilePointer();\n                    long dataStartFromIndex = currentIndexKey == null\n                                            ? -1\n                                            : rowStart + 2 + currentIndexKey.remaining() + (sstable.descriptor.hasIntRowSize ? 4 : 8);\n                    long dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex;\n                    assert currentIndexKey != null || indexFile.isEOF();\n                    if (logger.isDebugEnabled() && currentIndexKey != null)\n                        logger.debug(String.format(\"Index doublecheck: row %s is %s bytes\", ByteBufferUtil.bytesToHex(currentIndexKey),  dataSizeFromIndex));\n\n                    writer.mark();\n                    try\n                    {\n                        if (key == null)\n                            throw new IOError(new IOException(\"Unable to read row key from data file\"));\n                        if (dataSize > dataFile.length())\n                            throw new IOError(new IOException(\"Impossible row size \" + dataSize));\n                        SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStart, dataSize, true);\n                        AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                        if (compactedRow.isEmpty())\n                        {\n                            emptyRows++;\n                        }\n                        else\n                        {\n                            writer.append(compactedRow);\n                            goodRows++;\n                        }\n                        if (!key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex)\n                            logger.warn(\"Index file contained a different key or row size; using key from data file\");\n                    }\n                    catch (Throwable th)\n                    {\n                        throwIfFatal(th);\n                        logger.warn(\"Non-fatal error reading row (stacktrace follows)\", th);\n                        writer.resetAndTruncate();\n\n                        if (currentIndexKey != null\n                            && (key == null || !key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex || dataSize != dataSizeFromIndex))\n                        {\n                            logger.info(String.format(\"Retrying from row index; data is %s bytes starting at %s\",\n                                                      dataSizeFromIndex, dataStartFromIndex));\n                            key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, currentIndexKey);\n                            try\n                            {\n                                SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStartFromIndex, dataSizeFromIndex, true);\n                                AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                                if (compactedRow.isEmpty())\n                                {\n                                    emptyRows++;\n                                }\n                                else\n                                {\n                                    writer.append(compactedRow);\n                                    goodRows++;\n                                }\n                            }\n                            catch (Throwable th2)\n                            {\n                                throwIfFatal(th2);\n                                // Skipping rows is dangerous for counters (see CASSANDRA-2759)\n                                if (isCommutative)\n                                    throw new IOError(th2);\n\n                                logger.warn(\"Retry failed too.  Skipping to next row (retry's stacktrace follows)\", th2);\n                                writer.resetAndTruncate();\n                                dataFile.seek(nextRowPositionFromIndex);\n                                badRows++;\n                            }\n                        }\n                        else\n                        {\n                            // Skipping rows is dangerous for counters (see CASSANDRA-2759)\n                            if (isCommutative)\n                                throw new IOError(th);\n\n                            logger.warn(\"Row at \" + dataStart + \" is unreadable; skipping to next\");\n                            if (currentIndexKey != null)\n                                dataFile.seek(nextRowPositionFromIndex);\n                            badRows++;\n                        }\n                    }\n                }\n\n                if (writer.getFilePointer() > 0)\n                    newSstable = writer.closeAndOpenReader(sstable.maxDataAge);\n            }\n            finally\n            {\n                writer.cleanupIfNecessary();\n            }\n\n            if (newSstable != null)\n            {\n                cfs.replaceCompactedSSTables(Arrays.asList(sstable), Arrays.asList(newSstable));\n                logger.info(\"Scrub of \" + sstable + \" complete: \" + goodRows + \" rows in new sstable and \" + emptyRows + \" empty (tombstoned) rows dropped\");\n                if (badRows > 0)\n                    logger.warn(\"Unable to recover \" + badRows + \" rows that were skipped.  You can attempt manual recovery from the pre-scrub snapshot.  You can also run nodetool repair to transfer the data from a healthy replica, if any\");\n            }\n            else\n            {\n                cfs.markCompacted(Arrays.asList(sstable));\n                if (badRows > 0)\n                    logger.warn(\"No valid rows found while scrubbing \" + sstable + \"; it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot\");\n                else\n                    logger.info(\"Scrub of \" + sstable + \" complete; looks like all \" + emptyRows + \" rows were tombstoned\");\n            }\n        }\n        finally\n        {\n            FileUtils.closeQuietly(dataFile);\n            FileUtils.closeQuietly(indexFile);\n\n            executor.finishCompaction(scrubInfo);\n        }\n    }","commit_id":"9e04de6ac093925402a9e42f7cbb239c92f949ab","url":"https://github.com/apache/cassandra"},{"original_method":"private Tuple columnToTuple(ByteBuffer name, IColumn col, CfDef cfDef) throws IOException\n    {\n        Tuple pair = TupleFactory.getInstance().newTuple(2);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n\n        if (col instanceof Column)\n        {\n            // standard\n            pair.set(0, marshallers.get(0).compose(name));\n            if (validators.get(name) == null)\n                // Have to special case BytesType because compose returns a ByteBuffer\n                if (marshallers.get(1) instanceof BytesType)\n                    pair.set(1, new DataByteArray(ByteBufferUtil.getArray(col.value())));\n                else\n                    pair.set(1, marshallers.get(1).compose(col.value()));\n            else\n                pair.set(1, validators.get(name).compose(col.value()));\n            return pair;\n        }\n\n        // super\n        ArrayList<Tuple> subcols = new ArrayList<Tuple>();\n        for (IColumn subcol : col.getSubColumns())\n            subcols.add(columnToTuple(subcol.name(), subcol, cfDef));\n        \n        pair.set(1, new DefaultDataBag(subcols));\n        return pair;\n    }","id":51049,"modified_method":"private Tuple columnToTuple(ByteBuffer name, IColumn col, CfDef cfDef) throws IOException\n    {\n        Tuple pair = TupleFactory.getInstance().newTuple(2);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n\n        setTupleValue(pair, 0, marshallers.get(0).compose(name));\n        if (col instanceof Column)\n        {\n            // standard\n            if (validators.get(name) == null)\n                setTupleValue(pair, 1, marshallers.get(1).compose(col.value()));\n            else\n                setTupleValue(pair, 1, validators.get(name).compose(col.value()));\n            return pair;\n        }\n\n        // super\n        ArrayList<Tuple> subcols = new ArrayList<Tuple>();\n        for (IColumn subcol : col.getSubColumns())\n            subcols.add(columnToTuple(subcol.name(), subcol, cfDef));\n        \n        pair.set(1, new DefaultDataBag(subcols));\n        return pair;\n    }","commit_id":"9c4c63ccae2dee3cdead7d2e83928e26d8a84a48","url":"https://github.com/apache/cassandra"},{"original_method":"public void putNext(Tuple t) throws ExecException, IOException\n    {\n        ByteBuffer key = objToBB(t.get(0));\n        DefaultDataBag pairs = (DefaultDataBag) t.get(1);\n        ArrayList<Mutation> mutationList = new ArrayList<Mutation>();\n        CfDef cfDef = getCfDef(storeSignature);\n        List<AbstractType> marshallers = getDefaultMarshallers(cfDef);\n        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);\n        try\n        {\n            for (Tuple pair : pairs)\n            {\n               Mutation mutation = new Mutation();\n               if (DataType.findType(pair.get(1)) == DataType.BAG) // supercolumn\n               {\n                   org.apache.cassandra.thrift.SuperColumn sc = new org.apache.cassandra.thrift.SuperColumn();\n                   sc.name = objToBB(pair.get(0));\n                   ArrayList<org.apache.cassandra.thrift.Column> columns = new ArrayList<org.apache.cassandra.thrift.Column>();\n                   for (Tuple subcol : (DefaultDataBag) pair.get(1))\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(subcol.get(0));\n                       column.value = objToBB(subcol.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       columns.add(column);\n                   }\n                   if (columns.isEmpty()) // a deletion\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.super_column = objToBB(pair.get(0));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       sc.columns = columns;\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.super_column = sc;\n                   }\n               }\n               else // assume column since it couldn't be anything else\n               {\n                   if (pair.get(1) == null)\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.predicate = new org.apache.cassandra.thrift.SlicePredicate();\n                       mutation.deletion.predicate.column_names = Arrays.asList(objToBB(pair.get(0)));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = marshallers.get(0).decompose((pair.get(0)));\n                       if (validators.get(column.name) == null)\n                           // Have to special case BytesType to convert DataByteArray into ByteBuffer\n                           if (marshallers.get(1) instanceof BytesType)\n                               column.value = objToBB(pair.get(1));\n                           else\n                               column.value = marshallers.get(1).decompose(pair.get(1));\n                       else\n                           column.value = validators.get(column.name).decompose(pair.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.column = column;\n                   }\n               }\n               mutationList.add(mutation);\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(e + \" Output must be (key, {(column,value)...}) for ColumnFamily or (key, {supercolumn:{(column,value)...}...}) for SuperColumnFamily\", e);\n        }\n        try\n        {\n            writer.write(key, mutationList);\n        }\n        catch (InterruptedException e)\n        {\n           throw new IOException(e);\n        }\n    }","id":51050,"modified_method":"public void putNext(Tuple t) throws ExecException, IOException\n    {\n        ByteBuffer key = objToBB(t.get(0));\n        DefaultDataBag pairs = (DefaultDataBag) t.get(1);\n        ArrayList<Mutation> mutationList = new ArrayList<Mutation>();\n        CfDef cfDef = getCfDef(storeSignature);\n        try\n        {\n            for (Tuple pair : pairs)\n            {\n               Mutation mutation = new Mutation();\n               if (DataType.findType(pair.get(1)) == DataType.BAG) // supercolumn\n               {\n                   org.apache.cassandra.thrift.SuperColumn sc = new org.apache.cassandra.thrift.SuperColumn();\n                   sc.name = objToBB(pair.get(0));\n                   ArrayList<org.apache.cassandra.thrift.Column> columns = new ArrayList<org.apache.cassandra.thrift.Column>();\n                   for (Tuple subcol : (DefaultDataBag) pair.get(1))\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(subcol.get(0));\n                       column.value = objToBB(subcol.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       columns.add(column);\n                   }\n                   if (columns.isEmpty()) // a deletion\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.super_column = objToBB(pair.get(0));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       sc.columns = columns;\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.super_column = sc;\n                   }\n               }\n               else // assume column since it couldn't be anything else\n               {\n                   if (pair.get(1) == null)\n                   {\n                       mutation.deletion = new Deletion();\n                       mutation.deletion.predicate = new org.apache.cassandra.thrift.SlicePredicate();\n                       mutation.deletion.predicate.column_names = Arrays.asList(objToBB(pair.get(0)));\n                       mutation.deletion.setTimestamp(System.currentTimeMillis() * 1000);\n                   }\n                   else\n                   {\n                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();\n                       column.name = objToBB(pair.get(0));\n                       column.value = objToBB(pair.get(1));\n                       column.setTimestamp(System.currentTimeMillis() * 1000);\n                       mutation.column_or_supercolumn = new ColumnOrSuperColumn();\n                       mutation.column_or_supercolumn.column = column;\n                   }\n               }\n               mutationList.add(mutation);\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(e + \" Output must be (key, {(column,value)...}) for ColumnFamily or (key, {supercolumn:{(column,value)...}...}) for SuperColumnFamily\", e);\n        }\n        try\n        {\n            writer.write(key, mutationList);\n        }\n        catch (InterruptedException e)\n        {\n           throw new IOException(e);\n        }\n    }","commit_id":"9c4c63ccae2dee3cdead7d2e83928e26d8a84a48","url":"https://github.com/apache/cassandra"},{"original_method":"public void renderDropDownField(StringBuffer buffer, Map context, DropDownField dropDownField) {\n        ModelFormField modelFormField = dropDownField.getModelFormField();\n        ModelForm modelForm = modelFormField.getModelForm();\n        this.makeBlockString(buffer, modelFormField.getWidgetStyle(), modelFormField.getEntry(context));\n        this.appendWhitespace(buffer);\n    }","id":51051,"modified_method":"public void renderDropDownField(StringBuffer buffer, Map context, DropDownField dropDownField) {\n        ModelFormField modelFormField = dropDownField.getModelFormField();\n        ModelForm modelForm = modelFormField.getModelForm();\n        String currentValue = modelFormField.getEntry(context);\n        List allOptionValues = dropDownField.getAllOptionValues(context, modelForm.getDelegator());\n        // if the current value should go first, display it\n        if (UtilValidate.isNotEmpty(currentValue) && \"first-in-list\".equals(dropDownField.getCurrent())) {\n            String explicitDescription = dropDownField.getCurrentDescription(context);\n            if (UtilValidate.isNotEmpty(explicitDescription)) {\n                this.makeBlockString(buffer, modelFormField.getWidgetStyle(), explicitDescription);\n            } else {\n                this.makeBlockString(buffer, modelFormField.getWidgetStyle(), ModelFormField.FieldInfoWithOptions.getDescriptionForOptionKey(currentValue, allOptionValues));\n            }\n        } else {\n            Iterator optionValueIter = allOptionValues.iterator();\n            while (optionValueIter.hasNext()) {\n                ModelFormField.OptionValue optionValue = (ModelFormField.OptionValue) optionValueIter.next();\n                String noCurrentSelectedKey = dropDownField.getNoCurrentSelectedKey(context);\n                if ((UtilValidate.isNotEmpty(currentValue) && currentValue.equals(optionValue.getKey()) && \"selected\".equals(dropDownField.getCurrent())) ||\n                        (UtilValidate.isEmpty(currentValue) && noCurrentSelectedKey != null && noCurrentSelectedKey.equals(optionValue.getKey()))) {\n                    this.makeBlockString(buffer, modelFormField.getWidgetStyle(), optionValue.getDescription());\n                    break;\n                }\n            }\n        }\n        this.appendWhitespace(buffer);\n    }","commit_id":"2f4ceba5ffde94ae9902f853b21dfd21c5b8313d","url":"https://github.com/apache/ofbiz"},{"original_method":"public static List<BookmarksEntry> getEntries(Hits hits) {\n\t\tList<BookmarksEntry> entries = new ArrayList<BookmarksEntry>();\n\n\t\tfor (Document document : hits.getDocs()) {\n\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\tdocument.get(Field.ENTRY_CLASS_PK));\n\n\t\t\ttry {\n\t\t\t\tBookmarksEntry entry = BookmarksEntryServiceUtil.getEntry(\n\t\t\t\t\tentryClassPK);\n\n\t\t\t\tentries.add(entry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Bookmarks search index is stale and contains entry \" +\n\t\t\t\t\t\t\tentryClassPK);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}","id":51052,"modified_method":"public static List<Object> getEntries(Hits hits) {\n\t\tList<Object> entries = new ArrayList<Object>();\n\n\t\tfor (Document document : hits.getDocs()) {\n\t\t\tString entryClassName = document.get(Field.ENTRY_CLASS_NAME);\n\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\tdocument.get(Field.ENTRY_CLASS_PK));\n\n\t\t\ttry {\n\t\t\t\tObject obj = null;\n\n\t\t\t\tif (entryClassName.equals(BookmarksEntry.class.getName())) {\n\t\t\t\t\tobj = BookmarksEntryLocalServiceUtil.getEntry(entryClassPK);\n\t\t\t\t}\n\t\t\t\telse if (entryClassName.equals(\n\t\t\t\t\t\t\tBookmarksFolder.class.getName())) {\n\n\t\t\t\t\tobj = BookmarksFolderLocalServiceUtil.getFolder(\n\t\t\t\t\t\tentryClassPK);\n\t\t\t\t}\n\n\t\t\t\tentries.add(obj);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Bookmarks search index is stale and contains entry \" +\n\t\t\t\t\t\t\tentryClassPK);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}","commit_id":"f970ea9049204edf077d1af95953021a41fb1e4b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<BlogsEntry> getEntries(Hits hits) {\n\t\tList<BlogsEntry> entries = new ArrayList<BlogsEntry>();\n\n\t\tfor (Document document : hits.getDocs()) {\n\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\tdocument.get(Field.ENTRY_CLASS_PK));\n\n\t\t\ttry {\n\t\t\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\t\t\tentryClassPK);\n\n\t\t\t\tentries.add(entry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Blogs search index is stale and contains entry \" +\n\t\t\t\t\t\t\tentryClassPK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}","id":51053,"modified_method":"public static List<Object> getEntries(Hits hits) {\n\t\tList<Object> entries = new ArrayList<Object>();\n\n\t\tfor (Document document : hits.getDocs()) {\n\t\t\tString entryClassName = GetterUtil.getString(\n\t\t\t\tdocument.get(Field.ENTRY_CLASS_NAME));\n\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\tdocument.get(Field.ENTRY_CLASS_PK));\n\n\t\t\ttry {\n\t\t\t\tObject obj = null;\n\n\t\t\t\tif (entryClassName.equals(BlogsEntry.class.getName())) {\n\t\t\t\t\tobj = BlogsEntryLocalServiceUtil.getEntry(entryClassPK);\n\t\t\t\t}\n\t\t\t\telse if (entryClassName.equals(MBMessage.class.getName())) {\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\tdocument.get(Field.CLASS_PK));\n\n\t\t\t\t\tBlogsEntryLocalServiceUtil.getEntry(classPK);\n\n\t\t\t\t\tobj = MBMessageLocalServiceUtil.getMessage(entryClassPK);\n\t\t\t\t}\n\n\t\t\t\tentries.add(obj);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Blogs search index is stale and contains entry \" +\n\t\t\t\t\t\t\tentryClassPK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}","commit_id":"3620bfbf731808fb13687e3f91b08b2afb60d71f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public long size(int index) {\n        Segment segment = getSegment();\n        ListRecord values = getValueList(segment);\n        checkElementIndex(index, values.size());\n        return segment.readLength(values.getEntry(0));\n    }","id":51054,"modified_method":"@Override\n    public long size(int index) {\n        ListRecord values = getValueList(getSegment());\n        checkElementIndex(index, values.size());\n        RecordId entry = values.getEntry(index);\n\n        if (getType().equals(BINARY) || getType().equals(BINARIES)) {\n            return new SegmentBlob(entry).length();\n        }\n\n        return getSegment().readLength(entry);\n    }","commit_id":"db272d3f55fde056c5877519c2f18f4185ecb339","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n   * Registers all the sinks configured in the metrics config.\n   */\n  private void registerSinks() {\n    Properties instConfig = mMetricsConfig.getInstanceProperties(mInstance);\n    Map<String, Properties> sinkConfigs = mMetricsConfig.subProperties(instConfig, SINK_REGEX);\n    for (Map.Entry<String, Properties> entry : sinkConfigs.entrySet()) {\n      String classPath = entry.getValue().getProperty(\"class\");\n      if (classPath != null) {\n        try {\n          Sink sink =\n              (Sink) Class.forName(classPath)\n                  .getConstructor(Properties.class, MetricRegistry.class)\n                  .newInstance(entry.getValue(), mMetricRegistry);\n          if (entry.getKey().equals(\"servlet\")) {\n            mMetricsServlet = (MetricsServlet) sink;\n          } else {\n            mSinks.add(sink);\n          }\n        } catch (Exception e) {\n          LOG.error(\"Sink class {} cannot be instantiated\", classPath, e);\n        }\n      }\n    }\n  }","id":51055,"modified_method":"/**\n   * Registers all the sinks configured in the metrics config.\n   */\n  private void registerSinks() {\n    Properties instConfig = mMetricsConfig.getInstanceProperties(mInstance);\n    Map<String, Properties> sinkConfigs = mMetricsConfig.subProperties(instConfig, SINK_REGEX);\n    for (Map.Entry<String, Properties> entry : sinkConfigs.entrySet()) {\n      String classPath = entry.getValue().getProperty(\"class\");\n      if (classPath != null) {\n        try {\n\n          Class<? extends Sink> clazz = Class.forName(classPath).asSubclass(Sink.class);\n\n          Sink sink =\n                  clazz.getConstructor(Properties.class, MetricRegistry.class)\n                          .newInstance(entry.getValue(), mMetricRegistry);\n\n          if (clazz.equals(CsvSink.class)) {\n            mMetricRegistry.setHistoryEnabled(true);\n            mMetricRegistry.setCsvPath(((CsvSink) sink).getPollDir());\n          }\n\n          if (entry.getKey().equals(\"servlet\")) {\n            mMetricsServlet = (MetricsServlet) sink;\n          } else {\n            mSinks.add(sink);\n          }\n        } catch (Exception e) {\n          LOG.error(\"Sink class {} cannot be instantiated\", classPath, e);\n        }\n      }\n    }\n  }","commit_id":"dfa0995965ca3668a453c38c0d09b04e6b937fc5","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void addServices(DefaultServiceRegistry serviceRegistry) {\n\n        if (OperatingSystem.current().isWindows()) {\n            serviceRegistry.add(Chmod.class, new EmptyChmod());\n            serviceRegistry.add(Stat.class, new FallbackStat());\n            serviceRegistry.add(Symlink.class, new FallbackSymlink());\n            return;\n        }\n\n        serviceRegistry.add(Symlink.class, createSymlink());\n\n        if (JavaVersion.current().isJava7()) {\n            String jdkFilePermissionclass = \"org.gradle.internal.nativeplatform.filesystem.jdk7.PosixJdk7FilePermissionHandler\";\n            try {\n                FilePermissionHandler handler = (FilePermissionHandler) FilePermissionHandler.class.getClassLoader().loadClass(jdkFilePermissionclass).newInstance();\n                serviceRegistry.add(FilePermissionHandler.class, handler);\n                return;\n            } catch (ClassNotFoundException e) {\n                LOGGER.warn(String.format(\"Unable to load %s. Continuing with fallback.\", jdkFilePermissionclass));\n            } catch (Exception e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }\n\n        serviceRegistry.add(Chmod.class, createChmod());\n        serviceRegistry.add(Stat.class, createStat());\n    }","id":51056,"modified_method":"private static void addServices(DefaultServiceRegistry serviceRegistry) {\n\n        if (OperatingSystem.current().isWindows()) {\n            serviceRegistry.add(Chmod.class, new EmptyChmod());\n            serviceRegistry.add(Stat.class, new FallbackStat());\n            serviceRegistry.add(Symlink.class, new FallbackSymlink());\n            return;\n        }\n\n        serviceRegistry.add(Symlink.class, createSymlink());\n\n        if (JavaVersion.current().isJava7()) {\n            String jdkFilePermissionclass = \"org.gradle.internal.nativeplatform.filesystem.jdk7.PosixJdk7FilePermissionHandler\";\n            try {\n                Object handler = FileSystemServices.class.getClassLoader().loadClass(jdkFilePermissionclass).newInstance();\n                serviceRegistry.add(Stat.class, (Stat) handler);\n                serviceRegistry.add(Chmod.class, (Chmod) handler);\n                return;\n            } catch (ClassNotFoundException e) {\n                LOGGER.warn(String.format(\"Unable to load %s. Continuing with fallback.\", jdkFilePermissionclass));\n            } catch (Exception e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }\n\n        serviceRegistry.add(Chmod.class, createChmod());\n        serviceRegistry.add(Stat.class, createStat());\n    }","commit_id":"559d7ae73c422483fe14acbab0119301d003c1c0","url":"https://github.com/gradle/gradle"},{"original_method":"public static void main(String args[]) throws Exception\n    {\n        StringBuffer sb = new StringBuffer();\n        String framework = null;\n        PrintStream out = System.out;\n        InputStream in = System.in;\n        boolean console = false;\n\n        for (int i = 0; i < args.length; i++)\n        {\n            String arg = args[i];\n            if (arg.equals(\"-f\"))\n            {\n                framework = args[++i];\n            }\n            else\n            {\n                if (arg.equals(\"-cp\") || arg.equals(\"-classpath\"))\n                {\n                    classpath(args[++i]);\n                }\n                else\n                {\n                    if (arg.equals(\"-console\"))\n                    {\n                        console = true;\n                    }\n                    else\n                    {\n                        if (arg.equals(\"-i\"))\n                        {\n                            in = new FileInputStream(args[++i]);\n                        }\n                        else\n                        {\n                            if (arg.equals(\"-o\"))\n                            {\n                                out = new PrintStream(new FileOutputStream(args[++i]));\n                            }\n                            else\n                            {\n                                sb.append(' ');\n                                sb.append(arg);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (framework == null)\n        {\n            System.err.println(\"No framework set\");\n            System.exit(1);\n        }\n\n        ThreadIOImpl threadio = new ThreadIOImpl();\n        threadio.start();\n        URL[] urls = classpath.toArray(new URL[classpath.size()]);\n        URLClassLoader urlcl = new URLClassLoader(urls, Launcher.class.getClassLoader());\n        Class<?> fw = urlcl.loadClass(framework);\n\n        Constructor<?> c = fw.getConstructor(Map.class, List.class);\n        Properties p = new Properties(System.getProperties());\n        Bundle bundle = (Bundle) c.newInstance(p, null);\n\n        OSGiShell shell = new OSGiShell();\n        shell.setThreadio(threadio);\n        shell.setBundle(bundle);\n        shell.start();\n\n\n        CommandSession session = shell.createSession(in, out, System.err);\n        session.put(\"shell\", shell);\n        session.put(\"threadio\", threadio);\n\n        session.execute(sb);\n        out.flush();\n\n        if (bundle.getState() == Bundle.ACTIVE)\n        {\n        }\n        if (console)\n        {\n            Console cons = new Console();\n            cons.setSession(session);\n            cons.run();\n        }\n    }","id":51057,"modified_method":"public static void main(String args[]) throws Exception\n    {\n        StringBuffer sb = new StringBuffer();\n        String fwkClassName = null;\n        PrintStream out = System.out;\n        InputStream in = System.in;\n        boolean console = false;\n\n        for (int i = 0; i < args.length; i++)\n        {\n            String arg = args[i];\n            if (arg.equals(\"-f\"))\n            {\n                fwkClassName = args[++i];\n            }\n            else\n            {\n                if (arg.equals(\"-cp\") || arg.equals(\"-classpath\"))\n                {\n                    classpath(args[++i]);\n                }\n                else\n                {\n                    if (arg.equals(\"-console\"))\n                    {\n                        console = true;\n                    }\n                    else\n                    {\n                        if (arg.equals(\"-i\"))\n                        {\n                            in = new FileInputStream(args[++i]);\n                        }\n                        else\n                        {\n                            if (arg.equals(\"-o\"))\n                            {\n                                out = new PrintStream(new FileOutputStream(args[++i]));\n                            }\n                            else\n                            {\n                                sb.append(' ');\n                                sb.append(arg);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        URL[] urls = classpath.toArray(new URL[classpath.size()]);\n        URLClassLoader cl = new URLClassLoader(urls, Launcher.class.getClassLoader());\n\n        Properties p = new Properties(System.getProperties());\n\n        Framework framework;\n        if (fwkClassName == null)\n        {\n            framework = getFrameworkFactory(cl).newFramework(p);\n        }\n        else\n        {\n            Class<?> fw = cl.loadClass(fwkClassName);\n            Constructor<?> c = fw.getConstructor(Map.class, List.class);\n            framework = (Framework) c.newInstance(p);\n        }\n\n        ThreadIOImpl threadio = new ThreadIOImpl();\n        threadio.start();\n\n        OSGiShell shell = new OSGiShell();\n        shell.setThreadio(threadio);\n        shell.setBundle(framework);\n        shell.start();\n\n        CommandSession session = shell.createSession(in, out, System.err);\n        session.put(\"shell\", shell);\n        session.put(\"threadio\", threadio);\n\n        session.execute(sb);\n        out.flush();\n\n        if (framework.getState() == Bundle.ACTIVE)\n        {\n        }\n        if (console)\n        {\n            Console cons = new Console();\n            cons.setSession(session);\n            cons.run();\n        }\n    }","commit_id":"0b118e69b98052a734cd5e9ae4f43649480f0b5a","url":"https://github.com/apache/felix"},{"original_method":"public PasswordCredentials getCredentials() {\n        if (passwordCredentials == null && alternativeCredentials != null) {\n            throw new IllegalStateException(\"Password credentials has been overridden by a specific credentials of type [\"\n                    + alternativeCredentials.getClass().getName()\n                    + \"] Credentials should be accessed using 'getAlternativeCredentials()'\");\n        }\n        return passwordCredentials;\n    }","id":51058,"modified_method":"public PasswordCredentials getCredentials() {\n        if(credentials != null && !(credentials instanceof PasswordCredentials)) {\n            throw new IllegalStateException(String.format(\"Requested credentials must be of type '%s'.\", PasswordCredentials.class.getName()));\n        }\n        return (PasswordCredentials) credentials;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public void credentials(Action<? super PasswordCredentials> action) {\n        if (passwordCredentials == null) {\n            throw new IllegalStateException(\"Password credentials is null, most likely an alternative \"\n                    + \"credentials type has been configured for this repository\");\n        }\n        action.execute(passwordCredentials);\n    }","id":51059,"modified_method":"public void credentials(Action<? super PasswordCredentials> action) {\n        if (credentials != null) {\n            throw new IllegalStateException(\"Cannot overwrite already configured credentials.\");\n        }\n        credentials = instantiator.newInstance(DefaultPasswordCredentials.class);\n        action.execute((PasswordCredentials)credentials);\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public Credentials getAlternativeCredentials() {\n        if (null == alternativeCredentials) {\n            throw new IllegalStateException(\"This repository has not been configured a specific credentials type \"\n                    + \"e.g. (credentials(PasswordCredentials){ ... })\");\n        }\n        return alternativeCredentials;\n    }","id":51060,"modified_method":"public Credentials getAlternativeCredentials() {\n        return credentials;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends Credentials> void credentials(Class<T> clazz, Action<? super T> action) throws IllegalStateException {\n        if(alternativeCredentials != null) {\n            throw new IllegalStateException(\"Cannot overwrite already configured strongly typed credentials.\");\n        }\n        T instance = null;\n        if (clazz == AwsCredentials.class) {\n            instance = (T) instantiator.newInstance(DefaultAwsCredentials.class);\n        } else if (clazz == PasswordCredentials.class) {\n            instance = (T) instantiator.newInstance(DefaultPasswordCredentials.class);\n        }\n        overrideDefaultCredentials(instance);\n        action.execute(instance);\n    }","id":51061,"modified_method":"public <T extends Credentials> void credentials(Class<T> clazz, Action<? super T> action) throws IllegalStateException {\n        if(credentials != null) {\n            throw new IllegalStateException(\"Cannot overwrite already configured credentials.\");\n        }\n        if (clazz == AwsCredentials.class) {\n            credentials = instantiator.newInstance(DefaultAwsCredentials.class);\n        } else if (clazz == PasswordCredentials.class) {\n            credentials= instantiator.newInstance(DefaultPasswordCredentials.class);\n        }\n        action.execute((T) credentials);\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"AbstractAuthenticationSupportedRepository(PasswordCredentials passwordCredentials, Instantiator instantiator) {\n        this.passwordCredentials = passwordCredentials;\n        this.alternativeCredentials = passwordCredentials;\n        this.instantiator = instantiator;\n    }","id":51062,"modified_method":"AbstractAuthenticationSupportedRepository(Instantiator instantiator) {\n        this.instantiator = instantiator;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public MavenArtifactRepository createMavenRepository() {\n        return instantiator.newInstance(DefaultMavenArtifactRepository.class, fileResolver, createPasswordCredentials(), transportFactory,\n                locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n    }","id":51063,"modified_method":"public MavenArtifactRepository createMavenRepository() {\n        return instantiator.newInstance(DefaultMavenArtifactRepository.class, fileResolver, transportFactory,\n                locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public MavenArtifactRepository createMavenLocalRepository() {\n        MavenArtifactRepository mavenRepository = instantiator.newInstance(DefaultMavenLocalArtifactRepository.class, fileResolver, createPasswordCredentials(), transportFactory,\n                locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n        final File localMavenRepository = localMavenRepositoryLocator.getLocalMavenRepository();\n        mavenRepository.setUrl(localMavenRepository);\n        return mavenRepository;\n    }","id":51064,"modified_method":"public MavenArtifactRepository createMavenLocalRepository() {\n        MavenArtifactRepository mavenRepository = instantiator.newInstance(DefaultMavenLocalArtifactRepository.class, fileResolver, transportFactory,\n                locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n        final File localMavenRepository = localMavenRepositoryLocator.getLocalMavenRepository();\n        mavenRepository.setUrl(localMavenRepository);\n        return mavenRepository;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifactRepository createIvyRepository() {\n        return instantiator.newInstance(DefaultIvyArtifactRepository.class, fileResolver, createPasswordCredentials(), transportFactory,\n                locallyAvailableResourceFinder, instantiator, resolverStrategy, artifactFileStore);\n    }","id":51065,"modified_method":"public IvyArtifactRepository createIvyRepository() {\n        return instantiator.newInstance(DefaultIvyArtifactRepository.class, fileResolver, transportFactory,\n                locallyAvailableResourceFinder, instantiator, resolverStrategy, artifactFileStore);\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIvyArtifactRepository(FileResolver fileResolver, PasswordCredentials credentials, RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder, Instantiator instantiator,\n                                        ResolverStrategy resolverStrategy, FileStore<ModuleComponentArtifactMetaData> artifactFileStore) {\n        super(credentials, instantiator);\n        this.fileResolver = fileResolver;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.resolverStrategy = resolverStrategy;\n        this.artifactFileStore = artifactFileStore;\n        this.additionalPatternsLayout = new AdditionalPatternsRepositoryLayout(fileResolver);\n        this.layout = new GradleRepositoryLayout();\n        this.metaDataProvider = new MetaDataProvider();\n        this.instantiator = instantiator;\n    }","id":51066,"modified_method":"public DefaultIvyArtifactRepository(FileResolver fileResolver, RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder, Instantiator instantiator,\n                                        ResolverStrategy resolverStrategy, FileStore<ModuleComponentArtifactMetaData> artifactFileStore) {\n        super(instantiator);\n        this.fileResolver = fileResolver;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.resolverStrategy = resolverStrategy;\n        this.artifactFileStore = artifactFileStore;\n        this.additionalPatternsLayout = new AdditionalPatternsRepositoryLayout(fileResolver);\n        this.layout = new GradleRepositoryLayout();\n        this.metaDataProvider = new MetaDataProvider();\n        this.instantiator = instantiator;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultMavenArtifactRepository(FileResolver fileResolver, PasswordCredentials credentials, RepositoryTransportFactory transportFactory,\n                                          LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder,\n                                          Instantiator instantiator,\n                                          FileStore<ModuleComponentArtifactMetaData> artifactFileStore, MetaDataParser pomParser) {\n        super(credentials, instantiator);\n        this.fileResolver = fileResolver;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.artifactFileStore = artifactFileStore;\n        this.pomParser = pomParser;\n    }","id":51067,"modified_method":"public DefaultMavenArtifactRepository(FileResolver fileResolver, RepositoryTransportFactory transportFactory,\n                                          LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder,\n                                          Instantiator instantiator,\n                                          FileStore<ModuleComponentArtifactMetaData> artifactFileStore, MetaDataParser pomParser) {\n        super(instantiator);\n        this.fileResolver = fileResolver;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.artifactFileStore = artifactFileStore;\n        this.pomParser = pomParser;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultMavenLocalArtifactRepository(FileResolver fileResolver, PasswordCredentials credentials, RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder, Instantiator instantiator,\n                                        FileStore<ModuleComponentArtifactMetaData> artifactFileStore, MetaDataParser pomParser) {\n        super(fileResolver, credentials, transportFactory, locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n    }","id":51068,"modified_method":"public DefaultMavenLocalArtifactRepository(FileResolver fileResolver, RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ModuleComponentArtifactMetaData> locallyAvailableResourceFinder, Instantiator instantiator,\n                                        FileStore<ModuleComponentArtifactMetaData> artifactFileStore, MetaDataParser pomParser) {\n        super(fileResolver, transportFactory, locallyAvailableResourceFinder, instantiator, artifactFileStore, pomParser);\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureCredentials(DefaultHttpClient httpClient, PasswordCredentials credentials) {\n        String username = credentials.getUsername();\n        if (username != null && username.length() > 0) {\n            useCredentials(httpClient, credentials, AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n\n            // Use preemptive authorisation if no other authorisation has been established\n            httpClient.addRequestInterceptor(new PreemptiveAuth(new BasicScheme()), 0);\n        }\n    }","id":51069,"modified_method":"private void configureCredentials(DefaultHttpClient httpClient, PasswordCredentials credentials) {\n        if(credentials != null) {\n            String username = credentials.getUsername();\n            if (username != null && username.length() > 0) {\n                useCredentials(httpClient, credentials, AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n\n                // Use preemptive authorisation if no other authorisation has been established\n                httpClient.addRequestInterceptor(new PreemptiveAuth(new BasicScheme()), 0);\n            }\n        }\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"public RemoteRepository create() {\n        RemoteRepository remoteRepository = new RemoteRepository();\n        remoteRepository.setUrl(artifactRepository.getUrl().toString());\n\n        PasswordCredentials credentials = artifactRepository.getCredentials();\n        String username = credentials.getUsername();\n        String password = credentials.getPassword();\n\n        if (username != null || password != null) {\n            Authentication authentication = new Authentication();\n            authentication.setUserName(username);\n            authentication.setPassword(password);\n            remoteRepository.addAuthentication(authentication);\n        }\n\n        return remoteRepository;\n    }","id":51070,"modified_method":"public RemoteRepository create() {\n        RemoteRepository remoteRepository = new RemoteRepository();\n        remoteRepository.setUrl(artifactRepository.getUrl().toString());\n\n        PasswordCredentials credentials = (PasswordCredentials) artifactRepository.getCredentials();\n\n        String username = credentials.getUsername();\n        String password = credentials.getPassword();\n\n        if (username != null || password != null) {\n            Authentication authentication = new Authentication();\n            authentication.setUserName(username);\n            authentication.setPassword(password);\n            remoteRepository.addAuthentication(authentication);\n        }\n\n        return remoteRepository;\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"private org.gradle.internal.resource.PasswordCredentials convertPasswordCredentials(Credentials credentials) {\n        if (!(credentials instanceof PasswordCredentials)) {\n            throw new IllegalArgumentException(String.format(\"Credentials must be an instance of: %s\", PasswordCredentials.class.getCanonicalName()));\n        }\n        PasswordCredentials passwordCredentials = (PasswordCredentials) credentials;\n        return new org.gradle.internal.resource.PasswordCredentials(passwordCredentials.getUsername(), passwordCredentials.getPassword());\n    }","id":51071,"modified_method":"private org.gradle.internal.resource.PasswordCredentials convertPasswordCredentials(Credentials credentials) {\n        if(credentials == null) {\n            return null;\n        }\n        if (!(credentials instanceof PasswordCredentials)) {\n            throw new IllegalArgumentException(String.format(\"Credentials must be an instance of: %s\", PasswordCredentials.class.getCanonicalName()));\n        }\n        PasswordCredentials passwordCredentials = (PasswordCredentials) credentials;\n        return new org.gradle.internal.resource.PasswordCredentials(passwordCredentials.getUsername(), passwordCredentials.getPassword());\n    }","commit_id":"53fc9b6cfbf8e4f7f09fc1a9fe5774e16b09fb40","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * This method cancels the schedules which were created in {@link #schedule()}.\n     * \n     * @see Future#cancel(boolean)\n     */\n    protected void unschedule()\n    {\n        synchronized (schedules)\n        {\n            // cancel our schedules gently: do not interrupt when polling is in progress\n            for (Iterator i = schedules.iterator(); i.hasNext();)\n            {\n                ScheduledFuture schedule = (ScheduledFuture)i.next();\n                schedule.cancel(false);\n                i.remove();\n\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(ObjectUtils.identityToShortString(this) + \" cancelled polling schedule: \"\n                                 + ObjectUtils.identityToShortString(schedule));\n                }\n            }\n        }\n    }","id":51072,"modified_method":"/**\n     * This method cancels the schedules which were created in {@link #schedule()}.\n     * \n     * @see Future#cancel(boolean)\n     */\n    protected void unschedule()\n    {\n        synchronized (schedules)\n        {\n            // cancel our schedules gently: do not interrupt when polling is in progress\n            for (Iterator<ScheduledFuture> i = schedules.iterator(); i.hasNext();)\n            {\n                ScheduledFuture schedule = i.next();\n                schedule.cancel(false);\n                i.remove();\n\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(ObjectUtils.identityToShortString(this) + \" cancelled polling schedule: \"\n                                 + ObjectUtils.identityToShortString(schedule));\n                }\n            }\n        }\n    }","commit_id":"9d099ddc0f1a009b7d9205eb6baa31eeb37915c2","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void poll()\n    {\n        try\n        {\n            List<File> files = this.listFiles();\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Files: \" + files.toString());\n            }\n            Comparator comparator = getComparator();\n            if (comparator != null)\n            {\n                Collections.sort(files, comparator);\n            }\n            for (File file : files)\n            {\n                // don't process directories\n                if (file.isFile())\n                {\n                    processFile(file);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            getConnector().getMuleContext().getExceptionListener().handleException(e);\n        }\n    }","id":51073,"modified_method":"@Override\n    public void poll()\n    {\n        try\n        {\n            List<File> files = this.listFiles();\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Files: \" + files.toString());\n            }\n            Comparator<File> comparator = getComparator();\n            if (comparator != null)\n            {\n                Collections.sort(files, comparator);\n            }\n            for (File file : files)\n            {\n                // don't process directories\n                if (file.isFile())\n                {\n                    processFile(file);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            getConnector().getMuleContext().getExceptionListener().handleException(e);\n        }\n    }","commit_id":"9d099ddc0f1a009b7d9205eb6baa31eeb37915c2","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Comparator getComparator() throws Exception\n    {\n\n        Object o = getEndpoint().getProperty(COMPARATOR_CLASS_NAME_PROPERTY);\n        Object reverseProperty = this.getEndpoint().getProperty(COMPARATOR_REVERSE_ORDER_PROPERTY);\n        boolean reverse = false;\n        if (o != null)\n        {\n            if (reverseProperty != null)\n            {\n                reverse = Boolean.valueOf((String) reverseProperty);\n            }\n            Class clazz = Class.forName(o.toString());\n            o = clazz.newInstance();\n            return reverse ? new ReverseComparator((Comparator) o) : (Comparator) o;\n        }\n        return null;\n    }","id":51074,"modified_method":"protected Comparator<File> getComparator() throws Exception\n    {\n        Object comparatorClassName = getEndpoint().getProperty(COMPARATOR_CLASS_NAME_PROPERTY);\n        if (comparatorClassName != null)\n        {\n            Object reverseProperty = this.getEndpoint().getProperty(COMPARATOR_REVERSE_ORDER_PROPERTY);\n            boolean reverse = false;\n            if (reverseProperty != null)\n            {\n                reverse = Boolean.valueOf((String) reverseProperty);\n            }\n            \n            Class<?> clazz = Class.forName(comparatorClassName.toString());\n            Comparator<?> comparator = (Comparator<?>)clazz.newInstance();\n            return reverse ? new ReverseComparator(comparator) : comparator;\n        }\n        return null;\n    }","commit_id":"9d099ddc0f1a009b7d9205eb6baa31eeb37915c2","url":"https://github.com/mulesoft/mule"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tgetSubject().getPrincipals().add(getPrincipal());\n\t\t\tgetSubject().getPrivateCredentials().add(getPassword());\n\n\t\t\tObject group = ReflectionUtil.newInstance(_JGROUP, \"Roles\");\n\t\t\tObject role = ReflectionUtil.newInstance(_JROLE, \"users\");\n\n\t\t\ttry {\n\t\t\t\tMethod method = MethodCache.get(\n\t\t\t\t\t_JGROUP, \"addMember\", new Class[] {role.getClass()});\n\n\t\t\t\tmethod.invoke(group, new Object[] {role});\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\tgetSubject().getPrincipals().add((Principal)group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":51075,"modified_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tgetSubject().getPrincipals().add(getPrincipal());\n\t\t\tgetSubject().getPrivateCredentials().add(getPassword());\n\n\t\t\tPrincipal group = (Principal)ReflectionUtil.newInstance(\n\t\t\t\t_JGROUP, \"Roles\");\n\t\t\tObject role = ReflectionUtil.newInstance(_JROLE, \"users\");\n\n\t\t\ttry {\n\t\t\t\tMethod method = MethodCache.get(\n\t\t\t\t\t_JGROUP, \"addMember\", new Class[] {role.getClass()});\n\n\t\t\t\tmethod.invoke(group, new Object[] {role});\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\tgetSubject().getPrincipals().add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"cd9054d2162f3da7422ff6808e4591d9d5603b72","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getUserName(RenderRequest req, RenderResponse res) {\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString userName = prefs.getValue(\"user-name\", req.getRemoteUser());\n\n\t\tif (Validator.isNull(userName)) {\n\t\t\tuserName = req.getRemoteUser();\n\t\t}\n\n\t\treturn userName;\n\t}","id":51076,"modified_method":"protected String getUserName(RenderRequest req, RenderResponse res) {\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString userName = prefs.getValue(\"user-name\", StringPool.BLANK);\n\n\t\tif (Validator.isNull(userName)) {\n\t\t\tuserName = req.getRemoteUser();\n\t\t}\n\n\t\treturn userName;\n\t}","commit_id":"cd9054d2162f3da7422ff6808e4591d9d5603b72","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getPassword(RenderRequest req, RenderResponse res)\n\t\tthrows PortalException, SystemException {\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString defaultPassword = null;\n\n\t\tif (req.getRemoteUser() != null) {\n\t\t\tdefaultPassword = PortalUtil.getUserPassword(req);\n\t\t}\n\n\t\tString password = prefs.getValue(\"password\", defaultPassword);\n\n\t\tif (Validator.isNull(password)) {\n\t\t\tpassword = defaultPassword;\n\t\t}\n\n\t\treturn password;\n\t}","id":51077,"modified_method":"protected String getPassword(RenderRequest req, RenderResponse res)\n\t\tthrows PortalException, SystemException {\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString password = prefs.getValue(\"password\", StringPool.BLANK);\n\n\t\tif (Validator.isNull(password)) {\n\t\t\tpassword = PortalUtil.getUserPassword(req);\n\t\t}\n\n\t\treturn password;\n\t}","commit_id":"cd9054d2162f3da7422ff6808e4591d9d5603b72","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * How many measured events do we have for the given period?  If the period is negative,\n     * return the lifetime events.\n     *\n     */\n    private long getEventCount(PeerProfile profile, long period, boolean tunnelTestOnly) {\n        if (period < 0) {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(60*60*1000l);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(60*60*1000l);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(60*60*1000l);\n            \n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeEventCount();\n            long tunnelTests = tunnelTestRate.getLifetimeEventCount();\n\n            return dbResponses + tunnelResponses + tunnelTests;\n        } else {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(period);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(period);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(period);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getCurrentEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getCurrentEventCount();\n            long tunnelTests = tunnelTestRate.getCurrentEventCount();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"TunnelTests for period \" + period + \": \" + tunnelTests +\n                           \" last: \" + tunnelTestRate.getLastEventCount() + \" lifetime: \" +\n                           tunnelTestRate.getLifetimeEventCount());\n\n            return dbResponses + tunnelResponses + tunnelTests;\n        }\n    }","id":51078,"modified_method":"/**\n     * How many measured events do we have for the given period?  If the period is negative,\n     * return the lifetime events.\n     *\n     */\n    private long getEventCount(PeerProfile profile, long period, boolean tunnelTestOnly) {\n        if (period < 0) {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(60*60*1000l);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(60*60*1000l);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(60*60*1000l);\n            \n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeEventCount();\n            long tunnelTests = tunnelTestRate.getLifetimeEventCount();\n\n            return dbResponses + tunnelResponses + tunnelTests;\n        } else {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(period);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(period);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(period);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getCurrentEventCount() + dbResponseRate.getLastEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getCurrentEventCount() + tunnelResponseRate.getLastEventCount();\n            long tunnelTests = tunnelTestRate.getCurrentEventCount() + tunnelTestRate.getLastEventCount();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"TunnelTests for period \" + period + \": \" + tunnelTests +\n                           \" last: \" + tunnelTestRate.getLastEventCount() + \" lifetime: \" +\n                           tunnelTestRate.getLifetimeEventCount());\n\n            return dbResponses + tunnelResponses + tunnelTests;\n        }\n    }","commit_id":"0d431213cdc141bc8112a144a843d95b179b3b16","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Retrieve the average measured round trip time within the period specified (including \n     * db responses, tunnel create responses, and tunnel tests).  If the period is negative, \n     * it uses the lifetime stats.  In addition, it weights each of those three measurements\n     * equally according to their event count (e.g. 4 dbResponses @ 10 seconds and 1 tunnel test\n     * at 5 seconds will leave the average at 9 seconds)\n     *\n     */\n    private double getMeasuredRoundTripTime(PeerProfile profile, long period, boolean tunnelTestOnly) {\n        if (period < 0) {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(60*60*1000l);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(60*60*1000l);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(60*60*1000l);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeEventCount();\n            long tunnelTests = tunnelTestRate.getLifetimeEventCount();\n\n            double dbResponseTime = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeAverageValue();\n            double tunnelResponseTime = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeAverageValue();\n            double tunnelTestTime = tunnelTestRate.getLifetimeAverageValue();\n\n            long events = dbResponses + tunnelResponses + tunnelTests;\n            if (events <= 0) return 0;\n            return (dbResponses*dbResponseTime + tunnelResponses*tunnelResponseTime + tunnelTests*tunnelTestTime)\n                   / events;\n        } else {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(period);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(period);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(period);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getCurrentEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getCurrentEventCount();\n            long tunnelTests = tunnelTestRate.getCurrentEventCount();\n\n            double dbResponseTime = tunnelTestOnly ? 0 : dbResponseRate.getAverageValue();\n            double tunnelResponseTime = tunnelTestOnly ? 0 : tunnelResponseRate.getAverageValue();\n            double tunnelTestTime = tunnelTestRate.getAverageValue();\n\n            long events = dbResponses + tunnelResponses + tunnelTests;\n            if (events <= 0) return 0;\n            return (dbResponses*dbResponseTime + tunnelResponses*tunnelResponseTime + tunnelTests*tunnelTestTime)\n                   / events;\n        }\n    }","id":51079,"modified_method":"/**\n     * Retrieve the average measured round trip time within the period specified (including \n     * db responses, tunnel create responses, and tunnel tests).  If the period is negative, \n     * it uses the lifetime stats.  In addition, it weights each of those three measurements\n     * equally according to their event count (e.g. 4 dbResponses @ 10 seconds and 1 tunnel test\n     * at 5 seconds will leave the average at 9 seconds)\n     *\n     */\n    private double getMeasuredRoundTripTime(PeerProfile profile, long period, boolean tunnelTestOnly) {\n        if (period < 0) {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(60*60*1000l);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(60*60*1000l);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(60*60*1000l);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeEventCount();\n            long tunnelTests = tunnelTestRate.getLifetimeEventCount();\n\n            double dbResponseTime = tunnelTestOnly ? 0 : dbResponseRate.getLifetimeAverageValue();\n            double tunnelResponseTime = tunnelTestOnly ? 0 : tunnelResponseRate.getLifetimeAverageValue();\n            double tunnelTestTime = tunnelTestRate.getLifetimeAverageValue();\n\n            long events = dbResponses + tunnelResponses + tunnelTests;\n            if (events <= 0) return 0;\n            return (dbResponses*dbResponseTime + tunnelResponses*tunnelResponseTime + tunnelTests*tunnelTestTime)\n                   / events;\n        } else {\n            Rate dbResponseRate = profile.getDbResponseTime().getRate(period);\n            Rate tunnelResponseRate = profile.getTunnelCreateResponseTime().getRate(period);\n            Rate tunnelTestRate = profile.getTunnelTestResponseTime().getRate(period);\n\n            long dbResponses = tunnelTestOnly ? 0 : dbResponseRate.getCurrentEventCount() + dbResponseRate.getLastEventCount();\n            long tunnelResponses = tunnelTestOnly ? 0 : tunnelResponseRate.getCurrentEventCount() + tunnelResponseRate.getLastEventCount();\n            long tunnelTests = tunnelTestRate.getCurrentEventCount() + tunnelTestRate.getLastEventCount();\n\n            double dbResponseTime = tunnelTestOnly ? 0 : dbResponseRate.getAverageValue();\n            double tunnelResponseTime = tunnelTestOnly ? 0 : tunnelResponseRate.getAverageValue();\n            double tunnelTestTime = tunnelTestRate.getAverageValue();\n\n            long events = dbResponses + tunnelResponses + tunnelTests;\n            if (events <= 0) return 0;\n            return (dbResponses*dbResponseTime + tunnelResponses*tunnelResponseTime + tunnelTests*tunnelTestTime)\n                   / events;\n        }\n    }","commit_id":"0d431213cdc141bc8112a144a843d95b179b3b16","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  @return randomized number of hops 0-7, not including ourselves\n     */\n    protected int getLength(RouterContext ctx, TunnelPoolSettings settings) {\n        int length = settings.getLength();\n        //int override = settings.getLengthOverride();\n        //if (override != 0)\n        //    length = override;\n        //else if (settings.getLengthVariance() != 0) {\n        if (settings.getLengthVariance() != 0) {\n            int skew = settings.getLengthVariance();\n            if (skew > 0)\n                length += ctx.random().nextInt(skew+1);\n            else {\n                skew = 1 - skew;\n                int off = ctx.random().nextInt(skew);\n                if (ctx.random().nextBoolean())\n                    length += off;\n                else\n                    length -= off;\n            }\n        }\n        if (length < 0)\n            length = 0;\n        else if (length > 7) // as documented in tunnel.html\n            length = 7;\n        /*\n        if ( (ctx.tunnelManager().getOutboundTunnelCount() <= 0) || \n             (ctx.tunnelManager().getFreeTunnelCount() <= 0) ) {\n            Log log = ctx.logManager().getLog(TunnelPeerSelector.class);\n            // no tunnels to build tunnels with\n            if (settings.getAllowZeroHop()) {\n                if (log.shouldLog(Log.INFO))\n                    log.info(\"no outbound tunnels or free inbound tunnels, but we do allow zeroHop: \" + settings);\n                return 0;\n            } else {\n                if (log.shouldLog(Log.WARN))\n                    log.warn(\"no outbound tunnels or free inbound tunnels, and we dont allow zeroHop: \" + settings);\n                return -1;\n            }\n        }\n        */\n        return length;\n    }","id":51080,"modified_method":"/**\n     *  @return randomized number of hops 0-7, not including ourselves\n     */\n    protected int getLength(RouterContext ctx, TunnelPoolSettings settings) {\n        int length = settings.getLength();\n        int override = settings.getLengthOverride();\n        if (override >= 0) {\n            length = override;\n        } else if (settings.getLengthVariance() != 0) {\n            int skew = settings.getLengthVariance();\n            if (skew > 0)\n                length += ctx.random().nextInt(skew+1);\n            else {\n                skew = 1 - skew;\n                int off = ctx.random().nextInt(skew);\n                if (ctx.random().nextBoolean())\n                    length += off;\n                else\n                    length -= off;\n            }\n        }\n        if (length < 0)\n            length = 0;\n        else if (length > 7) // as documented in tunnel.html\n            length = 7;\n        /*\n        if ( (ctx.tunnelManager().getOutboundTunnelCount() <= 0) || \n             (ctx.tunnelManager().getFreeTunnelCount() <= 0) ) {\n            Log log = ctx.logManager().getLog(TunnelPeerSelector.class);\n            // no tunnels to build tunnels with\n            if (settings.getAllowZeroHop()) {\n                if (log.shouldLog(Log.INFO))\n                    log.info(\"no outbound tunnels or free inbound tunnels, but we do allow zeroHop: \" + settings);\n                return 0;\n            } else {\n                if (log.shouldLog(Log.WARN))\n                    log.warn(\"no outbound tunnels or free inbound tunnels, and we dont allow zeroHop: \" + settings);\n                return -1;\n            }\n        }\n        */\n        return length;\n    }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Return settings.getTotalQuantity, unless this is an exploratory tunnel\n     *  AND exploratory build success rate is less than 1/10, AND total settings\n     *  is greater than 1. Otherwise subtract 1 to help prevent congestion collapse,\n     *  and prevent really unintegrated routers from working too hard.\n     *  We only do this for exploratory as different clients could have different\n     *  length settings. Although I guess inbound and outbound exploratory\n     *  could be different too, and inbound is harder...\n     *\n     *  @since 0.8.11\n     */\n    private int getAdjustedTotalQuantity() {\n        int rv = _settings.getTotalQuantity();\n        if (_settings.isExploratory() && rv > 1) {\n            RateStat e = _context.statManager().getRate(\"tunnel.buildExploratoryExpire\");\n            RateStat r = _context.statManager().getRate(\"tunnel.buildExploratoryReject\");\n            RateStat s = _context.statManager().getRate(\"tunnel.buildExploratorySuccess\");\n            if (e != null && r != null && s != null) {\n                // 60 min was too long - is 10 min too short?\n                // By not adding in previous period, this gives us a burst every\n                // 10 min - is that good or bad?\n                Rate er = e.getRate(10*60*1000);\n                Rate rr = r.getRate(10*60*1000);\n                Rate sr = s.getRate(10*60*1000);\n                if (er != null && rr != null && sr != null) {\n                    long ec = er.getCurrentEventCount();\n                    long rc = rr.getCurrentEventCount();\n                    long sc = sr.getCurrentEventCount();\n                    long tot = ec + rc + sc;\n                    if (tot >= 10) {\n                        if (1000 * sc / tot <=  1000 / 10)\n                            rv--;\n                    }\n                }\n            }\n        }\n        return rv;\n    }","id":51081,"modified_method":"/**\n     *  Return settings.getTotalQuantity, unless this is an exploratory tunnel\n     *  AND exploratory build success rate is less than 1/10, AND total settings\n     *  is greater than 1. Otherwise subtract 1 to help prevent congestion collapse,\n     *  and prevent really unintegrated routers from working too hard.\n     *  We only do this for exploratory as different clients could have different\n     *  length settings. Although I guess inbound and outbound exploratory\n     *  could be different too, and inbound is harder...\n     *\n     *  @since 0.8.11\n     */\n    private int getAdjustedTotalQuantity() {\n        int rv = _settings.getTotalQuantity();\n        if (_settings.isExploratory() && rv > 1) {\n            RateStat e = _context.statManager().getRate(\"tunnel.buildExploratoryExpire\");\n            RateStat r = _context.statManager().getRate(\"tunnel.buildExploratoryReject\");\n            RateStat s = _context.statManager().getRate(\"tunnel.buildExploratorySuccess\");\n            if (e != null && r != null && s != null) {\n                Rate er = e.getRate(10*60*1000);\n                Rate rr = r.getRate(10*60*1000);\n                Rate sr = s.getRate(10*60*1000);\n                if (er != null && rr != null && sr != null) {\n                    long ec = er.getCurrentEventCount() + er.getLastEventCount();\n                    long rc = rr.getCurrentEventCount() + rr.getLastEventCount();\n                    long sc = sr.getCurrentEventCount() + sr.getLastEventCount();\n                    long tot = ec + rc + sc;\n                    if (tot >= BUILD_TRIES_QUANTITY_OVERRIDE) {\n                        if (1000 * sc / tot <=  1000 / BUILD_TRIES_QUANTITY_OVERRIDE)\n                            rv--;\n                    }\n                }\n            }\n        }\n        return rv;\n    }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  @return null on failure\n     */\n    private PooledTunnelCreatorConfig configureNewTunnel(boolean forceZeroHop) {\n        TunnelPoolSettings settings = getSettings();\n        // peers for new tunnel, including us, ENDPOINT FIRST\n        List<Hash> peers = null;\n        long now = _context.clock().now();\n        long expiration = now + TunnelPoolSettings.DEFAULT_DURATION;\n\n        if (!forceZeroHop) {\n            int len = settings.getLength();\n            if (len > 0 && _context.random().nextBoolean()) {\n                // look for a tunnel to reuse, if the right length and expiring soon\n                // ignore variance for now.\n                len++;   // us\n                synchronized (_tunnels) {\n                    for (TunnelInfo ti : _tunnels) {\n                        if (ti.getLength() == len && ti.getExpiration() < now + 3*60*1000 && !ti.wasReused()) {\n                            ti.setReused();\n                            peers = new ArrayList(len);\n                            // peers list is ordered endpoint first, but cfg.getPeer() is ordered gateway first\n                            for (int i = len - 1; i >= 0; i--) {\n                                peers.add(ti.getPeer(i));\n                            }\n                        }\n                    }\n                }\n            }\n            if (peers == null)\n                peers = _peerSelector.selectPeers(_context, settings);\n\n            if ( (peers == null) || (peers.isEmpty()) ) {\n                // no peers to build the tunnel with, and \n                // the pool is refusing 0 hop tunnels\n                if (peers == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No peers to put in the new tunnel! selectPeers returned null!  boo, hiss!\");\n                } else {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No peers to put in the new tunnel! selectPeers returned an empty list?!\");\n                }\n                return null;\n            }\n        } else {\n            peers = new ArrayList(1);\n            peers.add(_context.routerHash());\n        }\n\n        PooledTunnelCreatorConfig cfg = new PooledTunnelCreatorConfig(_context, peers.size(), settings.isInbound(), settings.getDestination());\n        cfg.setTunnelPool(this);\n        // peers list is ordered endpoint first, but cfg.getPeer() is ordered gateway first\n        for (int i = 0; i < peers.size(); i++) {\n            int j = peers.size() - 1 - i;\n            cfg.setPeer(j, peers.get(i));\n            HopConfig hop = cfg.getConfig(j);\n            hop.setCreation(_context.clock().now());\n            hop.setExpiration(expiration);\n            hop.setIVKey(_context.keyGenerator().generateSessionKey());\n            hop.setLayerKey(_context.keyGenerator().generateSessionKey());\n            // tunnelIds will be updated during building, and as the creator, we\n            // don't need to worry about prev/next hop\n        }\n        cfg.setExpiration(expiration);\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Config contains \" + peers + \": \" + cfg);\n        synchronized (_inProgress) {\n            _inProgress.add(cfg);\n        }\n        return cfg;\n    }","id":51082,"modified_method":"/**\n     *  @return null on failure\n     */\n    private PooledTunnelCreatorConfig configureNewTunnel(boolean forceZeroHop) {\n        TunnelPoolSettings settings = getSettings();\n        // peers for new tunnel, including us, ENDPOINT FIRST\n        List<Hash> peers = null;\n        long now = _context.clock().now();\n        long expiration = now + TunnelPoolSettings.DEFAULT_DURATION;\n\n        if (!forceZeroHop) {\n            int len = settings.getLengthOverride();\n            if (len < 0)\n                len = settings.getLength();\n            if (len > 0 && _context.random().nextBoolean()) {\n                // look for a tunnel to reuse, if the right length and expiring soon\n                // ignore variance for now.\n                len++;   // us\n                synchronized (_tunnels) {\n                    for (TunnelInfo ti : _tunnels) {\n                        if (ti.getLength() >= len && ti.getExpiration() < now + 3*60*1000 && !ti.wasReused()) {\n                            ti.setReused();\n                            len = ti.getLength();\n                            peers = new ArrayList(len);\n                            // peers list is ordered endpoint first, but cfg.getPeer() is ordered gateway first\n                            for (int i = len - 1; i >= 0; i--) {\n                                peers.add(ti.getPeer(i));\n                            }\n                        }\n                    }\n                }\n            }\n            if (peers == null) {\n                setLengthOverride();\n                peers = _peerSelector.selectPeers(_context, settings);\n            }\n\n            if ( (peers == null) || (peers.isEmpty()) ) {\n                // no peers to build the tunnel with, and \n                // the pool is refusing 0 hop tunnels\n                if (peers == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No peers to put in the new tunnel! selectPeers returned null!  boo, hiss!\");\n                } else {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No peers to put in the new tunnel! selectPeers returned an empty list?!\");\n                }\n                return null;\n            }\n        } else {\n            peers = new ArrayList(1);\n            peers.add(_context.routerHash());\n        }\n\n        PooledTunnelCreatorConfig cfg = new PooledTunnelCreatorConfig(_context, peers.size(), settings.isInbound(), settings.getDestination());\n        cfg.setTunnelPool(this);\n        // peers list is ordered endpoint first, but cfg.getPeer() is ordered gateway first\n        for (int i = 0; i < peers.size(); i++) {\n            int j = peers.size() - 1 - i;\n            cfg.setPeer(j, peers.get(i));\n            HopConfig hop = cfg.getConfig(j);\n            hop.setCreation(_context.clock().now());\n            hop.setExpiration(expiration);\n            hop.setIVKey(_context.keyGenerator().generateSessionKey());\n            hop.setLayerKey(_context.keyGenerator().generateSessionKey());\n            // tunnelIds will be updated during building, and as the creator, we\n            // don't need to worry about prev/next hop\n        }\n        cfg.setExpiration(expiration);\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Config contains \" + peers + \": \" + cfg);\n        synchronized (_inProgress) {\n            _inProgress.add(cfg);\n        }\n        return cfg;\n    }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public TunnelPoolSettings() {\n        _quantity = DEFAULT_QUANTITY;\n        _backupQuantity = DEFAULT_BACKUP_QUANTITY;\n        // _rebuildPeriod = DEFAULT_REBUILD_PERIOD;\n        //_duration = DEFAULT_DURATION;\n        _length = DEFAULT_LENGTH;\n        _lengthVariance = DEFAULT_LENGTH_VARIANCE;\n        _allowZeroHop = DEFAULT_ALLOW_ZERO_HOP;\n        _IPRestriction = DEFAULT_IP_RESTRICTION;\n        _unknownOptions = new Properties();\n        _randomKey = generateRandomKey();\n    }","id":51083,"modified_method":"public TunnelPoolSettings() {\n        _quantity = DEFAULT_QUANTITY;\n        _backupQuantity = DEFAULT_BACKUP_QUANTITY;\n        // _rebuildPeriod = DEFAULT_REBUILD_PERIOD;\n        //_duration = DEFAULT_DURATION;\n        _length = DEFAULT_LENGTH;\n        _lengthVariance = DEFAULT_LENGTH_VARIANCE;\n        _lengthOverride = -1;\n        _allowZeroHop = DEFAULT_ALLOW_ZERO_HOP;\n        _IPRestriction = DEFAULT_IP_RESTRICTION;\n        _unknownOptions = new Properties();\n        _randomKey = generateRandomKey();\n    }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setLength(int length) { _length = length; }","id":51084,"modified_method":"/**\n     *  How many remote hops should be in the tunnel NOT including us\n     *  @param length 0 to 7 (not enforced here)\n     */\n    public void setLength(int length) { _length = length; }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** how many remote hops should be in the tunnel */\n    public int getLength() { return _length; }","id":51085,"modified_method":"/**\n     *  How many remote hops should be in the tunnel NOT including us\n     *  @return 0 to 7\n     */\n    public int getLength() { return _length; }","commit_id":"bf0947ee8256439ad3dc277b8db04e1240221169","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public EditPOIMenuController(OsmandApplication app, MapActivity mapActivity, PointDescription pointDescription, OsmPoint osmPoint) {\n\t\tsuper(new EditPOIMenuBuilder(app, osmPoint), pointDescription, mapActivity);\n\t\tthis.osmPoint = osmPoint;\n\t\tplugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);\n\n\t\tpoiUploader = new ProgressDialogPoiUploader() {\n\t\t\t@Override\n\t\t\tpublic void showProgressDialog(OsmPoint[] points, boolean closeChangeSet) {\n\t\t\t\tProgressDialog dialog = ProgressImplementation.createProgressDialog(\n\t\t\t\t\t\tgetMapActivity(),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.uploading),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.local_openstreetmap_uploading),\n\t\t\t\t\t\tProgressDialog.STYLE_HORIZONTAL).getDialog();\n\t\t\t\tOsmEditsUploadListener listener = new OsmEditsUploadListenerHelper(getMapActivity(),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.local_openstreetmap_were_uploaded)) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void uploadEnded(Map<OsmPoint, String> loadErrorsMap) {\n\t\t\t\t\t\tsuper.uploadEnded(loadErrorsMap);\n\t\t\t\t\t\tgetMapActivity().getContextMenu().close();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOpenstreetmapRemoteUtil remotepoi = new OpenstreetmapRemoteUtil(getMapActivity());\n\t\t\t\tOsmBugsRemoteUtil remotebug = new OsmBugsRemoteUtil(getMapActivity().getMyApplication());\n\t\t\t\tUploadOpenstreetmapPointAsyncTask uploadTask = new UploadOpenstreetmapPointAsyncTask(\n\t\t\t\t\t\tdialog, listener, plugin, remotepoi, remotebug, points.length, closeChangeSet);\n\t\t\t\tuploadTask.execute(points);\n\n\t\t\t\tdialog.show();\n\t\t\t}\n\t\t};\n\n\t\tleftTitleButtonController = new TitleButtonController() {\n\t\t\t@Override\n\t\t\tpublic void buttonPressed() {\n\t\t\t\tif (plugin != null) {\n\t\t\t\t\tSendPoiDialogFragment sendPoiDialogFragment = SendPoiDialogFragment.createInstance(new OsmPoint[]{getOsmPoint()});\n\t\t\t\t\tsendPoiDialogFragment.setPoiUploader(poiUploader);\n\t\t\t\t\tsendPoiDialogFragment.show(getMapActivity().getSupportFragmentManager(), SendPoiDialogFragment.TAG);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tleftTitleButtonController.caption = getMapActivity().getString(R.string.shared_string_upload);\n\t\tleftTitleButtonController.leftIconId = R.drawable.ic_action_export;\n\n\t\trightTitleButtonController = new TitleButtonController() {\n\t\t\t@Override\n\t\t\tpublic void buttonPressed() {\n\t\t\t\tAccessibleAlertBuilder bld = new AccessibleAlertBuilder(getMapActivity());\n\t\t\t\tbld.setMessage(R.string.recording_delete_confirm);\n\t\t\t\tbld.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tif (plugin != null) {\n\t\t\t\t\t\t\tboolean deleted = false;\n\t\t\t\t\t\t\tOsmPoint point = getOsmPoint();\n\t\t\t\t\t\t\tif (point instanceof OsmNotesPoint) {\n\t\t\t\t\t\t\t\tdeleted = plugin.getDBBug().deleteAllBugModifications((OsmNotesPoint) point);\n\t\t\t\t\t\t\t} else if (point instanceof OpenstreetmapPoint) {\n\t\t\t\t\t\t\t\tdeleted = plugin.getDBPOI().deletePOI((OpenstreetmapPoint) point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (deleted) {\n\t\t\t\t\t\t\t\tgetMapActivity().getContextMenu().close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbld.setNegativeButton(R.string.shared_string_no, null);\n\t\t\t\tbld.show();\n\t\t\t}\n\t\t};\n\t\trightTitleButtonController.caption = getMapActivity().getString(R.string.shared_string_delete);\n\t\trightTitleButtonController.leftIconId = R.drawable.ic_action_delete_dark;\n\n\t\tif (osmPoint.getGroup() == OsmPoint.Group.POI) {\n\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_created_poi);\n\t\t} else if (osmPoint.getGroup() == OsmPoint.Group.BUG) {\n\t\t\tif(osmPoint.getAction() == Action.DELETE) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_removed_note);\n\t\t\t} else if(osmPoint.getAction() == Action.MODIFY) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_commented_note);\n\t\t\t} else if(osmPoint.getAction() == Action.REOPEN) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_reopened_note);\n\t\t\t} else/* if(osmPoint.getAction() == Action.CREATE) */{\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_created_note);\n\t\t\t}\n\t\t} else {\n\t\t\tpointTypeStr = \"\";\n\t\t}\n\t}","id":51086,"modified_method":"public EditPOIMenuController(OsmandApplication app, MapActivity mapActivity, PointDescription pointDescription, OsmPoint osmPoint) {\n\t\tsuper(new EditPOIMenuBuilder(app, osmPoint), pointDescription, mapActivity);\n\t\tthis.osmPoint = osmPoint;\n\t\tplugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);\n\n\t\tpoiUploader = new ProgressDialogPoiUploader() {\n\t\t\t@Override\n\t\t\tpublic void showProgressDialog(OsmPoint[] points, boolean closeChangeSet) {\n\t\t\t\tProgressDialog dialog = ProgressImplementation.createProgressDialog(\n\t\t\t\t\t\tgetMapActivity(),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.uploading),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.local_openstreetmap_uploading),\n\t\t\t\t\t\tProgressDialog.STYLE_HORIZONTAL).getDialog();\n\t\t\t\tOsmEditsUploadListener listener = new OsmEditsUploadListenerHelper(getMapActivity(),\n\t\t\t\t\t\tgetMapActivity().getString(R.string.local_openstreetmap_were_uploaded)) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void uploadEnded(Map<OsmPoint, String> loadErrorsMap) {\n\t\t\t\t\t\tsuper.uploadEnded(loadErrorsMap);\n\t\t\t\t\t\tgetMapActivity().getContextMenu().close();\n\t\t\t\t\t\tOsmBugsLayer l = getMapActivity().getMapView().getLayerByClass(OsmBugsLayer.class);\n\t\t\t\t\t\tif(l != null) {\n\t\t\t\t\t\t\tl.clearCache();\n\t\t\t\t\t\t\tgetMapActivity().refreshMap();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOpenstreetmapRemoteUtil remotepoi = new OpenstreetmapRemoteUtil(getMapActivity());\n\t\t\t\tOsmBugsRemoteUtil remotebug = new OsmBugsRemoteUtil(getMapActivity().getMyApplication());\n\t\t\t\tUploadOpenstreetmapPointAsyncTask uploadTask = new UploadOpenstreetmapPointAsyncTask(\n\t\t\t\t\t\tdialog, listener, plugin, remotepoi, remotebug, points.length, closeChangeSet);\n\t\t\t\tuploadTask.execute(points);\n\n\t\t\t\tdialog.show();\n\t\t\t}\n\t\t};\n\n\t\tleftTitleButtonController = new TitleButtonController() {\n\t\t\t@Override\n\t\t\tpublic void buttonPressed() {\n\t\t\t\tif (plugin != null) {\n\t\t\t\t\tSendPoiDialogFragment sendPoiDialogFragment = SendPoiDialogFragment.createInstance(new OsmPoint[]{getOsmPoint()});\n\t\t\t\t\tsendPoiDialogFragment.setPoiUploader(poiUploader);\n\t\t\t\t\tsendPoiDialogFragment.show(getMapActivity().getSupportFragmentManager(), SendPoiDialogFragment.TAG);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tleftTitleButtonController.caption = getMapActivity().getString(R.string.shared_string_upload);\n\t\tleftTitleButtonController.leftIconId = R.drawable.ic_action_export;\n\n\t\trightTitleButtonController = new TitleButtonController() {\n\t\t\t@Override\n\t\t\tpublic void buttonPressed() {\n\t\t\t\tAccessibleAlertBuilder bld = new AccessibleAlertBuilder(getMapActivity());\n\t\t\t\tbld.setMessage(R.string.recording_delete_confirm);\n\t\t\t\tbld.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tif (plugin != null) {\n\t\t\t\t\t\t\tboolean deleted = false;\n\t\t\t\t\t\t\tOsmPoint point = getOsmPoint();\n\t\t\t\t\t\t\tif (point instanceof OsmNotesPoint) {\n\t\t\t\t\t\t\t\tdeleted = plugin.getDBBug().deleteAllBugModifications((OsmNotesPoint) point);\n\t\t\t\t\t\t\t} else if (point instanceof OpenstreetmapPoint) {\n\t\t\t\t\t\t\t\tdeleted = plugin.getDBPOI().deletePOI((OpenstreetmapPoint) point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (deleted) {\n\t\t\t\t\t\t\t\tgetMapActivity().getContextMenu().close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbld.setNegativeButton(R.string.shared_string_no, null);\n\t\t\t\tbld.show();\n\t\t\t}\n\t\t};\n\t\trightTitleButtonController.caption = getMapActivity().getString(R.string.shared_string_delete);\n\t\trightTitleButtonController.leftIconId = R.drawable.ic_action_delete_dark;\n\n\t\tif (osmPoint.getGroup() == OsmPoint.Group.POI) {\n\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_created_poi);\n\t\t} else if (osmPoint.getGroup() == OsmPoint.Group.BUG) {\n\t\t\tif(osmPoint.getAction() == Action.DELETE) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_removed_note);\n\t\t\t} else if(osmPoint.getAction() == Action.MODIFY) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_commented_note);\n\t\t\t} else if(osmPoint.getAction() == Action.REOPEN) {\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_reopened_note);\n\t\t\t} else/* if(osmPoint.getAction() == Action.CREATE) */{\n\t\t\t\tpointTypeStr = getMapActivity().getString(R.string.osm_edit_created_note);\n\t\t\t}\n\t\t} else {\n\t\t\tpointTypeStr = \"\";\n\t\t}\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onPrepareDialog(int id, Dialog dialog) {\n\t\tswitch (id) {\n\t\t\tcase DIALOG_BUG:\n//\t\t\t\t((EditText)dialog.findViewById(R.id.messageEditText)).setText(\"\");\n\t\t\t\tbreak;\n\t\t}\n\t}","id":51087,"modified_method":"@Override\n\tpublic void onPrepareDialog(int id, Dialog dialog) {\n\t\tswitch (id) {\n\t\t\tcase DIALOG_BUG:\n\t\t\t\tprepareBugDialog(dialogBundle, dialog);\n\t\t\t\t((EditText)dialog.findViewById(R.id.messageEditText)).setText(\"\");\n\t\t\t\tbreak;\n\t\t}\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private Dialog createBugDialog(final Bundle args) {\n\t\tfinal OpenStreetNote bug = (OpenStreetNote) args.getSerializable(KEY_BUG);\n\t\tfinal Action action = OsmBugsUtil.Action.valueOf((String) args.getSerializable(KEY_ACTION));\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(activity);\n\t\tint title ;\n\t\tif(action == Action.CLOSE) {\n\t\t\ttitle = R.string.osn_close_dialog_title;\n\t\t} else if(action == Action.MODIFY) {\n\t\t\ttitle = R.string.osn_comment_dialog_title;\n\t\t} else if(action == Action.REOPEN) {\n\t\t\ttitle = R.string.osn_reopen_dialog_title;\n\t\t} else {\n\t\t\ttitle = R.string.osn_add_dialog_title;\n\t\t}\n\t\tbuilder.setTitle(title);\n\t\tfinal View view = activity.getLayoutInflater().inflate(R.layout.open_bug, null);\n\t\tbuilder.setView(view);\n\t\t\n\t\tif(action == Action.CREATE && bug.comments.size() > 0) {\n\t\t\t((EditText)view.findViewById(R.id.messageEditText)).setText(bug.comments.get(0));\n\t\t}\n\t\tOsmBugsUtil util = getOsmbugsUtil(bug);\n\t\tfinal boolean offline =  util instanceof OsmBugsLocalUtil;\n\t\tif(offline) {\n\t\t\tview.findViewById(R.id.userNameEditText).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.userNameEditTextLabel).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.passwordEditText).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.passwordEditTextLabel).setVisibility(View.GONE);\n\t\t} else {\n\t\t\t((EditText)view.findViewById(R.id.userNameEditText)).setText(getUserName());\n\t\t\t((EditText)view.findViewById(R.id.passwordEditText)).setText(((OsmandApplication) activity.getApplication()).getSettings().USER_PASSWORD.get());\n\t\t}\n\t\tAndroidUtils.softKeyboardDelayed((EditText) view.findViewById(R.id.messageEditText));\n\t\tbuilder.setNegativeButton(R.string.shared_string_cancel, null);\n\t\tbuilder.setPositiveButton(title, new DialogInterface.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tif (bug != null) {\n\t\t\t\t\tString text = offline ? getMessageText(view) : getTextAndUpdateUserPwd(view);\n\t\t\t\t\t// server validation will handle it\n//\t\t\t\t\tif (us.length() == 0 || pwd.length() == 0) {\n//\t\t\t\t\t\tAccessibleToast.makeText(activity, activity.getString(R.string.osb_author_or_password_not_specified),\n//\t\t\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n//\t\t\t\t\t}\n\t\t\t\t\tif(action == Action.CLOSE) {\n\t\t\t\t\t\tclosingAsync(bug, text);\n\t\t\t\t\t} else if(action == Action.MODIFY) {\n\t\t\t\t\t\taddingCommentAsync(bug, text);\n\t\t\t\t\t} else if(action == Action.REOPEN) {\n\t\t\t\t\t\treopeningtAsync(bug, text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcreateNewBugAsync(bug.getLatitude(), bug.getLongitude(), text);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tactivity.getContextMenu().close();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn builder.create();\n\t}","id":51088,"modified_method":"private Dialog createBugDialog(final Bundle args) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(activity);\n\t\t\n\t\tbuilder.setTitle(\"\");\n\t\tfinal View view = activity.getLayoutInflater().inflate(R.layout.open_bug, null);\n\t\tview.setId(R.id.layout);\n\t\tbuilder.setView(view);\n\t\t\n\n\t\tbuilder.setNegativeButton(R.string.shared_string_cancel, null);\n\t\tbuilder.setPositiveButton(R.string.shared_string_commit, null);\n\t\treturn builder.create();\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void closingAsync(final OpenStreetNote bug, final String text) {\n\t\tAsyncTask<Void, Void, String> task = new AsyncTask<Void, Void, String>() {\n\t\t\tprivate OsmBugsUtil osmbugsUtil;\n\n\t\t\t@Override\n\t\t\tprotected String doInBackground(Void... params) {\n\t\t\t\tosmbugsUtil = getOsmbugsUtil(bug);\n\t\t\t\treturn osmbugsUtil.closingBug(bug.getLatitude(), bug.getLongitude(), bug.getId(), text);\n\t\t\t}\n\n\t\t\tprotected void onPostExecute(String closed) {\n\t\t\t\tif (closed == null) {\n\t\t\t\t\tif(local == osmbugsUtil) { \n\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osm_changes_added_to_local_edits, Toast.LENGTH_LONG).show();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osn_close_dialog_success, Toast.LENGTH_LONG).show();\n\t\t\t\t\t}\n\t\t\t\t\tclearCache();\n\t\t\t\t\trefreshMap();\n\t\t\t\t} else {\n\t\t\t\t\tAccessibleToast.makeText(activity, activity.getString(R.string.osn_close_dialog_error) + \"\\n\" + closed,\n\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\texecuteTaskInBackground(task);\n\t}","id":51089,"modified_method":"private void asyncActionTask(final OpenStreetNote bug, final String text, final Action action) {\n\t\tAsyncTask<Void, Void, OsmBugResult> task = new AsyncTask<Void, Void, OsmBugResult>() {\n\t\t\tprivate OsmBugsUtil osmbugsUtil;\n\t\t\t@Override\n\t\t\tprotected OsmBugResult doInBackground(Void... params) {\n\t\t\t\tosmbugsUtil = getOsmbugsUtil(bug);\n\t\t\t\tif(action == Action.REOPEN) {\n\t\t\t\t\treturn osmbugsUtil.reopenBug(bug.getLatitude(), bug.getLongitude(), bug.getId(), text);\n\t\t\t\t} else if(action == Action.MODIFY) {\n\t\t\t\t\treturn osmbugsUtil.addingComment(bug.getLatitude(), bug.getLongitude(), bug.getId(), text);\n\t\t\t\t} else if(action == Action.CLOSE) {\n\t\t\t\t\treturn osmbugsUtil.closingBug(bug.getLatitude(), bug.getLongitude(), bug.getId(), text);\n\t\t\t\t} else if(action == Action.CREATE) {\n\t\t\t\t\treturn osmbugsUtil.createNewBug(bug.getLatitude(), bug.getLongitude(), text);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tprotected void onPostExecute(OsmBugResult obj) {\n\t\t\t\tif (obj != null && obj.warning == null) {\n\t\t\t\t\tif(local == osmbugsUtil) { \n\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osm_changes_added_to_local_edits, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\tif(obj.local != null) {\n\t\t\t\t\t\t\tPointDescription pd = new PointDescription(PointDescription.POINT_TYPE_OSM_BUG, obj.local.getText());\n\t\t\t\t\t\t\tactivity.getContextMenu().show(new LatLon(obj.local.getLatitude(), obj.local.getLongitude()), pd, obj.local);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(action == Action.REOPEN) {\n\t\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osn_add_dialog_success, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t} else if(action == Action.MODIFY) {\n\t\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osb_comment_dialog_success, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t} else if(action == Action.CLOSE) {\n\t\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osn_close_dialog_success, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t} else if(action == Action.CREATE) {\n\t\t\t\t\t\t\tAccessibleToast.makeText(activity, R.string.osn_add_dialog_success, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tclearCache();\n\t\t\t\t} else {\n\t\t\t\t\tint r = R.string.osb_comment_dialog_error;\n\t\t\t\t\tif(action == Action.REOPEN) {\n\t\t\t\t\t\tr = R.string.osn_add_dialog_error;\n\t\t\t\t\t} else if(action == Action.CLOSE) {\n\t\t\t\t\t\tr = R.string.osn_close_dialog_error;\n\t\t\t\t\t} else if(action == Action.CREATE) {\n\t\t\t\t\t\tr = R.string.osn_add_dialog_error;\n\t\t\t\t\t}\n\t\t\t\t\tAccessibleToast.makeText(activity, activity.getResources().getString(r) + \"\\n\" + obj, Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\texecuteTaskInBackground(task);\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String closingBug(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(id);\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.DELETE);\n\t\treturn db.addOsmbugs(p) ? null : \"\";\n\t}","id":51090,"modified_method":"@Override\n\tpublic OsmBugResult closingBug(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(id);\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.DELETE);\n\t\treturn wrap(p, db.addOsmbugs(p));\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String addingComment(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(id);\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.MODIFY);\n\t\treturn db.addOsmbugs(p) ? null : \"\";\n\t}","id":51091,"modified_method":"@Override\n\tpublic OsmBugResult addingComment(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(id);\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.MODIFY);\n\t\treturn wrap(p, db.addOsmbugs(p));\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String createNewBug(double latitude, double longitude, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(Math.min(-2, db.getMinID() -1));\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.CREATE);\n\t\treturn db.addOsmbugs(p) ? null : \"\";\n\t}","id":51092,"modified_method":"@Override\n\tpublic OsmBugResult createNewBug(double latitude, double longitude, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(Math.min(-2, db.getMinID() -1));\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.CREATE);\n\t\treturn wrap(p, db.addOsmbugs(p));\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String reopenBug(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(Math.min(-2, db.getMinID() -1));\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.REOPEN);\n\t\treturn db.addOsmbugs(p) ? null : \"\";\n\t}","id":51093,"modified_method":"@Override\n\tpublic OsmBugResult reopenBug(double latitude, double longitude, long id, String text){\n\t\tOsmNotesPoint p = new OsmNotesPoint();\n\t\tp.setId(Math.min(-2, db.getMinID() -1));\n\t\tp.setText(text);\n\t\tp.setLatitude(latitude);\n\t\tp.setLongitude(longitude);\n\t\tp.setAction(OsmPoint.Action.REOPEN);\n\t\treturn wrap(p, db.addOsmbugs(p));\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String addingComment(double latitude, double longitude, long id, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"/\");\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/comment?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"adding comment\"); //$NON-NLS-1$\n\t}","id":51094,"modified_method":"@Override\n\tpublic OsmBugResult addingComment(double latitude, double longitude, long id, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"/\");\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/comment?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"adding comment\"); //$NON-NLS-1$\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String closingBug(double latitude, double longitude, long id, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"/\");\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/close?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"close bug\"); //$NON-NLS-1$\n\t}","id":51095,"modified_method":"@Override\n\tpublic OsmBugResult closingBug(double latitude, double longitude, long id, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"/\");\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/close?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"close bug\"); //$NON-NLS-1$\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String reopenBug(double latitude, double longitude, long id, String text){\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"?\"); //$NON-NLS-1$\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/reopen?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"reopen bug\"); //$NON-NLS-1$\n\t}","id":51096,"modified_method":"@Override\n\tpublic OsmBugResult reopenBug(double latitude, double longitude, long id, String text){\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"?\"); //$NON-NLS-1$\n\t\tb.append(id); //$NON-NLS-1$\n\t\tb.append(\"/reopen?text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"reopen bug\"); //$NON-NLS-1$\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private String editingPOI(String url, String requestMethod, String userOperation) {\n\t\ttry {\n\t\t\tHttpURLConnection connection = NetworkUtils.getHttpURLConnection(url);\n\t\t\tlog.info(\"Editing poi \" + url);\n\t\t\tconnection.setConnectTimeout(15000);\n\t\t\tconnection.setRequestMethod(requestMethod);\n\t\t\tconnection.setRequestProperty(\"User-Agent\", Version.getFullVersion(app)); //$NON-NLS-1$\n\t\t\tif (true) {\n\t\t\t\tString token = settings.USER_NAME.get() + \":\" + settings.USER_PASSWORD.get(); //$NON-NLS-1$\n\t\t\t\tconnection.addRequestProperty(\"Authorization\", \"Basic \" + Base64.encode(token.getBytes(\"UTF-8\"))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t}\n\t\t\tconnection.setDoInput(true);\n\t\t\tif (requestMethod.equals(\"PUT\") || requestMethod.equals(\"POST\") || requestMethod.equals(\"DELETE\")) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t// connection.setDoOutput(true);\n\t\t\t\t//\t\t\t\tconnection.setRequestProperty(\"Content-type\", \"text/xml\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t// OutputStream out = connection.getOutputStream();\n\t\t\t\t// String requestBody = null;\n\t\t\t\t// if (requestBody != null) {\n\t\t\t\t//\t\t\t\t\tBufferedWriter bwr = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"), 1024); //$NON-NLS-1$\n\t\t\t\t// bwr.write(requestBody);\n\t\t\t\t// bwr.flush();\n\t\t\t\t// }\n\t\t\t\t// out.close();\n\t\t\t}\n\t\t\tconnection.connect();\n\t\t\tString msg = connection.getResponseMessage();\n\t\t\tboolean ok = connection.getResponseCode() == HttpURLConnection.HTTP_OK;\n\t\t\tlog.info(msg); //$NON-NLS-1$\n\t\t\t// populate return fields.\n\n\t\t\tStringBuilder responseBody = Algorithms.readFromInputStream(connection.getInputStream());\n\t\t\tlog.info(\"Response : \" + responseBody); //$NON-NLS-1$\n\t\t\tconnection.disconnect();\n\t\t\tif (!ok) {\n\t\t\t\treturn msg + \"\\n\" + responseBody;\n\t\t\t}\n\t\t} catch (NullPointerException e) {\n\t\t\t// that's tricky case why NPE is thrown to fix that problem httpClient could be used\n\t\t\tString msg = app.getString(R.string.auth_failed);\n\t\t\tlog.error(msg, e);\n\t\t\treturn app.getString(R.string.auth_failed) + \"\";\n\t\t} catch (MalformedURLException e) {\n\t\t\tlog.error(userOperation + \" \" + app.getString(R.string.failed_op), e); //$NON-NLS-1$\n\t\t\treturn e.getMessage() + \"\";\n\t\t} catch (IOException e) {\n\t\t\tlog.error(userOperation + \" \" + app.getString(R.string.failed_op), e); //$NON-NLS-1$\n\t\t\treturn e.getMessage() + \" link unavailable\";\n\t\t}\n\t\treturn null;\n\t}","id":51097,"modified_method":"private OsmBugResult editingPOI(String url, String requestMethod, String userOperation) {\n\t\tOsmBugResult r = new OsmBugResult();\n\t\ttry {\n\t\t\tHttpURLConnection connection = NetworkUtils.getHttpURLConnection(url);\n\t\t\tlog.info(\"Editing poi \" + url);\n\t\t\tconnection.setConnectTimeout(15000);\n\t\t\tconnection.setRequestMethod(requestMethod);\n\t\t\tconnection.setRequestProperty(\"User-Agent\", Version.getFullVersion(app)); //$NON-NLS-1$\n\t\t\tif (true) {\n\t\t\t\tString token = settings.USER_NAME.get() + \":\" + settings.USER_PASSWORD.get(); //$NON-NLS-1$\n\t\t\t\tconnection.addRequestProperty(\"Authorization\", \"Basic \" + Base64.encode(token.getBytes(\"UTF-8\"))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t}\n\t\t\tconnection.setDoInput(true);\n\t\t\tif (requestMethod.equals(\"PUT\") || requestMethod.equals(\"POST\") || requestMethod.equals(\"DELETE\")) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t// connection.setDoOutput(true);\n\t\t\t\t//\t\t\t\tconnection.setRequestProperty(\"Content-type\", \"text/xml\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t// OutputStream out = connection.getOutputStream();\n\t\t\t\t// String requestBody = null;\n\t\t\t\t// if (requestBody != null) {\n\t\t\t\t//\t\t\t\t\tBufferedWriter bwr = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"), 1024); //$NON-NLS-1$\n\t\t\t\t// bwr.write(requestBody);\n\t\t\t\t// bwr.flush();\n\t\t\t\t// }\n\t\t\t\t// out.close();\n\t\t\t}\n\t\t\tconnection.connect();\n\t\t\tString msg = connection.getResponseMessage();\n\t\t\tboolean ok = connection.getResponseCode() == HttpURLConnection.HTTP_OK;\n\t\t\tlog.info(msg); //$NON-NLS-1$\n\t\t\t// populate return fields.\n\n\t\t\tStringBuilder responseBody = Algorithms.readFromInputStream(connection.getInputStream());\n\t\t\tlog.info(\"Response : \" + responseBody); //$NON-NLS-1$\n\t\t\tconnection.disconnect();\n\t\t\tif (!ok) {\n\t\t\t\tr.warning =  msg + \"\\n\" + responseBody;\n\t\t\t}\n\t\t} catch (NullPointerException e) {\n\t\t\t// that's tricky case why NPE is thrown to fix that problem httpClient could be used\n\t\t\tString msg = app.getString(R.string.auth_failed);\n\t\t\tlog.error(msg, e);\n\t\t\tr.warning =  app.getString(R.string.auth_failed) + \"\";\n\t\t} catch (MalformedURLException e) {\n\t\t\tlog.error(userOperation + \" \" + app.getString(R.string.failed_op), e); //$NON-NLS-1$\n\t\t\tr.warning = e.getMessage() + \"\";\n\t\t} catch (IOException e) {\n\t\t\tlog.error(userOperation + \" \" + app.getString(R.string.failed_op), e); //$NON-NLS-1$\n\t\t\tr.warning = e.getMessage() + \" link unavailable\";\n\t\t}\n\t\treturn r;\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String createNewBug(double latitude, double longitude, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"?\"); //$NON-NLS-1$\n\t\tb.append(\"lat=\").append(latitude); //$NON-NLS-1$\n\t\tb.append(\"&lon=\").append(longitude); //$NON-NLS-1$\n\t\tb.append(\"&text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"creating bug\"); //$NON-NLS-1$\n\t}","id":51098,"modified_method":"@Override\n\tpublic OsmBugResult createNewBug(double latitude, double longitude, String text) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(getNotesApi()).append(\"?\"); //$NON-NLS-1$\n\t\tb.append(\"lat=\").append(latitude); //$NON-NLS-1$\n\t\tb.append(\"&lon=\").append(longitude); //$NON-NLS-1$\n\t\tb.append(\"&text=\").append(URLEncoder.encode(text)); //$NON-NLS-1$\n\t\treturn editingPOI(b.toString(), \"POST\", \"creating bug\"); //$NON-NLS-1$\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected Map<OsmPoint, String> doInBackground(OsmPoint... points) {\n\t\tMap<OsmPoint, String> loadErrorsMap = new HashMap<>();\n\n\t\tboolean uploaded = false;\n\t\tfor (OsmPoint point : points) {\n\t\t\tif (interruptUploading)\n\t\t\t\tbreak;\n\n\t\t\tif (point.getGroup() == OsmPoint.Group.POI) {\n\t\t\t\tOpenstreetmapPoint p = (OpenstreetmapPoint) point;\n\t\t\t\tEntityInfo entityInfo = null;\n\t\t\t\tif (OsmPoint.Action.CREATE != p.getAction()) {\n\t\t\t\t\tentityInfo = remotepoi.loadNode(p.getEntity());\n\t\t\t\t}\n\t\t\t\tNode n = remotepoi.commitNodeImpl(p.getAction(), p.getEntity(), entityInfo,\n\t\t\t\t\t\tp.getComment(), false);\n\t\t\t\tif (n != null) {\n\t\t\t\t\tuploaded = true;\n\t\t\t\t\tplugin.getDBPOI().deletePOI(p);\n\t\t\t\t\tpublishProgress(p);\n\t\t\t\t}\n\t\t\t\tloadErrorsMap.put(point, n != null ? null : \"Unknown problem\");\n\t\t\t} else if (point.getGroup() == OsmPoint.Group.BUG) {\n\t\t\t\tOsmNotesPoint p = (OsmNotesPoint) point;\n\t\t\t\tString errorMessage = null;\n\t\t\t\tif (p.getAction() == OsmPoint.Action.CREATE) {\n\t\t\t\t\terrorMessage = remotebug.createNewBug(p.getLatitude(), p.getLongitude(), p.getText());\n\t\t\t\t} else if (p.getAction() == OsmPoint.Action.MODIFY) {\n\t\t\t\t\terrorMessage = remotebug.addingComment(p.getLatitude(), p.getLongitude(), p.getId(), p.getText());\n\t\t\t\t} else if (p.getAction() == OsmPoint.Action.DELETE) {\n\t\t\t\t\terrorMessage = remotebug.closingBug(p.getLatitude(), p.getLongitude(), p.getId(), p.getText());\n\t\t\t\t}\n\t\t\t\tif (errorMessage == null) {\n\t\t\t\t\tplugin.getDBBug().deleteAllBugModifications(p);\n\t\t\t\t\tpublishProgress(p);\n\t\t\t\t}\n\t\t\t\tloadErrorsMap.put(point, errorMessage);\n\t\t\t}\n\t\t}\n\t\tif(uploaded && closeChangeSet) {\n\t\t\tremotepoi.closeChangeSet();\n\t\t}\n\n\t\treturn loadErrorsMap;\n\t}","id":51099,"modified_method":"@Override\n\tprotected Map<OsmPoint, String> doInBackground(OsmPoint... points) {\n\t\tMap<OsmPoint, String> loadErrorsMap = new HashMap<>();\n\n\t\tboolean uploaded = false;\n\t\tfor (OsmPoint point : points) {\n\t\t\tif (interruptUploading)\n\t\t\t\tbreak;\n\n\t\t\tif (point.getGroup() == OsmPoint.Group.POI) {\n\t\t\t\tOpenstreetmapPoint p = (OpenstreetmapPoint) point;\n\t\t\t\tEntityInfo entityInfo = null;\n\t\t\t\tif (OsmPoint.Action.CREATE != p.getAction()) {\n\t\t\t\t\tentityInfo = remotepoi.loadNode(p.getEntity());\n\t\t\t\t}\n\t\t\t\tNode n = remotepoi.commitNodeImpl(p.getAction(), p.getEntity(), entityInfo,\n\t\t\t\t\t\tp.getComment(), false);\n\t\t\t\tif (n != null) {\n\t\t\t\t\tuploaded = true;\n\t\t\t\t\tplugin.getDBPOI().deletePOI(p);\n\t\t\t\t\tpublishProgress(p);\n\t\t\t\t}\n\t\t\t\tloadErrorsMap.put(point, n != null ? null : \"Unknown problem\");\n\t\t\t} else if (point.getGroup() == OsmPoint.Group.BUG) {\n\t\t\t\tOsmNotesPoint p = (OsmNotesPoint) point;\n\t\t\t\tString errorMessage = null;\n\t\t\t\tif (p.getAction() == OsmPoint.Action.CREATE) {\n\t\t\t\t\terrorMessage = remotebug.createNewBug(p.getLatitude(), p.getLongitude(), p.getText()).warning;\n\t\t\t\t} else if (p.getAction() == OsmPoint.Action.MODIFY) {\n\t\t\t\t\terrorMessage = remotebug.addingComment(p.getLatitude(), p.getLongitude(), p.getId(), p.getText()).warning;\n\t\t\t\t} else if (p.getAction() == OsmPoint.Action.REOPEN) {\n\t\t\t\t\terrorMessage = remotebug.reopenBug(p.getLatitude(), p.getLongitude(), p.getId(), p.getText()).warning;\n\t\t\t\t} else if (p.getAction() == OsmPoint.Action.DELETE) {\n\t\t\t\t\terrorMessage = remotebug.closingBug(p.getLatitude(), p.getLongitude(), p.getId(), p.getText()).warning;\n\t\t\t\t}\n\t\t\t\tif (errorMessage == null) {\n\t\t\t\t\tplugin.getDBBug().deleteAllBugModifications(p);\n\t\t\t\t\tpublishProgress(p);\n\t\t\t\t}\n\t\t\t\tloadErrorsMap.put(point, errorMessage);\n\t\t\t}\n\t\t}\n\t\tif(uploaded && closeChangeSet) {\n\t\t\tremotepoi.closeChangeSet();\n\t\t}\n\n\t\treturn loadErrorsMap;\n\t}","commit_id":"e4b8bb59ef55a05c81f56725ae958e5f90757057","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":51100,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","commit_id":"d2dea56088120323791dfddbc3c4aac152d9e894","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildMessage( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","id":51101,"modified_method":"private static String message( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","commit_id":"d2dea56088120323791dfddbc3c4aac152d9e894","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MediaTypeNotSupportedException( Collection<MediaType> supported, MediaType... requested )\n    {\n        super( buildMessage( supported, requested ) );\n    }","id":51102,"modified_method":"public MediaTypeNotSupportedException( Response.Status status, Collection<MediaType> supported,\n                                           MediaType... requested )\n    {\n        super( createResponse( status, message( supported, requested ) ) );\n    }","commit_id":"d2dea56088120323791dfddbc3c4aac152d9e894","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n            throws MediaTypeNotSupportedException\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(),\n                acceptable.toArray( new MediaType[acceptable.size()] ) );\n    }","id":51103,"modified_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        return new OutputFormat( new NullFormat(formats.keySet(), acceptable.toArray( new MediaType[acceptable.size()] )), baseUri, injector );\n    }","commit_id":"d2dea56088120323791dfddbc3c4aac152d9e894","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InputFormat inputFormat( MediaType type ) throws MediaTypeNotSupportedException\n    {\n        if ( type == null ) return NULL_FORMAT;\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(), type );\n    }","id":51104,"modified_method":"public InputFormat inputFormat( MediaType type )\n    {\n        if(type == null)\n        {\n            return new NullFormat( formats.keySet() );\n        }\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        return new NullFormat( formats.keySet(), type );\n    }","commit_id":"d2dea56088120323791dfddbc3c4aac152d9e894","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":51105,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","commit_id":"176b2b608e2e6abf7536a84a2d7cd635444bd07d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MediaTypeNotSupportedException( Collection<MediaType> supported, MediaType... requested )\n    {\n        super( buildMessage( supported, requested ) );\n    }","id":51106,"modified_method":"public MediaTypeNotSupportedException( Response.Status status, Collection<MediaType> supported,\n                                           MediaType... requested )\n    {\n        super( createResponse( status, message( supported, requested ) ) );\n    }","commit_id":"176b2b608e2e6abf7536a84a2d7cd635444bd07d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildMessage( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","id":51107,"modified_method":"private static String message( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","commit_id":"176b2b608e2e6abf7536a84a2d7cd635444bd07d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n            throws MediaTypeNotSupportedException\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(),\n                acceptable.toArray( new MediaType[acceptable.size()] ) );\n    }","id":51108,"modified_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        return new OutputFormat( new NullFormat(formats.keySet(), acceptable.toArray( new MediaType[acceptable.size()] )), baseUri, injector );\n    }","commit_id":"176b2b608e2e6abf7536a84a2d7cd635444bd07d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InputFormat inputFormat( MediaType type ) throws MediaTypeNotSupportedException\n    {\n        if ( type == null ) return NULL_FORMAT;\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(), type );\n    }","id":51109,"modified_method":"public InputFormat inputFormat( MediaType type )\n    {\n        if(type == null)\n        {\n            return new NullFormat( formats.keySet() );\n        }\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        return new NullFormat( formats.keySet(), type );\n    }","commit_id":"176b2b608e2e6abf7536a84a2d7cd635444bd07d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":51110,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","commit_id":"e9838fce35da5259514d8391f7725261edf2609c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MediaTypeNotSupportedException( Collection<MediaType> supported, MediaType... requested )\n    {\n        super( buildMessage( supported, requested ) );\n    }","id":51111,"modified_method":"public MediaTypeNotSupportedException( Response.Status status, Collection<MediaType> supported,\n                                           MediaType... requested )\n    {\n        super( createResponse( status, message( supported, requested ) ) );\n    }","commit_id":"e9838fce35da5259514d8391f7725261edf2609c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildMessage( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","id":51112,"modified_method":"private static String message( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","commit_id":"e9838fce35da5259514d8391f7725261edf2609c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n            throws MediaTypeNotSupportedException\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(),\n                acceptable.toArray( new MediaType[acceptable.size()] ) );\n    }","id":51113,"modified_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        return new OutputFormat( new NullFormat(formats.keySet(), acceptable.toArray( new MediaType[acceptable.size()] )), baseUri, injector );\n    }","commit_id":"e9838fce35da5259514d8391f7725261edf2609c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InputFormat inputFormat( MediaType type ) throws MediaTypeNotSupportedException\n    {\n        if ( type == null ) return NULL_FORMAT;\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(), type );\n    }","id":51114,"modified_method":"public InputFormat inputFormat( MediaType type )\n    {\n        if(type == null)\n        {\n            return new NullFormat( formats.keySet() );\n        }\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        return new NullFormat( formats.keySet(), type );\n    }","commit_id":"e9838fce35da5259514d8391f7725261edf2609c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":51115,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","commit_id":"70a1fcf290e6a83856c4b8827e00379cd620d240","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildMessage( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","id":51116,"modified_method":"private static String message( Collection<MediaType> supported, MediaType[] requested )\n    {\n        StringBuilder message = new StringBuilder( \"No matching representation format found.\\n\" );\n        if ( requested.length == 0 )\n        {\n            message.append( \"No requested representation format supplied.\" );\n        }\n        else if ( requested.length == 1 )\n        {\n            message.append( \"Request format: \" ).append( requested[0] ).append( \"\\n\" );\n        }\n        else\n        {\n            message.append( \"Requested formats:\\n\" );\n            for ( int i = 0; i < requested.length; i++ )\n            {\n                message.append( \" \" ).append( i ).append( \". \" );\n                message.append( requested[i] ).append( \"\\n\" );\n            }\n        }\n        message.append( \"Supported representation formats:\" );\n        if ( supported.isEmpty() )\n        {\n            message.append( \" none\" );\n        }\n        else\n        {\n            for ( MediaType type : supported )\n            {\n                message.append( \"\\n * \" ).append( type );\n            }\n        }\n        return message.toString();\n    }","commit_id":"70a1fcf290e6a83856c4b8827e00379cd620d240","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MediaTypeNotSupportedException( Collection<MediaType> supported, MediaType... requested )\n    {\n        super( buildMessage( supported, requested ) );\n    }","id":51117,"modified_method":"public MediaTypeNotSupportedException( Response.Status status, Collection<MediaType> supported,\n                                           MediaType... requested )\n    {\n        super( createResponse( status, message( supported, requested ) ) );\n    }","commit_id":"70a1fcf290e6a83856c4b8827e00379cd620d240","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InputFormat inputFormat( MediaType type ) throws MediaTypeNotSupportedException\n    {\n        if ( type == null ) return NULL_FORMAT;\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(), type );\n    }","id":51118,"modified_method":"public InputFormat inputFormat( MediaType type )\n    {\n        if(type == null)\n        {\n            return new NullFormat( formats.keySet() );\n        }\n\n        RepresentationFormat format = formats.get( type );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        format = formats.get( new MediaType( type.getType(), type.getSubtype() ) );\n        if ( format != null )\n        {\n            return format;\n        }\n\n        return new NullFormat( formats.keySet(), type );\n    }","commit_id":"70a1fcf290e6a83856c4b8827e00379cd620d240","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n            throws MediaTypeNotSupportedException\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        throw new MediaTypeNotSupportedException( formats.keySet(),\n                acceptable.toArray( new MediaType[acceptable.size()] ) );\n    }","id":51119,"modified_method":"public OutputFormat outputFormat( List<MediaType> acceptable, URI baseUri )\n    {\n        for ( MediaType type : acceptable )\n        {\n            RepresentationFormat format = formats.get( type );\n            if ( format != null )\n            {\n                return new OutputFormat( format, baseUri, injector );\n            }\n        }\n\n        return new OutputFormat( new NullFormat(formats.keySet(), acceptable.toArray( new MediaType[acceptable.size()] )), baseUri, injector );\n    }","commit_id":"70a1fcf290e6a83856c4b8827e00379cd620d240","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ImagePainter(int width, int height, long backgroundColor) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.defaultCol = BLACK;\r\n        this.defaultMode = MODE_REPLACE;\r\n        grid = new long[width*height];\r\n        for (int n= width * height - 1; n >= 0; n--) grid[n] = backgroundColor;\r\n    }","id":51120,"modified_method":"public ImagePainter(int width, int height, long backgroundColor) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.defaultCol = ADDITIVE_BLACK;\r\n        this.defaultMode = MODE_REPLACE;\r\n        grid = new long[width*height];\r\n        for (int n= width * height - 1; n >= 0; n--) grid[n] = backgroundColor;\r\n    }","commit_id":"d98ed41f311496d7473390efcb5f21d2b5d4d9d1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void plot(int x, int y) {\r\n        if ((x < 0) || (x >= width)) return;\r\n        if ((y < 0) || (y >= height)) return;\r\n        if (defaultMode == MODE_REPLACE) {\r\n            grid[x + y * width] = defaultCol;\r\n        } else if (defaultMode == MODE_MIX) {\r\n            int n = x + y * width;\r\n            long c = grid[n];\r\n            if (c < 0) {\r\n                grid[n] = defaultCol;\r\n            } else {\r\n                int r = ((int) ((c >> 16) + (defaultCol >> 16))) & 0xff;\r\n                int g = ((int) (((c >> 8) & 0xff) + ((defaultCol >> 8) & 0xff))) & 0xff;\r\n                int b = ((int) ((c & 0xff) + (defaultCol & 0xff))) & 0xff;\r\n                grid[n] = r << 16 | g << 8 | b;\r\n            }\r\n        }\r\n    }","id":51121,"modified_method":"private void plot(int x, int y) {\r\n        if ((x < 0) || (x >= width)) return;\r\n        if ((y < 0) || (y >= height)) return;\r\n        if (defaultMode == MODE_REPLACE) {\r\n            grid[x + y * width] = defaultCol;\r\n        } else if (defaultMode == MODE_ADD) {\r\n            int n = x + y * width;\r\n            long c = grid[n];\r\n            if (c < 0) {\r\n                grid[n] = defaultCol;\r\n            } else {\r\n                int r = ((int) ((c >> 16) + (defaultCol >> 16))); if (r > 0xff) r = 0xff;\r\n                int g = ((int) (((c >> 8) & 0xff) + ((defaultCol >> 8) & 0xff))); if (g > 0xff) g = 0xff;\r\n                int b = ((int) ((c & 0xff) + (defaultCol & 0xff))); if (b > 0xff) b = 0xff;\r\n                grid[n] = r << 16 | g << 8 | b;\r\n            }\r\n        } else if (defaultMode == MODE_SUB) {\r\n            int n = x + y * width;\r\n            long c = grid[n];\r\n            if (c < 0) c = 0xffffff;\r\n            int r = ((int) ((c >> 16) - (defaultCol >> 16))); if (r < 0) r = 0;\r\n            int g = ((int) (((c >> 8) & 0xff) - ((defaultCol >> 8) & 0xff))); if (g < 0) g = 0;\r\n            int b = ((int) ((c & 0xff) - (defaultCol & 0xff))); if (g < 0) g = 0;\r\n            grid[n] = r << 16 | g << 8 | b;\r\n        }\r\n    }","commit_id":"d98ed41f311496d7473390efcb5f21d2b5d4d9d1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public BufferedImage toImage(boolean complementary) {\r\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D gr = bi.createGraphics();\r\n        gr.setBackground(Color.white);\r\n        gr.clearRect(0, 0, width, height);\r\n\r\n        WritableRaster wr = bi.getRaster();\r\n        long c;\r\n        int r, g, b, m, n, d;\r\n        for (int i = width - 1; i >= 0; i--) {\r\n            for (int j = height - 1; j >= 0; j--) {\r\n                c = grid[i + j * width];\r\n                if (c >= 0) {\r\n                    r = (int) (c >> 16);\r\n                    g = (int) ((c >> 8) & 0xff);\r\n                    b = (int) (c & 0xff);\r\n                    m = Math.max(g + b, Math.max(r + b, r + g)); // max of m = 0x1fe\r\n                    n = Math.max(r, Math.max(g, b));\r\n                    d = 1 + ((m + n) / 0x1ff);\r\n                    if (complementary) {\r\n                        wr.setPixel(i, j, new int[]{(m + 2 * r - g - b) / d, (m + 2 * g - r - b) / d , (m + 2 * b - r - g) / d});\r\n                    } else {\r\n                        wr.setPixel(i, j, new int[]{r, g, b});\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return bi;\r\n    }","id":51122,"modified_method":"public BufferedImage toImage(boolean complementary) {\r\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D gr = bi.createGraphics();\r\n        gr.setBackground(Color.white);\r\n        gr.clearRect(0, 0, width, height);\r\n        \r\n        WritableRaster wr = bi.getRaster();\r\n        long c;\r\n        if (complementary) {\r\n            int r, g, b;\r\n            // then set pixels\r\n            for (int i = width - 1; i >= 0; i--) {\r\n                for (int j = height - 1; j >= 0; j--) {\r\n                    c = grid[i + j * width];\r\n                    if (c >= 0) {\r\n                        r = (int) (c >> 16);\r\n                        g = (int) ((c >> 8) & 0xff);\r\n                        b = (int) (c & 0xff);\r\n                        wr.setPixel(i, j, new int[]{(0x1fe - g - b) / 2, (0x1fe - r - b) / 2, (0x1fe - r - g) / 2});\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = width - 1; i >= 0; i--) {\r\n                for (int j = height - 1; j >= 0; j--) {\r\n                    c = grid[i + j * width];\r\n                    if (c >= 0) {\r\n                        wr.setPixel(i, j, new int[]{(int) (c >> 16), (int) ((c >> 8) & 0xff), (int) (c & 0xff)});\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return bi;\r\n    }","commit_id":"d98ed41f311496d7473390efcb5f21d2b5d4d9d1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static BufferedImage respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        /*\r\n        BufferedImage bi = new BufferedImage(640, 400, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, 640, 400);\r\n        \r\n        g.setColor(new Color(200, 200, 0));\r\n        g.drawRect(100, 50, 40, 30);\r\n        \r\n        g.setColor(new Color(0, 0, 200));\r\n        try {\r\n            Class[] pType    = {Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE};\r\n            Object[] pParam = new Integer[]{new Integer(66), new Integer(55), new Integer(80), new Integer(80)};\r\n            \r\n            String com = \"drawRect\";\r\n            Method m = g.getClass().getMethod(com, pType);\r\n            Object result = m.invoke(g, pParam);\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        WritableRaster r = bi.getRaster();\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 30, new int[]{255, 0, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 32, new int[]{0, 255, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 34, new int[]{0, 0, 255});\r\n        return bi;\r\n        */\r\n        ImagePainter img = new ImagePainter(800, 600, ImagePainter.TRANSPARENT);\r\n        \r\n        img.setMode(ImagePainter.MODE_MIX);\r\n        img.setColor(ImagePainter.BLACK);\r\n        for (int y = 0; y < 600; y = y + 50) img.print(0, y, \"\" + y);\r\n        for (int x = 0; x < 800; x = x + 50) img.print(x, 10, \"\" + x);\r\n        img.setColor(ImagePainter.BLUE);\r\n        img.dot(150, 100, 90, true);\r\n        img.setColor(ImagePainter.GREEN);\r\n        img.dot(190, 130, 60, true);\r\n        img.setColor(ImagePainter.RED);\r\n        img.arc(300, 270, 30, 70, 0, 360);\r\n        img.setColor(\"AA0000\");\r\n        img.arc(220, 90, 50, 90, 30, 110);\r\n        img.arc(210, 77, 50, 90, 30, 110);\r\n        img.setColor(ImagePainter.WHITE);\r\n        img.print(50, 100, \"BROADCAST MESSAGE #772: NODE %882 WHITE abcefghijklmnopqrstuvwxyz\");\r\n        img.setColor(ImagePainter.BLACK);\r\n        img.print(50, 110, \"BROADCAST MESSAGE #772: NODE %882 BLACK abcefghijklmnopqrstuvwxyz\");\r\n        img.setColor(ImagePainter.GREEN);\r\n        img.print(50, 120, \"BROADCAST MESSAGE #772: NODE %882 GREEN abcefghijklmnopqrstuvwxyz\");\r\n        for (long i = 0; i < 256; i++) {\r\n            img.setColor(i);\r\n            img.dot(10 + 14 * (int) (i / 16), 200 + 14 * (int) (i % 16), 6, true);\r\n        }\r\n        img.setColor(\"008000\");\r\n        img.dot(10 + 14 * 8, 200 + 14 * 8, 90, true);\r\n        \r\n        return img.toImage(true);\r\n        \r\n    }","id":51123,"modified_method":"public static BufferedImage respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        /*\r\n        BufferedImage bi = new BufferedImage(640, 400, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, 640, 400);\r\n        \r\n        g.setColor(new Color(200, 200, 0));\r\n        g.drawRect(100, 50, 40, 30);\r\n        \r\n        g.setColor(new Color(0, 0, 200));\r\n        try {\r\n            Class[] pType    = {Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE};\r\n            Object[] pParam = new Integer[]{new Integer(66), new Integer(55), new Integer(80), new Integer(80)};\r\n            \r\n            String com = \"drawRect\";\r\n            Method m = g.getClass().getMethod(com, pType);\r\n            Object result = m.invoke(g, pParam);\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        WritableRaster r = bi.getRaster();\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 30, new int[]{255, 0, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 32, new int[]{0, 255, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 34, new int[]{0, 0, 255});\r\n        return bi;\r\n        */\r\n        ImagePainter img = new ImagePainter(800, 600, ImagePainter.TRANSPARENT);\r\n        \r\n        img.setMode(ImagePainter.MODE_ADD);\r\n        img.setColor(ImagePainter.ADDITIVE_BLACK);\r\n        for (int y = 0; y < 600; y = y + 50) img.print(0, 6 + y, \"\" + y);\r\n        for (int x = 0; x < 800; x = x + 50) img.print(x, 6    , \"\" + x);\r\n        img.setColor(ImagePainter.ADDITIVE_RED);\r\n        img.dot(550, 110, 90, true);\r\n        img.setColor(ImagePainter.ADDITIVE_GREEN);\r\n        img.dot(480, 200, 90, true);\r\n        img.setColor(ImagePainter.ADDITIVE_BLUE);\r\n        img.dot(620, 200, 90, true);\r\n        img.setColor(ImagePainter.ADDITIVE_RED);\r\n        img.arc(300, 270, 30, 70, 0, 360);\r\n        img.setColor(\"330000\");\r\n        img.arc(220, 110, 50, 90, 30, 110);\r\n        img.arc(210, 120, 50, 90, 30, 110);\r\n        img.setColor(ImagePainter.ADDITIVE_BLACK);\r\n        img.print(50, 110, \"BROADCAST MESSAGE #772: NODE %882 BLACK abcefghijklmnopqrstuvwxyz\");\r\n        img.setColor(ImagePainter.ADDITIVE_GREEN);\r\n        img.print(50, 120, \"BROADCAST MESSAGE #772: NODE %882 GREEN abcefghijklmnopqrstuvwxyz\");\r\n        for (long i = 0; i < 256; i++) {\r\n            img.setColor(i);\r\n            img.dot(10 + 14 * (int) (i / 16), 200 + 14 * (int) (i % 16), 6, true);\r\n        }\r\n        img.setColor(\"008000\");\r\n        img.dot(10 + 14 * 8, 200 + 14 * 8, 90, true);\r\n        /*\r\n        for (long r = 0; r < 256; r = r + 16) {\r\n            for (long g = 0; g < 256; g = g + 16) {\r\n                for (long b = 0; b < 256; b = b + 16) {\r\n                    img.setColor(r << 16 + g << 8 + b);\r\n                    img.dot((int) (10 + 48 * g + 12 * ((r / 16) / 12)), (int) (420 + 48 * b + 12 * ((r / 16) % 12)), 4, true);\r\n                }\r\n            }\r\n        }*/\r\n        img.setColor(\"0000A0\");\r\n        img.arc(550, 400, 40, 81, 0, 360);\r\n        img.setColor(\"010100\");\r\n        for (int i = 0; i <= 360; i++) {\r\n            img.arc(550, 400, 40, 41 + i/9, 0, i);\r\n        }\r\n        img.setColor(ImagePainter.ADDITIVE_BLACK);\r\n        int angle;\r\n        for (byte c = (byte) 'A'; c <= 'Z'; c++) {\r\n            angle = ((byte) c - (byte) 'A') * 360 / ((byte) 'Z' - (byte) 'A');\r\n            img.arcLine(550, 400, 81, 100, angle);\r\n            img.arcPrint(550, 400, 100, angle, \"ANGLE\" + angle + \":\" + (char) c);\r\n        }\r\n        return img.toImage(true);\r\n        \r\n    }","commit_id":"d98ed41f311496d7473390efcb5f21d2b5d4d9d1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void dot(int x, int y, int radius, boolean filled, long color, byte mode) {\r\n        setColor(color);\r\n        setMode(mode);\r\n        if (filled) {\r\n            for (int i = radius; i >= 0; i--) circle(x, y, i);\r\n        } else {\r\n            circle(x, y, radius);\r\n        }\r\n    }","id":51124,"modified_method":"public void dot(int x, int y, int radius, boolean filled, long color, byte mode) {\r\n        setColor(color);\r\n        setMode(mode);\r\n        if (filled) {\r\n            for (int r = radius; r >= 0; r--) circle(x, y, r);\r\n        } else {\r\n            circle(x, y, radius);\r\n        }\r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public BufferedImage toImage() {\r\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, width, height);\r\n\r\n        WritableRaster r = bi.getRaster();\r\n        long c;\r\n        for (int i = width - 1; i >= 0; i--) {\r\n            for (int j = height - 1; j >= 0; j--) {\r\n                c = grid[i + j * width];\r\n                if (c >= 0) r.setPixel(i, j, new int[]{(int) (c >> 16), (int) ((c >> 8) & 0xff), (int) (c & 0xff)});\r\n            }\r\n        }\r\n        \r\n        return bi;\r\n    }","id":51125,"modified_method":"public BufferedImage toImage(boolean complementary) {\r\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, width, height);\r\n\r\n        WritableRaster r = bi.getRaster();\r\n        long c;\r\n        for (int i = width - 1; i >= 0; i--) {\r\n            for (int j = height - 1; j >= 0; j--) {\r\n                c = grid[i + j * width];\r\n                if (c >= 0) {\r\n                    if (complementary) {\r\n                        r.setPixel(i, j, new int[]{0xff - (int) ((((c >> 8) & 0xff) + (c & 0xff)) / 2), 0xff - (int) (((c >> 16) + (c & 0xff)) / 2) , 0xff - (int) ((((c >> 8) & 0xff) + (c >> 16)) / 2)});\r\n                    } else {\r\n                        r.setPixel(i, j, new int[]{(int) (c >> 16), (int) ((c >> 8) & 0xff), (int) (c & 0xff)});\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return bi;\r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void circle(int xc, int yc, int radius) {\r\n        int xn, yn;\r\n        for (int i = 359; i >= 0; i--) {\r\n            xn = xc + (int) (radius * Math.cos(Math.PI * 2 * i / 360));\r\n            yn = yc + (int) (radius * Math.sin(Math.PI * 2 * i / 360));\r\n            plot(xn, yn);\r\n        }\r\n    }","id":51126,"modified_method":"private void circle(int xc, int yc, int radius) {\r\n        if (radius == 0) {\r\n            plot(xc, yc);\r\n        } else {\r\n            int[][] c = circles[radius - 1];\r\n            int x, y;\r\n            for (int i = c.length - 1; i >= 0; i--) {\r\n                x = c[i][0];\r\n                y = c[i][1];\r\n                plot(xc + x, yc + y);\r\n                plot(xc - x + 1, yc + y);\r\n                plot(xc + x, yc - y + 1);\r\n                plot(xc - x + 1, yc - y + 1);\r\n            }\r\n        }\r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void plot(int x, int y) {\r\n        if ((x < 0) || (x >= width)) return;\r\n        if ((y < 0) || (y >= height)) return;\r\n        if (defaultMode == MODE_REPLACE) {\r\n            grid[x + y * width] = defaultCol;\r\n        } else if (defaultMode == MODE_MIX) {\r\n            int n = x + y * width;\r\n            long c = grid[n];\r\n            int r = ((int) ((c >> 16) + (defaultCol >> 16))) & 0xff;\r\n            int g = ((int) (((c >> 8) & 0xff) + ((defaultCol >> 8) & 0xff))) & 0xff;\r\n            int b = ((int) ((c & 0xff) + (defaultCol & 0xff))) & 0xff;\r\n            grid[n] = r << 16 | g << 8 | b;\r\n        }\r\n    }","id":51127,"modified_method":"private void plot(int x, int y) {\r\n        if ((x < 0) || (x >= width)) return;\r\n        if ((y < 0) || (y >= height)) return;\r\n        if (defaultMode == MODE_REPLACE) {\r\n            grid[x + y * width] = defaultCol;\r\n        } else if (defaultMode == MODE_MIX) {\r\n            int n = x + y * width;\r\n            long c = grid[n];\r\n            if (c < 0) {\r\n                grid[n] = defaultCol;\r\n            } else {\r\n                int r = ((int) ((c >> 16) + (defaultCol >> 16))) & 0xff;\r\n                int g = ((int) (((c >> 8) & 0xff) + ((defaultCol >> 8) & 0xff))) & 0xff;\r\n                int b = ((int) ((c & 0xff) + (defaultCol & 0xff))) & 0xff;\r\n                grid[n] = r << 16 | g << 8 | b;\r\n            }\r\n        }\r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static BufferedImage respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        /*\r\n        BufferedImage bi = new BufferedImage(640, 400, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, 640, 400);\r\n        \r\n        g.setColor(new Color(200, 200, 0));\r\n        g.drawRect(100, 50, 40, 30);\r\n        \r\n        g.setColor(new Color(0, 0, 200));\r\n        try {\r\n            Class[] pType    = {Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE};\r\n            Object[] pParam = new Integer[]{new Integer(66), new Integer(55), new Integer(80), new Integer(80)};\r\n            \r\n            String com = \"drawRect\";\r\n            Method m = g.getClass().getMethod(com, pType);\r\n            Object result = m.invoke(g, pParam);\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        WritableRaster r = bi.getRaster();\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 30, new int[]{255, 0, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 32, new int[]{0, 255, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 34, new int[]{0, 0, 255});\r\n        return bi;\r\n        */\r\n        ImagePainter img = new ImagePainter(300, 200, ImagePainter.TRANSPARENT);\r\n        img.dot(150, 100, 50, true, ImagePainter.BLUE, ImagePainter.MODE_REPLACE);\r\n        img.dot(170, 130, 40, true, ImagePainter.GREEN, ImagePainter.MODE_REPLACE);\r\n        return img.toImage();\r\n        \r\n    }","id":51128,"modified_method":"public static BufferedImage respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        /*\r\n        BufferedImage bi = new BufferedImage(640, 400, BufferedImage.TYPE_INT_RGB); \r\n        Graphics2D g = bi.createGraphics();\r\n        g.setBackground(Color.white);\r\n        g.clearRect(0, 0, 640, 400);\r\n        \r\n        g.setColor(new Color(200, 200, 0));\r\n        g.drawRect(100, 50, 40, 30);\r\n        \r\n        g.setColor(new Color(0, 0, 200));\r\n        try {\r\n            Class[] pType    = {Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE};\r\n            Object[] pParam = new Integer[]{new Integer(66), new Integer(55), new Integer(80), new Integer(80)};\r\n            \r\n            String com = \"drawRect\";\r\n            Method m = g.getClass().getMethod(com, pType);\r\n            Object result = m.invoke(g, pParam);\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        WritableRaster r = bi.getRaster();\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 30, new int[]{255, 0, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 32, new int[]{0, 255, 0});\r\n        for (int i = 20; i < 100; i++) r.setPixel(i, 34, new int[]{0, 0, 255});\r\n        return bi;\r\n        */\r\n        ImagePainter img = new ImagePainter(300, 200, ImagePainter.TRANSPARENT);\r\n        img.dot(150, 100, 90, true, ImagePainter.BLUE, ImagePainter.MODE_MIX);\r\n        img.dot(190, 130, 60, true, ImagePainter.GREEN, ImagePainter.MODE_MIX);\r\n        img.arc(220, 90, 50, 90, 30, 110, ImagePainter.RED / 2, ImagePainter.MODE_MIX);\r\n        img.arc(210, 77, 50, 90, 30, 110, ImagePainter.RED / 2, ImagePainter.MODE_MIX);\r\n        img.print(50, 100, \"BROADCAST MESSAGE #772: NODE %882 BLACK\", ImagePainter.WHITE, ImagePainter.MODE_MIX);\r\n        img.print(50, 120, \"BROADCAST MESSAGE #772: NODE %882 GREEN\", ImagePainter.GREEN, ImagePainter.MODE_REPLACE);\r\n        return img.toImage(true);\r\n        \r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaWordIndexEntry(String urlHash, int count, int posintext, int posinphrase, int posofphraseint, int virtualage, int quality, String language, char doctype, boolean local) {\r\n\r\n\t// ** hier fehlt noch als Attribut: <Wortposition im Text>, damit 'nearby' getrackt werden kann **\r\n\r\n\tif ((language == null) || (language.length() != plasmaCrawlLURL.urlLanguageLength)) language = \"uk\";\r\n\tthis.urlHash = urlHash;\r\n\tthis.count = count;\r\n        this.posintext = posintext;\r\n        this.posinphrase = posinphrase;\r\n        this.posofphrase = posofphrase;\r\n\tthis.age = virtualage;\r\n\tthis.quality = quality;\r\n\tthis.language = language.getBytes();\r\n\tthis.doctype = doctype;\r\n\tthis.localflag = (local) ? LT_LOCAL : LT_GLOBAL;\r\n    }","id":51129,"modified_method":"public plasmaWordIndexEntry(String urlHash, int count, int posintext, int posinphrase, int posofphrase, int virtualage, int quality, String language, char doctype, boolean local) {\r\n\r\n\t// ** hier fehlt noch als Attribut: <Wortposition im Text>, damit 'nearby' getrackt werden kann **\r\n\r\n\tif ((language == null) || (language.length() != plasmaCrawlLURL.urlLanguageLength)) language = \"uk\";\r\n\tthis.urlHash = urlHash;\r\n\tthis.count = count;\r\n        this.posintext = posintext;\r\n        this.posinphrase = posinphrase;\r\n        this.posofphrase = posofphrase;\r\n\tthis.age = virtualage;\r\n\tthis.quality = quality;\r\n\tthis.language = language.getBytes();\r\n\tthis.doctype = doctype;\r\n\tthis.localflag = (local) ? LT_LOCAL : LT_GLOBAL;\r\n    }","commit_id":"1a5d98cd6d0c9c7666900cd75488a05f6eff2899","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void create(final String code){\n\n        final Random random = new Random();\n\n        final int width = this.getWidth();\n        final int height = this.getHeight();\n        final int chars = code.length();\n\n        int x;\n        int y;\n        int ub = 0;\n        final int widthPerChar = width/chars;\n        final int pixels = width * height;\n\n\n        //printing code\n        for(int i=0;i<chars;i++){\n            y = random.nextInt(height/2) + (height/4);\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            PrintTool.print(this, widthPerChar*i+random.nextInt(widthPerChar/2) , y , 0, code.substring(i,i+1), -1);\n        }\n\n        //adding some noise\n\n        //random pixels\n        ub = pixels/100;\n        for(int i=0;i<ub;i++){\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            x = random.nextInt(width);\n            y = random.nextInt(height);\n            plot(x, y, 100);\n        }\n\n        //random lines\n        ub = pixels/1000;\n        for(int i=0;i<ub;i++){\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            x = random.nextInt(width);\n            y = random.nextInt(height);\n            line(x, y, x + random.nextInt(5), y + random.nextInt(5));\n        }\n\n    }","id":51130,"modified_method":"private void create(final String code){\n\n        final Random random = new Random();\n\n        final int width = this.getWidth();\n        final int height = this.getHeight();\n        final int chars = code.length();\n\n        int x;\n        int y;\n        int ub = 0;\n        final int widthPerChar = width/chars;\n        final int pixels = width * height;\n\n\n        //printing code\n        for(int i=0;i<chars;i++){\n            y = random.nextInt(height/2) + (height/4);\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            PrintTool.print(this, widthPerChar*i+random.nextInt(widthPerChar/2) , y , 0, code.substring(i,i+1), -1);\n        }\n\n        //adding some noise\n\n        //random pixels\n        ub = pixels/100;\n        for(int i=0;i<ub;i++){\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            x = random.nextInt(width);\n            y = random.nextInt(height);\n            plot(x, y, 100);\n        }\n\n        //random lines\n        ub = pixels/1000;\n        for(int i=0;i<ub;i++){\n            setColor(((random.nextInt(128)+64)<<16) + ((random.nextInt(128)+64)<<8) + random.nextInt(128)+64);\n            x = random.nextInt(width);\n            y = random.nextInt(height);\n            line(x, y, x + random.nextInt(5), y + random.nextInt(5), 100);\n        }\n\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void drawVerticalScale(final boolean left, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int x = (left) ? leftborder : width - rightborder;\n        int y = height - bottomborder;\n        int s = offset;\n        String s1;\n        int s1max = 0;\n        while (y > topborder) {\n            if ((colorScale != null) && (y > topborder) && (y < (height - bottomborder))) {\n                setColor(colorScale);\n                line(leftborder, y, width - rightborder, y);\n            }\n            setColor(colorNaming);\n            line(x - 3, y, x + 3, y);\n            s1 = (s >= 1000000 && s % 10000 == 0) ? Integer.toString(s / 1000000) + \"M\" : (s >= 1000 && s % 1000 == 0) ? Integer.toString(s / 1000) + \"K\" : Integer.toString(s);\n            if (s1.length() > s1max) s1max = s1.length();\n            PrintTool.print(this, (left) ? leftborder - 4 : width - rightborder + 4, y, 0, s1, (left) ? 1 : -1);\n            y -= pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, (left) ? x - s1max * 6 - 6 : x + s1max * 6 + 9, topborder, 90, name, 1);\n        line(x, topborder - 4, x, height - bottomborder + 4);\n    }","id":51131,"modified_method":"private void drawVerticalScale(final boolean left, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int x = (left) ? leftborder : width - rightborder;\n        int y = height - bottomborder;\n        int s = offset;\n        String s1;\n        int s1max = 0;\n        while (y > topborder) {\n            if ((colorScale != null) && (y > topborder) && (y < (height - bottomborder))) {\n                setColor(colorScale);\n                line(leftborder, y, width - rightborder, y, 100);\n            }\n            setColor(colorNaming);\n            line(x - 3, y, x + 3, y, 100);\n            s1 = (s >= 1000000 && s % 10000 == 0) ? Integer.toString(s / 1000000) + \"M\" : (s >= 1000 && s % 1000 == 0) ? Integer.toString(s / 1000) + \"K\" : Integer.toString(s);\n            if (s1.length() > s1max) s1max = s1.length();\n            PrintTool.print(this, (left) ? leftborder - 4 : width - rightborder + 4, y, 0, s1, (left) ? 1 : -1);\n            y -= pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, (left) ? x - s1max * 6 - 6 : x + s1max * 6 + 9, topborder, 90, name, 1);\n        line(x, topborder - 4, x, height - bottomborder + 4, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void chartLine(final int dimension_x, final int dimension_y, final int coord_x1, final int coord_y1, final int coord_x2, final int coord_y2) {\n        final int x1 = (coord_x1 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y1 = (coord_y1 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        final int x2 = (coord_x2 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y2 = (coord_y2 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        line(leftborder + x1, height - bottomborder - y1, leftborder + x2, height - bottomborder - y2);\n    }","id":51132,"modified_method":"public void chartLine(final int dimension_x, final int dimension_y, final int coord_x1, final int coord_y1, final int coord_x2, final int coord_y2) {\n        final int x1 = (coord_x1 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y1 = (coord_y1 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        final int x2 = (coord_x2 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y2 = (coord_y2 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        line(leftborder + x1, height - bottomborder - y1, leftborder + x2, height - bottomborder - y2, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void drawHorizontalScale(final boolean top, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int y = (top) ? topborder : height - bottomborder;\n        int x = leftborder;\n        int s = offset;\n        while (x < width - rightborder) {\n            if ((colorScale != null) && (x > leftborder) && (x < (width - rightborder))) {\n                setColor(colorScale);\n                line(x, topborder, x, height - bottomborder);\n            }\n            setColor(colorNaming);\n            line(x, y - 3, x, y + 3);\n            PrintTool.print(this, x, (top) ? y - 3 : y + 9, 0, Integer.toString(s), -1);\n            x += pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, width - rightborder, (top) ? y - 9 : y + 15, 0, name, 1);\n        line(leftborder - 4, y, width - rightborder + 4, y);\n    }","id":51133,"modified_method":"private void drawHorizontalScale(final boolean top, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int y = (top) ? topborder : height - bottomborder;\n        int x = leftborder;\n        int s = offset;\n        while (x < width - rightborder) {\n            if ((colorScale != null) && (x > leftborder) && (x < (width - rightborder))) {\n                setColor(colorScale);\n                line(x, topborder, x, height - bottomborder, 100);\n            }\n            setColor(colorNaming);\n            line(x, y - 3, x, y + 3, 100);\n            PrintTool.print(this, x, (top) ? y - 3 : y + 9, 0, Integer.toString(s), -1);\n            x += pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, width - rightborder, (top) ? y - 9 : y + 15, 0, name, 1);\n        line(leftborder - 4, y, width - rightborder + 4, y, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static EncodedImage respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final boolean authorized = sb.adminAuthenticated(header) >= 2;\r\n        \r\n        long timeSeconds = System.currentTimeMillis() / 1000;\r\n        if (buffer != null && timeSeconds - lastAccessSeconds < 2) {\r\n            //System.out.println(\"*** NetworkPicture: cache hit (1)\");\r\n            return buffer;\r\n        }\r\n        synchronized (sync) {\r\n            if (buffer != null && timeSeconds - lastAccessSeconds < 2)  {\r\n                //System.out.println(\"*** NetworkPicture: cache hit (2)\");\r\n                return buffer;\r\n            }\r\n            int width = 768;\r\n            int height = 576;\r\n            int passiveLimit = 720; // 12 hours\r\n            int potentialLimit = 720;\r\n            int maxCount = 1000;\r\n            String bgcolor = NetworkGraph.COL_BACKGROUND;\r\n            boolean corona = true;\r\n            int coronaangle = 0;\r\n            long communicationTimeout = -1;\r\n            \r\n            if (post != null) {\r\n                width = post.getInt(\"width\", 768);\r\n                height = post.getInt(\"height\", 576);\r\n                passiveLimit = post.getInt(\"pal\", 1440);\r\n                potentialLimit = post.getInt(\"pol\", 1440);\r\n                maxCount = post.getInt(\"max\", 1000);\r\n                corona = post.get(\"corona\", \"true\").equals(\"true\");\r\n                coronaangle = (corona) ? post.getInt(\"coronaangle\", 0) : -1;\r\n                communicationTimeout = post.getLong(\"ct\", -1);\r\n                bgcolor = post.get(\"bgcolor\", bgcolor);\r\n            }\r\n            \r\n            //too small values lead to an error, too big to huge CPU/memory consumption, resulting in possible DOS.\r\n            if (width < 320 ) width = 320;\r\n            if (width > 1920) width = 1920;\r\n            if (height < 240) height = 240;\r\n            if (height > 1920) height = 1920;\r\n            if (!authorized) {\r\n                width = Math.min(768, width);\r\n                height = Math.min(576, height);\r\n            }\r\n            if (passiveLimit > 1000000) passiveLimit = 1000000;\r\n            if (potentialLimit > 1000000) potentialLimit = 1000000;\r\n            if (maxCount > 10000) maxCount = 10000;\r\n            buffer = new EncodedImage(NetworkGraph.getNetworkPicture(sb.peers, 10000, width, height, passiveLimit, potentialLimit, maxCount, coronaangle, communicationTimeout, env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\"), env.getConfig(\"network.unit.description\", \"unspecified\"), bgcolor).getImage(), \"png\");\r\n            lastAccessSeconds = System.currentTimeMillis() / 1000;\r\n        }\r\n        return buffer;\r\n    }","id":51134,"modified_method":"public static EncodedImage respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final boolean authorized = sb.adminAuthenticated(header) >= 2;\r\n        \r\n        long timeSeconds = System.currentTimeMillis() / 1000;\r\n        if (buffer != null && !authorized && timeSeconds - lastAccessSeconds < 2) {\r\n            //System.out.println(\"*** NetworkPicture: cache hit (1)\");\r\n            return buffer;\r\n        }\r\n        synchronized (sync) {\r\n            if (buffer != null && !authorized  && timeSeconds - lastAccessSeconds < 2)  {\r\n                //System.out.println(\"*** NetworkPicture: cache hit (2)\");\r\n                return buffer;\r\n            }\r\n            int width = 768;\r\n            int height = 576;\r\n            int passiveLimit = 720; // 12 hours\r\n            int potentialLimit = 720;\r\n            int maxCount = 1000;\r\n            String bgcolor = NetworkGraph.COL_BACKGROUND;\r\n            boolean corona = true;\r\n            int coronaangle = 0;\r\n            long communicationTimeout = -1;\r\n            \r\n            if (post != null) {\r\n                width = post.getInt(\"width\", 768);\r\n                height = post.getInt(\"height\", 576);\r\n                passiveLimit = post.getInt(\"pal\", 1440);\r\n                potentialLimit = post.getInt(\"pol\", 1440);\r\n                maxCount = post.getInt(\"max\", 1000);\r\n                corona = post.get(\"corona\", \"true\").equals(\"true\");\r\n                coronaangle = (corona) ? post.getInt(\"coronaangle\", 0) : -1;\r\n                communicationTimeout = post.getLong(\"ct\", -1);\r\n                bgcolor = post.get(\"bgcolor\", bgcolor);\r\n            }\r\n            \r\n            //too small values lead to an error, too big to huge CPU/memory consumption, resulting in possible DOS.\r\n            if (width < 320 ) width = 320;\r\n            if (width > 1920) width = 1920;\r\n            if (height < 240) height = 240;\r\n            if (height > 1920) height = 1920;\r\n            if (!authorized) {\r\n                width = Math.min(768, width);\r\n                height = Math.min(576, height);\r\n            }\r\n            if (passiveLimit > 1000000) passiveLimit = 1000000;\r\n            if (potentialLimit > 1000000) potentialLimit = 1000000;\r\n            if (maxCount > 10000) maxCount = 10000;\r\n            buffer = new EncodedImage(NetworkGraph.getNetworkPicture(sb.peers, 10000, width, height, passiveLimit, potentialLimit, maxCount, coronaangle, communicationTimeout, env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\"), env.getConfig(\"network.unit.description\", \"unspecified\"), bgcolor).getImage(), \"png\");\r\n            lastAccessSeconds = System.currentTimeMillis() / 1000;\r\n        }\r\n        return buffer;\r\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void plot(final int x, final int y, final int intensity) {\n        if ((x < 0) || (x >= width)) return;\n        if ((y < 0) || (y >= height)) return;\n        synchronized (cc) {\n        \tif (this.defaultMode == MODE_REPLACE) {\n        \t\tif (intensity == 100) {\n        \t\t\tcc[0] = defaultColR;\n            \t\tcc[1] = defaultColG;\n            \t\tcc[2] = defaultColB;\n        \t\t} else {\n        \t\t\tint[] c = new int[3];\n            \t\tc = grid.getPixel(x, y, c);\n        \t\t\tcc[0] = (intensity * defaultColR + (100 - intensity) * c[0]) / 100;\n        \t\t\tcc[1] = (intensity * defaultColG + (100 - intensity) * c[1]) / 100;\n        \t\t\tcc[2] = (intensity * defaultColB + (100 - intensity) * c[2]) / 100;\n        \t\t}\n        \t} else if (this.defaultMode == MODE_ADD) {\n        \t\tint[] c = new int[3];\n        \t\tc = grid.getPixel(x, y, c);\n        \t\tif (intensity == 100) {\n        \t\t\tcc[0] = (0xff & c[0]) + defaultColR; if (cc[0] > 255) cc[0] = 255;\n        \t\t\tcc[1] = (0xff & c[1]) + defaultColG; if (cc[1] > 255) cc[1] = 255;\n        \t\t\tcc[2] = (0xff & c[2]) + defaultColB; if (cc[2] > 255) cc[2] = 255;\n        \t\t} else {\n        \t\t\tcc[0] = (0xff & c[0]) + (intensity * defaultColR / 100); if (cc[0] > 255) cc[0] = 255;\n        \t\t\tcc[1] = (0xff & c[1]) + (intensity * defaultColG / 100); if (cc[1] > 255) cc[1] = 255;\n        \t\t\tcc[2] = (0xff & c[2]) + (intensity * defaultColB / 100); if (cc[2] > 255) cc[2] = 255;\n        \t\t}\n        \t} else if (this.defaultMode == MODE_SUB) {\n        \t\tint[] c = new int[3];\n        \t\tc = grid.getPixel(x, y, c);\n        \t\tif (intensity == 100) {\n        \t\t\tcc[0] = (0xff & c[0]) - defaultColR; if (cc[0] < 0) cc[0] = 0;\n        \t\t\tcc[1] = (0xff & c[1]) - defaultColG; if (cc[1] < 0) cc[1] = 0;\n        \t\t\tcc[2] = (0xff & c[2]) - defaultColB; if (cc[2] < 0) cc[2] = 0;\n        \t\t} else {\n        \t\t\tcc[0] = (0xff & c[0]) - (intensity * defaultColR / 100); if (cc[0] < 0) cc[0] = 0;\n        \t\t\tcc[1] = (0xff & c[1]) - (intensity * defaultColG / 100); if (cc[1] < 0) cc[1] = 0;\n        \t\t\tcc[2] = (0xff & c[2]) - (intensity * defaultColB / 100); if (cc[2] < 0) cc[2] = 0;\n        \t\t}\n        \t}\n        \tgrid.setPixel(x, y, cc);\n        }\n    }","id":51135,"modified_method":"public void plot(final int x, final int y, final int intensity) {\n        if ((x < 0) || (x >= width)) return;\n        if ((y < 0) || (y >= height)) return;\n        synchronized (cc) {\n        \tif (this.defaultMode == MODE_REPLACE) {\n        \t\tif (intensity == 100) {\n        \t\t\tcc[0] = defaultColR;\n            \t\tcc[1] = defaultColG;\n            \t\tcc[2] = defaultColB;\n                    grid.setPixel(x, y, cc);\n        \t\t} else {\n        \t\t\tint[] c = grid.getPixel(x, y, cc);\n        \t\t\tc[0] = (intensity * defaultColR + (100 - intensity) * c[0]) / 100;\n        \t\t\tc[1] = (intensity * defaultColG + (100 - intensity) * c[1]) / 100;\n        \t\t\tc[2] = (intensity * defaultColB + (100 - intensity) * c[2]) / 100;\n                    grid.setPixel(x, y, c);\n        \t\t}\n        \t} else if (this.defaultMode == MODE_ADD) {\n        \t\tint[] c = grid.getPixel(x, y, cc);\n        \t\tif (intensity == 100) {\n        \t\t\tc[0] = (0xff & c[0]) + defaultColR; if (cc[0] > 255) cc[0] = 255;\n        \t\t\tc[1] = (0xff & c[1]) + defaultColG; if (cc[1] > 255) cc[1] = 255;\n        \t\t\tc[2] = (0xff & c[2]) + defaultColB; if (cc[2] > 255) cc[2] = 255;\n        \t\t} else {\n        \t\t\tc[0] = (0xff & c[0]) + (intensity * defaultColR / 100); if (cc[0] > 255) cc[0] = 255;\n        \t\t\tc[1] = (0xff & c[1]) + (intensity * defaultColG / 100); if (cc[1] > 255) cc[1] = 255;\n        \t\t\tc[2] = (0xff & c[2]) + (intensity * defaultColB / 100); if (cc[2] > 255) cc[2] = 255;\n        \t\t}\n                grid.setPixel(x, y, c);\n        \t} else if (this.defaultMode == MODE_SUB) {\n        \t\tint[] c = grid.getPixel(x, y, cc);\n        \t\tif (intensity == 100) {\n        \t\t\tc[0] = (0xff & c[0]) - defaultColR; if (cc[0] < 0) cc[0] = 0;\n        \t\t\tc[1] = (0xff & c[1]) - defaultColG; if (cc[1] < 0) cc[1] = 0;\n        \t\t\tc[2] = (0xff & c[2]) - defaultColB; if (cc[2] < 0) cc[2] = 0;\n        \t\t} else {\n        \t\t\tc[0] = (0xff & c[0]) - (intensity * defaultColR / 100); if (cc[0] < 0) cc[0] = 0;\n        \t\t\tc[1] = (0xff & c[1]) - (intensity * defaultColG / 100); if (cc[1] < 0) cc[1] = 0;\n        \t\t\tc[2] = (0xff & c[2]) - (intensity * defaultColB / 100); if (cc[2] < 0) cc[2] = 0;\n        \t\t}\n                grid.setPixel(x, y, c);\n        \t}\n        }\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void line(final int Ax, final int Ay, final int Bx, final int By) {\n        if (this.defaultMode == MODE_REPLACE) {\n            List<int[]> points = linex(Ax * 2, Ay * 2, Bx * 2, By * 2);\n            for (int[] point: points) plot(point[0] / 2, point[1] / 2, 100);\n        } else {\n            List<int[]> points = linex(Ax * 2, Ay * 2, Bx * 2, By * 2);\n            for (int[] point: points) plot(point[0] / 2, point[1] / 2, 50);\n        }\n    }","id":51136,"modified_method":"public void line(int Ax, int Ay, final int Bx, final int By, final int intensity) {\n        // Bresenham's line drawing algorithm\n        int dX = Math.abs(Bx-Ax);\n        int dY = Math.abs(By-Ay);\n        int Xincr, Yincr;\n        if (Ax > Bx) Xincr=-1; else Xincr=1;\n        if (Ay > By) Yincr=-1; else Yincr=1;\n        if (dX >= dY) {\n            final int dPr  = dY<<1;\n            final int dPru = dPr - (dX<<1);\n            int P    = dPr - dX;\n            for (; dX>=0; dX--) {\n                plot(Ax, Ay, intensity);\n                if (P > 0) {\n                    Ax+=Xincr;\n                    Ay+=Yincr;\n                    P+=dPru;\n                } else {\n                    Ax+=Xincr;\n                    P+=dPr;\n                }\n            }\n        } else {\n            final int dPr  = dX<<1;\n            final int dPru = dPr - (dY<<1);\n            int P    = dPr - dY;\n            for (; dY>=0; dY--) {\n                plot(Ax, Ay, intensity);\n                if (P > 0) {\n                    Ax+=Xincr;\n                    Ay+=Yincr;\n                    P+=dPru;\n                } else {\n                    Ay+=Yincr;\n                    P+=dPr;\n                }\n            }\n        }\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void arcLine(final int cx, final int cy, final int innerRadius, final int outerRadius, final int angle) {\n        double a = Math.PI * ((double) angle) / 180.0;\n        double cosa = Math.cos(a);\n        double sina = Math.sin(a);\n        final int xi = cx + (int) (innerRadius * cosa);\n        final int yi = cy - (int) (innerRadius * sina);\n        final int xo = cx + (int) (outerRadius * cosa);\n        final int yo = cy - (int) (outerRadius * sina);\n        line(xi, yi, xo, yo);\n    }","id":51137,"modified_method":"public void arcLine(final int cx, final int cy, final int innerRadius, final int outerRadius, final int angle) {\n        double a = Math.PI * ((double) angle) / 180.0;\n        double cosa = Math.cos(a);\n        double sina = Math.sin(a);\n        final int xi = cx + (int) (innerRadius * cosa);\n        final int yi = cy - (int) (innerRadius * sina);\n        final int xo = cx + (int) (outerRadius * cosa);\n        final int yo = cy - (int) (outerRadius * sina);\n        line(xi, yi, xo, yo, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void lineDot(final int x0, final int y0, final int x1, final int y1, final int radius, final int distance, final long lineColor, final long dotColor) {\n        // draw a line with a dot at the end.\n        // the radius value is the radius of the dot\n        // the distance value is the distance of the dot border to the endpoint\n        \n        // compute first the angle of the line between the points\n        final double angle = (x1 - x0 > 0) ? Math.atan(((double) (y0 - y1)) / ((double) (x1 - x0))) : Math.PI - Math.atan(((double) (y0 - y1)) / ((double) (x0 - x1)));\n        // now find two more points in between\n        // first calculate the radius' of the points\n        final double ra = Math.sqrt(((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1))); // from a known point x1, y1\n        final double rb = ra - radius - distance;\n        final double rc = rb - radius;\n        //System.out.println(\"CONTROL angle = \" + angle);\n        //System.out.println(\"CONTROL x1 = \" + x1 + \", x1calc = \" + ((x0 + ((int) ra * Math.cos(angle)))));\n        //System.out.println(\"CONTROL y1 = \" + y1 + \", y1calc = \" + ((y0 - ((int) ra * Math.sin(angle)))));\n        // the points are on a circle with radius rb and rc\n        final int x2 = x0 + ((int) (rb * Math.cos(angle)));\n        final int y2 = y0 - ((int) (rb * Math.sin(angle)));\n        final int x3 = x0 + ((int) (rc * Math.cos(angle)));\n        final int y3 = y0 - ((int) (rc * Math.sin(angle)));\n        setColor(lineColor);\n        line(x0, y0, x3, y3);\n        setColor(dotColor);\n        dot(x2, y2, radius, true);\n    }","id":51138,"modified_method":"public void lineDot(final int x0, final int y0, final int x1, final int y1, final int radius, final int distance, final long lineColor, final long dotColor) {\n        // draw a line with a dot at the end.\n        // the radius value is the radius of the dot\n        // the distance value is the distance of the dot border to the endpoint\n        \n        // compute first the angle of the line between the points\n        final double angle = (x1 - x0 > 0) ? Math.atan(((double) (y0 - y1)) / ((double) (x1 - x0))) : Math.PI - Math.atan(((double) (y0 - y1)) / ((double) (x0 - x1)));\n        // now find two more points in between\n        // first calculate the radius' of the points\n        final double ra = Math.sqrt(((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1))); // from a known point x1, y1\n        final double rb = ra - radius - distance;\n        final double rc = rb - radius;\n        //System.out.println(\"CONTROL angle = \" + angle);\n        //System.out.println(\"CONTROL x1 = \" + x1 + \", x1calc = \" + ((x0 + ((int) ra * Math.cos(angle)))));\n        //System.out.println(\"CONTROL y1 = \" + y1 + \", y1calc = \" + ((y0 - ((int) ra * Math.sin(angle)))));\n        // the points are on a circle with radius rb and rc\n        final int x2 = x0 + ((int) (rb * Math.cos(angle)));\n        final int y2 = y0 - ((int) (rb * Math.sin(angle)));\n        final int x3 = x0 + ((int) (rc * Math.cos(angle)));\n        final int y3 = y0 - ((int) (rc * Math.sin(angle)));\n        setColor(lineColor);\n        line(x0, y0, x3, y3, 100);\n        setColor(dotColor);\n        dot(x2, y2, radius, true);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void demoPaint(final RasterPlotter m) {\n        m.setColor(GREY);\n        m.line(0,  70, 100,  70); PrintTool.print(m, 0,  65, 0, \"Grey\", -1);\n        m.line(65, 0,   65, 300);\n        m.setColor(RED);\n        m.line(0,  90, 100,  90); PrintTool.print(m, 0,  85, 0, \"Red\", -1);\n        m.line(70, 0,   70, 300);\n        m.setColor(GREEN);\n        m.line(0, 110, 100, 110); PrintTool.print(m, 0, 105, 0, \"Green\", -1);\n        m.line(75, 0,   75, 300);\n        m.setColor(BLUE);\n        m.line(0, 130, 100, 130); PrintTool.print(m, 0, 125, 0, \"Blue\", -1);\n        m.line(80, 0,   80, 300);\n    }","id":51139,"modified_method":"public static void demoPaint(final RasterPlotter m) {\n        m.setColor(GREY);\n        m.line(0,  70, 100,  70, 100); PrintTool.print(m, 0,  65, 0, \"Grey\", -1);\n        m.line(65, 0,   65, 300, 100);\n        m.setColor(RED);\n        m.line(0,  90, 100,  90, 100); PrintTool.print(m, 0,  85, 0, \"Red\", -1);\n        m.line(70, 0,   70, 300, 100);\n        m.setColor(GREEN);\n        m.line(0, 110, 100, 110, 100); PrintTool.print(m, 0, 105, 0, \"Green\", -1);\n        m.line(75, 0,   75, 300, 100);\n        m.setColor(BLUE);\n        m.line(0, 130, 100, 130, 100); PrintTool.print(m, 0, 125, 0, \"Blue\", -1);\n        m.line(80, 0,   80, 300, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void arcConnect(final int cx, final int cy, final int arcRadius, final int angle1, final int angle2) {\n        double a1 = Math.PI * ((double) angle1) / 180.0;\n        double a2 = Math.PI * ((double) angle2) / 180.0;\n        final int x1 = cx + (int) (arcRadius * Math.cos(a1));\n        final int y1 = cy - (int) (arcRadius * Math.sin(a1));\n        final int x2 = cx + (int) (arcRadius * Math.cos(a2));\n        final int y2 = cy - (int) (arcRadius * Math.sin(a2));\n        line(x1, y1, x2, y2);\n    }","id":51140,"modified_method":"public void arcConnect(final int cx, final int cy, final int arcRadius, final int angle1, final int angle2) {\n        double a1 = Math.PI * ((double) angle1) / 180.0;\n        double a2 = Math.PI * ((double) angle2) / 180.0;\n        final int x1 = cx + (int) (arcRadius * Math.cos(a1));\n        final int y1 = cy - (int) (arcRadius * Math.sin(a1));\n        final int x2 = cx + (int) (arcRadius * Math.cos(a2));\n        final int y2 = cy - (int) (arcRadius * Math.sin(a2));\n        line(x1, y1, x2, y2, 100);\n    }","commit_id":"55a2536bcf0309faae20c9f4dee5c4b7b5f2dd05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public SNode getConceptDeclarationNode() {\n    return (SNode) SModelUtil.findConceptDeclaration(getConcept().getQualifiedName());\n  }","id":51141,"modified_method":"public org.jetbrains.mps.openapi.model.SNode getConceptDeclarationNode() {\n    return getConcept().getDeclarationNode();\n  }","commit_id":"f5d2d3484196ab7307fd7e2ddfb15a3c28d708dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode getConceptDeclaration(SNode node) {\n    return (node == null ? null : SModelUtil.findConceptDeclaration(node.getConcept().getQualifiedName()));\n  }","id":51142,"modified_method":"public static SNode getConceptDeclaration(SNode node) {\n    return (node == null ? null : node.getConcept().getDeclarationNode());\n  }","commit_id":"49eedcb191886431a71827d7459cf9bdb21b5f41","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new ReferenceableConceptsChecker()));\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getNodeDescendants(n, null, true, new SAbstractConcept[]{})) {\n                  SNode ccp = SNodeOperations.as(((SNode) ((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode()), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","id":51143,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new ReferenceableConceptsChecker()));\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getNodeDescendants(n, null, true, new SAbstractConcept[]{})) {\n                  SNode ccp = SNodeOperations.as(((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode(), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","commit_id":"5926c08e0f5472ff0cbe6979741c7c3c20f09fcb","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkNode(List<SearchResult<ModelCheckerIssue>> results, SNode node, SNode refNode, boolean isAncestor, SNode anchor) {\n    SNode conceptDecl = SModelUtil.findConceptDeclaration(node.getConcept().getQualifiedName());\n    if (conceptDecl == null) {\n      SpecificChecker.addIssue(results, node, \"No concept found for \" + node.toString(), ModelChecker.SEVERITY_ERROR, \"no concept\", null);\n    }\n    if (SNodeOperations.isInstanceOf(conceptDecl, MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n      SNode decl = SNodeOperations.cast(conceptDecl, MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n\n      if (isAncestor) {\n        if (SNodeOperations.isInstanceOf(decl, MetaAdapterFactory.getInterfaceConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3361475375157466558l, \"jetbrains.mps.lang.core.structure.ScopeFacade\")) && !(ListSequence.fromList(SNodeOperations.getNodeAncestors(refNode, null, true)).contains(node))) {\n          SpecificChecker.addIssue(results, anchor, \"Reference from outside to a node under ScopeFacade: facade=\" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a non-referenceable node\", null);\n        }\n      } else {\n\n        if (SPropertyOperations.hasValue(decl, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null)) {\n          SpecificChecker.addIssue(results, anchor, \"Reference to a non-referenceable node found: \" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a non-referenceable node\", null);\n        } else if (SPropertyOperations.hasValue(decl, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null) && !((SNodeOperations.getContainingRoot(node) == SNodeOperations.getContainingRoot(refNode)))) {\n          SpecificChecker.addIssue(results, anchor, \"Cross-root reference to a locally referenceable node found: \" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a locally referenceable node\", null);\n        }\n      }\n    } else {\n      SpecificChecker.addIssue(results, node, \"Interface instance found! \" + node.toString(), ModelChecker.SEVERITY_ERROR, \"no concept\", null);\n    }\n  }","id":51144,"modified_method":"private void checkNode(List<SearchResult<ModelCheckerIssue>> results, SNode node, SNode refNode, boolean isAncestor, SNode anchor) {\n    SNode conceptDecl = SNodeOperations.as(node.getConcept().getDeclarationNode(), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1169125787135l, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n    if (conceptDecl == null) {\n      SpecificChecker.addIssue(results, node, \"No concept found for \" + node.toString(), ModelChecker.SEVERITY_ERROR, \"no concept\", null);\n    }\n    if (SNodeOperations.isInstanceOf(conceptDecl, MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n      SNode decl = SNodeOperations.cast(conceptDecl, MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n\n      if (isAncestor) {\n        if (SNodeOperations.isInstanceOf(decl, MetaAdapterFactory.getInterfaceConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3361475375157466558l, \"jetbrains.mps.lang.core.structure.ScopeFacade\")) && !(ListSequence.fromList(SNodeOperations.getNodeAncestors(refNode, null, true)).contains(node))) {\n          SpecificChecker.addIssue(results, anchor, \"Reference from outside to a node under ScopeFacade: facade=\" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a non-referenceable node\", null);\n        }\n      } else {\n\n        if (SPropertyOperations.hasValue(decl, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null)) {\n          SpecificChecker.addIssue(results, anchor, \"Reference to a non-referenceable node found: \" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a non-referenceable node\", null);\n        } else if (SPropertyOperations.hasValue(decl, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null) && !((SNodeOperations.getContainingRoot(node) == SNodeOperations.getContainingRoot(refNode)))) {\n          SpecificChecker.addIssue(results, anchor, \"Cross-root reference to a locally referenceable node found: \" + SPropertyOperations.getString(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\")), ModelChecker.SEVERITY_ERROR, \"reference to a locally referenceable node\", null);\n        }\n      }\n    } else {\n      SpecificChecker.addIssue(results, node, \"Interface instance found! \" + node.toString(), ModelChecker.SEVERITY_ERROR, \"no concept\", null);\n    }\n  }","commit_id":"5926c08e0f5472ff0cbe6979741c7c3c20f09fcb","url":"https://github.com/JetBrains/MPS"},{"original_method":"synchronized protected void updateContent() {\n        if (getFile().isPresent() == false) {\n            Platform.runLater(() -> imageBorder.setCenter(null));\n        } else {\n            doReadImageTask(getFile().get());\n        }\n    }","id":51145,"modified_method":"synchronized protected void updateContent() {\n        if (getFile().isPresent()) {\n            doReadImageTask(getFile().get());\n        }\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"synchronized protected void disposeContent() {\n        if (imageTask != null) {\n            imageTask.cancel();\n        }\n        imageTask = null;\n        Platform.runLater(() -> imageView.setImage(null));\n\n    }","id":51146,"modified_method":"synchronized protected void disposeContent() {\n        if (imageTask != null) {\n            imageTask.cancel();\n        }\n        imageTask = null;\n        Platform.runLater(() -> {\n            imageView.setImage(null);\n            imageBorder.setCenter(null);\n        });\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    void showImage(DrawableFile<?> file, Task<Image> imageTask) {\n        //Note that all error conditions are allready logged in readImageTask.succeeded()\n        try {\n            Image fxImage = imageTask.get();\n            if (nonNull(fxImage)) {\n                //we have non-null image show it\n                imageView.setImage(fxImage);\n                imageBorder.setCenter(imageView);\n            } else {\n                showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\n            }\n        } catch (CancellationException ex) {\n\n        } catch (InterruptedException | ExecutionException ex) {\n            showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\n        }\n    }","id":51147,"modified_method":"@ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    private void showImage(DrawableFile<?> file, Task<Image> imageTask) {\n        //Note that all error conditions are allready logged in readImageTask.succeeded()\n        try {\n            Image fxImage = imageTask.get();\n            if (nonNull(fxImage)) {\n                //we have non-null image show it\n                imageView.setImage(fxImage);\n                imageBorder.setCenter(imageView);\n            } else {\n                showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\n            }\n        } catch (CancellationException ex) {\n\n        } catch (InterruptedException | ExecutionException ex) {\n            showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\n        }\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"synchronized Node doReadImageTask(DrawableFile<?> file) {\n        disposeContent();\n        Task<Image> myTask = newReadImageTask(file);\n        imageTask = myTask;\n        Node progressNode = newProgressIndicator(myTask);\n        Platform.runLater(() -> imageBorder.setCenter(progressNode));\n\n        //called on fx thread\n        imageTask.setOnSucceeded(succeeded -> showImage(file, myTask));\n        imageTask.setOnFailed(failed -> showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file));\n\n        exec.execute(myTask);\n        return progressNode;\n    }","id":51148,"modified_method":"synchronized Node doReadImageTask(DrawableFile<?> file) {\n        Task<Image> myTask = newReadImageTask(file);\n        imageTask = myTask;\n        Node progressNode = newProgressIndicator(myTask);\n        Platform.runLater(() -> imageBorder.setCenter(progressNode));\n\n        //called on fx thread\n        myTask.setOnSucceeded(succeeded -> {\n            showImage(file, myTask);\n            synchronized (DrawableUIBase.this) {\n                imageTask = null;\n            }\n        });\n        myTask.setOnFailed(failed -> {\n            showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\n            synchronized (DrawableUIBase.this) {\n                imageTask = null;\n            }\n        });\n        myTask.setOnCancelled(cancelled -> {\n            disposeContent();\n        });\n\n        exec.execute(myTask);\n        return progressNode;\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected javafx.scene.image.Image readImage() throws IOException {\n            try (InputStream inputStream = new BufferedInputStream(new ReadContentInputStream(file));) {\n                if (ImageUtils.isGIF(file)) {\n                    //directly read GIF to preserve potential animation,\n                    javafx.scene.image.Image image = new javafx.scene.image.Image(new BufferedInputStream(inputStream));\n                    if (image.isError() == false) {\n                        return image;\n                    }\n                    //fall through to default iamge reading code if there was an error\n                }\n\n                try (ImageInputStream input = ImageIO.createImageInputStream(inputStream)) {\n                    if (input == null) {\n                        throw new IIOException(COULD_NOT_CREATE_IMAGE_INPUT_STREAM);\n                    }\n                    Iterator<ImageReader> readers = ImageIO.getImageReaders(input);\n\n                    if (readers.hasNext()) {\n                        reader = readers.next();\n                        reader.addIIOReadProgressListener(this);\n                        reader.setInput(input);\n                        /*\n                         * This is the important part, get or create a\n                         * ImageReadParam, create a destination image to hold\n                         * the decoded result, then pass that image with the\n                         * param.\n                         */\n                        ImageReadParam param = reader.getDefaultReadParam();\n\n                        bufferedImage = reader.getImageTypes(0).next().createBufferedImage(reader.getWidth(0), reader.getHeight(0));\n                        param.setDestination(bufferedImage);\n                        try {\n                            reader.read(0, param);\n                            if (isCancelled()) {\n                                return null;\n                            }\n                        } catch (IOException iOException) {\n                            // Ignore this exception or display a warning or similar, for exceptions happening during decoding\n                            logContentError(logger, Level.WARNING, \"ImageIO could not read {0}.  It may be unsupported or corrupt: \" + iOException.toString(), file);\n                        }\n                        reader.removeIIOReadProgressListener(this);\n                        reader.dispose();\n                        return SwingFXUtils.toFXImage(bufferedImage, null);\n                    } else {\n                        throw newImageReaderException(file);\n\n                    }\n                }\n            }\n        }","id":51149,"modified_method":"protected javafx.scene.image.Image readImage() throws IOException {\n            try (InputStream inputStream = new BufferedInputStream(new ReadContentInputStream(file));) {\n                if (ImageUtils.isGIF(file)) {\n                    //directly read GIF to preserve potential animation,\n                    javafx.scene.image.Image image = new javafx.scene.image.Image(new BufferedInputStream(inputStream));\n                    if (image.isError() == false) {\n                        return image;\n                    }\n                    //fall through to default iamge reading code if there was an error\n                }\n\n                try (ImageInputStream input = ImageIO.createImageInputStream(inputStream)) {\n                    if (input == null) {\n                        throw new IIOException(COULD_NOT_CREATE_IMAGE_INPUT_STREAM);\n                    }\n                    Iterator<ImageReader> readers = ImageIO.getImageReaders(input);\n\n                    if (readers.hasNext()) {\n                        reader = readers.next();\n                        reader.addIIOReadProgressListener(this);\n                        reader.setInput(input);\n                        /*\n                         * This is the important part, get or create a\n                         * ImageReadParam, create a destination image to hold\n                         * the decoded result, then pass that image with the\n                         * param.\n                         */\n                        ImageReadParam param = reader.getDefaultReadParam();\n\n                        BufferedImage bufferedImage = reader.getImageTypes(0).next().createBufferedImage(reader.getWidth(0), reader.getHeight(0));\n                        param.setDestination(bufferedImage);\n                        try {\n                            bufferedImage = reader.read(0, param);\n                            if (isCancelled()) {\n                                return null;\n                            }\n                        } catch (IOException iOException) {\n                            // Ignore this exception or display a warning or similar, for exceptions happening during decoding\n                            logContentError(logger, Level.WARNING, \"ImageIO could not read {0}.  It may be unsupported or corrupt: \" + iOException.toString(), file);\n                        } finally {\n                            reader.removeIIOReadProgressListener(this);\n                            reader.dispose();\n                        }\n                        return SwingFXUtils.toFXImage(bufferedImage, null);\n                    } else {\n                        throw newImageReaderException(file);\n                    }\n                }\n            }\n        }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     *\n     * @param file          the value of file\n     * @param errorTemplate the value of errorTemplate\n     *\n     * @return the int\n     *\n     * @throws IIOException\n     * @throws IOException\n     */\n    private static <T> T getIntProperty(AbstractFile file, final String errorTemplate, PropertyExctractor<T> propertyExtractor) throws IOException {\n        try (InputStream inputStream = new BufferedInputStream(new ReadContentInputStream(file));) {\n\n            try (ImageInputStream input = ImageIO.createImageInputStream(inputStream)) {\n                if (input == null) {\n                    IIOException iioException = new IIOException(COULD_NOT_CREATE_IMAGE_INPUT_STREAM);\n                    ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + iioException.toString(), file);\n                    throw iioException;\n                }\n                Iterator<ImageReader> readers = ImageIO.getImageReaders(input);\n\n                if (readers.hasNext()) {\n                    ImageReader reader = readers.next();\n                    reader.setInput(input);\n                    try {\n                        return propertyExtractor.extract(reader);\n                    } catch (IOException ex) {\n                        ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + ex.toString(), file);\n                        throw ex;\n                    }\n                } else {\n                    IIOException iioException = newImageReaderException(file);\n                    ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + iioException.toString(), file);\n\n                    throw iioException;\n                }\n            }\n        }\n    }","id":51150,"modified_method":"/**\n     *\n     * @param file          the value of file\n     * @param errorTemplate the value of errorTemplate\n     *\n     * @return the int\n     *\n     * @throws IIOException\n     * @throws IOException\n     */\n    private static <T> T getIntProperty(AbstractFile file, final String errorTemplate, PropertyExctractor<T> propertyExtractor) throws IOException {\n        try (InputStream inputStream = new BufferedInputStream(new ReadContentInputStream(file));) {\n\n            try (ImageInputStream input = ImageIO.createImageInputStream(inputStream)) {\n                if (input == null) {\n                    IIOException iioException = new IIOException(COULD_NOT_CREATE_IMAGE_INPUT_STREAM);\n                    ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + iioException.toString(), file);\n                    throw iioException;\n                }\n                Iterator<ImageReader> readers = ImageIO.getImageReaders(input);\n\n                if (readers.hasNext()) {\n                    ImageReader reader = readers.next();\n                    reader.setInput(input);\n                    try {\n\n                        return propertyExtractor.extract(reader);\n                    } catch (IOException ex) {\n                        ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + ex.toString(), file);\n                        throw ex;\n                    } finally {\n                        reader.dispose();\n                    }\n                } else {\n                    IIOException iioException = newImageReaderException(file);\n                    ImageUtils.logContentError(LOGGER, Level.WARNING, errorTemplate + iioException.toString(), file);\n\n                    throw iioException;\n                }\n            }\n        }\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        @NbBundle.Messages({\n            \"# {0} - file name\",\n            \"LoadImageTask.mesageText=Reading image: {0}\"})\n        protected javafx.scene.image.Image call() throws Exception {\n            updateMessage(Bundle.LoadImageTask_mesageText(file.getName()));\n            return readImage();\n        }","id":51151,"modified_method":"@Override\n        @NbBundle.Messages({\n            \"# {0} - file name\",\n            \"LoadImageTask.mesageText=Reading image: {0}\"})\n        protected javafx.scene.image.Image call() throws Exception {\n\n            return readImage();\n        }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        protected javafx.scene.image.Image call() throws Exception {\n\n            // If a thumbnail file is already saved locally, just read that.\n            if (cacheFile.exists()) {\n                try {\n                    BufferedImage cachedThumbnail = ImageIO.read(cacheFile);\n                    if (nonNull(cachedThumbnail) && cachedThumbnail.getWidth() == iconSize) {\n                        return SwingFXUtils.toFXImage(cachedThumbnail, null);\n                    }\n                } catch (Exception ex) {\n                    logContentError(logger, Level.WARNING, \"ImageIO had a problem reading thumbnail for image {0}: \" + ex.toString(), file);\n                }\n            }\n\n            BufferedImage thumbnail = null;\n            if (VideoUtils.isVideoThumbnailSupported(file)) {\n                if (openCVLoaded) {\n                    updateMessage(\"Generating preview for \" + file.getName());\n                    thumbnail = VideoUtils.generateVideoThumbnail(file, iconSize);\n                } else {\n                    thumbnail = DEFAULT_THUMBNAIL;\n                }\n            } else {\n                BufferedImage bufferedImage = SwingFXUtils.fromFXImage(readImage(), null);\n                if (isNull(bufferedImage)) {\n                    LOGGER.log(Level.WARNING, \"Failed to read image for thumbnail generation.\");\n                    throw new IIOException(\"Failed to read image for thumbnail generation.\");\n                }\n                updateProgress(-1, 1);\n\n                try {\n                    thumbnail = ScalrWrapper.resizeFast(bufferedImage, iconSize);\n                } catch (IllegalArgumentException | OutOfMemoryError e) {\n                    // if resizing does not work due to extreme aspect ratio, crop the image instead.\n                    logContentError(logger, Level.WARNING, \"Could not scale image {0}: \" + e.toString() + \".  Attemptying to crop {0} instead\", file);\n\n                    final int height = bufferedImage.getHeight();\n                    final int width = bufferedImage.getWidth();\n                    if (iconSize < height || iconSize < width) {\n                        final int cropHeight = Math.min(iconSize, height);\n                        final int cropWidth = Math.min(iconSize, width);\n\n                        try {\n                            thumbnail = ScalrWrapper.cropImage(bufferedImage, cropWidth, cropHeight);\n                        } catch (Exception cropException) {\n                            logContentError(logger, Level.WARNING, \"Could not crop image {0}: \" + cropException.toString(), file);\n                            throw cropException;\n                        }\n                    }\n                } catch (Exception e) {\n                    logContentError(logger, Level.WARNING, \"Could not scale image {0}: \" + e.toString(), file);\n                    throw e;\n                }\n            }\n            updateProgress(-1, 1);\n            if (nonNull(thumbnail) && DEFAULT_THUMBNAIL != thumbnail) {\n                saveThumbnail(thumbnail);\n            }\n            return SwingFXUtils.toFXImage(thumbnail, null);\n        }","id":51152,"modified_method":"@Override\n        protected javafx.scene.image.Image call() throws Exception {\n\n            // If a thumbnail file is already saved locally, just read that.\n            if (cacheFile.exists()) {\n                try {\n                    BufferedImage cachedThumbnail = ImageIO.read(cacheFile);\n                    if (nonNull(cachedThumbnail) && cachedThumbnail.getWidth() == iconSize) {\n                        return SwingFXUtils.toFXImage(cachedThumbnail, null);\n                    }\n                } catch (IOException ex) {\n                    logContentError(logger, Level.WARNING, \"ImageIO had a problem reading thumbnail for image {0}: \" + ex.toString(), file);\n                }\n            }\n\n            BufferedImage thumbnail = null;\n            if (VideoUtils.isVideoThumbnailSupported(file)) {\n                if (openCVLoaded) {\n                    updateMessage(\"Generating preview for \" + file.getName());\n                    thumbnail = VideoUtils.generateVideoThumbnail(file, iconSize);\n                } else {\n                    thumbnail = DEFAULT_THUMBNAIL;\n                }\n            } else {\n                BufferedImage bufferedImage = SwingFXUtils.fromFXImage(readImage(), null);\n                if (isNull(bufferedImage)) {\n                    LOGGER.log(Level.WARNING, \"Failed to read image for thumbnail generation.\");\n                    throw new IIOException(\"Failed to read image for thumbnail generation.\");\n                }\n                updateProgress(-1, 1);\n\n                try {\n                    thumbnail = ScalrWrapper.resizeFast(bufferedImage, iconSize);\n                } catch (IllegalArgumentException | OutOfMemoryError e) {\n                    // if resizing does not work due to extreme aspect ratio, crop the image instead.\n                    logContentError(logger, Level.WARNING, \"Could not scale image {0}: \" + e.toString() + \".  Attemptying to crop {0} instead\", file);\n\n                    final int height = bufferedImage.getHeight();\n                    final int width = bufferedImage.getWidth();\n                    if (iconSize < height || iconSize < width) {\n                        final int cropHeight = Math.min(iconSize, height);\n                        final int cropWidth = Math.min(iconSize, width);\n\n                        try {\n                            thumbnail = ScalrWrapper.cropImage(bufferedImage, cropWidth, cropHeight);\n                        } catch (Exception cropException) {\n                            logContentError(logger, Level.WARNING, \"Could not crop image {0}: \" + cropException.toString(), file);\n                            throw cropException;\n                        }\n                    }\n                } catch (Exception e) {\n                    logContentError(logger, Level.WARNING, \"Could not scale image {0}: \" + e.toString(), file);\n                    throw e;\n                }\n            }\n            updateProgress(-1, 1);\n            if (nonNull(thumbnail) && DEFAULT_THUMBNAIL != thumbnail) {\n                saveThumbnail(thumbnail);\n            }\n            return SwingFXUtils.toFXImage(thumbnail, null);\n        }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"ReadImageTask(AbstractFile file) {\n            super(file);\n        }","id":51153,"modified_method":"ReadImageTask(AbstractFile file) {\n            super(file);\n            updateMessage(Bundle.LoadImageTask_mesageText(file.getName()));\n        }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    synchronized protected void setFileHelper(Long newFileID) {\n        setFileIDOpt(Optional.ofNullable(newFileID));\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                imageBorder.setCenter(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n            });\n        } else {\n            disposeContent();\n            updateAttributesTable();\n            updateCategory();\n            updateContent();\n        }\n    }","id":51154,"modified_method":"@Override\n    synchronized protected void setFileHelper(Long newFileID) {\n        setFileIDOpt(Optional.ofNullable(newFileID));\n        disposeContent();\n        if (nonNull(newFileID)) {\n            updateAttributesTable();\n            updateCategory();\n            updateContent();\n        }\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    synchronized protected void updateContent() {\n        if (getFile().isPresent() == false) {\n            mediaCache = null;\n            Platform.runLater(() -> imageBorder.setCenter(null));\n\n        } else {\n            DrawableFile<?> file = getFile().get();\n            if (file.isVideo()) {\n                //specially handling for videos\n                Node mediaNode = (isNull(mediaCache)) ? null : mediaCache.get();\n                if (nonNull(mediaNode)) {\n                    Platform.runLater(() -> imageBorder.setCenter(mediaNode));\n                } else {\n\n                    MediaLoadTask mediaTask = new MediaLoadTask(((VideoFile<?>) file));\n                    Node progressNode = newProgressIndicator(mediaTask);\n                    Platform.runLater(() -> imageBorder.setCenter(progressNode));\n\n                    //called on fx thread\n                    mediaTask.setOnSucceeded(succedded -> showMedia(file, mediaTask));\n                    mediaTask.setOnFailed(failed -> showErrorNode(getMediaLoadErrorLabel(mediaTask), file));\n\n                    exec.execute(mediaTask);\n                }\n            } else {\n                super.updateContent();\n            }\n        }\n    }","id":51155,"modified_method":"@Override\n    synchronized protected void updateContent() {\n        disposeContent();\n        if (getFile().isPresent()) {\n            DrawableFile<?> file = getFile().get();\n            if (file.isVideo()) {\n                doMediaLoadTask((VideoFile<?>) file);\n            } else {\n                doReadImageTask(file);\n            }\n        }\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected void disposeContent() {\n        stopVideo();\n\n        super.disposeContent();\n//        if (mediaTask != null) {\n//            mediaTask.cancel(true);\n//        }\n//        mediaTask = null;\n        mediaCache = null;\n    }","id":51156,"modified_method":"@Override\n    synchronized protected void disposeContent() {\n        stopVideo();\n\n        if (mediaTask != null) {\n            mediaTask.cancel(true);\n        }\n        mediaTask = null;\n        super.disposeContent();\n    }","commit_id":"8f32064c2d8ad7b763d9f416f3a4edb44130d44f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected void handleResponse(CommandContext ctx, ModelNode result, boolean composite) {\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(Util.getFailureDescription(result));\n            return;\n        }\n    }","id":51157,"modified_method":"protected void handleResponse(CommandContext ctx, ModelNode response, boolean composite) {\n        if (!Util.isSuccess(response)) {\n            ctx.printLine(Util.getFailureDescription(response));\n            return;\n        }\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (CommandFormatException e1) {\n            ctx.printLine(e1.getLocalizedMessage());\n            return;\n        }\n\n        if(request == null) {\n            ctx.printLine(\"Operation request wasn't built.\");\n            return;\n        }\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        final ModelNode result;\n        try {\n            result = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to perform operation: \" + e.getLocalizedMessage());\n            return;\n        }\n        handleResponse(ctx, result, Util.COMPOSITE.equals(request.get(Util.OPERATION).asString()));\n    }","id":51158,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (CommandFormatException e1) {\n            ctx.printLine(e1.getLocalizedMessage());\n            return;\n        }\n\n        if(request == null) {\n            ctx.printLine(\"Operation request wasn't built.\");\n            return;\n        }\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        final ModelNode response;\n        try {\n            response = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to perform operation: \" + e.getLocalizedMessage());\n            return;\n        }\n        handleResponse(ctx, response, Util.COMPOSITE.equals(request.get(Util.OPERATION).asString()));\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        final ParsedCommandLine parsedCmd = ctx.getParsedCommandLine();\n        String nodePath = this.nodePath.getValue(parsedCmd);\n\n        final OperationRequestAddress address;\n        if (nodePath != null) {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n            CommandLineParser.CallbackHandler handler = new DefaultCallbackHandler(address);\n\n            // this is for correct parsing of escaped characters\n            nodePath = ctx.getArgumentsString();\n            if(l.isPresent(parsedCmd)) {\n                nodePath = nodePath.trim();\n                if(nodePath.startsWith(\"-l \")) {\n                    nodePath = nodePath.substring(3);\n                } else {\n                    nodePath = nodePath.substring(0, nodePath.length() - 3);\n                }\n            }\n\n            try {\n                ctx.getCommandLineParser().parse(nodePath, handler);\n            } catch (CommandFormatException e) {\n                ctx.printLine(e.getLocalizedMessage());\n            }\n        } else {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n        }\n\n        List<String> names = null;\n        if(address.endsOnType()) {\n            final String type = address.getNodeType();\n            address.toParentNode();\n            names = Util.getNodeNames(ctx.getModelControllerClient(), address, type);\n        } else {\n            final ModelNode composite = new ModelNode();\n            composite.get(Util.OPERATION).set(Util.COMPOSITE);\n            composite.get(Util.ADDRESS).setEmptyList();\n            final ModelNode steps = composite.get(Util.STEPS);\n\n            {\n                final ModelNode typesRequest = new ModelNode();\n                typesRequest.get(Util.OPERATION).set(Util.READ_CHILDREN_TYPES);\n                final ModelNode addressNode = typesRequest.get(Util.ADDRESS);\n                if (address.isEmpty()) {\n                    addressNode.setEmptyList();\n                } else {\n                    Iterator<Node> iterator = address.iterator();\n                    while (iterator.hasNext()) {\n                        OperationRequestAddress.Node node = iterator.next();\n                        if (node.getName() != null) {\n                            addressNode.add(node.getType(), node.getName());\n                        } else if (iterator.hasNext()) {\n                            throw new OperationFormatException(\"Expected a node name for type '\" + node.getType()\n                                    + \"' in path '\" + ctx.getPrefixFormatter().format(address) + \"'\");\n                        }\n                    }\n                }\n                steps.add(typesRequest);\n            }\n\n            {\n                final ModelNode resourceRequest = new ModelNode();\n                resourceRequest.get(Util.OPERATION).set(Util.READ_RESOURCE);\n                final ModelNode addressNode = resourceRequest.get(Util.ADDRESS);\n                if (address.isEmpty()) {\n                    addressNode.setEmptyList();\n                } else {\n                    Iterator<Node> iterator = address.iterator();\n                    while (iterator.hasNext()) {\n                        OperationRequestAddress.Node node = iterator.next();\n                        if (node.getName() != null) {\n                            addressNode.add(node.getType(), node.getName());\n                        } else if (iterator.hasNext()) {\n                            throw new OperationFormatException(\"Expected a node name for type '\" + node.getType()\n                                    + \"' in path '\" + ctx.getPrefixFormatter().format(address) + \"'\");\n                        }\n                    }\n                }\n                resourceRequest.get(Util.INCLUDE_RUNTIME).set(Util.TRUE);\n                steps.add(resourceRequest);\n            }\n\n            if(l.isPresent(parsedCmd)) {\n                final ModelNode request = new ModelNode();\n                request.get(Util.OPERATION).set(Util.READ_RESOURCE_DESCRIPTION);\n                final ModelNode addressNode = request.get(Util.ADDRESS);\n                if (address.isEmpty()) {\n                    addressNode.setEmptyList();\n                } else {\n                    Iterator<Node> iterator = address.iterator();\n                    while (iterator.hasNext()) {\n                        OperationRequestAddress.Node node = iterator.next();\n                        if (node.getName() != null) {\n                            addressNode.add(node.getType(), node.getName());\n                        } else if (iterator.hasNext()) {\n                            throw new OperationFormatException(\"Expected a node name for type '\" + node.getType()\n                                    + \"' in path '\" + ctx.getPrefixFormatter().format(address) + \"'\");\n                        }\n                    }\n                }\n                steps.add(request);\n            }\n\n            try {\n                ModelNode outcome = ctx.getModelControllerClient().execute(composite);\n                if(Util.isSuccess(outcome)) {\n                    if(outcome.hasDefined(Util.RESULT)) {\n                        ModelNode resultNode = outcome.get(Util.RESULT);\n\n                        ModelNode attrDescriptions = null;\n                        ModelNode childDescriptions = null;\n                        if(resultNode.hasDefined(Util.STEP_3)) {\n                            final ModelNode stepOutcome = resultNode.get(Util.STEP_3);\n                            if(Util.isSuccess(stepOutcome)) {\n                                if(stepOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode descrResult = stepOutcome.get(Util.RESULT);\n                                    if(descrResult.hasDefined(Util.ATTRIBUTES)) {\n                                        attrDescriptions = descrResult.get(Util.ATTRIBUTES);\n                                    }\n                                    if(descrResult.hasDefined(Util.CHILDREN)) {\n                                        childDescriptions = descrResult.get(Util.CHILDREN);\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-resource-description request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to get resource description: \" + outcome);\n                            }\n                        }\n\n                        List<String> typeNames = null;\n                        if(resultNode.hasDefined(Util.STEP_1)) {\n                            ModelNode typesOutcome = resultNode.get(Util.STEP_1);\n                            if(Util.isSuccess(typesOutcome)) {\n                                if(typesOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode resourceResult = typesOutcome.get(Util.RESULT);\n                                    final List<ModelNode> types = resourceResult.asList();\n                                    if (!types.isEmpty()) {\n                                        typeNames = new ArrayList<String>();\n                                        for (ModelNode type : types) {\n                                            typeNames.add(type.asString());\n                                        }\n                                        if(childDescriptions == null && attrDescriptions == null) {\n                                            names = typeNames;\n                                        }\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-children-types request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to fetch type names: \" + outcome);\n                            }\n                        } else {\n                            ctx.printLine(\"The result for children type names is not available: \" + outcome);\n                        }\n\n                        if(resultNode.hasDefined(Util.STEP_2)) {\n                            ModelNode resourceOutcome = resultNode.get(Util.STEP_2);\n                            if(Util.isSuccess(resourceOutcome)) {\n                                if(resourceOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode resourceResult = resourceOutcome.get(Util.RESULT);\n                                    final List<Property> props = resourceResult.asPropertyList();\n                                    if (!props.isEmpty()) {\n                                        // potentially, allowed and default values\n//                                        SimpleTable attrTable = attrDescriptions == null ? null :\n//                                            new SimpleTable(new String[]{\"ATTR NAME\", \"VALUE\", \"TYPE\", \"NILLABLE\", \"REQUIRED\", \"ACCESS\", \"EXPR\", \"RESTART\", \"STORAGE\"});\n//                                      SimpleTable childrenTable = childDescriptions == null ? null :\n//                                            new SimpleTable(new String[]{\"CHILD NAME\", \"MIN-OCCURS\", \"MAX-OCCURS\"});\n                                        StrictSizeTable attrTable = attrDescriptions == null ? null : new StrictSizeTable(attrDescriptions.keys().size());\n                                        StrictSizeTable childrenTable = childDescriptions == null ? null : new StrictSizeTable(childDescriptions.keys().size());\n                                        if(typeNames == null && attrTable == null && childrenTable == null) {\n                                            typeNames = new ArrayList<String>();\n                                        }\n\n                                        for (Property prop : props) {\n                                            final StringBuilder buf = new StringBuilder();\n                                            if(typeNames == null || !typeNames.contains(prop.getName())) {\n                                                if(attrDescriptions == null) {\n                                                    buf.append(prop.getName());\n                                                    buf.append('=');\n                                                    buf.append(prop.getValue().asString());\n// TODO the value should be formatted nicer but the current fomatter uses new lines for complex value which doesn't work here\n//                                                    final ModelNode value = prop.getValue();\n//                                                    ModelNodeFormatter.Factory.forType(value.getType()).format(buf, 0, value);\n                                                    typeNames.add(buf.toString());\n                                                    buf.setLength(0);\n                                                } else {\n                                                    if(attrDescriptions.hasDefined(prop.getName())) {\n                                                        final ModelNode attrDescr = attrDescriptions.get(prop.getName());\n/*                                                        attrTable.addLine(new String[]{prop.getName(),\n                                                                prop.getValue().asString(),\n                                                                getAsString(attrDescr, Util.TYPE),\n                                                                getAsString(attrDescr, Util.NILLABLE),\n                                                                getAsString(attrDescr, Util.REQUIRED),\n                                                                getAsString(attrDescr, Util.ACCESS_TYPE),\n                                                                getAsString(attrDescr, Util.EXPRESSIONS_ALLOWED),\n                                                                getAsString(attrDescr, Util.RESTART_REQUIRED),\n                                                                getAsString(attrDescr, Util.STORAGE)\n                                                                });\n*/\n                                                        attrTable.addCell(\"ATTRIBUTE\", prop.getName());\n                                                        attrTable.addCell(Util.VALUE, prop.getValue().asString());\n                                                        for(String name : attrDescr.keys()) {\n                                                            if(!Util.DESCRIPTION.equals(name) &&\n                                                                    !Util.HEAD_COMMENT_ALLOWED.equals(name) &&\n                                                                    !Util.TAIL_COMMENT_ALLOWED.equals(name)) {\n                                                                attrTable.addCell(name, attrDescr.get(name).asString());\n                                                            }\n                                                        }\n                                                    } else {\n/*                                                        attrTable.addLine(new String[]{prop.getName(),\n                                                                prop.getValue().asString(),\n                                                                \"n/a\", \"n/a\", \"n/a\", \"n/a\", \"n/a\", \"n/a\"\n                                                            });\n*/\n                                                        attrTable.addCell(\"ATTRIBUTE\", prop.getName());\n                                                        attrTable.addCell(Util.VALUE, prop.getValue().asString());\n                                                    }\n                                                    if(!attrTable.isAtLastRow()) {\n                                                        attrTable.nextRow();\n                                                    }\n                                                }\n                                            } else if(childDescriptions != null) {\n                                                if(childDescriptions.hasDefined(prop.getName())) {\n                                                    final ModelNode childDescr = childDescriptions.get(prop.getName());\n/*                                                    childrenTable.addLine(new String[]{prop.getName(),\n                                                            getAsString(childDescr, Util.MIN_OCCURS),\n                                                            getAsString(childDescr, Util.MAX_OCCURS)\n                                                            });\n*/\n                                                    childrenTable.addCell(\"CHILD\", prop.getName());\n                                                    for(String name : childDescr.keys()) {\n                                                        if(!Util.DESCRIPTION.equals(name) &&\n                                                                !Util.HEAD_COMMENT_ALLOWED.equals(name) &&\n                                                                !Util.TAIL_COMMENT_ALLOWED.equals(name)) {\n                                                            childrenTable.addCell(name, childDescr.get(name).asString());\n                                                        }\n                                                    }\n                                                } else {\n//                                                    attrTable.addLine(new String[]{prop.getName(), \"n/a\", \"n/a\"});\n                                                    childrenTable.addCell(\"CHILD\", prop.getName());\n                                                }\n                                                if(!childrenTable.isAtLastRow()) {\n                                                    childrenTable.nextRow();\n                                                }\n                                            }\n                                        }\n\n                                        if(childrenTable != null && !childrenTable.isEmpty()) {\n                                            ctx.printLine(childrenTable.toString());\n                                        }\n                                        if(attrTable != null && !attrTable.isEmpty()) {\n                                            ctx.printLine(attrTable.toString());\n                                        }\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-resource request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to fetch attributes: \" + outcome);\n                            }\n                        } else {\n                            ctx.printLine(\"The result for attributes is not available: \" + outcome);\n                        }\n                    }\n                } else {\n                    ctx.printLine(\"Failed to fetch the list of children: \" + outcome);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        if(names != null) {\n            printList(ctx, names, l.isPresent(parsedCmd));\n        }\n    }","id":51159,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        final ParsedCommandLine parsedCmd = ctx.getParsedCommandLine();\n        String nodePath = this.nodePath.getValue(parsedCmd);\n\n        final OperationRequestAddress address;\n        if (nodePath != null) {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n            CommandLineParser.CallbackHandler handler = new DefaultCallbackHandler(address);\n\n            // this is for correct parsing of escaped characters\n            nodePath = ctx.getArgumentsString();\n            if(l.isPresent(parsedCmd)) {\n                nodePath = nodePath.trim();\n                if(nodePath.startsWith(\"-l \")) {\n                    nodePath = nodePath.substring(3);\n                } else {\n                    nodePath = nodePath.substring(0, nodePath.length() - 3);\n                }\n            }\n\n            try {\n                ctx.getCommandLineParser().parse(nodePath, handler);\n            } catch (CommandFormatException e) {\n                ctx.printLine(e.getLocalizedMessage());\n            }\n        } else {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n        }\n\n        List<String> names = null;\n        if(address.endsOnType()) {\n            final String type = address.getNodeType();\n            address.toParentNode();\n            names = Util.getNodeNames(ctx.getModelControllerClient(), address, type);\n        } else {\n            final ModelNode composite = new ModelNode();\n            composite.get(Util.OPERATION).set(Util.COMPOSITE);\n            composite.get(Util.ADDRESS).setEmptyList();\n            final ModelNode steps = composite.get(Util.STEPS);\n\n            {\n                final ModelNode typesRequest = new ModelNode();\n                typesRequest.get(Util.OPERATION).set(Util.READ_CHILDREN_TYPES);\n                final ModelNode addressNode = typesRequest.get(Util.ADDRESS);\n                if (address.isEmpty()) {\n                    addressNode.setEmptyList();\n                } else {\n                    Iterator<Node> iterator = address.iterator();\n                    while (iterator.hasNext()) {\n                        OperationRequestAddress.Node node = iterator.next();\n                        if (node.getName() != null) {\n                            addressNode.add(node.getType(), node.getName());\n                        } else if (iterator.hasNext()) {\n                            throw new OperationFormatException(\"Expected a node name for type '\" + node.getType()\n                                    + \"' in path '\" + ctx.getPrefixFormatter().format(address) + \"'\");\n                        }\n                    }\n                }\n                steps.add(typesRequest);\n            }\n\n            {\n                final ModelNode resourceRequest = new ModelNode();\n                resourceRequest.get(Util.OPERATION).set(Util.READ_RESOURCE);\n                final ModelNode addressNode = resourceRequest.get(Util.ADDRESS);\n                if (address.isEmpty()) {\n                    addressNode.setEmptyList();\n                } else {\n                    Iterator<Node> iterator = address.iterator();\n                    while (iterator.hasNext()) {\n                        OperationRequestAddress.Node node = iterator.next();\n                        if (node.getName() != null) {\n                            addressNode.add(node.getType(), node.getName());\n                        } else if (iterator.hasNext()) {\n                            throw new OperationFormatException(\"Expected a node name for type '\" + node.getType()\n                                    + \"' in path '\" + ctx.getPrefixFormatter().format(address) + \"'\");\n                        }\n                    }\n                }\n                resourceRequest.get(Util.INCLUDE_RUNTIME).set(Util.TRUE);\n                steps.add(resourceRequest);\n            }\n\n            if(l.isPresent(parsedCmd)) {\n                steps.add(Util.buildRequest(ctx, address, Util.READ_RESOURCE_DESCRIPTION));\n            }\n\n            try {\n                ModelNode outcome = ctx.getModelControllerClient().execute(composite);\n                if(Util.isSuccess(outcome)) {\n                    if(outcome.hasDefined(Util.RESULT)) {\n                        ModelNode resultNode = outcome.get(Util.RESULT);\n\n                        ModelNode attrDescriptions = null;\n                        ModelNode childDescriptions = null;\n                        if(resultNode.hasDefined(Util.STEP_3)) {\n                            final ModelNode stepOutcome = resultNode.get(Util.STEP_3);\n                            if(Util.isSuccess(stepOutcome)) {\n                                if(stepOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode descrResult = stepOutcome.get(Util.RESULT);\n                                    if(descrResult.hasDefined(Util.ATTRIBUTES)) {\n                                        attrDescriptions = descrResult.get(Util.ATTRIBUTES);\n                                    }\n                                    if(descrResult.hasDefined(Util.CHILDREN)) {\n                                        childDescriptions = descrResult.get(Util.CHILDREN);\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-resource-description request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to get resource description: \" + outcome);\n                            }\n                        }\n\n                        List<String> typeNames = null;\n                        if(resultNode.hasDefined(Util.STEP_1)) {\n                            ModelNode typesOutcome = resultNode.get(Util.STEP_1);\n                            if(Util.isSuccess(typesOutcome)) {\n                                if(typesOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode resourceResult = typesOutcome.get(Util.RESULT);\n                                    final List<ModelNode> types = resourceResult.asList();\n                                    if (!types.isEmpty()) {\n                                        typeNames = new ArrayList<String>();\n                                        for (ModelNode type : types) {\n                                            typeNames.add(type.asString());\n                                        }\n                                        if(childDescriptions == null && attrDescriptions == null) {\n                                            names = typeNames;\n                                        }\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-children-types request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to fetch type names: \" + outcome);\n                            }\n                        } else {\n                            ctx.printLine(\"The result for children type names is not available: \" + outcome);\n                        }\n\n                        if(resultNode.hasDefined(Util.STEP_2)) {\n                            ModelNode resourceOutcome = resultNode.get(Util.STEP_2);\n                            if(Util.isSuccess(resourceOutcome)) {\n                                if(resourceOutcome.hasDefined(Util.RESULT)) {\n                                    final ModelNode resourceResult = resourceOutcome.get(Util.RESULT);\n                                    final List<Property> props = resourceResult.asPropertyList();\n                                    if (!props.isEmpty()) {\n                                        // potentially, allowed and default values\n//                                        SimpleTable attrTable = attrDescriptions == null ? null :\n//                                            new SimpleTable(new String[]{\"ATTR NAME\", \"VALUE\", \"TYPE\", \"NILLABLE\", \"REQUIRED\", \"ACCESS\", \"EXPR\", \"RESTART\", \"STORAGE\"});\n//                                      SimpleTable childrenTable = childDescriptions == null ? null :\n//                                            new SimpleTable(new String[]{\"CHILD NAME\", \"MIN-OCCURS\", \"MAX-OCCURS\"});\n                                        StrictSizeTable attrTable = attrDescriptions == null ? null : new StrictSizeTable(attrDescriptions.keys().size());\n                                        StrictSizeTable childrenTable = childDescriptions == null ? null : new StrictSizeTable(childDescriptions.keys().size());\n                                        if(typeNames == null && attrTable == null && childrenTable == null) {\n                                            typeNames = new ArrayList<String>();\n                                        }\n\n                                        for (Property prop : props) {\n                                            final StringBuilder buf = new StringBuilder();\n                                            if(typeNames == null || !typeNames.contains(prop.getName())) {\n                                                if(attrDescriptions == null) {\n                                                    buf.append(prop.getName());\n                                                    buf.append('=');\n                                                    buf.append(prop.getValue().asString());\n// TODO the value should be formatted nicer but the current fomatter uses new lines for complex value which doesn't work here\n//                                                    final ModelNode value = prop.getValue();\n//                                                    ModelNodeFormatter.Factory.forType(value.getType()).format(buf, 0, value);\n                                                    typeNames.add(buf.toString());\n                                                    buf.setLength(0);\n                                                } else {\n                                                    if(attrDescriptions.hasDefined(prop.getName())) {\n                                                        final ModelNode attrDescr = attrDescriptions.get(prop.getName());\n/*                                                        attrTable.addLine(new String[]{prop.getName(),\n                                                                prop.getValue().asString(),\n                                                                getAsString(attrDescr, Util.TYPE),\n                                                                getAsString(attrDescr, Util.NILLABLE),\n                                                                getAsString(attrDescr, Util.REQUIRED),\n                                                                getAsString(attrDescr, Util.ACCESS_TYPE),\n                                                                getAsString(attrDescr, Util.EXPRESSIONS_ALLOWED),\n                                                                getAsString(attrDescr, Util.RESTART_REQUIRED),\n                                                                getAsString(attrDescr, Util.STORAGE)\n                                                                });\n*/\n                                                        attrTable.addCell(\"ATTRIBUTE\", prop.getName());\n                                                        attrTable.addCell(Util.VALUE, prop.getValue().asString());\n                                                        for(String name : attrDescr.keys()) {\n                                                            if(!Util.DESCRIPTION.equals(name) &&\n                                                                    !Util.HEAD_COMMENT_ALLOWED.equals(name) &&\n                                                                    !Util.TAIL_COMMENT_ALLOWED.equals(name)) {\n                                                                attrTable.addCell(name, attrDescr.get(name).asString());\n                                                            }\n                                                        }\n                                                    } else {\n/*                                                        attrTable.addLine(new String[]{prop.getName(),\n                                                                prop.getValue().asString(),\n                                                                \"n/a\", \"n/a\", \"n/a\", \"n/a\", \"n/a\", \"n/a\"\n                                                            });\n*/\n                                                        attrTable.addCell(\"ATTRIBUTE\", prop.getName());\n                                                        attrTable.addCell(Util.VALUE, prop.getValue().asString());\n                                                    }\n                                                    if(!attrTable.isAtLastRow()) {\n                                                        attrTable.nextRow();\n                                                    }\n                                                }\n                                            } else if(childDescriptions != null) {\n                                                if(childDescriptions.hasDefined(prop.getName())) {\n                                                    final ModelNode childDescr = childDescriptions.get(prop.getName());\n/*                                                    childrenTable.addLine(new String[]{prop.getName(),\n                                                            getAsString(childDescr, Util.MIN_OCCURS),\n                                                            getAsString(childDescr, Util.MAX_OCCURS)\n                                                            });\n*/\n                                                    childrenTable.addCell(\"CHILD\", prop.getName());\n                                                    for(String name : childDescr.keys()) {\n                                                        if(!Util.DESCRIPTION.equals(name) &&\n                                                                !Util.HEAD_COMMENT_ALLOWED.equals(name) &&\n                                                                !Util.TAIL_COMMENT_ALLOWED.equals(name)) {\n                                                            childrenTable.addCell(name, childDescr.get(name).asString());\n                                                        }\n                                                    }\n                                                } else {\n//                                                    attrTable.addLine(new String[]{prop.getName(), \"n/a\", \"n/a\"});\n                                                    childrenTable.addCell(\"CHILD\", prop.getName());\n                                                }\n                                                if(!childrenTable.isAtLastRow()) {\n                                                    childrenTable.nextRow();\n                                                }\n                                            }\n                                        }\n\n                                        if(childrenTable != null && !childrenTable.isEmpty()) {\n                                            ctx.printLine(childrenTable.toString());\n                                        }\n                                        if(attrTable != null && !attrTable.isEmpty()) {\n                                            ctx.printLine(attrTable.toString());\n                                        }\n                                    }\n                                } else {\n                                    ctx.printLine(\"Result is not available for read-resource request: \" + outcome);\n                                }\n                            } else {\n                                ctx.printLine(\"Failed to fetch attributes: \" + outcome);\n                            }\n                        } else {\n                            ctx.printLine(\"The result for attributes is not available: \" + outcome);\n                        }\n                    }\n                } else {\n                    ctx.printLine(\"Failed to fetch the list of children: \" + outcome);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        if(names != null) {\n            printList(ctx, names, l.isPresent(parsedCmd));\n        }\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void handleResponse(CommandContext ctx, ModelNode result, boolean composite) {\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(Util.getFailureDescription(result));\n            return;\n        }\n        final StringBuilder buf = formatResponse(ctx, result, composite, null);\n        if(buf != null) {\n            ctx.printLine(buf.toString());\n        }\n    }","id":51160,"modified_method":"protected void handleResponse(CommandContext ctx, ModelNode response, boolean composite) {\n        if (!Util.isSuccess(response)) {\n            ctx.printLine(Util.getFailureDescription(response));\n            return;\n        }\n        if(!response.hasDefined(Util.RESULT)) {\n            return;\n        }\n\n        final ModelNode result = response.get(Util.RESULT);\n\n        if(composite) {\n            final SimpleTable table = new SimpleTable(2);\n            final StringBuilder valueBuf = new StringBuilder();\n            if(result.hasDefined(Util.STEP_1)) {\n                final ModelNode stepOutcome = result.get(Util.STEP_1);\n                if(Util.isSuccess(stepOutcome)) {\n                    if(stepOutcome.hasDefined(Util.RESULT)) {\n                        final ModelNode valueResult = stepOutcome.get(Util.RESULT);\n                        final ModelNodeFormatter formatter = ModelNodeFormatter.Factory.forType(valueResult.getType());\n                        formatter.format(valueBuf, 0, valueResult);\n                    } else {\n                        valueBuf.append(\"n/a\");\n                    }\n                    table.addLine(new String[]{\"value\", valueBuf.toString()});\n                } else {\n                    ctx.printLine(\"Failed to get resource description: \" + response);\n                }\n            }\n\n            if(result.hasDefined(Util.STEP_2)) {\n                final ModelNode stepOutcome = result.get(Util.STEP_2);\n                if(Util.isSuccess(stepOutcome)) {\n                    if(stepOutcome.hasDefined(Util.RESULT)) {\n                        final ModelNode descrResult = stepOutcome.get(Util.RESULT);\n                        if(descrResult.hasDefined(Util.ATTRIBUTES)) {\n                            ModelNode attributes = descrResult.get(Util.ATTRIBUTES);\n                            final String name = this.name.getValue(ctx.getParsedCommandLine());\n                            if(name == null) {\n                                ctx.printLine(\"Attribute name is not available in handleResponse.\");\n                            } else if(attributes.hasDefined(name)) {\n                                final ModelNode descr = attributes.get(name);\n                                for(String prop : descr.keys()) {\n                                    table.addLine(new String[]{prop, descr.get(prop).asString()});\n                                }\n                            } else {\n                                ctx.printLine(\"Attribute description is not available.\");\n                            }\n                        } else {\n                            ctx.printLine(\"The resource doesn't provide attribute descriptions.\");\n                        }\n                    } else {\n                        ctx.printLine(\"Result is not available for read-resource-description request: \" + response);\n                    }\n                } else {\n                    ctx.printLine(\"Failed to get resource description: \" + response);\n                }\n            }\n            ctx.printLine(table.toString(true));\n        } else {\n            final ModelNodeFormatter formatter = ModelNodeFormatter.Factory.forType(result.getType());\n            final StringBuilder buf = new StringBuilder();\n            formatter.format(buf, 0, result);\n            ctx.printLine(buf.toString());\n        }\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode buildRequest(CommandContext ctx) throws CommandFormatException {\n\n        final ParsedCommandLine parsedCmd = ctx.getParsedCommandLine();\n        final String name = this.name.getValue(parsedCmd);\n        if(name == null || name.isEmpty()) {\n            throw new CommandFormatException(\"Required argument \" + this.name.getFullName() + \" is not specified.\");\n        }\n\n        final OperationRequestAddress address = getAddress(ctx);\n        final ModelNode req = new ModelNode();\n        if(address.isEmpty()) {\n            req.get(Util.ADDRESS).setEmptyList();\n        } else {\n            if(address.endsOnType()) {\n                throw new CommandFormatException(\"The address ends on a type: \" + address.getNodeType());\n            }\n            final ModelNode addrNode = req.get(Util.ADDRESS);\n            for(OperationRequestAddress.Node node : address) {\n                addrNode.add(node.getType(), node.getName());\n            }\n        }\n        req.get(Util.OPERATION).set(Util.READ_ATTRIBUTE);\n        req.get(Util.NAME).set(name);\n\n        final String includeDefaults = this.includeDefaults.getValue(parsedCmd);\n        if(includeDefaults != null && !includeDefaults.isEmpty()) {\n            req.get(Util.INCLUDE_DEFAULTS).set(includeDefaults);\n        }\n\n        return req;\n    }","id":51161,"modified_method":"@Override\n    public ModelNode buildRequest(CommandContext ctx) throws CommandFormatException {\n\n        final ParsedCommandLine parsedCmd = ctx.getParsedCommandLine();\n        final String name = this.name.getValue(parsedCmd);\n        if(name == null || name.isEmpty()) {\n            throw new CommandFormatException(\"Required argument \" + this.name.getFullName() + \" is not specified.\");\n        }\n\n        final OperationRequestAddress address = getAddress(ctx);\n        ModelNode req = Util.buildRequest(ctx, address, Util.READ_ATTRIBUTE);\n        req.get(Util.NAME).set(name);\n\n        final String includeDefaults = this.includeDefaults.getValue(parsedCmd);\n        if(includeDefaults != null && !includeDefaults.isEmpty()) {\n            req.get(Util.INCLUDE_DEFAULTS).set(includeDefaults);\n        }\n\n        if(verbose.isPresent(parsedCmd)) {\n            final ModelNode composite = new ModelNode();\n            composite.get(Util.OPERATION).set(Util.COMPOSITE);\n            composite.get(Util.ADDRESS).setEmptyList();\n            final ModelNode steps = composite.get(Util.STEPS);\n            steps.add(req);\n            steps.add(Util.buildRequest(ctx, address, Util.READ_RESOURCE_DESCRIPTION));\n            req = composite;\n        }\n\n        return req;\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ReadAttributeHandler(CommandContext ctx) {\n        super(ctx, \"read-attribute\", true);\n\n        node = new ArgumentWithValue(this, OperationRequestCompleter.ARG_VALUE_COMPLETER, \"--node\");\n\n        name = new ArgumentWithValue(this, new DefaultCompleter(new DefaultCompleter.CandidatesProvider() {\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                try {\n                    final OperationRequestAddress address = getAddress(ctx);\n                    final ModelNode req = new ModelNode();\n                    if(address.isEmpty()) {\n                        req.get(Util.ADDRESS).setEmptyList();\n                    } else {\n                        if(address.endsOnType()) {\n                            return Collections.emptyList();\n                        }\n                        final ModelNode addrNode = req.get(Util.ADDRESS);\n                        for(OperationRequestAddress.Node node : address) {\n                            addrNode.add(node.getType(), node.getName());\n                        }\n                    }\n                    req.get(Util.OPERATION).set(Util.READ_RESOURCE_DESCRIPTION);\n                    try {\n                        final ModelNode response = ctx.getModelControllerClient().execute(req);\n                        if(Util.isSuccess(response)) {\n                            if(response.hasDefined(Util.RESULT)) {\n                                final ModelNode result = response.get(Util.RESULT);\n                                if(result.hasDefined(Util.ATTRIBUTES)) {\n                                    Set<String> attributes = result.get(Util.ATTRIBUTES).keys();\n                                    if(attributes.isEmpty()) {\n                                        return Collections.emptyList();\n                                    }\n                                    final List<String> candidates = new ArrayList<String>(attributes.size());\n                                    candidates.addAll(attributes);\n                                    return candidates;\n                                } else {\n                                    return Collections.emptyList();\n                                }\n                            } else {\n                                return Collections.emptyList();\n                            }\n                        } else {\n                            return Collections.emptyList();\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } catch (CommandFormatException e) {\n                    ctx.printLine(e.getLocalizedMessage());\n                    return Collections.emptyList();\n                }\n                return Collections.emptyList();\n            }}), \"--name\");\n\n        includeDefaults = new ArgumentWithValue(this, SimpleTabCompleter.BOOLEAN, \"--include-defaults\");\n    }","id":51162,"modified_method":"public ReadAttributeHandler(CommandContext ctx) {\n        super(ctx, \"read-attribute\", true);\n\n        node = new ArgumentWithValue(this, OperationRequestCompleter.ARG_VALUE_COMPLETER, \"--node\");\n\n        name = new ArgumentWithValue(this, new DefaultCompleter(new DefaultCompleter.CandidatesProvider() {\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                try {\n                    final OperationRequestAddress address = getAddress(ctx);\n                    final ModelNode req = new ModelNode();\n                    if(address.isEmpty()) {\n                        req.get(Util.ADDRESS).setEmptyList();\n                    } else {\n                        if(address.endsOnType()) {\n                            return Collections.emptyList();\n                        }\n                        final ModelNode addrNode = req.get(Util.ADDRESS);\n                        for(OperationRequestAddress.Node node : address) {\n                            addrNode.add(node.getType(), node.getName());\n                        }\n                    }\n                    req.get(Util.OPERATION).set(Util.READ_RESOURCE_DESCRIPTION);\n                    try {\n                        final ModelNode response = ctx.getModelControllerClient().execute(req);\n                        if(Util.isSuccess(response)) {\n                            if(response.hasDefined(Util.RESULT)) {\n                                final ModelNode result = response.get(Util.RESULT);\n                                if(result.hasDefined(Util.ATTRIBUTES)) {\n                                    Set<String> attributes = result.get(Util.ATTRIBUTES).keys();\n                                    if(attributes.isEmpty()) {\n                                        return Collections.emptyList();\n                                    }\n                                    final List<String> candidates = new ArrayList<String>(attributes.size());\n                                    candidates.addAll(attributes);\n                                    return candidates;\n                                } else {\n                                    return Collections.emptyList();\n                                }\n                            } else {\n                                return Collections.emptyList();\n                            }\n                        } else {\n                            return Collections.emptyList();\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } catch (CommandFormatException e) {\n                    ctx.printLine(e.getLocalizedMessage());\n                    return Collections.emptyList();\n                }\n                return Collections.emptyList();\n            }}), \"--name\");\n\n        includeDefaults = new ArgumentWithValue(this, SimpleTabCompleter.BOOLEAN, \"--include-defaults\");\n\n        verbose = new ArgumentWithoutValue(this, \"--verbose\", \"-v\");\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"public String toString() {\n        StringBuilder buf = new StringBuilder();\n        Formatter formatter = new Formatter(buf);\n        final StringBuilder formatBuf = new StringBuilder();\n        for(int length : columnLengths) {\n            formatBuf.append(\"%-\").append(length).append('s');\n        }\n        final String format = formatBuf.toString();\n        formatter.format(format, header);\n        for(Object[] line : lines) {\n            buf.append('\\n');\n            formatter.format(format, line);\n        }\n        return buf.toString();\n    }","id":51163,"modified_method":"public String toString() {\n        return toString(false);\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void addLine(String[] line) {\n        if(line == null) {\n           throw new IllegalArgumentException(\"The line can't be null.\");\n        }\n        if(line.length != header.length) {\n            throw new IllegalArgumentException(\"Line length \" + line.length + \" doesn't match headers' length \" + header.length);\n        }\n\n        final String[] values = new String[line.length];\n        for(int i = 0; i < line.length; ++i) {\n            String value = line[i];\n            if(value == null) {\n                value = \"null\";\n            }\n            values[i] = value;\n            if(columnLengths[i] < value.length() + 1) {\n                columnLengths[i] = value.length() + 1;\n            }\n        }\n        lines.add(values);\n    }","id":51164,"modified_method":"public void addLine(String[] line) {\n        if(line == null) {\n           throw new IllegalArgumentException(\"The line can't be null.\");\n        }\n        if(line.length != columnLengths.length) {\n            throw new IllegalArgumentException(\"Line length \" + line.length + \" doesn't match headers' length \" + header.length);\n        }\n\n        final String[] values = new String[line.length];\n        for(int i = 0; i < line.length; ++i) {\n            String value = line[i];\n            if(value == null) {\n                value = \"null\";\n            }\n            values[i] = value;\n            if(columnLengths[i] < value.length() + 1) {\n                columnLengths[i] = value.length() + 1;\n            }\n        }\n        lines.add(values);\n    }","commit_id":"319947d4be22925f3580930787dfeeccedea27ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void mergeWith(@NotNull final HgRepository repository,\n                               @NotNull String branchName,\n                               @NotNull final UpdatedFiles updatedFiles) {\n    final Project project = repository.getProject();\n    final HgMergeCommand hgMergeCommand = new HgMergeCommand(project, repository.getRoot());\n    hgMergeCommand.setRevision(branchName);//there is no difference between branch or revision or bookmark as parameter to merge,\n    // we need just a string\n    new Task.Backgroundable(project, \"Merging changes...\") {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          hgMergeCommand.merge();\n          new HgConflictResolver(project, updatedFiles).resolve(repository.getRoot());\n        }\n        catch (VcsException exception) {\n          if (exception.isWarning()) {\n            VcsNotifier.getInstance(project).notifyWarning(\"Warning during merge\", exception.getMessage());\n          }\n          else {\n            VcsNotifier.getInstance(project).notifyError(\"Exception during merge\", exception.getMessage());\n          }\n        }\n      }\n    }.queue();\n  }","id":51165,"modified_method":"public static void mergeWith(@NotNull final HgRepository repository,\n                               @NotNull final String branchName,\n                               @NotNull final UpdatedFiles updatedFiles) {\n    mergeWith(repository, branchName, updatedFiles, null);\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void initRepo(String repoRoot) {\n    cd(repoRoot);\n    hg(\"init\");\n    touch(\"file.txt\");\n    hg(\"add file.txt\");\n    hg(\"commit -m initial\");\n  }","id":51166,"modified_method":"public static void initRepo(String repoRoot) {\n    cd(repoRoot);\n    hg(\"init\");\n    touch(\"file.txt\");\n    hg(\"add file.txt\");\n    hg(\"commit -m initial\");\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void executeOnPooledThreadIfNeeded(Runnable runnable) {\n    if (EventQueue.isDispatchThread()) {\n      ApplicationManager.getApplication().executeOnPooledThread(runnable);\n    } else {\n      runnable.run();\n    }\n  }","id":51167,"modified_method":"public static void executeOnPooledThreadIfNeeded(Runnable runnable) {\n    if (EventQueue.isDispatchThread() && !ApplicationManager.getApplication().isUnitTestMode()) {\n      ApplicationManager.getApplication().executeOnPooledThread(runnable);\n    } else {\n      runnable.run();\n    }\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GitRepository initRepository(String name) {\n    String tempDirectory = FileUtil.getTempDirectory();\n    String root = tempDirectory + \"/\"  + name;\n    assertTrue(new File(root).mkdirs());\n    GitRepository repository = GitTestUtil.createRepository(getProject(), root);\n    GitBranchesCollection branches = repository.getBranches();\n    assertEquals(1, branches.getLocalBranches().size());\n    return repository;\n  }","id":51168,"modified_method":"@NotNull\n  protected abstract Repository initRepository(@NotNull String name);","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCleanupRemovedBranch() {\n    GitRepository repository = initRepository(\"foo\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    assertNotNull(defaultTask);\n    assertEquals(0, defaultTask.getBranches().size());\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    assertEquals(2, localTask.getBranches().size());\n    assertEquals(1, defaultTask.getBranches().size());\n\n    // let's add non-existing branch\n    BranchInfo info = new BranchInfo();\n    info.name = \"non-existing\";\n    info.repository = defaultTask.getBranches().get(0).repository;\n    defaultTask.addBranch(info);\n\n    assertEquals(\"foo\", repository.getCurrentBranch().getName());\n    myTaskManager.activateTask(defaultTask, false);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n    // do not re-create \"non-existing\"\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","id":51169,"modified_method":"public void testCleanupRemovedBranch() throws InterruptedException {\n    Repository repository = initRepository(\"foo\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    assertNotNull(defaultTask);\n    assertEquals(0, defaultTask.getBranches().size());\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    assertEquals(2, localTask.getBranches().size());\n    assertEquals(1, defaultTask.getBranches().size());\n\n    // let's add non-existing branch\n    BranchInfo info = new BranchInfo();\n    info.name = \"non-existing\";\n    info.repository = defaultTask.getBranches().get(0).repository;\n    defaultTask.addBranch(info);\n    assertEquals(\"foo\", repository.getCurrentBranchName());\n    myTaskManager.activateTask(defaultTask, false);\n    assertEquals(getDefaultBranchName(), repository.getCurrentBranchName());\n    // do not re-create \"non-existing\"\n    assertEquals(2, getNumberOfBranches(repository));\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTaskManager() throws Exception {\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    assertNotNull(defaultTask);\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n\n    assertEquals(4, localTask.getBranches().size());\n    assertEquals(2, localTask.getBranches(true).size());\n    assertEquals(2, localTask.getBranches(false).size());\n\n    assertEquals(2, defaultTask.getBranches().size());\n\n    myTaskManager.activateTask(defaultTask, false);\n\n    GitRepository repository = repositories.get(0);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    foo = myTaskManager.createLocalTask(\"foo\");\n    localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    assertEquals(\"foo\", repository.getCurrentBranch().getName());\n\n    myTaskManager.mergeBranch(localTask);\n    repository.update();\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n    assertEquals(1, repository.getBranches().getLocalBranches().size());\n\n    myTaskManager.activateTask(defaultTask, false);\n    myTaskManager.activateTask(foo, false);\n  }","id":51170,"modified_method":"public void testTaskManager() throws Exception {\n    List<Repository> repositories = initRepositories(\"community\", \"idea\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    assertNotNull(defaultTask);\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    String defaultBranchName = getDefaultBranchName();\n\n    assertEquals(4, localTask.getBranches().size());\n    assertEquals(2, localTask.getBranches(true).size());\n    assertEquals(2, localTask.getBranches(false).size());\n\n    assertEquals(2, defaultTask.getBranches().size());\n\n    myTaskManager.activateTask(defaultTask, false);\n\n    Repository repository = repositories.get(0);\n    assertEquals(defaultBranchName, repository.getCurrentBranchName());\n\n    foo = myTaskManager.createLocalTask(\"foo\");\n    localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    assertEquals(\"foo\", repository.getCurrentBranchName());\n    commitChanges(repository);\n\n    myTaskManager.mergeBranch(localTask);\n    assertEquals(defaultBranchName, repository.getCurrentBranchName());\n    assertEquals(1, getNumberOfBranches(repository));\n\n    myTaskManager.activateTask(defaultTask, false);\n    myTaskManager.activateTask(foo, false);\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCommit() throws Exception {\n    GitRepository repository = initRepository(\"foo\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    final LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n\n    VirtualFile root = repository.getRoot();\n    File file = new File(root.getPath(), \"foo.txt\");\n    assertTrue(file.createNewFile());\n    final VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(file);\n    GitFileUtils.addFiles(getProject(), root, virtualFile);\n    myDirtyScopeManager.fileDirty(virtualFile);\n    myChangeListManager.ensureUpToDate(false);\n    Change change = myChangeListManager.getChange(virtualFile);\n    assertNotNull(change);\n    ProjectLevelVcsManager.getInstance(getProject()).getAllActiveVcss()[0].getCheckinEnvironment()\n      .commit(Collections.singletonList(change), \"foo\");\n    myTaskManager.mergeBranch(localTask);\n\n    repository.update();\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n    assertEquals(1, repository.getBranches().getLocalBranches().size());\n  }","id":51171,"modified_method":"public void testCommit() throws Exception {\n    Repository repository = initRepository(\"foo\");\n    LocalTask defaultTask = myTaskManager.getActiveTask();\n    LocalTaskImpl foo = myTaskManager.createLocalTask(\"foo\");\n    final LocalTask localTask = myTaskManager.activateTask(foo, false);\n    myTaskManager.createBranch(localTask, defaultTask, myTaskManager.suggestBranchName(localTask));\n    commitChanges(repository);\n    myTaskManager.mergeBranch(localTask);\n\n    assertEquals(getDefaultBranchName(), repository.getCurrentBranchName());\n    assertEquals(1, getNumberOfBranches(repository));\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<GitRepository> initRepositories(String... names) {\n    return ContainerUtil.map(names, new Function<String, GitRepository>() {\n      @Override\n      public GitRepository fun(String s) {\n        return initRepository(s);\n      }\n    });\n  }","id":51172,"modified_method":"private List<Repository> initRepositories(String... names) {\n    return ContainerUtil.map(names, new Function<String, Repository>() {\n      @Override\n      public Repository fun(String s) {\n        return initRepository(s);\n      }\n    });\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGitTaskHandler() throws Exception {\n\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    GitRepository repository = repositories.get(0);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    VcsTaskHandler.TaskInfo defaultInfo = handler.getActiveTask();\n    final String first = \"first\";\n    VcsTaskHandler.TaskInfo firstInfo = handler.startNewTask(first);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(defaultInfo, null);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    final String second = \"second\";\n    VcsTaskHandler.TaskInfo secondInfo = handler.startNewTask(second);\n    assertEquals(3, repository.getBranches().getLocalBranches().size());\n    assertEquals(second, repository.getCurrentBranch().getName());\n\n    handler.closeTask(secondInfo, firstInfo);\n    repository.update();\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","id":51173,"modified_method":"public void testVcsTaskHandler() throws Exception {\n\n    List<Repository> repositories = initRepositories(\"community\", \"idea\");\n    Repository repository = repositories.get(0);\n    String defaultBranchName = getDefaultBranchName();\n    assertEquals(defaultBranchName, repository.getCurrentBranchName());\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    VcsTaskHandler.TaskInfo defaultInfo = handler.getActiveTask();\n    final String first = \"first\";\n    VcsTaskHandler.TaskInfo firstInfo = handler.startNewTask(first);\n    assertEquals(2, getNumberOfBranches(repository));\n    assertEquals(first, repository.getCurrentBranchName());\n\n    handler.switchToTask(defaultInfo, null);\n    assertEquals(defaultBranchName, repository.getCurrentBranchName());\n\n    final String second = \"second\";\n    VcsTaskHandler.TaskInfo secondInfo = handler.startNewTask(second);\n    assertEquals(3, getNumberOfBranches(repository));\n    assertEquals(second, repository.getCurrentBranchName());\n    handler.switchToTask(firstInfo, null);\n    commitChanges(repository);\n    handler.closeTask(secondInfo, firstInfo);\n    assertEquals(2, getNumberOfBranches(repository));\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testOpenTaskDialog() throws Exception {\n    initRepository(\"foo\");\n    LocalTaskImpl task = myTaskManager.createLocalTask(\"foo\");\n    OpenTaskDialog dialog = new OpenTaskDialog(getProject(), task);\n    Disposer.register(myTestRootDisposable, dialog.getDisposable());\n    dialog.createTask();\n    assertEquals(\"foo\", myTaskManager.getActiveTask().getSummary());\n    List<BranchInfo> branches = task.getBranches(true);\n    assertEquals(1, branches.size());\n    assertEquals(\"master\", branches.get(0).name);\n    branches = task.getBranches(false);\n    assertEquals(1, branches.size());\n    assertEquals(\"foo\", branches.get(0).name);\n  }","id":51174,"modified_method":"public void testOpenTaskDialog() throws Exception {\n    initRepository(\"foo\");\n    String defaultBranchName = getDefaultBranchName();\n    LocalTaskImpl task = myTaskManager.createLocalTask(\"foo\");\n    OpenTaskDialog dialog = new OpenTaskDialog(getProject(), task);\n    Disposer.register(myTestRootDisposable, dialog.getDisposable());\n    dialog.createTask();\n    assertEquals(\"foo\", myTaskManager.getActiveTask().getSummary());\n    List<BranchInfo> branches = task.getBranches(true);\n    assertEquals(1, branches.size());\n    assertEquals(defaultBranchName, branches.get(0).name);\n    branches = task.getBranches(false);\n    assertEquals(1, branches.size());\n    assertEquals(\"foo\", branches.get(0).name);\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myTaskManager = (TaskManagerImpl)TaskManager.getManager(getProject());\n    GitVcsSettings.getInstance(myProject).getAppSettings().setPathToGit(GitExecutor.PathHolder.GIT_EXECUTABLE);\n\n    myChangeListManager = (ChangeListManagerImpl)ChangeListManager.getInstance(getProject());\n    myChangeListManager.projectOpened();\n    myDirtyScopeManager = ((VcsDirtyScopeManagerImpl)VcsDirtyScopeManager.getInstance(getProject()));\n    myDirtyScopeManager.projectOpened();\n  }","id":51175,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myTaskManager = (TaskManagerImpl)TaskManager.getManager(getProject());\n    myChangeListManager = (ChangeListManagerImpl)ChangeListManager.getInstance(getProject());\n    myChangeListManager.projectOpened();\n    myDirtyScopeManager = ((VcsDirtyScopeManagerImpl)VcsDirtyScopeManager.getInstance(getProject()));\n    myDirtyScopeManager.projectOpened();\n  }","commit_id":"365f5e9ef9be96d6d4181d3227e238d6e92f6125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void invoke() {\n        CancellationOperation op = new CancellationOperation(uuid, interrupt);\n        InvocationBuilder builder = createInvocationBuilder(getServiceName(), op, target);\n        builder.setTryCount(CANCEL_TRY_COUNT).setTryPauseMillis(CANCEL_TRY_PAUSE_MILLIS);\n        InternalCompletableFuture future = builder.invoke();\n        boolean result = false;\n        try {\n            result = (Boolean) future.get();\n        } catch (InterruptedException e) {\n            ILogger logger = getClientEngine().getLogger(CancellationRequest.class);\n            logger.warning(e);\n        } catch (ExecutionException e) {\n            ILogger logger = getClientEngine().getLogger(CancellationRequest.class);\n            logger.warning(e);\n        }\n        getEndpoint().sendResponse(result, getCallId());\n    }","id":51176,"modified_method":"@Override\n    protected void invoke() {\n        CancellationOperation op = new CancellationOperation(uuid, interrupt);\n        InvocationBuilder builder = createInvocationBuilder(getServiceName(), op, target);\n        builder.setTryCount(CANCEL_TRY_COUNT).setTryPauseMillis(CANCEL_TRY_PAUSE_MILLIS);\n        InternalCompletableFuture future = builder.invoke();\n        boolean result = false;\n        try {\n            result = (Boolean) future.get();\n        } catch (InterruptedException e) {\n            logException(e);\n        } catch (ExecutionException e) {\n            logException(e);\n        }\n        getEndpoint().sendResponse(result, getCallId());\n    }","commit_id":"18d273936c6e3a87d41e36a60d4cc8953652930d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"final void process() {\n        beforeProcess();\n        final ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, getPartition())\n                .setReplicaIndex(getReplicaIndex()).setTryCount(TRY_COUNT)\n                .setCallback(new CallbackImpl(endpoint));\n        builder.invoke();\n    }","id":51177,"modified_method":"@Override\n    final void process() {\n        beforeProcess();\n        ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, getPartition())\n                .setReplicaIndex(getReplicaIndex())\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false)\n                .setCallback(new CallbackImpl(endpoint));\n        builder.invoke();\n    }","commit_id":"18d273936c6e3a87d41e36a60d4cc8953652930d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    final void process() throws Exception {\n        ClientEndpoint endpoint = getEndpoint();\n        OperationFactory operationFactory = createOperationFactory();\n        Collection<Address> targets = getTargets();\n        if (targets.isEmpty()) {\n            endpoint.sendResponse(reduce(new HashMap<Address, Object>()), getCallId());\n            return;\n        }\n\n        MultiTargetCallback callback = new MultiTargetCallback(targets);\n        for (Address target : targets) {\n            Operation op = operationFactory.createOperation();\n            op.setCallerUuid(endpoint.getUuid());\n            InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, target)\n                    .setTryCount(TRY_COUNT)\n                    .setCallback(new SingleTargetCallback(target, callback));\n            builder.invoke();\n        }\n    }","id":51178,"modified_method":"@Override\n    final void process() throws Exception {\n        ClientEndpoint endpoint = getEndpoint();\n        OperationFactory operationFactory = createOperationFactory();\n        Collection<Address> targets = getTargets();\n        if (targets.isEmpty()) {\n            endpoint.sendResponse(reduce(new HashMap<Address, Object>()), getCallId());\n            return;\n        }\n\n        MultiTargetCallback callback = new MultiTargetCallback(targets);\n        for (Address target : targets) {\n            Operation op = operationFactory.createOperation();\n            op.setCallerUuid(endpoint.getUuid());\n            InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, target)\n                    .setTryCount(TRY_COUNT)\n                    .setResultDeserialized(false)\n                    .setCallback(new SingleTargetCallback(target, callback));\n            builder.invoke();\n        }\n    }","commit_id":"21ba083821de07ccf877d80b1f710052bfcb21e4","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    final void process() throws Exception {\n        final ClientEndpoint endpoint = getEndpoint();\n        final Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        final InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, getTarget())\n                .setTryCount(TRY_COUNT)\n                .setCallback(new Callback<Object>() {\n                    public void notify(Object object) {\n                        endpoint.sendResponse(filter(object), getCallId());\n                    }\n                });\n        builder.invoke();\n    }","id":51179,"modified_method":"@Override\n    final void process() throws Exception {\n        final ClientEndpoint endpoint = getEndpoint();\n        final Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        final InvocationBuilder builder = clientEngine.createInvocationBuilder(getServiceName(), op, getTarget())\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false)\n                .setCallback(new Callback<Object>() {\n                    public void notify(Object object) {\n                        endpoint.sendResponse(filter(object), getCallId());\n                    }\n                });\n        builder.invoke();\n    }","commit_id":"21ba083821de07ccf877d80b1f710052bfcb21e4","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Id.Program getWorkflowId(Id.Namespace namespace, AdapterSpecification adapterSpec) {\n    ApplicationSpecification appSpec = store.getApplication(Id.Application.from(namespace, adapterSpec.getTemplate()));\n    Preconditions.checkNotNull(appSpec);\n    Preconditions.checkArgument(appSpec.getWorkflows().size() == 1);\n    String workflowName = Lists.newArrayList(appSpec.getWorkflows().keySet()).get(0);\n    return Id.Program.from(namespace.getId(), adapterSpec.getTemplate(), ProgramType.WORKFLOW, workflowName);\n  }","id":51180,"modified_method":"private Id.Program getWorkflowId(Id.Namespace namespace, AdapterSpecification adapterSpec) throws NotFoundException {\n    Id.Application appId = Id.Application.from(namespace, adapterSpec.getTemplate());\n    ApplicationSpecification appSpec = store.getApplication(appId);\n    try {\n      Preconditions.checkArgument(appSpec != null);\n      Preconditions.checkArgument(appSpec.getWorkflows().size() == 1);\n    } catch (IllegalArgumentException e) {\n      throw new NotFoundException(appId);\n    }\n    String workflowName = Iterables.getFirst(appSpec.getWorkflows().keySet(), null);\n    return Id.Program.from(namespace.getId(), adapterSpec.getTemplate(), ProgramType.WORKFLOW, workflowName);\n  }","commit_id":"a25078253a12cc0b2463130f09bd85519e416495","url":"https://github.com/caskdata/cdap"},{"original_method":"public AdapterSpecification createSpecification() {\n    ScheduleSpecification scheduleSpec = null;\n    if (programType == ProgramType.WORKFLOW) {\n      String workflowName = templateSpec.getWorkflows().values().iterator().next().getName();\n      scheduleSpec = new ScheduleSpecification(schedule, new ScheduleProgramInfo(\n        SchedulableProgramType.WORKFLOW, workflowName), runtimeArgs);\n    }\n\n    AdapterSpecification.Builder builder =\n      AdapterSpecification.builder(adapterName, adapterConfig.getTemplate())\n        .setDescription(adapterConfig.getDescription())\n        .setConfig(adapterConfig.getConfig())\n        .setDatasets(dataSetInstances)\n        .setDatasetModules(dataSetModules)\n        .setStreams(streams)\n        .setRuntimeArgs(runtimeArgs)\n        .setScheduleSpec(scheduleSpec)\n        .setInstances(instances);\n    return builder.build();\n  }","id":51181,"modified_method":"public AdapterSpecification createSpecification() {\n    ScheduleSpecification scheduleSpec = null;\n    if (programType == ProgramType.WORKFLOW) {\n      String workflowName = Iterables.getFirst(templateSpec.getWorkflows().keySet(), null);\n      scheduleSpec = new ScheduleSpecification(schedule, new ScheduleProgramInfo(\n        SchedulableProgramType.WORKFLOW, workflowName), runtimeArgs);\n    }\n\n    AdapterSpecification.Builder builder =\n      AdapterSpecification.builder(adapterName, adapterConfig.getTemplate())\n        .setDescription(adapterConfig.getDescription())\n        .setConfig(adapterConfig.getConfig())\n        .setDatasets(dataSetInstances)\n        .setDatasetModules(dataSetModules)\n        .setStreams(streams)\n        .setRuntimeArgs(runtimeArgs)\n        .setScheduleSpec(scheduleSpec)\n        .setInstances(instances);\n    return builder.build();\n  }","commit_id":"a25078253a12cc0b2463130f09bd85519e416495","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @return An instance of {@link com.continuuity.app.queue.QueueSpecification} containing the URI for the queue\n   * and the matching {@link com.continuuity.api.io.Schema}\n   */\n  protected QueueSpecification createSpec(final URI uri, final Schema schema) {\n    return new QueueSpecification() {\n      @Override\n      public QueueName getQueueName() {\n        return QueueName.from(uri);\n      }\n\n      @Override\n      public Schema getSchemas() {\n        return schema;\n      }\n    };\n  }","id":51182,"modified_method":"/**\n   * @return An instance of {@link QueueSpecification} containing the URI for the queue\n   * and the matching {@link Schema}\n   */\n  protected QueueSpecification createSpec(final QueueName queueName, final Schema inputSchema, final Schema outputSchema) {\n    return new QueueSpecification() {\n      @Override\n      public QueueName getQueueName() {\n        return queueName;\n      }\n\n      @Override\n      public Schema getInputSchema() {\n        return inputSchema;\n      }\n\n      @Override\n      public Schema getOutputSchema() {\n        return outputSchema;\n      }\n\n      @Override\n      public int hashCode() {\n        return Objects.hashCode(getQueueName(), getInputSchema(), getOutputSchema());\n      }\n\n      @Override\n      public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof QueueSpecification)) {\n          return false;\n        }\n        QueueSpecification other = (QueueSpecification)obj;\n        return Objects.equal(getQueueName(), other.getQueueName())\n                && Objects.equal(getInputSchema(), other.getInputSchema())\n                && Objects.equal(getOutputSchema(), other.getOutputSchema());\n      }\n    };\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Generates an URI for the stream.\n   *\n   * @param account The stream belongs to\n   * @param stream  connected to flow\n   * @return An {@link URI} with schema as stream\n   */\n  protected URI streamURI(Id.Account account, String stream) {\n    try {\n      URI uri = new URI(\"stream\", Joiner.on(\"/\").join(new Object[]{ \"/\", account.getId(), stream }), null);\n      return uri;\n    } catch(Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":51183,"modified_method":"/**\n   * Generates an QueueName for the stream.\n   *\n   * @param account The stream belongs to\n   * @param stream  connected to flow\n   * @return An {@link QueueName} with schema as stream\n   */\n  protected QueueName queueNameFromStream(Id.Account account, String stream) {\n    URI uri = URI.create(Joiner.on(\"/\").join(\"stream:\", \"\", account.getId(), stream));\n    return QueueName.from(uri);\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * This method verifies output schema of a flowlets is compatible with the input schema of downstream\n   * flowlet.Following is how this is done\n   * <p>\n   * Assume that we have a flowlet X and flowlet Y and X is connected to Y as per the definitions in\n   * connection. Following have to be true to say that flowlet X is safely connected to Y\n   * <ul>\n   * <li>For each output emitter type of X, there is atleast one input on Y that can accept and process data\n   * (including ANY)<\/li>\n   * <li>Schema's of the output emitter type of X that matches output type of Y have to be compatible<\/li>\n   * <li><\/li>\n   * <\/ul>\n   * <\/p>\n   *\n   * @param source flowlet definition\n   * @param target flowlet definition\n   * @return An instance of {@link VerifyResult}\n   */\n  private VerifyResult connectionVerification(FlowletDefinition source, FlowletDefinition target) {\n    Map<String, Set<Schema>> output = source.getOutputs();\n    Map<String, Set<Schema>> input = target.getInputs();\n\n    boolean found = false;\n    for(Map.Entry<String, Set<Schema>> entryOutput : output.entrySet()) {\n      String outputName = entryOutput.getKey();\n\n      // Check also caught in the configure during creation phase.\n      // We restrict number of schema's an output can have.\n      if(entryOutput.getValue().size() > 1) {\n        return VerifyResult.FAILURE(Err.Flow.MORE_OUTPUT_NOT_ALLOWED, entryOutput.getKey(),\n                                    source.getFlowletSpec().getName());\n      }\n\n      for(Map.Entry<String, Set<Schema>> entryInput : input.entrySet()) {\n        String inputName = entryInput.getKey();\n\n        // When the output name is same as input name - we check if their schema's\n        // are same (equal or compatible)\n        if(outputName.equals(inputName)) {\n          found = SchemaFinder.checkSchema(entryOutput.getValue(), entryInput.getValue());\n          Schema c = SchemaFinder.findSchema(entryOutput.getValue(), entryInput.getValue());\n        }\n\n        // If not found there, we do a small optimization where we check directly if\n        // the output matches the schema of ANY_INPUT schema. If it doesn't then we\n        // have an issue else we are good.\n        if(! found && input.containsKey(FlowletDefinition.ANY_INPUT)) {\n          found = SchemaFinder.checkSchema(entryOutput.getValue(), input.get(FlowletDefinition.ANY_INPUT));\n        }\n        // If we found a schema that matches then we are good.\n        if(found){\n          return VerifyResult.SUCCESS();\n        }\n      }\n    }\n    return VerifyResult.FAILURE(\n      Err.Flow.NO_INPUT_FOR_OUTPUT, target.getFlowletSpec().getName(), source.getFlowletSpec().getName());\n  }","id":51184,"modified_method":"/**\n   * This method verifies output schema of a flowlets is compatible with the input schema of downstream\n   * flowlet.Following is how this is done\n   * <p>\n   * Assume that we have a flowlet X and flowlet Y and X is connected to Y as per the definitions in\n   * connection. Following have to be true to say that flowlet X is safely connected to Y\n   * <ul>\n   * <li>For each output emitter type of X, there is atleast one input on Y that can accept and process data\n   * (including ANY)<\/li>\n   * <li>Schema's of the output emitter type of X that matches output type of Y have to be compatible<\/li>\n   * <li><\/li>\n   * <\/ul>\n   * <\/p>\n   *\n   * @param source flowlet definition\n   * @param target flowlet definition\n   * @return An instance of {@link VerifyResult}\n   */\n  private VerifyResult connectionVerification(FlowletDefinition source, FlowletDefinition target) {\n    Map<String, Set<Schema>> output = source.getOutputs();\n    Map<String, Set<Schema>> input = target.getInputs();\n\n    boolean found = false;\n    for(Map.Entry<String, Set<Schema>> entryOutput : output.entrySet()) {\n      String outputName = entryOutput.getKey();\n\n      // Check also caught in the configure during creation phase.\n      // We restrict number of schema's an output can have.\n      if(entryOutput.getValue().size() > 1) {\n        return VerifyResult.FAILURE(Err.Flow.MORE_OUTPUT_NOT_ALLOWED, entryOutput.getKey(),\n                                    source.getFlowletSpec().getName());\n      }\n\n      for(Map.Entry<String, Set<Schema>> entryInput : input.entrySet()) {\n        String inputName = entryInput.getKey();\n\n        // When the output name is same as input name - we check if their schema's\n        // are same (equal or compatible)\n        if(outputName.equals(inputName)) {\n          found = SchemaFinder.checkSchema(entryOutput.getValue(), entryInput.getValue());\n          ImmutablePair<Schema, Schema> c = SchemaFinder.findSchema(entryOutput.getValue(), entryInput.getValue());\n        }\n\n        // If not found there, we do a small optimization where we check directly if\n        // the output matches the schema of ANY_INPUT schema. If it doesn't then we\n        // have an issue else we are good.\n        if(! found && input.containsKey(FlowletDefinition.ANY_INPUT)) {\n          found = SchemaFinder.checkSchema(entryOutput.getValue(), input.get(FlowletDefinition.ANY_INPUT));\n        }\n        // If we found a schema that matches then we are good.\n        if(found){\n          return VerifyResult.SUCCESS();\n        }\n      }\n    }\n    return VerifyResult.FAILURE(\n      Err.Flow.NO_INPUT_FOR_OUTPUT, target.getFlowletSpec().getName(), source.getFlowletSpec().getName());\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * This method is responsible for inspecting the flowlet class and inspecting to figure out what\n   * method are used for processing input and what are used for emitting outputs.\n   * @param flowletClass defining the flowlet that needs to be inspected.\n   * @param datasets reference to set of datasets names.\n   * @param inputs reference to map of name to input types used for processing events on queues.\n   * @param outputs reference to map of name to {@link OutputEmitter} and the types they handle.\n   */\n  private void inspectFlowlet(Class<?> flowletClass,\n                              Set<String> datasets,\n                              Map<String, Set<Type>> inputs,\n                              Map<String, Set<Type>> outputs) throws UnsupportedTypeException {\n    TypeToken<?> flowletType = TypeToken.of(flowletClass);\n\n    // Walk up the hierarchy of flowlet class.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n\n      // Grab all the DataSet and OutputEmitter fields\n      for (Field field : type.getRawType().getDeclaredFields()) {\n        if (DataSet.class.isAssignableFrom(field.getType())) {\n          UseDataSet dataset = field.getAnnotation(UseDataSet.class);\n          if (dataset == null || dataset.value().isEmpty()) {\n            continue;\n          }\n          datasets.add(dataset.value());\n\n        } else if (OutputEmitter.class.equals(field.getType())) {\n          Type emitterType = field.getGenericType();\n          Preconditions.checkArgument(emitterType instanceof ParameterizedType,\n                                      \"Type info missing from OutputEmitter; class: %s; field: %s.\", type, field);\n\n          // Extract the Output type from the first type argument of OutputEmitter\n          Type outputType = ((ParameterizedType) emitterType).getActualTypeArguments()[0];\n          String outputName = field.isAnnotationPresent(Output.class) ?\n                                  field.getAnnotation(Output.class).value() : DEFAULT_OUTPUT;\n\n          Set<Type> types = outputs.get(outputName);\n          if (types == null) {\n            types = Sets.newHashSet();\n            outputs.put(outputName, types);\n          }\n          types.add(outputType);\n        }\n      }\n\n      // Grab all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        // There should be no process method on GeneratorFlowlet\n        if (GeneratorFlowlet.class.isAssignableFrom(type.getRawType())) {\n          continue;\n        }\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        Type[] methodParams = method.getGenericParameterTypes();\n        Preconditions.checkArgument(methodParams.length > 0 && methodParams.length <= 2,\n                                    \"Type parameter missing from process method; class: %s, method: %s\",\n                                    type, method);\n\n        // If there are more than one parameter, there be exactly two and the 2nd one should be InputContext\n        if (methodParams.length == 2) {\n          Preconditions.checkArgument(InputContext.class.equals(TypeToken.of(methodParams[1]).getRawType()),\n                                      \"The second parameter of the process method must be %s type.\",\n                                      InputContext.class.getName());\n        }\n\n        // Extract the Input type from the first parameter of the process method\n        Type inputType = type.resolveType(methodParams[0]).getType();\n\n        List<String> inputNames = Lists.newLinkedList();\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames.add(ANY_INPUT);\n        } else {\n          Collections.addAll(inputNames, processAnnotation.value());\n        }\n\n        for (String inputName : inputNames) {\n          Set<Type> types = inputs.get(inputName);\n          if (types == null) {\n            types = Sets.newHashSet();\n            inputs.put(inputName, types);\n          }\n          Preconditions.checkArgument(!types.contains(inputType),\n                                      \"Same type already defined for the same input. Type: %s, input: %s\",\n                                      inputType, inputName);\n          types.add(inputType);\n        }\n      }\n    }\n  }","id":51185,"modified_method":"/**\n   * This method is responsible for inspecting the flowlet class and inspecting to figure out what\n   * method are used for processing input and what are used for emitting outputs.\n   * @param flowletClass defining the flowlet that needs to be inspected.\n   * @param datasets reference to set of datasets names.\n   * @param inputs reference to map of name to input types used for processing events on queues.\n   * @param outputs reference to map of name to {@link OutputEmitter} and the types they handle.\n   */\n  private void inspectFlowlet(Class<?> flowletClass,\n                              Set<String> datasets,\n                              Map<String, Set<Type>> inputs,\n                              Map<String, Set<Type>> outputs) throws UnsupportedTypeException {\n    TypeToken<?> flowletType = TypeToken.of(flowletClass);\n\n    // Walk up the hierarchy of flowlet class.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n\n      // Grab all the DataSet and OutputEmitter fields\n      for (Field field : type.getRawType().getDeclaredFields()) {\n        if (DataSet.class.isAssignableFrom(field.getType())) {\n          UseDataSet dataset = field.getAnnotation(UseDataSet.class);\n          if (dataset == null || dataset.value().isEmpty()) {\n            continue;\n          }\n          datasets.add(dataset.value());\n\n        } else if (OutputEmitter.class.equals(field.getType())) {\n          Type emitterType = field.getGenericType();\n          Preconditions.checkArgument(emitterType instanceof ParameterizedType,\n                                      \"Type info missing from OutputEmitter; class: %s; field: %s.\", type, field);\n\n          // Extract the Output type from the first type argument of OutputEmitter\n          Type outputType = ((ParameterizedType) emitterType).getActualTypeArguments()[0];\n          String outputName = field.isAnnotationPresent(Output.class) ?\n                                  field.getAnnotation(Output.class).value() : DEFAULT_OUTPUT;\n\n          Set<Type> types = outputs.get(outputName);\n          if (types == null) {\n            types = Sets.newHashSet();\n            outputs.put(outputName, types);\n          }\n          Preconditions.checkArgument(types.add(outputType),\n                                      \"Same output name cannot have same type; class: %s, field: %s\", type, field);\n        }\n      }\n\n      // Grab all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        // There should be no process method on GeneratorFlowlet\n        if (GeneratorFlowlet.class.isAssignableFrom(type.getRawType())) {\n          continue;\n        }\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        Type[] methodParams = method.getGenericParameterTypes();\n        Preconditions.checkArgument(methodParams.length > 0 && methodParams.length <= 2,\n                                    \"Type parameter missing from process method; class: %s, method: %s\",\n                                    type, method);\n\n        // If there are more than one parameter, there be exactly two and the 2nd one should be InputContext\n        if (methodParams.length == 2) {\n          Preconditions.checkArgument(InputContext.class.equals(TypeToken.of(methodParams[1]).getRawType()),\n                                      \"The second parameter of the process method must be %s type.\",\n                                      InputContext.class.getName());\n        }\n\n        // Extract the Input type from the first parameter of the process method\n        Type inputType = type.resolveType(methodParams[0]).getType();\n\n        List<String> inputNames = Lists.newLinkedList();\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames.add(ANY_INPUT);\n        } else {\n          Collections.addAll(inputNames, processAnnotation.value());\n        }\n\n        for (String inputName : inputNames) {\n          Set<Type> types = inputs.get(inputName);\n          if (types == null) {\n            types = Sets.newHashSet();\n            inputs.put(inputName, types);\n          }\n          Preconditions.checkArgument(types.add(inputType),\n                                      \"Same type already defined for the same input. Type: %s, input: %s\",\n                                      inputType, inputName);\n        }\n      }\n    }\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"public FlowletProgramRunner(OperationExecutor opex, OperationContext opCtx) {\n    this.opex = opex;\n    this.opCtx = opCtx;\n  }","id":51186,"modified_method":"@Inject\n  public FlowletProgramRunner(OperationExecutor opex) {\n    this.opex = opex;\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"private FlowletProcessDriver instantiateFlowlet(FlowSpecification flowSpec, FlowletDefinition flowletDef,\n                                                  String flowletName,\n                                                  Class<? extends Flowlet> flowletClass,\n                                                  DataSetContext dataSetCtx,\n                                                  TransactionAgentSupplier txAgentSupplier) throws Exception {\n\n    TypeToken<? extends Flowlet> flowletType = TypeToken.of(flowletClass);\n    Flowlet flowlet = flowletClass.newInstance();\n    List<OutputEmitter<?>> outputEmitters = Lists.newArrayList();\n\n    // Walk up the hierarchy of flowlet class.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n\n      // Inject DataSet and Emitter fields\n      for (Field field : type.getRawType().getDeclaredFields()) {\n        // Inject DataSet\n        if (DataSet.class.isAssignableFrom(field.getType())) {\n          UseDataSet dataset = field.getAnnotation(UseDataSet.class);\n          if (dataset == null || dataset.value().isEmpty()) {\n            continue;\n          }\n          if (!field.isAccessible()) {\n            field.setAccessible(true);\n          }\n          field.set(flowlet, dataSetCtx.getDataSet(dataset.value()));\n          continue;\n        }\n        // Inject OutputEmitter\n        if (OutputEmitter.class.equals(field.getType())) {\n          TypeToken<?> outputType = TypeToken.of(((ParameterizedType)field.getGenericType())\n                                                   .getActualTypeArguments()[0]);\n          String outputName = field.isAnnotationPresent(Output.class) ?\n                    field.getAnnotation(Output.class).value() : FlowletDefinition.DEFAULT_OUTPUT;\n\n          // TODO: Lookup queue name by output name\n          // TODO: Find way to create QueueProducer\n\n//          TransactionOutputEmitter<?> outputEmitter =\n//            new ReflectionOutputEmitter(new QueueProducer(), queueName, flowletDef.getOutputs().get(outputName).iterator().next());\n//          if (!field.isAccessible()) {\n//            field.setAccessible(true);\n//          }\n//          field.set(flowlet, outputEmitter);\n//          outputEmitters.add(outputEmitter);\n        }\n      }\n\n      // Extracts all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(FlowletDefinition.PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        List<String> inputNames;\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames = ImmutableList.of(FlowletDefinition.ANY_INPUT);\n        } else {\n          inputNames = ImmutableList.copyOf(processAnnotation.value());\n        }\n\n        // TODO: Find out the queue name by input name\n        // TODO: Create method invoker\n\n      }\n    }\n    return null;\n  }","id":51187,"modified_method":"private FlowletProcessDriver instantiateFlowlet(Class<? extends Flowlet> flowletClass,\n                                                  FlowletContext flowletContext,\n                                                  OutputEmitterFactory outputEmitterFactory,\n                                                  SchemaCache schemaCache,\n                                                  FlowletDefinition flowletDef,\n                                                  FlowSpecification flowSpec,\n                                                  String flowletName,\n                                                  TransactionAgentSupplier txAgentSupplier) throws Exception {\n\n    TypeToken<? extends Flowlet> flowletType = TypeToken.of(flowletClass);\n    Flowlet flowlet = flowletClass.newInstance();\n    ImmutableList.Builder<OutputSubmitter> outputSubmitters = ImmutableList.builder();\n\n    // Walk up the hierarchy of flowlet class.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n\n      // Inject DataSet and Emitter fields\n      for (Field field : type.getRawType().getDeclaredFields()) {\n        // Inject DataSet\n        if (DataSet.class.isAssignableFrom(field.getType())) {\n          UseDataSet dataset = field.getAnnotation(UseDataSet.class);\n          if (dataset != null && !dataset.value().isEmpty()) {\n            setField(flowlet, field, flowletContext.getDataSet(dataset.value()));\n          }\n          continue;\n        }\n        // Inject OutputEmitter\n        if (OutputEmitter.class.equals(field.getType())) {\n          TypeToken<?> outputType = TypeToken.of(((ParameterizedType)field.getGenericType())\n                                                   .getActualTypeArguments()[0]);\n          String outputName = field.isAnnotationPresent(Output.class) ?\n                    field.getAnnotation(Output.class).value() : FlowletDefinition.DEFAULT_OUTPUT;\n\n          OutputEmitter<?> outputEmitter = outputEmitterFactory.create(outputType);\n          setField(flowlet, field, outputEmitter);\n          if (outputEmitter instanceof OutputSubmitter) {\n            outputSubmitters.add((OutputSubmitter)outputEmitter);\n          }\n        }\n      }\n    }\n\n    OutputSubmitter outputSubmitter = new MultiOutputSubmitter(outputSubmitters.build());\n\n    // Walk up the hierarchy of flowlet class again to get all process methods\n    // It needs to be traverse twice because process method needs to know all output emitters.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n      // Extracts all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(FlowletDefinition.PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        List<String> inputNames;\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames = ImmutableList.of(FlowletDefinition.ANY_INPUT);\n        } else {\n          inputNames = ImmutableList.copyOf(processAnnotation.value());\n        }\n\n        // TODO: Find out the queue name by input name\n        // TODO: Create method invoker\n\n      }\n    }\n    return null;\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Controller run(Program program, ProgramOptions options) {\n    try {\n      Preconditions.checkArgument(program.getProcessorType() == Type.FLOW, \"Supported process type\");\n\n      String flowletName = options.getName();\n\n      ApplicationSpecification appSpec = program.getSpecification();\n      Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n      Type processorType = program.getProcessorType();\n      Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n      Preconditions.checkArgument(processorType == Type.FLOW, \"Only FLOW process type is supported.\");\n\n      String processorName = program.getProgramName();\n      Preconditions.checkNotNull(processorName, \"Missing processor name.\");\n\n      FlowSpecification flowSpec = appSpec.getFlows().get(processorName);\n      FlowletDefinition flowletDef = flowSpec.getFlowlets().get(flowletName);\n\n      Preconditions.checkNotNull(flowletDef, \"Definition missing for flowlet \\\"%s\\\"\", flowletName);\n      ClassLoader classLoader = program.getMainClass().getClassLoader();\n      Class<? extends Flowlet> flowletClass = (Class<? extends Flowlet>)\n                                                  Class.forName(flowletDef.getFlowletSpec().getClassName(),\n                                                                true, classLoader);\n\n      Preconditions.checkArgument(Flowlet.class.isAssignableFrom(flowletClass), \"%s is not a Flowlet.\", flowletClass);\n\n      TransactionProxy transactionProxy = new TransactionProxy();\n      TransactionAgentSupplier txAgentSupplier = new SmartTransactionAgentSupplier(opex, opCtx, transactionProxy);\n      DataFabric dataFabric = new DataFabricImpl(opex, opCtx);\n      DataSetContext dataSetCtxr = new DataSetInstantiator(dataFabric, transactionProxy, classLoader);\n\n      final FlowletProcessDriver driver = instantiateFlowlet(flowSpec, flowletDef, flowletName,\n                                                       flowletClass, dataSetCtxr, txAgentSupplier);\n\n      driver.start();\n      return new Controller() {\n        @Override public void suspend() { driver.suspend(); }\n        @Override public void resume() { driver.resume(); }\n        @Override public void stop() { driver.stopAndWait(); }\n      };\n\n    } catch(Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":51188,"modified_method":"@Override\n  public Controller run(Program program, ProgramOptions options) {\n    try {\n      // Extract and verify parameters\n      Preconditions.checkArgument(program.getProcessorType() == Type.FLOW, \"Supported process type\");\n\n      String flowletName = options.getName();\n      int instanceId = Integer.parseInt(options.getArguments().getOption(\"instanceId\", \"-1\"));\n      Preconditions.checkArgument(instanceId >= 0, \"Missing instance Id\");\n\n      ApplicationSpecification appSpec = program.getSpecification();\n      Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n      Type processorType = program.getProcessorType();\n      Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n      Preconditions.checkArgument(processorType == Type.FLOW, \"Only FLOW process type is supported.\");\n\n      String processorName = program.getProgramName();\n      Preconditions.checkNotNull(processorName, \"Missing processor name.\");\n\n      FlowSpecification flowSpec = appSpec.getFlows().get(processorName);\n      FlowletDefinition flowletDef = flowSpec.getFlowlets().get(flowletName);\n\n      Preconditions.checkNotNull(flowletDef, \"Definition missing for flowlet \\\"%s\\\"\", flowletName);\n      ClassLoader classLoader = program.getMainClass().getClassLoader();\n      Class<? extends Flowlet> flowletClass = (Class<? extends Flowlet>)\n                                                  Class.forName(flowletDef.getFlowletSpec().getClassName(),\n                                                                true, classLoader);\n\n      Preconditions.checkArgument(Flowlet.class.isAssignableFrom(flowletClass), \"%s is not a Flowlet.\", flowletClass);\n\n      // Creates opex related objects\n      OperationContext opCtx = new OperationContext(program.getAccountId(), program.getApplicationId());\n      TransactionProxy transactionProxy = new TransactionProxy();\n      TransactionAgentSupplier txAgentSupplier = new SmartTransactionAgentSupplier(opex, opCtx, transactionProxy);\n      DataFabric dataFabric = new DataFabricImpl(opex, opCtx);\n      DataSetInstantiator dataSetInstantiator = new DataSetInstantiator(dataFabric, transactionProxy, classLoader);\n      dataSetInstantiator.setDataSets(ImmutableList.copyOf(appSpec.getDataSets().values()));\n\n      // Creates flowlet context\n      BasicFlowletContext flowletContext = new BasicFlowletContext(program, flowletName, instanceId,\n                                                                   createDataSets(dataSetInstantiator, flowletDef));\n\n      // Creates QueueSpecification\n//      Table<String,String,Set<QueueSpecification>> queueSpecs =\n//        new SimpleQueueSpecificationGenerator(Id.Account.from(program.getAccountId()))\n//            .create(flowSpec);\n//\n//      final FlowletProcessDriver driver = instantiateFlowlet(flowletClass,\n//                                                             flowletContext,\n//                                                             outputEmitterFactory(flowletContext.getQueueProducer(),\n//                                                                                  queueSpecs));\n\n//      driver.start();\n//      return new Controller() {\n//        @Override public void suspend() { driver.suspend(); }\n//        @Override public void resume() { driver.resume(); }\n//        @Override public void stop() { driver.stopAndWait(); }\n//      };\n      return null;\n\n    } catch(Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Finds the right schema to be used for the connections.\n   * <p>\n   *   A connection should have the following:\n   *   <ul>\n   *     <li>Equal overrides compatible : So if there is equal, we use that<\/li>\n   *     <li>In case of compatible, we try to find one schema and only one. More than one is a error.<\/li>\n   *   <\/ul>\n   * <\/p>\n   * @param output\n   * @param input\n   * @return\n   */\n  @Nullable\n  public static Schema findSchema(Set<Schema> output, Set<Schema> input) {\n    Schema compatibleSchema = null;\n    int compatible = 0;\n\n    for(Schema outputSchema : output) {\n      for(Schema inputSchema : input) {\n        if(outputSchema.equals(inputSchema)) {\n          return inputSchema;\n        }\n\n        if(outputSchema.isCompatible(inputSchema)) {\n          compatibleSchema = inputSchema;\n          compatible++;\n        }\n      }\n    }\n\n    // If there are more than one compatible, then it's a problem\n    // we should have only strictly one.\n    if(compatible == 1) {\n      return compatibleSchema;\n    }\n\n    return null;\n  }","id":51189,"modified_method":"/**\n   * Finds the right schema to be used for the connections.\n   * <p>\n   *   A connection should have the following:\n   *   <ul>\n   *     <li>Equal overrides compatible : So if there is equal, we use that<\/li>\n   *     <li>In case of compatible, we try to find one schema and only one. More than one is a error.<\/li>\n   *   <\/ul>\n   * <\/p>\n   * @param output\n   * @param input\n   * @return An {@link ImmutablePair} with first as input schema and second as output schema.\n   */\n  @Nullable\n  public static ImmutablePair<Schema, Schema> findSchema(Set<Schema> output, Set<Schema> input) {\n    ImmutablePair<Schema, Schema> compatibleSchema = null;\n    int compatible = 0;\n\n    for(Schema outputSchema : output) {\n      for(Schema inputSchema : input) {\n        if(outputSchema.equals(inputSchema)) {\n          return new ImmutablePair<Schema, Schema>(inputSchema, outputSchema);\n        }\n\n        if (outputSchema.isCompatible(inputSchema)) {\n          compatible++;\n\n          // If there are more than one compatible, then it's a problem\n          // we should have only strictly one.\n          if (compatible > 1) {\n            return null;\n          }\n          compatibleSchema = new ImmutablePair<Schema, Schema>(inputSchema, outputSchema);\n        }\n      }\n    }\n\n    return compatibleSchema;\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Given a {@link FlowSpecification}\n   *\n   * @param input {@link FlowSpecification}\n   * @return A {@link Table}\n   */\n  @Override\n  public Table<Node, String, Set<QueueSpecification>> create(FlowSpecification input) {\n    Table<Node, String, Set<QueueSpecification>> table = HashBasedTable.create();\n\n    String flow = input.getName();\n    Map<String, FlowletDefinition> flowlets = input.getFlowlets();\n\n    // Iterate through connections of a flow.\n    for(FlowletConnection connection : input.getConnections()) {\n      final String source = connection.getSourceName();\n      final String target = connection.getTargetName();\n      final Node sourceNode = new Node(connection.getSourceType(), source);\n\n      // If the source type is a flowlet, then we attempt to find a matching\n      // connection that is equal or compatible. Equality has higher priority\n      // over compatibility.\n      if(connection.getSourceType() == FlowletConnection.Type.FLOWLET) {\n        List<SchemaURIHolder> holders = findSchema(flow, flowlets.get(source), flowlets.get(target));\n        for(SchemaURIHolder holder : holders) {\n          if(table.contains(sourceNode, target)) {\n            table.get(sourceNode, target).add(createSpec(holder.getOutput(), holder.getSchema()));\n          } else {\n            table.put(sourceNode, target, Sets.newHashSet(createSpec(holder.getOutput(), holder.getSchema())));\n          }\n        }\n      }\n\n      // Connection is a Stream.\n      if(connection.getSourceType() == FlowletConnection.Type.STREAM) {\n        try {\n          // Create schema for StreamEvent and compare that with the inputs of the flowlet.\n          final Schema schema = (new ReflectionSchemaGenerator()).generate((new TypeToken<StreamEvent>() {}).getType                                                                                                     ());\n          Schema foundSchema = null;\n          for(Map.Entry<String, Set<Schema>> entry : flowlets.get(target).getInputs().entrySet()) {\n            foundSchema = SchemaFinder.findSchema(ImmutableSet.of(schema), entry.getValue());\n            if(foundSchema != null) {\n              break;\n            }\n          }\n\n          if(foundSchema != null) {\n            if(table.contains(sourceNode, target)) {\n              table.get(sourceNode, target).add(createSpec(streamURI(account, source), foundSchema));\n            } else {\n              table.put(sourceNode, target,Sets.newHashSet(createSpec(streamURI(account, source), foundSchema)));\n            }\n          } else {\n            throw new RuntimeException(\"Unable to find matching schema for connection between \"\n                                        + source + \" and %s \" + target);\n          }\n        } catch(UnsupportedTypeException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    }\n    return table;\n  }","id":51190,"modified_method":"/**\n   * Given a {@link FlowSpecification}\n   *\n   * @param input {@link FlowSpecification}\n   * @return A {@link Table}\n   */\n  @Override\n  public Table<Node, String, Set<QueueSpecification>> create(FlowSpecification input) {\n    Table<Node, String, Set<QueueSpecification>> table = HashBasedTable.create();\n\n    String flow = input.getName();\n    Map<String, FlowletDefinition> flowlets = input.getFlowlets();\n\n    // Iterate through connections of a flow.\n    for(FlowletConnection connection : input.getConnections()) {\n      final String source = connection.getSourceName();\n      final String target = connection.getTargetName();\n      final Node sourceNode = new Node(connection.getSourceType(), source);\n\n      Set<QueueSpecification> queueSpec;\n      if (connection.getSourceType() == FlowletConnection.Type.FLOWLET) {\n        queueSpec = generateQueueSpecification(account, flow, connection,\n                                               flowlets.get(target).getInputs(), flowlets.get(source).getOutputs());\n      } else {\n        queueSpec = generateQueueSpecification(account, flow, connection, flowlets.get(target).getInputs(),\n                                               ImmutableMap.<String, Set<Schema>>of(\n                                                  connection.getSourceName(), ImmutableSet.of(STREAM_EVENT_SCHEMA)));\n      }\n      Set<QueueSpecification> queueSpecifications = table.get(sourceNode, target);\n      if (queueSpecifications == null) {\n        queueSpecifications = Sets.newHashSet();\n        table.put(sourceNode, target, queueSpecifications);\n      }\n      queueSpecifications.addAll(queueSpec);\n    }\n    return table;\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueueSpecificationGenWithToyApp() throws Exception {\n    ApplicationSpecification appSpec = new ToyApp().configure();\n    ApplicationSpecificationAdapter adapter = ApplicationSpecificationAdapter.create(new ReflectionSchemaGenerator());\n    ApplicationSpecification newSpec = adapter.fromJson(adapter.toJson(appSpec));\n\n    QueueSpecificationGenerator generator = new SimpleQueueSpecificationGenerator(Id.Account.DEFAULT());\n    table = generator.create(newSpec.getFlows().values().iterator().next());\n\n    // Stream X\n    Assert.assertTrue(get(FlowletConnection.Type.STREAM, \"X\", \"A\")\n                        .iterator().next().getQueueName().toString().equals(\"stream://demo/X\"));\n\n    Assert.assertTrue(get(FlowletConnection.Type.STREAM, \"Y\", \"B\")\n                        .iterator().next().getQueueName().toString().equals(\"stream://demo/Y\"));\n\n    // Node A\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"A\", \"E\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/A/out1\"));\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"A\", \"C\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/A/out\"));\n\n    // Node B\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"B\", \"E\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/B/out\"));\n\n    // Node C\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"C\", \"D\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/C/c1\"));\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"C\", \"F\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/C/c2\"));\n\n    // Node D\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"D\", \"G\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/D/d1\"));\n\n    // Node E\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"E\", \"G\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/E/out\"));\n\n    // Node F\n    Assert.assertTrue(get(FlowletConnection.Type.FLOWLET, \"F\", \"G\")\n                        .iterator().next().getQueueName().toString().equals(\"queue://ToyFlow/F/f1\"));\n  }","id":51191,"modified_method":"@Test\n  public void testQueueSpecificationGenWithToyApp() throws Exception {\n    ApplicationSpecification appSpec = new ToyApp().configure();\n    ApplicationSpecificationAdapter adapter = ApplicationSpecificationAdapter.create(new ReflectionSchemaGenerator());\n    ApplicationSpecification newSpec = adapter.fromJson(adapter.toJson(appSpec));\n\n    QueueSpecificationGenerator generator = new SimpleQueueSpecificationGenerator(Id.Account.DEFAULT());\n    table = generator.create(newSpec.getFlows().values().iterator().next());\n\n    dumpConnectionQueue(table);\n\n    // Stream X\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.STREAM, \"X\", \"A\"), \"stream://demo/X\"));\n\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.STREAM, \"Y\", \"B\"), \"stream://demo/Y\"));\n\n    // Node A\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"A\", \"E\"), \"queue://ToyFlow/A/out1\"));\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"A\", \"C\"), \"queue://ToyFlow/A/out\"));\n\n    // Node B\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"B\", \"E\"), \"queue://ToyFlow/B/out\"));\n\n    // Node C\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"C\", \"D\"), \"queue://ToyFlow/C/c1\"));\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"C\", \"F\"), \"queue://ToyFlow/C/c2\"));\n\n    // Node D\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"D\", \"G\"), \"queue://ToyFlow/D/d1\"));\n\n    // Node E\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"E\", \"G\"), \"queue://ToyFlow/E/out\"));\n\n    // Node F\n    Assert.assertTrue(containsQueue(get(FlowletConnection.Type.FLOWLET, \"F\", \"G\"), \"queue://ToyFlow/F/f1\"));\n  }","commit_id":"90b76fc8b9855ffad0d453af526f7b4adaa8fa85","url":"https://github.com/caskdata/cdap"},{"original_method":"public Collection<LogEvent> readLogPrev(Location file, Filter logFilter, long fromTimeMs, final int maxEvents) {\n    FSDataInputStream inputStream = null;\n    DataFileReader<GenericRecord> dataFileReader = null;\n\n    try {\n      inputStream = new FSDataInputStream(file.getInputStream());\n      dataFileReader = new DataFileReader<GenericRecord>(new AvroFSInput(inputStream, file.length()),\n                                                         new GenericDatumReader<GenericRecord>(schema));\n\n      if (!dataFileReader.hasNext()) {\n        return ImmutableList.of();\n      }\n\n      GenericRecord datum;\n      List<List<LogEvent>> logSegments = Lists.newArrayList();\n      int count = 0;\n\n      // Calculate skipLen based on fileLength\n      long unSkippedLen = file.length();\n      long skipLen = unSkippedLen / 10;\n      if (skipLen > DEFAULT_SKIP_LEN) {\n        skipLen = DEFAULT_SKIP_LEN;\n      } else if (skipLen <= 0) {\n        skipLen = DEFAULT_SKIP_LEN;\n      }\n\n      List<LogEvent> logSegment = Lists.newArrayList();\n      long prevSyncPos = file.length() - 1;\n      long nextSyncPos;\n      while (unSkippedLen > 0) {\n        long seekPos = unSkippedLen < skipLen ? 0 : unSkippedLen - skipLen;\n        unSkippedLen -= skipLen;\n\n        dataFileReader.sync(seekPos);\n        nextSyncPos = prevSyncPos;\n        prevSyncPos = dataFileReader.previousSync();\n\n        logSegment = logSegment.isEmpty() ? logSegment : Lists.<LogEvent>newArrayList();\n        while (dataFileReader.hasNext()) {\n          datum = dataFileReader.next();\n\n          // Stop at the end of current segment.\n          if (dataFileReader.hasNext() && dataFileReader.pastSync(nextSyncPos)) {\n            break;\n          }\n\n          ILoggingEvent loggingEvent = LoggingEvent.decode(datum);\n\n          if (loggingEvent.getTimeStamp() > fromTimeMs) {\n            break;\n          }\n\n          if (logFilter.match(loggingEvent)) {\n            ++count;\n            logSegment.add(new LogEvent(loggingEvent, loggingEvent.getTimeStamp()));\n          }\n        }\n\n        if (!logSegment.isEmpty()) {\n          logSegments.add(logSegment);\n        }\n\n        if (count > maxEvents) {\n          break;\n        }\n      }\n\n      int skip = count >= maxEvents ? count - maxEvents : 0;\n      return Lists.newArrayList(Iterables.skip(Iterables.concat(Lists.reverse(logSegments)), skip));\n    } catch (Exception e) {\n      LOG.error(String.format(\"Got exception while reading log file %s\", file.toURI()), e);\n      throw Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          if (dataFileReader != null) {\n            dataFileReader.close();\n          }\n        } finally {\n          if (inputStream != null) {\n            inputStream.close();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Got exception while closing log file %s\", file.toURI()), e);\n      }\n    }\n  }","id":51192,"modified_method":"public Collection<LogEvent> readLogPrev(Location file, Filter logFilter, long fromTimeMs, final int maxEvents) {\n    FSDataInputStream inputStream = null;\n    DataFileReader<GenericRecord> dataFileReader = null;\n\n    try {\n      inputStream = new FSDataInputStream(file.getInputStream());\n      dataFileReader = new DataFileReader<GenericRecord>(new AvroFSInput(inputStream, file.length()),\n                                                         new GenericDatumReader<GenericRecord>(schema));\n\n      if (!dataFileReader.hasNext()) {\n        return ImmutableList.of();\n      }\n\n      GenericRecord datum;\n      List<List<LogEvent>> logSegments = Lists.newArrayList();\n      int count = 0;\n\n      // Calculate skipLen based on fileLength\n      long unSkippedLen = file.length();\n      long skipLen = unSkippedLen / 10;\n      if (skipLen > DEFAULT_SKIP_LEN) {\n        skipLen = DEFAULT_SKIP_LEN;\n      } else if (skipLen <= 0) {\n        skipLen = DEFAULT_SKIP_LEN;\n      }\n\n      List<LogEvent> logSegment = Lists.newArrayList();\n      long prevSyncPos = file.length() - 1;\n      long nextSyncPos;\n      boolean  lastFileSegment = true;\n\n      while (unSkippedLen > 0) {\n        long seekPos = unSkippedLen < skipLen ? 0 : unSkippedLen - skipLen;\n        unSkippedLen -= skipLen;\n\n        dataFileReader.sync(seekPos);\n        nextSyncPos = prevSyncPos;\n        prevSyncPos = dataFileReader.previousSync();\n\n        logSegment = logSegment.isEmpty() ? logSegment : Lists.<LogEvent>newArrayList();\n        while (dataFileReader.hasNext()) {\n          datum = dataFileReader.next();\n\n          // Stop at the end of current segment.\n          // Note: pastSync does not have any meaning for the last file segment\n          if (!lastFileSegment && dataFileReader.pastSync(nextSyncPos)) {\n            break;\n          }\n\n          lastFileSegment = false;\n\n          ILoggingEvent loggingEvent = LoggingEvent.decode(datum);\n\n          if (loggingEvent.getTimeStamp() > fromTimeMs) {\n            break;\n          }\n\n          if (logFilter.match(loggingEvent)) {\n            ++count;\n            logSegment.add(new LogEvent(loggingEvent, loggingEvent.getTimeStamp()));\n          }\n        }\n\n        if (!logSegment.isEmpty()) {\n          logSegments.add(logSegment);\n        }\n\n        if (count > maxEvents) {\n          break;\n        }\n      }\n\n      int skip = count >= maxEvents ? count - maxEvents : 0;\n      return Lists.newArrayList(Iterables.skip(Iterables.concat(Lists.reverse(logSegments)), skip));\n    } catch (Exception e) {\n      LOG.error(String.format(\"Got exception while reading log file %s\", file.toURI()), e);\n      throw Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          if (dataFileReader != null) {\n            dataFileReader.close();\n          }\n        } finally {\n          if (inputStream != null) {\n            inputStream.close();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Got exception while closing log file %s\", file.toURI()), e);\n      }\n    }\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset - maxEvents;\n            int adjMaxEvents = maxEvents;\n\n            if (fromOffset < 0)  {\n              startOffset = latestOffset - maxEvents;\n            }\n\n            if (startOffset < 0) {\n              startOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.EARLIEST);\n              adjMaxEvents = (int) (fromOffset - startOffset);\n            }\n\n            if (startOffset == fromOffset || startOffset >= latestOffset) {\n              // At end of kafka events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, adjMaxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":51193,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset - maxEvents;\n            int adjMaxEvents = maxEvents;\n\n            if (fromOffset < 0)  {\n              startOffset = latestOffset - maxEvents;\n            }\n\n            if (startOffset < 0) {\n              startOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.EARLIEST);\n              adjMaxEvents = (int) (fromOffset - startOffset);\n            }\n\n            if (startOffset == fromOffset || startOffset >= latestOffset) {\n              // At end of kafka events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, adjMaxEvents, callback);\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset + 1;\n\n            if (fromOffset < 0) {\n              startOffset = latestOffset - maxEvents;\n            }\n\n            if (startOffset >= latestOffset) {\n              // At end of events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":51194,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset + 1;\n\n            if (fromOffset < 0) {\n              startOffset = latestOffset - maxEvents;\n            }\n\n            if (startOffset >= latestOffset) {\n              // At end of events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n\n          callback.init();\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            long prevInterval = -1;\n            Location prevFile = null;\n            List<Location> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevInterval != -1 && prevInterval < toTimeMs) {\n                files.add(prevFile);\n              }\n              prevInterval = entry.getKey();\n              prevFile = entry.getValue();\n            }\n\n            if (prevInterval != -1 && prevInterval < toTimeMs) {\n              files.add(prevFile);\n            }\n\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(schema);\n            for (Location file : files) {\n              avroFileLogReader.readLog(locationFactory.create(file.toURI()), logFilter, fromTimeMs, toTimeMs,\n                                        Integer.MAX_VALUE, callback);\n            }\n          } catch (Exception e) {\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","id":51195,"modified_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n\n          callback.init();\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            long prevInterval = -1;\n            Location prevFile = null;\n            List<Location> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevInterval != -1 && prevInterval < toTimeMs) {\n                files.add(prevFile);\n              }\n              prevInterval = entry.getKey();\n              prevFile = entry.getValue();\n            }\n\n            if (prevInterval != -1 && prevInterval < toTimeMs) {\n              files.add(prevFile);\n            }\n\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(schema);\n            for (Location file : files) {\n              avroFileLogReader.readLog(locationFactory.create(file.toURI()), logFilter, fromTimeMs, toTimeMs,\n                                        Integer.MAX_VALUE, callback);\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public FileLogAppender(CConfiguration cConfig, LocationFactory locationFactory) {\n    setName(APPENDER_NAME);\n\n    String baseDir = cConfig.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(baseDir, \"Log base dir cannot be null\");\n    this.logBaseDir = locationFactory.create(baseDir);\n\n    float rotationMins = cConfig.getFloat(LoggingConfiguration.LOG_FILE_ROTATION_INTERVAL_MINS,\n                                      TimeUnit.MINUTES.convert(1, TimeUnit.DAYS));\n    Preconditions.checkArgument(rotationMins > 0, \"Log file rotation interval is invalid: %s\", rotationMins);\n    this.logFileRotationIntervalMs = (long) (rotationMins * 60 * 1000);\n\n    this.syncIntervalBytes = cConfig.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 50 * 1024);\n    Preconditions.checkArgument(this.syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", this.syncIntervalBytes);\n\n    long retentionDurationDays = cConfig.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS, -1);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n    this.retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n  }","id":51196,"modified_method":"@Inject\n  public FileLogAppender(CConfiguration cConfig, DataSetAccessor dataSetAccessor,\n                         TransactionSystemClient txClient,\n                         LocationFactory locationFactory) {\n    setName(APPENDER_NAME);\n\n    this.dataSetAccessor = dataSetAccessor;\n    this.txClient = txClient;\n    this.locationFactory = locationFactory;\n\n    String baseDir = cConfig.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(baseDir, \"Log base dir cannot be null\");\n    this.logBaseDir = locationFactory.create(baseDir);\n\n    this.syncIntervalBytes = cConfig.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 50 * 1024);\n    Preconditions.checkArgument(this.syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", this.syncIntervalBytes);\n\n    long retentionDurationDays = cConfig.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS, -1);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n    this.retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n\n    maxLogFileSizeBytes = cConfig.getLong(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024 * 1024);\n    Preconditions.checkArgument(maxLogFileSizeBytes > 0,\n                                \"Max log file size is invalid: %s\", maxLogFileSizeBytes);\n\n    inactiveIntervalMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS,\n                                              LoggingConfiguration.DEFAULT_LOG_SAVER_INACTIVE_FILE_INTERVAL_MS);\n    Preconditions.checkArgument(inactiveIntervalMs > 0,\n                                \"Inactive interval is invalid: %s\", inactiveIntervalMs);\n\n    checkpointIntervalMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_CHECKPOINT_INTERVAL_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_CHECKPOINT_INTERVAL_MS);\n    Preconditions.checkArgument(checkpointIntervalMs > 0,\n                                \"Checkpoint interval is invalid: %s\", checkpointIntervalMs);\n\n    logCleanupIntervalMins = cConfig.getInt(LoggingConfiguration.LOG_CLEANUP_RUN_INTERVAL_MINS,\n                                            LoggingConfiguration.DEFAULT_LOG_CLEANUP_RUN_INTERVAL_MINS);\n    Preconditions.checkArgument(logCleanupIntervalMins > 0,\n                                \"Log cleanup run interval is invalid: %s\", logCleanupIntervalMins);\n\n    this.scheduledExecutor =\n      MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor(\n        Threads.createDaemonThreadFactory(\"file-log-appender\")));\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void append(ILoggingEvent eventObject) {\n    LoggingContext loggingContext = LoggingContextAccessor.getLoggingContext();\n    if (loggingContext == null) {\n      return;\n    }\n\n    try {\n      logFileWriter.append(eventObject);\n    } catch (Throwable t) {\n      LOG.error(\"Got exception while serializing log event {}.\", eventObject, t);\n    }\n  }","id":51197,"modified_method":"@Override\n  protected void append(ILoggingEvent eventObject) {\n    LoggingContext loggingContext = LoggingContextAccessor.getLoggingContext();\n    if (loggingContext == null) {\n      return;\n    }\n\n    try {\n      GenericRecord datum = LoggingEvent.encode(logSchema, eventObject);\n      logFileWriter.append(ImmutableList.of(new LogWriteEvent(datum, eventObject, loggingContext)));\n    } catch (Throwable t) {\n      LOG.error(\"Got exception while serializing log event {}.\", eventObject, t);\n    }\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    super.stop();\n    close();\n  }","id":51198,"modified_method":"@Override\n  public void stop() {\n    super.stop();\n    scheduledExecutor.shutdownNow();\n    close();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start() {\n    super.start();\n    try {\n      logFileWriter = new LogFileWriter(logBaseDir, new LogSchema().getAvroSchema(),\n                                        syncIntervalBytes, logFileRotationIntervalMs, retentionDurationMs);\n    } catch (IOException e) {\n      close();\n      throw Throwables.propagate(e);\n    }\n  }","id":51199,"modified_method":"@Override\n  public void start() {\n    super.start();\n    try {\n      logSchema = new LogSchema().getAvroSchema();\n      FileMetaDataManager fileMetaDataManager = new FileMetaDataManager(LogSaver.getMetaTable(dataSetAccessor), txClient,\n                                                                        locationFactory);\n\n      AvroFileWriter avroFileWriter = new AvroFileWriter(fileMetaDataManager, logBaseDir,\n                                                         logSchema,\n                                                         maxLogFileSizeBytes, syncIntervalBytes,\n                                                         inactiveIntervalMs);\n      logFileWriter = new SimpleLogFileWriter(avroFileWriter, checkpointIntervalMs);\n\n      LogCleanup logCleanup = new LogCleanup(locationFactory, fileMetaDataManager,\n                                       logBaseDir, retentionDurationMs);\n      scheduledExecutor.scheduleAtFixedRate(logCleanup, 10,\n                                            logCleanupIntervalMins, TimeUnit.MINUTES);\n    } catch (Exception e) {\n      close();\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testLogRead(LoggingContext loggingContext) throws Exception {\n    LOG.info(\"Verifying logging context {}\", loggingContext.getLogPathFragment());\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"developer\");\n    DistributedLogReader distributedLogReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf, new SeekableLocalLocationFactory());\n\n    LogCallback logCallback1 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, 0, Long.MAX_VALUE, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n\n    Assert.assertEquals(60, allEvents.size());\n    for (int i = 0; i < 60; ++i) {\n      Assert.assertEquals(String.format(\"Test log message %d arg1 arg2\", i),\n                          allEvents.get(i).getLoggingEvent().getFormattedMessage());\n\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(AccountLoggingContext.TAG_ACCOUNT_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(AccountLoggingContext.TAG_ACCOUNT_ID));\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(ApplicationLoggingContext.TAG_APPLICATION_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(ApplicationLoggingContext.TAG_APPLICATION_ID));\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(FlowletLoggingContext.TAG_FLOW_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(FlowletLoggingContext.TAG_FLOW_ID));\n    }\n\n    LogCallback logCallback2 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(20).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 10 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 19 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(5).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(55).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(50, events.size());\n    Assert.assertEquals(\"Test log message 5 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 54 arg1 arg2\", events.get(49).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(30).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(53).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(23, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 52 arg1 arg2\", events.get(22).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(35).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(3, events.size());\n    Assert.assertEquals(\"Test log message 35 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 37 arg1 arg2\", events.get(2).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback6 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(53).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(6, events.size());\n    Assert.assertEquals(\"Test log message 53 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 58 arg1 arg2\", events.get(5).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(59).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback8 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(0).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback8);\n    events = logCallback8.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback9 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(20).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(20).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback10 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(32).getLoggingEvent().getTimeStamp() - 999999,\n                                allEvents.get(45).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertTrue(events.size() > 13);\n    Assert.assertEquals(\"Test log message 32 arg1 arg2\",\n                        events.get(events.size() - 13).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 44 arg1 arg2\",\n                        events.get(events.size() - 1).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback11 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(18).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(34).getLoggingEvent().getTimeStamp() + 999999,\n                                Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertTrue(events.size() > 16);\n    Assert.assertEquals(\"Test log message 18 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 33 arg1 arg2\",\n                        events.get(events.size() - 1 - (events.size() - 16)).getLoggingEvent().getFormattedMessage());\n  }","id":51200,"modified_method":"private void testLogRead(LoggingContext loggingContext) throws Exception {\n    LOG.info(\"Verifying logging context {}\", loggingContext.getLogPathFragment());\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"developer\");\n    DistributedLogReader distributedLogReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf,\n                               new SeekableLocalLocationFactory(new LocalLocationFactory()));\n\n    LogCallback logCallback1 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, 0, Long.MAX_VALUE, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n\n    Assert.assertEquals(60, allEvents.size());\n    for (int i = 0; i < 60; ++i) {\n      Assert.assertEquals(String.format(\"Test log message %d arg1 arg2\", i),\n                          allEvents.get(i).getLoggingEvent().getFormattedMessage());\n\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(AccountLoggingContext.TAG_ACCOUNT_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(AccountLoggingContext.TAG_ACCOUNT_ID));\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(ApplicationLoggingContext.TAG_APPLICATION_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(ApplicationLoggingContext.TAG_APPLICATION_ID));\n      Assert.assertEquals(\n        loggingContext.getSystemTagsMap().get(FlowletLoggingContext.TAG_FLOW_ID).getValue(),\n        allEvents.get(i).getLoggingEvent().getMDCPropertyMap().get(FlowletLoggingContext.TAG_FLOW_ID));\n    }\n\n    LogCallback logCallback2 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(20).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 10 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 19 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(5).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(55).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(50, events.size());\n    Assert.assertEquals(\"Test log message 5 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 54 arg1 arg2\", events.get(49).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(30).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(53).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(23, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 52 arg1 arg2\", events.get(22).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(35).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(3, events.size());\n    Assert.assertEquals(\"Test log message 35 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 37 arg1 arg2\", events.get(2).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback6 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(53).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(6, events.size());\n    Assert.assertEquals(\"Test log message 53 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 58 arg1 arg2\", events.get(5).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(59).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback8 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(0).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback8);\n    events = logCallback8.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback9 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(20).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(20).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback10 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(32).getLoggingEvent().getTimeStamp() - 999999,\n                                allEvents.get(45).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertTrue(events.size() > 13);\n    Assert.assertEquals(\"Test log message 32 arg1 arg2\",\n                        events.get(events.size() - 13).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 44 arg1 arg2\",\n                        events.get(events.size() - 1).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback11 = new LogCallback();\n    distributedLogReader.getLog(loggingContext, allEvents.get(18).getLoggingEvent().getTimeStamp(),\n                                allEvents.get(34).getLoggingEvent().getTimeStamp() + 999999,\n                                Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertTrue(events.size() > 16);\n    Assert.assertEquals(\"Test log message 18 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 33 arg1 arg2\",\n                        events.get(events.size() - 1 - (events.size() - 16)).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback2.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, 0, 15, Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 25, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ultimateOffset + 1, 15, Filter.EMPTY_FILTER,\n                         logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n  }","id":51201,"modified_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback2.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, 0, 15, Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 25, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ultimateOffset + 1, 15, Filter.EMPTY_FILTER,\n                         logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testGetNext(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogNext(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n    long penultimateOffset = events.get(8).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 31 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogNext(loggingContext, ultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogNext(loggingContext, ultimateOffset + 1, 20, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogNext(loggingContext, penultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(1, events.size());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n  }","id":51202,"modified_method":"public void testGetNext(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogNext(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n    long penultimateOffset = events.get(8).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 31 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogNext(loggingContext, ultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogNext(loggingContext, ultimateOffset + 1, 20, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogNext(loggingContext, penultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(1, events.size());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          callback.init();\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            SortedMap<Long, Location> sortedFiles = getFiles(null);\n            if (sortedFiles.isEmpty()) {\n              return;\n            }\n\n            long prevInterval = -1;\n            Location prevPath = null;\n            List<Location> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevInterval != -1 && prevInterval < toTimeMs) {\n                files.add(prevPath);\n              }\n              prevInterval = entry.getKey();\n              prevPath = entry.getValue();\n            }\n\n            if (prevInterval != -1 && prevInterval < toTimeMs) {\n              files.add(prevPath);\n            }\n\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(schema);\n            for (Location file : files) {\n              avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n            }\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","id":51203,"modified_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          callback.init();\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            if (sortedFiles.isEmpty()) {\n              return;\n            }\n\n            long prevInterval = -1;\n            Location prevPath = null;\n            List<Location> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevInterval != -1 && prevInterval < toTimeMs) {\n                files.add(prevPath);\n              }\n              prevInterval = entry.getKey();\n              prevPath = entry.getValue();\n            }\n\n            if (prevInterval != -1 && prevInterval < toTimeMs) {\n              files.add(prevPath);\n            }\n\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(schema);\n            for (Location file : files) {\n              avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(new Runnable() {\n      @Override\n      public void run() {\n        callback.init();\n        try {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                            filter));\n\n          SortedMap<Long, Location> sortedFiles = getFiles(Collections.<Long>reverseOrder());\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long fromTimeMs = fromOffset >= 0 ? fromOffset - 1 : System.currentTimeMillis();\n\n          List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n            if (entry.getKey() <= fromTimeMs) {\n              tailFiles.add(entry.getValue());\n            }\n          }\n\n          List<Collection<LogEvent>> logSegments = Lists.newLinkedList();\n          AvroFileLogReader logReader = new AvroFileLogReader(schema);\n          int count = 0;\n          for (Location file : tailFiles) {\n            Collection<LogEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs,\n                                                                maxEvents - count);\n            logSegments.add(events);\n            count += events.size();\n            if (count >= maxEvents) {\n              break;\n            }\n          }\n\n          for (LogEvent event : Iterables.concat(Lists.reverse(logSegments))) {\n            callback.handle(event);\n          }\n        } finally {\n          callback.close();\n        }\n      }\n    });\n  }","id":51204,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(new Runnable() {\n      @Override\n      public void run() {\n        callback.init();\n        try {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                            filter));\n\n          SortedMap<Long, Location> sortedFiles =\n            ImmutableSortedMap.copyOf(fileMetaDataManager.listFiles(loggingContext), Collections.<Long>reverseOrder());\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long fromTimeMs = fromOffset >= 0 ? fromOffset - 1 : System.currentTimeMillis();\n\n          List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n            if (entry.getKey() <= fromTimeMs) {\n              tailFiles.add(entry.getValue());\n            }\n          }\n\n          List<Collection<LogEvent>> logSegments = Lists.newLinkedList();\n          AvroFileLogReader logReader = new AvroFileLogReader(schema);\n          int count = 0;\n          for (Location file : tailFiles) {\n            Collection<LogEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs,\n                                                                maxEvents - count);\n            logSegments.add(events);\n            count += events.size();\n            if (count >= maxEvents) {\n              break;\n            }\n          }\n\n          for (LogEvent event : Iterables.concat(Lists.reverse(logSegments))) {\n            callback.handle(event);\n          }\n        } catch (Throwable e) {\n          LOG.error(\"Got exception: \", e);\n          throw  Throwables.propagate(e);\n        } finally {\n          callback.close();\n        }\n      }\n    });\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset < 0) {\n      getLogPrev(loggingContext, -1, maxEvents, filter, callback);\n      return;\n    }\n\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          callback.init();\n\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n            long fromTimeMs = fromOffset + 1;\n\n            SortedMap<Long, Location> sortedFiles = getFiles(null);\n            if (sortedFiles.isEmpty()) {\n              return;\n            }\n\n            long prevInterval = -1;\n            Location prevPath = null;\n            List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevPath != null) {\n                tailFiles.add(prevPath);\n              }\n              prevInterval = entry.getKey();\n              prevPath = entry.getValue();\n            }\n\n            if (prevInterval != -1) {\n              tailFiles.add(prevPath);\n            }\n\n            AvroFileLogReader logReader = new AvroFileLogReader(schema);\n            CountingCallback countingCallback = new CountingCallback(callback);\n            for (Location file : tailFiles) {\n              logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - countingCallback.getCount(),\n                                countingCallback);\n              if (countingCallback.getCount() >= maxEvents) {\n                break;\n              }\n            }\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","id":51205,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset < 0) {\n      getLogPrev(loggingContext, -1, maxEvents, filter, callback);\n      return;\n    }\n\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          callback.init();\n\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n            long fromTimeMs = fromOffset + 1;\n\n            SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            if (sortedFiles.isEmpty()) {\n              return;\n            }\n\n            long prevInterval = -1;\n            Location prevPath = null;\n            List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && prevPath != null) {\n                tailFiles.add(prevPath);\n              }\n              prevInterval = entry.getKey();\n              prevPath = entry.getValue();\n            }\n\n            if (prevInterval != -1) {\n              tailFiles.add(prevPath);\n            }\n\n            AvroFileLogReader logReader = new AvroFileLogReader(schema);\n            CountingCallback countingCallback = new CountingCallback(callback);\n            for (Location file : tailFiles) {\n              logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - countingCallback.getCount(),\n                                countingCallback);\n              if (countingCallback.getCount() >= maxEvents) {\n                break;\n              }\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public SingleNodeLogReader(CConfiguration cConf, LocationFactory locationFactory) {\n    String baseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(baseDir, \"Log base dir cannot be null\");\n    this.logBaseDir = locationFactory.create(baseDir);\n\n    try {\n      this.schema = new LogSchema().getAvroSchema();\n    } catch (IOException e) {\n      LOG.error(\"Cannot get LogSchema\", e);\n      throw Throwables.propagate(e);\n    }\n\n    // Thread pool of size max MAX_THREAD_POOL_SIZE.\n    // 60 seconds wait time before killing idle threads.\n    // Keep no idle threads more than 60 seconds.\n    // If max thread pool size reached, reject the new coming\n    this.executor =\n      new ThreadPoolExecutor(0, MAX_THREAD_POOL_SIZE,\n                             60L, TimeUnit.SECONDS,\n                             new SynchronousQueue<Runnable>(),\n                             Threads.createDaemonThreadFactory(\"single-log-reader-%d\"),\n                             new ThreadPoolExecutor.DiscardPolicy());\n  }","id":51206,"modified_method":"@Inject\n  public SingleNodeLogReader(CConfiguration cConf, DataSetAccessor dataSetAccessor,\n                             TransactionSystemClient txClient,\n                             SeekableLocalLocationFactory locationFactory) {\n    String baseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(baseDir, \"Log base dir cannot be null\");\n\n    try {\n      this.schema = new LogSchema().getAvroSchema();\n      this.fileMetaDataManager = new FileMetaDataManager(LogSaver.getMetaTable(dataSetAccessor), txClient,\n                                                         locationFactory);\n\n    } catch (Exception e) {\n      LOG.error(\"Got exception\", e);\n      throw Throwables.propagate(e);\n    }\n\n    // Thread pool of size max MAX_THREAD_POOL_SIZE.\n    // 60 seconds wait time before killing idle threads.\n    // Keep no idle threads more than 60 seconds.\n    // If max thread pool size reached, reject the new coming\n    this.executor =\n      new ThreadPoolExecutor(0, MAX_THREAD_POOL_SIZE,\n                             60L, TimeUnit.SECONDS,\n                             new SynchronousQueue<Runnable>(),\n                             Threads.createDaemonThreadFactory(\"single-log-reader-%d\"),\n                             new ThreadPoolExecutor.DiscardPolicy());\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetLogNext() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logReader = new SingleNodeLogReader(cConf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetNext(logReader, loggingContext);\n    logReader.close();\n  }","id":51207,"modified_method":"@Test\n  public void testGetLogNext() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logReader =\n      new SingleNodeLogReader(cConf, dataSetAccessor, txClient,\n                              new SeekableLocalLocationFactory(new LocalLocationFactory()));\n    LoggingTester tester = new LoggingTester();\n    tester.testGetNext(logReader, loggingContext);\n    logReader.close();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setUpContext() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    LOG_BASE_DIR = \"/tmp/log_files_\" + new Random(System.currentTimeMillis()).nextLong();\n\n\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n    cConf.set(LoggingConfiguration.LOG_FILE_ROTATION_INTERVAL_MINS, \"0.015\");\n    cConf.setInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 100);\n    FileLogAppender appender = new FileLogAppender(cConf, new LocalLocationFactory());\n    new LogAppenderInitializer(appender).initialize(\"TestFileLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestFileLogging\");\n    for (int i = 0; i < 20; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    appender.getLogFileWriter().rotate(System.currentTimeMillis());\n\n    for (int i = 20; i < 40; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    appender.getLogFileWriter().rotate(System.currentTimeMillis());\n\n    for (int i = 40; i < 60; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n  }","id":51208,"modified_method":"@BeforeClass\n  public static void setUpContext() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    LOG_BASE_DIR = \"/tmp/log_files_\" + new Random(System.currentTimeMillis()).nextLong();\n\n\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n    cConf.setInt(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024);\n\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    txClient = new InMemoryTxSystemClient(txManager);\n\n    FileLogAppender appender = new FileLogAppender(cConf, dataSetAccessor, txClient, new LocalLocationFactory());\n    new LogAppenderInitializer(appender).initialize(\"TestFileLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestFileLogging\");\n    for (int i = 0; i < 60; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetLog() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logTail = new SingleNodeLogReader(cConf, new LocalLocationFactory());\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, -1, 60, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertEquals(60, allEvents.size());\n\n    LoggingTester.LogCallback logCallback2 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(15).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(5, events.size());\n    Assert.assertEquals(allEvents.get(10).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(14).getLoggingEvent().getFormattedMessage(),\n                        events.get(4).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback3 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(59, events.size());\n    Assert.assertEquals(allEvents.get(0).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(58).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback4 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(12).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(41).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(29, events.size());\n    Assert.assertEquals(allEvents.get(12).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(40).getLoggingEvent().getFormattedMessage(),\n                        events.get(28).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback5 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(22).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(16, events.size());\n    Assert.assertEquals(allEvents.get(22).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(37).getLoggingEvent().getFormattedMessage(),\n                        events.get(15).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback6 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(41).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(18, events.size());\n    Assert.assertEquals(allEvents.get(41).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(17).getLoggingEvent().getFormattedMessage());\n\n  }","id":51209,"modified_method":"@Test\n  public void testGetLog() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logTail =\n      new SingleNodeLogReader(cConf, dataSetAccessor, txClient,\n                              new SeekableLocalLocationFactory(new LocalLocationFactory()));\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, -1, 60, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertEquals(60, allEvents.size());\n\n    LoggingTester.LogCallback logCallback2 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(15).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(5, events.size());\n    Assert.assertEquals(allEvents.get(10).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(14).getLoggingEvent().getFormattedMessage(),\n                        events.get(4).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback3 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(59, events.size());\n    Assert.assertEquals(allEvents.get(0).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(58).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback4 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(12).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(41).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(29, events.size());\n    Assert.assertEquals(allEvents.get(12).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(40).getLoggingEvent().getFormattedMessage(),\n                        events.get(28).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback5 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(22).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(16, events.size());\n    Assert.assertEquals(allEvents.get(22).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(37).getLoggingEvent().getFormattedMessage(),\n                        events.get(15).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback6 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(41).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(18, events.size());\n    Assert.assertEquals(allEvents.get(41).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(17).getLoggingEvent().getFormattedMessage());\n\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetLogPrev() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logReader = new SingleNodeLogReader(cConf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetPrev(logReader, loggingContext);\n    logReader.close();\n  }","id":51210,"modified_method":"@Test\n  public void testGetLogPrev() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, LOG_BASE_DIR);\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    SingleNodeLogReader logReader =\n      new SingleNodeLogReader(cConf, dataSetAccessor, txClient,\n                              new SeekableLocalLocationFactory(new LocalLocationFactory()));\n    LoggingTester tester = new LoggingTester();\n    tester.testGetPrev(logReader, loggingContext);\n    logReader.close();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetPrev() throws Exception {\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"ACCT_1\");\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    DistributedLogReader logReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetPrev(logReader, loggingContext);\n    logReader.close();\n  }","id":51211,"modified_method":"@Test\n  public void testGetPrev() throws Exception {\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"TFL_ACCT_1\");\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    DistributedLogReader logReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetPrev(logReader, loggingContext);\n    logReader.close();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetNext() throws Exception {\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"ACCT_1\");\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    DistributedLogReader logReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetNext(logReader, loggingContext);\n    logReader.close();\n  }","id":51212,"modified_method":"@Test\n  public void testGetNext() throws Exception {\n    CConfiguration conf = new CConfiguration();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.LOG_RUN_ACCOUNT, \"TFL_ACCT_1\");\n\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\");\n    DistributedLogReader logReader =\n      new DistributedLogReader(new InMemoryDataSetAccessor(conf), txClient, conf, new LocalLocationFactory());\n    LoggingTester tester = new LoggingTester();\n    tester.testGetNext(logReader, loggingContext);\n    logReader.close();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    txClient = new InMemoryTxSystemClient(txManager);\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n\n    CConfiguration conf = CConfiguration.create();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.KAFKA_PRODUCER_TYPE, \"async\");\n    LogAppender appender = new LogAppenderInitializer(new KafkaLogAppender(conf)).initialize(\"TestKafkaLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestKafkaLogging\");\n    Exception e1 = new Exception(\"Test Exception1\");\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n    for (int i = 0; i < 60; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    appender.stop();\n  }","id":51213,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    txClient = new InMemoryTxSystemClient(txManager);\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n\n    CConfiguration conf = CConfiguration.create();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.KAFKA_PRODUCER_TYPE, \"async\");\n    LogAppender appender = new LogAppenderInitializer(new KafkaLogAppender(conf)).initialize(\"TestKafkaLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestKafkaLogging\");\n    Exception e1 = new Exception(\"Test Exception1\");\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n    for (int i = 0; i < 60; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    appender.stop();\n  }","commit_id":"9cbf5ad6b026062246aee0d07c7a3564360ffd8d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void execute(JobExecutionContext context) throws JobExecutionException {\n    try {\n      LOG.info(\"Received Trigger at {}\", context.getScheduledFireTime().toString());\n      JobDataMap triggerMap = context.getTrigger().getJobDataMap();\n      JobDataMap map = context.getMergedJobDataMap();\n      String[] keys = map.getKeys();\n\n      Preconditions.checkArgument(triggerMap.getString(KEY).equals(VALUE));\n      Preconditions.checkArgument(keys != null);\n      Preconditions.checkArgument(keys.length > 0);\n      LOG.info(\"Number of parameters {}\", keys.length);\n      for (String key : keys) {\n        LOG.info(\"Parameter key: {}, value: {}\", key, map.get(key));\n      }\n    } catch (Throwable e) {\n      throw Throwables.propagate(e);\n    }\n    throw new JobExecutionException(\"exception\");\n  }","id":51214,"modified_method":"@Override\n  public void execute(JobExecutionContext context) throws JobExecutionException {\n    try {\n      LOG.info(\"Received Trigger at {}\", context.getScheduledFireTime().toString());\n      JobDataMap triggerMap = context.getTrigger().getJobDataMap();\n      JobDataMap map = context.getMergedJobDataMap();\n      String[] keys = map.getKeys();\n\n      TriggerKey triggerKey = context.getTrigger().getKey();\n      if (triggerKey.getName().equalsIgnoreCase(\"g2\")) {\n        Preconditions.checkArgument(triggerMap.getString(KEY).equals(VALUE));\n      } else {\n        Preconditions.checkArgument(!triggerMap.containsKey(KEY));\n      }\n\n      Preconditions.checkArgument(keys != null);\n      Preconditions.checkArgument(keys.length > 0);\n      LOG.info(\"Number of parameters {}\", keys.length);\n      for (String key : keys) {\n        LOG.info(\"Parameter key: {}, value: {}\", key, map.get(key));\n      }\n    } catch (Throwable e) {\n      throw Throwables.propagate(e);\n    }\n    throw new JobExecutionException(\"exception\");\n  }","commit_id":"5fc0023eea45f0072a1f361262dd6eb610b79a4f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testJobProperties() throws SchedulerException, UnsupportedTypeException, InterruptedException {\n    String schedulerName = \"testPropertiesScheduler\";\n    schedulerSetup(true, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n      .withIdentity(\"developer:application1:mapreduce1\")\n      .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n      .withIdentity(\"g1\")\n      .usingJobData(LogPrintingJob.KEY, LogPrintingJob.VALUE)\n      .startNow()\n      .withSchedule(CronScheduleBuilder.cronSchedule(\"0/1 * * * * ?\"))\n      .build();\n\n    JobKey key =  job.getKey();\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n    //Make sure that the job gets triggered more than once.\n    TimeUnit.SECONDS.sleep(3);\n    scheduler.deleteJob(key);\n  }","id":51215,"modified_method":"@Test\n  public void testJobProperties() throws SchedulerException, UnsupportedTypeException, InterruptedException {\n    String schedulerName = \"testPropertiesScheduler\";\n    schedulerSetup(true, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n      .withIdentity(\"developer:application1:mapreduce1\")\n      .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n      .withIdentity(\"g2\")\n      .usingJobData(LogPrintingJob.KEY, LogPrintingJob.VALUE)\n      .startNow()\n      .withSchedule(CronScheduleBuilder.cronSchedule(\"0/1 * * * * ?\"))\n      .build();\n\n    JobKey key =  job.getKey();\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n    //Make sure that the job gets triggered more than once.\n    TimeUnit.SECONDS.sleep(3);\n    scheduler.deleteJob(key);\n  }","commit_id":"5fc0023eea45f0072a1f361262dd6eb610b79a4f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSchedulerWithPersistence() throws SchedulerException,\n                                                    UnsupportedTypeException {\n    String schedulerName = \"persistentScheduler\";\n    //start scheduler enabling persistence.\n    schedulerSetup(true, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n      .withIdentity(\"developer:application1:mapreduce2\")\n      .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n      .withIdentity(\"p1\")\n      .usingJobData(LogPrintingJob.KEY, LogPrintingJob.VALUE)\n      .startNow()\n      .withSchedule(CronScheduleBuilder.cronSchedule(\"0 0/5 * * * ?\"))\n      .build();\n\n    JobKey key =  job.getKey();\n\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n\n    //Get the job stored.\n    JobDetail jobStored = scheduler.getJobDetail(job.getKey());\n    List<? extends Trigger> triggers = scheduler.getTriggersOfJob(job.getKey());\n\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n    Assert.assertEquals(1, triggers.size());\n\n    //Shutdown scheduler.\n    schedulerTearDown();\n\n    //restart scheduler.\n    schedulerSetup(true, schedulerName);\n\n    //read the job\n    jobStored = scheduler.getJobDetail(job.getKey());\n    // The job with old job key should exist since it is persisted in Dataset\n    Assert.assertNotNull(jobStored);\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n\n    triggers = scheduler.getTriggersOfJob(job.getKey());\n    Assert.assertEquals(1, triggers.size());\n\n    schedulerTearDown();\n  }","id":51216,"modified_method":"@Test\n  public void testSchedulerWithPersistence() throws SchedulerException,\n                                                    UnsupportedTypeException {\n    String schedulerName = \"persistentScheduler\";\n    //start scheduler enabling persistence.\n    schedulerSetup(true, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n      .withIdentity(\"developer:application1:mapreduce2\")\n      .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n      .withIdentity(\"p1\")\n      .startNow()\n      .withSchedule(CronScheduleBuilder.cronSchedule(\"0 0/5 * * * ?\"))\n      .build();\n\n    JobKey key =  job.getKey();\n\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n\n    //Get the job stored.\n    JobDetail jobStored = scheduler.getJobDetail(job.getKey());\n    List<? extends Trigger> triggers = scheduler.getTriggersOfJob(job.getKey());\n\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n    Assert.assertEquals(1, triggers.size());\n\n    //Shutdown scheduler.\n    schedulerTearDown();\n\n    //restart scheduler.\n    schedulerSetup(true, schedulerName);\n\n    //read the job\n    jobStored = scheduler.getJobDetail(job.getKey());\n    // The job with old job key should exist since it is persisted in Dataset\n    Assert.assertNotNull(jobStored);\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n\n    triggers = scheduler.getTriggersOfJob(job.getKey());\n    Assert.assertEquals(1, triggers.size());\n\n    schedulerTearDown();\n  }","commit_id":"5fc0023eea45f0072a1f361262dd6eb610b79a4f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSchedulerWithoutPersistence() throws SchedulerException, UnsupportedTypeException {\n    String schedulerName = \"NonPersistentScheduler\";\n    //start scheduler without enabling persistence.\n    schedulerSetup(false, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n                              .withIdentity(\"developer:application1:mapreduce1\")\n                              .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n                                     .withIdentity(\"g1\")\n                                     .usingJobData(LogPrintingJob.KEY, LogPrintingJob.VALUE)\n                                     .startNow()\n                                     .withSchedule(CronScheduleBuilder.cronSchedule(\"0 0/5 * * * ?\"))\n                                     .build();\n\n    JobKey key =  job.getKey();\n\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n\n    //Get the job stored.\n    JobDetail jobStored = scheduler.getJobDetail(job.getKey());\n    List<? extends Trigger> triggers = scheduler.getTriggersOfJob(job.getKey());\n\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n    Assert.assertEquals(1, triggers.size());\n\n    //Shutdown scheduler.\n    schedulerTearDown();\n\n    //restart scheduler.\n    schedulerSetup(false, schedulerName);\n\n   //read the job\n    jobStored = scheduler.getJobDetail(job.getKey());\n    // The job with old job key should not exist since it is not persisted.\n    Assert.assertNull(jobStored);\n    schedulerTearDown();\n  }","id":51217,"modified_method":"@Test\n  public void testSchedulerWithoutPersistence() throws SchedulerException, UnsupportedTypeException {\n    String schedulerName = \"NonPersistentScheduler\";\n    //start scheduler without enabling persistence.\n    schedulerSetup(false, schedulerName);\n    JobDetail job = JobBuilder.newJob(LogPrintingJob.class)\n                              .withIdentity(\"developer:application1:mapreduce1\")\n                              .build();\n\n    Trigger trigger  = TriggerBuilder.newTrigger()\n                                     .withIdentity(\"g1\")\n                                     .startNow()\n                                     .withSchedule(CronScheduleBuilder.cronSchedule(\"0 0/5 * * * ?\"))\n                                     .build();\n\n    JobKey key =  job.getKey();\n\n    //Schedule job\n    scheduler.scheduleJob(job, trigger);\n\n    //Get the job stored.\n    JobDetail jobStored = scheduler.getJobDetail(job.getKey());\n    List<? extends Trigger> triggers = scheduler.getTriggersOfJob(job.getKey());\n\n    Assert.assertEquals(jobStored.getKey().getName(), key.getName());\n    Assert.assertEquals(1, triggers.size());\n\n    //Shutdown scheduler.\n    schedulerTearDown();\n\n    //restart scheduler.\n    schedulerSetup(false, schedulerName);\n\n   //read the job\n    jobStored = scheduler.getJobDetail(job.getKey());\n    // The job with old job key should not exist since it is not persisted.\n    Assert.assertNull(jobStored);\n    schedulerTearDown();\n  }","commit_id":"5fc0023eea45f0072a1f361262dd6eb610b79a4f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tactionRequest = ActionUtil.getWrappedActionRequest(actionRequest, null);\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = ActionUtil.getPortlet(actionRequest);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, PrincipalException.class.getName());\n\n\t\t\tsetForward(actionRequest, \"portlet.portlet_configuration.error\");\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\t\taddTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tvalidateFile(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"copy_from_live\")) {\n\t\t\t\t\tStagingUtil.copyFromLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.DELETE_TEMP)) {\n\t\t\t\t\tdeleteTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.EXPORT)) {\n\t\t\t\t\texportData(actionRequest, actionResponse, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.IMPORT)) {\n\t\t\t\t\timportData(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"publish_to_live\")) {\n\t\t\t\t\tStagingUtil.publishToLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\n\t\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\t\tactionRequest, 0, false, plid, portlet.getPortletId());\n\n\t\t\t\tDate startDate = dateRange.getStartDate();\n\n\t\t\t\tif (startDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"startDate\", String.valueOf(startDate.getTime()));\n\t\t\t\t}\n\n\t\t\t\tDate endDate = dateRange.getEndDate();\n\n\t\t\t\tif (endDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"endDate\", String.valueOf(endDate.getTime()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (cmd.equals(Constants.ADD_TEMP) ||\n\t\t\t\tcmd.equals(Constants.DELETE_TEMP)) {\n\n\t\t\t\thandleUploadException(\n\t\t\t\t\tportletConfig, actionRequest, actionResponse,\n\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((e instanceof LARFileException) ||\n\t\t\t\t\t(e instanceof LARFileSizeException) ||\n\t\t\t\t\t(e instanceof LARTypeException) ||\n\t\t\t\t\t(e instanceof LocaleException) ||\n\t\t\t\t\t(e instanceof NoSuchLayoutException) ||\n\t\t\t\t\t(e instanceof PortletIdException) ||\n\t\t\t\t\t(e instanceof PrincipalException) ||\n\t\t\t\t\t(e instanceof StructureDuplicateStructureKeyException) ||\n\t\t\t\t\t(e instanceof RecordSetDuplicateRecordSetKeyException)) {\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(e, e);\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, ExportImportAction.class.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":51218,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tactionRequest = ActionUtil.getWrappedActionRequest(actionRequest, null);\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = ActionUtil.getPortlet(actionRequest);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, PrincipalException.class.getName());\n\n\t\t\tsetForward(actionRequest, \"portlet.portlet_configuration.error\");\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\t\taddTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tvalidateFile(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"copy_from_live\")) {\n\t\t\t\t\tStagingUtil.copyFromLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.DELETE_TEMP)) {\n\t\t\t\t\tdeleteTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.EXPORT)) {\n\t\t\t\t\texportData(actionRequest, actionResponse, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.IMPORT)) {\n\t\t\t\t\timportData(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"publish_to_live\")) {\n\t\t\t\t\tStagingUtil.publishToLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\n\t\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\t\tactionRequest, 0, false, plid, portlet.getPortletId());\n\n\t\t\t\tDate startDate = dateRange.getStartDate();\n\n\t\t\t\tif (startDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"startDate\", String.valueOf(startDate.getTime()));\n\t\t\t\t}\n\n\t\t\t\tDate endDate = dateRange.getEndDate();\n\n\t\t\t\tif (endDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"endDate\", String.valueOf(endDate.getTime()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (cmd.equals(Constants.ADD_TEMP) ||\n\t\t\t\tcmd.equals(Constants.DELETE_TEMP)) {\n\n\t\t\t\thandleUploadException(\n\t\t\t\t\tportletConfig, actionRequest, actionResponse,\n\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((e instanceof LARFileException) ||\n\t\t\t\t\t(e instanceof LARFileSizeException) ||\n\t\t\t\t\t(e instanceof LARTypeException) ||\n\t\t\t\t\t(e instanceof LocaleException) ||\n\t\t\t\t\t(e instanceof NoSuchLayoutException) ||\n\t\t\t\t\t(e instanceof PortletIdException) ||\n\t\t\t\t\t(e instanceof PrincipalException) ||\n\t\t\t\t\t(e instanceof StructureDuplicateStructureKeyException) ||\n\t\t\t\t\t(e instanceof RecordSetDuplicateRecordSetKeyException)) {\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(e, e);\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, ExportImportAction.class.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"9edcd889450ced27b1a4d48471c998f0b06e76e7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void importData(ActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\tLayoutServiceUtil.importPortletInfo(\n\t\t\tplid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), file);\n\t}","id":51219,"modified_method":"@Override\n\tprotected void importData(ActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\tLayoutServiceUtil.importPortletInfoInBackground(\n\t\t\tportlet.getPortletId(), plid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), file);\n\t}","commit_id":"9edcd889450ced27b1a4d48471c998f0b06e76e7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _doProcessEvent(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet, Layout layout, Event event)\n\t\tthrows Exception {\n\n\t\tString portletId = portlet.getPortletId();\n\n\t\tServletContext servletContext =\n\t\t\t(ServletContext)request.getAttribute(WebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tWindowState windowState = null;\n\n\t\tif (layoutTypePortlet.hasStateMaxPortletId(portletId)) {\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\t\telse if (layoutTypePortlet.hasStateMinPortletId(portletId)) {\n\t\t\twindowState = WindowState.MINIMIZED;\n\t\t}\n\t\telse {\n\t\t\twindowState = WindowState.NORMAL;\n\t\t}\n\n\t\tPortletMode portletMode = null;\n\n\t\tif (layoutTypePortlet.hasModeAboutPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.ABOUT;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeConfigPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.CONFIG;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditPortletId(portletId)) {\n\t\t\tportletMode = PortletMode.EDIT;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditDefaultsPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.EDIT_DEFAULTS;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditGuestPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.EDIT_GUEST;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeHelpPortletId(portletId)) {\n\t\t\tportletMode = PortletMode.HELP;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModePreviewPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.PREVIEW;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModePrintPortletId(portletId)) {\n\t\t\tportletMode = LiferayPortletMode.PRINT;\n\t\t}\n\t\telse {\n\t\t\tportletMode = PortletMode.VIEW;\n\t\t}\n\n\t\tlong scopeGroupId = getScopeGroupId(request, layout, portletId);\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tscopeGroupId, layout, portletId, null);\n\n\t\tEventRequestImpl eventRequestImpl = EventRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\teventRequestImpl.setEvent(\n\t\t\tserializeEvent(event, invokerPortlet.getPortletClassLoader()));\n\n\t\tUser user = PortalUtil.getUser(request);\n\t\tLayout requestLayout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tEventResponseImpl eventResponseImpl = EventResponseFactory.create(\n\t\t\teventRequestImpl, response, portletId, user, requestLayout);\n\n\t\teventRequestImpl.defineObjects(portletConfig, eventResponseImpl);\n\n\t\ttry {\n\t\t\tinvokerPortlet.processEvent(eventRequestImpl, eventResponseImpl);\n\n\t\t\tif (eventResponseImpl.isCalledSetRenderParameter()) {\n\t\t\t\tMap<String, String[]> renderParameterMap =\n\t\t\t\t\tnew HashMap<String, String[]>();\n\n\t\t\t\trenderParameterMap.putAll(\n\t\t\t\t\teventResponseImpl.getRenderParameterMap());\n\n\t\t\t\tRenderParametersPool.put(\n\t\t\t\t\trequest, requestLayout.getPlid(), portletId,\n\t\t\t\t\trenderParameterMap);\n\t\t\t}\n\n\t\t\tprocessEvents(request, response, eventResponseImpl.getEvents());\n\t\t}\n\t\tfinally {\n\t\t\teventRequestImpl.cleanUp();\n\t\t}\n\t}","id":51220,"modified_method":"private void _doProcessEvent(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet, Layout layout, Event event)\n\t\tthrows Exception {\n\n\t\tServletContext servletContext =\n\t\t\t(ServletContext)request.getAttribute(WebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tWindowState windowState = null;\n\n\t\tif (layoutTypePortlet.hasStateMaxPortletId(portlet.getPortletId())) {\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\t\telse if (layoutTypePortlet.hasStateMinPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\twindowState = WindowState.MINIMIZED;\n\t\t}\n\t\telse {\n\t\t\twindowState = WindowState.NORMAL;\n\t\t}\n\n\t\tPortletMode portletMode = null;\n\n\t\tif (layoutTypePortlet.hasModeAboutPortletId(portlet.getPortletId())) {\n\t\t\tportletMode = LiferayPortletMode.ABOUT;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeConfigPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = LiferayPortletMode.CONFIG;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = PortletMode.EDIT;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditDefaultsPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = LiferayPortletMode.EDIT_DEFAULTS;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeEditGuestPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = LiferayPortletMode.EDIT_GUEST;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModeHelpPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = PortletMode.HELP;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModePreviewPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = LiferayPortletMode.PREVIEW;\n\t\t}\n\t\telse if (layoutTypePortlet.hasModePrintPortletId(\n\t\t\t\t\tportlet.getPortletId())) {\n\n\t\t\tportletMode = LiferayPortletMode.PRINT;\n\t\t}\n\t\telse {\n\t\t\tportletMode = PortletMode.VIEW;\n\t\t}\n\n\t\tlong scopeGroupId = getScopeGroupId(\n\t\t\trequest, layout, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tscopeGroupId, layout, portlet.getPortletId(), null);\n\n\t\tEventRequestImpl eventRequestImpl = EventRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\teventRequestImpl.setEvent(\n\t\t\tserializeEvent(event, invokerPortlet.getPortletClassLoader()));\n\n\t\tUser user = PortalUtil.getUser(request);\n\t\tLayout requestLayout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tEventResponseImpl eventResponseImpl = EventResponseFactory.create(\n\t\t\teventRequestImpl, response, portlet.getPortletId(), user,\n\t\t\trequestLayout);\n\n\t\teventRequestImpl.defineObjects(portletConfig, eventResponseImpl);\n\n\t\ttry {\n\t\t\tinvokerPortlet.processEvent(eventRequestImpl, eventResponseImpl);\n\n\t\t\tif (eventResponseImpl.isCalledSetRenderParameter()) {\n\t\t\t\tMap<String, String[]> renderParameterMap =\n\t\t\t\t\tnew HashMap<String, String[]>();\n\n\t\t\t\trenderParameterMap.putAll(\n\t\t\t\t\teventResponseImpl.getRenderParameterMap());\n\n\t\t\t\tRenderParametersPool.put(\n\t\t\t\t\trequest, requestLayout.getPlid(), portlet.getPortletId(),\n\t\t\t\t\trenderParameterMap);\n\t\t\t}\n\n\t\t\tprocessEvents(request, response, eventResponseImpl.getEvents());\n\t\t}\n\t\tfinally {\n\t\t\teventRequestImpl.cleanUp();\n\t\t}\n\t}","commit_id":"fbaec6e2b655de7541c45d40d432482cd99d765e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _doPreparePortlet(HttpServletRequest request, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tUser user = PortalUtil.getUser(request);\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tString portletId = portlet.getPortletId();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request, portletId);\n\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\n\t\tif (user != null) {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tInvokerPortletImpl.clearResponse(\n\t\t\t\tsession, layout.getPrimaryKey(), portletId,\n\t\t\t\tLanguageUtil.getLanguageId(request));\n\t\t}\n\n\t\tprocessPublicRenderParameters(request, layout, portlet);\n\n\t\tif (themeDisplay.isLifecycleRender() ||\n\t\t\tthemeDisplay.isLifecycleResource()) {\n\n\t\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\t\tif (layout.isTypeControlPanel() &&\n\t\t\t\t((windowState == null) ||\n\t\t\t\t\twindowState.equals(WindowState.NORMAL) ||\n\t\t\t\t\tValidator.isNull(windowState.toString()))) {\n\n\t\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t\t}\n\n\t\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\t\tPortalUtil.updateWindowState(\n\t\t\t\tportletId, user, layout, windowState, request);\n\n\t\t\tPortalUtil.updatePortletMode(\n\t\t\t\tportletId, user, layout, portletMode, request);\n\t\t}\n\t}","id":51221,"modified_method":"private void _doPreparePortlet(HttpServletRequest request, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tUser user = PortalUtil.getUser(request);\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(\n\t\t\trequest, portlet.getPortletId());\n\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\n\t\tif (user != null) {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tInvokerPortletImpl.clearResponse(\n\t\t\t\tsession, layout.getPrimaryKey(), portlet.getPortletId(),\n\t\t\t\tLanguageUtil.getLanguageId(request));\n\t\t}\n\n\t\tprocessPublicRenderParameters(request, layout, portlet);\n\n\t\tif (themeDisplay.isLifecycleRender() ||\n\t\t\tthemeDisplay.isLifecycleResource()) {\n\n\t\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\t\tif (layout.isTypeControlPanel() &&\n\t\t\t\t((windowState == null) ||\n\t\t\t\t\twindowState.equals(WindowState.NORMAL) ||\n\t\t\t\t\tValidator.isNull(windowState.toString()))) {\n\n\t\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t\t}\n\n\t\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\t\tPortalUtil.updateWindowState(\n\t\t\t\tportlet.getPortletId(), user, layout, windowState, request);\n\n\t\t\tPortalUtil.updatePortletMode(\n\t\t\t\tportlet.getPortletId(), user, layout, portletMode, request);\n\t\t}\n\t}","commit_id":"fbaec6e2b655de7541c45d40d432482cd99d765e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _doProcessAction(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tString portletId = portlet.getPortletId();\n\n\t\tif (!PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\tString url = request.getRequestURI().toString();\n\t\t\t\tLastPath lastPath = (LastPath) request.getAttribute(\n\t\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\t\tif (lastPath != null) {\n\t\t\t\t\tStringBundler lastPathSB = new StringBundler(4);\n\n\t\t\t\t\tlastPathSB.append(PortalUtil.getPortalURL(request));\n\t\t\t\t\tlastPathSB.append(lastPath.getContextPath());\n\t\t\t\t\tlastPathSB.append(lastPath.getPath());\n\n\t\t\t\t\turl = lastPathSB.toString();\n\t\t\t\t}\n\n\t\t\t\t_log.error(\"Portlet default resource check denied to execute \" +\n\t\t\t\t\t\"processAction [portletId, page url]: [\" + portletId +\n\t\t\t\t\t\", \" + url + \"]\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\tif (layout.isTypeControlPanel() &&\n\t\t\t((windowState == null) || windowState.equals(WindowState.NORMAL) ||\n\t\t\t Validator.isNull(windowState.toString()))) {\n\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portletId);\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tString contentType = request.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t}\n\n\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\ttry {\n\t\t\tif ((contentType != null) &&\n\t\t\t\tcontentType.startsWith(ContentTypes.MULTIPART_FORM_DATA)) {\n\n\t\t\t\tPortletConfigImpl invokerPortletConfigImpl =\n\t\t\t\t\t(PortletConfigImpl)invokerPortlet.getPortletConfig();\n\n\t\t\t\tif (invokerPortlet.isStrutsPortlet() ||\n\t\t\t\t\t((invokerPortletConfigImpl != null) &&\n\t\t\t\t\t\t!invokerPortletConfigImpl.isWARFile())) {\n\n\t\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\t\trequest);\n\n\t\t\t\t\trequest = uploadServletRequest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.AUTH_TOKEN_CHECK_ENABLED &&\n\t\t\t\tinvokerPortlet.isCheckAuthToken()) {\n\n\t\t\t\tAuthTokenUtil.check(request);\n\t\t\t}\n\n\t\t\tActionRequestImpl actionRequestImpl = ActionRequestFactory.create(\n\t\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tActionResponseImpl actionResponseImpl =\n\t\t\t\tActionResponseFactory.create(\n\t\t\t\t\tactionRequestImpl, response, portletId, user, layout,\n\t\t\t\t\twindowState, portletMode);\n\n\t\t\tactionRequestImpl.defineObjects(portletConfig, actionResponseImpl);\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, layout, portlet, portletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.processAction(\n\t\t\t\t\tactionRequestImpl, actionResponseImpl);\n\n\t\t\t\tactionResponseImpl.transferHeaders(response);\n\t\t\t}\n\n\t\t\tRenderParametersPool.put(\n\t\t\t\trequest, layout.getPlid(), portletId,\n\t\t\t\tactionResponseImpl.getRenderParameterMap());\n\n\t\t\tList<Event> events = actionResponseImpl.getEvents();\n\n\t\t\tif (!events.isEmpty()) {\n\t\t\t\tprocessEvents(request, response, events);\n\n\t\t\t\tactionRequestImpl.defineObjects(\n\t\t\t\t\tportletConfig, actionResponseImpl);\n\t\t\t}\n\n\t\t\tString redirectLocation = actionResponseImpl.getRedirectLocation();\n\n\t\t\tif (Validator.isNotNull(redirectLocation)) {\n\t\t\t\tresponse.sendRedirect(redirectLocation);\n\t\t\t}\n\t\t\telse if (portlet.isActionURLRedirect()) {\n\t\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\t\tactionRequestImpl, actionRequestImpl.getPortletName(),\n\t\t\t\t\tlayout.getPlid(), PortletRequest.RENDER_PHASE);\n\n\t\t\t\tMap<String, String[]> renderParameters =\n\t\t\t\t\tactionResponseImpl.getRenderParameterMap();\n\n\t\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tString[] value = entry.getValue();\n\n\t\t\t\t\tportletURL.setParameter(key, value);\n\t\t\t\t}\n\n\t\t\t\tresponse.sendRedirect(portletURL.toString());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadServletRequest != null) {\n\t\t\t\tuploadServletRequest.cleanUp();\n\t\t\t}\n\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","id":51222,"modified_method":"private void _doProcessAction(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tif (!PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject processAction for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\tif (layout.isTypeControlPanel() &&\n\t\t\t((windowState == null) || windowState.equals(WindowState.NORMAL) ||\n\t\t\t Validator.isNull(windowState.toString()))) {\n\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tString contentType = request.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t}\n\n\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\ttry {\n\t\t\tif ((contentType != null) &&\n\t\t\t\tcontentType.startsWith(ContentTypes.MULTIPART_FORM_DATA)) {\n\n\t\t\t\tPortletConfigImpl invokerPortletConfigImpl =\n\t\t\t\t\t(PortletConfigImpl)invokerPortlet.getPortletConfig();\n\n\t\t\t\tif (invokerPortlet.isStrutsPortlet() ||\n\t\t\t\t\t((invokerPortletConfigImpl != null) &&\n\t\t\t\t\t\t!invokerPortletConfigImpl.isWARFile())) {\n\n\t\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\t\trequest);\n\n\t\t\t\t\trequest = uploadServletRequest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.AUTH_TOKEN_CHECK_ENABLED &&\n\t\t\t\tinvokerPortlet.isCheckAuthToken()) {\n\n\t\t\t\tAuthTokenUtil.check(request);\n\t\t\t}\n\n\t\t\tActionRequestImpl actionRequestImpl = ActionRequestFactory.create(\n\t\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tActionResponseImpl actionResponseImpl =\n\t\t\t\tActionResponseFactory.create(\n\t\t\t\t\tactionRequestImpl, response, portlet.getPortletId(), user,\n\t\t\t\t\tlayout, windowState, portletMode);\n\n\t\t\tactionRequestImpl.defineObjects(portletConfig, actionResponseImpl);\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, layout, portlet, portletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.processAction(\n\t\t\t\t\tactionRequestImpl, actionResponseImpl);\n\n\t\t\t\tactionResponseImpl.transferHeaders(response);\n\t\t\t}\n\n\t\t\tRenderParametersPool.put(\n\t\t\t\trequest, layout.getPlid(), portlet.getPortletId(),\n\t\t\t\tactionResponseImpl.getRenderParameterMap());\n\n\t\t\tList<Event> events = actionResponseImpl.getEvents();\n\n\t\t\tif (!events.isEmpty()) {\n\t\t\t\tprocessEvents(request, response, events);\n\n\t\t\t\tactionRequestImpl.defineObjects(\n\t\t\t\t\tportletConfig, actionResponseImpl);\n\t\t\t}\n\n\t\t\tString redirectLocation = actionResponseImpl.getRedirectLocation();\n\n\t\t\tif (Validator.isNotNull(redirectLocation)) {\n\t\t\t\tresponse.sendRedirect(redirectLocation);\n\t\t\t}\n\t\t\telse if (portlet.isActionURLRedirect()) {\n\t\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\t\tactionRequestImpl, actionRequestImpl.getPortletName(),\n\t\t\t\t\tlayout.getPlid(), PortletRequest.RENDER_PHASE);\n\n\t\t\t\tMap<String, String[]> renderParameters =\n\t\t\t\t\tactionResponseImpl.getRenderParameterMap();\n\n\t\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tString[] value = entry.getValue();\n\n\t\t\t\t\tportletURL.setParameter(key, value);\n\t\t\t\t}\n\n\t\t\t\tresponse.sendRedirect(portletURL.toString());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadServletRequest != null) {\n\t\t\t\tuploadServletRequest.cleanUp();\n\t\t\t}\n\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","commit_id":"fbaec6e2b655de7541c45d40d432482cd99d765e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _doServeResource(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tString portletId = portlet.getPortletId();\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tif (!PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\tString url = request.getRequestURI().toString();\n\t\t\t\tLastPath lastPath = (LastPath) request.getAttribute(\n\t\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\t\tif (lastPath != null) {\n\t\t\t\t\tStringBundler lastPathSB = new StringBundler(4);\n\n\t\t\t\t\tlastPathSB.append(PortalUtil.getPortalURL(request));\n\t\t\t\t\tlastPathSB.append(lastPath.getContextPath());\n\t\t\t\t\tlastPathSB.append(lastPath.getPath());\n\n\t\t\t\t\turl = lastPathSB.toString();\n\t\t\t\t}\n\n\t\t\t\t_log.error(\"Portlet default resource check denied to execute \" +\n\t\t\t\t\t\"serveResource [portletId, page url]: [\" + portletId +\n\t\t\t\t\t\", \" + url + \"]\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tWindowState windowState =\n\t\t\t(WindowState)request.getAttribute(WebKeys.WINDOW_STATE);\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portletId);\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tString portletPrimaryKey = PortletPermissionUtil.getPrimaryKey(\n\t\t\tlayout.getPlid(), portletId);\n\n\t\tportletDisplay.setId(portletId);\n\t\tportletDisplay.setRootPortletId(portlet.getRootPortletId());\n\t\tportletDisplay.setInstanceId(portlet.getInstanceId());\n\t\tportletDisplay.setResourcePK(portletPrimaryKey);\n\t\tportletDisplay.setPortletName(portletConfig.getPortletName());\n\t\tportletDisplay.setNamespace(PortalUtil.getPortletNamespace(portletId));\n\n\t\tWebDAVStorage webDAVStorage = portlet.getWebDAVStorageInstance();\n\n\t\tif (webDAVStorage != null) {\n\t\t\tportletDisplay.setWebDAVEnabled(true);\n\t\t}\n\t\telse {\n\t\t\tportletDisplay.setWebDAVEnabled(false);\n\t\t}\n\n\t\tResourceRequestImpl resourceRequestImpl = ResourceRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\tResourceResponseImpl resourceResponseImpl =\n\t\t\tResourceResponseFactory.create(\n\t\t\t\tresourceRequestImpl, response, portletId, companyId);\n\n\t\tresourceRequestImpl.defineObjects(portletConfig, resourceResponseImpl);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tresourceRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, layout, portlet, portletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.serveResource(\n\t\t\t\t\tresourceRequestImpl, resourceResponseImpl);\n\n\t\t\t\tresourceResponseImpl.transferHeaders(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","id":51223,"modified_method":"private void _doServeResource(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tif (!PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject serveResource for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tWindowState windowState =\n\t\t\t(WindowState)request.getAttribute(WebKeys.WINDOW_STATE);\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (PortalUtil.isAllowAddPortletDefaultResource(request, portlet)) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tString portletPrimaryKey = PortletPermissionUtil.getPrimaryKey(\n\t\t\tlayout.getPlid(), portlet.getPortletId());\n\n\t\tportletDisplay.setId(portlet.getPortletId());\n\t\tportletDisplay.setRootPortletId(portlet.getRootPortletId());\n\t\tportletDisplay.setInstanceId(portlet.getInstanceId());\n\t\tportletDisplay.setResourcePK(portletPrimaryKey);\n\t\tportletDisplay.setPortletName(portletConfig.getPortletName());\n\t\tportletDisplay.setNamespace(\n\t\t\tPortalUtil.getPortletNamespace(portlet.getPortletId()));\n\n\t\tWebDAVStorage webDAVStorage = portlet.getWebDAVStorageInstance();\n\n\t\tif (webDAVStorage != null) {\n\t\t\tportletDisplay.setWebDAVEnabled(true);\n\t\t}\n\t\telse {\n\t\t\tportletDisplay.setWebDAVEnabled(false);\n\t\t}\n\n\t\tResourceRequestImpl resourceRequestImpl = ResourceRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\tResourceResponseImpl resourceResponseImpl =\n\t\t\tResourceResponseFactory.create(\n\t\t\t\tresourceRequestImpl, response, portlet.getPortletId(),\n\t\t\t\tcompanyId);\n\n\t\tresourceRequestImpl.defineObjects(portletConfig, resourceResponseImpl);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tresourceRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, layout, portlet, portletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.serveResource(\n\t\t\t\t\tresourceRequestImpl, resourceResponseImpl);\n\n\t\t\t\tresourceResponseImpl.transferHeaders(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","commit_id":"fbaec6e2b655de7541c45d40d432482cd99d765e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addPortletAuthToken(StringBundler sb, Key key) {\n\t\tif (!PropsValues.PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpServletRequest request = PortalUtil.getOriginalServletRequest(\n\t\t\t_request);\n\n\t\tString ppauth = ParamUtil.getString(request, \"p_p_auth\");\n\n\t\tString actualPortletAuthenticationToken = AuthTokenUtil.getToken(\n\t\t\t_request, _plid, _portletId);\n\n\t\tif (Validator.isNotNull(ppauth) &&\n\t\t\tppauth.equals(actualPortletAuthenticationToken)) {\n\n\t\t\tsb.append(\"p_p_auth\");\n\t\t\tsb.append(StringPool.EQUAL);\n\t\t\tsb.append(processValue(key, ppauth));\n\t\t\tsb.append(StringPool.AMPERSAND);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortlet portlet = (Portlet)_request.getAttribute(\n\t\t\tWebKeys.RENDER_PORTLET);\n\n\t\tif ((portlet != null) &&\n\t\t\t(portlet.getPortletId().equals(_portletId) ||\n\t\t\t portlet.getPortletId().equals(PortletKeys.CONTROL_PANEL_MENU) ||\n\t\t\t (!_portlet.isAddDefaultResource()))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSet<String> portletAddDefaultResourceCheckWhiteList =\n\t\t\tPortalUtil.getPortletAddDefaultResourceCheckWhitelist();\n\n\t\tif (portletAddDefaultResourceCheckWhiteList.contains(_portletId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsb.append(\"p_p_auth\");\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(processValue(key, actualPortletAuthenticationToken));\n\t\tsb.append(StringPool.AMPERSAND);\n\t}","id":51224,"modified_method":"protected void addPortletAuthToken(StringBundler sb, Key key) {\n\t\tif (!PropsValues.PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpServletRequest request = PortalUtil.getOriginalServletRequest(\n\t\t\t_request);\n\n\t\tString ppauth = ParamUtil.getString(request, \"p_p_auth\");\n\n\t\tString actualPortletAuthenticationToken = AuthTokenUtil.getToken(\n\t\t\t_request, _plid, _portletId);\n\n\t\tif (Validator.isNotNull(ppauth) &&\n\t\t\tppauth.equals(actualPortletAuthenticationToken)) {\n\n\t\t\tsb.append(\"p_p_auth\");\n\t\t\tsb.append(StringPool.EQUAL);\n\t\t\tsb.append(processValue(key, ppauth));\n\t\t\tsb.append(StringPool.AMPERSAND);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortlet portlet = (Portlet)_request.getAttribute(\n\t\t\tWebKeys.RENDER_PORTLET);\n\n\t\tif (portlet != null) {\n\t\t\tString portletId = portlet.getPortletId();\n\n\t\t\tif (portletId.equals(_portletId) ||\n\t\t\t\tportletId.equals(PortletKeys.CONTROL_PANEL_MENU) ||\n\t\t\t\t!_portlet.isAddDefaultResource()) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tSet<String> portletAddDefaultResourceCheckWhiteList =\n\t\t\tPortalUtil.getPortletAddDefaultResourceCheckWhitelist();\n\n\t\tif (portletAddDefaultResourceCheckWhiteList.contains(_portletId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsb.append(\"p_p_auth\");\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(processValue(key, actualPortletAuthenticationToken));\n\t\tsb.append(StringPool.AMPERSAND);\n\t}","commit_id":"fbaec6e2b655de7541c45d40d432482cd99d765e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void subscribe(\n\t\t\tLiferayPortletConfig liferayPortletConfig,\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletId = liferayPortletConfig.getPortletId();\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, themeDisplay.getPlid(),\n\t\t\t\tportletId);\n\n\t\tAssetPublisherUtil.subscribe(\n\t\t\tthemeDisplay.getUserId(), themeDisplay.getScopeGroupId(),\n\t\t\tportletPreferences.getPortletPreferencesId(), portletId,\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","id":51225,"modified_method":"private void subscribe(\n\t\t\tLiferayPortletConfig liferayPortletConfig,\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, themeDisplay.getPlid(),\n\t\t\t\tliferayPortletConfig.getPortletId());\n\n\t\tAssetPublisherUtil.subscribe(\n\t\t\tthemeDisplay.getUserId(), themeDisplay.getScopeGroupId(),\n\t\t\tportletPreferences.getPortletPreferencesId(),\n\t\t\tliferayPortletConfig.getPortletId(),\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","commit_id":"2b97fc3ed9c216523fcad1f9023d1d5a03205585","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void unsubscribe(\n\t\t\tLiferayPortletConfig liferayPortletConfig,\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletId = liferayPortletConfig.getPortletId();\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, themeDisplay.getPlid(),\n\t\t\t\tportletId);\n\n\t\tAssetPublisherUtil.unsubscribe(\n\t\t\tthemeDisplay.getUserId(),\n\t\t\tportletPreferences.getPortletPreferencesId(), portletId,\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","id":51226,"modified_method":"private void unsubscribe(\n\t\t\tLiferayPortletConfig liferayPortletConfig,\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, themeDisplay.getPlid(),\n\t\t\t\tliferayPortletConfig.getPortletId());\n\n\t\tAssetPublisherUtil.unsubscribe(\n\t\t\tthemeDisplay.getUserId(),\n\t\t\tportletPreferences.getPortletPreferencesId(),\n\t\t\tliferayPortletConfig.getPortletId(),\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","commit_id":"2b97fc3ed9c216523fcad1f9023d1d5a03205585","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tactionRequest = ActionUtil.getWrappedActionRequest(actionRequest, null);\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = ActionUtil.getPortlet(actionRequest);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, PrincipalException.class.getName());\n\n\t\t\tsetForward(actionRequest, \"portlet.portlet_configuration.error\");\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\t\taddTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tvalidateFile(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"copy_from_live\")) {\n\t\t\t\t\tStagingUtil.copyFromLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.DELETE_TEMP)) {\n\t\t\t\t\tdeleteTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.EXPORT)) {\n\t\t\t\t\texportData(actionRequest, actionResponse, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.IMPORT)) {\n\t\t\t\t\timportData(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"publish_to_live\")) {\n\t\t\t\t\tStagingUtil.publishToLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\n\t\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\t\tactionRequest, 0, false, plid, portlet.getPortletId());\n\n\t\t\t\tDate startDate = dateRange.getStartDate();\n\n\t\t\t\tif (startDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"startDate\", String.valueOf(startDate.getTime()));\n\t\t\t\t}\n\n\t\t\t\tDate endDate = dateRange.getEndDate();\n\n\t\t\t\tif (endDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"endDate\", String.valueOf(endDate.getTime()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (cmd.equals(Constants.ADD_TEMP) ||\n\t\t\t\tcmd.equals(Constants.DELETE_TEMP)) {\n\n\t\t\t\thandleUploadException(\n\t\t\t\t\tportletConfig, actionRequest, actionResponse,\n\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((e instanceof LARFileException) ||\n\t\t\t\t\t(e instanceof LARFileSizeException) ||\n\t\t\t\t\t(e instanceof LARTypeException) ||\n\t\t\t\t\t(e instanceof LocaleException) ||\n\t\t\t\t\t(e instanceof NoSuchLayoutException) ||\n\t\t\t\t\t(e instanceof PortletIdException) ||\n\t\t\t\t\t(e instanceof PrincipalException) ||\n\t\t\t\t\t(e instanceof StructureDuplicateStructureKeyException) ||\n\t\t\t\t\t(e instanceof RecordSetDuplicateRecordSetKeyException)) {\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(e, e);\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, ExportImportAction.class.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":51227,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tactionRequest = ActionUtil.getWrappedActionRequest(actionRequest, null);\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = ActionUtil.getPortlet(actionRequest);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, PrincipalException.class.getName());\n\n\t\t\tsetForward(actionRequest, \"portlet.portlet_configuration.error\");\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\t\taddTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tvalidateFile(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"copy_from_live\")) {\n\t\t\t\t\tStagingUtil.copyFromLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.DELETE_TEMP)) {\n\t\t\t\t\tdeleteTempFileEntry(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.EXPORT)) {\n\t\t\t\t\texportData(actionRequest, actionResponse, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(Constants.IMPORT)) {\n\t\t\t\t\timportData(\n\t\t\t\t\t\tactionRequest, actionResponse,\n\t\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t\telse if (cmd.equals(\"publish_to_live\")) {\n\t\t\t\t\tStagingUtil.publishToLive(actionRequest, portlet);\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\n\t\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\t\tactionRequest, 0, false, plid, portlet.getPortletId());\n\n\t\t\t\tDate startDate = dateRange.getStartDate();\n\n\t\t\t\tif (startDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"startDate\", String.valueOf(startDate.getTime()));\n\t\t\t\t}\n\n\t\t\t\tDate endDate = dateRange.getEndDate();\n\n\t\t\t\tif (endDate != null) {\n\t\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\t\"endDate\", String.valueOf(endDate.getTime()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (cmd.equals(Constants.ADD_TEMP) ||\n\t\t\t\tcmd.equals(Constants.DELETE_TEMP)) {\n\n\t\t\t\thandleUploadException(\n\t\t\t\t\tportletConfig, actionRequest, actionResponse,\n\t\t\t\t\tExportImportHelper.TEMP_FOLDER_NAME +\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((e instanceof LARFileException) ||\n\t\t\t\t\t(e instanceof LARFileSizeException) ||\n\t\t\t\t\t(e instanceof LARTypeException) ||\n\t\t\t\t\t(e instanceof LocaleException) ||\n\t\t\t\t\t(e instanceof NoSuchLayoutException) ||\n\t\t\t\t\t(e instanceof PortletIdException) ||\n\t\t\t\t\t(e instanceof PrincipalException) ||\n\t\t\t\t\t(e instanceof StructureDuplicateStructureKeyException) ||\n\t\t\t\t\t(e instanceof RecordSetDuplicateRecordSetKeyException)) {\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(e, e);\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, ExportImportAction.class.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b942cc7fe425e6364dbd34bf7af8c740789777fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportData(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\t\tString fileName = ParamUtil.getString(\n\t\t\t\tactionRequest, \"exportFileName\");\n\n\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\tactionRequest, groupId, false, plid, portlet.getPortletId());\n\n\t\t\tfile = LayoutServiceUtil.exportPortletInfoAsFile(\n\t\t\t\tplid, groupId, portlet.getPortletId(),\n\t\t\t\tactionRequest.getParameterMap(), dateRange.getStartDate(),\n\t\t\t\tdateRange.getEndDate());\n\n\t\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\t\tactionRequest);\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\tactionResponse);\n\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, new FileInputStream(file),\n\t\t\t\tContentTypes.APPLICATION_ZIP);\n\n\t\t\tsetForward(actionRequest, ActionConstants.COMMON_NULL);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":51228,"modified_method":"protected void exportData(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\t\tString fileName = ParamUtil.getString(\n\t\t\t\tactionRequest, \"exportFileName\");\n\n\t\t\tDateRange dateRange = ExportImportHelperUtil.getDateRange(\n\t\t\t\tactionRequest, groupId, false, plid, portlet.getPortletId());\n\n\t\t\tLayoutServiceUtil.exportPortletInfoAsFileInBackground(\n\t\t\t\tportlet.getPortletId(), plid, groupId, portlet.getPortletId(),\n\t\t\t\tactionRequest.getParameterMap(), dateRange.getStartDate(),\n\t\t\t\tdateRange.getEndDate(), fileName);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t}\n\t}","commit_id":"b942cc7fe425e6364dbd34bf7af8c740789777fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String generate(Link link)\n    {\n        String result;\n\n        String format = this.configuration.getLinkLabelFormat();\n        DocumentName documentName = this.bridge.getDocumentName(link.getReference());\n        \n        // Replace %w with the wiki name\n        result = format.replace(\"%w\", documentName.getWiki()); \n        \n        // Replace %p with the page name\n        result = result.replace(\"%p\", documentName.getPage()); \n\n        // Replace %s with the space name\n        result = result.replace(\"%s\", documentName.getSpace());\n\n        // Replace %P with the page name in camel case + space\n        if (result.indexOf(\"%P\") > -1) {\n            String normalizedPage = documentName.getPage().replaceAll(\"([a-z])([A-Z])\", \"$1 $2\");\n            result = result.replace(\"%P\", normalizedPage);\n        }\n        \n        // Replace %t with the document title and fall back to %p if the title is null or empty\n        if (result.indexOf(\"%t\") > -1) {\n            try {\n                DocumentModelBridge document = this.bridge.getDocument(link.getReference());\n                if (!StringUtils.isBlank(document.getTitle())) {\n                    result = result.replace(\"%t\", document.getTitle());\n                } else {\n                    result = documentName.getPage();\n                }\n            } catch (Exception e) {\n                // If there's an error (meaning the document cannot be retrieved from the database for some reason)\n                // the fall back to displaying %p\n                result = documentName.getPage();\n            }\n        }\n        \n        return result;\n    }","id":51229,"modified_method":"public String generate(Link link)\n    {\n        return link.getReference();\n    }","commit_id":"c6b23f3bb0adaf4bbc658d6c8177edf794eec385","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.rendering.renderer.PrintRendererFactory#createRenderer(org.xwiki.rendering.parser.Syntax,\n     *      org.xwiki.rendering.renderer.printer.WikiPrinter)\n     */\n    public PrintRenderer createRenderer(Syntax targetSyntax, WikiPrinter printer)\n    {\n        PrintRenderer result;\n\n        if (targetSyntax.toIdString().equals(\"xhtml/1.0\")) {\n            result = new XHTMLRenderer(printer, this.xhtmlRendererFactory.createXHTMLLinkRenderer(),\n                this.xhtmlRendererFactory.createXHTMLImageRenderer());\n        } else if (targetSyntax.toIdString().equals(\"xwiki/2.0\")) {\n            result = new XWikiSyntaxRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"event/1.0\")) {\n            result = new EventsRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"tex/1.0\")) {\n            result = new TexRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"plain/1.0\")) {\n            result = new PlainTextRenderer(printer, linkLabelGenerator);\n        } else {\n            throw new RuntimeException(\"No renderer found for target syntax [\" + targetSyntax + \"]\");\n        }\n\n        return result;\n    }","id":51230,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.rendering.renderer.PrintRendererFactory#createRenderer(org.xwiki.rendering.parser.Syntax,\n     *      org.xwiki.rendering.renderer.printer.WikiPrinter)\n     */\n    public PrintRenderer createRenderer(Syntax targetSyntax, WikiPrinter printer)\n    {\n        PrintRenderer result;\n\n        if (targetSyntax.toIdString().equals(\"xhtml/1.0\")) {\n            result = new XHTMLRenderer(printer, this.xhtmlRendererFactory.createXHTMLLinkRenderer(),\n                this.xhtmlRendererFactory.createXHTMLImageRenderer());\n        } else if (targetSyntax.toIdString().equals(\"xwiki/2.0\")) {\n            result = new XWikiSyntaxRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"event/1.0\")) {\n            result = new EventsRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"tex/1.0\")) {\n            result = new TexRenderer(printer);\n        } else if (targetSyntax.toIdString().equals(\"plain/1.0\")) {\n            result = new PlainTextRenderer(printer, this.linkLabelGenerator);\n        } else {\n            throw new RuntimeException(\"No renderer found for target syntax [\" + targetSyntax + \"]\");\n        }\n\n        return result;\n    }","commit_id":"c6b23f3bb0adaf4bbc658d6c8177edf794eec385","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see XHTMLRendererFactory#createXHTMLLinkRenderer()\n     */\n    public XHTMLLinkRenderer createXHTMLLinkRenderer()\n    {\n        return new XWikiXHTMLLinkRenderer(this.documentAccessBridge,\n            this.linkLabelGenerator, this.attachmentParser, this.documentNameSerializer);        \n    }","id":51231,"modified_method":"/**\n     * {@inheritDoc}\n     * @see XHTMLRendererFactory#createXHTMLLinkRenderer()\n     */\n    public XHTMLLinkRenderer createXHTMLLinkRenderer()\n    {\n        XHTMLLinkRenderer renderer;\n        try {\n            WikiModel wikiModel = (WikiModel) this.componentManager.lookup(WikiModel.class);\n            renderer = new WikiXHTMLLinkRenderer(wikiModel, this.linkLabelGenerator, this.attachmentParser); \n        } catch (ComponentLookupException e) {\n            // There's no WikiModel implementation available, fall back to the Simple Renderer\n            renderer = new SimpleXHTMLLinkRenderer(); \n        }\n        return renderer; \n    }","commit_id":"c6b23f3bb0adaf4bbc658d6c8177edf794eec385","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see XHTMLRendererFactory#createXHTMLImageRenderer()\n     */\n    public XHTMLImageRenderer createXHTMLImageRenderer()\n    {\n        return new XWikiXHTMLImageRenderer(this.documentAccessBridge);\n    }","id":51232,"modified_method":"/**\n     * {@inheritDoc}\n     * @see XHTMLRendererFactory#createXHTMLImageRenderer()\n     */\n    public XHTMLImageRenderer createXHTMLImageRenderer()\n    {\n        XHTMLImageRenderer renderer;\n        try {\n            WikiModel wikiModel = (WikiModel) this.componentManager.lookup(WikiModel.class);\n            renderer = new WikiXHTMLImageRenderer(wikiModel); \n        } catch (ComponentLookupException e) {\n            // There's no WikiModel implementation available, fall back to the Simple Renderer\n            renderer = new SimpleXHTMLImageRenderer(); \n        }\n        return renderer; \n    }","commit_id":"c6b23f3bb0adaf4bbc658d6c8177edf794eec385","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public RenderingTestSuite(String name) throws Exception\n    {\n        super(name);\n\n        DefaultLinkLabelGenerator linkLabelGenerator = new DefaultLinkLabelGenerator();\n        linkLabelGenerator.setDocumentAccessBridge(new MockDocumentAccessBridge());\n        linkLabelGenerator.setRenderingConfiguration(new DefaultRenderingConfiguration());\n\n        XHTMLRendererFactory xhtmlRendererFactory = new DefaultXHTMLRendererFactory();\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"documentAccessBridge\", new MockDocumentAccessBridge());\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"linkLabelGenerator\", linkLabelGenerator);\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"attachmentParser\", new DefaultAttachmentParser());\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"documentNameSerializer\", new MockDocumentNameSerializer());\n        \n        this.rendererFactory = new DefaultPrintRendererFactory();\n        ReflectionUtils.setFieldValue(this.rendererFactory, \"xhtmlRendererFactory\", xhtmlRendererFactory);\n        ReflectionUtils.setFieldValue(this.rendererFactory, \"linkLabelGenerator\", linkLabelGenerator);\n\n        this.syntaxFactory = new DefaultSyntaxFactory();\n    }","id":51233,"modified_method":"public RenderingTestSuite(String name) throws Exception\n    {\n        super(name);\n\n        XWikiLinkLabelGenerator linkLabelGenerator = new XWikiLinkLabelGenerator();\n        linkLabelGenerator.setDocumentAccessBridge(new MockDocumentAccessBridge());\n        linkLabelGenerator.setRenderingConfiguration(new DefaultRenderingConfiguration());\n\n        XHTMLRendererFactory xhtmlRendererFactory = new DefaultXHTMLRendererFactory();\n        \n        XWikiComponentInitializer initializer = new XWikiComponentInitializer();\n        initializer.getComponentManager().registerComponent(MockDocumentAccessBridge.getComponentDescriptor());\n        initializer.getComponentManager().registerComponent(MockDocumentNameSerializer.getComponentDescriptor());\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"componentManager\", initializer.getComponentManager());\n\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"linkLabelGenerator\", linkLabelGenerator);\n        ReflectionUtils.setFieldValue(xhtmlRendererFactory, \"attachmentParser\", new DefaultAttachmentParser());\n        \n        this.rendererFactory = new DefaultPrintRendererFactory();\n        ReflectionUtils.setFieldValue(this.rendererFactory, \"xhtmlRendererFactory\", xhtmlRendererFactory);\n        ReflectionUtils.setFieldValue(this.rendererFactory, \"linkLabelGenerator\", linkLabelGenerator);\n\n        this.syntaxFactory = new DefaultSyntaxFactory();\n    }","commit_id":"c6b23f3bb0adaf4bbc658d6c8177edf794eec385","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@SuppressWarnings(\"rawtypes\")\r\n\tpublic static Object fromStream(final ODocument iRecord, final Object iPojo, final OEntityManager iEntityManager,\r\n\t\t\tfinal OUserObject2RecordHandler iObj2RecHandler, final String iFetchPlan, final boolean iLazyLoading) {\r\n\t\tOFetchHelper.checkFetchPlanValid(iFetchPlan);\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal Class<?> pojoClass = iPojo.getClass();\r\n\r\n\t\tfinal List<Field> properties = getClassFields(pojoClass);\r\n\r\n\t\tString fieldName;\r\n\t\tObject fieldValue;\r\n\r\n\t\tfinal String idFieldName = setObjectID(iRecord.getIdentity(), iPojo);\r\n\t\tfinal String vFieldName = setObjectVersion(iRecord.getVersion(), iPojo);\r\n\r\n\t\t// CALL BEFORE UNMARSHALLING\r\n\t\tinvokeCallback(iPojo, iRecord, OBeforeDeserialization.class);\r\n\r\n\t\tfinal String[] fieldNames = new String[properties.size()];\r\n\r\n\t\t// BIND BASIC FIELDS, LINKS WILL BE BOUND BY THE FETCH API\r\n\t\tint f = 0;\r\n\t\tfor (Field p : properties) {\r\n\t\t\tfieldName = p.getName();\r\n\t\t\tfieldNames[f++] = fieldName;\r\n\r\n\t\t\tif (fieldName.equals(idFieldName) || fieldName.equals(vFieldName))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif (iRecord.containsField(fieldName)) {\r\n\t\t\t\t// BIND ONLY THE SPECIFIED FIELDS\r\n\t\t\t\tfieldValue = iRecord.field(fieldName);\r\n\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof ODocument)\r\n\t\t\t\t\t\t|| (fieldValue instanceof Collection<?> && (((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument)))\r\n\t\t\t\t\t\t|| (!(fieldValue instanceof Map<?, ?>) || ((Map<?, ?>) fieldValue).size() == 0 || !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))) {\r\n\r\n\t\t\t\t\tfinal Class<?> genericTypeClass = OReflectionHelper.getGenericMultivalueType(p);\r\n\r\n\t\t\t\t\tif (genericTypeClass != null)\r\n\t\t\t\t\t\tif (genericTypeClass.isEnum()) {\r\n\t\t\t\t\t\t\t// TRANSFORM THE MULTI-VALUE\r\n\t\t\t\t\t\t\tif (fieldValue instanceof List) {\r\n\t\t\t\t\t\t\t\t// LIST: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal List<Object> list = (List<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (int i = 0; i < list.size(); ++i) {\r\n\t\t\t\t\t\t\t\t\tv = list.get(i);\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tlist.set(i, v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Set) {\r\n\t\t\t\t\t\t\t\t// SET: CREATE A TEMP SET TO WORK WITH ITEMS\r\n\t\t\t\t\t\t\t\tfinal Set<Object> newColl = new HashSet<Object>();\r\n\t\t\t\t\t\t\t\tfinal Set<Object> set = (Set<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tfor (Object v : set) {\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tnewColl.add(v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tsetFieldValue(iPojo, fieldName, newColl);\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Map) {\r\n\t\t\t\t\t\t\t\t// MAP: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal Map<String, Object> map = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (Entry<String, ?> entry : map.entrySet()) {\r\n\t\t\t\t\t\t\t\t\tv = entry.getValue();\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tmap.put(entry.getKey(), v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TRANSFORM THE MULTI-VALUE\r\n\t\t\t\t\t\t\tif (fieldValue instanceof List) {\r\n\t\t\t\t\t\t\t\t// LIST: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal List<Object> list = (List<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (int i = 0; i < list.size(); ++i) {\r\n\t\t\t\t\t\t\t\t\tv = list.get(i);\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tlist.set(i, unserializeFieldValue(genericTypeClass, v));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Set) {\r\n\t\t\t\t\t\t\t\t// SET: CREATE A TEMP SET TO WORK WITH ITEMS\r\n\t\t\t\t\t\t\t\tfinal Set<Object> newColl = new HashSet<Object>();\r\n\t\t\t\t\t\t\t\tfinal Set<Object> set = (Set<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tfor (Object v : set)\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tnewColl.add(unserializeFieldValue(genericTypeClass, v));\r\n\r\n\t\t\t\t\t\t\t\tsetFieldValue(iPojo, fieldName, newColl);\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Map) {\r\n\t\t\t\t\t\t\t\t// MAP: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal Map<String, Object> map = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (Entry<String, ?> entry : map.entrySet()) {\r\n\t\t\t\t\t\t\t\t\tv = entry.getValue();\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tmap.put(entry.getKey(), unserializeFieldValue(genericTypeClass, v));\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfinal Type type = p.getGenericType();\r\n\t\t\t\t\tsetFieldValue(iPojo, fieldName,\r\n\t\t\t\t\t\t\tunserializeFieldValue((Class<?>) (type != null && type instanceof Class<?> ? type : null), fieldValue));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfinal OFetchListener listener = new OObjectFetchListener();\r\n\t\tfinal OFetchContext context = new OObjectFetchContext(iFetchPlan, iLazyLoading, iEntityManager, iObj2RecHandler);\r\n\t\t// BIND LINKS FOLLOWING THE FETCHING PLAN\r\n\t\tOFetchHelper.fetch(iRecord, iPojo, OFetchHelper.buildFetchPlan(iFetchPlan), listener, context);\r\n\r\n\t\t// CALL AFTER UNMARSHALLING\r\n\t\tinvokeCallback(iPojo, iRecord, OAfterDeserialization.class);\r\n\r\n\t\tOProfiler.getInstance().stopChrono(\"Object.fromStream\", timer);\r\n\r\n\t\treturn iPojo;\r\n\t}","id":51234,"modified_method":"@SuppressWarnings(\"rawtypes\")\r\n\tpublic static Object fromStream(final ODocument iRecord, final Object iPojo, final OEntityManager iEntityManager,\r\n\t\t\tfinal OUserObject2RecordHandler iObj2RecHandler, final String iFetchPlan, final boolean iLazyLoading) {\r\n\t\tOFetchHelper.checkFetchPlanValid(iFetchPlan);\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal Class<?> pojoClass = iPojo.getClass();\r\n\r\n\t\tfinal List<Field> properties = getClassFields(pojoClass);\r\n\r\n\t\tString fieldName;\r\n\t\tObject fieldValue;\r\n\r\n\t\tfinal String idFieldName = setObjectID(iRecord.getIdentity(), iPojo);\r\n\t\tfinal String vFieldName = setObjectVersion(iRecord.getVersion(), iPojo);\r\n\r\n\t\t// CALL BEFORE UNMARSHALLING\r\n\t\tinvokeCallback(iPojo, iRecord, OBeforeDeserialization.class);\r\n\r\n\t\tfinal String[] fieldNames = new String[properties.size()];\r\n\r\n\t\t// BIND BASIC FIELDS, LINKS WILL BE BOUND BY THE FETCH API\r\n\t\tint f = 0;\r\n\t\tfor (Field p : properties) {\r\n\t\t\tfieldName = p.getName();\r\n\t\t\tfieldNames[f++] = fieldName;\r\n\r\n\t\t\tif (fieldName.equals(idFieldName) || fieldName.equals(vFieldName))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif (iRecord.containsField(fieldName)) {\r\n\t\t\t\t// BIND ONLY THE SPECIFIED FIELDS\r\n\t\t\t\tfieldValue = iRecord.field(fieldName);\r\n\r\n\t\t\t\tObject value = fieldValue;\r\n\t\t\t\tType type = null;\r\n\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof ODocument)\r\n\t\t\t\t\t\t|| (fieldValue instanceof Collection<?> && (((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument)))\r\n\t\t\t\t\t\t|| (!(fieldValue instanceof Map<?, ?>) || ((Map<?, ?>) fieldValue).size() == 0 || !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))) {\r\n\r\n\t\t\t\t\tfinal Class<?> genericTypeClass = OReflectionHelper.getGenericMultivalueType(p);\r\n\r\n\t\t\t\t\tif (genericTypeClass != null)\r\n\t\t\t\t\t\tif (genericTypeClass.isEnum()) {\r\n\t\t\t\t\t\t\t// TRANSFORM THE MULTI-VALUE\r\n\t\t\t\t\t\t\tif (fieldValue instanceof List) {\r\n\t\t\t\t\t\t\t\t// LIST: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal List<Object> list = (List<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (int i = 0; i < list.size(); ++i) {\r\n\t\t\t\t\t\t\t\t\tv = list.get(i);\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tlist.set(i, v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvalue = list;\r\n\t\t\t\t\t\t\t\ttype = List.class;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Set) {\r\n\t\t\t\t\t\t\t\t// SET: CREATE A TEMP SET TO WORK WITH ITEMS\r\n\t\t\t\t\t\t\t\tfinal Set<Object> newColl = new HashSet<Object>();\r\n\t\t\t\t\t\t\t\tfinal Set<Object> set = (Set<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tfor (Object v : set) {\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tnewColl.add(v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tvalue = newColl;\r\n\t\t\t\t\t\t\t\ttype = Set.class;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Map) {\r\n\t\t\t\t\t\t\t\t// MAP: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal Map<String, Object> map = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (Entry<String, ?> entry : map.entrySet()) {\r\n\t\t\t\t\t\t\t\t\tv = entry.getValue();\r\n\t\t\t\t\t\t\t\t\tif (v != null) {\r\n\t\t\t\t\t\t\t\t\t\tv = Enum.valueOf((Class<Enum>) genericTypeClass, v.toString());\r\n\t\t\t\t\t\t\t\t\t\tmap.put(entry.getKey(), v);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttype = Map.class;\r\n\t\t\t\t\t\t\t\tvalue = map;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TRANSFORM THE MULTI-VALUE\r\n\t\t\t\t\t\t\tif (fieldValue instanceof List) {\r\n\t\t\t\t\t\t\t\t// LIST: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal List<Object> list = (List<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (int i = 0; i < list.size(); ++i) {\r\n\t\t\t\t\t\t\t\t\tv = list.get(i);\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tlist.set(i, unserializeFieldValue(genericTypeClass, v));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvalue = list;\r\n\t\t\t\t\t\t\t\ttype = List.class;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Set) {\r\n\t\t\t\t\t\t\t\t// SET: CREATE A TEMP SET TO WORK WITH ITEMS\r\n\t\t\t\t\t\t\t\tfinal Set<Object> newColl = new HashSet<Object>();\r\n\t\t\t\t\t\t\t\tfinal Set<Object> set = (Set<Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tfor (Object v : set)\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tnewColl.add(unserializeFieldValue(genericTypeClass, v));\r\n\r\n\t\t\t\t\t\t\t\tvalue = newColl;\r\n\t\t\t\t\t\t\t\ttype = Set.class;\r\n\t\t\t\t\t\t\t} else if (fieldValue instanceof Map) {\r\n\t\t\t\t\t\t\t\t// MAP: TRANSFORM EACH SINGLE ITEM\r\n\t\t\t\t\t\t\t\tfinal Map<String, Object> map = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\t\t\t\tObject v;\r\n\t\t\t\t\t\t\t\tfor (Entry<String, ?> entry : map.entrySet()) {\r\n\t\t\t\t\t\t\t\t\tv = entry.getValue();\r\n\t\t\t\t\t\t\t\t\tif (v != null)\r\n\t\t\t\t\t\t\t\t\t\tmap.put(entry.getKey(), unserializeFieldValue(genericTypeClass, v));\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvalue = map;\r\n\t\t\t\t\t\t\t\ttype = Map.class;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (type == null) {\r\n\t\t\t\t\t\ttype = p.getGenericType();\r\n\t\t\t\t\t\tvalue = unserializeFieldValue((Class<?>) (type != null && type instanceof Class<?> ? type : null), fieldValue);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsetFieldValue(iPojo, fieldName, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfinal OFetchListener listener = new OObjectFetchListener();\r\n\t\tfinal OFetchContext context = new OObjectFetchContext(iFetchPlan, iLazyLoading, iEntityManager, iObj2RecHandler);\r\n\t\t// BIND LINKS FOLLOWING THE FETCHING PLAN\r\n\t\tOFetchHelper.fetch(iRecord, iPojo, OFetchHelper.buildFetchPlan(iFetchPlan), listener, context);\r\n\r\n\t\t// CALL AFTER UNMARSHALLING\r\n\t\tinvokeCallback(iPojo, iRecord, OAfterDeserialization.class);\r\n\r\n\t\tOProfiler.getInstance().stopChrono(\"Object.fromStream\", timer);\r\n\r\n\t\treturn iPojo;\r\n\t}","commit_id":"8c3935f300b66d0e016e036bbffa8c62607740b9","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void updateTableButtons(final JTable table,\n                                         final EditableModel tableModel,\n                                         final AddRemoveUpDownPanel p) {\n    if (table.isEnabled() && p != null) {\n      final int index = table.getSelectedRow();\n      if (0 <= index && index < ((TableModel)tableModel).getRowCount()) {\n        final boolean downEnable = index < ((TableModel)tableModel).getRowCount() - 1;\n        final boolean upEnable = index > 0;\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.REMOVE, true);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.UP, upEnable);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.DOWN, downEnable);\n      } else {\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.REMOVE, false);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.UP, false);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.DOWN, false);\n      }\n      p.setEnabled(AddRemoveUpDownPanel.Buttons.ADD, true);\n    }\n  }","id":51235,"modified_method":"private static void updateTableButtons(final JTable table,\n                                         final EditableModel tableModel,\n                                         final AddRemoveUpDownPanel p) {\n    if (table.isEnabled() && p != null) {\n      final int index = table.getSelectedRow();\n      final int size = ((TableModel)tableModel).getRowCount();\n      if (0 <= index && index < size) {\n        final boolean downEnable = table.getSelectionModel().getMaxSelectionIndex() < size - 1;\n        final boolean upEnable = table.getSelectionModel().getMinSelectionIndex() > 0;\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.REMOVE, true);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.UP, upEnable);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.DOWN, downEnable);\n      } else {\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.REMOVE, false);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.UP, false);\n        p.setEnabled(AddRemoveUpDownPanel.Buttons.DOWN, false);\n      }\n      p.setEnabled(AddRemoveUpDownPanel.Buttons.ADD, true);\n    }\n  }","commit_id":"09c08926c994e079ac864ed0906a6c540b4b5419","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createDefaultTableActions(@Nullable final ElementProducer<?> producer) {\n    final JTable table = myTable;\n    final EditableModel tableModel = (EditableModel)myTableModel;\n\n    myAddAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        if (tableModel instanceof ListTableModel && producer != null) {\n          //noinspection unchecked\n          ((ListTableModel)tableModel).addRow(producer.createElement());\n        } else {\n          tableModel.addRow();\n        }\n        final int index = myTableModel.getRowCount() - 1;\n        table.editCellAt(index, 0);\n        table.setRowSelectionInterval(index, index);\n        table.setColumnSelectionInterval(0, 0);\n        table.getParent().repaint();\n        final Component editorComponent = table.getEditorComponent();\n        if (editorComponent != null) {\n          final Rectangle bounds = editorComponent.getBounds();\n          table.scrollRectToVisible(bounds);\n          editorComponent.requestFocus();\n        }\n      }\n    };\n\n    myRemoveAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 <= index && index < myTableModel.getRowCount()) {\n          tableModel.removeRow(index);\n          if (index < myTableModel.getRowCount()) {\n            table.setRowSelectionInterval(index, index);\n          }\n          else {\n            if (index > 0) {\n              table.setRowSelectionInterval(index - 1, index - 1);\n            }\n          }\n          updateTableButtons(table, tableModel, myPanel);\n        }\n\n        table.getParent().repaint();\n        table.requestFocus();\n      }\n    };\n\n    myUpAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 < index && index < myTableModel.getRowCount()) {\n          tableModel.exchangeRows(index, index - 1);\n          table.setRowSelectionInterval(index - 1, index - 1);\n        }\n        table.requestFocus();\n      }\n    };\n\n    myDownAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 <= index && index < myTableModel.getRowCount() - 1) {\n          tableModel.exchangeRows(index, index + 1);\n          table.setRowSelectionInterval(index + 1, index + 1);\n        }\n        table.requestFocus();\n      }\n    };\n   }","id":51236,"modified_method":"private void createDefaultTableActions(@Nullable final ElementProducer<?> producer) {\n    final JTable table = myTable;\n    final EditableModel tableModel = (EditableModel)myTableModel;\n\n    myAddAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        if (tableModel instanceof ListTableModel && producer != null) {\n          //noinspection unchecked\n          ((ListTableModel)tableModel).addRow(producer.createElement());\n        } else {\n          tableModel.addRow();\n        }\n        final int index = myTableModel.getRowCount() - 1;\n        table.editCellAt(index, 0);\n        table.setRowSelectionInterval(index, index);\n        table.setColumnSelectionInterval(0, 0);\n        table.getParent().repaint();\n        final Component editorComponent = table.getEditorComponent();\n        if (editorComponent != null) {\n          final Rectangle bounds = editorComponent.getBounds();\n          table.scrollRectToVisible(bounds);\n          editorComponent.requestFocus();\n        }\n      }\n    };\n\n    myRemoveAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 <= index && index < myTableModel.getRowCount()) {\n          tableModel.removeRow(index);\n          if (index < myTableModel.getRowCount()) {\n            table.setRowSelectionInterval(index, index);\n          }\n          else {\n            if (index > 0) {\n              table.setRowSelectionInterval(index - 1, index - 1);\n            }\n          }\n          updateTableButtons(table, tableModel, myPanel);\n        }\n\n        table.getParent().repaint();\n        table.requestFocus();\n      }\n    };\n\n    myUpAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 < index && index < myTableModel.getRowCount()) {\n            tableModel.exchangeRows(index, index - 1);\n            table.setRowSelectionInterval(index - 1, index - 1);\n          }\n        }\n        table.requestFocus();\n      }\n    };\n\n    myDownAction = new Runnable() {\n      public void run() {\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 <= index && index < myTableModel.getRowCount() - 1) {\n            tableModel.exchangeRows(index, index + 1);\n            table.setRowSelectionInterval(index + 1, index + 1);\n          }\n        }\n        table.requestFocus();\n      }\n    };\n   }","commit_id":"09c08926c994e079ac864ed0906a6c540b4b5419","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    TableModelEditor.DialogItemEditor<ConfigurableWebBrowser> itemEditor = new TableModelEditor.DialogItemEditor<ConfigurableWebBrowser>() {\n      @NotNull\n      @Override\n      public Class<ConfigurableWebBrowser> getItemClass() {\n        return ConfigurableWebBrowser.class;\n      }\n\n      @Override\n      public ConfigurableWebBrowser clone(@NotNull ConfigurableWebBrowser item, boolean forInPlaceEditing) {\n        return new ConfigurableWebBrowser(forInPlaceEditing ? item.getId() : UUID.randomUUID(),\n                                          item.getFamily(), item.getName(), item.getPath(), item.isActive(),\n                                          forInPlaceEditing ? item.getSpecificSettings() : cloneSettings(item));\n      }\n\n      @Override\n      public void edit(@NotNull ConfigurableWebBrowser browser, @NotNull Function<ConfigurableWebBrowser, ConfigurableWebBrowser> mutator, boolean isAdd) {\n        BrowserSpecificSettings settings = cloneSettings(browser);\n        if (settings != null && ShowSettingsUtil.getInstance().editConfigurable(browsersTable, settings.createConfigurable())) {\n          mutator.fun(browser).setSpecificSettings(settings);\n        }\n      }\n\n      @Nullable\n      private BrowserSpecificSettings cloneSettings(@NotNull ConfigurableWebBrowser browser) {\n        BrowserSpecificSettings settings = browser.getSpecificSettings();\n        if (settings == null) {\n          return null;\n        }\n\n        BrowserSpecificSettings newSettings = browser.getFamily().createBrowserSpecificSettings();\n        assert newSettings != null;\n        TableModelEditor.cloneUsingXmlSerialization(settings, newSettings);\n        return newSettings;\n      }\n\n      @Override\n      public void applyEdited(@NotNull ConfigurableWebBrowser oldItem, @NotNull ConfigurableWebBrowser newItem) {\n        oldItem.setSpecificSettings(newItem.getSpecificSettings());\n      }\n\n      @Override\n      public boolean isEditable(@NotNull ConfigurableWebBrowser browser) {\n        return browser.getSpecificSettings() != null;\n      }\n\n      @Override\n      public boolean isRemovable(@NotNull ConfigurableWebBrowser item) {\n        return !WebBrowserManager.getInstance().isPredefinedBrowser(item);\n      }\n    };\n    browsersEditor = new TableModelEditor<ConfigurableWebBrowser>(COLUMNS, itemEditor, \"No web browsers configured\")\n      .modelListener(new TableModelEditor.DataChangedListener<ConfigurableWebBrowser>() {\n        @Override\n        public void tableChanged(TableModelEvent event) {\n          update(event.getFirstRow());\n        }\n\n        @Override\n        public void dataChanged(@NotNull ColumnInfo<ConfigurableWebBrowser, ?> columnInfo, int rowIndex) {\n          if (columnInfo == PATH_COLUMN_INFO) {\n            update(rowIndex);\n          }\n        }\n\n        private void update(int rowIndex) {\n          if (rowIndex == 0 && getDefaultBrowser() == DefaultBrowserPolicy.FIRST) {\n            setCustomPathToFirstListed();\n          }\n        }\n      });\n    browsersTable = browsersEditor.createComponent();\n  }","id":51237,"modified_method":"private void createUIComponents() {\n    TableModelEditor.DialogItemEditor<ConfigurableWebBrowser> itemEditor = new TableModelEditor.DialogItemEditor<ConfigurableWebBrowser>() {\n      @NotNull\n      @Override\n      public Class<ConfigurableWebBrowser> getItemClass() {\n        return ConfigurableWebBrowser.class;\n      }\n\n      @Override\n      public ConfigurableWebBrowser clone(@NotNull ConfigurableWebBrowser item, boolean forInPlaceEditing) {\n        return new ConfigurableWebBrowser(forInPlaceEditing ? item.getId() : UUID.randomUUID(),\n                                          item.getFamily(), item.getName(), item.getPath(), item.isActive(),\n                                          forInPlaceEditing ? item.getSpecificSettings() : cloneSettings(item));\n      }\n\n      @Override\n      public void edit(@NotNull ConfigurableWebBrowser browser, @NotNull Function<ConfigurableWebBrowser, ConfigurableWebBrowser> mutator, boolean isAdd) {\n        BrowserSpecificSettings settings = cloneSettings(browser);\n        if (settings != null && ShowSettingsUtil.getInstance().editConfigurable(browsersTable, settings.createConfigurable())) {\n          mutator.fun(browser).setSpecificSettings(settings);\n        }\n      }\n\n      @Nullable\n      private BrowserSpecificSettings cloneSettings(@NotNull ConfigurableWebBrowser browser) {\n        BrowserSpecificSettings settings = browser.getSpecificSettings();\n        if (settings == null) {\n          return null;\n        }\n\n        BrowserSpecificSettings newSettings = browser.getFamily().createBrowserSpecificSettings();\n        assert newSettings != null;\n        TableModelEditor.cloneUsingXmlSerialization(settings, newSettings);\n        return newSettings;\n      }\n\n      @Override\n      public void applyEdited(@NotNull ConfigurableWebBrowser oldItem, @NotNull ConfigurableWebBrowser newItem) {\n        oldItem.setSpecificSettings(newItem.getSpecificSettings());\n      }\n\n      @Override\n      public boolean isEditable(@NotNull ConfigurableWebBrowser browser) {\n        return browser.getSpecificSettings() != null;\n      }\n\n      @Override\n      public boolean isRemovable(@NotNull ConfigurableWebBrowser item) {\n        return !WebBrowserManager.getInstance().isPredefinedBrowser(item);\n      }\n    };\n    browsersEditor = new TableModelEditor<ConfigurableWebBrowser>(COLUMNS, itemEditor, \"No web browsers configured\")\n      .modelListener(new TableModelEditor.DataChangedListener<ConfigurableWebBrowser>() {\n        @Override\n        public void tableChanged(TableModelEvent event) {\n          update();\n        }\n\n        @Override\n        public void dataChanged(@NotNull ColumnInfo<ConfigurableWebBrowser, ?> columnInfo, int rowIndex) {\n          if (columnInfo == PATH_COLUMN_INFO || columnInfo == ACTIVE_COLUMN_INFO) {\n            update();\n          }\n        }\n\n        private void update() {\n          if (getDefaultBrowser() == DefaultBrowserPolicy.FIRST) {\n            setCustomPathToFirstListed();\n          }\n        }\n      });\n    browsersTable = browsersEditor.createComponent();\n  }","commit_id":"e16e0c1155ad4560d415e47d332b49fddd2858c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setCustomPathToFirstListed() {\n    ListTableModel<ConfigurableWebBrowser> model = browsersEditor.getModel();\n    alternativeBrowserPathField.setText(model.getRowCount() == 0 ? \"\" : model.getRowValue(0).getPath());\n  }","id":51238,"modified_method":"private void setCustomPathToFirstListed() {\n    ListTableModel<ConfigurableWebBrowser> model = browsersEditor.getModel();\n    for (int i = 0, n = model.getRowCount(); i < n; i++) {\n      ConfigurableWebBrowser browser = model.getRowValue(i);\n      if (browser.isActive() && browser.getPath() != null) {\n        alternativeBrowserPathField.setText(browser.getPath());\n        return;\n      }\n    }\n\n    alternativeBrowserPathField.setText(\"\");\n  }","commit_id":"e16e0c1155ad4560d415e47d332b49fddd2858c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doUpdatePackages(final PackageManagementService packageManagementService) {\n    myPackagesTable.setPaintBusy(true);\n    final Application application = ApplicationManager.getApplication();\n    application.executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        Collection<InstalledPackage> packages = Lists.newArrayList();\n        if (packageManagementService != null) {\n          try {\n            packages = packageManagementService.getInstalledPackages();\n          }\n          catch (IOException e) {\n            // do nothing, we already have an empty list\n          }\n          finally {\n            final Collection<InstalledPackage> finalPackages = packages;\n\n            final Map<String, RepoPackage> cache = buildNameToPackageMap(packageManagementService.getAllPackagesCached());\n            final boolean shouldFetchLatestVersionsForOnlyInstalledPackages = shouldFetchLatestVersionsForOnlyInstalledPackages();\n            if (cache.isEmpty()) {\n              if (!shouldFetchLatestVersionsForOnlyInstalledPackages) {\n                refreshLatestVersions();\n              }\n            }\n            application.invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                if (packageManagementService == myPackageManagementService) {\n                  myPackagesTableModel.getDataVector().clear();\n                  for (InstalledPackage pkg : finalPackages) {\n                    RepoPackage repoPackage = cache.get(pkg.getName());\n                    final String version = repoPackage != null ? repoPackage.getLatestVersion() : null;\n                    myPackagesTableModel\n                      .addRow(new Object[]{pkg, pkg.getVersion(), version == null ? \"\" : version});\n                  }\n                  if (!cache.isEmpty()) {\n                    myPackagesTable.setPaintBusy(false);\n                  }\n                  if (shouldFetchLatestVersionsForOnlyInstalledPackages) {\n                    setLatestVersionsForInstalledPackages();\n                  }\n                }\n              }\n            }, ModalityState.any());\n          }\n        }\n      }\n    });\n  }","id":51239,"modified_method":"public void doUpdatePackages(@NotNull final PackageManagementService packageManagementService) {\n    myPackagesTable.setPaintBusy(true);\n    final Application application = ApplicationManager.getApplication();\n    application.executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        Collection<InstalledPackage> packages = Lists.newArrayList();\n        try {\n          packages = packageManagementService.getInstalledPackages();\n        }\n        catch (IOException e) {\n          // do nothing, we already have an empty list\n        }\n        finally {\n          final Collection<InstalledPackage> finalPackages = packages;\n\n          final Map<String, RepoPackage> cache = buildNameToPackageMap(packageManagementService.getAllPackagesCached());\n          final boolean shouldFetchLatestVersionsForOnlyInstalledPackages = shouldFetchLatestVersionsForOnlyInstalledPackages();\n          if (cache.isEmpty()) {\n            if (!shouldFetchLatestVersionsForOnlyInstalledPackages) {\n              refreshLatestVersions();\n            }\n          }\n          application.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (packageManagementService == myPackageManagementService) {\n                myPackagesTableModel.getDataVector().clear();\n                for (InstalledPackage pkg : finalPackages) {\n                  RepoPackage repoPackage = cache.get(pkg.getName());\n                  final String version = repoPackage != null ? repoPackage.getLatestVersion() : null;\n                  myPackagesTableModel\n                    .addRow(new Object[]{pkg, pkg.getVersion(), version == null ? \"\" : version});\n                }\n                if (!cache.isEmpty()) {\n                  myPackagesTable.setPaintBusy(false);\n                }\n                if (shouldFetchLatestVersionsForOnlyInstalledPackages) {\n                  setLatestVersionsForInstalledPackages();\n                }\n              }\n            }\n          }, ModalityState.any());\n        }\n      }\n    });\n  }","commit_id":"6b3a0a4c43736a8e58ee44b90f914b132867881a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updatePackages(@Nullable PackageManagementService packageManagementService) {\n    myPackageManagementService = packageManagementService;\n    myPackagesTable.clearSelection();\n    myPackagesTableModel.getDataVector().clear();\n    doUpdatePackages(packageManagementService);\n  }","id":51240,"modified_method":"public void updatePackages(@Nullable PackageManagementService packageManagementService) {\n    myPackageManagementService = packageManagementService;\n    myPackagesTable.clearSelection();\n    myPackagesTableModel.getDataVector().clear();\n    myPackagesTableModel.fireTableDataChanged();\n    if (packageManagementService != null) {\n      doUpdatePackages(packageManagementService);\n    }\n  }","commit_id":"6b3a0a4c43736a8e58ee44b90f914b132867881a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setLatestVersionsForInstalledPackages() {\n    final PackageManagementServiceEx serviceEx = getServiceEx();\n    if (serviceEx == null) {\n      return;\n    }\n    final AtomicInteger restPackageCount = new AtomicInteger(0);\n    for (int i = 0; i < myPackagesTableModel.getRowCount(); ++i) {\n      final int finalIndex = i;\n      final InstalledPackage pkg = getInstalledPackageAt(finalIndex);\n      restPackageCount.incrementAndGet();\n      serviceEx.fetchLatestVersion(pkg, new CatchingConsumer<String, Exception>() {\n\n        private void decrement() {\n          if (restPackageCount.decrementAndGet() == 0) {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                myPackagesTable.setPaintBusy(false);\n              }\n            }, ModalityState.any());\n          }\n        }\n\n        @Override\n        public void consume(Exception e) {\n          decrement();\n        }\n\n        @Override\n        public void consume(@Nullable final String latestVersion) {\n          if (latestVersion == null) {\n            decrement();\n            return;\n          }\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (finalIndex < myPackagesTableModel.getRowCount()) {\n                InstalledPackage p = getInstalledPackageAt(finalIndex);\n                if (pkg == p) {\n                  myPackagesTableModel.setValueAt(latestVersion, finalIndex, 2);\n                }\n              }\n              decrement();\n            }\n          }, ModalityState.any());\n        }\n      });\n    }\n  }","id":51241,"modified_method":"private void setLatestVersionsForInstalledPackages() {\n    final PackageManagementServiceEx serviceEx = getServiceEx();\n    if (serviceEx == null) {\n      return;\n    }\n    int packageCount = myPackagesTableModel.getRowCount();\n    if (packageCount == 0) {\n      myPackagesTable.setPaintBusy(false);\n    }\n    final AtomicInteger inProgressPackageCount = new AtomicInteger(packageCount);\n    for (int i = 0; i < packageCount; ++i) {\n      final int finalIndex = i;\n      final InstalledPackage pkg = getInstalledPackageAt(finalIndex);\n      serviceEx.fetchLatestVersion(pkg, new CatchingConsumer<String, Exception>() {\n\n        private void decrement() {\n          if (inProgressPackageCount.decrementAndGet() == 0) {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                myPackagesTable.setPaintBusy(false);\n              }\n            }, ModalityState.any());\n          }\n        }\n\n        @Override\n        public void consume(Exception e) {\n          decrement();\n        }\n\n        @Override\n        public void consume(@Nullable final String latestVersion) {\n          if (latestVersion == null) {\n            decrement();\n            return;\n          }\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (finalIndex < myPackagesTableModel.getRowCount()) {\n                InstalledPackage p = getInstalledPackageAt(finalIndex);\n                if (pkg == p) {\n                  myPackagesTableModel.setValueAt(latestVersion, finalIndex, 2);\n                }\n              }\n              decrement();\n            }\n          }, ModalityState.any());\n        }\n      });\n    }\n  }","commit_id":"6b3a0a4c43736a8e58ee44b90f914b132867881a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void update(AnActionEvent e) {\n      final JComponent component = getContextComponent();\n      if (myButton != Buttons.ADD && component != null) {\n        if ((component instanceof JTable && ((JTable)component).getRowCount() == 0)\n          || (component instanceof JList && ((JList)component).getModel().getSize() == 0)) {\n          e.getPresentation().setEnabled(false);\n        } else {\n          e.getPresentation().setEnabled(true);\n        }\n      }\n    }","id":51242,"modified_method":"@Override\n    public void update(AnActionEvent e) {\n      final JComponent c = getContextComponent();\n      if (c instanceof JTable || c instanceof JList) {\n        final ListSelectionModel model = c instanceof JTable ? ((JTable)c).getSelectionModel() \n                                                             : ((JList)c).getSelectionModel();\n        final int size = c instanceof JTable ? ((JTable)c).getRowCount()  \n                                             : ((JList)c).getModel().getSize();\n        final int min = model.getMinSelectionIndex();\n        final int max = model.getMaxSelectionIndex();\n        \n        if ((myButton == Buttons.UP && min < 1)\n          || (myButton == Buttons.DOWN && max == size - 1)\n          || (myButton != Buttons.ADD && size == 0)) {\n          e.getPresentation().setEnabled(false);\n        } else {\n          e.getPresentation().setEnabled(isEnabled());\n        }\n      }\n    }","commit_id":"53910c8482e1b59b5068c29875645e99579dfdde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createTableWithButtons() {\n    final boolean isAnalyzeShown = ((ApplicationEx)ApplicationManager.getApplication()).isInternal();\n\n    final AnActionButton addButton = new AnActionButton(ProjectBundle.message(\"button.add\"), null, IconUtil.getAddRowIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        initPopupActions();\n        final JBPopup popup = JBPopupFactory.getInstance().createListPopup(\n          new BaseListPopupStep<AddItemPopupAction<?>>(null, myPopupActions) {\n            @Override\n            public Icon getIconFor(AddItemPopupAction<?> aValue) {\n              return aValue.getIcon();\n            }\n\n            @Override\n            public boolean hasSubstep(AddItemPopupAction<?> selectedValue) {\n              return selectedValue.hasSubStep();\n            }\n\n            public boolean isMnemonicsNavigationEnabled() {\n              return true;\n            }\n\n            public PopupStep onChosen(final AddItemPopupAction<?> selectedValue, final boolean finalChoice) {\n              if (selectedValue.hasSubStep()) {\n                return selectedValue.createSubStep();\n              }\n              return doFinalStep(new Runnable() {\n                public void run() {\n                  selectedValue.execute();\n                }\n              });\n            }\n\n            @NotNull\n            public String getTextFor(AddItemPopupAction<?> value) {\n              return \"&\" + value.getIndex() + \"  \" + value.getTitle();\n            }\n          });\n        final RelativePoint point = getPreferredPopupPoint();\n        if (point == null) {\n          popup.showInBestPositionFor(e.getDataContext());\n        } else {\n          popup.show(point);\n        }\n      }\n    };\n\n    final ClasspathPanelAction removeAction = new ClasspathPanelAction(this) {\n      @Override\n      public void run() {\n        final List removedRows = TableUtil.removeSelectedItems(myEntryTable);\n        if (removedRows.isEmpty()) {\n          return;\n        }\n        for (final Object removedRow : removedRows) {\n          final ClasspathTableItem<?> item = (ClasspathTableItem<?>)((Object[])removedRow)[ClasspathTableModel.ITEM_COLUMN];\n          final OrderEntry orderEntry = item.getEntry();\n          if (orderEntry == null) {\n            continue;\n          }\n\n          getRootModel().removeOrderEntry(orderEntry);\n        }\n        final int[] selectedRows = myEntryTable.getSelectedRows();\n        myModel.fireTableDataChanged();\n        TableUtil.selectRows(myEntryTable, selectedRows);\n        final StructureConfigurableContext context = ModuleStructureConfigurable.getInstance(myState.getProject()).getContext();\n        context.getDaemonAnalyzer().queueUpdate(new ModuleProjectStructureElement(context, getRootModel().getModule()));\n      }\n    };\n\n    final AnActionButton removeButton = new AnActionButton(ProjectBundle.message(\"button.remove\"), null, IconUtil.getRemoveRowIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        removeAction.actionPerformed(null);\n      }\n    };\n\n    myEditButton = new AnActionButton(ProjectBundle.message(\"module.classpath.button.edit\"), null, IconUtil.getEditIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        final OrderEntry entry = getSelectedEntry();\n        if (!(entry instanceof LibraryOrderEntry)) return;\n\n        final Library library = ((LibraryOrderEntry)entry).getLibrary();\n        if (library == null) {\n          return;\n        }\n        final LibraryTable table = library.getTable();\n        final String tableLevel = table != null ? table.getTableLevel() : LibraryTableImplUtil.MODULE_LEVEL;\n        final LibraryTablePresentation presentation = LibraryEditingUtil.getLibraryTablePresentation(getProject(), tableLevel);\n        final LibraryTableModifiableModelProvider provider = getModifiableModelProvider(tableLevel);\n        EditExistingLibraryDialog dialog = EditExistingLibraryDialog.createDialog(ClasspathPanelImpl.this, provider, library, myState.getProject(),\n                                                                                  presentation, getStructureConfigurableContext());\n        dialog.setContextModule(getRootModel().getModule());\n        dialog.show();\n        myEntryTable.repaint();\n        ModuleStructureConfigurable.getInstance(myState.getProject()).getTree().repaint();\n      }\n    };\n\n    final AnActionButton upButton = new AnActionButton(ProjectBundle.message(\"module.classpath.button.move.up\"), null, IconUtil.getMoveRowUpIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        moveSelectedRows(-1);\n      }\n    };\n\n    final AnActionButton downButton = new AnActionButton(ProjectBundle.message(\"module.classpath.button.move.down\"), null, IconUtil.getMoveRowDownIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        moveSelectedRows(+1);\n      }\n    };\n\n    final AnActionButton analyzeButton = new AnActionButton(ProjectBundle.message(\"classpath.panel.analyze\"), null, SystemInfo.isMac ? PlatformIcons.TABLE_ANALYZE : PlatformIcons.ANALYZE) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        AnalyzeDependenciesDialog.show(getRootModel().getModule());\n      }\n    };\n\n    myEntryTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final int[] selectedRows = myEntryTable.getSelectedRows();\n        boolean removeButtonEnabled = true;\n        int minRow = myEntryTable.getRowCount() + 1;\n        int maxRow = -1;\n        for (final int selectedRow : selectedRows) {\n          minRow = Math.min(minRow, selectedRow);\n          maxRow = Math.max(maxRow, selectedRow);\n          final ClasspathTableItem<?> item = myModel.getItemAt(selectedRow);\n          if (!item.isRemovable()) {\n            removeButtonEnabled = false;\n          }\n        }\n        upButton.setEnabled(minRow > 0 && minRow < myEntryTable.getRowCount());\n        downButton.setEnabled(maxRow >= 0 && maxRow < myEntryTable.getRowCount() - 1);\n        removeButton.setEnabled(removeButtonEnabled);\n        ClasspathTableItem<?> selectedItem = selectedRows.length == 1 ? myModel.getItemAt(selectedRows[0]) : null;\n        myEditButton.setEnabled(selectedItem != null && selectedItem.isEditable());\n      }\n    });\n\n    addButton.setShortcut(CustomShortcutSet.fromString(\"alt A\", \"INSERT\"));\n    removeButton.setShortcut(CustomShortcutSet.fromString(\"alt DELETE\"));\n    upButton.setShortcut(CustomShortcutSet.fromString(\"alt UP\"));\n    downButton.setShortcut(CustomShortcutSet.fromString(\"alt DOWN\"));\n    myEntryTable.setBorder(new LineBorder(UIUtil.getBorderColor()));\n\n    final ToolbarDecorator decorator = ToolbarDecorator.createDecorator(myEntryTable);\n    decorator\n      .addExtraAction(addButton)\n      .addExtraAction(removeButton)\n      .addExtraAction(upButton)\n      .addExtraAction(downButton)\n      .addExtraAction(myEditButton);\n    if (isAnalyzeShown) {\n      decorator.addExtraAction(analyzeButton);\n    }\n    return decorator.createPanel();\n  }","id":51243,"modified_method":"private JComponent createTableWithButtons() {\n    final boolean isAnalyzeShown = ((ApplicationEx)ApplicationManager.getApplication()).isInternal();\n\n    final ClasspathPanelAction removeAction = new ClasspathPanelAction(this) {\n      @Override\n      public void run() {\n        final List removedRows = TableUtil.removeSelectedItems(myEntryTable);\n        if (removedRows.isEmpty()) {\n          return;\n        }\n        for (final Object removedRow : removedRows) {\n          final ClasspathTableItem<?> item = (ClasspathTableItem<?>)((Object[])removedRow)[ClasspathTableModel.ITEM_COLUMN];\n          final OrderEntry orderEntry = item.getEntry();\n          if (orderEntry == null) {\n            continue;\n          }\n\n          getRootModel().removeOrderEntry(orderEntry);\n        }\n        final int[] selectedRows = myEntryTable.getSelectedRows();\n        myModel.fireTableDataChanged();\n        TableUtil.selectRows(myEntryTable, selectedRows);\n        final StructureConfigurableContext context = ModuleStructureConfigurable.getInstance(myState.getProject()).getContext();\n        context.getDaemonAnalyzer().queueUpdate(new ModuleProjectStructureElement(context, getRootModel().getModule()));\n      }\n    };\n\n    myEditButton = new AnActionButton(ProjectBundle.message(\"module.classpath.button.edit\"), null, IconUtil.getEditIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        final OrderEntry entry = getSelectedEntry();\n        if (!(entry instanceof LibraryOrderEntry)) return;\n\n        final Library library = ((LibraryOrderEntry)entry).getLibrary();\n        if (library == null) {\n          return;\n        }\n        final LibraryTable table = library.getTable();\n        final String tableLevel = table != null ? table.getTableLevel() : LibraryTableImplUtil.MODULE_LEVEL;\n        final LibraryTablePresentation presentation = LibraryEditingUtil.getLibraryTablePresentation(getProject(), tableLevel);\n        final LibraryTableModifiableModelProvider provider = getModifiableModelProvider(tableLevel);\n        EditExistingLibraryDialog dialog = EditExistingLibraryDialog.createDialog(ClasspathPanelImpl.this, provider, library, myState.getProject(),\n                                                                                  presentation, getStructureConfigurableContext());\n        dialog.setContextModule(getRootModel().getModule());\n        dialog.show();\n        myEntryTable.repaint();\n        ModuleStructureConfigurable.getInstance(myState.getProject()).getTree().repaint();\n      }\n    };\n\n\n    final AnActionButton analyzeButton = new AnActionButton(ProjectBundle.message(\"classpath.panel.analyze\"), null, SystemInfo.isMac ? PlatformIcons.TABLE_ANALYZE : PlatformIcons.ANALYZE) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        AnalyzeDependenciesDialog.show(getRootModel().getModule());\n      }\n    };\n\n    //addButton.setShortcut(CustomShortcutSet.fromString(\"alt A\", \"INSERT\"));\n    //removeButton.setShortcut(CustomShortcutSet.fromString(\"alt DELETE\"));\n    //upButton.setShortcut(CustomShortcutSet.fromString(\"alt UP\"));\n    //downButton.setShortcut(CustomShortcutSet.fromString(\"alt DOWN\"));\n    myEntryTable.setBorder(new LineBorder(UIUtil.getBorderColor()));\n\n    final ToolbarDecorator decorator = ToolbarDecorator.createDecorator(myEntryTable);\n    decorator\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          initPopupActions();\n          final JBPopup popup = JBPopupFactory.getInstance().createListPopup(\n            new BaseListPopupStep<AddItemPopupAction<?>>(null, myPopupActions) {\n              @Override\n              public Icon getIconFor(AddItemPopupAction<?> aValue) {\n                return aValue.getIcon();\n              }\n\n              @Override\n              public boolean hasSubstep(AddItemPopupAction<?> selectedValue) {\n                return selectedValue.hasSubStep();\n              }\n\n              public boolean isMnemonicsNavigationEnabled() {\n                return true;\n              }\n\n              public PopupStep onChosen(final AddItemPopupAction<?> selectedValue, final boolean finalChoice) {\n                if (selectedValue.hasSubStep()) {\n                  return selectedValue.createSubStep();\n                }\n                return doFinalStep(new Runnable() {\n                  public void run() {\n                    selectedValue.execute();\n                  }\n                });\n              }\n\n              @NotNull\n              public String getTextFor(AddItemPopupAction<?> value) {\n                return \"&\" + value.getIndex() + \"  \" + value.getTitle();\n              }\n            });\n          popup.show(button.getPreferredPopupPoint());\n        }\n      })\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          removeAction.actionPerformed(null);\n        }\n      })\n      .setUpAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          moveSelectedRows(-1);\n        }\n      })\n      .setDownAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          moveSelectedRows(+1);\n        }\n      })\n      .addExtraAction(myEditButton);\n    if (isAnalyzeShown) {\n      decorator.addExtraAction(analyzeButton);\n    }\n    final JPanel panel = decorator.createPanel();\n\n    myEntryTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final int[] selectedRows = myEntryTable.getSelectedRows();\n        boolean removeButtonEnabled = true;\n        int minRow = myEntryTable.getRowCount() + 1;\n        int maxRow = -1;\n        for (final int selectedRow : selectedRows) {\n          minRow = Math.min(minRow, selectedRow);\n          maxRow = Math.max(maxRow, selectedRow);\n          final ClasspathTableItem<?> item = myModel.getItemAt(selectedRow);\n          if (!item.isRemovable()) {\n            removeButtonEnabled = false;\n          }\n        }\n        ToolbarDecorator.findRemoveButton(panel).setEnabled(removeButtonEnabled);\n        ClasspathTableItem<?> selectedItem = selectedRows.length == 1 ? myModel.getItemAt(selectedRows[0]) : null;\n        myEditButton.setEnabled(selectedItem != null && selectedItem.isEditable());\n      }\n    });\n\n    return panel;\n  }","commit_id":"53910c8482e1b59b5068c29875645e99579dfdde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String encrypt(String plain){\n    \tif(!EncryptionSecretKeyChecker.useEncryption()){\n    \t\treturn plain;\n    \t}\n    \t//synchornize ??\n    \tif(s_encryptor == null){\n    \t\tinitialize();\n    \t}\n    \treturn s_encryptor.encrypt(plain);\n    }","id":51244,"modified_method":"public static String encrypt(String plain){\n    \tif(!EncryptionSecretKeyChecker.useEncryption() || (plain == null) || plain.isEmpty()){\n    \t\treturn plain;\n    \t}\n    \tif(s_encryptor == null){\n    \t\tinitialize();\n    \t}\n    \tString encryptedString = null;\n\t\ttry {\n\t\t\tencryptedString = s_encryptor.encrypt(plain);\n\t\t} catch (EncryptionOperationNotPossibleException e) {\n\t\t\ts_logger.debug(\"Error while encrypting: \"+plain);\n\t\t\tthrow e;\n\t\t}\n    \treturn encryptedString;\n    }","commit_id":"e86b03c2e61fdf03ee7360d43f38a5d6eb8eca3b","url":"https://github.com/apache/cloudstack"},{"original_method":"public static String decrypt(String encrypted){\n    \tif(!EncryptionSecretKeyChecker.useEncryption()){\n    \t\treturn encrypted;\n    \t}\n    \tif(s_encryptor == null){\n    \t\tinitialize();\n    \t}\n    \treturn s_encryptor.decrypt(encrypted);\n    }","id":51245,"modified_method":"public static String decrypt(String encrypted){\n    \tif(!EncryptionSecretKeyChecker.useEncryption() || (encrypted == null) || encrypted.isEmpty()){\n    \t\treturn encrypted;\n    \t}\n    \tif(s_encryptor == null){\n    \t\tinitialize();\n    \t}\n    \t\n    \tString plain = null;\n    \ttry {\n\t\t\tplain = s_encryptor.decrypt(encrypted);\n\t\t} catch (EncryptionOperationNotPossibleException e) {\n\t\t\ts_logger.debug(\"Error while decrypting: \"+encrypted);\n\t\t\tthrow e;\n\t\t}\n    \treturn plain;\n    }","commit_id":"e86b03c2e61fdf03ee7360d43f38a5d6eb8eca3b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public String getValueAndInitIfNotExist(String name, String category, String initValue, String desc) {\n        String returnValue = initValue;\n        try {\n            ConfigurationVO config = findByName(name);\n            if (config != null) {\n                if (config.getValue() != null) {\n                    returnValue = config.getValue();\n                } else {\n                    update(name, category, initValue);\n                }\n            } else {\n                if (category.equals(\"Hidden\") || category.equals(\"Secure\")) {\n                    initValue = DBEncryptionUtil.encrypt(initValue);\n                }\n                ConfigurationVO newConfig = new ConfigurationVO(category, \"DEFAULT\", \"management-server\", name, initValue, desc);\n                persist(newConfig);\n            }\n            return returnValue;\n        } catch (Exception e) {\n            s_logger.warn(\"Unable to update Configuration Value\", e);\n            throw new CloudRuntimeException(\"Unable to initialize configuration variable: \" + name);\n\n        }\n    }","id":51246,"modified_method":"@Override\n    @DB\n    public String getValueAndInitIfNotExist(String name, String category, String initValue, String desc) {\n        String returnValue = initValue;\n        try {\n            ConfigurationVO config = findByName(name);\n            if (config != null) {\n                if (config.getValue() != null) {\n                    returnValue = config.getValue();\n                } else {\n                    update(name, category, initValue);\n                }\n            } else {\n                ConfigurationVO newConfig = new ConfigurationVO(category, \"DEFAULT\", \"management-server\", name, initValue, desc);\n                persist(newConfig);\n            }\n            return returnValue;\n        } catch (Exception e) {\n            s_logger.warn(\"Unable to update Configuration Value\", e);\n            throw new CloudRuntimeException(\"Unable to initialize configuration variable: \" + name);\n\n        }\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void persistDefaultValues() throws InternalErrorException {\n\n        // Create system user and admin user\n        saveUser();\n\n        // Get init\n        String init = _configDao.getValue(\"init\");\n\n        if (init == null || init.equals(\"false\")) {\n            s_logger.debug(\"ConfigurationServer is saving default values to the database.\");\n\n            // Save default Configuration Table values\n            List<String> categories = Config.getCategories();\n            for (String category : categories) {\n                // If this is not a premium environment, don't insert premium configuration values\n                if (!_configDao.isPremium() && category.equals(\"Premium\")) {\n                    continue;\n                }\n\n                List<Config> configs = Config.getConfigs(category);\n                for (Config c : configs) {\n                    String name = c.key();\n\n                    // if the config value already present in the db, don't insert it again\n                    if (_configDao.findByName(name) != null) {\n                        continue;\n                    }\n\n                    String instance = \"DEFAULT\";\n                    String component = c.getComponent();\n                    String value = c.getDefaultValue();\n                    value = (\"Hidden\".equals(category) || \"Secure\".equals(category)) ? DBEncryptionUtil.encrypt(value) : value;\n                    String description = c.getDescription();\n                    ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);\n                    configVO.setDefaultValue(value);\n                    _configDao.persist(configVO);\n                }\n            }\n\n            _configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), \"true\");\n            s_logger.debug(\"ConfigurationServer made secondary storage vm required.\");\n\n            _configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), \"false\");\n            s_logger.debug(\"ConfigurationServer made secondary storage copy encrypt set to false.\");\n\n            _configDao.update(\"secstorage.secure.copy.cert\", \"realhostip\");\n            s_logger.debug(\"ConfigurationServer made secondary storage copy use realhostip.\");\n\n            // Save default service offerings\n            createServiceOffering(User.UID_SYSTEM, \"Small Instance\", 1, 512, 500, \"Small Instance\", ProvisioningType.THIN, false, false, null);\n            createServiceOffering(User.UID_SYSTEM, \"Medium Instance\", 1, 1024, 1000, \"Medium Instance\", ProvisioningType.THIN, false, false, null);\n            // Save default disk offerings\n            createdefaultDiskOffering(null, \"Small\", \"Small Disk, 5 GB\", ProvisioningType.THIN, 5, null, false, false);\n            createdefaultDiskOffering(null, \"Medium\", \"Medium Disk, 20 GB\", ProvisioningType.THIN, 20, null, false, false);\n            createdefaultDiskOffering(null, \"Large\", \"Large Disk, 100 GB\", ProvisioningType.THIN, 100, null, false, false);\n            createdefaultDiskOffering(null, \"Large\", \"Large Disk, 100 GB\", ProvisioningType.THIN, 100, null, false, false);\n            createdefaultDiskOffering(null, \"Custom\", \"Custom Disk\", ProvisioningType.THIN, 0, null, true, false);\n\n            // Save the mount parent to the configuration table\n            String mountParent = getMountParent();\n            if (mountParent != null) {\n                _configDao.update(Config.MountParent.key(), Config.MountParent.getCategory(), mountParent);\n                s_logger.debug(\"ConfigurationServer saved \\\"\" + mountParent + \"\\\" as mount.parent.\");\n            } else {\n                s_logger.debug(\"ConfigurationServer could not detect mount.parent.\");\n            }\n\n            String hostIpAdr = NetUtils.getDefaultHostIp();\n            boolean needUpdateHostIp = true;\n            if (hostIpAdr != null) {\n                Boolean devel = Boolean.valueOf(_configDao.getValue(\"developer\"));\n                if (devel) {\n                    String value = _configDao.getValue(ApiServiceConfiguration.ManagementHostIPAdr.key());\n                    if (value != null && !value.equals(\"localhost\")) {\n                        needUpdateHostIp = false;\n                    }\n                }\n\n                if (needUpdateHostIp) {\n                    _configDepot.createOrUpdateConfigObject(ApiServiceConfiguration.class.getSimpleName(), ApiServiceConfiguration.ManagementHostIPAdr, hostIpAdr);\n                    s_logger.debug(\"ConfigurationServer saved \\\"\" + hostIpAdr + \"\\\" as host.\");\n                }\n            }\n\n            // generate a single sign-on key\n            updateSSOKey();\n\n            // Create default network offerings\n            createDefaultNetworkOfferings();\n\n            // Create default networks\n            createDefaultNetworks();\n\n            // Create userIpAddress ranges\n\n            // Update existing vlans with networkId\n            List<VlanVO> vlans = _vlanDao.listAll();\n            if (vlans != null && !vlans.isEmpty()) {\n                for (final VlanVO vlan : vlans) {\n                    if (vlan.getNetworkId().longValue() == 0) {\n                        updateVlanWithNetworkId(vlan);\n                    }\n\n                    // Create vlan user_ip_address range\n                    String ipPange = vlan.getIpRange();\n                    String[] range = ipPange.split(\"-\");\n                    final String startIp = range[0];\n                    final String endIp = range[1];\n\n                    Transaction.execute(new TransactionCallbackNoReturn() {\n                        @Override\n                        public void doInTransactionWithoutResult(TransactionStatus status) {\n                            IPRangeConfig config = new IPRangeConfig();\n                            long startIPLong = NetUtils.ip2Long(startIp);\n                            long endIPLong = NetUtils.ip2Long(endIp);\n                            config.savePublicIPRange(TransactionLegacy.currentTxn(), startIPLong, endIPLong, vlan.getDataCenterId(), vlan.getId(), vlan.getNetworkId(),\n                                    vlan.getPhysicalNetworkId());\n                        }\n                    });\n\n                }\n            }\n        }\n        // Update resource count if needed\n        updateResourceCount();\n\n        // keystore for SSL/TLS connection\n        updateSSLKeystore();\n\n        // store the public and private keys in the database\n        updateKeyPairs();\n\n        // generate a random password for system vm\n        updateSystemvmPassword();\n\n        // generate a random password used to authenticate zone-to-zone copy\n        generateSecStorageVmCopyPassword();\n\n        // Update the cloud identifier\n        updateCloudIdentifier();\n\n        _configDepotAdmin.populateConfigurations();\n        // setup XenServer default PV driver version\n        initiateXenServerPVDriverVersion();\n\n        // We should not update seed data UUID column here since this will be invoked in upgrade case as well.\n        //updateUuids();\n        // Set init to true\n        _configDao.update(\"init\", \"Hidden\", \"true\");\n\n        // invalidate cache in DAO as we have changed DB status\n        _configDao.invalidateCache();\n    }","id":51247,"modified_method":"@Override\n    public void persistDefaultValues() throws InternalErrorException {\n\n        // Create system user and admin user\n        saveUser();\n\n        // Get init\n        String init = _configDao.getValue(\"init\");\n\n        if (init == null || init.equals(\"false\")) {\n            s_logger.debug(\"ConfigurationServer is saving default values to the database.\");\n\n            // Save default Configuration Table values\n            List<String> categories = Config.getCategories();\n            for (String category : categories) {\n                // If this is not a premium environment, don't insert premium configuration values\n                if (!_configDao.isPremium() && category.equals(\"Premium\")) {\n                    continue;\n                }\n\n                List<Config> configs = Config.getConfigs(category);\n                for (Config c : configs) {\n                    String name = c.key();\n\n                    // if the config value already present in the db, don't insert it again\n                    if (_configDao.findByName(name) != null) {\n                        continue;\n                    }\n\n                    String instance = \"DEFAULT\";\n                    String component = c.getComponent();\n                    String value = c.getDefaultValue();\n                    String description = c.getDescription();\n                    ConfigurationVO configVO = new ConfigurationVO(category, instance, component, name, value, description);\n                    configVO.setDefaultValue(value);\n                    _configDao.persist(configVO);\n                }\n            }\n\n            _configDao.update(Config.UseSecondaryStorageVm.key(), Config.UseSecondaryStorageVm.getCategory(), \"true\");\n            s_logger.debug(\"ConfigurationServer made secondary storage vm required.\");\n\n            _configDao.update(Config.SecStorageEncryptCopy.key(), Config.SecStorageEncryptCopy.getCategory(), \"false\");\n            s_logger.debug(\"ConfigurationServer made secondary storage copy encrypt set to false.\");\n\n            _configDao.update(\"secstorage.secure.copy.cert\", \"realhostip\");\n            s_logger.debug(\"ConfigurationServer made secondary storage copy use realhostip.\");\n\n            // Save default service offerings\n            createServiceOffering(User.UID_SYSTEM, \"Small Instance\", 1, 512, 500, \"Small Instance\", ProvisioningType.THIN, false, false, null);\n            createServiceOffering(User.UID_SYSTEM, \"Medium Instance\", 1, 1024, 1000, \"Medium Instance\", ProvisioningType.THIN, false, false, null);\n            // Save default disk offerings\n            createdefaultDiskOffering(null, \"Small\", \"Small Disk, 5 GB\", ProvisioningType.THIN, 5, null, false, false);\n            createdefaultDiskOffering(null, \"Medium\", \"Medium Disk, 20 GB\", ProvisioningType.THIN, 20, null, false, false);\n            createdefaultDiskOffering(null, \"Large\", \"Large Disk, 100 GB\", ProvisioningType.THIN, 100, null, false, false);\n            createdefaultDiskOffering(null, \"Large\", \"Large Disk, 100 GB\", ProvisioningType.THIN, 100, null, false, false);\n            createdefaultDiskOffering(null, \"Custom\", \"Custom Disk\", ProvisioningType.THIN, 0, null, true, false);\n\n            // Save the mount parent to the configuration table\n            String mountParent = getMountParent();\n            if (mountParent != null) {\n                _configDao.update(Config.MountParent.key(), Config.MountParent.getCategory(), mountParent);\n                s_logger.debug(\"ConfigurationServer saved \\\"\" + mountParent + \"\\\" as mount.parent.\");\n            } else {\n                s_logger.debug(\"ConfigurationServer could not detect mount.parent.\");\n            }\n\n            String hostIpAdr = NetUtils.getDefaultHostIp();\n            boolean needUpdateHostIp = true;\n            if (hostIpAdr != null) {\n                Boolean devel = Boolean.valueOf(_configDao.getValue(\"developer\"));\n                if (devel) {\n                    String value = _configDao.getValue(ApiServiceConfiguration.ManagementHostIPAdr.key());\n                    if (value != null && !value.equals(\"localhost\")) {\n                        needUpdateHostIp = false;\n                    }\n                }\n\n                if (needUpdateHostIp) {\n                    _configDepot.createOrUpdateConfigObject(ApiServiceConfiguration.class.getSimpleName(), ApiServiceConfiguration.ManagementHostIPAdr, hostIpAdr);\n                    s_logger.debug(\"ConfigurationServer saved \\\"\" + hostIpAdr + \"\\\" as host.\");\n                }\n            }\n\n            // generate a single sign-on key\n            updateSSOKey();\n\n            // Create default network offerings\n            createDefaultNetworkOfferings();\n\n            // Create default networks\n            createDefaultNetworks();\n\n            // Create userIpAddress ranges\n\n            // Update existing vlans with networkId\n            List<VlanVO> vlans = _vlanDao.listAll();\n            if (vlans != null && !vlans.isEmpty()) {\n                for (final VlanVO vlan : vlans) {\n                    if (vlan.getNetworkId().longValue() == 0) {\n                        updateVlanWithNetworkId(vlan);\n                    }\n\n                    // Create vlan user_ip_address range\n                    String ipPange = vlan.getIpRange();\n                    String[] range = ipPange.split(\"-\");\n                    final String startIp = range[0];\n                    final String endIp = range[1];\n\n                    Transaction.execute(new TransactionCallbackNoReturn() {\n                        @Override\n                        public void doInTransactionWithoutResult(TransactionStatus status) {\n                            IPRangeConfig config = new IPRangeConfig();\n                            long startIPLong = NetUtils.ip2Long(startIp);\n                            long endIPLong = NetUtils.ip2Long(endIp);\n                            config.savePublicIPRange(TransactionLegacy.currentTxn(), startIPLong, endIPLong, vlan.getDataCenterId(), vlan.getId(), vlan.getNetworkId(),\n                                    vlan.getPhysicalNetworkId());\n                        }\n                    });\n\n                }\n            }\n        }\n        // Update resource count if needed\n        updateResourceCount();\n\n        // keystore for SSL/TLS connection\n        updateSSLKeystore();\n\n        // store the public and private keys in the database\n        updateKeyPairs();\n\n        // generate a random password for system vm\n        updateSystemvmPassword();\n\n        // generate a random password used to authenticate zone-to-zone copy\n        generateSecStorageVmCopyPassword();\n\n        // Update the cloud identifier\n        updateCloudIdentifier();\n\n        _configDepotAdmin.populateConfigurations();\n        // setup XenServer default PV driver version\n        initiateXenServerPVDriverVersion();\n\n        // We should not update seed data UUID column here since this will be invoked in upgrade case as well.\n        //updateUuids();\n        // Set init to true\n        _configDao.update(\"init\", \"Hidden\", \"true\");\n\n        // invalidate cache in DAO as we have changed DB status\n        _configDao.invalidateCache();\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void updateSSLKeystore() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Processing updateSSLKeyStore\");\n        }\n\n        String dbString = _configDao.getValue(\"ssl.keystore\");\n\n        File confFile = PropertiesUtil.findConfigFile(\"db.properties\");\n        String confPath = null;\n        String keystorePath = null;\n        File keystoreFile = null;\n\n        if (null != confFile) {\n            confPath = confFile.getParent();\n            keystorePath = confPath + Link.keystoreFile;\n            keystoreFile = new File(keystorePath);\n        }\n\n        boolean dbExisted = (dbString != null && !dbString.isEmpty());\n\n        s_logger.info(\"SSL keystore located at \" + keystorePath);\n        try {\n            if (!dbExisted && null != confFile) {\n                if (!keystoreFile.exists()) {\n                    generateDefaultKeystore(keystorePath);\n                    s_logger.info(\"Generated SSL keystore.\");\n                }\n                String base64Keystore = getBase64Keystore(keystorePath);\n                ConfigurationVO configVO =\n                        new ConfigurationVO(\"Hidden\", \"DEFAULT\", \"management-server\", \"ssl.keystore\", DBEncryptionUtil.encrypt(base64Keystore),\n                                \"SSL Keystore for the management servers\");\n                _configDao.persist(configVO);\n                s_logger.info(\"Stored SSL keystore to database.\");\n            } else if (null != keystoreFile && keystoreFile.exists()) { // and dbExisted\n                // Check if they are the same one, otherwise override with local keystore\n                String base64Keystore = getBase64Keystore(keystorePath);\n                if (base64Keystore.compareTo(dbString) != 0) {\n                    _configDao.update(\"ssl.keystore\", \"Hidden\", base64Keystore);\n                    s_logger.info(\"Updated database keystore with local one.\");\n                }\n            } else { // !keystoreFile.exists() and dbExisted\n                // Export keystore to local file\n                byte[] storeBytes = Base64.decodeBase64(dbString);\n                try {\n                    String tmpKeystorePath = \"/tmp/tmpkey\";\n                    FileOutputStream fo = new FileOutputStream(tmpKeystorePath);\n                    fo.write(storeBytes);\n                    fo.close();\n                    Script script = new Script(true, \"cp\", 5000, null);\n                    script.add(tmpKeystorePath);\n\n                    //There is a chance, although small, that the keystorePath is null. In that case, do not add it to the script.\n                    if (null != keystorePath) {\n                        script.add(keystorePath);\n                    }\n                    String result = script.execute();\n                    if (result != null) {\n                        throw new IOException();\n                    }\n                } catch (Exception e) {\n                    throw new IOException(\"Fail to create keystore file!\", e);\n                }\n                s_logger.info(\"Stored database keystore to local.\");\n            }\n        } catch (Exception ex) {\n            s_logger.warn(\"Would use fail-safe keystore to continue.\", ex);\n        }\n    }","id":51248,"modified_method":"protected void updateSSLKeystore() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Processing updateSSLKeyStore\");\n        }\n\n        String dbString = _configDao.getValue(\"ssl.keystore\");\n\n        File confFile = PropertiesUtil.findConfigFile(\"db.properties\");\n        String confPath = null;\n        String keystorePath = null;\n        File keystoreFile = null;\n\n        if (null != confFile) {\n            confPath = confFile.getParent();\n            keystorePath = confPath + Link.keystoreFile;\n            keystoreFile = new File(keystorePath);\n        }\n\n        boolean dbExisted = (dbString != null && !dbString.isEmpty());\n\n        s_logger.info(\"SSL keystore located at \" + keystorePath);\n        try {\n            if (!dbExisted && null != confFile) {\n                if (!keystoreFile.exists()) {\n                    generateDefaultKeystore(keystorePath);\n                    s_logger.info(\"Generated SSL keystore.\");\n                }\n                String base64Keystore = getBase64Keystore(keystorePath);\n                ConfigurationVO configVO =\n                        new ConfigurationVO(\"Hidden\", \"DEFAULT\", \"management-server\", \"ssl.keystore\", base64Keystore,\n                                \"SSL Keystore for the management servers\");\n                _configDao.persist(configVO);\n                s_logger.info(\"Stored SSL keystore to database.\");\n            } else if (null != keystoreFile && keystoreFile.exists()) { // and dbExisted\n                // Check if they are the same one, otherwise override with local keystore\n                String base64Keystore = getBase64Keystore(keystorePath);\n                if (base64Keystore.compareTo(dbString) != 0) {\n                    _configDao.update(\"ssl.keystore\", \"Hidden\", base64Keystore);\n                    s_logger.info(\"Updated database keystore with local one.\");\n                }\n            } else { // !keystoreFile.exists() and dbExisted\n                // Export keystore to local file\n                byte[] storeBytes = Base64.decodeBase64(dbString);\n                try {\n                    String tmpKeystorePath = \"/tmp/tmpkey\";\n                    FileOutputStream fo = new FileOutputStream(tmpKeystorePath);\n                    fo.write(storeBytes);\n                    fo.close();\n                    Script script = new Script(true, \"cp\", 5000, null);\n                    script.add(tmpKeystorePath);\n\n                    //There is a chance, although small, that the keystorePath is null. In that case, do not add it to the script.\n                    if (null != keystorePath) {\n                        script.add(keystorePath);\n                    }\n                    String result = script.execute();\n                    if (result != null) {\n                        throw new IOException();\n                    }\n                } catch (Exception e) {\n                    throw new IOException(\"Fail to create keystore file!\", e);\n                }\n                s_logger.info(\"Stored database keystore to local.\");\n            }\n        } catch (Exception ex) {\n            s_logger.warn(\"Would use fail-safe keystore to continue.\", ex);\n        }\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getValue() {\n        return ((\"Hidden\".equals(getCategory()) || \"Secure\".equals(getCategory())) ? DBEncryptionUtil.decrypt(value) : value);\n    }","id":51249,"modified_method":"@Override\n    public String getValue() {\n        if(isEncryptedConfig()) {\n            return DBEncryptionUtil.decrypt(value);\n        } else {\n            return value;\n        }\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"public void setValue(String value) {\n        this.value = value;\n    }","id":51250,"modified_method":"public void setValue(String value) {\n        if(isEncryptedConfig()) {\n            this.value = DBEncryptionUtil.encrypt(value);\n        } else {\n            this.value = value;\n        }\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"public ConfigurationVO(String category, String instance, String component, String name, String value, String description) {\n        this.category = category;\n        this.instance = instance;\n        this.component = component;\n        this.name = name;\n        this.value = value;\n        this.description = description;\n    }","id":51251,"modified_method":"public ConfigurationVO(String category, String instance, String component, String name, String value, String description) {\n        this.category = category;\n        this.instance = instance;\n        this.component = component;\n        this.name = name;\n        this.description = description;\n        setValue(value);\n    }","commit_id":"c3e5964dcbbd3b3ff34562aeeb9f8daa154ee7d1","url":"https://github.com/apache/cloudstack"},{"original_method":"public void handleView(View v) {\n        if(v == null) return;\n        Vector<Address> mbrs=v.getMembers();\n        suspected_mbrs.retainAll(mbrs);\n    }","id":51252,"modified_method":"public void handleView(View v) {\n        if(v == null) return;\n        Vector<Address> mbrs=v.getMembers();\n        synchronized(this) {\n            suspected_mbrs.retainAll(mbrs);\n        }\n    }","commit_id":"1179d66ecf9c68f2b3c9033c41d203537b075d21","url":"https://github.com/belaban/JGroups"},{"original_method":"public void handleView(View v) {\n        if(v == null) return;\n        Vector<Address> mbrs=v.getMembers();\n        suspected_mbrs.retainAll(mbrs);\n    }","id":51253,"modified_method":"public void handleView(View v) {\n        if(v == null) return;\n        Vector<Address> mbrs=v.getMembers();\n        synchronized(this) {\n            suspected_mbrs.retainAll(mbrs);\n        }\n    }","commit_id":"9bda48b40396c21c6dc7540eb3a52e24e1fb2246","url":"https://github.com/belaban/JGroups"},{"original_method":"void suspect(Address mbr) {\n        Message suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        Header hdr=new Header(Header.SUSPECT, mbr);\n        suspect_msg.putHeader(this.id, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n        num_suspect_events++;\n        suspect_history.add(mbr);\n    }","id":51254,"modified_method":"void suspect(List<Address> suspects) {\n        if(suspects == null)\n            return;\n\n        num_suspect_events+=suspects.size();\n\n        final List<Address> eligible_mbrs=new ArrayList<Address>();\n        synchronized(this) {\n            for(Address suspect: suspects) {\n                suspect_history.add(suspect);\n                suspected_mbrs.add(suspect);\n            }\n            eligible_mbrs.addAll(members);\n            eligible_mbrs.removeAll(suspected_mbrs);\n        }\n\n        // Check if we're coord, then send up the stack\n        if(local_addr != null && !eligible_mbrs.isEmpty()) {\n            Address first=eligible_mbrs.get(0);\n            if(local_addr.equals(first)) {\n                if(log.isDebugEnabled())\n                    log.debug(\"suspecting \" + suspected_mbrs);\n                for(Address suspect: suspects) {\n                    up_prot.up(new Event(Event.SUSPECT, suspect));\n                    down_prot.down(new Event(Event.SUSPECT, suspect));\n                }\n            }\n        }\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message heartbeat=new Message(); // send to all\n            heartbeat.setFlag(Message.OOB);\n            Header hdr=new Header(Header.HEARTBEAT);\n            heartbeat.putHeader(id, hdr);\n            down_prot.down(new Event(Event.MSG, heartbeat));\n            num_heartbeats_sent++;\n        }","id":51255,"modified_method":"public void run() {\n            Message heartbeat=new Message(); // send to all\n            heartbeat.setFlag(Message.OOB);\n            heartbeat.putHeader(id, new HeartbeatHeader());\n            down_prot.down(new Event(Event.MSG, heartbeat));\n            num_heartbeats_sent++;\n        }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        stopHeartbeatSender();\n        stopTimeoutChecker();\n    }","id":51256,"modified_method":"public void stop() {\n        stopHeartbeatSender();\n        stopTimeoutChecker();\n        suspected_mbrs.clear();\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {                        \n            if(log.isTraceEnabled())\n                log.trace(\"checking for expired senders, table is:\\n\" + printTimeStamps());\n\n            long current_time=System.currentTimeMillis(), diff;\n            for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n                Entry<Address,Long> entry=it.next();\n                Address key=entry.getKey();\n                Long val=entry.getValue();\n                if(val == null) {\n                    it.remove();\n                    continue;\n                }\n                diff=current_time - val.longValue();\n                if(diff > timeout) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"haven't received a heartbeat from \" + key + \" for \" + diff + \" ms, suspecting it\");\n                    suspect(key);\n                }\n            }\n        }","id":51257,"modified_method":"public void run() {                        \n            List<Address> suspects=new LinkedList<Address>();\n            long current_time=System.currentTimeMillis(), diff;\n            for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n                Entry<Address,Long> entry=it.next();\n                Address key=entry.getKey();\n                Long val=entry.getValue();\n                if(val == null) {\n                    it.remove();\n                    continue;\n                }\n                diff=current_time - val.longValue();\n                if(diff > timeout) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"haven't received a heartbeat from \" + key + \" for \" + diff +\n                                \" ms, adding it to suspect list\");\n                    suspects.add(key);\n                }\n            }\n            if(!suspects.isEmpty())\n                suspect(suspects);\n        }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"private String printTimeStamps() {\n        StringBuilder sb=new StringBuilder();\n        long current_time=System.currentTimeMillis();\n        for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n            Entry<Address,Long> entry=it.next();\n            sb.append(entry.getKey()).append(\": \");\n            sb.append(current_time - entry.getValue().longValue()).append(\" ms old\\n\");\n        }\n        return sb.toString();\n    }","id":51258,"modified_method":"private String _printTimestamps() {\n        StringBuilder sb=new StringBuilder();\n        long current_time=System.currentTimeMillis();\n        for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n            Entry<Address,Long> entry=it.next();\n            sb.append(entry.getKey()).append(\": \");\n            sb.append(current_time - entry.getValue().longValue()).append(\" ms old\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector<Address> mbrs=v.getMembers();\n        boolean has_at_least_two=mbrs.size() > 1;\n\n        members.clear();\n        members.addAll(mbrs);\n\n        Set<Address> keys=timestamps.keySet();\n        keys.retainAll(mbrs); // remove all nodes which have left the cluster\n        for(Address member: mbrs)\n            update(member);\n\n        if(has_at_least_two) {\n            startHeartbeatSender();\n            startTimeoutChecker();\n        }\n        else {\n            stopHeartbeatSender();\n            stopTimeoutChecker();\n        }\n    }","id":51259,"modified_method":"private void handleViewChange(View v) {\n        List<Address> mbrs=v.getMembers();\n\n        synchronized(this) {\n            members.clear();\n            members.addAll(mbrs);\n            suspected_mbrs.retainAll(mbrs);\n            timestamps.keySet().retainAll(mbrs);\n        }\n\n        for(Address member: mbrs)\n            update(member);\n\n        if(mbrs.size() > 1) {\n            startHeartbeatSender();\n            startTimeoutChecker();\n        }\n        else {\n            stopHeartbeatSender();\n            stopTimeoutChecker();\n        }\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        Header  hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(Header)msg.getHeader(this.id);\n                if(msg_counts_as_heartbeat)\n                    update(msg.getSrc()); // update when data is received too ? maybe a bit costly\n                if(hdr == null)\n                    break;  // message did not originate from FD_ALL layer, just pass up\n\n                switch(hdr.type) {\n                    case Header.HEARTBEAT: \n                        Address sender=msg.getSrc();\n                        if(sender.equals(local_addr))\n                            break;\n                        update(sender); // updates the heartbeat entry for 'sender'\n                        num_heartbeats_received++;\n                        break;          // don't pass up !\n\n                    case Header.SUSPECT:\n                        if(log.isTraceEnabled()) log.trace(\"[SUSPECT] suspect hdr is \" + hdr);\n                        down_prot.down(new Event(Event.SUSPECT, hdr.suspected_mbr));\n                        up_prot.up(new Event(Event.SUSPECT, hdr.suspected_mbr));\n                        break;\n                }\n                return null;            \n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","id":51260,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address sender=msg.getSrc();\n\n                if(msg_counts_as_heartbeat) {\n                    update(sender); // update when data is received too ? maybe a bit costly\n                    break;\n                }\n                Header hdr=msg.getHeader(this.id);\n                if(hdr == null)\n                    break;  // message did not originate from FD_ALL layer, just pass up\n\n                update(sender); // updates the heartbeat entry for 'sender'\n                num_heartbeats_received++;\n                return null;\n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation(description=\"Prints timestamps\")\n    public String printTimestamps() {\n        return printTimeStamps();\n    }","id":51261,"modified_method":"@ManagedOperation(description=\"Prints timestamps\")\n    public String printTimestamps() {\n        return _printTimestamps();\n    }","commit_id":"0a4b5107feec25505fd1398baf563345209e1a49","url":"https://github.com/belaban/JGroups"},{"original_method":"private String printTimeStamps() {\n        StringBuilder sb=new StringBuilder();\n        long current_time=System.currentTimeMillis();\n        for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n            Entry<Address,Long> entry=it.next();\n            sb.append(entry.getKey()).append(\": \");\n            sb.append(current_time - entry.getValue().longValue()).append(\" ms old\\n\");\n        }\n        return sb.toString();\n    }","id":51262,"modified_method":"private String _printTimestamps() {\n        StringBuilder sb=new StringBuilder();\n        long current_time=System.currentTimeMillis();\n        for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n            Entry<Address,Long> entry=it.next();\n            sb.append(entry.getKey()).append(\": \");\n            sb.append(current_time - entry.getValue().longValue()).append(\" ms old\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        stopHeartbeatSender();\n        stopTimeoutChecker();\n    }","id":51263,"modified_method":"public void stop() {\n        stopHeartbeatSender();\n        stopTimeoutChecker();\n        suspected_mbrs.clear();\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        Header  hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(Header)msg.getHeader(this.id);\n                if(msg_counts_as_heartbeat)\n                    update(msg.getSrc()); // update when data is received too ? maybe a bit costly\n                if(hdr == null)\n                    break;  // message did not originate from FD_ALL layer, just pass up\n\n                switch(hdr.type) {\n                    case Header.HEARTBEAT: \n                        Address sender=msg.getSrc();\n                        if(sender.equals(local_addr))\n                            break;\n                        update(sender); // updates the heartbeat entry for 'sender'\n                        num_heartbeats_received++;\n                        break;          // don't pass up !\n\n                    case Header.SUSPECT:\n                        if(log.isTraceEnabled()) log.trace(\"[SUSPECT] suspect hdr is \" + hdr);\n                        down_prot.down(new Event(Event.SUSPECT, hdr.suspected_mbr));\n                        up_prot.up(new Event(Event.SUSPECT, hdr.suspected_mbr));\n                        break;\n                }\n                return null;            \n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","id":51264,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address sender=msg.getSrc();\n\n                if(msg_counts_as_heartbeat) {\n                    update(sender); // update when data is received too ? maybe a bit costly\n                    break;\n                }\n                Header hdr=msg.getHeader(this.id);\n                if(hdr == null)\n                    break;  // message did not originate from FD_ALL layer, just pass up\n\n                update(sender); // updates the heartbeat entry for 'sender'\n                num_heartbeats_received++;\n                return null;\n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation(description=\"Prints timestamps\")\n    public String printTimestamps() {\n        return printTimeStamps();\n    }","id":51265,"modified_method":"@ManagedOperation(description=\"Prints timestamps\")\n    public String printTimestamps() {\n        return _printTimestamps();\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"void suspect(Address mbr) {\n        Message suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        Header hdr=new Header(Header.SUSPECT, mbr);\n        suspect_msg.putHeader(this.id, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n        num_suspect_events++;\n        suspect_history.add(mbr);\n    }","id":51266,"modified_method":"void suspect(List<Address> suspects) {\n        if(suspects == null)\n            return;\n\n        num_suspect_events+=suspects.size();\n\n        final List<Address> eligible_mbrs=new ArrayList<Address>();\n        synchronized(this) {\n            for(Address suspect: suspects) {\n                suspect_history.add(suspect);\n                suspected_mbrs.add(suspect);\n            }\n            eligible_mbrs.addAll(members);\n            eligible_mbrs.removeAll(suspected_mbrs);\n        }\n\n        // Check if we're coord, then send up the stack\n        if(local_addr != null && !eligible_mbrs.isEmpty()) {\n            Address first=eligible_mbrs.get(0);\n            if(local_addr.equals(first)) {\n                if(log.isDebugEnabled())\n                    log.debug(\"suspecting \" + suspected_mbrs);\n                for(Address suspect: suspects) {\n                    up_prot.up(new Event(Event.SUSPECT, suspect));\n                    down_prot.down(new Event(Event.SUSPECT, suspect));\n                }\n            }\n        }\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector<Address> mbrs=v.getMembers();\n        boolean has_at_least_two=mbrs.size() > 1;\n\n        members.clear();\n        members.addAll(mbrs);\n\n        Set<Address> keys=timestamps.keySet();\n        keys.retainAll(mbrs); // remove all nodes which have left the cluster\n        for(Address member: mbrs)\n            update(member);\n\n        if(has_at_least_two) {\n            startHeartbeatSender();\n            startTimeoutChecker();\n        }\n        else {\n            stopHeartbeatSender();\n            stopTimeoutChecker();\n        }\n    }","id":51267,"modified_method":"private void handleViewChange(View v) {\n        List<Address> mbrs=v.getMembers();\n\n        synchronized(this) {\n            members.clear();\n            members.addAll(mbrs);\n            suspected_mbrs.retainAll(mbrs);\n            timestamps.keySet().retainAll(mbrs);\n        }\n\n        for(Address member: mbrs)\n            update(member);\n\n        if(mbrs.size() > 1) {\n            startHeartbeatSender();\n            startTimeoutChecker();\n        }\n        else {\n            stopHeartbeatSender();\n            stopTimeoutChecker();\n        }\n    }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message heartbeat=new Message(); // send to all\n            heartbeat.setFlag(Message.OOB);\n            Header hdr=new Header(Header.HEARTBEAT);\n            heartbeat.putHeader(id, hdr);\n            down_prot.down(new Event(Event.MSG, heartbeat));\n            num_heartbeats_sent++;\n        }","id":51268,"modified_method":"public void run() {\n            Message heartbeat=new Message(); // send to all\n            heartbeat.setFlag(Message.OOB);\n            heartbeat.putHeader(id, new HeartbeatHeader());\n            down_prot.down(new Event(Event.MSG, heartbeat));\n            num_heartbeats_sent++;\n        }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {                        \n            if(log.isTraceEnabled())\n                log.trace(\"checking for expired senders, table is:\\n\" + printTimeStamps());\n\n            long current_time=System.currentTimeMillis(), diff;\n            for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n                Entry<Address,Long> entry=it.next();\n                Address key=entry.getKey();\n                Long val=entry.getValue();\n                if(val == null) {\n                    it.remove();\n                    continue;\n                }\n                diff=current_time - val.longValue();\n                if(diff > timeout) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"haven't received a heartbeat from \" + key + \" for \" + diff + \" ms, suspecting it\");\n                    suspect(key);\n                }\n            }\n        }","id":51269,"modified_method":"public void run() {                        \n            List<Address> suspects=new LinkedList<Address>();\n            long current_time=System.currentTimeMillis(), diff;\n            for(Iterator<Entry<Address,Long>> it=timestamps.entrySet().iterator(); it.hasNext();) {\n                Entry<Address,Long> entry=it.next();\n                Address key=entry.getKey();\n                Long val=entry.getValue();\n                if(val == null) {\n                    it.remove();\n                    continue;\n                }\n                diff=current_time - val.longValue();\n                if(diff > timeout) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"haven't received a heartbeat from \" + key + \" for \" + diff +\n                                \" ms, adding it to suspect list\");\n                    suspects.add(key);\n                }\n            }\n            if(!suspects.isEmpty())\n                suspect(suspects);\n        }","commit_id":"88a7b2562cc8e8cb210690b2c80101c7133e75be","url":"https://github.com/belaban/JGroups"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"create\")\n      .setDescription(\"Create a custom rule or a manual rule\")\n      .setSince(\"4.4\")\n      .setPost(true)\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TEMPLATE_KEY)\n      .setDescription(\"Key of the template rule in order to create a custom rule\")\n      .setExampleValue(\"java:XPath\");\n\n    action\n      .createParam(PARAM_NAME)\n      .setDescription(\"Rule name\")\n      .setRequired(true)\n      .setExampleValue(\"My custom rule\");\n\n    action\n      .createParam(PARAM_DESCRIPTION)\n      .setDescription(\"Rule description\")\n      .setRequired(true)\n      .setExampleValue(\"Description of my custom rule\");\n\n    action\n      .createParam(PARAM_SEVERITY)\n      .setDescription(\"Rule severity\")\n      .setRequired(true)\n      .setPossibleValues(Severity.ALL);\n\n    action\n      .createParam(PARAM_STATUS)\n      .setDescription(\"Rule status\")\n      .setRequired(true)\n      .setDefaultValue(RuleStatus.READY)\n      .setPossibleValues(RuleStatus.values());\n\n    action.createParam(PARAMS)\n      .setDescription(\"Parameters as semi-colon list of <key>=<value>, for example 'params=key1=v1;key2=v2'\");\n  }","id":51270,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"create\")\n      .setDescription(\"Create a custom rule or a manual rule\")\n      .setSince(\"4.4\")\n      .setPost(true)\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_KEY)\n      .setDescription(\"Key of the rule\")\n      .setExampleValue(\"Todo_should_not_be_used\");\n\n    action\n      .createParam(PARAM_TEMPLATE_KEY)\n      .setDescription(\"Key of the template rule in order to create a custom rule\")\n      .setExampleValue(\"java:XPath\");\n\n    action\n      .createParam(PARAM_NAME)\n      .setDescription(\"Rule name\")\n      .setRequired(true)\n      .setExampleValue(\"My custom rule\");\n\n    action\n      .createParam(PARAM_DESCRIPTION)\n      .setDescription(\"Rule description\")\n      .setRequired(true)\n      .setExampleValue(\"Description of my custom rule\");\n\n    action\n      .createParam(PARAM_SEVERITY)\n      .setDescription(\"Rule severity\")\n      .setRequired(true)\n      .setPossibleValues(Severity.ALL);\n\n    action\n      .createParam(PARAM_STATUS)\n      .setDescription(\"Rule status\")\n      .setRequired(true)\n      .setDefaultValue(RuleStatus.READY)\n      .setPossibleValues(RuleStatus.values());\n\n    action.createParam(PARAMS)\n      .setDescription(\"Parameters as semi-colon list of <key>=<value>, for example 'params=key1=v1;key2=v2'\");\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) {\n    String templateRuleKey = request.param(PARAM_TEMPLATE_KEY);\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRuleKey != null ? RuleKey.parse(templateRuleKey) : null)\n      .setName(request.mandatoryParam(PARAM_NAME))\n      .setHtmlDescription(request.mandatoryParam(PARAM_DESCRIPTION))\n      .setSeverity(request.mandatoryParam(PARAM_SEVERITY))\n      .setStatus(RuleStatus.valueOf(request.mandatoryParam(PARAM_STATUS)));\n    String params = request.param(PARAMS);\n    if (!Strings.isNullOrEmpty(params)) {\n      newRule.setParameters(KeyValueFormat.parse(params));\n    }\n    writeResponse(response, service.create(newRule));\n  }","id":51271,"modified_method":"@Override\n  public void handle(Request request, Response response) {\n    String templateRuleKey = request.param(PARAM_TEMPLATE_KEY);\n    NewRule newRule = new NewRule()\n      .setRuleKey(request.mandatoryParam(PARAM_KEY))\n      .setTemplateKey(templateRuleKey != null ? RuleKey.parse(templateRuleKey) : null)\n      .setName(request.mandatoryParam(PARAM_NAME))\n      .setHtmlDescription(request.mandatoryParam(PARAM_DESCRIPTION))\n      .setSeverity(request.mandatoryParam(PARAM_SEVERITY))\n      .setStatus(RuleStatus.valueOf(request.mandatoryParam(PARAM_STATUS)));\n    String params = request.param(PARAMS);\n    if (!Strings.isNullOrEmpty(params)) {\n      newRule.setParameters(KeyValueFormat.parse(params));\n    }\n    writeResponse(response, service.create(newRule));\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Template rule\n    RuleDto templateRule = ruleDao.insert(session, RuleTesting.newDto(RuleKey.of(\"java\", \"S001\")).setCardinality(Cardinality.MULTIPLE));\n    RuleParamDto param = RuleParamDto.createFor(templateRule).setName(\"regex\").setType(\"STRING\").setDescription(\"Reg ex\").setDefaultValue(\".*\");\n    ruleDao.addRuleParam(session, templateRule, param);\n    session.commit();\n\n    WsTester.TestRequest request = wsTester.newGetRequest(\"api/rules\", \"create\")\n      .setParam(\"template_key\", templateRule.getKey().toString())\n      .setParam(\"name\", \"My custom rule\")\n      .setParam(\"html_description\", \"Description\")\n      .setParam(\"severity\", \"MAJOR\")\n      .setParam(\"status\", \"BETA\")\n      .setParam(\"params\", \"regex=a.*\");\n    request.execute().assertJson(getClass(), \"create_custom_rule.json\", false);\n  }","id":51272,"modified_method":"@Test\n  public void create_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Template rule\n    RuleDto templateRule = ruleDao.insert(session, RuleTesting.newDto(RuleKey.of(\"java\", \"S001\")).setCardinality(Cardinality.MULTIPLE));\n    RuleParamDto param = RuleParamDto.createFor(templateRule).setName(\"regex\").setType(\"STRING\").setDescription(\"Reg ex\").setDefaultValue(\".*\");\n    ruleDao.addRuleParam(session, templateRule, param);\n    session.commit();\n\n    WsTester.TestRequest request = wsTester.newGetRequest(\"api/rules\", \"create\")\n      .setParam(\"key\", \"MY_CUSTOM\")\n      .setParam(\"template_key\", templateRule.getKey().toString())\n      .setParam(\"name\", \"My custom rule\")\n      .setParam(\"html_description\", \"Description\")\n      .setParam(\"severity\", \"MAJOR\")\n      .setParam(\"status\", \"BETA\")\n      .setParam(\"params\", \"regex=a.*\");\n    request.execute().assertJson(getClass(), \"create_custom_rule.json\", false);\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RuleKey create(NewRule newRule) {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      RuleKey templateKey = newRule.templateKey();\n      if (templateKey != null) {\n        RuleDto templateRule = dbClient.ruleDao().getByKey(dbSession, newRule.templateKey());\n        if (!Cardinality.MULTIPLE.equals(templateRule.getCardinality())) {\n          throw new IllegalArgumentException(\"This rule is not a template rule: \" + templateKey.toString());\n        }\n        validateRule(newRule);\n        RuleKey customRuleKey = createCustomRule(newRule, templateRule, dbSession);\n        dbSession.commit();\n        return customRuleKey;\n      }\n      throw new IllegalArgumentException(\"Not supported\");\n    } finally {\n      dbSession.close();\n    }\n  }","id":51273,"modified_method":"public RuleKey create(NewRule newRule) {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      RuleKey templateKey = newRule.templateKey();\n      if (templateKey != null) {\n        RuleDto templateRule = dbClient.ruleDao().getByKey(dbSession, templateKey);\n        if (!Cardinality.MULTIPLE.equals(templateRule.getCardinality())) {\n          throw new IllegalArgumentException(\"This rule is not a template rule: \" + templateKey.toString());\n        }\n        validateRule(newRule);\n\n        RuleKey customRuleKey = RuleKey.of(templateRule.getRepositoryKey(), newRule.ruleKey());\n        checkRuleKeyUnicity(customRuleKey, dbSession);\n        createCustomRule(customRuleKey, newRule, templateRule, dbSession);\n        dbSession.commit();\n        return customRuleKey;\n      }\n      throw new IllegalArgumentException(\"Not supported\");\n    } finally {\n      dbSession.close();\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private RuleKey createCustomRule(NewRule newRule, RuleDto templateRuleDto, DbSession dbSession){\n    RuleKey ruleKey = RuleKey.of(templateRuleDto.getRepositoryKey(), templateRuleDto.getRuleKey() + \"_\" + system.now());\n    RuleDto ruleDto = RuleDto.createFor(ruleKey)\n      .setParentId(templateRuleDto.getId())\n      .setConfigKey(templateRuleDto.getConfigKey())\n      .setName(newRule.name())\n      .setDescription(newRule.htmlDescription())\n      .setSeverity(newRule.severity())\n      .setCardinality(Cardinality.SINGLE)\n      .setStatus(newRule.status())\n      .setLanguage(templateRuleDto.getLanguage())\n      .setDefaultSubCharacteristicId(templateRuleDto.getDefaultSubCharacteristicId())\n      .setDefaultRemediationFunction(templateRuleDto.getDefaultRemediationFunction())\n      .setDefaultRemediationCoefficient(templateRuleDto.getDefaultRemediationCoefficient())\n      .setDefaultRemediationOffset(templateRuleDto.getDefaultRemediationOffset())\n      .setEffortToFixDescription(templateRuleDto.getEffortToFixDescription())\n      .setTags(templateRuleDto.getTags())\n      .setSystemTags(templateRuleDto.getSystemTags());\n    dbClient.ruleDao().insert(dbSession, ruleDto);\n\n    for (RuleParamDto templateRuleParamDto : dbClient.ruleDao().findRuleParamsByRuleKey(dbSession, templateRuleDto.getKey())) {\n      String newRuleParam = newRule.parameter(templateRuleParamDto.getName());\n      if (newRuleParam == null) {\n        throw new IllegalArgumentException(String.format(\"The parameter '%s' has not been set\", templateRuleParamDto.getName()));\n      }\n      createCustomRuleParams(newRuleParam, ruleDto, templateRuleParamDto, dbSession);\n    }\n    return ruleKey;\n  }","id":51274,"modified_method":"private RuleKey createCustomRule(RuleKey ruleKey, NewRule newRule, RuleDto templateRuleDto, DbSession dbSession){\n    RuleDto ruleDto = RuleDto.createFor(ruleKey)\n      .setParentId(templateRuleDto.getId())\n      .setConfigKey(templateRuleDto.getConfigKey())\n      .setName(newRule.name())\n      .setDescription(newRule.htmlDescription())\n      .setSeverity(newRule.severity())\n      .setCardinality(Cardinality.SINGLE)\n      .setStatus(newRule.status())\n      .setLanguage(templateRuleDto.getLanguage())\n      .setDefaultSubCharacteristicId(templateRuleDto.getDefaultSubCharacteristicId())\n      .setDefaultRemediationFunction(templateRuleDto.getDefaultRemediationFunction())\n      .setDefaultRemediationCoefficient(templateRuleDto.getDefaultRemediationCoefficient())\n      .setDefaultRemediationOffset(templateRuleDto.getDefaultRemediationOffset())\n      .setEffortToFixDescription(templateRuleDto.getEffortToFixDescription())\n      .setTags(templateRuleDto.getTags())\n      .setSystemTags(templateRuleDto.getSystemTags());\n    dbClient.ruleDao().insert(dbSession, ruleDto);\n\n    for (RuleParamDto templateRuleParamDto : dbClient.ruleDao().findRuleParamsByRuleKey(dbSession, templateRuleDto.getKey())) {\n      String newRuleParam = newRule.parameter(templateRuleParamDto.getName());\n      if (newRuleParam == null) {\n        throw new IllegalArgumentException(String.format(\"The parameter '%s' has not been set\", templateRuleParamDto.getName()));\n      }\n      createCustomRuleParams(newRuleParam, ruleDto, templateRuleParamDto, dbSession);\n    }\n    return ruleKey;\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void validateRule(NewRule newRule) {\n    if (Strings.isNullOrEmpty(newRule.name())) {\n      throw new IllegalArgumentException(\"The name is missing\");\n    }\n    if (Strings.isNullOrEmpty(newRule.htmlDescription())) {\n      throw new IllegalArgumentException(\"The description is missing\");\n    }\n    String severity = newRule.severity();\n    if (Strings.isNullOrEmpty(severity)) {\n      throw new IllegalArgumentException(\"The severity is missing\");\n    } else if (!Severity.ALL.contains(severity)) {\n      throw new IllegalArgumentException(\"This severity is invalid : \" + severity);\n    }\n    if (newRule.status() == null) {\n      throw new IllegalArgumentException(\"The status is missing\");\n    }\n  }","id":51275,"modified_method":"private static void validateRule(NewRule newRule) {\n    validateRuleKey(newRule.ruleKey());\n    if (Strings.isNullOrEmpty(newRule.name())) {\n      throw new IllegalArgumentException(\"The name is missing\");\n    }\n    if (Strings.isNullOrEmpty(newRule.htmlDescription())) {\n      throw new IllegalArgumentException(\"The description is missing\");\n    }\n    String severity = newRule.severity();\n    if (Strings.isNullOrEmpty(severity)) {\n      throw new IllegalArgumentException(\"The severity is missing\");\n    } else if (!Severity.ALL.contains(severity)) {\n      throw new IllegalArgumentException(\"This severity is invalid : \" + severity);\n    }\n    if (newRule.status() == null) {\n      throw new IllegalArgumentException(\"The status is missing\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RuleCreator(DbClient dbClient, System2 system) {\n    this.dbClient = dbClient;\n    this.system = system;\n  }","id":51276,"modified_method":"public RuleCreator(DbClient dbClient) {\n    this.dbClient = dbClient;\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_status() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The status is missing\");\n    }\n  }","id":51277,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_status() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The status is missing\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_a_param_is_missing() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY);\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The parameter 'regex' has not been set\");\n    }\n  }","id":51278,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_a_param_is_missing() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY);\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The parameter 'regex' has not been set\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_description() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The description is missing\");\n    }\n  }","id":51279,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_description() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The description is missing\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_severity() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The severity is missing\");\n    }\n  }","id":51280,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_severity() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The severity is missing\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_name() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without name\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The name is missing\");\n    }\n  }","id":51281,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_name() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The name is missing\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_wrong_rule_template() throws Exception {\n    // insert rule\n    RuleDto rule = dao.insert(dbSession,\n      RuleTesting.newDto(RuleKey.of(\"java\", \"S001\"))\n        .setCardinality(Cardinality.SINGLE));\n    dbSession.commit();\n\n    // Create custom rule with unknown template rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(rule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"This rule is not a template rule: java:S001\");\n    }\n  }","id":51282,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_wrong_rule_template() throws Exception {\n    // insert rule\n    RuleDto rule = dao.insert(dbSession,\n      RuleTesting.newDto(RuleKey.of(\"java\", \"S001\"))\n        .setCardinality(Cardinality.SINGLE));\n    dbSession.commit();\n\n    // Create custom rule with unknown template rule\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(rule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"This rule is not a template rule: java:S001\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_custom_rule() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = creator.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = db.ruleDao().getNullableByKey(dbSession, customRuleKey);\n    assertThat(rule).isNotNull();\n    assertThat(rule.getParentId()).isEqualTo(templateRule.getId());\n    assertThat(rule.getName()).isEqualTo(\"My custom\");\n    assertThat(rule.getDescription()).isEqualTo(\"Some description\");\n    assertThat(rule.getSeverityString()).isEqualTo(\"MAJOR\");\n    assertThat(rule.getStatus()).isEqualTo(RuleStatus.READY);\n    assertThat(rule.getLanguage()).isEqualTo(\"java\");\n    assertThat(rule.getConfigKey()).isEqualTo(\"S001\");\n    assertThat(rule.getDefaultSubCharacteristicId()).isEqualTo(1);\n    assertThat(rule.getDefaultRemediationFunction()).isEqualTo(\"LINEAR_OFFSET\");\n    assertThat(rule.getDefaultRemediationCoefficient()).isEqualTo(\"1h\");\n    assertThat(rule.getDefaultRemediationOffset()).isEqualTo(\"5min\");\n    assertThat(rule.getEffortToFixDescription()).isEqualTo(\"desc\");\n    assertThat(rule.getTags()).containsOnly(\"usertag1\", \"usertag2\");\n    assertThat(rule.getSystemTags()).containsOnly(\"tag1\", \"tag4\");\n\n    List<RuleParamDto> params = db.ruleDao().findRuleParamsByRuleKey(dbSession, customRuleKey);\n    assertThat(params).hasSize(1);\n\n    RuleParamDto param = params.get(0);\n    // From template rule\n    assertThat(param.getName()).isEqualTo(\"regex\");\n    assertThat(param.getDescription()).isEqualTo(\"Reg ex\");\n    assertThat(param.getType()).isEqualTo(\"STRING\");\n    // From user\n    assertThat(param.getDefaultValue()).isEqualTo(\"a.*\");\n  }","id":51283,"modified_method":"@Test\n  public void create_custom_rule() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = creator.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = db.ruleDao().getNullableByKey(dbSession, customRuleKey);\n    assertThat(rule).isNotNull();\n    assertThat(rule.getKey()).isEqualTo(RuleKey.of(\"java\", \"CUSTOM_RULE\"));\n    assertThat(rule.getParentId()).isEqualTo(templateRule.getId());\n    assertThat(rule.getName()).isEqualTo(\"My custom\");\n    assertThat(rule.getDescription()).isEqualTo(\"Some description\");\n    assertThat(rule.getSeverityString()).isEqualTo(\"MAJOR\");\n    assertThat(rule.getStatus()).isEqualTo(RuleStatus.READY);\n    assertThat(rule.getLanguage()).isEqualTo(\"java\");\n    assertThat(rule.getConfigKey()).isEqualTo(\"S001\");\n    assertThat(rule.getDefaultSubCharacteristicId()).isEqualTo(1);\n    assertThat(rule.getDefaultRemediationFunction()).isEqualTo(\"LINEAR_OFFSET\");\n    assertThat(rule.getDefaultRemediationCoefficient()).isEqualTo(\"1h\");\n    assertThat(rule.getDefaultRemediationOffset()).isEqualTo(\"5min\");\n    assertThat(rule.getEffortToFixDescription()).isEqualTo(\"desc\");\n    assertThat(rule.getTags()).containsOnly(\"usertag1\", \"usertag2\");\n    assertThat(rule.getSystemTags()).containsOnly(\"tag1\", \"tag4\");\n\n    List<RuleParamDto> params = db.ruleDao().findRuleParamsByRuleKey(dbSession, customRuleKey);\n    assertThat(params).hasSize(1);\n\n    RuleParamDto param = params.get(0);\n    // From template rule\n    assertThat(param.getName()).isEqualTo(\"regex\");\n    assertThat(param.getDescription()).isEqualTo(\"Reg ex\");\n    assertThat(param.getType()).isEqualTo(\"STRING\");\n    // From user\n    assertThat(param.getDefaultValue()).isEqualTo(\"a.*\");\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_invalid_severity() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(\"INVALID\")\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"This severity is invalid : INVALID\");\n    }\n  }","id":51284,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_invalid_severity() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"CUSTOM_RULE\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(\"INVALID\")\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"This severity is invalid : INVALID\");\n    }\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void delete_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Create template rule\n    RuleKey templateRuleKey = RuleKey.of(\"java\", \"S001\");\n    dao.insert(dbSession, RuleTesting.newDto(templateRuleKey).setCardinality(Cardinality.MULTIPLE));\n    dbSession.commit();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRuleKey)\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = service.create(newRule);\n\n    // Delete custom rule\n    service.delete(customRuleKey);\n  }","id":51285,"modified_method":"@Test\n  public void delete_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Create template rule\n    RuleKey templateRuleKey = RuleKey.of(\"java\", \"S001\");\n    dao.insert(dbSession, RuleTesting.newDto(templateRuleKey).setCardinality(Cardinality.MULTIPLE));\n    dbSession.commit();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"MY_CUSTOM\")\n      .setTemplateKey(templateRuleKey)\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = service.create(newRule);\n\n    // Delete custom rule\n    service.delete(customRuleKey);\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Create template rule\n    RuleKey templateRuleKey = RuleKey.of(\"java\", \"S001\");\n    dao.insert(dbSession, RuleTesting.newDto(templateRuleKey).setCardinality(Cardinality.MULTIPLE));\n    dbSession.commit();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRuleKey)\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = service.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = dao.getNullableByKey(dbSession, customRuleKey);\n    assertThat(rule).isNotNull();\n  }","id":51286,"modified_method":"@Test\n  public void create_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Create template rule\n    RuleKey templateRuleKey = RuleKey.of(\"java\", \"S001\");\n    dao.insert(dbSession, RuleTesting.newDto(templateRuleKey).setCardinality(Cardinality.MULTIPLE));\n    dbSession.commit();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"MY_CUSTOM\")\n      .setTemplateKey(templateRuleKey)\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"regex\", \"a.*\"));\n    RuleKey customRuleKey = service.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = dao.getNullableByKey(dbSession, customRuleKey);\n    assertThat(rule).isNotNull();\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Template rule\n    RuleDto templateRule = ruleDao.insert(session, RuleTesting.newDto(RuleKey.of(\"java\", \"S001\")).setCardinality(Cardinality.MULTIPLE));\n    RuleParamDto param = RuleParamDto.createFor(templateRule).setName(\"regex\").setType(\"STRING\").setDescription(\"Reg ex\").setDefaultValue(\".*\");\n    ruleDao.addRuleParam(session, templateRule, param);\n    session.commit();\n\n    // Custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"Old custom\")\n      .setHtmlDescription(\"Old description\")\n      .setSeverity(Severity.MINOR)\n      .setStatus(RuleStatus.BETA)\n      .setParameters(ImmutableMap.of(\"regex\", \"a\"));\n    RuleKey customRuleKey = ruleService.create(newRule);\n    session.clearCache();\n\n    WsTester.TestRequest request = wsTester.newGetRequest(\"api/rules\", \"update\")\n      .setParam(\"key\", customRuleKey.toString())\n      .setParam(\"name\", \"My custom rule\")\n      .setParam(\"html_description\", \"Description\")\n      .setParam(\"severity\", \"MAJOR\")\n      .setParam(\"status\", \"BETA\")\n      .setParam(\"params\", \"regex=a.*\");\n    request.execute().assertJson(getClass(), \"update_custom_rule.json\", false);\n  }","id":51287,"modified_method":"@Test\n  public void update_custom_rule() throws Exception {\n    MockUserSession.set()\n      .setGlobalPermissions(GlobalPermissions.QUALITY_PROFILE_ADMIN)\n      .setLogin(\"me\");\n\n    // Template rule\n    RuleDto templateRule = ruleDao.insert(session, RuleTesting.newDto(RuleKey.of(\"java\", \"S001\")).setCardinality(Cardinality.MULTIPLE));\n    RuleParamDto param = RuleParamDto.createFor(templateRule).setName(\"regex\").setType(\"STRING\").setDescription(\"Reg ex\").setDefaultValue(\".*\");\n    ruleDao.addRuleParam(session, templateRule, param);\n    session.commit();\n\n    // Custom rule\n    NewRule newRule = new NewRule()\n      .setRuleKey(\"MY_CUSTOM\")\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"Old custom\")\n      .setHtmlDescription(\"Old description\")\n      .setSeverity(Severity.MINOR)\n      .setStatus(RuleStatus.BETA)\n      .setParameters(ImmutableMap.of(\"regex\", \"a\"));\n    RuleKey customRuleKey = ruleService.create(newRule);\n    session.clearCache();\n\n    WsTester.TestRequest request = wsTester.newGetRequest(\"api/rules\", \"update\")\n      .setParam(\"key\", customRuleKey.toString())\n      .setParam(\"name\", \"My custom rule\")\n      .setParam(\"html_description\", \"Description\")\n      .setParam(\"severity\", \"MAJOR\")\n      .setParam(\"status\", \"BETA\")\n      .setParam(\"params\", \"regex=a.*\");\n    request.execute().assertJson(getClass(), \"update_custom_rule.json\", false);\n  }","commit_id":"a774a62aec4318d3db04aaa8bc0a4cf741959f03","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private AggregationBuilder getAssigneesFacet(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery) {\n    String fieldName = IssueNormalizer.IssueField.ASSIGNEE.field();\n    String facetName = IssueFilterParameters.ASSIGNEES;\n\n    // Same as in super.stickyFacetBuilder\n    BoolFilterBuilder facetFilter = getStickyFacetFilter(esQuery, filters, fieldName);\n    FilterAggregationBuilder facetTopAggregation = buildTopFacetAggregation(fieldName, facetName, facetFilter);\n    addSelectedItemsToFacet(fieldName, facetName, facetTopAggregation, query.assignees().toArray());\n\n    // Add missing facet for unassigned issues\n    facetTopAggregation.subAggregation(\n      AggregationBuilders\n        .missing(facetName + \"_missing\")\n        .field(fieldName)\n      );\n\n    return AggregationBuilders\n      .global(facetName)\n      .subAggregation(facetTopAggregation);\n  }","id":51288,"modified_method":"private AggregationBuilder getAssigneesFacet(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery) {\n    String fieldName = IssueNormalizer.IssueField.ASSIGNEE.field();\n    String facetName = IssueFilterParameters.ASSIGNEES;\n\n    // Same as in super.stickyFacetBuilder\n    Map<String, FilterBuilder> assigneeFilters = Maps.newHashMap(filters);\n    assigneeFilters.remove(\"__isAssigned\");\n    assigneeFilters.remove(fieldName);\n    BoolFilterBuilder facetFilter = getStickyFacetFilter(esQuery, assigneeFilters, fieldName);\n    FilterAggregationBuilder facetTopAggregation = buildTopFacetAggregation(fieldName, facetName, facetFilter);\n    addSelectedItemsToFacet(fieldName, facetName, facetTopAggregation, query.assignees().toArray());\n\n    // Add missing facet for unassigned issues\n    facetTopAggregation.subAggregation(\n      AggregationBuilders\n        .missing(facetName + \"_missing\")\n        .field(fieldName)\n      );\n\n    return AggregationBuilders\n      .global(facetName)\n      .subAggregation(facetTopAggregation);\n  }","commit_id":"475f89e829fee978c2f01395cd13fc2f9951bb7c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private AggregationBuilder getResolutionFacet(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery) {\n    String fieldName = IssueNormalizer.IssueField.RESOLUTION.field();\n    String facetName = IssueFilterParameters.RESOLUTIONS;\n\n    // Same as in super.stickyFacetBuilder\n    BoolFilterBuilder facetFilter = getStickyFacetFilter(esQuery, filters, fieldName);\n    FilterAggregationBuilder facetTopAggregation = buildTopFacetAggregation(fieldName, facetName, facetFilter);\n    addSelectedItemsToFacet(fieldName, facetName, facetTopAggregation, query.resolutions().toArray());\n\n    // Add missing facet for unresolved issues\n    facetTopAggregation.subAggregation(\n      AggregationBuilders\n        .missing(facetName + \"_missing\")\n        .field(fieldName)\n      );\n\n    return AggregationBuilders\n      .global(facetName)\n      .subAggregation(facetTopAggregation);\n  }","id":51289,"modified_method":"private AggregationBuilder getResolutionFacet(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery) {\n    String fieldName = IssueNormalizer.IssueField.RESOLUTION.field();\n    String facetName = IssueFilterParameters.RESOLUTIONS;\n\n    // Same as in super.stickyFacetBuilder\n    Map<String, FilterBuilder> resolutionFilters = Maps.newHashMap(filters);\n    resolutionFilters.remove(\"__isResolved\");\n    resolutionFilters.remove(fieldName);\n    BoolFilterBuilder facetFilter = getStickyFacetFilter(esQuery, resolutionFilters, fieldName);\n    FilterAggregationBuilder facetTopAggregation = buildTopFacetAggregation(fieldName, facetName, facetFilter);\n    addSelectedItemsToFacet(fieldName, facetName, facetTopAggregation, query.resolutions().toArray());\n\n    // Add missing facet for unresolved issues\n    facetTopAggregation.subAggregation(\n      AggregationBuilders\n        .missing(facetName + \"_missing\")\n        .field(fieldName)\n      );\n\n    return AggregationBuilders\n      .global(facetName)\n      .subAggregation(facetTopAggregation);\n  }","commit_id":"475f89e829fee978c2f01395cd13fc2f9951bb7c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Result<Rule> search(RuleQuery query, QueryContext options) {\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    QueryBuilder qb = this.getQuery(query);\n    Map<String, FilterBuilder> filters = this.getFilters(query, options);\n\n    if (options.isFacet()) {\n      Logger.getLogger(this.getClass()).info(\"Facets = \" + options.facets());\n      for (AggregationBuilder aggregation : getFacets(qb, filters).values()) {\n        esSearch.addAggregation(aggregation);\n      }\n    }\n\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n    setFields(options, esSearch);\n\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n    for (FilterBuilder ffb : filters.values()) {\n      fb.must(ffb);\n    }\n\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n    SearchResponse esResult = getClient().execute(esSearch);\n    return new Result<Rule>(this, esResult);\n  }","id":51290,"modified_method":"public Result<Rule> search(RuleQuery query, QueryContext options) {\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    QueryBuilder qb = this.getQuery(query);\n    Map<String, FilterBuilder> filters = this.getFilters(query, options);\n\n    if (options.isFacet()) {\n      for (AggregationBuilder aggregation : getFacets(qb, filters).values()) {\n        esSearch.addAggregation(aggregation);\n      }\n    }\n\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n    setFields(options, esSearch);\n\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n    for (FilterBuilder ffb : filters.values()) {\n      fb.must(ffb);\n    }\n\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n    SearchResponse esResult = getClient().execute(esSearch);\n    return new Result<Rule>(this, esResult);\n  }","commit_id":"475f89e829fee978c2f01395cd13fc2f9951bb7c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void display_facets() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project)\n      .setIssueCreationDate(DateUtils.parseDate(\"2014-09-04\"))\n      .setIssueUpdateDate(DateUtils.parseDate(\"2014-12-04\"))\n      .setRule(rule)\n      .setDebt(10L)\n      .setProject(project)\n      .setComponent(file)\n      .setStatus(\"OPEN\").setResolution(\"OPEN\")\n      .setKee(\"82fd47d4-b650-4037-80bc-7b112bd4eac2\")\n      .setSeverity(\"MAJOR\");\n    db.issueDao().insert(session, issue);\n    session.commit();\n\n    WsTester.Result result = wsTester.newGetRequest(IssuesWs.API_ENDPOINT, SearchAction.SEARCH_ACTION)\n      .setParam(SearchAction.PARAM_FACETS, \"statuses,severities,resolutions,componentRoots,rules,components,assignees,languages\")\n      .execute();\n    result.assertJson(this.getClass(), \"display_facets.json\", false);\n  }","id":51291,"modified_method":"@Test\n  public void display_facets() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project)\n      .setIssueCreationDate(DateUtils.parseDate(\"2014-09-04\"))\n      .setIssueUpdateDate(DateUtils.parseDate(\"2014-12-04\"))\n      .setRule(rule)\n      .setDebt(10L)\n      .setProject(project)\n      .setComponent(file)\n      .setStatus(\"OPEN\")\n      .setKee(\"82fd47d4-b650-4037-80bc-7b112bd4eac2\")\n      .setSeverity(\"MAJOR\");\n    db.issueDao().insert(session, issue);\n    session.commit();\n\n    WsTester.Result result = wsTester.newGetRequest(IssuesWs.API_ENDPOINT, SearchAction.SEARCH_ACTION)\n      .setParam(\"resolved\", \"false\")\n      .setParam(SearchAction.PARAM_FACETS, \"statuses,severities,resolutions,componentRoots,rules,components,assignees,languages\")\n      .execute();\n    result.assertJson(this.getClass(), \"display_facets.json\", false);\n  }","commit_id":"475f89e829fee978c2f01395cd13fc2f9951bb7c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void hide_rules() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project)\n      .setIssueCreationDate(DateUtils.parseDate(\"2014-09-04\"))\n      .setIssueUpdateDate(DateUtils.parseDate(\"2014-12-04\"))\n      .setRule(rule)\n      .setDebt(10L)\n      .setProject(project)\n      .setComponent(file)\n      .setStatus(\"OPEN\").setResolution(\"OPEN\")\n      .setKee(\"82fd47d4-b650-4037-80bc-7b112bd4eac2\")\n      .setSeverity(\"MAJOR\");\n    db.issueDao().insert(session, issue);\n    session.commit();\n\n    WsTester.Result result = wsTester.newGetRequest(IssuesWs.API_ENDPOINT, SearchAction.SEARCH_ACTION).setParam(IssueFilterParameters.HIDE_RULES, \"true\").execute();\n    result.assertJson(this.getClass(), \"hide_rules.json\", false);\n  }","id":51292,"modified_method":"@Test\n  public void hide_rules() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project)\n      .setIssueCreationDate(DateUtils.parseDate(\"2014-09-04\"))\n      .setIssueUpdateDate(DateUtils.parseDate(\"2014-12-04\"))\n      .setRule(rule)\n      .setDebt(10L)\n      .setProject(project)\n      .setComponent(file)\n      .setStatus(\"OPEN\")\n      .setKee(\"82fd47d4-b650-4037-80bc-7b112bd4eac2\")\n      .setSeverity(\"MAJOR\");\n    db.issueDao().insert(session, issue);\n    session.commit();\n\n    WsTester.Result result = wsTester.newGetRequest(IssuesWs.API_ENDPOINT, SearchAction.SEARCH_ACTION).setParam(IssueFilterParameters.HIDE_RULES, \"true\").execute();\n    result.assertJson(this.getClass(), \"hide_rules.json\", false);\n  }","commit_id":"475f89e829fee978c2f01395cd13fc2f9951bb7c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void distributehorizontal()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        \n        int min = 99999;\n        int max = -99999;\n        int sels = chef.jobMeta.nrSelected();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum x coordinate...\n        int selnr = 0;\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.x < min) min = p.x;\n                if (p.x > max) max = p.x;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the jobentries in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = chef.jobMeta.getJobEntry(order[j]).getLocation();\n                Point p2 = chef.jobMeta.getJobEntry(order[j + 1]).getLocation();\n                if (p1.x > p2.x) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two jobentries becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            jobentries[i] = chef.jobMeta.getJobEntry(order[i]);\n            Point p = jobentries[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.x = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n        \n        // Undo!\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n\n        redraw();\n    }","id":51293,"modified_method":"private void distributehorizontal()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        \n        int min = 99999;\n        int max = -99999;\n        int sels = chef.jobMeta.nrSelected();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum x coordinate...\n        int selnr = 0;\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.x < min) min = p.x;\n                if (p.x > max) max = p.x;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the jobentries in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = chef.jobMeta.getJobEntry(order[j]).getLocation();\n                Point p2 = chef.jobMeta.getJobEntry(order[j + 1]).getLocation();\n                if (p1.x > p2.x) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two jobentries becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            jobentries[i] = chef.jobMeta.getJobEntry(order[i]);\n            Point p = jobentries[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.x = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n        \n        // Undo!\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public ChefGraph(Composite par, int style, Chef je) \n\t{\n\t\tsuper(par, style);\n\t\tshell = par.getShell();\n\t\tlog = LogWriter.getInstance();\n\t\tchef = je;\n\t\tcanvas = this;\n        \n\t\tnewProps();\n\t\t\n\t\tselrect = null;\n\t\thop_candidate = null;\n\t\tlast_hop_split = null;\n\n\t\tselected_entries = null;\n\t\tselected_note = null;\n        \n        hori = getHorizontalBar();\n\t\tvert = getVerticalBar();\n\n\t\thori.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tredraw();\n\t\t\t}\n\t\t});\n\t\tvert.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tredraw();\n\t\t\t}\n\t\t});\n\t\thori.setThumb(100);\n\t\tvert.setThumb(100);\n\n\t\thori.setVisible(true);\n\t\tvert.setVisible(true);\n\n\t\tsetVisible(true);\n\t\t\n\t\tloadImages();\n\n\t\taddPaintListener(new PaintListener() {\n\t\t\tpublic void paintControl(PaintEvent e) {\n\t\t\t\tChefGraph.this.paintControl(e);\n\t\t\t}\n\t\t});\n\n\t\tselected_entries = null;\n\t\tlastclick = null;\n\n\t\taddKeyListener(new KeyAdapter() \n\t\t{\n\t\t\tpublic void keyPressed(KeyEvent e) \n\t\t\t{\n\t\t\t\tshift = (e.keyCode == SWT.SHIFT);\n\t\t\t\tcontrol = (e.keyCode == SWT.CONTROL);\n\t\t\t}\n\n\t\t\tpublic void keyReleased(KeyEvent e) \n\t\t\t{\n\t\t\t\tshift = (e.keyCode == SWT.SHIFT);\n\t\t\t\tcontrol = (e.keyCode == SWT.CONTROL);\n\t\t\t}\n\t\t});\n\n\t\taddMouseListener(new MouseAdapter() \n\t\t{\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) \n\t\t\t{\n\t\t\t    clearSettings();\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\t\n\t\t\t\tJobEntryCopy jobentry = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\tif (jobentry != null) \n\t\t\t\t{\n\t\t\t\t\tif (e.button==1) \n\t\t\t\t\t{\n\t\t\t\t\t\teditEntry(jobentry);\n\t\t\t\t\t}\n\t\t\t\t\telse // launch Chef or Spoon \n\t\t\t\t\t{\n\t\t\t\t\t\tlaunchStuff(jobentry);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// Check if point lies on one of the many hop-lines...\n\t\t\t\t\tJobHopMeta online = findJobHop(real.x, real.y);\n\t\t\t\t\tif (online != null) \n\t\t\t\t\t{\n\t\t\t\t\t\t// editJobHop(online);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNotePadMeta ni = chef.jobMeta.getNote(real.x, real.y);\n\t\t\t\t\t\tif (ni!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teditNote(ni);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void mouseDown(MouseEvent e) \n\t\t\t{\n                clearSettings();\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n                \n\t\t\t\tlast_button = e.button;\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\n\t\t\t\t// Clear the tooltip!\n\t\t\t\tsetToolTipText(null);\n\n\t\t\t\t// Set the pop-up menu\n\t\t\t\tsetMenu(real.x, real.y);\n\t\t\t\t\n\t\t\t\tJobEntryCopy je = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\tif (je != null) \n\t\t\t\t{\n\t\t\t\t\tselected_entries = chef.jobMeta.getSelectedEntries();\n\t\t\t\t\tselected_icon = je;\n\t\t\t\t\t// make sure this is correct!!!\n\t\t\t\t\t// When an icon is moved that is not selected, it gets selected too late.\n\t\t\t\t\t// It is not captured here, but in the mouseMoveListener...\n\t\t\t\t\tprev_locations = chef.jobMeta.getSelectedLocations();\n\n\t\t\t\t\tPoint p = je.getLocation();\n\t\t\t\t\ticonoffset = new Point(real.x - p.x, real.y - p.y);\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// Dit we hit a note?\n\t\t\t\t\tNotePadMeta ni = chef.jobMeta.getNote(real.x, real.y);\n\t\t\t\t\tif (ni!=null && last_button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tselected_note = ni;\n\t\t\t\t\t\tPoint loc = ni.getLocation();\n\t\t\t\t\t\tprevious_note_location = new Point(loc.x, loc.y);\n\t\t\t\t\t\tnoteoffset = new Point(real.x - loc.x, real.y - loc.y);\n\t\t\t\t\t\tSystem.out.println(\"We hit a note!!\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tselrect = new Rectangle(real.x, real.y, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastclick = new Point(real.x, real.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void mouseUp(MouseEvent e) \n\t\t\t{\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n\n\t\t\t\tif (iconoffset==null) iconoffset=new Point(0,0);\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\tPoint icon = new Point(real.x - iconoffset.x, real.y - iconoffset.y);\n\n\t\t\t\t// See if we need to add a hop...\n\t\t\t\tif (hop_candidate != null) \n\t\t\t\t{\n\t\t\t\t\t// hop doesn't already exist\n\t\t\t\t\tif (chef.jobMeta.findJobHop(hop_candidate.from_entry, hop_candidate.to_entry) == null) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (!hop_candidate.from_entry.evaluates() && hop_candidate.from_entry.isUnconditional())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thop_candidate.setUnconditional();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thop_candidate.setConditional();\n\t\t\t\t\t\t\tint nr = chef.jobMeta.findNrNextChefGraphEntries(hop_candidate.from_entry);\n\t\n\t\t\t\t\t\t\t// If there is one green link: make this one red! (or vice-versa)\n\t\t\t\t\t\t\tif (nr == 1) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tJobEntryCopy jge = chef.jobMeta.findNextChefGraphEntry(hop_candidate.from_entry, 0);\n\t\t\t\t\t\t\t\tJobHopMeta other = chef.jobMeta.findJobHop(hop_candidate.from_entry, jge);\n\t\t\t\t\t\t\t\tif (other != null) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\thop_candidate.setEvaluation(!other.getEvaluation());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tchef.jobMeta.addJobHop(hop_candidate);\n\t\t\t\t\t\tchef.addUndoNew(new JobHopMeta[] { hop_candidate }, new int[] { chef.jobMeta.indexOfJobHop(hop_candidate) } );\n\t\t\t\t\t\tchef.refreshTree();\n\t\t\t\t\t}\n\t\t\t\t\thop_candidate = null;\n\t\t\t\t\tselected_entries = null;\n\t\t\t\t\tlast_button = 0;\n\t\t\t\t\tredraw();\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\t// Did we select a region on the screen?  \n\t\t\t\telse if (selrect != null) \n\t\t\t\t{\n\t\t\t\t\tselrect.width  = real.x - selrect.x;\n\t\t\t\t\tselrect.height = real.y - selrect.y;\n\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tchef.jobMeta.selectInRect(selrect);\n\t\t\t\t\tselrect = null;\n\t\t\t\t\tredraw();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Clicked on an icon?\n\t\t\t\t//\n\t\t\t\telse if (selected_icon != null)\n\t\t\t\t{\n\t\t\t\t\tif (e.button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lastclick.x == e.x && lastclick.y == e.y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Flip selection when control is pressed!\n\t\t\t\t\t\t\tif (control)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tselected_icon.flipSelected();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Otherwise, select only the icon clicked on!\n\t\t\t\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\t\t\t\tselected_icon.setSelected(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // We moved around some items: store undo info...\n\t\t\t\t\t\tif (selected_entries != null && prev_locations != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint indexes[] = chef.jobMeta.getEntryIndexes(selected_entries); \n\t\t\t\t\t\t\tchef.addUndoPosition(selected_entries, indexes, prev_locations, chef.jobMeta.getSelectedLocations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// OK, we moved the step, did we move it across a hop?\n\t\t\t\t\t// If so, ask to split the hop!\n\t\t\t\t\tif (split_hop)\n\t\t\t\t\t{\n\t\t\t\t\t\tJobHopMeta hi = findJobHop(icon.x + iconsize / 2, icon.y + iconsize / 2);\n\t\t\t\t\t\tif (hi != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint id = 0;\n\t\t\t\t\t\t\tif (!chef.props.getAutoSplit())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMessageDialogWithToggle md = new MessageDialogWithToggle(shell, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Split hop?\", \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Do you want to split this hop?\"+Const.CR+hi.from_entry.getName()+\" --> \"+hi.to_entry.getName(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t MessageDialog.QUESTION,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t new String[] { \"Yes\", \"No\" },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Don't ask again\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t chef.props.getAutoSplit()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t );\n\t\t\t\t\t\t\t\tid = md.open();\n\t\t\t\t\t\t\t\tchef.props.setAutoSplit(md.getToggleState());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (id == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tJobHopMeta newhop1 = new JobHopMeta(hi.from_entry, selected_icon);\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobHop(newhop1);\n\t\t\t\t\t\t\t\tJobHopMeta newhop2 = new JobHopMeta(selected_icon, hi.to_entry);\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobHop(newhop2);\n\t\t\t\t\t\t\t\tif (!selected_icon.evaluates()) newhop2.setUnconditional();\n\n\t\t\t\t\t\t\t\tchef.addUndoNew(new JobHopMeta[] { (JobHopMeta)newhop1.clone(), (JobHopMeta)newhop2.clone() }, new int[] { chef.jobMeta.indexOfJobHop(newhop1), chef.jobMeta.indexOfJobHop(newhop2)});\n\t\t\t\t\t\t\t\tint idx = chef.jobMeta.indexOfJobHop(hi);\n\t\t\t\t\t\t\t\tchef.addUndoDelete(new JobHopMeta[] { (JobHopMeta)hi.clone() }, new int[] { idx });\n\t\t\t\t\t\t\t\tchef.jobMeta.removeJobHop(idx);\n\t\t\t\t\t\t\t\tchef.refreshTree();\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsplit_hop = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tselected_entries = null;\n\t\t\t\t\tredraw();\n\t\t\t\t}\n \n\t\t\t\t// Notes?\n\t\t\t\telse if (selected_note != null)\n\t\t\t\t{\n\t\t\t\t\tPoint note = new Point(real.x - noteoffset.x, real.y - noteoffset.y);\n\t\t\t\t\tif (last_button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lastclick.x != e.x || lastclick.y != e.y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint indexes[] = new int[] { chef.jobMeta.indexOfNote(selected_note) };\n\t\t\t\t\t\t\tchef.addUndoPosition(new NotePadMeta[] { selected_note }, indexes, new Point[] { previous_note_location }, new Point[] { note });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tselected_note = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\taddMouseMoveListener(new MouseMoveListener() \n\t\t{\n\t\t\tpublic void mouseMove(MouseEvent e) \n\t\t\t{\n                // Remember the last position of the mouse for paste with keyboard\n                lastMove = new Point(e.x, e.y);\n\n\t\t\t\tif (iconoffset==null) iconoffset=new Point(0,0);\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\tPoint icon = new Point(real.x - iconoffset.x, real.y - iconoffset.y);\n\n\t\t\t\tsetToolTip(real.x, real.y);\n\n\t\t\t\t// First see if the icon we clicked on was selected.\n\t\t\t\t// If the icon was not selected, we should unselect all other icons,\n\t\t\t\t// selected and move only the one icon\n\t\t\t\tif (selected_icon != null && !selected_icon.isSelected())\n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tselected_icon.setSelected(true);\n\t\t\t\t\tselected_entries = new JobEntryCopy[] { selected_icon };\n\t\t\t\t\tprev_locations = new Point[] { selected_icon.getLocation()};\n\t\t\t\t}\n\n\t\t\t\t// Did we select a region...?\n\t\t\t\tif (selrect != null) \n\t\t\t\t{\n\t\t\t\t\tselrect.width = real.x - selrect.x;\n\t\t\t\t\tselrect.height = real.y - selrect.y;\n\t\t\t\t\tredraw();\n\t\t\t\t} \n\t\t\t\telse\n\t\t\t\t\n\t\t\t\t// Or just one entry on the screen?\n\t\t\t\tif (selected_entries != null) \n\t\t\t\t{\n\t\t\t\t\tif (last_button == 1 && !shift) \n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * One or more icons are selected and moved around...\n\t\t\t\t\t\t * \n\t\t\t\t\t\t * new : new position of the ICON (not the mouse pointer)\n\t\t\t\t\t\t * dx  : difference with previous position\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint dx = icon.x - selected_icon.getLocation().x;\n\t\t\t\t\t\tint dy = icon.y - selected_icon.getLocation().y;\n\n\t\t\t\t\t\tJobHopMeta hi =findJobHop(icon.x+iconsize/2, icon.y+iconsize/2);\n\t\t\t\t\t\tif (hi != null) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//log.logBasic(\"MouseMove\", \"Split hop candidate B!\");\n\t\t\t\t\t\t\tif (!chef.jobMeta.isEntryUsedInHops(selected_icon)) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//log.logBasic(\"MouseMove\", \"Split hop candidate A!\");\n\t\t\t\t\t\t\t\tsplit_hop = true;\n\t\t\t\t\t\t\t\tlast_hop_split = hi;\n\t\t\t\t\t\t\t\thi.setSplit(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (last_hop_split != null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlast_hop_split.setSplit(false);\n\t\t\t\t\t\t\t\tlast_hop_split = null;\n\t\t\t\t\t\t\t\tsplit_hop = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// One or more job entries are being moved around!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tfor (int i = 0; i < chef.jobMeta.nrJobEntries(); i++) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tJobEntryCopy je = chef.jobMeta.getJobEntry(i);\n\t\t\t\t\t\t\tif (je.isSelected()) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tje.setLocation(je.getLocation().x + dx, je.getLocation().y + dy);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// selected_icon.setLocation(icon.x, icon.y);\n\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t} \n\t\t\t\t\telse\n                    //\tThe middle button perhaps?\n\t\t\t\t\tif (last_button == 2 || (last_button == 1 && shift))\t\n\t\t\t\t\t{\n\t\t\t\t\t\tJobEntryCopy si = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\t\t\tif (si != null && !selected_icon.equals(si)) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hop_candidate == null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thop_candidate =\tnew JobHopMeta(selected_icon, si);\n\t\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hop_candidate != null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thop_candidate = null;\n\t\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t// are we moving a note around? \n\t\t\t\tif (selected_note!=null)\n\t\t\t\t{\n\t\t\t\t\tif (last_button==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tPoint note = new Point(real.x - noteoffset.x, real.y - noteoffset.y);\n\t\t\t\t\t\tselected_note.setLocation(note.x, note.y);\n\t\t\t\t\t\tchef.refreshGraph();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Drag & Drop for steps\n\t\tTransfer[] ttypes = new Transfer[] { TextTransfer.getInstance() };\n\t\tDropTarget ddTarget = new DropTarget(this, DND.DROP_MOVE | DND.DROP_COPY);\n\t\tddTarget.setTransfer(ttypes);\n\t\tddTarget.addDropListener(new DropTargetListener() \n\t\t{\n\t\t\tpublic void dragEnter(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = getRealPosition(canvas, event.x, event.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void dragLeave(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = null;\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void dragOperationChanged(DropTargetEvent event) \n\t\t\t{\n\t\t\t}\n\n\t\t\tpublic void dragOver(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = getRealPosition(canvas, event.x, event.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void drop(DropTargetEvent event) \n\t\t\t{\n\t\t\t\t// no data to copy, indicate failure in event.detail \n\t\t\t\tif (event.data == null)\n\t\t\t\t{\n\t\t\t\t\tevent.detail = DND.DROP_NONE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoint p = getRealPosition(canvas, event.x, event.y);\n\t\t\t\t\n\t\t\t\tStringTokenizer strtok = new StringTokenizer((String) event.data, Const.CR);\n\t\t\t\tif (strtok.countTokens() == 1) \n\t\t\t\t{\n\t\t\t\t\tString entry = strtok.nextToken();\n\t\t\t\t\t//System.out.println(\"new entry: \"+entry);\n\t\t\t\t\t\n\t\t\t\t\tJobEntryCopy jge = chef.jobMeta.findJobEntry(entry, 0);\n\n\t\t\t\t\tif (jge != null)  // Create duplicate of existing entry \n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"DROP \"+jge.toString()+\", type=\"+ JobEntryCopy.getTypeDesc(jge.getType())+\", start=\"+jge.isStart()+\", drawn=\"+jge.isDrawn());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// There can be only 1 start!\n\t\t\t\t\t\tif (jge.isStart() && jge.isDrawn()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.YES | SWT.ICON_ERROR);\n\t\t\t\t\t\t\tmb.setMessage(\"You can only use the start icon once in a job.\");\n\t\t\t\t\t\t\tmb.setText(\"Sorry!\");\n\t\t\t\t\t\t\tmb.open();\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboolean jge_changed=false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// For undo :\n\t\t\t\t\t\tJobEntryCopy before = (JobEntryCopy)jge.clone_deep();\n\t\t\t\t\t\t\n\t\t\t\t\t\tJobEntryCopy newjge = jge;\n\t\t\t\t\t\tif (jge.isDrawn()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnewjge = (JobEntryCopy)jge.clone();\n\t\t\t\t\t\t\tif (newjge!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// newjge.setEntry(jge.getEntry());\n\t\t\t\t\t\t\t\tlog.logDebug(toString(), \"entry aft = \"+((Object)jge.getEntry()).toString());\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnewjge.setNr(chef.jobMeta.findUnusedNr(newjge.getName()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobEntry(newjge);\n\t\t\t\t\t\t\t\tchef.addUndoNew(new JobEntryCopy[] {newjge}, new int[] { chef.jobMeta.indexOfJobEntry(newjge)} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.logDebug(toString(), \"jge is not cloned!\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.logDebug(toString(), jge.toString()+\" is not drawn\");\n\t\t\t\t\t\t\tjge_changed=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewjge.setLocation(p.x, p.y);\n\t\t\t\t\t\tnewjge.setDrawn();\n\t\t\t\t\t\tif (jge_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchef.addUndoChange(new JobEntryCopy[] { before }, new JobEntryCopy[] {newjge}, new int[] { chef.jobMeta.indexOfJobEntry(newjge)});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t\tchef.refreshTree();\n\t\t\t\t\t\tlog.logBasic(\"DropTargetEvent\", \"DROP \"+newjge.toString()+\"!, type=\"+ JobEntryCopy.getTypeDesc(newjge.getType()));\n\t\t\t\t\t} \n\t\t\t\t\telse // Entry doesn't exist: create new one.\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"New entry of type [\"+entry+\"]\"); \n\t\t\t\t\t\t\n\t\t\t\t\t\tjge = chef.newChefGraphEntry(entry);\n\t\t\t\t\t\tif (jge != null) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjge.setLocation(p.x, p.y);\n\t\t\t\t\t\t\tjge.setDrawn();\n\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void dropAccept(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = null;\n\t\t\t}\n\t\t});\n\n\t\t// Keyboard shortcuts...\n\t\taddKeyListener(new KeyAdapter() \n\t\t{\n\t\t\tpublic void keyPressed(KeyEvent e) \n\t\t\t{\n\t\t\t\tif ((int) e.character == 1) // CTRL-A\n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.selectAll();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n                if ((int) e.character == 3) // CTRL-C\n                {\n                    chef.copyJobEntries(chef.jobMeta.getSelectedEntries());\n                }\n                if ((int) e.character == 22) // CTRL-V\n                {\n                    String clipcontent = chef.fromClipboard();\n                    if (clipcontent != null)\n                    {\n                        if (lastMove != null)\n                        {\n                            chef.pasteSteps(clipcontent, lastMove);\n                        }\n                    }\n\n                    //spoon.pasteSteps( );\n                }\n\t\t\t\tif (e.keyCode == SWT.ESC) \n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n                // CTRL-UP : allignTop();\n                if (e.keyCode == SWT.ARROW_UP && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    alligntop();\n                }\n                // CTRL-DOWN : allignBottom();\n                if (e.keyCode == SWT.ARROW_DOWN && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignbottom();\n                }\n                // CTRL-LEFT : allignleft();\n                if (e.keyCode == SWT.ARROW_LEFT && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignleft();\n                }\n                // CTRL-RIGHT : allignRight();\n                if (e.keyCode == SWT.ARROW_RIGHT && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignright();\n                }\n                // ALT-RIGHT : distributeHorizontal();\n                if (e.keyCode == SWT.ARROW_RIGHT && (e.stateMask & SWT.ALT) != 0)\n                {\n                    distributehorizontal();\n                }\n                // ALT-UP : distributeVertical();\n                if (e.keyCode == SWT.ARROW_UP && (e.stateMask & SWT.ALT) != 0)\n                {\n                    distributevertical();\n                }\n                // ALT-HOME : snap to grid\n                if (e.keyCode == SWT.HOME && (e.stateMask & SWT.ALT) != 0)\n                {\n                    snaptogrid(Const.GRID_SIZE);\n                }\n\t\t\t}\n\t\t});\n\n\t\taddKeyListener(chef.defKeys);\n\n\t\tsetBackground(GUIResource.getInstance().getColorBackground());\n\t}","id":51294,"modified_method":"public ChefGraph(Composite par, int style, Chef je) \n\t{\n\t\tsuper(par, style);\n\t\tshell = par.getShell();\n\t\tlog = LogWriter.getInstance();\n\t\tchef = je;\n\t\tcanvas = this;\n        \n\t\tnewProps();\n\t\t\n\t\tselrect = null;\n\t\thop_candidate = null;\n\t\tlast_hop_split = null;\n\n\t\tselected_entries = null;\n\t\tselected_note = null;\n        \n        hori = getHorizontalBar();\n\t\tvert = getVerticalBar();\n\n\t\thori.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tredraw();\n\t\t\t}\n\t\t});\n\t\tvert.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tredraw();\n\t\t\t}\n\t\t});\n\t\thori.setThumb(100);\n\t\tvert.setThumb(100);\n\n\t\thori.setVisible(true);\n\t\tvert.setVisible(true);\n\n\t\tsetVisible(true);\n\t\t\n\t\tloadImages();\n\n\t\taddPaintListener(new PaintListener() {\n\t\t\tpublic void paintControl(PaintEvent e) {\n\t\t\t\tChefGraph.this.paintControl(e);\n\t\t\t}\n\t\t});\n\n\t\tselected_entries = null;\n\t\tlastclick = null;\n\n\t\taddKeyListener(new KeyAdapter() \n\t\t{\n\t\t\tpublic void keyPressed(KeyEvent e) \n\t\t\t{\n\t\t\t\tshift = (e.keyCode == SWT.SHIFT);\n\t\t\t\tcontrol = (e.keyCode == SWT.CONTROL);\n\t\t\t}\n\n\t\t\tpublic void keyReleased(KeyEvent e) \n\t\t\t{\n\t\t\t\tshift = (e.keyCode == SWT.SHIFT);\n\t\t\t\tcontrol = (e.keyCode == SWT.CONTROL);\n\t\t\t}\n\t\t});\n\n\t\taddMouseListener(new MouseAdapter() \n\t\t{\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) \n\t\t\t{\n\t\t\t    clearSettings();\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\t\n\t\t\t\tJobEntryCopy jobentry = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\tif (jobentry != null) \n\t\t\t\t{\n\t\t\t\t\tif (e.button==1) \n\t\t\t\t\t{\n\t\t\t\t\t\teditEntry(jobentry);\n\t\t\t\t\t}\n\t\t\t\t\telse // launch Chef or Spoon \n\t\t\t\t\t{\n\t\t\t\t\t\tlaunchStuff(jobentry);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// Check if point lies on one of the many hop-lines...\n\t\t\t\t\tJobHopMeta online = findJobHop(real.x, real.y);\n\t\t\t\t\tif (online != null) \n\t\t\t\t\t{\n\t\t\t\t\t\t// editJobHop(online);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNotePadMeta ni = chef.jobMeta.getNote(real.x, real.y);\n\t\t\t\t\t\tif (ni!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teditNote(ni);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void mouseDown(MouseEvent e) \n\t\t\t{\n                clearSettings();\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n                \n\t\t\t\tlast_button = e.button;\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\n\t\t\t\t// Clear the tooltip!\n\t\t\t\tsetToolTipText(null);\n\n\t\t\t\t// Set the pop-up menu\n\t\t\t\tsetMenu(real.x, real.y);\n\t\t\t\t\n\t\t\t\tJobEntryCopy je = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\tif (je != null) \n\t\t\t\t{\n\t\t\t\t\tselected_entries = chef.jobMeta.getSelectedEntries();\n\t\t\t\t\tselected_icon = je;\n\t\t\t\t\t// make sure this is correct!!!\n\t\t\t\t\t// When an icon is moved that is not selected, it gets selected too late.\n\t\t\t\t\t// It is not captured here, but in the mouseMoveListener...\n\t\t\t\t\tprev_locations = chef.jobMeta.getSelectedLocations();\n\n\t\t\t\t\tPoint p = je.getLocation();\n\t\t\t\t\ticonoffset = new Point(real.x - p.x, real.y - p.y);\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// Dit we hit a note?\n\t\t\t\t\tNotePadMeta ni = chef.jobMeta.getNote(real.x, real.y);\n\t\t\t\t\tif (ni!=null && last_button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tselected_note = ni;\n\t\t\t\t\t\tPoint loc = ni.getLocation();\n\t\t\t\t\t\tprevious_note_location = new Point(loc.x, loc.y);\n\t\t\t\t\t\tnoteoffset = new Point(real.x - loc.x, real.y - loc.y);\n\t\t\t\t\t\tSystem.out.println(\"We hit a note!!\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tselrect = new Rectangle(real.x, real.y, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastclick = new Point(real.x, real.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void mouseUp(MouseEvent e) \n\t\t\t{\n                control = (e.stateMask & SWT.CONTROL) != 0;\n                shift = (e.stateMask & SWT.SHIFT) != 0;\n\n\t\t\t\tif (iconoffset==null) iconoffset=new Point(0,0);\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\tPoint icon = new Point(real.x - iconoffset.x, real.y - iconoffset.y);\n\n\t\t\t\t// See if we need to add a hop...\n\t\t\t\tif (hop_candidate != null) \n\t\t\t\t{\n\t\t\t\t\t// hop doesn't already exist\n\t\t\t\t\tif (chef.jobMeta.findJobHop(hop_candidate.from_entry, hop_candidate.to_entry) == null) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (!hop_candidate.from_entry.evaluates() && hop_candidate.from_entry.isUnconditional())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thop_candidate.setUnconditional();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thop_candidate.setConditional();\n\t\t\t\t\t\t\tint nr = chef.jobMeta.findNrNextChefGraphEntries(hop_candidate.from_entry);\n\t\n\t\t\t\t\t\t\t// If there is one green link: make this one red! (or vice-versa)\n\t\t\t\t\t\t\tif (nr == 1) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tJobEntryCopy jge = chef.jobMeta.findNextChefGraphEntry(hop_candidate.from_entry, 0);\n\t\t\t\t\t\t\t\tJobHopMeta other = chef.jobMeta.findJobHop(hop_candidate.from_entry, jge);\n\t\t\t\t\t\t\t\tif (other != null) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\thop_candidate.setEvaluation(!other.getEvaluation());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tchef.jobMeta.addJobHop(hop_candidate);\n\t\t\t\t\t\tchef.addUndoNew(new JobHopMeta[] { hop_candidate }, new int[] { chef.jobMeta.indexOfJobHop(hop_candidate) } );\n\t\t\t\t\t\tchef.refreshTree();\n\t\t\t\t\t}\n\t\t\t\t\thop_candidate = null;\n\t\t\t\t\tselected_entries = null;\n\t\t\t\t\tlast_button = 0;\n\t\t\t\t\tredraw();\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\t// Did we select a region on the screen?  \n\t\t\t\telse if (selrect != null) \n\t\t\t\t{\n\t\t\t\t\tselrect.width  = real.x - selrect.x;\n\t\t\t\t\tselrect.height = real.y - selrect.y;\n\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tchef.jobMeta.selectInRect(selrect);\n\t\t\t\t\tselrect = null;\n\t\t\t\t\tredraw();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Clicked on an icon?\n\t\t\t\t//\n\t\t\t\telse if (selected_icon != null)\n\t\t\t\t{\n\t\t\t\t\tif (e.button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lastclick.x == e.x && lastclick.y == e.y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Flip selection when control is pressed!\n\t\t\t\t\t\t\tif (control)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tselected_icon.flipSelected();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Otherwise, select only the icon clicked on!\n\t\t\t\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\t\t\t\tselected_icon.setSelected(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // We moved around some items: store undo info...\n\t\t\t\t\t\tif (selected_entries != null && prev_locations != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint indexes[] = chef.jobMeta.getEntryIndexes(selected_entries); \n\t\t\t\t\t\t\tchef.addUndoPosition(selected_entries, indexes, prev_locations, chef.jobMeta.getSelectedLocations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// OK, we moved the step, did we move it across a hop?\n\t\t\t\t\t// If so, ask to split the hop!\n\t\t\t\t\tif (split_hop)\n\t\t\t\t\t{\n\t\t\t\t\t\tJobHopMeta hi = findJobHop(icon.x + iconsize / 2, icon.y + iconsize / 2);\n\t\t\t\t\t\tif (hi != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint id = 0;\n\t\t\t\t\t\t\tif (!chef.props.getAutoSplit())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMessageDialogWithToggle md = new MessageDialogWithToggle(shell, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Split hop?\", \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Do you want to split this hop?\"+Const.CR+hi.from_entry.getName()+\" --> \"+hi.to_entry.getName(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t MessageDialog.QUESTION,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t new String[] { \"Yes\", \"No\" },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Don't ask again\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t chef.props.getAutoSplit()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t );\n\t\t\t\t\t\t\t\tid = md.open();\n\t\t\t\t\t\t\t\tchef.props.setAutoSplit(md.getToggleState());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (id == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tJobHopMeta newhop1 = new JobHopMeta(hi.from_entry, selected_icon);\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobHop(newhop1);\n\t\t\t\t\t\t\t\tJobHopMeta newhop2 = new JobHopMeta(selected_icon, hi.to_entry);\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobHop(newhop2);\n\t\t\t\t\t\t\t\tif (!selected_icon.evaluates()) newhop2.setUnconditional();\n\n\t\t\t\t\t\t\t\tchef.addUndoNew(new JobHopMeta[] { (JobHopMeta)newhop1.clone(), (JobHopMeta)newhop2.clone() }, new int[] { chef.jobMeta.indexOfJobHop(newhop1), chef.jobMeta.indexOfJobHop(newhop2)});\n\t\t\t\t\t\t\t\tint idx = chef.jobMeta.indexOfJobHop(hi);\n\t\t\t\t\t\t\t\tchef.addUndoDelete(new JobHopMeta[] { (JobHopMeta)hi.clone() }, new int[] { idx });\n\t\t\t\t\t\t\t\tchef.jobMeta.removeJobHop(idx);\n\t\t\t\t\t\t\t\tchef.refreshTree();\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsplit_hop = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tselected_entries = null;\n\t\t\t\t\tredraw();\n\t\t\t\t}\n \n\t\t\t\t// Notes?\n\t\t\t\telse if (selected_note != null)\n\t\t\t\t{\n\t\t\t\t\tPoint note = new Point(real.x - noteoffset.x, real.y - noteoffset.y);\n\t\t\t\t\tif (last_button == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lastclick.x != e.x || lastclick.y != e.y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint indexes[] = new int[] { chef.jobMeta.indexOfNote(selected_note) };\n\t\t\t\t\t\t\tchef.addUndoPosition(new NotePadMeta[] { selected_note }, indexes, new Point[] { previous_note_location }, new Point[] { note });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tselected_note = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\taddMouseMoveListener(new MouseMoveListener() \n\t\t{\n\t\t\tpublic void mouseMove(MouseEvent e) \n\t\t\t{\n                // Remember the last position of the mouse for paste with keyboard\n                lastMove = new Point(e.x, e.y);\n\n\t\t\t\tif (iconoffset==null) iconoffset=new Point(0,0);\n\t\t\t\tPoint real = screen2real(e.x, e.y);\n\t\t\t\tPoint icon = new Point(real.x - iconoffset.x, real.y - iconoffset.y);\n\n\t\t\t\tsetToolTip(real.x, real.y);\n\n\t\t\t\t// First see if the icon we clicked on was selected.\n\t\t\t\t// If the icon was not selected, we should unselect all other icons,\n\t\t\t\t// selected and move only the one icon\n\t\t\t\tif (selected_icon != null && !selected_icon.isSelected())\n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tselected_icon.setSelected(true);\n\t\t\t\t\tselected_entries = new JobEntryCopy[] { selected_icon };\n\t\t\t\t\tprev_locations = new Point[] { selected_icon.getLocation()};\n\t\t\t\t}\n\n\t\t\t\t// Did we select a region...?\n\t\t\t\tif (selrect != null) \n\t\t\t\t{\n\t\t\t\t\tselrect.width = real.x - selrect.x;\n\t\t\t\t\tselrect.height = real.y - selrect.y;\n\t\t\t\t\tredraw();\n\t\t\t\t} \n\t\t\t\telse\n\t\t\t\t\n\t\t\t\t// Or just one entry on the screen?\n\t\t\t\tif (selected_entries != null) \n\t\t\t\t{\n\t\t\t\t\tif (last_button == 1 && !shift) \n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * One or more icons are selected and moved around...\n\t\t\t\t\t\t * \n\t\t\t\t\t\t * new : new position of the ICON (not the mouse pointer)\n\t\t\t\t\t\t * dx  : difference with previous position\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint dx = icon.x - selected_icon.getLocation().x;\n\t\t\t\t\t\tint dy = icon.y - selected_icon.getLocation().y;\n\n\t\t\t\t\t\tJobHopMeta hi =findJobHop(icon.x+iconsize/2, icon.y+iconsize/2);\n\t\t\t\t\t\tif (hi != null) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//log.logBasic(\"MouseMove\", \"Split hop candidate B!\");\n\t\t\t\t\t\t\tif (!chef.jobMeta.isEntryUsedInHops(selected_icon)) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//log.logBasic(\"MouseMove\", \"Split hop candidate A!\");\n\t\t\t\t\t\t\t\tsplit_hop = true;\n\t\t\t\t\t\t\t\tlast_hop_split = hi;\n\t\t\t\t\t\t\t\thi.setSplit(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (last_hop_split != null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlast_hop_split.setSplit(false);\n\t\t\t\t\t\t\t\tlast_hop_split = null;\n\t\t\t\t\t\t\t\tsplit_hop = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// One or more job entries are being moved around!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tfor (int i = 0; i < chef.jobMeta.nrJobEntries(); i++) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tJobEntryCopy je = chef.jobMeta.getJobEntry(i);\n\t\t\t\t\t\t\tif (je.isSelected()) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tje.setLocation(je.getLocation().x + dx, je.getLocation().y + dy);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// selected_icon.setLocation(icon.x, icon.y);\n\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t} \n\t\t\t\t\telse\n                    //\tThe middle button perhaps?\n\t\t\t\t\tif (last_button == 2 || (last_button == 1 && shift))\t\n\t\t\t\t\t{\n\t\t\t\t\t\tJobEntryCopy si = chef.jobMeta.getChefGraphEntry(real.x, real.y, iconsize);\n\t\t\t\t\t\tif (si != null && !selected_icon.equals(si)) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hop_candidate == null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thop_candidate =\tnew JobHopMeta(selected_icon, si);\n\t\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hop_candidate != null) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thop_candidate = null;\n\t\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t// are we moving a note around? \n\t\t\t\tif (selected_note!=null)\n\t\t\t\t{\n\t\t\t\t\tif (last_button==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tPoint note = new Point(real.x - noteoffset.x, real.y - noteoffset.y);\n\t\t\t\t\t\tselected_note.setLocation(note.x, note.y);\n\t\t\t\t\t\tchef.refreshGraph();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Drag & Drop for steps\n\t\tTransfer[] ttypes = new Transfer[] { TextTransfer.getInstance() };\n\t\tDropTarget ddTarget = new DropTarget(this, DND.DROP_MOVE | DND.DROP_COPY);\n\t\tddTarget.setTransfer(ttypes);\n\t\tddTarget.addDropListener(new DropTargetListener() \n\t\t{\n\t\t\tpublic void dragEnter(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = getRealPosition(canvas, event.x, event.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void dragLeave(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = null;\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void dragOperationChanged(DropTargetEvent event) \n\t\t\t{\n\t\t\t}\n\n\t\t\tpublic void dragOver(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = getRealPosition(canvas, event.x, event.y);\n\t\t\t\tredraw();\n\t\t\t}\n\n\t\t\tpublic void drop(DropTargetEvent event) \n\t\t\t{\n\t\t\t\t// no data to copy, indicate failure in event.detail \n\t\t\t\tif (event.data == null)\n\t\t\t\t{\n\t\t\t\t\tevent.detail = DND.DROP_NONE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoint p = getRealPosition(canvas, event.x, event.y);\n\t\t\t\t\n\t\t\t\tStringTokenizer strtok = new StringTokenizer((String) event.data, Const.CR);\n\t\t\t\tif (strtok.countTokens() == 1) \n\t\t\t\t{\n\t\t\t\t\tString entry = strtok.nextToken();\n\t\t\t\t\t//System.out.println(\"new entry: \"+entry);\n\t\t\t\t\t\n\t\t\t\t\tJobEntryCopy jge = chef.jobMeta.findJobEntry(entry, 0, true);\n\n\t\t\t\t\tif (jge != null)  // Create duplicate of existing entry \n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"DROP \"+jge.toString()+\", type=\"+ JobEntryCopy.getTypeDesc(jge.getType())+\", start=\"+jge.isStart()+\", drawn=\"+jge.isDrawn());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// There can be only 1 start!\n\t\t\t\t\t\tif (jge.isStart() && jge.isDrawn()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.YES | SWT.ICON_ERROR);\n\t\t\t\t\t\t\tmb.setMessage(\"You can only use the start icon once in a job.\");\n\t\t\t\t\t\t\tmb.setText(\"Sorry!\");\n\t\t\t\t\t\t\tmb.open();\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboolean jge_changed=false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// For undo :\n\t\t\t\t\t\tJobEntryCopy before = (JobEntryCopy)jge.clone_deep();\n\t\t\t\t\t\t\n\t\t\t\t\t\tJobEntryCopy newjge = jge;\n\t\t\t\t\t\tif (jge.isDrawn()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnewjge = (JobEntryCopy)jge.clone();\n\t\t\t\t\t\t\tif (newjge!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// newjge.setEntry(jge.getEntry());\n\t\t\t\t\t\t\t\tlog.logDebug(toString(), \"entry aft = \"+((Object)jge.getEntry()).toString());\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnewjge.setNr(chef.jobMeta.findUnusedNr(newjge.getName()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tchef.jobMeta.addJobEntry(newjge);\n\t\t\t\t\t\t\t\tchef.addUndoNew(new JobEntryCopy[] {newjge}, new int[] { chef.jobMeta.indexOfJobEntry(newjge)} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.logDebug(toString(), \"jge is not cloned!\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.logDebug(toString(), jge.toString()+\" is not drawn\");\n\t\t\t\t\t\t\tjge_changed=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewjge.setLocation(p.x, p.y);\n\t\t\t\t\t\tnewjge.setDrawn();\n\t\t\t\t\t\tif (jge_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchef.addUndoChange(new JobEntryCopy[] { before }, new JobEntryCopy[] {newjge}, new int[] { chef.jobMeta.indexOfJobEntry(newjge)});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t\tchef.refreshTree();\n\t\t\t\t\t\tlog.logBasic(\"DropTargetEvent\", \"DROP \"+newjge.toString()+\"!, type=\"+ JobEntryCopy.getTypeDesc(newjge.getType()));\n\t\t\t\t\t} \n\t\t\t\t\telse // Entry doesn't exist: create new one.\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"New entry of type [\"+entry+\"]\"); \n\t\t\t\t\t\t\n\t\t\t\t\t\tjge = chef.newChefGraphEntry(entry);\n\t\t\t\t\t\tif (jge != null) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjge.setLocation(p.x, p.y);\n\t\t\t\t\t\t\tjge.setDrawn();\n\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void dropAccept(DropTargetEvent event) \n\t\t\t{\n\t\t\t\tdrop_candidate = null;\n\t\t\t}\n\t\t});\n\n\t\t// Keyboard shortcuts...\n\t\taddKeyListener(new KeyAdapter() \n\t\t{\n\t\t\tpublic void keyPressed(KeyEvent e) \n\t\t\t{\n\t\t\t\tif ((int) e.character == 1) // CTRL-A\n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.selectAll();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n                if ((int) e.character == 3) // CTRL-C\n                {\n                    chef.copyJobEntries(chef.jobMeta.getSelectedEntries());\n                }\n                if ((int) e.character == 22) // CTRL-V\n                {\n                    String clipcontent = chef.fromClipboard();\n                    if (clipcontent != null)\n                    {\n                        if (lastMove != null)\n                        {\n                            chef.pasteSteps(clipcontent, lastMove);\n                        }\n                    }\n\n                    //spoon.pasteSteps( );\n                }\n\t\t\t\tif (e.keyCode == SWT.ESC) \n\t\t\t\t{\n\t\t\t\t\tchef.jobMeta.unselectAll();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n                // CTRL-UP : allignTop();\n                if (e.keyCode == SWT.ARROW_UP && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    alligntop();\n                }\n                // CTRL-DOWN : allignBottom();\n                if (e.keyCode == SWT.ARROW_DOWN && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignbottom();\n                }\n                // CTRL-LEFT : allignleft();\n                if (e.keyCode == SWT.ARROW_LEFT && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignleft();\n                }\n                // CTRL-RIGHT : allignRight();\n                if (e.keyCode == SWT.ARROW_RIGHT && (e.stateMask & SWT.CONTROL) != 0)\n                {\n                    allignright();\n                }\n                // ALT-RIGHT : distributeHorizontal();\n                if (e.keyCode == SWT.ARROW_RIGHT && (e.stateMask & SWT.ALT) != 0)\n                {\n                    distributehorizontal();\n                }\n                // ALT-UP : distributeVertical();\n                if (e.keyCode == SWT.ARROW_UP && (e.stateMask & SWT.ALT) != 0)\n                {\n                    distributevertical();\n                }\n                // ALT-HOME : snap to grid\n                if (e.keyCode == SWT.HOME && (e.stateMask & SWT.ALT) != 0)\n                {\n                    snaptogrid(Const.GRID_SIZE);\n                }\n\t\t\t}\n\t\t});\n\n\t\taddKeyListener(chef.defKeys);\n\n\t\tsetBackground(GUIResource.getInstance().getColorBackground());\n\t}","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignright()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum x coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.x > max) max = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                jobentries[nr] = si;\n                Point p = si.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                si.setLocation(max, p.y);\n                after[nr] = new Point(max, p.y);\n                nr++;\n           }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","id":51295,"modified_method":"private void allignright()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum x coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.x > max) max = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                jobentries[nr] = entryCopy;\n                Point p = entryCopy.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                entryCopy.setLocation(max, p.y);\n                after[nr] = new Point(max, p.y);\n                nr++;\n           }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void alligntop()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        int min = 99999;\n\n        // First look for the minimum y coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.y < min) min = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                jobentries[nr] = si;\n                Point p = si.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                si.setLocation(p.x, min);\n                after[nr] = new Point(p.x, min);\n                nr++;\n           }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","id":51296,"modified_method":"private void alligntop()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        int min = 99999;\n\n        // First look for the minimum y coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.y < min) min = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                jobentries[nr] = entryCopy;\n                Point p = entryCopy.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                entryCopy.setLocation(p.x, min);\n                after[nr] = new Point(p.x, min);\n                nr++;\n           }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignleft()\n    {\n        if (chef.getJobMeta().nrSelected() == 0) return;\n\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum x coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.x < min) min = p.x;\n            }\n        }\n        \n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                jobentries[nr] = si;\n                Point p = si.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                si.setLocation(min, p.y);\n                after[nr] = new Point(min, p.y);\n                nr++;\n            }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","id":51297,"modified_method":"private void allignleft()\n    {\n        if (chef.getJobMeta().nrSelected() == 0) return;\n\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum x coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.x < min) min = p.x;\n            }\n        }\n        \n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                jobentries[nr] = entryCopy;\n                Point p = entryCopy.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                entryCopy.setLocation(min, p.y);\n                after[nr] = new Point(min, p.y);\n                nr++;\n            }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignbottom()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        int max = -99999;\n\n        // First look for the maximum y coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.y > max) max = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                jobentries[nr] = si;\n                Point p = si.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                si.setLocation(p.x, max);\n                after[nr] = new Point(p.x, max);\n                nr++;\n            }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","id":51298,"modified_method":"private void allignbottom()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        int max = -99999;\n\n        // First look for the maximum y coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.y > max) max = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                jobentries[nr] = entryCopy;\n                Point p = entryCopy.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                entryCopy.setLocation(p.x, max);\n                after[nr] = new Point(p.x, max);\n                nr++;\n            }\n        }\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void distributevertical()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = chef.jobMeta.nrSelected();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum y coordinate...\n        int selnr = 0;\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                Point p = si.getLocation();\n                if (p.y < min) min = p.y;\n                if (p.y > max) max = p.y;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the jobentries in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = chef.jobMeta.getJobEntry(order[j]).getLocation();\n                Point p2 = chef.jobMeta.getJobEntry(order[j + 1]).getLocation();\n                if (p1.y > p2.y) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two jobentries becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            jobentries[i] = chef.jobMeta.getJobEntry(order[i]);\n            Point p = jobentries[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.y = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        \n        redraw();\n    }","id":51299,"modified_method":"public void distributevertical()\n    {\n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = chef.jobMeta.nrSelected();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum y coordinate...\n        int selnr = 0;\n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                Point p = entryCopy.getLocation();\n                if (p.y < min) min = p.y;\n                if (p.y > max) max = p.y;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the jobentries in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = chef.jobMeta.getJobEntry(order[j]).getLocation();\n                Point p2 = chef.jobMeta.getJobEntry(order[j + 1]).getLocation();\n                if (p1.y > p2.y) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two jobentries becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            jobentries[i] = chef.jobMeta.getJobEntry(order[i]);\n            Point p = jobentries[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.y = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        \n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void snaptogrid(int size)\n    {\n        // First look for the minimum x coordinate...\n        \n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy si = chef.jobMeta.getJobEntry(i);\n            if (si.isSelected())\n            {\n                jobentries[nr] = si;\n                Point p = si.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                \n                // What's the modulus ?\n                int dx = p.x % size;\n                int dy = p.y % size;\n\n                // Correct the location to the nearest grid line!\n                // This means for size = 10\n                // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\n                // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\n                // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\n\n                if (dx > size / 2)\n                    p.x += size - dx;\n                else\n                    p.x -= dx;\n                if (dy > size / 2)\n                    p.y += size - dy;\n                else\n                    p.y -= dy;\n                after[nr] = new Point(p.x, p.y);\n                nr++;\n            }\n        }\n        \n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        \n        redraw();\n    }","id":51300,"modified_method":"private void snaptogrid(int size)\n    {\n        // First look for the minimum x coordinate...\n        \n        JobEntryCopy jobentries[] = new JobEntryCopy[chef.jobMeta.nrSelected()];\n        Point before[]   = new Point[chef.jobMeta.nrSelected()];\n        Point after[]    = new Point[chef.jobMeta.nrSelected()];\n        int nr = 0;\n        \n        for (int i = 0; i < chef.jobMeta.nrJobEntries(); i++)\n        {\n            JobEntryCopy entryCopy = chef.jobMeta.getJobEntry(i);\n            if (entryCopy.isSelected() && entryCopy.isDrawn())\n            {\n                jobentries[nr] = entryCopy;\n                Point p = entryCopy.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                \n                // What's the modulus ?\n                int dx = p.x % size;\n                int dy = p.y % size;\n\n                // Correct the location to the nearest grid line!\n                // This means for size = 10\n                // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\n                // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\n                // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\n\n                if (dx > size / 2)\n                    p.x += size - dx;\n                else\n                    p.x -= dx;\n                if (dy > size / 2)\n                    p.y += size - dy;\n                else\n                    p.y -= dy;\n                after[nr] = new Point(p.x, p.y);\n                nr++;\n            }\n        }\n        \n        chef.addUndoPosition(jobentries, chef.jobMeta.getEntryIndexes(jobentries), before, after );\n        \n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignleft()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum x coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x < min) min = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(min, p.y);\n                after[nr] = new Point(min, p.y);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","id":51301,"modified_method":"private void allignleft()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum x coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x < min) min = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(min, p.y);\n                after[nr] = new Point(min, p.y);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void snaptogrid(int size)\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        // First look for the minimum x coordinate...\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n\n                // What's the modulus ?\n                int dx = p.x % size;\n                int dy = p.y % size;\n\n                // Correct the location to the nearest grid line!\n                // This means for size = 10\n                // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\n                // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\n                // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\n\n                if (dx > size / 2)\n                    p.x += size - dx;\n                else\n                    p.x -= dx;\n                if (dy > size / 2)\n                    p.y += size - dy;\n                else\n                    p.y -= dy;\n                after[nr] = new Point(p.x, p.y);\n                nr++;\n            }\n        }\n\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","id":51302,"modified_method":"private void snaptogrid(int size)\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        // First look for the minimum x coordinate...\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n\n                // What's the modulus ?\n                int dx = p.x % size;\n                int dy = p.y % size;\n\n                // Correct the location to the nearest grid line!\n                // This means for size = 10\n                // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\n                // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\n                // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\n\n                if (dx > size / 2)\n                    p.x += size - dx;\n                else\n                    p.x -= dx;\n                if (dy > size / 2)\n                    p.y += size - dy;\n                else\n                    p.y -= dy;\n                after[nr] = new Point(p.x, p.y);\n                nr++;\n            }\n        }\n\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignright()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum x coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x > max) max = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(max, p.y);\n                after[nr] = new Point(max, p.y);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","id":51303,"modified_method":"private void allignright()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum x coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x > max) max = p.x;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(max, p.y);\n                after[nr] = new Point(max, p.y);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void drawTrans(GC gc)\n    {\n        if (spoon.props.isAntiAliasingEnabled() && Const.getOS().startsWith(\"Windows\")) gc.setAntialias(SWT.ON); //$NON-NLS-1$\n\n        shadowsize = spoon.props.getShadowSize();\n\n        Point area = getArea();\n        Point max = spoon.getTransMeta().getMaximum();\n        Point thumb = getThumb(area, max);\n        offset = getOffset(thumb, area);\n\n        hori.setThumb(thumb.x);\n        vert.setThumb(thumb.y);\n\n        gc.setFont(GUIResource.getInstance().getFontNote());\n\n        // First the notes\n        for (int i = 0; i < spoon.getTransMeta().nrNotes(); i++)\n        {\n            NotePadMeta ni = spoon.getTransMeta().getNote(i);\n            drawNote(gc, ni);\n        }\n\n        gc.setFont(GUIResource.getInstance().getFontGraph());\n        gc.setBackground(GUIResource.getInstance().getColorBackground());\n\n        if (shadowsize > 0)\n        {\n            for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n            {\n                StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n                if (stepMeta.isDrawn()) drawStepShadow(gc, stepMeta);\n            }\n        }\n\n        for (int i = 0; i < spoon.getTransMeta().nrTransHops(); i++)\n        {\n            TransHopMeta hi = spoon.getTransMeta().getTransHop(i);\n            drawHop(gc, hi);\n        }\n\n        if (candidate != null)\n        {\n            drawHop(gc, candidate, true);\n        }\n\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isDrawn()) drawStep(gc, stepMeta);\n        }\n\n        if (drop_candidate != null)\n        {\n            gc.setLineStyle(SWT.LINE_SOLID);\n            gc.setForeground(GUIResource.getInstance().getColorBlack());\n            Point screen = real2screen(drop_candidate.x, drop_candidate.y);\n            gc.drawRectangle(screen.x, screen.y, iconsize, iconsize);\n        }\n\n        drawRect(gc, selrect);\n    }","id":51304,"modified_method":"public void drawTrans(GC gc)\n    {\n        if (spoon.props.isAntiAliasingEnabled()) gc.setAntialias(SWT.ON);\n\n        shadowsize = spoon.props.getShadowSize();\n\n        Point area = getArea();\n        Point max = spoon.getTransMeta().getMaximum();\n        Point thumb = getThumb(area, max);\n        offset = getOffset(thumb, area);\n\n        hori.setThumb(thumb.x);\n        vert.setThumb(thumb.y);\n\n        gc.setFont(GUIResource.getInstance().getFontNote());\n\n        // First the notes\n        for (int i = 0; i < spoon.getTransMeta().nrNotes(); i++)\n        {\n            NotePadMeta ni = spoon.getTransMeta().getNote(i);\n            drawNote(gc, ni);\n        }\n\n        gc.setFont(GUIResource.getInstance().getFontGraph());\n        gc.setBackground(GUIResource.getInstance().getColorGraph());\n\n        if (shadowsize > 0)\n        {\n            for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n            {\n                StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n                if (stepMeta.isDrawn()) drawStepShadow(gc, stepMeta);\n            }\n        }\n\n        for (int i = 0; i < spoon.getTransMeta().nrTransHops(); i++)\n        {\n            TransHopMeta hi = spoon.getTransMeta().getTransHop(i);\n            drawHop(gc, hi);\n        }\n\n        if (candidate != null)\n        {\n            drawHop(gc, candidate, true);\n        }\n\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isDrawn()) drawStep(gc, stepMeta);\n        }\n\n        if (drop_candidate != null)\n        {\n            gc.setLineStyle(SWT.LINE_SOLID);\n            gc.setForeground(GUIResource.getInstance().getColorBlack());\n            Point screen = real2screen(drop_candidate.x, drop_candidate.y);\n            gc.drawRectangle(screen.x, screen.y, iconsize, iconsize);\n        }\n\n        drawRect(gc, selrect);\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void distributevertical()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = spoon.getTransMeta().nrSelectedSteps();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum y coordinate...\n        int selnr = 0;\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y < min) min = p.y;\n                if (p.y > max) max = p.y;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the steps in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = spoon.getTransMeta().getStep(order[j]).getLocation();\n                Point p2 = spoon.getTransMeta().getStep(order[j + 1]).getLocation();\n                if (p1.y > p2.y) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two steps becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            steps[i] = spoon.getTransMeta().getStep(order[i]);\n            Point p = steps[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.y = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","id":51305,"modified_method":"public void distributevertical()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = spoon.getTransMeta().nrSelectedSteps();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum y coordinate...\n        int selnr = 0;\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y < min) min = p.y;\n                if (p.y > max) max = p.y;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the steps in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = spoon.getTransMeta().getStep(order[j]).getLocation();\n                Point p2 = spoon.getTransMeta().getStep(order[j + 1]).getLocation();\n                if (p1.y > p2.y) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two steps becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            steps[i] = spoon.getTransMeta().getStep(order[i]);\n            Point p = steps[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.y = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void distributehorizontal()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = spoon.getTransMeta().nrSelectedSteps();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum x coordinate...\n        int selnr = 0;\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x < min) min = p.x;\n                if (p.x > max) max = p.x;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the steps in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = spoon.getTransMeta().getStep(order[j]).getLocation();\n                Point p2 = spoon.getTransMeta().getStep(order[j + 1]).getLocation();\n                if (p1.x > p2.x) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two steps becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            steps[i] = spoon.getTransMeta().getStep(order[i]);\n            Point p = steps[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.x = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","id":51306,"modified_method":"private void distributehorizontal()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n\n        int min = 99999;\n        int max = -99999;\n        int sels = spoon.getTransMeta().nrSelectedSteps();\n        if (sels <= 1) return;\n        int order[] = new int[sels];\n\n        // First look for the minimum & maximum x coordinate...\n        int selnr = 0;\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.x < min) min = p.x;\n                if (p.x > max) max = p.x;\n                order[selnr] = i;\n                selnr++;\n            }\n        }\n\n        // Difficult to keep the steps in the correct order.\n        // If you just set the x-coordinates, you get special effects.\n        // Best is to keep the current order of things.\n        // First build an arraylist and store the order there.\n        // Then sort order[], based upon the coordinate of the step.\n        for (int i = 0; i < sels; i++)\n        {\n            for (int j = 0; j < sels - 1; j++)\n            {\n                Point p1 = spoon.getTransMeta().getStep(order[j]).getLocation();\n                Point p2 = spoon.getTransMeta().getStep(order[j + 1]).getLocation();\n                if (p1.x > p2.x) // swap\n                {\n                    int dummy = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = dummy;\n                }\n            }\n        }\n\n        // The distance between two steps becomes.\n        int distance = (max - min) / (sels - 1);\n\n        for (int i = 0; i < sels; i++)\n        {\n            steps[i] = spoon.getTransMeta().getStep(order[i]);\n            Point p = steps[i].getLocation();\n            before[i] = new Point(p.x, p.y);\n            p.x = min + (i * distance);\n            after[i] = new Point(p.x, p.y);\n        }\n\n        // Undo!\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void alligntop()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum y coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y < min) min = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(p.x, min);\n                after[nr] = new Point(p.x, min);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","id":51307,"modified_method":"private void alligntop()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int min = 99999;\n\n        // First look for the minimum y coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y < min) min = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(p.x, min);\n                after[nr] = new Point(p.x, min);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void allignbottom()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum y coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y > max) max = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(p.x, max);\n                after[nr] = new Point(p.x, max);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","id":51308,"modified_method":"private void allignbottom()\n    {\n        if (spoon.getTransMeta().nrSelectedSteps() == 0) return;\n\n        StepMeta steps[] = new StepMeta[spoon.getTransMeta().nrSelectedSteps()];\n        Point before[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        Point after[] = new Point[spoon.getTransMeta().nrSelectedSteps()];\n        int nr = 0;\n\n        int max = -99999;\n\n        // First look for the maximum y coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                Point p = stepMeta.getLocation();\n                if (p.y > max) max = p.y;\n            }\n        }\n        // Then apply the coordinate...\n        for (int i = 0; i < spoon.getTransMeta().nrSteps(); i++)\n        {\n            StepMeta stepMeta = spoon.getTransMeta().getStep(i);\n            if (stepMeta.isSelected() && stepMeta.isDrawn())\n            {\n                steps[nr] = stepMeta;\n                Point p = stepMeta.getLocation();\n                before[nr] = new Point(p.x, p.y);\n                stepMeta.setLocation(p.x, max);\n                after[nr] = new Point(p.x, max);\n                nr++;\n            }\n        }\n        spoon.addUndoPosition(steps, spoon.getTransMeta().getStepIndexes(steps), before, after);\n        redraw();\n    }","commit_id":"cf69283379cdf60bf49c8b584c25a8bd0ecba104","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static Language newInstance(LanguageDescriptor descriptor, MPSModuleOwner moduleOwner) {\n    Language language = new TestLanguage(descriptor, null);\n\n    Language registered = MPSModuleRepository.getInstance().registerModule(language, moduleOwner);\n    if (registered == language) {\n      language.setLanguageDescriptor(descriptor);\n    }\n\n    return registered;\n  }","id":51309,"modified_method":"public static Language newInstance(LanguageDescriptor descriptor, MPSModuleOwner moduleOwner) {\n    Language language = new TestLanguage(descriptor, null);\n\n    return MPSModuleRepository.getInstance().registerModule(language, moduleOwner);\n  }","commit_id":"9eb4b5521b370f43e7b213081637515eb7974cae","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static <T extends AbstractModule> T registerModule(T module, MPSModuleOwner moduleOwner) {\n    T registered = MPSModuleRepository.getInstance().registerModule(module, moduleOwner);\n    return registered;\n  }","id":51310,"modified_method":"private static <T extends AbstractModule> T registerModule(T module, MPSModuleOwner moduleOwner) {\n    return MPSModuleRepository.getInstance().registerModule(module, moduleOwner);\n  }","commit_id":"ce00b6d13053e6bde58a3298a9c1a9ccc87f2555","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Language newInstance(ModuleHandle handle, MPSModuleOwner moduleOwner) {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) handle.getDescriptor());\n    assert descriptor != null;\n    assert descriptor.getId() != null;\n\n    Language language = new Language();\n    language.setLanguageDescriptor(descriptor, false);\n    language.myDescriptorFile = handle.getFile();\n\n    LibrariesLoader.createLanguageLibs(moduleOwner, language, descriptor, MPSModuleRepository.getInstance());\n\n    return MPSModuleRepository.getInstance().registerModule(language, moduleOwner);\n  }","id":51311,"modified_method":"public static Language newInstance(ModuleHandle handle, MPSModuleOwner moduleOwner) {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) handle.getDescriptor());\n    assert descriptor != null;\n    assert descriptor.getId() != null;\n\n    Language language = new Language();\n    language.setLanguageDescriptor(descriptor, false);\n    language.myDescriptorFile = handle.getFile();\n\n    Language registered = MPSModuleRepository.getInstance().registerModule(language, moduleOwner);\n\n    if (registered == language) {\n      LibrariesLoader.createLanguageLibs(moduleOwner, language, descriptor, MPSModuleRepository.getInstance());\n    }\n\n    return registered;\n  }","commit_id":"6f408dd5574df18520113f3f659d831ded719f8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Language newInstance(LanguageDescriptor descriptor, MPSModuleOwner moduleOwner) {\n    Language language = new TestLanguage(descriptor, null);\n\n    return MPSModuleRepository.getInstance().registerModule(language, moduleOwner);\n  }","id":51312,"modified_method":"public static Language newInstance(LanguageDescriptor descriptor, MPSModuleOwner moduleOwner) {\n    Language newLanguage = new TestLanguage(descriptor, null);\n\n    Language language = MPSModuleRepository.getInstance().registerModule(newLanguage, moduleOwner);\n    if (language == newLanguage) {\n      language.revalidateGenerators();\n    }\n    return language;\n  }","commit_id":"795977163cfdad3bb4781a15be63a33b22145dcf","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      TreeFileChooser chooser = new TreeFileChooser();\n      chooser.setMode(TreeFileChooser.MODE_DIRECTORIES);\n      chooser.setContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\")));\n      final Wrappers._T<IFile> projectFolder = new Wrappers._T<IFile>(null);\n      final Wrappers._T<String> basePath = new Wrappers._T<String>(null);\n\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          basePath.value = BuildProject_Behavior.call_getBasePath_4959435991187146924(((SNode) MapSequence.fromMap(_params).get(\"node\")), Context.defaultContext());\n          if (basePath.value != null && isNotEmptyString(basePath.value)) {\n            projectFolder.value = FileSystem.getInstance().getFileByPath(basePath.value);\n          }\n        }\n      });\n      if (basePath.value == null) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"working directory is not available\");\n        }\n        return;\n      }\n      if (projectFolder.value != null) {\n        chooser.setInitialFile(projectFolder.value);\n      }\n      final IFile dir = chooser.showDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      if (dir == null || !(dir.isDirectory())) {\n        return;\n      }\n\n      modelAccess.executeCommandInEDT(new Runnable() {\n        public void run() {\n          List<ModulesMiner.ModuleHandle> modules = ModulesMiner.getInstance().collectModules(dir, false);\n          VisibleModules visible = new VisibleModules(((SNode) MapSequence.fromMap(_params).get(\"node\")), null);\n          visible.collect();\n\n          PathConverter converter = new PathConverter(((SNode) MapSequence.fromMap(_params).get(\"node\")));\n\n          List<ImportModuleHelper> helpers = new ArrayList<ImportModuleHelper>();\n          for (ModulesMiner.ModuleHandle handle : modules) {\n            SModuleReference modRef = handle.getDescriptor().getModuleReference();\n            if (visible.resolve(modRef.getModuleName(), modRef.getModuleId().toString()) != null) {\n              continue;\n            }\n\n            ImportModuleHelper helper = new ImportModuleHelper(((SNode) MapSequence.fromMap(_params).get(\"node\")), converter, handle.getFile(), handle.getDescriptor());\n            helper.create();\n            helpers.add(helper);\n          }\n          visible = new VisibleModules(((SNode) MapSequence.fromMap(_params).get(\"node\")), null);\n          visible.collect();\n\n          for (ImportModuleHelper helper : helpers) {\n            helper.update(visible);\n          }\n\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ImportAllModulesFromFolder\", t);\n      }\n    }\n  }","id":51313,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      TreeFileChooser chooser = new TreeFileChooser();\n      chooser.setMode(TreeFileChooser.MODE_DIRECTORIES);\n      chooser.setContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\")));\n      final Wrappers._T<IFile> projectFolder = new Wrappers._T<IFile>(null);\n      final Wrappers._T<String> basePath = new Wrappers._T<String>(null);\n\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          basePath.value = BuildProject_Behavior.call_getBasePath_4959435991187146924(((SNode) MapSequence.fromMap(_params).get(\"node\")), Context.defaultContext());\n          if (basePath.value != null && isNotEmptyString(basePath.value)) {\n            projectFolder.value = FileSystem.getInstance().getFileByPath(basePath.value);\n          }\n        }\n      });\n      if (basePath.value == null) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"working directory is not available\");\n        }\n        return;\n      }\n      if (projectFolder.value != null) {\n        chooser.setInitialFile(projectFolder.value);\n      }\n      final IFile dir = chooser.showDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      if (dir == null || !(dir.isDirectory())) {\n        return;\n      }\n\n      modelAccess.executeCommandInEDT(new Runnable() {\n        public void run() {\n          List<ModulesMiner.ModuleHandle> modules = ModulesMiner.getInstance().collectModules(dir, false);\n          VisibleModules visible = new VisibleModules(((SNode) MapSequence.fromMap(_params).get(\"node\")), null);\n          visible.collect();\n\n          PathConverter converter = new PathConverter(((SNode) MapSequence.fromMap(_params).get(\"node\")));\n\n          List<ImportModuleHelper> helpers = new ArrayList<ImportModuleHelper>();\n          for (ModulesMiner.ModuleHandle handle : modules) {\n            SModuleReference modRef = handle.getDescriptor().getModuleReference();\n            if (visible.resolve(modRef) != null) {\n              continue;\n            }\n\n            ImportModuleHelper helper = new ImportModuleHelper(((SNode) MapSequence.fromMap(_params).get(\"node\")), converter, handle.getFile(), handle.getDescriptor());\n            helper.create();\n            helpers.add(helper);\n          }\n          visible = new VisibleModules(((SNode) MapSequence.fromMap(_params).get(\"node\")), null);\n          visible.collect();\n\n          for (ImportModuleHelper helper : helpers) {\n            helper.update(visible);\n          }\n\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ImportAllModulesFromFolder\", t);\n      }\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void checkDevkit(ModuleChecker.CheckType type) {\n    DevkitDescriptor descriptor = (DevkitDescriptor) myModuleDescriptor;\n    SNode devKit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n\n    List<SNode> prevExt = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devKit, \"extends\", true));\n    List<SNode> prevExp = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devKit, \"exports\", true));\n\n    for (SModuleReference module : descriptor.getExtendedDevkits()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module.getModuleName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"extends\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return asOriginal(SLinkOperations.getTarget(it, \"devkit\", false)) == resolved;\n        }\n      }))) {\n        report(\"extends devkit dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = ListSequence.fromList(prevExt).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SLinkOperations.getTarget(it, \"devkit\", false) == resolved;\n          }\n        });\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", null);\n          SLinkOperations.setTarget(ul, \"devkit\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"extends\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExt).removeElement(ul);\n        }\n      }\n    }\n\n    for (SModuleReference module : descriptor.getExportedLanguages()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module.getModuleName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n        report(\"export language dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", null);\n          SLinkOperations.setTarget(ul, \"language\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExp).removeElement(ul);\n        }\n      }\n    }\n\n    // import devkit \n    for (SModuleReference module : descriptor.getExportedSolutions()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module.getModuleName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n        report(\"export solution dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", null);\n          SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExp).removeElement(ul);\n        }\n      }\n    }\n\n    if (type.doPartialImport) {\n      ListSequence.fromList(SLinkOperations.getTargets(devKit, \"extends\", true)).removeSequence(ListSequence.fromList(prevExt));\n      ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).removeSequence(ListSequence.fromList(prevExp));\n    }\n  }","id":51314,"modified_method":"public void checkDevkit(ModuleChecker.CheckType type) {\n    DevkitDescriptor descriptor = (DevkitDescriptor) myModuleDescriptor;\n    SNode devKit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n\n    List<SNode> prevExt = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devKit, \"extends\", true));\n    List<SNode> prevExp = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devKit, \"exports\", true));\n\n    for (SModuleReference module : descriptor.getExtendedDevkits()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"extends\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return asOriginal(SLinkOperations.getTarget(it, \"devkit\", false)) == resolved;\n        }\n      }))) {\n        report(\"extends devkit dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = ListSequence.fromList(prevExt).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SLinkOperations.getTarget(it, \"devkit\", false) == resolved;\n          }\n        });\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", null);\n          SLinkOperations.setTarget(ul, \"devkit\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"extends\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExt).removeElement(ul);\n        }\n      }\n    }\n\n    for (SModuleReference module : descriptor.getExportedLanguages()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n        report(\"export language dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", null);\n          SLinkOperations.setTarget(ul, \"language\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExp).removeElement(ul);\n        }\n      }\n    }\n\n    // import devkit \n    for (SModuleReference module : descriptor.getExportedSolutions()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(module), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n        report(\"export solution dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", null);\n          SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(prevExp).removeElement(ul);\n        }\n      }\n    }\n\n    if (type.doPartialImport) {\n      ListSequence.fromList(SLinkOperations.getTargets(devKit, \"extends\", true)).removeSequence(ListSequence.fromList(prevExt));\n      ListSequence.fromList(SLinkOperations.getTargets(devKit, \"exports\", true)).removeSequence(ListSequence.fromList(prevExp));\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode createBuildMps_ModuleDependencyOnModule_yr5c5g_a0a0a0a11a92(Object p0) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null, false);\n    n1.setProperty(\"reexport\", \"\" + false);\n    n1.setReferenceTarget(\"module\", (SNode) p0);\n    return n1;\n  }","id":51315,"modified_method":"private static SNode createBuildMps_ModuleDependencyOnModule_yr5c5g_a0a0a0a11a72(Object p0) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null, false);\n    n1.setProperty(\"reexport\", \"\" + false);\n    n1.setReferenceTarget(\"module\", (SNode) p0);\n    return n1;\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void checkLanguageDeps(ModuleChecker.CheckType type, List<SNode> previous) {\n    LanguageDescriptor descriptor = (LanguageDescriptor) myModuleDescriptor;\n    SNode language = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n\n    boolean importsCore = false;\n    boolean importsDescriptor = false;\n    for (SModuleReference extendedLang : descriptor.getExtendedLanguages()) {\n      if (!(importsCore) && CORE_LANGUAGE_UID.equals(extendedLang.getModuleId().toString())) {\n        importsCore = true;\n      }\n      if (!(importsDescriptor) && DESCRIPTOR_LANGUAGE_UID.equals(extendedLang.getModuleId().toString())) {\n        importsDescriptor = true;\n      }\n\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(extendedLang.getModuleName(), extendedLang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + extendedLang.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(language, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          SNode em = SNodeOperations.as(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n        report(\"extends language dependency should be extracted into build script: \" + extendedLang.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode res = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false) == resolved;\n          }\n        });\n        if (res == null) {\n          res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n          SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n          SLinkOperations.setTarget(ul, \"language\", resolved, false);\n          SLinkOperations.setTarget(res, \"dependency\", ul, true);\n          ListSequence.fromList(SLinkOperations.getTargets(language, \"dependencies\", true)).addElement(res);\n        } else {\n          ListSequence.fromList(previous).removeElement(res);\n        }\n      }\n    }\n\n    if (!(importsCore) && type.doFullImport) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(\"jetbrains.mps.lang.core\", CORE_LANGUAGE_UID), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find jetbrains.mps.lang.core language in dependencies for \" + SPropertyOperations.getString(myModule, \"name\"), myModule);\n      } else {\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(ul);\n      }\n    }\n    if (!(importsDescriptor) && type.doFullImport) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(\"jetbrains.mps.lang.descriptor\", DESCRIPTOR_LANGUAGE_UID), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find jetbrains.mps.lang.descriptor language in dependencies for \" + SPropertyOperations.getString(myModule, \"name\"), myModule);\n      } else {\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(ul);\n      }\n    }\n  }","id":51316,"modified_method":"public void checkLanguageDeps(ModuleChecker.CheckType type, List<SNode> previous) {\n    LanguageDescriptor descriptor = (LanguageDescriptor) myModuleDescriptor;\n    SNode language = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n\n    boolean importsCore = false;\n    boolean importsDescriptor = false;\n    for (SModuleReference extendedLang : descriptor.getExtendedLanguages()) {\n      if (!(importsCore) && BootstrapLanguages.coreLanguageRef().equals(extendedLang)) {\n        importsCore = true;\n      }\n      if (!(importsDescriptor) && BootstrapLanguages.descriptorLanguageRef().equals(extendedLang)) {\n        importsDescriptor = true;\n      }\n\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(extendedLang), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + extendedLang.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(language, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          SNode em = SNodeOperations.as(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n        report(\"extends language dependency should be extracted into build script: \" + extendedLang.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode res = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false) == resolved;\n          }\n        });\n        if (res == null) {\n          res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n          SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n          SLinkOperations.setTarget(ul, \"language\", resolved, false);\n          SLinkOperations.setTarget(res, \"dependency\", ul, true);\n          ListSequence.fromList(SLinkOperations.getTargets(language, \"dependencies\", true)).addElement(res);\n        } else {\n          ListSequence.fromList(previous).removeElement(res);\n        }\n      }\n    }\n\n    if (!(importsCore) && type.doFullImport) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(BootstrapLanguages.coreLanguageRef()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find jetbrains.mps.lang.core language in dependencies for \" + SPropertyOperations.getString(myModule, \"name\"), myModule);\n      } else {\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(ul);\n      }\n    }\n    if (!(importsDescriptor) && type.doFullImport) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(BootstrapLanguages.descriptorLanguageRef()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find jetbrains.mps.lang.descriptor language in dependencies for \" + SPropertyOperations.getString(myModule, \"name\"), myModule);\n      } else {\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(ul);\n      }\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void collectDependencies(ModuleChecker.CheckType type, List<SNode> previous) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ? usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) : false);\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Map<SNode, SNode> seen = new HashMap<SNode, SNode>();\n\n    Set<Dependency> dependencies = SetSequence.fromSetWithValues(new HashSet<Dependency>(), myModuleDescriptor.getDependencies());\n\n    // todo: hack \n    if (type.doFullImport) {\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\")) {\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"), \"dependencies\", true)).addElement(createBuildMps_ModuleDependencyOnModule_yr5c5g_a0a0a0a11a92(BuildMps_Generator_Behavior.call_getSourceLanguage_9200313594510517119(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"))));\n      }\n    }\n\n    for (Dependency dependency : dependencies) {\n      SModuleReference moduleRef = dependency.getModuleRef();\n      if (moduleRef.getModuleName().contains(\"#\") && !(SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"))) {\n        report(\"modules except generators cannot depend on generator: `\" + moduleRef.getModuleName() + \"'\", myOriginalModule);\n      }\n    }\n\n    // resolve all dependencies \n    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      SModuleReference moduleRef = dep.getModuleRef();\n      final Wrappers._T<SNode> resolved = new Wrappers._T<SNode>();\n      String targetName = moduleRef.getModuleName();\n      resolved.value = SNodeOperations.as(myVisibleModules.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n      if (resolved.value == null) {\n        report(\"dependency on a module not visible from current build project: \" + dep.getModuleRef().toString(), myOriginalModule);\n        continue;\n      }\n\n      Boolean alreadyReexport = depsToReexport.get(resolved.value);\n      if (alreadyReexport != null && alreadyReexport.booleanValue()) {\n        continue;\n      }\n      depsToReexport.put(resolved.value, reexport);\n\n      // import required \n      if (type.doPartialImport) {\n        SNode prev = seen.get(resolved.value);\n        if (prev != null) {\n          if (reexport) {\n            SPropertyOperations.set(prev, \"reexport\", \"\" + (true));\n          }\n          continue;\n        }\n\n        SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"module\", false) == resolved.value;\n          }\n        });\n\n        if (extr == null) {\n          extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n          SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n          SLinkOperations.setTarget(extr, \"dependency\", res, true);\n          SLinkOperations.setTarget(res, \"module\", resolved.value, false);\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n        } else {\n          ListSequence.fromList(previous).removeElement(extr);\n        }\n        seen.put(resolved.value, SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"));\n        SPropertyOperations.set(SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"reexport\", \"\" + (reexport));\n      }\n    }\n\n    // check & create \n    if (type.doFullImport || type.doCheck) {\n      for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {\n        SNode resolved = entry.getKey();\n        boolean reexport = entry.getValue().booleanValue();\n\n        boolean found = false;\n\n        if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, \"uuid\"))) {\n          found = true;\n          boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, \"uuid\"));\n          if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\")) && type.doCheck) {\n            report(\"wrong reexport status for dependency in build script for: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n          }\n        }\n\n        if (!(extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\"))) && type.doCheck) {\n          report(\"dependencies should be extracted into build script: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n        }\n\n        if (!(found) && type.doFullImport) {\n          SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n          SLinkOperations.setTarget(res, \"module\", resolved, false);\n          SPropertyOperations.set(res, \"reexport\", \"\" + (reexport));\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n        }\n      }\n    }\n\n    // java stubs: jars \n    for (String path : myModuleDescriptor.getAdditionalJavaStubPaths()) {\n      final SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        if (type.doCheck) {\n          final String relPath = BehaviorReflection.invokeVirtual(String.class, p, \"virtual_getRelativePath_5481553824944787371\", new Object[]{});\n          if (!(ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              SNode dep = (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\") ? SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true) : it);\n              return SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_yr5c5g_a0a1a0a0a0a0b0a0d0x0db(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true), \"virtual_getRelativePath_5481553824944787371\", new Object[]{}), relPath);\n            }\n          }))) {\n            report(\"jar stub library should be extracted into build script: \" + relPath, myOriginalModule);\n          }\n        }\n\n        if (type.doPartialImport) {\n          SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_yr5c5g_a0a0a0a0a0a0a0c0d0x0db(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true), \"virtual_getRelativePath_5481553824944787371\", new Object[]{}), BehaviorReflection.invokeVirtual(String.class, p, \"virtual_getRelativePath_5481553824944787371\", new Object[]{}));\n            }\n          });\n\n          if (extr == null) {\n            extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n            SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n            SLinkOperations.setTarget(jar, \"path\", p, true);\n            SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n            ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n          } else {\n            ListSequence.fromList(previous).removeElement(extr);\n          }\n        }\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":51317,"modified_method":"public void collectDependencies(ModuleChecker.CheckType type, List<SNode> previous) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ? usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) : false);\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Map<SNode, SNode> seen = new HashMap<SNode, SNode>();\n\n    Set<Dependency> dependencies = SetSequence.fromSetWithValues(new HashSet<Dependency>(), myModuleDescriptor.getDependencies());\n\n    // todo: hack \n    if (type.doFullImport) {\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\")) {\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"), \"dependencies\", true)).addElement(createBuildMps_ModuleDependencyOnModule_yr5c5g_a0a0a0a11a72(BuildMps_Generator_Behavior.call_getSourceLanguage_9200313594510517119(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"))));\n      }\n    }\n    if (!(SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\"))) {\n      for (Dependency dependency : dependencies) {\n        SModuleReference moduleRef = dependency.getModuleRef();\n        if (moduleRef.getModuleName().contains(\"#\")) {\n          report(\"modules except generators cannot depend on generator: `\" + moduleRef.getModuleName() + \"'\", myOriginalModule);\n        }\n      }\n    }\n\n    // resolve all dependencies \n    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      SModuleReference moduleRef = dep.getModuleRef();\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(moduleRef), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n      if (resolved == null) {\n        report(\"dependency on a module not visible from current build project: \" + dep.getModuleRef().toString(), myOriginalModule);\n        continue;\n      }\n\n      Boolean alreadyReexport = depsToReexport.get(resolved);\n      if (alreadyReexport != null && alreadyReexport.booleanValue()) {\n        continue;\n      }\n      depsToReexport.put(resolved, reexport);\n\n      // import required \n      if (type.doPartialImport) {\n        SNode prev = seen.get(resolved);\n        if (prev != null) {\n          if (reexport) {\n            SPropertyOperations.set(prev, \"reexport\", \"\" + (true));\n          }\n          continue;\n        }\n\n        SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"module\", false) == resolved;\n          }\n        });\n\n        if (extr == null) {\n          extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n          SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n          SLinkOperations.setTarget(extr, \"dependency\", res, true);\n          SLinkOperations.setTarget(res, \"module\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n        } else {\n          ListSequence.fromList(previous).removeElement(extr);\n        }\n        seen.put(resolved, SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"));\n        SPropertyOperations.set(SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"reexport\", \"\" + (reexport));\n      }\n    }\n\n    // check & create \n    if (type.doFullImport || type.doCheck) {\n      for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {\n        SNode resolved = entry.getKey();\n        boolean reexport = entry.getValue().booleanValue();\n\n        boolean found = false;\n\n        if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, \"uuid\"))) {\n          found = true;\n          boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, \"uuid\"));\n          if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\")) && type.doCheck) {\n            report(\"wrong reexport status for dependency in build script for: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n          }\n        }\n\n        if (!(extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\"))) && type.doCheck) {\n          report(\"dependencies should be extracted into build script: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n        }\n\n        if (!(found) && type.doFullImport) {\n          SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n          SLinkOperations.setTarget(res, \"module\", resolved, false);\n          SPropertyOperations.set(res, \"reexport\", \"\" + (reexport));\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n        }\n      }\n    }\n\n    // java stubs: jars \n    for (String path : myModuleDescriptor.getAdditionalJavaStubPaths()) {\n      final SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        if (type.doCheck) {\n          final String relPath = BehaviorReflection.invokeVirtual(String.class, p, \"virtual_getRelativePath_5481553824944787371\", new Object[]{});\n          if (!(ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              SNode dep = (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\") ? SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true) : it);\n              return SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_yr5c5g_a0a1a0a0a0a0b0a0d0w0bb(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true), \"virtual_getRelativePath_5481553824944787371\", new Object[]{}), relPath);\n            }\n          }))) {\n            report(\"jar stub library should be extracted into build script: \" + relPath, myOriginalModule);\n          }\n        }\n\n        if (type.doPartialImport) {\n          SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_yr5c5g_a0a0a0a0a0a0a0c0d0w0bb(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true), \"virtual_getRelativePath_5481553824944787371\", new Object[]{}), BehaviorReflection.invokeVirtual(String.class, p, \"virtual_getRelativePath_5481553824944787371\", new Object[]{}));\n            }\n          });\n\n          if (extr == null) {\n            extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n            SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n            SLinkOperations.setTarget(jar, \"path\", p, true);\n            SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n            ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n          } else {\n            ListSequence.fromList(previous).removeElement(extr);\n          }\n        }\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkModule(ModuleChecker.CheckType type) {\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\")) {\n      if (!(myModuleDescriptor instanceof LanguageDescriptor)) {\n        report(\"imported file is not a language file \" + SPropertyOperations.getString(myModule, \"name\"), myOriginalModule);\n        return;\n      }\n    }\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Solution\")) {\n      if (!(myModuleDescriptor instanceof SolutionDescriptor)) {\n        report(\"imported file is not a solution file \" + SPropertyOperations.getString(myModule, \"name\"), myOriginalModule);\n        return;\n      }\n    }\n\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    List<SNode> previous = ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n      }\n    }).toListSequence();\n\n    collectDependencies(type, previous);\n\n    if (type.doFullImport) {\n      collectLocalDependencies();\n    }\n\n    if (SNodeOperations.isInstanceOf(module, \"jetbrains.mps.build.mps.structure.BuildMps_Language\")) {\n      checkLanguage(type, previous);\n    }\n\n    collectSources(type);\n\n    if (type.doPartialImport) {\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).removeSequence(ListSequence.fromList(previous));\n    }\n\n    if (type.doFullImport) {\n      optimizeDeps();\n    }\n  }","id":51318,"modified_method":"private void checkModule(ModuleChecker.CheckType type) {\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\")) {\n      if (!(myModuleDescriptor instanceof LanguageDescriptor)) {\n        report(\"imported file is not a language file \" + SPropertyOperations.getString(myModule, \"name\"), myOriginalModule);\n        return;\n      }\n    }\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Solution\")) {\n      if (!(myModuleDescriptor instanceof SolutionDescriptor)) {\n        report(\"imported file is not a solution file \" + SPropertyOperations.getString(myModule, \"name\"), myOriginalModule);\n        return;\n      }\n    }\n\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    List<SNode> previous = Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getTargets(module, \"dependencies\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")).toListSequence();\n\n    collectDependencies(type, previous);\n\n    if (type.doFullImport) {\n      collectLocalDependencies();\n    }\n\n    if (SNodeOperations.isInstanceOf(module, \"jetbrains.mps.build.mps.structure.BuildMps_Language\")) {\n      checkLanguage(type, previous);\n    }\n\n    collectSources(type);\n\n    if (type.doPartialImport) {\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).removeSequence(ListSequence.fromList(previous));\n    }\n\n    if (type.doFullImport) {\n      optimizeDeps();\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_yr5c5g_a0a0e0r(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":51319,"modified_method":"private static boolean neq_yr5c5g_a0a0e0p(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean checkModuleReference(ModuleChecker.CheckType type) {\n    SModuleReference moduleReference = myModuleDescriptor.getModuleReference();\n\n    String expectedModuleName = moduleReference.getModuleName();\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\")) {\n      expectedModuleName = ((GeneratorDescriptor) myModuleDescriptor).getGeneratorUID();\n    }\n    if (type.doCheck && (neq_yr5c5g_a0a0e0r(SPropertyOperations.getString(myModule, \"name\"), expectedModuleName))) {\n      report(\"name in import doesn't match file content \" + SPropertyOperations.getString(myModule, \"name\") + \", should be: \" + expectedModuleName, myOriginalModule);\n      return false;\n    }\n    if (type.doPartialImport) {\n      SPropertyOperations.set(myModule, \"name\", expectedModuleName);\n    }\n\n    String expectedModuleUUID = moduleReference.getModuleId().toString();\n    if (type.doCheck && neq_yr5c5g_a0a8a71(SPropertyOperations.getString(myModule, \"uuid\"), expectedModuleUUID)) {\n      report(\"module id in import doesn't match file content \" + SPropertyOperations.getString(myModule, \"name\") + \", should be: \" + moduleReference.getModuleId().toString(), myOriginalModule);\n      return false;\n    }\n    if (type.doPartialImport) {\n      SPropertyOperations.set(myModule, \"uuid\", moduleReference.getModuleId().toString());\n    }\n\n    return true;\n  }","id":51320,"modified_method":"public boolean checkModuleReference(ModuleChecker.CheckType type) {\n    SModuleReference moduleReference = myModuleDescriptor.getModuleReference();\n\n    String expectedModuleName = moduleReference.getModuleName();\n    if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Generator\")) {\n      expectedModuleName = ((GeneratorDescriptor) myModuleDescriptor).getGeneratorUID();\n    }\n    if (type.doCheck && (neq_yr5c5g_a0a0e0p(SPropertyOperations.getString(myModule, \"name\"), expectedModuleName))) {\n      report(\"name in import doesn't match file content \" + SPropertyOperations.getString(myModule, \"name\") + \", should be: \" + expectedModuleName, myOriginalModule);\n      return false;\n    }\n    if (type.doPartialImport) {\n      SPropertyOperations.set(myModule, \"name\", expectedModuleName);\n    }\n\n    String expectedModuleUUID = moduleReference.getModuleId().toString();\n    if (type.doCheck && neq_yr5c5g_a0a8a51(SPropertyOperations.getString(myModule, \"uuid\"), expectedModuleUUID)) {\n      report(\"module id in import doesn't match file content \" + SPropertyOperations.getString(myModule, \"name\") + \", should be: \" + moduleReference.getModuleId().toString(), myOriginalModule);\n      return false;\n    }\n    if (type.doPartialImport) {\n      SPropertyOperations.set(myModule, \"uuid\", moduleReference.getModuleId().toString());\n    }\n\n    return true;\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectLocalDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Iterable<SModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();\n    Iterable<SModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();\n\n    for (SModuleReference lang : usedLanguages) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(lang.getModuleName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find used language in dependencies: \" + lang.getModuleName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n      SLinkOperations.setTarget(ul, \"language\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ul);\n    }\n    for (SModuleReference devkit : usedDevkits) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(devkit.getModuleName(), devkit.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find used devkit in dependencies: \" + devkit.getModuleName(), myModule);\n        continue;\n      }\n      SNode ud = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", null);\n      SLinkOperations.setTarget(ud, \"devkit\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ud);\n    }\n  }","id":51321,"modified_method":"private void collectLocalDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Iterable<SModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();\n    Iterable<SModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();\n\n    for (SModuleReference lang : usedLanguages) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(lang), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find used language in dependencies: \" + lang.getModuleName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n      SLinkOperations.setTarget(ul, \"language\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ul);\n    }\n    for (SModuleReference devkit : usedDevkits) {\n      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(devkit), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find used devkit in dependencies: \" + devkit.getModuleName(), myModule);\n        continue;\n      }\n      SNode ud = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", null);\n      SLinkOperations.setTarget(ud, \"devkit\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ud);\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_yr5c5g_a0a8a71(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":51322,"modified_method":"private static boolean neq_yr5c5g_a0a8a51(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void checkRuntime(ModuleChecker.CheckType type) {\n    LanguageDescriptor descriptor = (LanguageDescriptor) myModuleDescriptor;\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n\n    List<SNode> previous = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, \"runtime\", true));\n\n    for (SModuleReference runtimeModule : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(runtimeModule.getModuleName(), runtimeModule.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + runtimeModule.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n        report(\"runtime solution should be extracted into build script: \" + runtimeModule.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n          SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(previous).removeElement(ul);\n        }\n      }\n    }\n  }","id":51323,"modified_method":"public void checkRuntime(ModuleChecker.CheckType type) {\n    LanguageDescriptor descriptor = (LanguageDescriptor) myModuleDescriptor;\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n\n    List<SNode> previous = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, \"runtime\", true));\n\n    for (SModuleReference runtimeModule : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(myVisibleModules.resolve(runtimeModule), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + runtimeModule.getModuleName(), myModule);\n        continue;\n      }\n\n      if (type.doCheck && !(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n        report(\"runtime solution should be extracted into build script: \" + runtimeModule.toString(), myOriginalModule);\n      }\n\n      if (type.doPartialImport) {\n        SNode ul = SNodeOperations.as(ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false) == resolved;\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\");\n        if (ul == null) {\n          ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n          SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n        } else {\n          ListSequence.fromList(previous).removeElement(ul);\n        }\n      }\n    }\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_yr5c5g_a0a1a0a0a0a0b0a0d0x0db(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":51324,"modified_method":"private static boolean eq_yr5c5g_a0a1a0a0a0a0b0a0d0w0bb(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_yr5c5g_a0a0a0a0a0a0a0c0d0x0db(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":51325,"modified_method":"private static boolean eq_yr5c5g_a0a0a0a0a0a0a0c0d0w0bb(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"6924c016dc769804680dc8183e79d83222822437","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public String expandPath(@Nullable String path) {\n      if (path == null) {\n        return null;\n      }\n\n      if (moduleSourceDir != null) {\n        for (String macro : MacrosFactory.descriptors) {\n          if (path.startsWith(macro)) {\n            String relPath = path.substring(path.indexOf('}') + 1);\n            return IFileUtils.getCanonicalPath(moduleSourceDir.getDescendant(relPath));\n          }\n        }\n      }\n      if (path.startsWith(\"${\")) {\n        int index = path.indexOf(\"}\");\n        if (index == -1) {\n          reporter.report(\"invalid macro in `\" + path + \"'\", null, null);\n          return path;\n        }\n\n        String macroName = path.substring(2, index);\n        SNode found = null;\n        for (SNode macro : SLinkOperations.getChildren(SNodeOperations.getNodeAncestor(originalModule, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, \"jetbrains.mps.build.structure.BuildProject\"), false, false), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x4df58c6f18f84a22L, \"macros\"))) {\n          if (!(SNodeOperations.isInstanceOf(macro, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\")))) {\n            continue;\n          }\n\n          if (eq_krgnbt_a0c0f0d0f4(SPropertyOperations.getString(macro, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")), macroName)) {\n            found = SNodeOperations.cast(macro, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\"));\n            break;\n          }\n        }\n        if (found == null) {\n          reporter.report(\"macro is not declared in build script: \" + path, null, null);\n          return path;\n        }\n\n        String localPath = BuildSourcePath__BehaviorDescriptor.getLocalPath_id4Kip2_918Y$.invoke(SLinkOperations.getTarget(found, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, 0x668c6cfbafadf0eaL, \"defaultPath\")), (genContext != null ? Context.defaultContext(genContext) : Context.defaultContext()));\n        if (localPath == null) {\n          if (genContext != null) {\n            genContext.showWarningMessage(found, \"cannot resolve local path: \" + path + \", macro has no default value\");\n          }\n          return path;\n        }\n\n        String relPath = path.substring(index + 1);\n        return IFileUtils.getCanonicalPath(FileSystem.getInstance().getFileByPath(localPath).getDescendant(relPath));\n      }\n      return path;\n    }","id":51326,"modified_method":"@Override\n    public String expandPath(@Nullable String path) {\n      if (path == null) {\n        return null;\n      }\n\n      if (moduleSourceDir != null && path.startsWith(MacrosFactory.MODULE)) {\n        String relPath = path.substring(path.indexOf('}') + 1);\n        return IFileUtils.getCanonicalPath(moduleSourceDir.getDescendant(relPath));\n      }\n      if (path.startsWith(\"${\")) {\n        int index = path.indexOf(\"}\");\n        if (index == -1) {\n          reporter.report(\"invalid macro in `\" + path + \"'\", null, null);\n          return path;\n        }\n\n        String macroName = path.substring(2, index);\n        SNode found = null;\n        for (SNode macro : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SNodeOperations.getNodeAncestor(originalModule, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, \"jetbrains.mps.build.structure.BuildProject\"), false, false), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x4df58c6f18f84a22L, \"macros\")), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\")))) {\n          if (eq_krgnbt_a0a0f0d0f4(SPropertyOperations.getString(macro, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")), macroName)) {\n            found = macro;\n            break;\n          }\n        }\n        if (found == null) {\n          reporter.report(\"macro is not declared in build script: \" + path, null, null);\n          return path;\n        }\n\n        String localPath = BuildFolderMacro__BehaviorDescriptor.evaluate_id4jjtc7WZOzA.invoke(found, Context.defaultContext(genContext));\n        if (localPath == null) {\n          reporter.report(\"cannot resolve local path: \" + path + \", macro has no default value\", found, null);\n          return path;\n        }\n\n        String relPath = path.substring(index + 1);\n        return IFileUtils.getCanonicalPath(FileSystem.getInstance().getFileByPath(localPath).getDescendant(relPath));\n      }\n      return path;\n    }","commit_id":"b71bedb5273994b1585bd88085a6ca8e65a063af","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_krgnbt_a0c0f0d0f4(Object a, Object b) {\n      return (a != null ? a.equals(b) : a == b);\n    }","id":51327,"modified_method":"private static boolean eq_krgnbt_a0a0f0d0f4(Object a, Object b) {\n      return (a != null ? a.equals(b) : a == b);\n    }","commit_id":"b71bedb5273994b1585bd88085a6ca8e65a063af","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject__BehaviorDescriptor.getBasePath_id4jjtc7WZOyG.invoke(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n\n    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());\n    final List<SNode> withoutPath = ListSequence.fromList(new ArrayList<SNode>());\n    ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x4df58c6f18f84a22L, \"macros\"))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\"));\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        String path = normalizePath(BuildFolderMacro__BehaviorDescriptor.evaluate_id4jjtc7WZOzA.invoke(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\")), Context.defaultContext()), true);\n        if (path != null && path.length() > 1) {\n          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\"))));\n        } else {\n          ListSequence.fromList(withoutPath).addElement(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\")));\n        }\n      }\n    });\n    if (workingDirectory != null) {\n      ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));\n    }\n    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Integer>() {\n      public Integer select(Tuples._2<String, SNode> it) {\n        return it._0().length() * 2 - ((it._1() == null ? 1 : 0));\n      }\n    }, false);\n    macrosWithoutPath = withoutPath;\n  }","id":51328,"modified_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject__BehaviorDescriptor.getBasePath_id4jjtc7WZOyG.invoke(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n\n    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());\n    final List<SNode> withoutPath = ListSequence.fromList(new ArrayList<SNode>());\n    Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x4df58c6f18f84a22L, \"macros\")), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\"))).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        String path = normalizePath(BuildFolderMacro__BehaviorDescriptor.evaluate_id4jjtc7WZOzA.invoke(it, Context.defaultContext()), true);\n        if (path != null && path.length() > 1) {\n          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\"))));\n        } else {\n          ListSequence.fromList(withoutPath).addElement(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, \"jetbrains.mps.build.structure.BuildFolderMacro\")));\n        }\n      }\n    });\n    if (workingDirectory != null) {\n      ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));\n    }\n    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Integer>() {\n      public Integer select(Tuples._2<String, SNode> it) {\n        return it._0().length() * 2 - ((it._1() == null ? 1 : 0));\n      }\n    }, false);\n    macrosWithoutPath = withoutPath;\n  }","commit_id":"b71bedb5273994b1585bd88085a6ca8e65a063af","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public SNode resolve(SNode contextNode, @NotNull String refText) {\n    // todo \n    return null;\n  }","id":51329,"modified_method":"@Nullable\n  public abstract SNode resolve(SNode contextNode, @NotNull String refText);","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getAvailableElements(@Nullable String prefix) {\n    List<SNode> result = ListSequence.fromList(new ArrayList());\n    Set<String> overridenSignatures = SetSequence.fromSet(new HashSet());\n\n    for (List<SNode> methods : Sequence.fromIterable(MapSequence.fromMap(nameToMethods).values())) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(methods));\n      SetSequence.fromSet(overridenSignatures).addSequence(ListSequence.fromList(methods).select(new ISelector<SNode, String>() {\n        public String select(SNode it) {\n          return getSignatureForOverriding(it, classifier);\n        }\n      }));\n    }\n\n    Map<String, List<SNode>> groups = MapSequence.fromMap(new HashMap<String, List<SNode>>());\n    for (SNode extendedClassifier : Sequence.fromIterable(extendedClassifiers)) {\n      for (SNode method : ListSequence.fromList(((Scope) BehaviorManager.getInstance().invoke(Object.class, extendedClassifier, \"virtual_getVisibleMembers_8083692786967356611\", new Class[]{SNode.class, SNode.class, SNode.class}, classifier, kind)).getAvailableElements(prefix)).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));\n        }\n      }).select(new ISelector<SNode, SNode>() {\n        public SNode select(SNode it) {\n          return SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\");\n        }\n      })) {\n        if (!(SetSequence.fromSet(overridenSignatures).contains(getSignatureForOverriding(method, extendedClassifier)))) {\n          if (MapSequence.fromMap(groups).containsKey(SPropertyOperations.getString(method, \"name\"))) {\n            ListSequence.fromList(MapSequence.fromMap(groups).get(SPropertyOperations.getString(method, \"name\"))).addElement(method);\n          } else {\n            MapSequence.fromMap(groups).put(SPropertyOperations.getString(method, \"name\"), ListSequence.fromListAndArray(new ArrayList<SNode>(), method));\n          }\n        }\n      }\n    }\n\n    for (IMapping<String, List<SNode>> group : MapSequence.fromMap(groups)) {\n      // todo: extension methods? \n      if ((int) ListSequence.fromList(group.value()).select(new ISelector<SNode, SNode>() {\n        public SNode select(SNode it) {\n          return SNodeOperations.cast(SNodeOperations.getParent(it), \"jetbrains.mps.baseLanguage.structure.Classifier\");\n        }\n      }).distinct().count() == 1) {\n        ListSequence.fromList(result).addSequence(ListSequence.fromList(group.value()));\n      }\n    }\n\n    return result;\n  }","id":51330,"modified_method":"public List<SNode> getAvailableElements(@Nullable final String prefix) {\n    if (allMethods != null) {\n      return ListSequence.fromList(allMethods).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return prefix == null || SPropertyOperations.getString(it, \"name\").startsWith(prefix);\n        }\n      }).toListSequence();\n    }\n\n    List<SNode> result = ListSequence.fromList(new ArrayList());\n    Set<String> overridenSignatures = SetSequence.fromSet(new HashSet<String>());\n\n    for (List<SNode> methods : Sequence.fromIterable(MapSequence.fromMap(nameToMethods).values())) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(methods));\n      SetSequence.fromSet(overridenSignatures).addSequence(ListSequence.fromList(methods).select(new ISelector<SNode, String>() {\n        public String select(SNode it) {\n          return getSignatureForOverriding(it, classifier);\n        }\n      }));\n    }\n\n    Map<String, Set<SNode>> groups = MapSequence.fromMap(new HashMap<String, Set<SNode>>());\n    for (SNode extendedClassifier : Sequence.fromIterable(extendedClassifiers)) {\n      for (SNode method : ListSequence.fromList(((Scope) BehaviorManager.getInstance().invoke(Object.class, extendedClassifier, \"virtual_getVisibleMembers_8083692786967356611\", new Class[]{SNode.class, SNode.class, SNode.class}, classifier, kind)).getAvailableElements(prefix)).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));\n        }\n      }).select(new ISelector<SNode, SNode>() {\n        public SNode select(SNode it) {\n          return SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\");\n        }\n      })) {\n        String signature = getSignatureForOverriding(method, classifier);\n        if (!(SetSequence.fromSet(overridenSignatures).contains(signature))) {\n          if (MapSequence.fromMap(groups).containsKey(signature)) {\n            SetSequence.fromSet(MapSequence.fromMap(groups).get(signature)).addElement(method);\n          } else {\n            MapSequence.fromMap(groups).put(signature, SetSequence.fromSetAndArray(new HashSet<SNode>(), method));\n          }\n        }\n      }\n    }\n\n    for (IMapping<String, Set<SNode>> group : MapSequence.fromMap(groups)) {\n      // todo: extension methods? \n      ListSequence.fromList(result).addSequence(Sequence.fromIterable(getMethodsFromGroup(group.value())));\n    }\n\n    if (prefix == null) {\n      allMethods = ListSequence.fromList(result).select(new ISelector<SNode, SNode>() {\n        public SNode select(SNode it) {\n          return SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\");\n        }\n      }).toListSequence();\n    }\n\n    return result;\n  }","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope virtual_getMembers_2201875424515824604(SNode thisNode, SNode kind) {\n    SNode superClass = SLinkOperations.getTarget(ClassConcept_Behavior.call_getSuperclass_1240936569950(thisNode), \"classifier\", false);\n    if ((superClass == null)) {\n      superClass = SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\");\n    }\n    if (Classifier_Behavior.call_isSame_4855996797771684010(SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\"), thisNode)) {\n      superClass = null;\n    }\n    if (!(SNodeOperations.isInstanceOf(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"))) {\n      // todo: ??? for anonymous. fix in right way in anonymous \n      superClass = null;\n    }\n\n    // todo: remove this code from getMembers to getScope \n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.ThisConstructorKind\")) {\n      return new SimpleScope(SLinkOperations.getTargets(thisNode, \"constructor\", true));\n    }\n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperConstructorKind\") || SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperMethodKind\")) {\n      if (Classifier_Behavior.call_isSame_4855996797771684010(thisNode, SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\"))) {\n        return new EmptyScope();\n      }\n\n      if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperConstructorKind\")) {\n        return MemberScopes.visibleClassifierMembers(superClass, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ThisConstructorKind\"), thisNode);\n      }\n      if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperMethodKind\")) {\n        return MemberScopes.nonAbstractMethods(MemberScopes.visibleClassifierMembers(superClass, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"), thisNode));\n      }\n    }\n\n    // cache section \n    TransactionCache cache = ModelAccess.instance().getTransactionCache(\"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Scope cached = (Scope) cache.get(MultiTuple.<SNode,SNode>from(thisNode, kind));\n    if (cached != null) {\n      return cached;\n    }\n    // end cache section \n\n    SNode[] implementedInterfaces = ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"implementedInterface\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (SLinkOperations.getTarget(it, \"classifier\", false) != null);\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SLinkOperations.getTarget(it, \"classifier\", false);\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (it != null);\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.Interface\");\n      }\n    }).toGenericArray(SNode.class);\n\n    // todo: generialize this code \n    Scope result = null;\n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\")) {\n      result = FieldDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration\")) {\n      result = EnumConstantDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.Property\")) {\n      result = PropertyScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration\")) {\n      result = StaticFieldDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\")) {\n      result = StaticMethodDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    }\n\n    // cache section \n    if (result != null) {\n      cache.put(MultiTuple.<SNode,SNode>from(thisNode, kind), result);\n      return result;\n    }\n\n    return Classifier_Behavior.callSuper_getMembers_2201875424515824604(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", kind);\n  }","id":51331,"modified_method":"public static Scope virtual_getMembers_2201875424515824604(SNode thisNode, SNode kind) {\n    SNode superClass = SLinkOperations.getTarget(ClassConcept_Behavior.call_getSuperclass_1240936569950(thisNode), \"classifier\", false);\n    if ((superClass == null)) {\n      superClass = SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\");\n    }\n    if (Classifier_Behavior.call_isSame_4855996797771684010(SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\"), thisNode)) {\n      superClass = null;\n    }\n    if (!(SNodeOperations.isInstanceOf(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"))) {\n      // todo: ??? for anonymous. fix in right way in anonymous \n      superClass = null;\n    }\n\n    // todo: remove this code from getMembers to getScope \n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.ThisConstructorKind\")) {\n      return new SimpleScope(SLinkOperations.getTargets(thisNode, \"constructor\", true));\n    }\n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperConstructorKind\") || SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperMethodKind\")) {\n      if (Classifier_Behavior.call_isSame_4855996797771684010(thisNode, SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\"))) {\n        return new EmptyScope();\n      }\n\n      if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperConstructorKind\")) {\n        return MemberScopes.visibleClassifierMembers(superClass, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ThisConstructorKind\"), thisNode);\n      }\n      if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.SuperMethodKind\")) {\n        return MemberScopes.nonAbstractMethods(MemberScopes.visibleClassifierMembers(superClass, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"), thisNode));\n      }\n    }\n\n    // cache section \n    TransactionCache cache = ModelAccess.instance().getTransactionCache(\"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Scope cached = (Scope) cache.get(MultiTuple.<SNode,SNode>from(thisNode, kind));\n    if (cached != null) {\n      return cached;\n    }\n    // end cache section \n\n    SNode[] implementedInterfaces = ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"implementedInterface\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (SLinkOperations.getTarget(it, \"classifier\", false) != null);\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SLinkOperations.getTarget(it, \"classifier\", false);\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (it != null);\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.Interface\");\n      }\n    }).toGenericArray(SNode.class);\n\n    // todo: generialize this code \n    Scope result = null;\n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\")) {\n      result = FieldDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration\")) {\n      result = EnumConstantDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.Property\")) {\n      result = PropertyScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration\")) {\n      result = StaticFieldDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\")) {\n      result = StaticMethodDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    } else if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) {\n      result = InstanceMethodDeclarationScope.forClass(thisNode, SNodeOperations.cast(superClass, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), implementedInterfaces);\n    }\n\n    // cache section \n    if (result != null) {\n      cache.put(MultiTuple.<SNode,SNode>from(thisNode, kind), result);\n      return result;\n    }\n\n    return Classifier_Behavior.callSuper_getMembers_2201875424515824604(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", kind);\n  }","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public InstanceMethodDeclarationScope() {\n  }","id":51332,"modified_method":"public InstanceMethodDeclarationScope(SNode classifierNode, Iterable<SNode> extendedClassifiers) {\n    super(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"), classifierNode, extendedClassifiers);\n  }","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope forClass(SNode classNode, @Nullable SNode extendsClass, SNode... implementsInterfaces) {\n    // todo \n    return new EmptyScope();\n  }","id":51333,"modified_method":"public static Scope forClass(SNode classNode, @Nullable SNode extendsClass, SNode... implementsInterfaces) {\n    // collect extended classifiers \n    List<SNode> extendedClassifiers = ListSequence.fromList(new ArrayList<SNode>());\n    if ((extendsClass != null)) {\n      ListSequence.fromList(extendedClassifiers).addElement(extendsClass);\n    }\n    ListSequence.fromList(extendedClassifiers).addSequence(Sequence.fromIterable(Sequence.fromArray(implementsInterfaces)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (it != null);\n      }\n    }));\n    return new InstanceMethodDeclarationScope(classNode, extendedClassifiers);\n  }","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope forInterface(SNode interfaceNode, SNode... extendsInterfaces) {\n    // todo \n    return new EmptyScope();\n  }","id":51334,"modified_method":"public static Scope forInterface(SNode interfaceNode, SNode... extendsInterfaces) {\n    return new InstanceMethodDeclarationScope(interfaceNode, Sequence.fromArray(extendsInterfaces));\n  }","commit_id":"b3c44f8937184aeda166d33a5e5d09b2a8e9d9eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\r\n   * Returns the value of an attribute for a given relative coordinate.\r\n   * @param relative relative coordinate\r\n   * @return item value\r\n   */\r\n  String getValue(final double relative) {\r\n    if(numeric) {\r\n      if(numType == TYPEDBL) {\r\n        double d = min + (max - min) * relative;\r\n        return Double.toString(d);\r\n      } else {\r\n        int i = (int) (min + (max - min) * relative);\r\n        return Integer.toString(i);\r\n      }\r\n    } else {\r\n      final double pos = relative / (1.0d / (nrCats - 1));\r\n      final int posI = (int) Math.floor(pos + 0.5d);\r\n      if(Math.abs(pos - posI) <= 0.3d)\r\n        return Token.string(cats[posI]);\r\n      return \"\";\r\n    }\r\n  }","id":51335,"modified_method":"/**\r\n   * Returns the value of an attribute for a given relative coordinate.\r\n   * @param relative relative coordinate\r\n   * @return item value\r\n   */\r\n  String getValue(final double relative) {\r\n    if(numeric) {\r\n      if(numType == TYPEDBL) {\r\n        double d = min + (max - min) * relative;\r\n        return Double.toString(d);\r\n      } else {\r\n        int i = (int) (min + (max - min) * relative);\r\n        return Integer.toString(i);\r\n      }\r\n    } else {\r\n      final double pos = relative / (1.0d / (nrCats - 1));\r\n      final int posI = (int) Math.floor(pos + 0.5d);\r\n      if(Math.abs(pos - posI) <= 0.3d)\r\n        return string(cats[posI]);\r\n      return \"\";\r\n    }\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Determines the smallest and greatest occurring values for a specific item.\r\n   * Afterwards the extremes are slightly rounded to support a decent axis\r\n   * caption.\r\n   *\r\n   * If range between min/max < 10 extremes are calculated by floor/ceil \r\n   * function.\r\n   * If range >=10 the minimum is allowed to lie 25% of the range under the\r\n   * actual minimum. After that the final extreme is calculated as the value\r\n   * between the smallest allowed minimum and the actual minimum which is \r\n   * dividable by pow(10, log10(range)-1).\r\n   * \r\n   * Maximum v.v. . \r\n   */\r\n  private void calcExtremeValues() {\r\n    final Performance p = new Performance();\r\n    \r\n    min = Integer.MAX_VALUE;\r\n    max = Integer.MIN_VALUE;\r\n    for(int i = 0; i < vals.length; i++) {\r\n      if(vals[i].length < 1)\r\n        continue;\r\n      double d = Token.toDouble(vals[i]);\r\n      if(d < min)\r\n        min = d;\r\n      if(d > max) \r\n        max = d;\r\n    }\r\n    \r\n    final double range = max - min;\r\n    final int lmin = (int) (min - (range / 2));\r\n    final int lmax = (int) (max + (range / 2));\r\n    int tmin = (int) Math.floor(min);\r\n    int tmax = (int) Math.ceil(max);\r\n    final double rangePow = Math.floor(Math.log10(range) + .5d);\r\n    calculatedCaptionStep = (int) (Math.pow(10, rangePow - 1));\r\n    final double tmpStepL = (int) (Math.pow(10, rangePow));\r\n    \r\n    boolean sFound = false;\r\n    min = tmin;\r\n    while(tmin > lmin) {\r\n      if(tmin % tmpStepL == 0) {\r\n        min = tmin;\r\n        break;\r\n      }\r\n      if(!sFound && tmin % calculatedCaptionStep == 0) {\r\n        min = tmin;\r\n        sFound = true;\r\n      }\r\n      tmin--;\r\n    }\r\n    \r\n    max = tmax;\r\n    while(tmax < lmax) {\r\n      final int tmpRange = (int) (tmax - min);\r\n      if(tmax % tmpStepL == 0) {\r\n        max = tmax;\r\n        break;\r\n      }\r\n      if(!sFound && tmax % calculatedCaptionStep == 0 && \r\n          (tmpRange / calculatedCaptionStep) % 2 == 0) {\r\n        max = tmax;\r\n        sFound = true;\r\n      }\r\n      tmax++;\r\n    }\r\n    \r\n    System.out.println(p.getTimer());\r\n  }","id":51336,"modified_method":"/**\r\n   * Determines the smallest and greatest occurring values for a specific item.\r\n   * Afterwards the extremes are slightly rounded to support a decent axis\r\n   * caption.\r\n   *\r\n   * If range between min/max < 10 extremes are calculated by floor/ceil \r\n   * function.\r\n   * If range >=10 the minimum is allowed to lie 25% of the range under the\r\n   * actual minimum. After that the final extreme is calculated as the value\r\n   * between the smallest allowed minimum and the actual minimum which is \r\n   * dividable by pow(10, log10(range)-1).\r\n   * \r\n   * Maximum v.v. . \r\n   */\r\n  private void calcExtremeValues() {\r\n    final Performance p = new Performance();\r\n    \r\n    min = Integer.MAX_VALUE;\r\n    max = Integer.MIN_VALUE;\r\n    for(int i = 0; i < vals.length; i++) {\r\n      if(vals[i].length < 1)\r\n        continue;\r\n      double d = toDouble(vals[i]);\r\n      if(d < min)\r\n        min = d;\r\n      if(d > max) \r\n        max = d;\r\n    }\r\n    \r\n    final double range = max - min;\r\n    final int lmin = (int) (min - (range / 2));\r\n    final int lmax = (int) (max + (range / 2));\r\n    int tmin = (int) Math.floor(min);\r\n    int tmax = (int) Math.ceil(max);\r\n    final double rangePow = Math.floor(Math.log10(range) + .5d);\r\n    calculatedCaptionStep = (int) (Math.pow(10, rangePow - 1));\r\n    final double tmpStepL = (int) (Math.pow(10, rangePow));\r\n    \r\n    boolean sFound = false;\r\n    min = tmin;\r\n    while(tmin > lmin) {\r\n      if(tmin % tmpStepL == 0) {\r\n        min = tmin;\r\n        break;\r\n      }\r\n      if(!sFound && tmin % calculatedCaptionStep == 0) {\r\n        min = tmin;\r\n        sFound = true;\r\n      }\r\n      tmin--;\r\n    }\r\n    \r\n    max = tmax;\r\n    while(tmax < lmax) {\r\n      final int tmpRange = (int) (tmax - min);\r\n      if(tmax % tmpStepL == 0) {\r\n        max = tmax;\r\n        break;\r\n      }\r\n      if(!sFound && tmax % calculatedCaptionStep == 0 && \r\n          (tmpRange / calculatedCaptionStep) % 2 == 0) {\r\n        max = tmax;\r\n        sFound = true;\r\n      }\r\n      tmax++;\r\n    }\r\n    \r\n    System.out.println(p.getTimer());\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting.\r\n   */\r\n  void refreshAxis() {\r\n    if(attr == null || attr.length == 0) return;\r\n\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(data.tags.id(attr)) :\r\n      data.atts.stat(data.atts.id(attr));\r\n    numeric = key.kind == Kind.INT || key.kind == Kind.DBL;\r\n    if(numeric) {\r\n      numType = key.kind == Kind.INT ? TYPEINT : TYPEDBL;\r\n//      min = key.min;\r\n//      max = key.max;\r\n    } else {\r\n      cats = key.cats.keys();\r\n      final String[] tmpCats = new String[cats.length];\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        tmpCats[i] = Token.string(cats[i]);\r\n      }\r\n      Arrays.sort(tmpCats);\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        cats[i] = Token.token(tmpCats[i]);\r\n      }\r\n      nrCats = cats.length;\r\n    }\r\n\r\n    final int[] items = scatterData.pres;\r\n    co = new double[items.length];\r\n    vals = new byte[items.length][];\r\n    for(int i = 0; i < items.length; i++) {\r\n      int p = items[i];\r\n      final int limit = p + data.size(p, Data.ELEM);\r\n      byte[] value = {};\r\n      p++;\r\n      while(p < limit) {\r\n        final int kind = data.kind(p);\r\n        if(kind == Data.ELEM) {\r\n          final byte[] currName = data.tag(p);\r\n          if((Token.eq(attr, currName)) && isTag) {\r\n            final int attSize = data.attSize(p, kind);\r\n            value = data.text(p + attSize);\r\n            break;\r\n          }\r\n        } else if(kind == Data.ATTR) {\r\n          final byte[] currName = data.attName(p);\r\n          if((Token.eq(attr, currName)) && !isTag) {\r\n            value = data.attValue(p);\r\n            break;\r\n          }\r\n        }\r\n        p++;\r\n      }\r\n      vals[i] = value;\r\n    }\r\n    \r\n    if(numeric)\r\n      calcExtremeValues();\r\n    for(int i = 0; i < vals.length; i++) {\r\n      final byte[] val = vals[i];\r\n      if(val.length > 0) {\r\n        co[i] = calcPosition(val);\r\n      }\r\n    }\r\n    vals = null;\r\n  }","id":51337,"modified_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting.\r\n   */\r\n  void refreshAxis() {\r\n    if(attr == null || attr.length == 0) return;\r\n\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(data.tags.id(attr)) :\r\n      data.atts.stat(data.atts.id(attr));\r\n    numeric = key.kind == Kind.INT || key.kind == Kind.DBL;\r\n\r\n    if(numeric) {\r\n      numType = key.kind == Kind.INT ? TYPEINT : TYPEDBL;\r\n    } else {\r\n      cats = key.cats.keys();\r\n      final String[] tmpCats = new String[cats.length];\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        tmpCats[i] = string(cats[i]);\r\n      }\r\n      Arrays.sort(tmpCats);\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        cats[i] = token(tmpCats[i]);\r\n      }\r\n      nrCats = cats.length;\r\n    }\r\n\r\n    final int[] items = scatterData.pres;\r\n    co = new double[items.length];\r\n    vals = new byte[items.length][];\r\n    for(int i = 0; i < items.length; i++) {\r\n      int p = items[i];\r\n      final int limit = p + data.size(p, Data.ELEM);\r\n      byte[] value = {};\r\n      p++;\r\n      while(p < limit) {\r\n        final int kind = data.kind(p);\r\n        if(kind == Data.ELEM) {\r\n          final byte[] currName = data.tag(p);\r\n          if((eq(attr, currName)) && isTag) {\r\n            final int attSize = data.attSize(p, kind);\r\n            value = data.text(p + attSize);\r\n            break;\r\n          }\r\n        } else if(kind == Data.ATTR) {\r\n          final byte[] currName = data.attName(p);\r\n          if((eq(attr, currName)) && !isTag) {\r\n            value = data.attValue(p);\r\n            break;\r\n          }\r\n        }\r\n        p++;\r\n      }\r\n      vals[i] = value;\r\n    }\r\n    \r\n    if(numeric)\r\n      calcExtremeValues();\r\n    for(int i = 0; i < vals.length; i++) {\r\n      final byte[] val = vals[i];\r\n      if(val.length > 0) {\r\n        co[i] = calcPosition(val);\r\n      }\r\n    }\r\n    vals = null;\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Called if the user has changed the caption of the axis. If a new \r\n   * attribute was selected the positions of the plot items are recalculated.\r\n   * @param attribute attribute selected by the user\r\n   * @return true if new attribute was selected\r\n   */\r\n  boolean setAxis(final String attribute) {\r\n    if(attribute == null) return false;\r\n    final byte[] b = Token.token(attribute);\r\n    isTag = !Token.contains(b, AT);\r\n    attr = Token.delete(b, '@');\r\n    refreshAxis();\r\n    return true;\r\n  }","id":51338,"modified_method":"/**\r\n   * Called if the user has changed the caption of the axis. If a new \r\n   * attribute was selected the positions of the plot items are recalculated.\r\n   * @param attribute attribute selected by the user\r\n   * @return true if new attribute was selected\r\n   */\r\n  boolean setAxis(final String attribute) {\r\n    if(attribute == null) return false;\r\n    final byte[] b = token(attribute);\r\n    isTag = !contains(b, AT);\r\n    attr = delete(b, '@');\r\n    refreshAxis();\r\n    return true;\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Calculates the relative position of an item in the plot for a given value.\r\n   * @param value item value\r\n   * @return relative x or y value of the item\r\n   */\r\n  double calcPosition(final byte[] value) {\r\n    final double d = Token.toDouble(value);\r\n    double percentage = 0d;\r\n    if(numeric) {\r\n      final double range = max - min;\r\n      if(range == 0)\r\n        \r\n        percentage = 0.5d;\r\n      else\r\n        percentage = 1 / range * (d - min);\r\n     \r\n    } else {\r\n      if(nrCats == 1)\r\n        percentage = 0.5d;\r\n      else\r\n        for(int i = 0; i < nrCats; i++) {\r\n          if(Token.eq(value, cats[i])) {\r\n            percentage = (1.0d / (nrCats - 1)) * i;\r\n          }\r\n        }\r\n    }\r\n    return percentage;\r\n  }","id":51339,"modified_method":"/**\r\n   * Calculates the relative position of an item in the plot for a given value.\r\n   * @param value item value\r\n   * @return relative x or y value of the item\r\n   */\r\n  double calcPosition(final byte[] value) {\r\n    final double d = toDouble(value);\r\n    double percentage = 0d;\r\n    if(numeric) {\r\n      final double range = max - min;\r\n      if(range == 0)\r\n        \r\n        percentage = 0.5d;\r\n      else\r\n        percentage = 1 / range * (d - min);\r\n     \r\n    } else {\r\n      if(nrCats == 1)\r\n        percentage = 0.5d;\r\n      else\r\n        for(int i = 0; i < nrCats; i++) {\r\n          if(eq(value, cats[i])) {\r\n            percentage = (1.0d / (nrCats - 1)) * i;\r\n          }\r\n        }\r\n    }\r\n    return percentage;\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    \r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pWidth = plotWidth - NOVALUEBORDER;\r\n    final int pHeight = plotHeight - NOVALUEBORDER;\r\n    final ScatterAxis axis = drawX ? scatterData.xAxis : scatterData.yAxis;\r\n    if(drawX) {\r\n      g.drawLine(MARGINLEFT, h - MARGINBOTTOM, w - MARGINRIGHT, \r\n          h - MARGINBOTTOM);\r\n//      if(plotChanged)\r\n        axis.calcCaption(pWidth);\r\n    } else {\r\n      g.drawLine(MARGINLEFT, MARGINTOP, MARGINLEFT, \r\n          getHeight() - MARGINBOTTOM);\r\n//      if(plotChanged)\r\n        axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n    final boolean numeric = axis.numeric;\r\n    final int nrCaptions = (!numeric && axis.nrCats == 1) ? 3 : axis.nrCaptions;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int type = axis.numType;\r\n    \r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n          \r\n        if(type == ScatterAxis.TYPEINT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          //caption = Double.toString(captionValue);\r\n          caption = string(chopNumber(token(captionValue)));\r\n      } else {\r\n        if(axis.nrCats == 1) {\r\n          if(i == 1)\r\n            caption = string(axis.cats[0]);\r\n        } else {\r\n          caption = string(axis.cats[i]);\r\n        }\r\n      }\r\n      \r\n      if(caption.length() > 10) {\r\n        caption = caption.substring(0, 10);\r\n        caption += \"...\";\r\n      }\r\n\r\n      // draw rotated caption labels\r\n      final int capW = BaseXLayout.width(g, caption);\r\n      final int imgH = 160;\r\n      final int imgW = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = (Graphics2D) img.getGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.rotate(Math.sin(30), imgW, 0 + textH);\r\n      g2d.drawString(caption, imgW - capW, 0);\r\n      g.setColor(GUIConstants.color1);\r\n\r\n      if(drawX) {\r\n        final int x = MARGINLEFT + NOVALUEBORDER + \r\n          ((int) ((i * range) * pWidth));\r\n        g.drawImage(img, x - imgW + textH + 4, h - MARGINBOTTOM + 14, this);\r\n        g.drawLine(x, MARGINTOP, x, h - MARGINBOTTOM + 9);\r\n      } else {\r\n        final int y = h - MARGINBOTTOM - NOVALUEBORDER - \r\n        ((int) ((i * range) * pHeight));\r\n        g.drawLine(MARGINLEFT - 14, y, w - MARGINRIGHT, y);\r\n        g.drawImage(img, MARGINLEFT - imgW - 5, y - 6, this);\r\n      }\r\n    }\r\n  }","id":51340,"modified_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    \r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pWidth = plotWidth - NOVALUEBORDER;\r\n    final int pHeight = plotHeight - NOVALUEBORDER;\r\n    final ScatterAxis axis = drawX ? scatterData.xAxis : scatterData.yAxis;\r\n    if(drawX) {\r\n      g.drawLine(MARGINLEFT, h - MARGINBOTTOM, w - MARGINRIGHT, \r\n          h - MARGINBOTTOM);\r\n      if(plotChanged)\r\n        axis.calcCaption(pWidth);\r\n    } else {\r\n      g.drawLine(MARGINLEFT, MARGINTOP, MARGINLEFT, \r\n          getHeight() - MARGINBOTTOM);\r\n      if(plotChanged)\r\n        axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n    final boolean numeric = axis.numeric;\r\n    final int nrCaptions = (!numeric && axis.nrCats == 1) ? 3 : axis.nrCaptions;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int type = axis.numType;\r\n    \r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n          \r\n        if(type == ScatterAxis.TYPEINT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          caption = string(chopNumber(token(captionValue)));\r\n      } else {\r\n        if(axis.nrCats == 1) {\r\n          if(i == 1)\r\n            caption = string(axis.cats[0]);\r\n        } else {\r\n          caption = string(axis.cats[i]);\r\n        }\r\n      }\r\n      \r\n      if(caption.length() > 10) {\r\n        caption = caption.substring(0, 10);\r\n        caption += \"...\";\r\n      }\r\n\r\n      // draw rotated caption labels\r\n      final int capW = BaseXLayout.width(g, caption);\r\n      final int imgH = 160;\r\n      final int imgW = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = (Graphics2D) img.getGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.rotate(Math.sin(30), imgW, 0 + textH);\r\n      g2d.drawString(caption, imgW - capW, 0);\r\n      g.setColor(GUIConstants.color1);\r\n\r\n      if(drawX) {\r\n        final int x = MARGINLEFT + NOVALUEBORDER + \r\n          ((int) ((i * range) * pWidth));\r\n        g.drawImage(img, x - imgW + textH + 4, h - MARGINBOTTOM + 14, this);\r\n        g.drawLine(x, MARGINTOP, x, h - MARGINBOTTOM + 9);\r\n      } else {\r\n        final int y = h - MARGINBOTTOM - NOVALUEBORDER - \r\n        ((int) ((i * range) * pHeight));\r\n        g.drawLine(MARGINLEFT - 14, y, w - MARGINRIGHT, y);\r\n        g.drawImage(img, MARGINLEFT - imgW - 5, y - 6, this);\r\n      }\r\n    }\r\n  }","commit_id":"2bd8c0fe6d04140e5937221c0dc34acd8e304d6e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Calculates axis caption depending on view width / height.\r\n   * @param space space of view axis available for captions\r\n   */\r\n  void calcCaption(final int space) {\r\n    if(numeric) {\r\n      if(numType == TYPEINT) {\r\n        final int minI = (int) min;\r\n        final int maxI = (int) max;\r\n        int tmpStep = 1;\r\n        do {\r\n          captionStep = tmpStep;\r\n          int tmpMin = minI - minI % tmpStep;\r\n          int tmpMax = (maxI + tmpStep - 1) / tmpStep * tmpStep;\r\n          nrCaptions = (tmpMax - tmpMin) / tmpStep + 1;\r\n          if(String.valueOf(tmpStep).startsWith(\"1\"))\r\n            tmpStep *= tmpStep == 1 ? 5 : 2.5;\r\n          else\r\n            tmpStep *= 2;\r\n        } while(nrCaptions * ScatterView.CAPTIONWHITESPACE > space);\r\n        \r\n      } else {\r\n        nrCaptions = 5;\r\n        captionStep = .5d;\r\n      }\r\n    } else {\r\n      nrCaptions = nrCats;\r\n    }\r\n  }","id":51341,"modified_method":"/**\r\n   * Calculates axis caption depending on view width / height.\r\n   * @param space space of view axis available for captions\r\n   */\r\n  void calcCaption(final int space) {\r\n    if(numeric) {\r\n      if(numType == TYPEINT) {\r\n        final int minI = (int) min;\r\n        final int maxI = (int) max;\r\n        int tmpStep = 1;\r\n        do {\r\n          captionStep = tmpStep;\r\n          int tmpMin = minI - minI % tmpStep;\r\n          int tmpMax = maxI + maxI % tmpStep;\r\n          nrCaptions = (tmpMax - tmpMin) / tmpStep + 1;\r\n          if(String.valueOf(tmpStep).startsWith(\"1\"))\r\n            tmpStep *= tmpStep == 1 ? 5 : 2.5;\r\n          else\r\n            tmpStep *= 2;\r\n        } while(nrCaptions * ScatterView.CAPTIONWHITESPACE > space);\r\n        \r\n      } else if(numType == TYPEDBL) {\r\n        final double minD = min;\r\n        final double maxD = max;\r\n        double tmpStep = .01d;\r\n        if(maxD - minD > 500)\r\n          tmpStep = 1;\r\n        do {\r\n          captionStep = tmpStep;\r\n//          double tmpMin = (int) (minD / tmpStep) * tmpStep;\r\n//          double tmpMax = (int) ((maxD + tmpStep - .01d) / tmpStep) * tmpStep;\r\n          nrCaptions = (int) ((maxD - minD) / tmpStep) + 1;\r\n          if(String.valueOf(tmpStep).indexOf(\"1\") > -1) {\r\n            tmpStep *= 2.5;\r\n          } else {\r\n            tmpStep *= 2;\r\n          }\r\n        } while(nrCaptions * ScatterView.CAPTIONWHITESPACE > space &&\r\n            maxD - minD > tmpStep);\r\n        \r\n      } else {\r\n        nrCaptions = 5;\r\n        captionStep = .5d;\r\n      }\r\n    } else {\r\n      nrCaptions = nrCats;\r\n    }\r\n  }","commit_id":"bb9c2bae5a40e81d7c19662794acb52e517395b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawXaxis(final Graphics g) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    g.drawLine(MARGINLEFT, h - MARGINBOTTOM, w - MARGINRIGHT, \r\n        h - MARGINBOTTOM);\r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pWidth = plotWidth - NOVALUEBORDER;\r\n    final ScatterAxis axis = scatterData.xAxis;\r\n    axis.calcCaption(pWidth);\r\n    final int nrCaptions = axis.nrCats != 1 ? axis.nrCaptions : 3;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int type = axis.numType;\r\n    final boolean numeric = axis.numeric;\r\n    \r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      g.setColor(GUIConstants.color1);\r\n      final int x = MARGINLEFT + NOVALUEBORDER + ((int) ((i * range) * pWidth));\r\n      g.drawLine(x, MARGINTOP, x, h - MARGINBOTTOM + 9);\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n          \r\n        if(type == ScatterAxis.TYPEINT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          caption = \"double dummy\";\r\n      } else {\r\n        if(axis.nrCats == 1) {\r\n          if(i == 1)\r\n            caption = Token.string(axis.cats[0]);\r\n        } else {\r\n          caption = Token.string(axis.cats[i]);\r\n        }\r\n      }\r\n      \r\n      // draw rotated caption labels\r\n      if(caption.length() > 22) {\r\n        caption = caption.substring(0, 25);\r\n        caption += \"...\";\r\n      }\r\n\r\n      int capW = BaseXLayout.width(g, caption);\r\n      final int imgH = 160;\r\n      int imgW = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = (Graphics2D) img.getGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.rotate(Math.sin(30), imgW, 0 + textH);\r\n      g2d.drawString(caption, imgW - capW, 0);\r\n      g.drawImage(img, x - imgW + textH + 4, h - MARGINBOTTOM + 14, this);\r\n    }\r\n  }","id":51342,"modified_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawXaxis(final Graphics g) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    g.drawLine(MARGINLEFT, h - MARGINBOTTOM, w - MARGINRIGHT, \r\n        h - MARGINBOTTOM);\r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pWidth = plotWidth - NOVALUEBORDER;\r\n    final ScatterAxis axis = scatterData.xAxis;\r\n    if(plotChanged)\r\n      axis.calcCaption(pWidth);\r\n    final int nrCaptions = axis.nrCats != 1 ? axis.nrCaptions : 3;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int type = axis.numType;\r\n    final boolean numeric = axis.numeric;\r\n    \r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      g.setColor(GUIConstants.color1);\r\n      final int x = MARGINLEFT + NOVALUEBORDER + ((int) ((i * range) * pWidth));\r\n      g.drawLine(x, MARGINTOP, x, h - MARGINBOTTOM + 9);\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n          \r\n        if(type == ScatterAxis.TYPEINT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          caption = Double.toString(captionValue);\r\n      } else {\r\n        if(axis.nrCats == 1) {\r\n          if(i == 1)\r\n            caption = Token.string(axis.cats[0]);\r\n        } else {\r\n          caption = Token.string(axis.cats[i]);\r\n        }\r\n      }\r\n      \r\n      // draw rotated caption labels\r\n      if(caption.length() > 22) {\r\n        caption = caption.substring(0, 20);\r\n        caption += \"...\";\r\n      }\r\n\r\n      int capW = BaseXLayout.width(g, caption);\r\n      final int imgH = 160;\r\n      int imgW = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = (Graphics2D) img.getGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.rotate(Math.sin(30), imgW, 0 + textH);\r\n      g2d.drawString(caption, imgW - capW, 0);\r\n      g.drawImage(img, x - imgW + textH + 4, h - MARGINBOTTOM + 14, this);\r\n    }\r\n  }","commit_id":"bb9c2bae5a40e81d7c19662794acb52e517395b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws the y axis of the plot.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawYaxis(final Graphics g) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    g.drawLine(MARGINLEFT, MARGINTOP, MARGINLEFT, getHeight() - MARGINBOTTOM);\r\n    \r\n    scatterData.yAxis.calcCaption(plotHeight - NOVALUEBORDER);\r\n\r\n    final boolean numeric = scatterData.yAxis.numeric;\r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pHeight = plotHeight - NOVALUEBORDER;\r\n    final int nrCaptions = numeric ? (pHeight / \r\n        (textH + CAPTIONWHITESPACE)) :\r\n      scatterData.yAxis.nrCaptions;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      g.setColor(GUIConstants.color1);\r\n      final int y1 = h - MARGINBOTTOM - NOVALUEBORDER - \r\n      ((int) ((i * range) * pHeight));\r\n      g.drawLine(MARGINLEFT - 9, y1, w - MARGINRIGHT, y1);\r\n      g.setColor(Color.black);\r\n      String caption = null;\r\n      if(numeric) {\r\n        final double value = scatterData.yAxis.min +\r\n          (scatterData.yAxis.max - scatterData.yAxis.min) * range * i;\r\n        caption = Double.toString(value);\r\n      } else {\r\n        caption = Token.string(scatterData.yAxis.cats[i]);\r\n      }\r\n      final int capW = BaseXLayout.width(g, caption);\r\n      g.drawString(caption, MARGINLEFT - capW - 15, y1 + textH / 2 - 1);\r\n    }\r\n  }","id":51343,"modified_method":"/**\r\n   * Draws the y axis of the plot.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawYaxis(final Graphics g) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    g.drawLine(MARGINLEFT, MARGINTOP, MARGINLEFT, getHeight() - MARGINBOTTOM);\r\n    g.setFont(GUIConstants.font);\r\n    g.setColor(GUIConstants.color1);\r\n\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    final int pHeight = plotHeight - NOVALUEBORDER;\r\n    final ScatterAxis axis = scatterData.yAxis;\r\n    if(plotChanged)\r\n      axis.calcCaption(pHeight);\r\n    final int nrCaptions = axis.nrCats != 1 ? axis.nrCaptions : 3;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int type = axis.numType;\r\n    final boolean numeric = axis.numeric;\r\n    \r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      g.setColor(GUIConstants.color1);\r\n      final int y1 = h - MARGINBOTTOM - NOVALUEBORDER - \r\n      ((int) ((i * range) * pHeight));\r\n      g.drawLine(MARGINLEFT - 9, y1, w - MARGINRIGHT, y1);\r\n      g.setColor(Color.black);\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n        if(type == ScatterAxis.TYPEINT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          caption = Double.toString(captionValue);\r\n      } else {\r\n        if(axis.nrCats == 1) {\r\n          if(i == 1)\r\n            caption = Token.string(axis.cats[0]);\r\n        } else {\r\n          caption = Token.string(axis.cats[i]);\r\n        }\r\n      }\r\n      if(caption.length() > 22) {\r\n        caption = caption.substring(0, 20);\r\n        caption += \"...\";\r\n      }\r\n      final int capW = BaseXLayout.width(g, caption);\r\n      g.drawString(caption, MARGINLEFT - capW - 15, y1 + textH / 2 - 1);\r\n    }\r\n    \r\n//    final int h = getHeight();\r\n//    final int w = getWidth();\r\n//    g.setColor(GUIConstants.color1);\r\n//    g.drawLine(MARGINLEFT, MARGINTOP, MARGINLEFT, getHeight() - MARGINBOTTOM);\r\n//    \r\n//    if(plotChanged)\r\n//      scatterData.yAxis.calcCaption(plotHeight - NOVALUEBORDER);\r\n//\r\n//    final boolean numeric = scatterData.yAxis.numeric;\r\n//    g.setFont(GUIConstants.font);\r\n//    g.setColor(GUIConstants.color1);\r\n//    final int textH = g.getFontMetrics().getHeight();\r\n//    final int pHeight = plotHeight - NOVALUEBORDER;\r\n//    final int nrCaptions = numeric ? (pHeight / \r\n//        (textH + CAPTIONWHITESPACE)) :\r\n//      scatterData.yAxis.nrCaptions;\r\n//    final double range = 1.0d / (nrCaptions - 1);\r\n//    for(int i = 0; i < nrCaptions; i++) {\r\n//      g.setColor(GUIConstants.color1);\r\n//      final int y1 = h - MARGINBOTTOM - NOVALUEBORDER - \r\n//      ((int) ((i * range) * pHeight));\r\n//      g.drawLine(MARGINLEFT - 9, y1, w - MARGINRIGHT, y1);\r\n//      g.setColor(Color.black);\r\n//      String caption = null;\r\n//      if(numeric) {\r\n//        final double value = scatterData.yAxis.min +\r\n//          (scatterData.yAxis.max - scatterData.yAxis.min) * range * i;\r\n//        caption = Double.toString(value);\r\n//      } else {\r\n//        caption = Token.string(scatterData.yAxis.cats[i]);\r\n//      }\r\n//      final int capW = BaseXLayout.width(g, caption);\r\n//      g.drawString(caption, MARGINLEFT - capW - 15, y1 + textH / 2 - 1);\r\n//    }\r\n  }","commit_id":"bb9c2bae5a40e81d7c19662794acb52e517395b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Nullable\n  public String getName() {\n    final PsiElement element = getNameElement();\n    if (element instanceof GrLiteral) {\n      final Object value = ((GrLiteral)element).getValue();\n      if (value instanceof String) {\n        return (String)value;\n      }\n\n      if (value instanceof Number) {\n        return value.toString();\n      }\n    }\n    if (element instanceof GrExpression) {\n      final Object value = JavaPsiFacade.getInstance(getProject()).getConstantEvaluationHelper().computeConstantExpression(element);\n      if (value instanceof String) {\n        return (String)value;\n      }\n    }\n\n    final IElementType elemType = element.getNode().getElementType();\n    if (GroovyTokenTypes.mIDENT == elemType || TokenSets.KEYWORDS.contains(elemType)) {\n      return element.getText();\n    }\n\n    if (CommonClassNames.JAVA_LANG_STRING.equals(TypesUtil.getBoxedTypeName(elemType))) {\n      return GrStringUtil.removeQuotes(element.getText());\n    }\n\n    return null;\n  }","id":51344,"modified_method":"@Nullable\n  public String getName() {\n    final PsiElement element = getNameElement();\n    if (element instanceof GrLiteral) {\n      return convertToString(((GrLiteral)element).getValue());\n    }\n    if (element instanceof GrExpression) {\n      final Object value = JavaPsiFacade.getInstance(getProject()).getConstantEvaluationHelper().computeConstantExpression(element);\n      if (value instanceof String) {\n        return (String)value;\n      }\n    }\n\n    final IElementType elemType = element.getNode().getElementType();\n    if (GroovyTokenTypes.mIDENT == elemType || TokenSets.KEYWORDS.contains(elemType)) {\n      return element.getText();\n    }\n\n    return convertToString(GrLiteralImpl.getLiteralValue(element));\n  }","commit_id":"8fb554f2da94976e8303c2bee4325e34348b484e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getValue() {\n    final PsiElement child = getFirstChild();\n    IElementType elemType = child.getNode().getElementType();\n    String text = child.getText();\n    if (TokenSets.NUMBERS.contains(elemType)) {\n      text = text.replaceAll(\"_\", \"\");\n      try {\n        if (elemType == mNUM_INT) {\n          return Integer.parseInt(text);\n        }\n        else if (elemType == mNUM_LONG) {\n          return Long.parseLong(text);\n        }\n        else if (elemType == mNUM_FLOAT) {\n          return Float.parseFloat(text);\n        }\n        else if (elemType == mNUM_DOUBLE) {\n          return Double.parseDouble(text);\n        }\n        else if (elemType == mNUM_BIG_INT) {\n          return new BigInteger(text);\n        }\n        else if (elemType == mNUM_BIG_DECIMAL) {\n\n          return new BigDecimal(text);\n        }\n      }\n      catch (NumberFormatException ignored) {\n      }\n    }\n\n    else if (elemType == kFALSE) {\n      return Boolean.FALSE;\n    }\n    else if (elemType == kTRUE) {\n      return Boolean.TRUE;\n    }\n    else if (elemType == mSTRING_LITERAL) {\n      if (!text.startsWith(\"'\")) return null;\n      text = text.substring(1);\n      if (text.endsWith(\"'\")) {\n        text = text.substring(0, text.length() - 1);\n      }\n      return StringUtil.unescapeStringCharacters(text);\n    }\n    else if (elemType == mGSTRING_LITERAL) {\n      if (!text.startsWith(\"\\\"\")) return null;\n      if (text.startsWith(\"\\\"\\\"\\\"\")) {\n        text = StringUtil.trimEnd(text.substring(3), \"\\\"\\\"\\\"\");\n      }\n      else {\n        text = StringUtil.trimEnd(text.substring(1), \"\\\"\");\n      }\n      return StringUtil.unescapeStringCharacters(text);\n    }\n    return null; //todo\n  }","id":51345,"modified_method":"public Object getValue() {\n    return getLiteralValue(getFirstChild());\n  }","commit_id":"8fb554f2da94976e8303c2bee4325e34348b484e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void register(CompletionContributor contributor) {\n    MapArgumentCompletionProvider instance = new MapArgumentCompletionProvider();\n\n    ElementPattern<PsiElement> inArgumentListOfCall = psiElement().withParent(psiElement(GrReferenceExpression.class).withParent(\n      StandardPatterns.or(\n        psiElement(GrArgumentList.class).withParent(GrCall.class),\n        new GroovyElementPattern.Capture<GrListOrMap>(new InitialPatternCondition<GrListOrMap>(GrListOrMap.class) {\n          @Override\n          public boolean accepts(@Nullable Object o, ProcessingContext context) {\n            if (!(o instanceof GrListOrMap)) return false;\n            PsiElement parent = ((GrListOrMap)o).getParent();\n            if (!(parent instanceof GrArgumentList)) return false;\n\n            GrArgumentList argumentList = (GrArgumentList)parent;\n            if (argumentList.getNamedArguments().length > 0) return false;\n            if (argumentList.getExpressionArgumentIndex((GrListOrMap)o) > 0) return false;\n\n            if (!(argumentList.getParent() instanceof GrCall)) return false;\n\n            return true;\n          }\n        })\n      )\n    ));\n\n    ElementPattern<PsiElement> inLabel = psiElement(GroovyTokenTypes.mIDENT).withParent(psiElement(GrArgumentLabel.class).withParent(\n      namedArgument().isParameterOfMethodCall(null)));\n\n    contributor.extend(CompletionType.BASIC, inArgumentListOfCall, instance);\n    contributor.extend(CompletionType.BASIC, inLabel, instance);\n\n    contributor.extend(CompletionType.SMART, inArgumentListOfCall, instance);\n    contributor.extend(CompletionType.SMART, inLabel, instance);\n  }","id":51346,"modified_method":"public static void register(CompletionContributor contributor) {\n    MapArgumentCompletionProvider instance = new MapArgumentCompletionProvider();\n\n    ElementPattern<PsiElement> inArgumentListOfCall = psiElement().withParent(psiElement(GrReferenceExpression.class).withParent(\n      StandardPatterns.or(psiElement(GrArgumentList.class), psiElement(GrListOrMap.class)))\n    );\n\n    ElementPattern<PsiElement> inLabel = psiElement(GroovyTokenTypes.mIDENT).withParent(GrArgumentLabel.class);\n\n    contributor.extend(CompletionType.BASIC, inArgumentListOfCall, instance);\n    contributor.extend(CompletionType.BASIC, inLabel, instance);\n\n    contributor.extend(CompletionType.SMART, inArgumentListOfCall, instance);\n    contributor.extend(CompletionType.SMART, inLabel, instance);\n  }","commit_id":"8fb554f2da94976e8303c2bee4325e34348b484e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters,\n                                ProcessingContext context,\n                                @NotNull CompletionResultSet result) {\n    PsiElement mapOrArgumentList;\n\n    PsiElement parent = parameters.getPosition().getParent();\n    if (parent instanceof GrReferenceExpression) {\n      if (((GrReferenceExpression)parent).getQualifier() != null) return;\n      mapOrArgumentList = parent.getParent();\n    }\n    else {\n      mapOrArgumentList = parent.getParent().getParent();\n    }\n\n    PsiElement argumentList = mapOrArgumentList instanceof GrArgumentList ? mapOrArgumentList : mapOrArgumentList.getParent();\n\n    final GrCall call = (GrCall)argumentList.getParent();\n\n    Map<String, GroovyNamedArgumentProvider.ArgumentDescriptor> map =\n      GroovyNamedArgumentProvider.getNamedArgumentsFromAllProviders(call, null, true);\n\n    for (GrNamedArgument argument : PsiUtil.getFirstMapNamedArguments(call)) {\n      map.remove(argument.getLabelName());\n    }\n\n    for (Map.Entry<String, GroovyNamedArgumentProvider.ArgumentDescriptor> entry : map.entrySet()) {\n      LookupElement lookup = LookupElementBuilder.create(entry.getValue(), entry.getKey())\n        .setIcon(GroovyIcons.DYNAMIC)\n        .setInsertHandler(NamedArgumentInsertHandler.INSTANCE)\n        .setTailText(\":\");\n\n      result.addElement(lookup);\n    }\n  }","id":51347,"modified_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters,\n                                ProcessingContext context,\n                                @NotNull CompletionResultSet result) {\n    PsiElement mapOrArgumentList;\n\n    PsiElement parent = parameters.getPosition().getParent();\n    if (parent instanceof GrReferenceExpression) {\n      if (((GrReferenceExpression)parent).getQualifier() != null) return;\n      mapOrArgumentList = parent.getParent();\n    }\n    else {\n      mapOrArgumentList = parent.getParent().getParent();\n    }\n\n    if (mapOrArgumentList instanceof GrListOrMap) {\n      if (((GrListOrMap)mapOrArgumentList).getNamedArguments().length > 0) {\n        result.stopHere();\n      }\n    }\n\n    Map<String, GroovyNamedArgumentProvider.ArgumentDescriptor> map = calcNamedArgumentsForCall(mapOrArgumentList);\n    if (map.isEmpty()) {\n      map = findOtherNamedArgumentsInFile(mapOrArgumentList);\n    }\n    \n    for (GrNamedArgument argument : getSiblingNamedArguments(mapOrArgumentList)) {\n      map.remove(argument.getLabelName());\n    }\n\n    for (Map.Entry<String, GroovyNamedArgumentProvider.ArgumentDescriptor> entry : map.entrySet()) {\n      LookupElement lookup = LookupElementBuilder.create(entry.getValue(), entry.getKey())\n        .setIcon(GroovyIcons.DYNAMIC)\n        .setInsertHandler(NamedArgumentInsertHandler.INSTANCE)\n        .setTailText(\":\");\n\n      result.addElement(lookup);\n    }\n\n  }","commit_id":"8fb554f2da94976e8303c2bee4325e34348b484e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyCompletionContributor() {\n    extend(CompletionType.BASIC, psiElement(PsiElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        final PsiElement reference = position.getParent();\n        if (reference instanceof GrReferenceElement) {\n          final int invocationCount = parameters.getInvocationCount();\n          final boolean secondCompletionInvoked =\n            CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION ? invocationCount > 0 : invocationCount > 1;\n\n          final String prefix = result.getPrefixMatcher().getPrefix();\n          final boolean skipAccessors = !secondCompletionInvoked && !prefix.startsWith(GET_PREFIX) &&\n                                        !prefix.startsWith(SET_PREFIX) &&\n                                        !prefix.startsWith(IS_PREFIX);\n\n\n          result.restartCompletionOnPrefixChange(GET_PREFIX);\n          result.restartCompletionOnPrefixChange(SET_PREFIX);\n          result.restartCompletionOnPrefixChange(IS_PREFIX);\n          final Map<PsiModifierListOwner, LookupElement> staticMembers = hashMap();\n          ((GrReferenceElement)reference).processVariants(new Consumer<Object>() {\n            public void consume(Object element) {\n              final LookupElement lookupElement = element instanceof PsiClass\n                                                  ? GroovyCompletionUtil.createClassLookupItem((PsiClass)element)\n                                                  : GroovyCompletionUtil.getLookupElement(element);\n              Object object = lookupElement.getObject();\n              PsiSubstitutor substitutor = null;\n              if (object instanceof GroovyResolveResult) {\n                substitutor = ((GroovyResolveResult)object).getSubstitutor();\n                object = ((GroovyResolveResult)object).getElement();\n              }\n\n\n              //skip default groovy methods\n              if (!secondCompletionInvoked &&\n                  object instanceof GrGdkMethod &&\n                  GroovyCompletionUtil.skipDefGroovyMethod((GrGdkMethod)object, substitutor)) {\n                showInfo();\n                return;\n              }\n\n              //skip operator methods\n              if (!secondCompletionInvoked &&\n                  object instanceof PsiMethod &&\n                  GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(((PsiMethod)object).getName())) {\n                showInfo();\n                return;\n              }\n\n              //skip accessors if there is no get, set, is prefix\n              if (skipAccessors && object instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyAccessor((PsiMethod)object)) {\n                showInfo();\n                return;\n              }\n\n              if ((object instanceof PsiMethod || object instanceof PsiField) &&\n                  ((PsiModifierListOwner)object).hasModifierProperty(PsiModifier.STATIC)) {\n                if (lookupElement.getLookupString().equals(((PsiMember)object).getName())) {\n                  staticMembers.put((PsiModifierListOwner)object, lookupElement);\n                  return;\n                }\n              }\n              result.addElement(lookupElement);\n            }\n          });\n\n          if (((GrReferenceElement)reference).getQualifier() == null) {\n            completeStaticMembers(position).processMembersOfRegisteredClasses(null, new PairConsumer<PsiMember, PsiClass>() {\n              @Override\n              public void consume(PsiMember member, PsiClass psiClass) {\n                if (member instanceof GrAccessorMethod) {\n                  member = ((GrAccessorMethod)member).getProperty();\n                }\n                final String name = member.getName();\n                if (name == null || !result.getPrefixMatcher().prefixMatches(name)) {\n                  staticMembers.remove(member);\n                  return;\n                }\n                staticMembers.put(member, new JavaGlobalMemberLookupElement(member, psiClass, QUALIFIED_METHOD_INSERT_HANDLER, STATIC_IMPORT_INSERT_HANDLER, true));\n              }\n            });\n          }\n          result.addAllElements(staticMembers.values());\n        }\n      }\n    });\n\n    //provide 'this' and 'super' completions in ClassName.<caret>\n    extend(CompletionType.BASIC, AFTER_DOT, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n\n        assert position.getParent() instanceof GrReferenceExpression;\n        final GrReferenceExpression refExpr = ((GrReferenceExpression)position.getParent());\n        final GrExpression qualifier = refExpr.getQualifierExpression();\n        if (!(qualifier instanceof GrReferenceExpression)) return;\n\n        GrReferenceExpression referenceExpression = (GrReferenceExpression)qualifier;\n        final PsiElement resolved = referenceExpression.resolve();\n        if (!(resolved instanceof PsiClass)) return;\n        if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, position, false)) return;\n\n        for (String keyword : THIS_SUPER) {\n          result.addElement(LookupElementBuilder.create(keyword));\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, TYPE_IN_VARIABLE_DECLARATION_AFTER_MODIFIER, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (!GroovyCompletionUtil.isFirstElementAfterModifiersInVariableDeclaration(position, true)) return;\n\n        ResolverProcessor processor = CompletionProcessor.createClassCompletionProcessor(position);\n        ResolveUtil.treeWalkUp((GrVariable)position.getParent(), processor, false);\n        for (Object variant : GroovyCompletionUtil.getCompletionVariants(processor.getCandidates())) {\n\n          if (variant instanceof LookupElement) {\n            result.addElement((LookupElement)variant);\n            continue;\n          }\n\n          final String lookupString = variant.toString();\n          if (lookupString == null) continue;\n\n          LookupElementBuilder builder = LookupElementBuilder.create(variant, lookupString);\n          if (variant instanceof Iconable) {\n            builder = builder.setIcon(((Iconable)variant).getIcon(Iconable.ICON_FLAG_VISIBILITY));\n          }\n\n          builder.setInsertHandler(GroovyInsertHandler.INSTANCE);\n          result.addElement(builder);\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, IN_ARGUMENT_LIST_OF_CALL, MAP_ARGUMENT_COMPLETION_PROVIDER);\n    extend(CompletionType.BASIC, IN_MAP_KEY_ARGUMENT_LIST_OF_CALL, MAP_ARGUMENT_COMPLETION_PROVIDER);\n\n    // class name stuff\n\n    extend(CompletionType.CLASS_NAME, psiElement().withParent(GrReferenceElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (((GrReferenceElement)position.getParent()).getQualifier() != null) return;\n\n        final String s = result.getPrefixMatcher().getPrefix();\n        if (StringUtil.isEmpty(s) || !Character.isLowerCase(s.charAt(0))) return;\n\n        completeStaticMembers(position).processStaticMethodsGlobally(result);\n      }\n    });\n\n\n    final CompletionProvider<CompletionParameters> classNameProvider = new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        result.stopHere();\n        AllClassesGetter\n          .processJavaClasses(parameters, result.getPrefixMatcher(), parameters.getInvocationCount() <= 1, new Consumer<PsiClass>() {\n            @Override\n            public void consume(PsiClass psiClass) {\n              result.addElement(GroovyCompletionUtil.createClassLookupItem(psiClass));\n            }\n          });\n      }\n    };\n    extend(CompletionType.CLASS_NAME, psiElement(), classNameProvider);\n\n    extend(CompletionType.BASIC, psiElement().withParent(GrReferenceElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (((GrReferenceElement)position.getParent()).getQualifier() != null) return;\n\n        final String s = result.getPrefixMatcher().getPrefix();\n        if (StringUtil.isEmpty(s) || !Character.isUpperCase(s.charAt(0))) return;\n\n        classNameProvider.addCompletionVariants(parameters, context, result);\n      }\n    });\n  }","id":51348,"modified_method":"public GroovyCompletionContributor() {\n    extend(CompletionType.BASIC, psiElement(PsiElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement reference = parameters.getPosition().getParent();\n        if (reference instanceof GrReferenceElement) {\n          completeReference(parameters, result, (GrReferenceElement)reference);\n        }\n      }\n    });\n\n    //provide 'this' and 'super' completions in ClassName.<caret>\n    extend(CompletionType.BASIC, AFTER_DOT, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n\n        assert position.getParent() instanceof GrReferenceExpression;\n        final GrReferenceExpression refExpr = ((GrReferenceExpression)position.getParent());\n        final GrExpression qualifier = refExpr.getQualifierExpression();\n        if (!(qualifier instanceof GrReferenceExpression)) return;\n\n        GrReferenceExpression referenceExpression = (GrReferenceExpression)qualifier;\n        final PsiElement resolved = referenceExpression.resolve();\n        if (!(resolved instanceof PsiClass)) return;\n        if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, position, false)) return;\n\n        for (String keyword : THIS_SUPER) {\n          result.addElement(LookupElementBuilder.create(keyword));\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, TYPE_IN_VARIABLE_DECLARATION_AFTER_MODIFIER, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (!GroovyCompletionUtil.isFirstElementAfterModifiersInVariableDeclaration(position, true)) return;\n\n        ResolverProcessor processor = CompletionProcessor.createClassCompletionProcessor(position);\n        ResolveUtil.treeWalkUp((GrVariable)position.getParent(), processor, false);\n        for (Object variant : GroovyCompletionUtil.getCompletionVariants(processor.getCandidates())) {\n\n          if (variant instanceof LookupElement) {\n            result.addElement((LookupElement)variant);\n            continue;\n          }\n\n          final String lookupString = variant.toString();\n          if (lookupString == null) continue;\n\n          LookupElementBuilder builder = LookupElementBuilder.create(variant, lookupString);\n          if (variant instanceof Iconable) {\n            builder = builder.setIcon(((Iconable)variant).getIcon(Iconable.ICON_FLAG_VISIBILITY));\n          }\n\n          builder.setInsertHandler(GroovyInsertHandler.INSTANCE);\n          result.addElement(builder);\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, IN_ARGUMENT_LIST_OF_CALL, MAP_ARGUMENT_COMPLETION_PROVIDER);\n    extend(CompletionType.BASIC, IN_MAP_KEY_ARGUMENT_LIST_OF_CALL, MAP_ARGUMENT_COMPLETION_PROVIDER);\n\n    // class name stuff\n\n    extend(CompletionType.CLASS_NAME, psiElement().withParent(GrReferenceElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (((GrReferenceElement)position.getParent()).getQualifier() != null) return;\n\n        final String s = result.getPrefixMatcher().getPrefix();\n        if (StringUtil.isEmpty(s) || !Character.isLowerCase(s.charAt(0))) return;\n\n        completeStaticMembers(position).processStaticMethodsGlobally(result);\n      }\n    });\n\n\n    extend(CompletionType.CLASS_NAME, psiElement(), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        addAllClasses(parameters, result);\n      }\n    });\n\n  }","commit_id":"77146706ca556a4addfca528b6002114853eef9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isPossibleClosureParameter(GrReferenceExpression ref) {\n    return psiElement().withParent(GrClosableBlock.class).afterLeaf(\"{\").accepts(ref) || GroovyCompletionContributor.isInPossibleClosureParameter(ref);\n  }","id":51349,"modified_method":"private static boolean isPossibleClosureParameter(GrReferenceExpression ref) {\n    return psiElement().afterLeaf(CLOSURE_LBRACE).accepts(ref) ||\n           psiElement().afterLeaf(\n             psiElement().afterLeaf(\",\").withParent(\n               psiElement(GrVariable.class).withParent(\n                 psiElement(GrVariableDeclaration.class).afterLeaf(CLOSURE_LBRACE)))).accepts(ref) ||\n           GroovyCompletionContributor.isInPossibleClosureParameter(ref);\n  }","commit_id":"7b01e4abba98ea24c8d774e62cf52da4107232b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Booking(long bookingTypeId, long customerId) {\n\n\t\tCalendar today = GregorianCalendar.getInstance();\n\t\tCalendar weekFromToday = (Calendar)today.clone();\n\t\tweekFromToday.add(Calendar.DATE, 7);\n\n\t\tDate todayDate = new Date(today.getTimeInMillis());\n\t\tDate weekFromTodayDate = new Date(weekFromToday.getTimeInMillis());\n\t\t\n\t\t_bookingTypeId = bookingTypeId;\n\t\t_customerId = customerId;\n\t\t_startDate = todayDate;\n\t\t_finishDate = weekFromTodayDate;\n\t}","id":51350,"modified_method":"public Booking(long bookingTypeId, long customerId) {\n\t\tCalendar today = GregorianCalendar.getInstance();\n\n\t\tCalendar weekFromToday = (Calendar)today.clone();\n\n\t\tweekFromToday.add(Calendar.DATE, 7);\n\n\t\t_bookingTypeId = bookingTypeId;\n\t\t_customerId = customerId;\n\t\t_startDate = new Date(today.getTimeInMillis());\n\t\t_finishDate = new Date(weekFromToday.getTimeInMillis());\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Booking> getBookingsByCustomerId(long customerId) {\n\n\t\tArrayList<Booking> bookings = new ArrayList<Booking>();\n\n\t\tfor (Booking booking: getAllBookings()) {\n\t\t\tif (booking.getCustomerId() == customerId) {\n\t\t\t\tbookings.add(booking);\n\t\t\t}\n\t\t}\n\t\treturn bookings;\n\t}","id":51351,"modified_method":"public List<Booking> getBookingsByCustomerId(long customerId) {\n\t\tList<Booking> bookings = new ArrayList<Booking>();\n\n\t\tfor (Booking booking : getAllBookings()) {\n\t\t\tif (booking.getCustomerId() == customerId) {\n\t\t\t\tbookings.add(booking);\n\t\t\t}\n\t\t}\n\n\t\treturn bookings;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setBookingTypeId(long bookingTypeId) {\n\t\tthis._bookingTypeId = bookingTypeId;\n\t}","id":51352,"modified_method":"public void setBookingTypeId(long bookingTypeId) {\n\t\t_bookingTypeId = bookingTypeId;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setBookingTypeName(String bookingTypeName) {\n\t\tthis._bookingTypeName = bookingTypeName;\n\t}","id":51353,"modified_method":"public void setBookingTypeName(String bookingTypeName) {\n\t\t_bookingTypeName = bookingTypeName;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<BookingType> getAllBookingTypes() {\n\n\t\tif (_allBookingTypes == null) {\n\t\t\t_allBookingTypes = new ArrayList<BookingType>();\n\n\t\t\tBookingType bookingType = new BookingType(\n\t\t\t\t\tTYPE_ID_AIRFARE, \"Airfare\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_CRUISE, \"Cruise\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_HOTEL, \"Hotel\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_PLAY, \"Play/Theatre\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_RENTAL_CAR, \"Rental Car\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_THEME_PARK, \"Theme Park\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t\tbookingType = new BookingType(TYPE_ID_TRAIN, \"Train\");\n\t\t\t_allBookingTypes.add(bookingType);\n\t\t}\n\n\t\treturn _allBookingTypes;\n\t}","id":51354,"modified_method":"public List<BookingType> getAllBookingTypes() {\n\t\tif (_allBookingTypes == null) {\n\t\t\t_allBookingTypes = new ArrayList<BookingType>();\n\n\t\t\t_allBookingTypes.add(new BookingType(TYPE_ID_AIRFARE, \"Airfare\"));\n\t\t\t_allBookingTypes.add(new BookingType(TYPE_ID_CRUISE, \"Cruise\"));\n\t\t\t_allBookingTypes.add(new BookingType(TYPE_ID_HOTEL, \"Hotel\"));\n\t\t\t_allBookingTypes.add(new BookingType(TYPE_ID_PLAY, \"Play/Theatre\"));\n\t\t\t_allBookingTypes.add(\n\t\t\t\tnew BookingType(TYPE_ID_RENTAL_CAR, \"Rental Car\"));\n\t\t\t_allBookingTypes.add(\n\t\t\t\tnew BookingType(TYPE_ID_THEME_PARK, \"Theme Park\"));\n\t\t\t_allBookingTypes.add(new BookingType(TYPE_ID_TRAIN, \"Train\"));\n\t\t}\n\n\t\treturn _allBookingTypes;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void selectionListener(RowSelectorEvent rowSelectorEvent) {\n\n\t\tCustomerListModel customerListModel = getCustomerListModel();\n\n\t\tint rowIndex = rowSelectorEvent.getRow();\n\t\tCustomer customer = customerListModel.getAllCustomers().get(rowIndex);\n\t\tcustomerListModel.setSelected(customer);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"rowIndex=\" + rowSelectorEvent.getRow() + \" customerId=\" +\n\t\t\t\tcustomer.getCustomerId() + \" firstName=\" +\n\t\t\t\tcustomer.getFirstName() + \" lastName=\" +\n\t\t\t\tcustomer.getLastName());\n\t\t}\n\t}","id":51355,"modified_method":"public void selectionListener(RowSelectorEvent rowSelectorEvent) {\n\t\tCustomer customer = _customerListModel.getAllCustomers().get(\n\t\t\trowSelectorEvent.getRow());\n\n\t\t_customerListModel.setSelected(customer);\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Customer getSelected() {\n\t\treturn (Customer)PortletSessionUtil.getSharedSessionAttribute(\n\t\t\t\tPortletSessionUtil.ATTR_SELECTED_CUSTOMER);\n\t}","id":51356,"modified_method":"public Customer getSelected() {\n\t\treturn (Customer)PortletSessionUtil.getSharedSessionAttribute(\n\t\t\tPortletSessionUtil.SELECTED_CUSTOMER);\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void valueChangeListener(ValueChangeEvent valueChangeEvent) {\n\t\tgetRenderManager().getOnDemandRenderer(RENDER_GROUP).requestRender();\n\t}","id":51357,"modified_method":"public void valueChangeListener(ValueChangeEvent valueChangeEvent) {\n\t\tOnDemandRenderer onDemandRenderer =\n\t\t\tgetRenderManager().getOnDemandRenderer(CUSTOMER_RENDER_GROUP);\n\n\t\tonDemandRenderer.requestRender();\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tpublic List<Customer> getAllCustomers() {\n\n\t\tList<Customer> allCustomers = (List<Customer>)PortletSessionUtil\n\t\t\t.getSharedSessionAttribute(PortletSessionUtil.ATTR_CUSTOMER_LIST);\n\n\t\tif (allCustomers == null) {\n\t\t\tallCustomers = getCustomerService().getAllCustomers();\n\t\t\tPortletSessionUtil.setSharedSessionAttribute(\n\t\t\t\tPortletSessionUtil.ATTR_CUSTOMER_LIST, allCustomers);\n\t\t}\n\n\t\treturn allCustomers;\n\t}","id":51358,"modified_method":"public List<Customer> getAllCustomers() {\n\t\tList<Customer> allCustomers =\n\t\t\t(List<Customer>)PortletSessionUtil.getSharedSessionAttribute(\n\t\t\t\tPortletSessionUtil.CUSTOMER_LIST);\n\n\t\tif (allCustomers == null) {\n\t\t\tallCustomers = _customerService.getAllCustomers();\n\n\t\t\tPortletSessionUtil.setSharedSessionAttribute(\n\t\t\t\tPortletSessionUtil.CUSTOMER_LIST, allCustomers);\n\t\t}\n\n\t\treturn allCustomers;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setRenderManager(RenderManager renderManager) {\n\t\t_renderManager = renderManager;\n\t\t_renderManager.getOnDemandRenderer(RENDER_GROUP).add(this);\n\t}","id":51359,"modified_method":"public void setRenderManager(RenderManager renderManager) {\n\t\t_renderManager = renderManager;\n\n\t\tOnDemandRenderer onDemandRenderer =\n\t\t\tgetRenderManager().getOnDemandRenderer(CUSTOMER_RENDER_GROUP);\n\n\t\tonDemandRenderer.add(this);\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setSelected(Customer customer) {\n\n\t\tPortletSessionUtil.setSharedSessionAttribute(\n\t\t\tPortletSessionUtil.ATTR_SELECTED_CUSTOMER, customer);\n\n\t\t// Use ICEfaces Ajax-Push to force the Bookings portlet to re-render\n\t\t// the bookings according to the newly selected user.\n\t\tgetRenderManager().getOnDemandRenderer(RENDER_GROUP).requestRender();\n\t}","id":51360,"modified_method":"public void setSelected(Customer customer) {\n\t\tPortletSessionUtil.setSharedSessionAttribute(\n\t\t\tPortletSessionUtil.SELECTED_CUSTOMER, customer);\n\n\t\tOnDemandRenderer onDemandRenderer =\n\t\t\tgetRenderManager().getOnDemandRenderer(CUSTOMER_RENDER_GROUP);\n\n\t\tonDemandRenderer.requestRender();\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void dispose() throws Exception {\n\n\t\t// http://jira.icefaces.org/browse/ICE-2896\n\t\t// http://jira.icefaces.org/browse/ICE-2904\n\t\tgetRenderManager().getOnDemandRenderer(RENDER_GROUP).remove(this);\n\t}","id":51361,"modified_method":"public void dispose() throws Exception {\n\n\t\t// http://jira.icefaces.org/browse/ICE-2896\n\t\t// http://jira.icefaces.org/browse/ICE-2904\n\n\t\tOnDemandRenderer onDemandRenderer =\n\t\t\tgetRenderManager().getOnDemandRenderer(CUSTOMER_RENDER_GROUP);\n\n\t\tonDemandRenderer.remove(this);\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Customer> getAllCustomers() {\n\n\t\tif (_allCustomers == null) {\n\n\t\t\t_allCustomers = new ArrayList<Customer>();\n\n\t\t\tBookingService bookingService = getBookingService();\n\n\t\t\tCustomer customer = null;\n\t\t\tcustomer = new Customer(ID_BRIAN_GREEN, \"Brian\", \"Green\");\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_BRIAN_GREEN));\n\t\t\t_allCustomers.add(customer);\n\t\t\tcustomer = new Customer(ID_LIZ_KESSLER, \"Liz\", \"Kessler\");\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_LIZ_KESSLER));\n\t\t\t_allCustomers.add(customer);\n\t\t\tcustomer = new Customer(ID_RICH_SHEARER, \"Rich\", \"Shearer\");\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_RICH_SHEARER));\n\t\t\t_allCustomers.add(customer);\n\t\t}\n\n\t\treturn _allCustomers;\n\t}","id":51362,"modified_method":"public List<Customer> getAllCustomers() {\n\t\tif (_allCustomers == null) {\n\t\t\t_allCustomers = new ArrayList<Customer>();\n\n\t\t\tBookingService bookingService = getBookingService();\n\n\t\t\tCustomer customer = new Customer(ID_BRIAN_GREEN, \"Brian\", \"Green\");\n\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_BRIAN_GREEN));\n\n\t\t\t_allCustomers.add(customer);\n\n\t\t\tcustomer = new Customer(ID_LIZ_KESSLER, \"Liz\", \"Kessler\");\n\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_LIZ_KESSLER));\n\n\t\t\t_allCustomers.add(customer);\n\n\t\t\tcustomer = new Customer(ID_RICH_SHEARER, \"Rich\", \"Shearer\");\n\n\t\t\tcustomer.setBookings(\n\t\t\t\tbookingService.getBookingsByCustomerId(ID_RICH_SHEARER));\n\n\t\t\t_allCustomers.add(customer);\n\t\t}\n\n\t\treturn _allCustomers;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<SelectItem> getSelectItems() {\n\n\t\tif (_selectItems == null) {\n\t\t\t_selectItems = new ArrayList<SelectItem>();\n\n\t\t\tfor (\n\t\t\t\tBookingType bookingType :\n\t\t\t\tgetBookingTypeService().getAllBookingTypes()) {\n\t\t\t\t_selectItems.add(\n\t\t\t\t\tnew SelectItem(\n\t\t\t\t\t\tbookingType.getBookingTypeId(),\n\t\t\t\t\t\tbookingType.getBookingTypeName()));\n\t\t\t}\n\t\t}\n\n\t\treturn _selectItems;\n\t}","id":51363,"modified_method":"public List<SelectItem> getSelectItems() {\n\t\tif (_selectItems == null) {\n\t\t\t_selectItems = new ArrayList<SelectItem>();\n\n\t\t\tList<BookingType> bookingTypes =\n\t\t\t\t_bookingTypeService.getAllBookingTypes();\n\n\t\t\tfor (BookingType bookingType : bookingTypes) {\n\t\t\t\t_selectItems.add(\n\t\t\t\t\tnew SelectItem(\n\t\t\t\t\t\tbookingType.getBookingTypeId(),\n\t\t\t\t\t\tbookingType.getBookingTypeName()));\n\t\t\t}\n\t\t}\n\n\t\treturn _selectItems;\n\t}","commit_id":"45362ec88d88f6f10c2d1c9ad85fb056f8220be6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Load the image in a background thread.\n     *\n     * This method returns immediately and runs the image request asynchronously.\n     *\n     * @return the future of the requested image\n     * @since 10714\n     */\n    public CompletableFuture<ImageIcon> getAsync() {\n        return CompletableFuture.supplyAsync(this::get, IMAGE_FETCHER);\n    }","id":51364,"modified_method":"/**\n     * Load the image in a background thread.\n     *\n     * This method returns immediately and runs the image request asynchronously.\n     *\n     * @return the future of the requested image\n     * @since 10714\n     */\n    public CompletableFuture<ImageIcon> getAsync() {\n        return name.startsWith(HTTP_PROTOCOL) || name.startsWith(WIKI_PROTOCOL)\n                ? CompletableFuture.supplyAsync(this::get, IMAGE_FETCHER)\n                : CompletableFuture.completedFuture(get());\n    }","commit_id":"f6748b8a5acd76c3764abc0be8e2c8e25f0d391f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Load the image in a background thread.\n     *\n     * This method returns immediately and runs the image request asynchronously.\n     *\n     * @return the future of the requested image\n     * @since 10714\n     */\n     public CompletableFuture<ImageResource> getResourceAsync() {\n        return CompletableFuture.supplyAsync(this::getResource, IMAGE_FETCHER);\n    }","id":51365,"modified_method":"/**\n     * Load the image in a background thread.\n     *\n     * This method returns immediately and runs the image request asynchronously.\n     *\n     * @return the future of the requested image\n     * @since 10714\n     */\n    public CompletableFuture<ImageResource> getResourceAsync() {\n        return name.startsWith(HTTP_PROTOCOL) || name.startsWith(WIKI_PROTOCOL)\n                ? CompletableFuture.supplyAsync(this::getResource, IMAGE_FETCHER)\n                : CompletableFuture.completedFuture(getResource());\n    }","commit_id":"f6748b8a5acd76c3764abc0be8e2c8e25f0d391f","url":"https://github.com/openstreetmap/josm"},{"original_method":"public <V extends Object> CompletableFuture<V> runRead(final Function1<? super CancelIndicator, ? extends V> readRequest, final CancelIndicator cancelIndicator) {\n    final Supplier<V> _function = () -> {\n      return this.<V>run(readRequest, 1, cancelIndicator);\n    };\n    return CompletableFuture.<V>supplyAsync(_function, this.readExecutorService);\n  }","id":51366,"modified_method":"/**\n   * <p>\n   * The given <i>read request<\/i> will be ran:\n   * <ul>\n   * \t<li>concurrent with <i>running read requests<\/i>;<\/li>\n   * \t<li>first when <i>running write requests<\/i> completed.<\/li>\n   * <\/ul>\n   * <\/p>\n   * <p>\n   * A provided cancel indicator should implement {@link org.eclipse.xtext.ide.server.concurrent.CancellableIndicator CancellableIndicator}\n   * to let the given request to be cancelled by a write request.\n   * <\/p>\n   */\n  public <V extends Object> CompletableFuture<V> runRead(final Function1<? super CancelIndicator, ? extends V> readRequest, final CancelIndicator cancelIndicator) {\n    if ((cancelIndicator instanceof CancellableIndicator)) {\n      this.cancelIndicators.add(((CancellableIndicator)cancelIndicator));\n    }\n    final Supplier<V> _function = () -> {\n      try {\n        this.semaphore.acquire(1);\n        try {\n          return readRequest.apply(cancelIndicator);\n        } finally {\n          this.semaphore.release(1);\n        }\n      } catch (Throwable _e) {\n        throw Exceptions.sneakyThrow(_e);\n      }\n    };\n    CompletableFuture<V> _supplyAsync = CompletableFuture.<V>supplyAsync(_function, this.readExecutorService);\n    final BiConsumer<V, Throwable> _function_1 = (V $0, Throwable $1) -> {\n      if ((cancelIndicator instanceof CancellableIndicator)) {\n        this.cancelIndicators.remove(((CancellableIndicator)cancelIndicator));\n      }\n    };\n    return _supplyAsync.whenComplete(_function_1);\n  }","commit_id":"c7a28b527fe2a76c331c83a94baeaaa7ddc020bc","url":"https://github.com/eclipse/xtext"},{"original_method":"public CompletableFuture<Void> runWrite(final Procedure1<? super CancelIndicator> writeRequest, final CancelIndicator cancelIndicator) {\n    final Consumer<CancellableIndicator> _function = (CancellableIndicator it) -> {\n      it.cancel();\n    };\n    this.cancelIndicators.forEach(_function);\n    final Runnable _function_1 = () -> {\n      Function1<? super CancelIndicator, ? extends Void> _withVoidAsReturnType = this.withVoidAsReturnType(writeRequest);\n      this.<Void>run(_withVoidAsReturnType, this.MAX_PERMITS, cancelIndicator);\n    };\n    return CompletableFuture.runAsync(_function_1, this.writeExecutorService);\n  }","id":51367,"modified_method":"/**\n   * <p>\n   * The given <i>write request<\/i> will be ran first when <i>all running requests<\/i> completed.\n   * <\/p>\n   * <p>\n   * Currently <i>running requests<\/i> will be cancelled.\n   * <\/p>\n   * <p>\n   * A provided cancel indicator should implement {@link org.eclipse.xtext.ide.server.concurrent.CancellableIndicator CancellableIndicator}\n   * to let the given request to be cancelled by a write request.\n   * <\/p>\n   */\n  public CompletableFuture<Void> runWrite(final Procedure1<? super CancelIndicator> writeRequest, final CancelIndicator cancelIndicator) {\n    final Consumer<CancellableIndicator> _function = (CancellableIndicator it) -> {\n      it.cancel();\n    };\n    this.cancelIndicators.forEach(_function);\n    if ((cancelIndicator instanceof CancellableIndicator)) {\n      this.cancelIndicators.add(((CancellableIndicator)cancelIndicator));\n    }\n    final Runnable _function_1 = () -> {\n      try {\n        this.semaphore.acquire(this.MAX_PERMITS);\n        try {\n          writeRequest.apply(cancelIndicator);\n        } finally {\n          this.semaphore.release(this.MAX_PERMITS);\n        }\n      } catch (Throwable _e) {\n        throw Exceptions.sneakyThrow(_e);\n      }\n    };\n    CompletableFuture<Void> _runAsync = CompletableFuture.runAsync(_function_1, this.writeExecutorService);\n    final BiConsumer<Void, Throwable> _function_2 = (Void $0, Throwable $1) -> {\n      if ((cancelIndicator instanceof CancellableIndicator)) {\n        this.cancelIndicators.remove(((CancellableIndicator)cancelIndicator));\n      }\n    };\n    return _runAsync.whenComplete(_function_2);\n  }","commit_id":"c7a28b527fe2a76c331c83a94baeaaa7ddc020bc","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * Copies an expression. Used for inlining functions, or for copying static queries.\n   * It is utilized by {@link VarRef#inline}, {@link FuncItem#inlineExpr},\n   * {@link Closure#inlineExpr} and {@link StaticFunc#inlineExpr}.\n   * @param cc compilation context\n   * @param vm mapping from old variable IDs to new variable copies\n   * @return copied expression\n   */\n  public abstract Expr copy(CompileContext cc, IntObjMap<Var> vm);","id":51368,"modified_method":"/**\n   * Copies an expression. Used for inlining functions, or for copying static queries.\n   * It is utilized by {@link VarRef#inline}, {@link FuncItem#inlineExpr},\n   * {@link Closure#inlineExpr} and {@link StaticFunc#inlineExpr}.\n   * @param cc compilation context\n   * @param vm mapping from old variable IDs to new variable copies.\n   *           Required by {@link Closure#copy} and {@link VarRef#copy}\n   * @return copied expression\n   */\n  public abstract Expr copy(CompileContext cc, IntObjMap<Var> vm);","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public final Expr optimize(final CompileContext cc) throws QueryException {\n    // return empty root\n    if(root.isEmpty()) return optPre(cc);\n\n    // remember current context value (will be temporarily overwritten)\n    final QueryFocus focus = cc.qc.focus;\n    final Value cv = focus.value;\n    try {\n      focus.value = Path.initial(cc, root);\n      final Expr e = super.optimize(cc);\n      if(e != this) return e;\n    } finally {\n      focus.value = cv;\n    }\n\n    // check result size\n    seqType(root.seqType(), root.size());\n    if(size == 0) return optPre(cc);\n\n    // if possible, convert filter to root or path expression\n    final Expr ex = simplify(root, preds);\n    if(ex != null) return ex.optimize(cc);\n\n    // try to rewrite filter to index access\n    if(root instanceof ContextValue || root instanceof Value && root.data() != null) {\n      final Path ip = Path.get(info, root, Step.get(info, SELF, Test.NOD, preds));\n      final Expr ie = ip.index(cc, Path.initial(cc, root));\n      if(ie != ip) return ie;\n    }\n\n    // no numeric predicates.. use simple iterator\n    if(!super.has(Flag.POS)) return copyType(new IterFilter(info, root, preds));\n\n    // evaluate positional predicates\n    Expr e = root;\n    boolean opt = false;\n    for(final Expr pred : preds) {\n      final Pos pos = pred instanceof Pos ? (Pos) pred : null;\n      final boolean last = pred.isFunction(Function.LAST);\n\n      if(last) {\n        if(e.isValue()) {\n          // return sub-sequence\n          e = FnSubsequence.eval((Value) e, e.size(), 1);\n        } else {\n          // rewrite positional predicate to basex:last-from\n          e = cc.function(Function._UTIL_LAST_FROM, info, e);\n        }\n        opt = true;\n      } else if(pos != null) {\n        if(e.isValue()) {\n          // return sub-sequence\n          e = FnSubsequence.eval((Value) e, pos.min, pos.max - pos.min + 1);\n        } else if(pos.min == pos.max) {\n          // example: expr[pos] -> basex:item-at(expr, pos.min)\n          e = cc.function(Function._UTIL_ITEM_AT, info, e, Int.get(pos.min));\n        } else {\n          // example: expr[pos] -> basex:item-range(expr, pos.min, pos.max)\n          e = cc.function(Function._UTIL_ITEM_RANGE, info, e, Int.get(pos.min), Int.get(pos.max));\n        }\n        opt = true;\n      } else if(num(pred)) {\n        /* - rewrite positional predicate to basex:item-at\n         *   example: expr[pos] -> basex:item-at(expr, pos)\n         * - only choose deterministic and context-independent offsets.\n         *   example: (1 to 10)[random:integer(10)]  or  (1 to 10)[.] */\n        e = cc.function(Function._UTIL_ITEM_AT, info, e, pred);\n        opt = true;\n      } else {\n        // rebuild filter if no optimization can be applied\n        e = e instanceof Filter ? ((Filter) e).addPred(pred) : get(info, e, pred);\n      }\n    }\n\n    if(opt) {\n      cc.info(QueryText.OPTREWRITE_X, this);\n      return e.optimize(cc);\n    }\n\n    // standard iterator\n    return get(info, root, preds);\n  }","id":51369,"modified_method":"@Override\n  public final Expr optimize(final CompileContext cc) throws QueryException {\n    // return empty root\n    if(root.isEmpty()) return optPre(cc);\n\n    // remember current context value (will be temporarily overwritten)\n    final QueryFocus focus = cc.qc.focus;\n    final Value cv = focus.value;\n    try {\n      focus.value = Path.initial(cc, root);\n      final Expr e = super.optimize(cc);\n      if(e != this) return e;\n    } finally {\n      focus.value = cv;\n    }\n\n    // check result size\n    seqType(root.seqType(), root.size());\n    if(size == 0) return optPre(cc);\n\n    // if possible, convert filter to root or path expression\n    final Expr ex = simplify(root, preds);\n    if(ex != null) return ex.optimize(cc);\n\n    // try to rewrite filter to index access\n    if(root instanceof ContextValue || root instanceof Value && root.data() != null) {\n      final Path ip = Path.get(info, root, Step.get(info, SELF, Test.NOD, preds));\n      final Expr ie = ip.index(cc, Path.initial(cc, root));\n      if(ie != ip) return ie;\n    }\n\n    // no numeric predicates.. use simple iterator\n    if(!super.has(Flag.POS)) return copyType(new IterFilter(info, root, preds));\n\n    // evaluate positional predicates\n    Expr e = root;\n    boolean opt = false;\n    for(final Expr pred : preds) {\n      final Pos pos = pred instanceof Pos ? (Pos) pred : null;\n      final boolean last = pred.isFunction(Function.LAST);\n\n      if(last) {\n        if(e.isValue()) {\n          // return sub-sequence\n          e = FnSubsequence.eval((Value) e, e.size(), 1);\n        } else {\n          // rewrite positional predicate to basex:last-from\n          e = cc.function(Function._UTIL_LAST_FROM, info, e);\n        }\n        opt = true;\n      } else if(pos != null) {\n        if(e.isValue()) {\n          // return sub-sequence\n          e = FnSubsequence.eval((Value) e, pos.min, pos.max - pos.min + 1);\n        } else if(pos.min == pos.max) {\n          // example: expr[pos] -> basex:item-at(expr, pos.min)\n          e = cc.function(Function._UTIL_ITEM_AT, info, e, Int.get(pos.min));\n        } else {\n          // example: expr[pos] -> basex:item-range(expr, pos.min, pos.max)\n          e = cc.function(Function._UTIL_ITEM_RANGE, info, e, Int.get(pos.min), Int.get(pos.max));\n        }\n        opt = true;\n      } else if(num(pred)) {\n        /* - rewrite positional predicate to basex:item-at\n         *   example: expr[pos] -> basex:item-at(expr, pos)\n         * - only choose deterministic and context-independent offsets.\n         *   example: (1 to 10)[random:integer(10)]  or  (1 to 10)[.] */\n        e = cc.function(Function._UTIL_ITEM_AT, info, e, pred);\n        opt = true;\n      } else {\n        // rebuild filter if no optimization can be applied\n        e = (e instanceof Filter ? ((Filter) e).addPred(pred) : get(info, e, pred)).optimize(cc);\n      }\n    }\n\n    if(opt) {\n      cc.info(QueryText.OPTREWRITE_X, this);\n      return e;\n    }\n\n    // standard iterator\n    return get(info, root, preds);\n  }","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    // static condition: return branch in question\n    cond = cond.optimizeEbv(cc);\n    if(cond.isValue()) return optPre(exprs[branch(cc.qc)], cc);\n\n    // if A then B else B -> B (errors in A will be ignored)\n    if(exprs[0].sameAs(exprs[1])) return optPre(exprs[0], cc);\n\n    // if not(A) then B else C -> if A then C else B\n    if(cond.isFunction(Function.NOT)) {\n      cc.info(OPTREWRITE_X, this);\n      cond = ((Arr) cond).exprs[0];\n      final Expr tmp = exprs[0];\n      exprs[0] = exprs[1];\n      exprs[1] = tmp;\n    }\n\n    // rewritings for constant booleans\n    if(exprs[0].seqType().eq(SeqType.BLN) && exprs[1].seqType().eq(SeqType.BLN)) {\n      final Expr a = cond, b = exprs[0], c = exprs[1];\n      if(b == Bln.TRUE) {\n        if(c == Bln.FALSE) {\n          // if(A) then true() else false() -> xs:boolean(A)\n          cc.info(OPTPRE_X, this);\n          return compBln(a, info, cc.sc());\n        }\n        // if(A) then true() else C -> A or C\n        cc.info(OPTREWRITE_X, this);\n        return new Or(info, a, c).optimize(cc);\n      }\n\n      if(c == Bln.TRUE) {\n        if(b == Bln.FALSE) {\n          // if(A) then false() else true() -> not(A)\n          cc.info(OPTPRE_X, this);\n          return cc.function(Function.NOT, info, a).optimize(cc);\n        }\n        // if(A) then B else true() -> not(A) or B\n        cc.info(OPTREWRITE_X, this);\n        final Expr notA = cc.function(Function.NOT, info, a).optimize(cc);\n        return new Or(info, notA, b).optimize(cc);\n      }\n\n      if(b == Bln.FALSE) {\n        // if(A) then false() else C -> not(A) and C\n        cc.info(OPTREWRITE_X, this);\n        final Expr notA = cc.function(Function.NOT, info, a).optimize(cc);\n        return new And(info, notA, c).optimize(cc);\n      }\n\n      if(c == Bln.FALSE) {\n        // if(A) then B else false() -> A and B\n        cc.info(OPTREWRITE_X, this);\n        return new And(info, a, b).optimize(cc);\n      }\n    }\n\n    seqType = exprs[0].seqType().union(exprs[1].seqType());\n    return this;\n  }","id":51370,"modified_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    // static condition: return branch in question\n    cond = cond.optimizeEbv(cc);\n    if(cond.isValue()) return optPre(exprs[branch(cc.qc)], cc);\n\n    // if A then B else B -> B (errors in A will be ignored)\n    if(exprs[0].sameAs(exprs[1])) return optPre(exprs[0], cc);\n\n    // if not(A) then B else C -> if A then C else B\n    if(cond.isFunction(Function.NOT)) {\n      cc.info(OPTREWRITE_X, this);\n      cond = ((Arr) cond).exprs[0];\n      final Expr tmp = exprs[0];\n      exprs[0] = exprs[1];\n      exprs[1] = tmp;\n    }\n\n    // rewritings for constant booleans\n    if(exprs[0].seqType().eq(SeqType.BLN) && exprs[1].seqType().eq(SeqType.BLN)) {\n      final Expr a = cond, b = exprs[0], c = exprs[1];\n      if(b == Bln.TRUE) {\n        if(c == Bln.FALSE) {\n          // if(A) then true() else false() -> xs:boolean(A)\n          cc.info(OPTPRE_X, this);\n          return compBln(a, info, cc.sc());\n        }\n        // if(A) then true() else C -> A or C\n        cc.info(OPTREWRITE_X, this);\n        return new Or(info, a, c).optimize(cc);\n      }\n\n      if(c == Bln.TRUE) {\n        if(b == Bln.FALSE) {\n          // if(A) then false() else true() -> not(A)\n          cc.info(OPTPRE_X, this);\n          return cc.function(Function.NOT, info, a);\n        }\n        // if(A) then B else true() -> not(A) or B\n        cc.info(OPTREWRITE_X, this);\n        return new Or(info, cc.function(Function.NOT, info, a), b).optimize(cc);\n      }\n\n      if(b == Bln.FALSE) {\n        // if(A) then false() else C -> not(A) and C\n        cc.info(OPTREWRITE_X, this);\n        return new And(info, cc.function(Function.NOT, info, a), c).optimize(cc);\n      }\n\n      if(c == Bln.FALSE) {\n        // if(A) then B else false() -> A and B\n        cc.info(OPTREWRITE_X, this);\n        return new And(info, a, b).optimize(cc);\n      }\n    }\n\n    seqType = exprs[0].seqType().union(exprs[1].seqType());\n    return this;\n  }","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns an expression that is appropriate for inlining.\n   * @param cc compilation context\n   * @return inlineable expression\n   * @throws QueryException query exception\n   */\n  Expr inlineExpr(final CompileContext cc) throws QueryException {\n    return scoring ? cc.function(Function._FT_SCORE, info, expr).optimize(cc) :\n      var.checked(expr, cc);\n  }","id":51371,"modified_method":"/**\n   * Returns an expression that is appropriate for inlining.\n   * @param cc compilation context\n   * @return inlineable expression\n   * @throws QueryException query exception\n   */\n  Expr inlineExpr(final CompileContext cc) throws QueryException {\n    return scoring ? cc.function(Function._FT_SCORE, info, expr) : var.checked(expr, cc);\n  }","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    if(exprs.length != 2) return this;\n\n    final Expr ks = exprs[0], fs = exprs[1];\n    if(ks.isValue() && (fs instanceof Map || fs instanceof Array)) {\n      // guaranteed to be fully evaluated\n      return optPre(value(cc.qc), cc);\n    }\n\n    final Type tp = fs.seqType().type;\n    final boolean map = tp instanceof MapType, array = tp instanceof ArrayType;\n    if(!map && !array) return this;\n\n    final boolean oneInput = fs.size() == 1 || fs.seqType().one();\n    SeqType rt = ((FuncType) tp).type;\n    if(rt != null) {\n      // map lookup may result in empty sequence\n      if(map && !rt.mayBeZero()) rt = rt.withOcc(rt.one() ? Occ.ZERO_ONE : Occ.ZERO_MORE);\n      // wildcard or more than one input\n      if(ks == Str.WC || !oneInput) rt = rt.withOcc(rt.mayBeZero() ? Occ.ZERO_MORE : Occ.ONE_MORE);\n      seqType = rt;\n    }\n\n    if(ks != Str.WC) {\n      if(oneInput) {\n        // one function, rewrite to for-each or function call\n        final Expr opt = ks.size() == 1 || ks.seqType().one()\n            ? new DynFuncCall(info, cc.sc(), fs, ks) : cc.function(Function.FOR_EACH, info, exprs);\n        return optPre(opt, cc).optimize(cc);\n      }\n\n      if(ks.isValue()) {\n        // keys are constant, so we do not duplicate work in the inner loop\n        final LinkedList<Clause> clauses = new LinkedList<>();\n        final Var f = cc.vs().addNew(new QNm(\"f\"), null, false, cc.qc, info);\n        clauses.add(new For(f, null, null, fs, false));\n        final Var k = cc.vs().addNew(new QNm(\"k\"), null, false, cc.qc, info);\n        clauses.add(new For(k, null, null, ks, false));\n        final VarRef rf = new VarRef(info, f), rk = new VarRef(info, k);\n        final DynFuncCall ret = new DynFuncCall(info, cc.sc(), rf, rk);\n        return optPre(new GFLWOR(info, clauses, ret), cc).optimize(cc);\n      }\n    }\n\n    return this;\n  }","id":51372,"modified_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    if(exprs.length != 2) return this;\n\n    final Expr ks = exprs[0], fs = exprs[1];\n    if(ks.isValue() && (fs instanceof Map || fs instanceof Array)) {\n      // guaranteed to be fully evaluated\n      return optPre(value(cc.qc), cc);\n    }\n\n    final Type tp = fs.seqType().type;\n    final boolean map = tp instanceof MapType, array = tp instanceof ArrayType;\n    if(!map && !array) return this;\n\n    final boolean oneInput = fs.size() == 1 || fs.seqType().one();\n    SeqType rt = ((FuncType) tp).type;\n    if(rt != null) {\n      // map lookup may result in empty sequence\n      if(map && !rt.mayBeZero()) rt = rt.withOcc(rt.one() ? Occ.ZERO_ONE : Occ.ZERO_MORE);\n      // wildcard or more than one input\n      if(ks == Str.WC || !oneInput) rt = rt.withOcc(rt.mayBeZero() ? Occ.ZERO_MORE : Occ.ONE_MORE);\n      seqType = rt;\n    }\n\n    if(ks != Str.WC) {\n      if(oneInput) {\n        // one function, rewrite to for-each or function call\n        final Expr opt = ks.size() == 1 || ks.seqType().one()\n            ? new DynFuncCall(info, cc.sc(), fs, ks).optimize(cc)\n            : cc.function(Function.FOR_EACH, info, exprs);\n        return optPre(opt, cc);\n      }\n\n      if(ks.isValue()) {\n        // keys are constant, so we do not duplicate work in the inner loop\n        final LinkedList<Clause> clauses = new LinkedList<>();\n        final Var f = cc.vs().addNew(new QNm(\"f\"), null, false, cc.qc, info);\n        clauses.add(new For(f, null, null, fs, false));\n        final Var k = cc.vs().addNew(new QNm(\"k\"), null, false, cc.qc, info);\n        clauses.add(new For(k, null, null, ks, false));\n        final VarRef rf = new VarRef(info, f), rk = new VarRef(info, k);\n        final DynFuncCall ret = new DynFuncCall(info, cc.sc(), rf, rk);\n        return optPre(new GFLWOR(info, clauses, ret), cc).optimize(cc);\n      }\n    }\n\n    return this;\n  }","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    final Expr c = super.optimize(cc);\n    if(c != this) return c;\n\n    final int es = exprs.length;\n    final ExprList list = new ExprList(es);\n    for(int i = 0; i < es; i++) {\n      Expr e = exprs[i];\n      if(e instanceof CmpG) {\n        // merge adjacent comparisons\n        while(i + 1 < es && exprs[i + 1] instanceof CmpG) {\n          final Expr tmp = ((CmpG) e).union((CmpG) exprs[i + 1], cc);\n          if(tmp != null) {\n            e = tmp;\n            i++;\n          } else {\n            break;\n          }\n        }\n      }\n      // expression will always return true\n      if(e == Bln.TRUE) return optPre(Bln.TRUE, cc);\n      // skip expression yielding false\n      if(e != Bln.FALSE) list.add(e);\n    }\n\n    // all arguments return false\n    if(list.isEmpty()) return optPre(Bln.FALSE, cc);\n\n    if(es != list.size()) {\n      cc.info(OPTREWRITE_X, this);\n      exprs = list.finish();\n    }\n    compFlatten(cc);\n\n    boolean not = true;\n    for(final Expr expr : exprs) {\n      if(!expr.isFunction(Function.NOT)) {\n        not = false;\n        break;\n      }\n    }\n\n    if(not) {\n      cc.info(OPTREWRITE_X, this);\n      final int el = exprs.length;\n      final Expr[] inner = new Expr[el];\n      for(int e = 0; e < el; e++) inner[e] = ((Arr) exprs[e]).exprs[0];\n      final Expr ex = new And(info, inner).optimize(cc);\n      return cc.function(Function.NOT, info, ex).optimize(cc);\n    }\n\n    // return single expression if it yields a boolean\n    return exprs.length == 1 ? compBln(exprs[0], info, cc.sc()) : this;\n  }","id":51373,"modified_method":"@Override\n  public Expr optimize(final CompileContext cc) throws QueryException {\n    final Expr c = super.optimize(cc);\n    if(c != this) return c;\n\n    final int es = exprs.length;\n    final ExprList list = new ExprList(es);\n    for(int i = 0; i < es; i++) {\n      Expr e = exprs[i];\n      if(e instanceof CmpG) {\n        // merge adjacent comparisons\n        while(i + 1 < es && exprs[i + 1] instanceof CmpG) {\n          final Expr tmp = ((CmpG) e).union((CmpG) exprs[i + 1], cc);\n          if(tmp != null) {\n            e = tmp;\n            i++;\n          } else {\n            break;\n          }\n        }\n      }\n      // expression will always return true\n      if(e == Bln.TRUE) return optPre(Bln.TRUE, cc);\n      // skip expression yielding false\n      if(e != Bln.FALSE) list.add(e);\n    }\n\n    // all arguments return false\n    if(list.isEmpty()) return optPre(Bln.FALSE, cc);\n\n    if(es != list.size()) {\n      cc.info(OPTREWRITE_X, this);\n      exprs = list.finish();\n    }\n    compFlatten(cc);\n\n    boolean not = true;\n    for(final Expr expr : exprs) {\n      if(!expr.isFunction(Function.NOT)) {\n        not = false;\n        break;\n      }\n    }\n\n    if(not) {\n      cc.info(OPTREWRITE_X, this);\n      final int el = exprs.length;\n      final Expr[] inner = new Expr[el];\n      for(int e = 0; e < el; e++) inner[e] = ((Arr) exprs[e]).exprs[0];\n      final Expr ex = new And(info, inner).optimize(cc);\n      return cc.function(Function.NOT, info, ex);\n    }\n\n    // return single expression if it yields a boolean\n    return exprs.length == 1 ? compBln(exprs[0], info, cc.sc()) : this;\n  }","commit_id":"6d8cb991e12e52ad5e8db8bbb7f03e5abf936bee","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n\t * Compare source line annotations.\n\t * \n\t * @param rhsCollection lhs BugCollection\n\t * @param lhsCollection rhs BugCollection\n\t * @param lhs           a SourceLineAnnotation\n\t * @param rhs           another SourceLineAnnotation\n\t * @return comparison of lhs and rhs\n\t */\n\tpublic int compareSourceLines(BugCollection lhsCollection, BugCollection rhsCollection, SourceLineAnnotation lhs, SourceLineAnnotation rhs) {\n\t\tif (lhs == null || rhs == null) {\n\t\t\treturn compareNullElements(lhs, rhs);\n\t\t}\n\t\t\n\t\t// Classes must match fuzzily.\n\t\tint cmp = compareClassesByName(lhsCollection, rhsCollection, lhs.getClassName(), rhs.getClassName());\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t\t\n\t\t// If both annotations refer to entire methods, as opposed to\n\t\t// a specific instruction or range of instructions, consider them\n\t\t// equal.  This handles the case where a warning may refer to\n\t\t// another method (i.e., it was called).\n\t\t// Even if the referred-to method changes between versions, we want\n\t\t// the warning to be considered equivalent in both versions.\n\t\tif (!lhs.hasSpecificInstructions() && !rhs.hasSpecificInstructions())\n\t\t\treturn 0;\n\t\t\n\t\t// See if the opcode contexts match.\n\t\tif (   lhs.getEarlierOpcodesAsString(NUM_CONTEXT_OPCODES).equals(rhs.getEarlierOpcodesAsString(NUM_CONTEXT_OPCODES))\n\t\t\t&& lhs.getSelectedOpcodesAsString().equals(rhs.getSelectedOpcodesAsString())\n\t\t\t&& lhs.getLaterOpcodesAsString(NUM_CONTEXT_OPCODES).equals(rhs.getLaterOpcodesAsString(NUM_CONTEXT_OPCODES)))\n\t\t\t\treturn 0;\n\t\t\n\t\t// Give up and use exact matching algorithm to order the annotations\n\t\treturn lhs.compareTo(rhs);\n\t}","id":51374,"modified_method":"/**\n\t * Compare source line annotations.\n\t * \n\t * @param rhsCollection lhs BugCollection\n\t * @param lhsCollection rhs BugCollection\n\t * @param lhs           a SourceLineAnnotation\n\t * @param rhs           another SourceLineAnnotation\n\t * @return comparison of lhs and rhs\n\t */\n\tpublic int compareSourceLines(BugCollection lhsCollection, BugCollection rhsCollection, SourceLineAnnotation lhs, SourceLineAnnotation rhs) {\n\t\tif (lhs == null || rhs == null) {\n\t\t\treturn compareNullElements(lhs, rhs);\n\t\t}\n\t\t\n\t\t// Classes must match fuzzily.\n\t\tint cmp = compareClassesByName(lhsCollection, rhsCollection, lhs.getClassName(), rhs.getClassName());\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t\t\n\t\t// If both annotations refer to entire methods, as opposed to\n\t\t// a specific instruction or range of instructions, consider them\n\t\t// equal.  This handles the case where a warning may refer to\n\t\t// another method (i.e., it was called).\n\t\t// Even if the referred-to method changes between versions, we want\n\t\t// the warning to be considered equivalent in both versions.\n\t\tif (!lhs.hasSpecificInstructions() && !rhs.hasSpecificInstructions())\n\t\t\treturn 0;\n\t\t\n\t\t// Compare earlier opcodes\n\t\tif ((cmp = lhs.getEarlierOpcodesAsString(NUM_CONTEXT_OPCODES).compareTo(\n\t\t\t\trhs.getEarlierOpcodesAsString(NUM_CONTEXT_OPCODES))) != 0) {\n\t\t\treturn cmp;\n\t\t}\n\t\t\n\t\t// Compare selected opcodes\n\t\tif ((cmp = lhs.getSelectedOpcodesAsString().compareTo(rhs.getSelectedOpcodesAsString())) != 0) {\n\t\t\treturn cmp;\n\t\t}\n\t\t\n\t\t// Compare later opcodes\n\t\tif ((cmp = lhs.getLaterOpcodesAsString(NUM_CONTEXT_OPCODES).compareTo(\n\t\t\t\trhs.getLaterOpcodesAsString(NUM_CONTEXT_OPCODES))) != 0) {\n\t\t\treturn cmp;\n\t\t}\n\t\t\n\t\treturn 0;\n\t}","commit_id":"352f04588a1f7e533940714344d7cd80c4c1bb03","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Register a BugCollection.  This allows us to find the class and method\n\t * hashes for BugInstances to be compared.\n\t * \n\t * @param bugCollection a BugCollection\n\t */\n\tpublic void registerBugCollection(BugCollection bugCollection) {\n\t\tfor (Iterator<BugInstance> i = bugCollection.iterator(); i.hasNext(); ) {\n\t\t\tbugCollectionMap.put(i.next(), bugCollection);\n\t\t}\n\t\t\n\t\t// For each distinct ClassHash, keep track of the lexicographically\n\t\t// least class name.  This serves as the \"representative\" for all (equivalent)\n\t\t// classes sharing that hash value.  This allows us to ensure that the\n\t\t// class ordering induced by this comparator is transitive.\n\t\tfor (Iterator<ClassHash> i = bugCollection.classHashIterator(); i.hasNext();) {\n\t\t\tClassHash classHash = i.next();\n\t\t\tString canonicalClassName = classHashToCanonicalClassNameMap.get(classHash);\n\t\t\tif (canonicalClassName == null || classHash.getClassName().compareTo(canonicalClassName) < 0) {\n\t\t\t\tclassHashToCanonicalClassNameMap.put(classHash, classHash.getClassName());\n\t\t\t}\n\t\t}\n\t}","id":51375,"modified_method":"/**\n\t * Register a BugCollection.  This allows us to find the class and method\n\t * hashes for BugInstances to be compared.\n\t * \n\t * @param bugCollection a BugCollection\n\t */\n\tpublic void registerBugCollection(BugCollection bugCollection) {\n\t\tif (USE_HASHES) {\n\t\t\tfor (Iterator<BugInstance> i = bugCollection.iterator(); i.hasNext(); ) {\n\t\t\t\tbugCollectionMap.put(i.next(), bugCollection);\n\t\t\t}\n\t\t\t\n\t\t\t// For each distinct ClassHash, keep track of the lexicographically\n\t\t\t// least class name.  This serves as the \"representative\" for all (equivalent)\n\t\t\t// classes sharing that hash value.  This allows us to ensure that the\n\t\t\t// class ordering induced by this comparator is transitive.\n\t\t\tfor (Iterator<ClassHash> i = bugCollection.classHashIterator(); i.hasNext();) {\n\t\t\t\tClassHash classHash = i.next();\n\t\t\t\tString canonicalClassName = classHashToCanonicalClassNameMap.get(classHash);\n\t\t\t\tif (canonicalClassName == null || classHash.getClassName().compareTo(canonicalClassName) < 0) {\n\t\t\t\t\tclassHashToCanonicalClassNameMap.put(classHash, classHash.getClassName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"352f04588a1f7e533940714344d7cd80c4c1bb03","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean equalExceptReads(final ActiveRegion other) {\n        if ( ! activeRegionLoc.equals(other.activeRegionLoc) ) return false;\n        if ( isActive != other.isActive ) return false;\n        if ( genomeLocParser != other.genomeLocParser ) return false;\n        if ( extension != other.extension ) return false;\n        if ( ! extendedLoc.equals(other.extendedLoc) ) return false;\n        return true;\n    }","id":51376,"modified_method":"public boolean equalExceptReads(final ActiveRegion other) {\n        if ( activeRegionLoc.compareTo(other.activeRegionLoc) != 0 ) return false;\n        if ( isActive != other.isActive ) return false;\n        if ( genomeLocParser != other.genomeLocParser ) return false;\n        if ( extension != other.extension ) return false;\n        if ( extendedLoc.compareTo(other.extendedLoc) != 0 ) return false;\n        return true;\n    }","commit_id":"19cf37d4e3bb5a055f330bf42ced6b7b8898cf4b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void add(final GenomeLoc loc, final ActivityProfileResult result) {\n        if ( loc.size() != 1 )\n            throw new ReviewedStingException(\"Bad add call to ActivityProfile: loc \" + loc + \" size != 1\" );\n        if ( lastLoc != null && loc.getStart() != lastLoc.getStop() + 1 )\n            throw new ReviewedStingException(\"Bad add call to ActivityProfile: lastLoc added \" + lastLoc + \" and next is \" + loc);\n        isActiveList.add(result);\n        if( regionStartLoc == null ) {\n            regionStartLoc = loc;\n        }\n    }","id":51377,"modified_method":"public void add(final GenomeLoc loc, final ActivityProfileResult result) {\n        if ( loc.size() != 1 )\n            throw new ReviewedStingException(\"Bad add call to ActivityProfile: loc \" + loc + \" size != 1\" );\n        isActiveList.add(result);\n        if( regionStartLoc == null ) {\n            regionStartLoc = loc;\n        }\n    }","commit_id":"19cf37d4e3bb5a055f330bf42ced6b7b8898cf4b","url":"https://github.com/broadgsa/gatk"},{"original_method":"static Boolean extractSingleBooleanArg(String argname, Map<String,List<String>> args) {\r\n        List<String> l = args.get(argname);\r\n        args.remove(argname);\r\n        if ( l == null ) return null;\r\n\r\n        if ( l.size() > 1 ) {\r\n            System.err.println(\"Only one \"+argname+\" argument is allowed\");\r\n            System.exit(1);\r\n        }\r\n        if ( l.get(0).equals(\"true\") ) return new Boolean(true);\r\n        if ( l.get(0).equals(\"false\") ) return new Boolean(false);\r\n        System.err.println(\"Can not parse value provided for \"+argname+\" argument (\"+l.get(0)+\"); true/false are allowed\");\r\n        System.exit(1);\r\n        return null;\r\n    }","id":51378,"modified_method":"static Boolean extractSingleBooleanArg(String argname, Map<String,List<String>> args) {\r\n        List<String> l = args.get(argname);\r\n        args.remove(argname);\r\n        if ( l == null ) return null;\r\n\r\n        if ( l.size() > 1 ) {\r\n            System.err.println(\"Only one \"+argname+\" argument is allowed\");\r\n            System.exit(1);\r\n        }\r\n        if ( l.get(0).equals(\"true\") ) return Boolean.valueOf(true);\r\n        if ( l.get(0).equals(\"false\") ) return Boolean.valueOf(false);\r\n        System.err.println(\"Can not parse value provided for \"+argname+\" argument (\"+l.get(0)+\"); true/false are allowed\");\r\n        System.exit(1);\r\n        return Boolean.valueOf(false); // This value isn't used because it is preceded by System.exit(1)\r\n    }","commit_id":"19cf37d4e3bb5a055f330bf42ced6b7b8898cf4b","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void configureCompile(final Project project) {\n        project.addTaskLifecycleListener(GroovyCompile.class, new TaskLifecycleListener<GroovyCompile>() {\n            public void taskAdded(GroovyCompile compile) {\n                compile.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n                compile.conventionMapping(GUtil.map(\"groovySourceDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovySrcDirs();\n                    }\n                }));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", GroovyCompile.class, \"overwrite\", true), COMPILE);\n    }","id":51379,"modified_method":"private void configureCompile(final Project project) {\n        project.addTaskLifecycleListener(GroovyCompile.class, new TaskLifecycleListener<GroovyCompile>() {\n            public void taskAdded(GroovyCompile compile) {\n                compile.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n                compile.conventionMapping(GUtil.map(\"groovySourceDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovySrcDirs();\n                    }\n                }));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", GroovyCompile.class, \"overwrite\", true), COMPILE).setDescription(\n                \"Compiles the Java and Groovy source code.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        JavaPlugin javaPlugin = pluginRegistry.apply(JavaPlugin.class, project, customValues);\n        GroovyPluginConvention groovyPluginConvention = new GroovyPluginConvention(project, customValues);\n        project.getConvention().getPlugins().put(\"groovy\", groovyPluginConvention);\n        Configuration groovyConfiguration = project.getConfigurations().add(GROOVY).setVisible(false).setTransitive(false);\n\n        configureCompile(project);\n\n        configureTestCompile(javaPlugin, project);\n\n        configureJavadoc(project);\n\n        configureGroovydoc(project);\n\n        project.getConfigurations().get(COMPILE).extendsFrom(groovyConfiguration);\n    }","id":51380,"modified_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        JavaPlugin javaPlugin = pluginRegistry.apply(JavaPlugin.class, project, customValues);\n        GroovyPluginConvention groovyPluginConvention = new GroovyPluginConvention(project, customValues);\n        project.getConvention().getPlugins().put(\"groovy\", groovyPluginConvention);\n        Configuration groovyConfiguration = project.getConfigurations().add(GROOVY).setVisible(false).setTransitive(false).\n                setDescription(\"The groovy libraries to be used for this Groovy project.\");\n\n        configureCompile(project);\n\n        configureTestCompile(javaPlugin, project);\n\n        configureJavadoc(project);\n\n        configureGroovydoc(project);\n\n        project.getConfigurations().get(COMPILE).extendsFrom(groovyConfiguration);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureGroovydoc(final Project project) {\n        project.addTaskLifecycleListener(Groovydoc.class, new TaskLifecycleListener<Groovydoc>() {\n            public void taskAdded(Groovydoc groovydoc) {\n                groovydoc.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n                groovydoc.conventionMapping(GUtil.map(\"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovySrcDirs();\n                    }\n                }, \"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovydocDir();\n                    }\n                }));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Groovydoc.class), GROOVYDOC);\n    }","id":51381,"modified_method":"private void configureGroovydoc(final Project project) {\n        project.addTaskLifecycleListener(Groovydoc.class, new TaskLifecycleListener<Groovydoc>() {\n            public void taskAdded(Groovydoc groovydoc) {\n                groovydoc.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n                groovydoc.conventionMapping(GUtil.map(\"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovySrcDirs();\n                    }\n                }, \"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return groovy(convention).getGroovydocDir();\n                    }\n                }));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Groovydoc.class), GROOVYDOC).setDescription(\"Generates the groovydoc for the source code.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureTestCompile(JavaPlugin javaPlugin, Project project) {\n        GroovyCompile testCompile = (GroovyCompile) javaPlugin.configureTestCompile(\n                (Compile) project.createTask(GUtil.map(\"type\", GroovyCompile.class, \"overwrite\", true), TEST_COMPILE),\n                (Compile) project.task(COMPILE),\n                DefaultConventionsToPropertiesMapping.TEST_COMPILE,\n                project.getConfigurations());\n        testCompile.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n        testCompile.conventionMapping(GUtil.map(\n                \"groovySourceDirs\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return groovy(convention).getGroovyTestSrcDirs();\n            }\n        }));\n    }","id":51382,"modified_method":"private void configureTestCompile(JavaPlugin javaPlugin, Project project) {\n        GroovyCompile testCompile = (GroovyCompile) javaPlugin.configureTestCompile(\n                (Compile) project.createTask(GUtil.map(\"type\", GroovyCompile.class, \"overwrite\", true), TEST_COMPILE),\n                (Compile) project.task(COMPILE),\n                DefaultConventionsToPropertiesMapping.TEST_COMPILE,\n                project.getConfigurations());\n        testCompile.setGroovyClasspath(project.getConfigurations().get(\"groovy\"));\n        testCompile.setDescription(\"Compiles the Java and Groovy test source code.\");\n        testCompile.conventionMapping(GUtil.map(\n                \"groovySourceDirs\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return groovy(convention).getGroovyTestSrcDirs();\n            }\n        }));\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureCompile(final Project project) {\n        project.addTaskLifecycleListener(Compile.class, new TaskLifecycleListener<Compile>() {\n            public void taskAdded(Compile compile) {\n                compile.dependsOn(RESOURCES);\n                compile.setConfiguration(project.getConfigurations().get(COMPILE));\n                compile.conventionMapping(DefaultConventionsToPropertiesMapping.COMPILE);\n                addDependsOnProjectDependencies(compile, COMPILE);\n            }\n        });\n\n        project.createTask(GUtil.map(\"type\", Compile.class), COMPILE);\n    }","id":51383,"modified_method":"private void configureCompile(final Project project) {\n        project.addTaskLifecycleListener(Compile.class, new TaskLifecycleListener<Compile>() {\n            public void taskAdded(Compile compile) {\n                compile.dependsOn(RESOURCES);\n                compile.setConfiguration(project.getConfigurations().get(COMPILE));\n                compile.conventionMapping(DefaultConventionsToPropertiesMapping.COMPILE);\n                addDependsOnProjectDependencies(compile, COMPILE);\n            }\n        });\n\n        project.createTask(GUtil.map(\"type\", Compile.class), COMPILE).setDescription(\"Compiles the Java source code.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureTest(final Project project) {\n        project.addTaskLifecycleListener(Test.class, new TaskLifecycleListener<Test>() {\n            public void taskAdded(Test test) {\n                test.dependsOn(TEST_COMPILE);\n                test.conventionMapping(DefaultConventionsToPropertiesMapping.TEST);\n                test.setConfiguration(project.getConfigurations().get(TEST_RUNTIME));\n                addDependsOnProjectDependencies(test, TEST_RUNTIME);\n                test.doFirst(new TaskAction() {\n                    public void execute(Task task) {\n                        Test test = (Test) task;\n                        List unmanagedClasspathFromTestCompile = ((Compile) test.getProject().task(TEST_COMPILE))\n                                .getUnmanagedClasspath();\n                        test.unmanagedClasspath(unmanagedClasspathFromTestCompile.toArray(\n                                new Object[unmanagedClasspathFromTestCompile.size()]));\n                    }\n                });\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Test.class), TEST);\n    }","id":51384,"modified_method":"private void configureTest(final Project project) {\n        project.addTaskLifecycleListener(Test.class, new TaskLifecycleListener<Test>() {\n            public void taskAdded(Test test) {\n                test.dependsOn(TEST_COMPILE);\n                test.conventionMapping(DefaultConventionsToPropertiesMapping.TEST);\n                test.setConfiguration(project.getConfigurations().get(TEST_RUNTIME));\n                addDependsOnProjectDependencies(test, TEST_RUNTIME);\n                test.doFirst(new TaskAction() {\n                    public void execute(Task task) {\n                        Test test = (Test) task;\n                        List unmanagedClasspathFromTestCompile = ((Compile) test.getProject().task(TEST_COMPILE))\n                                .getUnmanagedClasspath();\n                        test.unmanagedClasspath(unmanagedClasspathFromTestCompile.toArray(\n                                new Object[unmanagedClasspathFromTestCompile.size()]));\n                    }\n                });\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Test.class), TEST).setDescription(\"Runs the tests.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJavaDoc(final Project project) {\n        project.addTaskLifecycleListener(Javadoc.class, new TaskLifecycleListener<Javadoc>() {\n            public void taskAdded(Javadoc javadoc) {\n                javadoc.conventionMapping(DefaultConventionsToPropertiesMapping.JAVADOC);\n                javadoc.setConfiguration(project.getConfigurations().get(COMPILE));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Javadoc.class), JAVADOC);\n    }","id":51385,"modified_method":"private void configureJavaDoc(final Project project) {\n        project.addTaskLifecycleListener(Javadoc.class, new TaskLifecycleListener<Javadoc>() {\n            public void taskAdded(Javadoc javadoc) {\n                javadoc.conventionMapping(DefaultConventionsToPropertiesMapping.JAVADOC);\n                javadoc.setConfiguration(project.getConfigurations().get(COMPILE));\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Javadoc.class), JAVADOC).setDescription(\"Generates the javadoc for the source code.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"void configureConfigurations(Project project) {\n        project.setProperty(\"status\", \"integration\");\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.add(COMPILE).setVisible(false).setTransitive(false);\n        Configuration runtimeConfiguration = configurations.add(RUNTIME).setVisible(false).extendsFrom(compileConfiguration);\n        Configuration compileTestsConfiguration = configurations.add(TEST_COMPILE).setVisible(false).extendsFrom(compileConfiguration).setTransitive(false);\n        Configuration runTestsConfiguration = configurations.add(TEST_RUNTIME).setVisible(false).extendsFrom(runtimeConfiguration, compileTestsConfiguration);\n        Configuration masterConfiguration = configurations.add(Dependency.MASTER_CONFIGURATION);\n        configurations.add(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration, masterConfiguration);\n        configurations.add(DISTS);\n    }","id":51386,"modified_method":"void configureConfigurations(Project project) {\n        project.setProperty(\"status\", \"integration\");\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.add(COMPILE).setVisible(false).setTransitive(false).\n                setDescription(\"Classpath for compiling the sources.\");\n        Configuration runtimeConfiguration = configurations.add(RUNTIME).setVisible(false).extendsFrom(compileConfiguration).\n                setDescription(\"Classpath for running the compiled sources.\");;\n        Configuration compileTestsConfiguration = configurations.add(TEST_COMPILE).setVisible(false).extendsFrom(compileConfiguration).\n                setTransitive(false).setDescription(\"Classpath for compiling the test sources.\");;\n        Configuration runTestsConfiguration = configurations.add(TEST_RUNTIME).setVisible(false).extendsFrom(runtimeConfiguration, compileTestsConfiguration).\n                setDescription(\"Classpath for running the test sources.\");;\n        Configuration masterConfiguration = configurations.add(Dependency.MASTER_CONFIGURATION).\n                setDescription(\"Configuration for the default artifacts.\");;\n        configurations.add(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration, masterConfiguration).\n                setDescription(\"Configuration the default artifacts and its dependencies.\");\n        configurations.add(DISTS);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureEclipse(Project project) {\n        Task eclipse = project.createTask(ECLIPSE).dependsOn(\n                configureEclipseProject(project),\n                configureEclipseClasspath(project)\n        );\n        project.createTask(WrapUtil.toMap(\"type\", EclipseClean.class), ECLIPSE_CLEAN);\n    }","id":51387,"modified_method":"private void configureEclipse(Project project) {\n        project.createTask(ECLIPSE).dependsOn(\n                configureEclipseProject(project),\n                configureEclipseClasspath(project)\n        ).setDescription(\"Generates an Eclipse .project and .classpath file.\");\n        project.createTask(WrapUtil.toMap(\"type\", EclipseClean.class), ECLIPSE_CLEAN).setDescription(\n                \"Deletes the Eclipse .project and .classpath files.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private EclipseProject configureEclipseProject(Project project) {\n        EclipseProject eclipseProject = (EclipseProject) project.createTask(GUtil.map(\"type\", EclipseProject.class), ECLIPSE_PROJECT);\n        eclipseProject.setProjectName(project.getName());\n        eclipseProject.setProjectType(ProjectType.JAVA);\n        return eclipseProject;\n    }","id":51388,"modified_method":"private EclipseProject configureEclipseProject(Project project) {\n        EclipseProject eclipseProject = (EclipseProject) project.createTask(GUtil.map(\"type\", EclipseProject.class), ECLIPSE_PROJECT);\n        eclipseProject.setProjectName(project.getName());\n        eclipseProject.setProjectType(ProjectType.JAVA);\n        eclipseProject.setDescription(\"Generates an Eclipse .project file.\");\n        return eclipseProject;\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(final Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(ReportingBasePlugin.class, project, customValues);\n\n        JavaPluginConvention javaConvention = new JavaPluginConvention(project, customValues);\n        Convention convention = project.getConvention();\n        convention.getPlugins().put(\"java\", javaConvention);\n\n        configureConfigurations(project);\n        configureUploadRules(project);\n\n        project.createTask(INIT);\n\n        ((ConventionTask) project.createTask(GUtil.map(\"type\", Clean.class), CLEAN)).\n                conventionMapping(GUtil.map(\n                        \"dir\", new ConventionValue() {\n                            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                                return project.getBuildDir();\n                            }\n                        }));\n\n        configureJavaDoc(project);\n\n        configureResources(project);\n        configureCompile(project);\n\n        configureTest(project);\n\n        configureTestResources(project);\n        configureTestCompile(project);\n\n        configureLibs(project, javaConvention);\n        configureDists(project, javaConvention);\n\n        project.createTask(UPLOAD);\n\n        configureEclipse(project);\n        configureEclipseWtpModule(project);\n    }","id":51389,"modified_method":"public void apply(final Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(ReportingBasePlugin.class, project, customValues);\n\n        JavaPluginConvention javaConvention = new JavaPluginConvention(project, customValues);\n        Convention convention = project.getConvention();\n        convention.getPlugins().put(\"java\", javaConvention);\n\n        configureConfigurations(project);\n        configureUploadRules(project);\n\n        project.createTask(INIT).setDescription(\"The first task of the Java plugin tasks to be excuted. Does nothing if not customized.\");\n\n        ((ConventionTask) project.createTask(GUtil.map(\"type\", Clean.class), CLEAN)).\n                conventionMapping(GUtil.map(\n                        \"dir\", new ConventionValue() {\n                            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                                return project.getBuildDir();\n                            }\n                        })).setDescription(\"Deletes the build directory.\");\n\n        configureJavaDoc(project);\n\n        configureResources(project);\n\n        configureCompile(project);\n\n        configureTest(project);\n\n        configureTestResources(project);\n        configureTestCompile(project);\n\n        configureLibs(project, javaConvention);\n        configureDists(project, javaConvention);\n\n        project.createTask(UPLOAD);\n\n        configureEclipse(project);\n        configureEclipseWtpModule(project);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private EclipseClasspath configureEclipseClasspath(Project project) {\n        EclipseClasspath eclipseClasspath = (EclipseClasspath) project.createTask(GUtil.map(\"type\", EclipseClasspath.class), ECLIPSE_CP);\n        eclipseClasspath.conventionMapping(GUtil.map(\n                \"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getSrcDirs(), java(convention).getResourceDirs());\n                    }\n                },\n                \"testSrcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getTestSrcDirs(), java(convention).getTestResourceDirs());\n                    }\n                },\n                \"outputDirectory\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return java(convention).getClassesDir();\n                    }\n                },\n                \"testOutputDirectory\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return java(convention).getTestClassesDir();\n                    }\n                },\n                \"classpathLibs\", new ConventionValue() {\n                    public Object getValue(Convention convention, final IConventionAware conventionAwareObject) {\n                        ConfigurationContainer configurationContainer = ((Task) conventionAwareObject).getProject().getConfigurations();\n                        return new ArrayList(configurationContainer.get(TEST_RUNTIME).copyRecursive(DependencySpecs.type(Type.EXTERNAL)).resolve());\n                    }\n                },\n                \"projectDependencies\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new ArrayList(((Task) conventionAwareObject).getProject().getConfigurations().get(TEST_RUNTIME).getAllProjectDependencies());\n                    }\n                }));\n        return eclipseClasspath;\n    }","id":51390,"modified_method":"private EclipseClasspath configureEclipseClasspath(Project project) {\n        EclipseClasspath eclipseClasspath = (EclipseClasspath) project.createTask(GUtil.map(\"type\", EclipseClasspath.class), ECLIPSE_CP);\n        eclipseClasspath.conventionMapping(GUtil.map(\n                \"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getSrcDirs(), java(convention).getResourceDirs());\n                    }\n                },\n                \"testSrcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getTestSrcDirs(), java(convention).getTestResourceDirs());\n                    }\n                },\n                \"outputDirectory\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return java(convention).getClassesDir();\n                    }\n                },\n                \"testOutputDirectory\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return java(convention).getTestClassesDir();\n                    }\n                },\n                \"classpathLibs\", new ConventionValue() {\n                    public Object getValue(Convention convention, final IConventionAware conventionAwareObject) {\n                        ConfigurationContainer configurationContainer = ((Task) conventionAwareObject).getProject().getConfigurations();\n                        return new ArrayList(configurationContainer.get(TEST_RUNTIME).copyRecursive(DependencySpecs.type(Type.EXTERNAL)).resolve());\n                    }\n                },\n                \"projectDependencies\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new ArrayList(((Task) conventionAwareObject).getProject().getConfigurations().get(TEST_RUNTIME).getAllProjectDependencies());\n                    }\n                }));\n        eclipseClasspath.setDescription(\"Generates an Eclipse .classpath file.\");\n        return eclipseClasspath;\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private Upload createUploadTask(String name, final Configuration configuration, Project project) {\n        final Upload upload = (Upload) project.createTask(GUtil.map(\"type\", Upload.class), name);\n        PublishInstruction publishInstruction = new PublishInstruction();\n        publishInstruction.setIvyFileParentDir(project.getBuildDir());\n        upload.setConfiguration(configuration);\n        upload.setPublishInstruction(publishInstruction);\n        upload.dependsOn(configuration.getBuildArtifacts());\n        return upload;\n    }","id":51391,"modified_method":"private Upload createUploadTask(String name, final Configuration configuration, Project project) {\n        final Upload upload = (Upload) project.createTask(GUtil.map(\"type\", Upload.class), name);\n        PublishInstruction publishInstruction = new PublishInstruction();\n        publishInstruction.setIvyFileParentDir(project.getBuildDir());\n        upload.setConfiguration(configuration);\n        upload.setPublishInstruction(publishInstruction);\n        upload.dependsOn(configuration.getBuildArtifacts());\n        upload.setDescription(String.format(\"Uploads all artifacts belonging to the %s configuration\", configuration.getName()));\n        return upload;\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureTestResources(Project project) {\n        ConventionTask testResources = (ConventionTask) project.createTask(GUtil.map(\"type\", Resources.class), TEST_RESOURCES);\n        testResources.setDependsOn(WrapUtil.toSet(COMPILE));\n        testResources.getSkipProperties().add(Task.AUTOSKIP_PROPERTY_PREFIX + TEST);\n        testResources.conventionMapping(DefaultConventionsToPropertiesMapping.TEST_RESOURCES);\n    }","id":51392,"modified_method":"private void configureTestResources(Project project) {\n        ConventionTask testResources = (ConventionTask) project.createTask(GUtil.map(\"type\", Resources.class), TEST_RESOURCES);\n        testResources.setDependsOn(WrapUtil.toSet(COMPILE));\n        testResources.getSkipProperties().add(Task.AUTOSKIP_PROPERTY_PREFIX + TEST);\n        testResources.conventionMapping(DefaultConventionsToPropertiesMapping.TEST_RESOURCES);\n        testResources.setDescription(\n                \"Process and copy the test resources into the binary directory of the compiled test sources.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureLibs(Project project, final JavaPluginConvention javaConvention) {\n        Bundle libsBundle = (Bundle) project.createTask(GUtil.map(\"type\", Bundle.class, \"dependsOn\", TEST), LIBS);\n        libsBundle.setDefaultConfigurations(WrapUtil.toList(Dependency.MASTER_CONFIGURATION));\n        libsBundle.setDefaultDestinationDir(project.getBuildDir());\n        libsBundle.conventionMapping(DefaultConventionsToPropertiesMapping.LIB);\n        Jar jar = libsBundle.jar();\n        jar.conventionMapping(WrapUtil.<String, ConventionValue>toMap(\"resourceCollections\",\n                new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return WrapUtil.toList(new FileSet(javaConvention.getClassesDir()));\n                    }\n                }));\n        project.getConfigurations().get(Dependency.MASTER_CONFIGURATION).addArtifact(new ArchivePublishArtifact(jar));\n    }","id":51393,"modified_method":"private void configureLibs(Project project, final JavaPluginConvention javaConvention) {\n        Bundle libsBundle = (Bundle) project.createTask(GUtil.map(\"type\", Bundle.class, \"dependsOn\", TEST), LIBS);\n        libsBundle.setDefaultConfigurations(WrapUtil.toList(Dependency.MASTER_CONFIGURATION));\n        libsBundle.setDefaultDestinationDir(project.getBuildDir());\n        libsBundle.conventionMapping(DefaultConventionsToPropertiesMapping.LIB);\n        Jar jar = libsBundle.jar();\n        jar.conventionMapping(WrapUtil.<String, ConventionValue>toMap(\"resourceCollections\",\n                new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return WrapUtil.toList(new FileSet(javaConvention.getClassesDir()));\n                    }\n                }));\n        jar.setDescription(\"Generates a jar archive with all the compiled classes.\");\n        project.getConfigurations().get(Dependency.MASTER_CONFIGURATION).addArtifact(new ArchivePublishArtifact(jar));\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureResources(Project project) {\n        project.addTaskLifecycleListener(Resources.class, new TaskLifecycleListener<Resources>() {\n            public void taskAdded(Resources resources) {\n                resources.dependsOn(INIT);\n                resources.conventionMapping(DefaultConventionsToPropertiesMapping.RESOURCES);\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Resources.class), RESOURCES);\n    }","id":51394,"modified_method":"private void configureResources(Project project) {\n        project.addTaskLifecycleListener(Resources.class, new TaskLifecycleListener<Resources>() {\n            public void taskAdded(Resources resources) {\n                resources.dependsOn(INIT);\n                resources.conventionMapping(DefaultConventionsToPropertiesMapping.RESOURCES);\n            }\n        });\n        project.createTask(GUtil.map(\"type\", Resources.class), RESOURCES).setDescription(\n                \"Process and copy the resources into the binary directory of the compiled sources.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureEclipseWtpModule(Project project) {\n        EclipseWtpModule eclipseWtpModule = (EclipseWtpModule) project.createTask(GUtil.map(\"type\", EclipseWtpModule.class), ECLIPSE_WTP_MODULE);\n\n\n        eclipseWtpModule.conventionMapping(GUtil.map(\n                \"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getSrcDirs(), java(convention).getResourceDirs());\n                    }\n                }));\n    }","id":51395,"modified_method":"private void configureEclipseWtpModule(Project project) {\n        EclipseWtpModule eclipseWtpModule = (EclipseWtpModule) project.createTask(GUtil.map(\"type\", EclipseWtpModule.class), ECLIPSE_WTP_MODULE);\n\n        eclipseWtpModule.conventionMapping(GUtil.map(\n                \"srcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return GUtil.addLists(java(convention).getSrcDirs(), java(convention).getResourceDirs());\n                    }\n                }));\n        eclipseWtpModule.setDescription(\"Generates the Eclipse Wtp files.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureTestCompile(Project project) {\n        configureTestCompile((Compile) project.createTask(GUtil.map(\"type\", Compile.class), TEST_COMPILE),\n                (Compile) project.task(COMPILE), DefaultConventionsToPropertiesMapping.TEST_COMPILE,\n                project.getConfigurations());\n    }","id":51396,"modified_method":"private void configureTestCompile(Project project) {\n        configureTestCompile((Compile) project.createTask(GUtil.map(\"type\", Compile.class), TEST_COMPILE),\n                (Compile) project.task(COMPILE), DefaultConventionsToPropertiesMapping.TEST_COMPILE,\n                project.getConfigurations()).setDescription(\"Compiles the Java test source code.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJettyRun(final Project project, final JettyPluginConvention jettyConvention) {\n        JettyRun jettyRun = (JettyRun) project.createTask(GUtil.map(\"type\", JettyRun.class), JETTY_RUN);\n        jettyRun.dependsOn(JavaPlugin.TEST_COMPILE);\n\n        configureAbstractJettyTask(project, jettyConvention, jettyRun);\n\n        jettyRun.setConfiguration(JavaPlugin.RUNTIME);\n        jettyRun.setTestConfiguration(JavaPlugin.TEST_RUNTIME);\n        jettyRun.setUseTestClasspath(false);\n        jettyRun.getConventionMapping().put(\"webXml\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getWebXml(project);\n            }\n        });\n        jettyRun.getConventionMapping().put(\"classesDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getClassesDir();\n            }\n        });\n        jettyRun.getConventionMapping().put(\"testClassesDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getTestClassesDir();\n            }\n        });\n        jettyRun.getConventionMapping().put(\"webAppSourceDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getWebAppDir();\n            }\n        });\n    }","id":51397,"modified_method":"private void configureJettyRun(final Project project, final JettyPluginConvention jettyConvention) {\n        JettyRun jettyRun = (JettyRun) project.createTask(GUtil.map(\"type\", JettyRun.class), JETTY_RUN);\n        jettyRun.setDescription(\"Uses your files as and where they are and deploys them to Jetty.\");\n        jettyRun.dependsOn(JavaPlugin.TEST_COMPILE);\n\n        configureAbstractJettyTask(project, jettyConvention, jettyRun);\n\n        jettyRun.setConfiguration(JavaPlugin.RUNTIME);\n        jettyRun.setTestConfiguration(JavaPlugin.TEST_RUNTIME);\n        jettyRun.setUseTestClasspath(false);\n        jettyRun.getConventionMapping().put(\"webXml\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getWebXml(project);\n            }\n        });\n        jettyRun.getConventionMapping().put(\"classesDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getClassesDir();\n            }\n        });\n        jettyRun.getConventionMapping().put(\"testClassesDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getTestClassesDir();\n            }\n        });\n        jettyRun.getConventionMapping().put(\"webAppSourceDirectory\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return getJavaConvention(project).getWebAppDir();\n            }\n        });\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJettyStop(Project project, final JettyPluginConvention jettyConvention) {\n        JettyStop jettyStop = (JettyStop) project.createTask(GUtil.map(\"type\", JettyStop.class), JETTY_STOP);\n        jettyStop.getConventionMapping().put(\"stopPort\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return jettyConvention.getStopPort();\n            }\n        });\n        jettyStop.getConventionMapping().put(\"stopKey\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return jettyConvention.getStopKey();\n            }\n        });\n    }","id":51398,"modified_method":"private void configureJettyStop(Project project, final JettyPluginConvention jettyConvention) {\n        JettyStop jettyStop = (JettyStop) project.createTask(GUtil.map(\"type\", JettyStop.class), JETTY_STOP);\n        jettyStop.setDescription(\"Stops Jetty.\");\n        jettyStop.getConventionMapping().put(\"stopPort\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return jettyConvention.getStopPort();\n            }\n        });\n        jettyStop.getConventionMapping().put(\"stopKey\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return jettyConvention.getStopKey();\n            }\n        });\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJettyRunWar(final Project project, JettyPluginConvention jettyConvention) {\n        JettyRunWar jettyRunWar = (JettyRunWar) project.createTask(GUtil.map(\"type\", JettyRunWar.class), JETTY_RUN_WAR);\n        jettyRunWar.dependsOn(\"archive_war\");\n\n        configureAbstractJettyTask(project, jettyConvention, jettyRunWar);\n        jettyRunWar.getConventionMapping().put(\"webApp\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return ((War) project.task(\"archive_war\")).getArchivePath();\n            }\n        });\n    }","id":51399,"modified_method":"private void configureJettyRunWar(final Project project, JettyPluginConvention jettyConvention) {\n        JettyRunWar jettyRunWar = (JettyRunWar) project.createTask(GUtil.map(\"type\", JettyRunWar.class), JETTY_RUN_WAR);\n        jettyRunWar.setDescription(\"Assembles the webapp into a war and deploys it to Jetty.\");\n        jettyRunWar.dependsOn(\"archive_war\");\n\n        configureAbstractJettyTask(project, jettyConvention, jettyRunWar);\n        jettyRunWar.getConventionMapping().put(\"webApp\", new ConventionValue() {\n            public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                return ((War) project.task(\"archive_war\")).getArchivePath();\n            }\n        });\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJettyRunWarExploded(Project project, JettyPluginConvention jettyConvention) {\n        JettyRunWarExploded jettyRunWarExploded = (JettyRunWarExploded)\n                 project.createTask(GUtil.map(\"type\", JettyRunWarExploded.class), JETTY_RUN_EXPLODED_WAR);\n        configureAbstractJettyTask(project, jettyConvention, jettyRunWarExploded);\n    }","id":51400,"modified_method":"private void configureJettyRunWarExploded(Project project, JettyPluginConvention jettyConvention) {\n        JettyRunWarExploded jettyRunWarExploded = (JettyRunWarExploded)\n                 project.createTask(GUtil.map(\"type\", JettyRunWarExploded.class), JETTY_RUN_EXPLODED_WAR);\n        jettyRunWarExploded.setDescription(\"Assembles the webapp into an exploded war and deploys it to Jetty.\");\n        configureAbstractJettyTask(project, jettyConvention, jettyRunWarExploded);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureInstall(Project project, JavaPluginConvention javaConvention) {\n        Upload installUpload = (Upload) project.createTask(GUtil.map(\"type\", Upload.class), INSTALL);\n        installUpload.setConfiguration(project.getConfigurations().get(Dependency.MASTER_CONFIGURATION));\n        PublishInstruction publishInstruction = new PublishInstruction();\n        publishInstruction.setIvyFileParentDir(new File(\"nonNullDummy\"));\n        installUpload.setPublishInstruction(publishInstruction);\n        installUpload.getRepositories().addMavenInstaller(\"maven-installer\");\n    }","id":51401,"modified_method":"private void configureInstall(Project project, JavaPluginConvention javaConvention) {\n        Upload installUpload = (Upload) project.createTask(GUtil.map(\"type\", Upload.class), INSTALL);\n        installUpload.setConfiguration(project.getConfigurations().get(Dependency.MASTER_CONFIGURATION));\n        PublishInstruction publishInstruction = new PublishInstruction();\n        publishInstruction.setIvyFileParentDir(new File(\"nonNullDummy\"));\n        installUpload.setPublishInstruction(publishInstruction);\n        installUpload.getRepositories().addMavenInstaller(\"maven-installer\");\n        installUpload.setDescription(\"Does a maven install of the master artifacts into the local .m2 cache.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(ReportingBasePlugin.class, project, customValues);\n        \n        TaskReportTask taskReportTask = (TaskReportTask) project.createTask(toMap(Task.TASK_TYPE, TaskReportTask.class),\n                \"taskReport\");\n        taskReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/tasks.txt\"));\n\n        PropertyReportTask propertyReportTask = (PropertyReportTask) project.createTask(toMap(Task.TASK_TYPE,\n                PropertyReportTask.class), \"propertyReport\");\n        propertyReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/properties.txt\"));\n\n        DependencyReportTask dependencyReportTask = (DependencyReportTask) project.createTask(toMap(Task.TASK_TYPE,\n                DependencyReportTask.class), \"dependencyReport\");\n        dependencyReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/dependencies.txt\"));\n    }","id":51402,"modified_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(ReportingBasePlugin.class, project, customValues);\n        \n        TaskReportTask taskReportTask = (TaskReportTask) project.createTask(toMap(Task.TASK_TYPE, TaskReportTask.class),\n                \"taskReport\");\n        taskReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/tasks.txt\"));\n        taskReportTask.setDescription(\"Shows a report about your tasks.\");\n\n        PropertyReportTask propertyReportTask = (PropertyReportTask) project.createTask(toMap(Task.TASK_TYPE,\n                PropertyReportTask.class), \"propertyReport\");\n        propertyReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/properties.txt\"));\n        propertyReportTask.setDescription(\"Shows a report about your properties.\");\n\n        DependencyReportTask dependencyReportTask = (DependencyReportTask) project.createTask(toMap(Task.TASK_TYPE,\n                DependencyReportTask.class), \"dependencyReport\");\n        dependencyReportTask.setOutputFile(new File(project.getBuildDir(), \"reports/project/dependencies.txt\"));\n        dependencyReportTask.setDescription(\"Shows a report about your library dependencies.\");\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(JavaPlugin.class, project, customValues);\n        project.task(project.getArchivesTaskBaseName() + \"_jar\").setEnabled(false);\n        War war = ((Bundle) project.task(\"libs\")).war();\n        project.getConfigurations().get(Dependency.MASTER_CONFIGURATION).addArtifact(new ArchivePublishArtifact(war));\n        configureConfigurations(project.getConfigurations());\n        configureEclipse(project, war);\n    }","id":51403,"modified_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map<String, ?> customValues) {\n        pluginRegistry.apply(JavaPlugin.class, project, customValues);\n        project.task(project.getArchivesTaskBaseName() + \"_jar\").setEnabled(false);\n        War war = ((Bundle) project.task(\"libs\")).war();\n        war.setDescription(\"Generates a war archive with all the compiled classes, the web-app content and the libraries.\");\n        project.getConfigurations().get(Dependency.MASTER_CONFIGURATION).addArtifact(new ArchivePublishArtifact(war));\n        configureConfigurations(project.getConfigurations());\n        configureEclipse(project, war);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"public void configureConfigurations(ConfigurationContainer configurationContainer) {\n        Configuration provideCompileConfiguration = configurationContainer.add(PROVIDED_COMPILE).setVisible(false);\n        Configuration provideRuntimeConfiguration = configurationContainer.add(PROVIDED_RUNTIME).setVisible(false).\n                extendsFrom(provideCompileConfiguration);\n        configurationContainer.get(JavaPlugin.COMPILE).extendsFrom(provideCompileConfiguration);\n        configurationContainer.get(JavaPlugin.RUNTIME).extendsFrom(provideRuntimeConfiguration);\n    }","id":51404,"modified_method":"public void configureConfigurations(ConfigurationContainer configurationContainer) {\n        Configuration provideCompileConfiguration = configurationContainer.add(PROVIDED_COMPILE).setVisible(false).\n                setDescription(\"Additional compile classpath for libraries that should not be part of the war archive.\");\n        Configuration provideRuntimeConfiguration = configurationContainer.add(PROVIDED_RUNTIME).setVisible(false).\n                extendsFrom(provideCompileConfiguration).\n                setDescription(\"Additional runtime classpath for libraries that should not be part of the war archive.\");\n        configurationContainer.get(JavaPlugin.COMPILE).extendsFrom(provideCompileConfiguration);\n        configurationContainer.get(JavaPlugin.RUNTIME).extendsFrom(provideRuntimeConfiguration);\n    }","commit_id":"a9a0489249d42667ed70de33367e863a7ea42aa6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\r\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\r\n\t\tability.setSourceId(this.getSourceId());\r\n\t\tif (ability.checkTrigger(event, game)) {\r\n\t\t\treturn condition.apply(game, this);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":51405,"modified_method":"@Override\r\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\r\n\t\tability.setSourceId(this.getSourceId());\r\n\t\tif (ability.checkTrigger(event, game)) {\r\n\t\t\tif (condition.apply(game, this)) {\r\n\t\t\t\tthis.targets.clear();\r\n\t\t\t\tthis.targets.addAll(ability.getTargets());\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"333562f72127a0f4cbdbaa082aa287551b8ecf0b","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\n\t\tif (event.getType() == EventType.DAMAGED_PLAYER && event.getSourceId().equals(this.sourceId)) {\n\t\t\tthis.addTarget(new TargetPlayer());\n\t\t\tthis.targets.get(0).add(event.getPlayerId(), game);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":51406,"modified_method":"@Override\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\n\t\tif (event.getType() == EventType.DAMAGED_PLAYER && event.getSourceId().equals(this.sourceId)) {\n\t\t\tthis.targets.clear();\n\t\t\tthis.addTarget(new TargetPlayer());\n\t\t\tthis.targets.get(0).add(event.getPlayerId(), game);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"333562f72127a0f4cbdbaa082aa287551b8ecf0b","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tCard card;\n\t\tfor (int i = 0; i < amount; i++) {\n\t\t\tcard = player.getLibrary().removeFromTop(game);\n\t\t\tif (card != null)\n\t\t\t\tplayer.getGraveyard().add(card);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}","id":51407,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tif (player != null) {\n\t\t\tfor (int i = 0; i < amount; i++) {\n\t\t\t\tCard card = player.getLibrary().removeFromTop(game);\n\t\t\t\tif (card != null)\n\t\t\t\t\tplayer.getGraveyard().add(card);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"333562f72127a0f4cbdbaa082aa287551b8ecf0b","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player targetPlayer = game.getPlayer(this.getTargetPointer().getFirst(game, source));\r\n        boolean colorShared;\r\n        if (targetPlayer != null) {\r\n            int possibleIterations = targetPlayer.getLibrary().size() / 2;\r\n            int iteration = 0;\r\n            do {\r\n                iteration++;\r\n                if (iteration > possibleIterations + 20) {\r\n                    // 801.16. If the game somehow enters a \"loop\" of mandatory actions, repeating a sequence of events\r\n                    // with no way to stop, the game is a draw for each player who controls an object that's involved in\r\n                    // that loop, as well as for each player within the range of influence of any of those players. They\r\n                    // leave the game. All remaining players continue to play the game.\r\n                    game.setDraw(source.getControllerId());\r\n                    return true;\r\n                }\r\n                colorShared = false;\r\n                Card card1 = targetPlayer.getLibrary().removeFromTop(game);\r\n                if (card1 != null) {\r\n                    targetPlayer.moveCardToGraveyardWithInfo(card1, source.getSourceId(), game, Zone.LIBRARY);\r\n                    Card card2 = targetPlayer.getLibrary().removeFromTop(game);\r\n                    if (card2 != null) {\r\n                        targetPlayer.moveCardToGraveyardWithInfo(card2, source.getSourceId(), game, Zone.LIBRARY);  \r\n                        if (card1.getColor().hasColor() && card2.getColor().hasColor()) {\r\n                            colorShared = card1.getColor().shares(card2.getColor());\r\n                        }\r\n                    }                    \r\n                }                \r\n            } while (colorShared && targetPlayer.isInGame());\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":51408,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player targetPlayer = game.getPlayer(this.getTargetPointer().getFirst(game, source));\r\n        boolean colorShared;\r\n        if (targetPlayer != null) {\r\n            int possibleIterations = targetPlayer.getLibrary().size() / 2;\r\n            int iteration = 0;\r\n            do {\r\n                iteration++;\r\n                if (iteration > possibleIterations + 20) {\r\n                    // 801.16. If the game somehow enters a \"loop\" of mandatory actions, repeating a sequence of events\r\n                    // with no way to stop, the game is a draw for each player who controls an object that's involved in\r\n                    // that loop, as well as for each player within the range of influence of any of those players. They\r\n                    // leave the game. All remaining players continue to play the game.\r\n                    game.setDraw(source.getControllerId());\r\n                    return true;\r\n                }\r\n                colorShared = false;\r\n                Card card1 = null;\r\n                Card card2 = null;\r\n                if (targetPlayer.getLibrary().size() > 0) {\r\n                    card1 = targetPlayer.getLibrary().removeFromTop(game);                    \r\n                    if (targetPlayer.getLibrary().size() > 0) {\r\n                        card2 = targetPlayer.getLibrary().removeFromTop(game);                                        \r\n                        if (card1.getColor().hasColor() && card2.getColor().hasColor()) {\r\n                            colorShared = card1.getColor().shares(card2.getColor());\r\n                        }                    \r\n                    }\r\n                }\r\n                if (card1 != null) {\r\n                    targetPlayer.moveCardToGraveyardWithInfo(card1, source.getSourceId(), game, Zone.LIBRARY);\r\n                }\r\n                if (card2 != null) {\r\n                    targetPlayer.moveCardToGraveyardWithInfo(card2, source.getSourceId(), game, Zone.LIBRARY);  \r\n                }\r\n            } while (colorShared && targetPlayer.isInGame());\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"7529d6f20712e9c1d337512d019533ceb11280f2","url":"https://github.com/magefree/mage"},{"original_method":"/**\r\n     * Tests that instead of one spore counter there were two spore counters added to Pallid Mycoderm\r\n     * if Doubling Season is on the battlefield.\r\n     */\r\n    @Test\r\n    public void testGrindstoneTest() {\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n        // As Painter's Servant enters the battlefield, choose a color.\r\n        // All cards that aren't on the battlefield, spells, and permanents are the chosen color in addition to their other colors.\r\n        addCard(Zone.HAND, playerA, \"Painter's Servant\");\r\n        // {3}, {T}: Target player puts the top two cards of his or her library into his or her graveyard. If both cards share a color, repeat this process.\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Grindstone\");\r\n\r\n        addCard(Zone.LIBRARY, playerA, \"Progenitus\", 2);\r\n        skipInitShuffling();\r\n\r\n        castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Painter's Servant\");\r\n        setChoice(playerA, \"Blue\");\r\n\r\n        activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{3},{T}: Target player puts the top two cards of his or her library into his or her graveyard. If both cards share a color, repeat this process.\");\r\n\r\n        setStopAt(1, PhaseStep.END_TURN);\r\n        execute();\r\n        \r\n        assertPermanentCount(playerA, \"Painter's Servant\", 1);\r\n    }","id":51409,"modified_method":"/**\r\n     * Tests that Grindstone mills all cards to graveyard while Painter's Servant is in play\r\n     * Iterating with two Progenius for a draw\r\n     */\r\n    @Test\r\n    public void testGrindstoneUlamog() {\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n        // As Painter's Servant enters the battlefield, choose a color.\r\n        // All cards that aren't on the battlefield, spells, and permanents are the chosen color in addition to their other colors.\r\n        addCard(Zone.HAND, playerA, \"Painter's Servant\");\r\n        // {3}, {T}: Target player puts the top two cards of his or her library into his or her graveyard. If both cards share a color, repeat this process.\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Grindstone\");\r\n\r\n        // When you cast Ulamog, the Infinite Gyre, destroy target permanent.\r\n        // Annihilator 4 (Whenever this creature attacks, defending player sacrifices four permanents.)\r\n        // Ulamog is indestructible.\r\n        // When Ulamog is put into a graveyard from anywhere, its owner shuffles his or her graveyard into his or her library.\r\n        addCard(Zone.LIBRARY, playerB, \"Ulamog, the Infinite Gyre\", 2);\r\n        skipInitShuffling();\r\n\r\n        castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Painter's Servant\");\r\n        setChoice(playerA, \"Blue\");\r\n\r\n        activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{3},{T}: Target player puts the top two cards of his or her library into his or her graveyard. If both cards share a color, repeat this process.\");\r\n        addTarget(playerA, playerB);\r\n\r\n        setStopAt(1, PhaseStep.END_TURN);\r\n        execute();\r\n        \r\n        // No cards in graveyard because Ulamog shuffle all cards back to Lib\r\n        assertGraveyardCount(playerB, 0);\r\n        assertPermanentCount(playerA, \"Painter's Servant\", 1);\r\n    }","commit_id":"7529d6f20712e9c1d337512d019533ceb11280f2","url":"https://github.com/magefree/mage"},{"original_method":"public Progenitus(UUID ownerId) {\n        super(ownerId, 121, \"Progenitus\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{W}{W}{U}{U}{B}{B}{R}{R}{G}{G}\");\n        this.expansionSetCode = \"CON\";\n        this.supertype.add(\"Legendary\");\n        this.subtype.add(\"Hydra\");\n        this.subtype.add(\"Avatar\");\n\n        this.color.setRed(true);\n        this.color.setBlue(true);\n        this.color.setGreen(true);\n        this.color.setBlack(true);\n        this.color.setWhite(true);\n        this.power = new MageInt(10);\n        this.toughness = new MageInt(10);\n\n        //     2/1/2009: \"Protection from everything\" means the following: Progenitus can't be blocked,\n        //               Progenitus can't be enchanted or equipped, Progenitus can't be the target of\n        //               spells or abilities, and all damage that would be dealt to Progenitus is prevented.\n        //     2/1/2009: Progenitus can still be affected by effects that don't target it or deal damage\n        //               to it (such as Day of Judgment).\n        \n        // Protection from everything\n        this.addAbility(new ProgenitusProtectionAbility());\n        // If Progenitus would be put into a graveyard from anywhere, reveal Progenitus and shuffle it into its owner's library instead.\n        this.addAbility(new PutIntoGraveFromAnywhereSourceAbility(new RevealAndShuffleIntoLibrarySourceEffect()));\n    }","id":51410,"modified_method":"public Progenitus(UUID ownerId) {\n        super(ownerId, 121, \"Progenitus\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{W}{W}{U}{U}{B}{B}{R}{R}{G}{G}\");\n        this.expansionSetCode = \"CON\";\n        this.supertype.add(\"Legendary\");\n        this.subtype.add(\"Hydra\");\n        this.subtype.add(\"Avatar\");\n\n        this.power = new MageInt(10);\n        this.toughness = new MageInt(10);\n\n        //     2/1/2009: \"Protection from everything\" means the following: Progenitus can't be blocked,\n        //               Progenitus can't be enchanted or equipped, Progenitus can't be the target of\n        //               spells or abilities, and all damage that would be dealt to Progenitus is prevented.\n        //     2/1/2009: Progenitus can still be affected by effects that don't target it or deal damage\n        //               to it (such as Day of Judgment).\n        \n        // Protection from everything\n        this.addAbility(new ProgenitusProtectionAbility());\n        // If Progenitus would be put into a graveyard from anywhere, reveal Progenitus and shuffle it into its owner's library instead.\n        this.addAbility(new PutIntoGraveFromAnywhereSourceAbility(new RevealAndShuffleIntoLibrarySourceEffect()));\n    }","commit_id":"7529d6f20712e9c1d337512d019533ceb11280f2","url":"https://github.com/magefree/mage"},{"original_method":"private DomainModel build( String projectId, File pomFile, ProjectBuilderConfiguration projectBuilderConfiguration )\n        throws ProjectBuildingException, IOException\n    {\n        DomainModel domainModel = new DomainModel( pomFile );\n        domainModel.setProjectDirectory( pomFile.getParentFile() );\n        domainModel.setMostSpecialized( true );\n\n        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n\n        domainModels.add( domainModel );\n        ArtifactRepository localRepository = projectBuilderConfiguration.getLocalRepository();\n        List<ArtifactRepository> remoteRepositories = projectBuilderConfiguration.getRemoteRepositories();\n\n        File parentFile = null;\n        int lineageCount = 0;\n        if ( domainModel.getParentId() != null )\n        {\n            List<DomainModel> mavenParents;\n            \n            if ( isParentLocal( domainModel.getRelativePathOfParent(), pomFile.getParentFile() ) )\n            {\n                mavenParents = getDomainModelParentsFromLocalPath( domainModel, localRepository, remoteRepositories, pomFile.getParentFile(), projectBuilderConfiguration );\n            }\n            else\n            {\n                mavenParents = getDomainModelParentsFromRepository( domainModel, localRepository, remoteRepositories );\n            }\n\n            if ( mavenParents.size() > 0 )\n            {\n                DomainModel dm = mavenParents.get( 0 );\n                parentFile = dm.getFile();\n                domainModel.setParentFile( parentFile );\n                lineageCount = mavenParents.size();\n            }\n\n            domainModels.addAll( mavenParents );\n        }\n\n        for ( DomainModel domain : domainModels )\n        {\n            normalizer.mergeDuplicates( domain.getModel() );\n        }\n\n        domainModels.add( new DomainModel( getSuperModel(), false ) );\n        List<DomainModel> profileModels = new ArrayList<DomainModel>();\n        //Process Profiles\n        for ( DomainModel domain : domainModels )\n        {\n            DomainModel dm = domain;\n\n            if ( !dm.getModel().getProfiles().isEmpty() )\n            {\n                Collection<Profile> profiles;\n                try\n                {\n                    profiles =\n                        profileSelector.getActiveProfiles( dm.getModel().getProfiles(), projectBuilderConfiguration );\n                }\n                catch ( ProfileActivationException e )\n                {\n                    throw new ProjectBuildingException( projectId, \"Failed to determine active profiles\", pomFile, e );\n                }\n                if ( !profiles.isEmpty() )\n                {\n                    for ( Profile p : profiles )\n                    {\n                        logger.debug( \"Merging profile into model: Model = \" + dm.getId() + \", Profile = \" + p.getId() );\n                    }\n                    profileModels.add( ProcessorContext.mergeProfilesIntoModel( profiles, dm ) );\n                }\n                else\n                {\n                    profileModels.add( dm );\n                }\n            }\n            else\n            {\n                profileModels.add( dm );\n            }\n        }\n\n        DomainModel transformedDomainModel = ProcessorContext.build( profileModels, listeners );\n\n        // Lineage count is inclusive to add the POM read in itself.\n        transformedDomainModel.setLineageCount( lineageCount + 1 );\n        transformedDomainModel.setParentFile( parentFile );\n\n        return transformedDomainModel;\n    }","id":51411,"modified_method":"private DomainModel build( String projectId, File pomFile, ProjectBuilderConfiguration projectBuilderConfiguration )\n        throws ProjectBuildingException, IOException\n    {\n        DomainModel domainModel = new DomainModel( pomFile );\n        domainModel.setProjectDirectory( pomFile.getParentFile() );\n        domainModel.setMostSpecialized( true );\n\n        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n\n        domainModels.add( domainModel );\n\n        ArtifactRepository localRepository = projectBuilderConfiguration.getLocalRepository();\n\n        List<ArtifactRepository> remoteRepositories = new ArrayList<ArtifactRepository>();\n        try\n        {\n            for ( Profile profile : profileSelector.getActiveProfiles( projectBuilderConfiguration.getProfiles(),\n                                                                       projectBuilderConfiguration ) )\n            {\n                for ( Repository repository : profile.getRepositories() )\n                {\n                    try\n                    {\n                        remoteRepositories.add( repositorySystem.buildArtifactRepository( repository ) );\n                    }\n                    catch ( InvalidRepositoryException e )\n                    {\n                        throw new ProjectBuildingException( projectId, \"Failed to create remote repository \"\n                            + repository, pomFile, e );\n                    }\n                }\n            }\n            remoteRepositories = repositorySystem.getMirrors( remoteRepositories );\n        }\n        catch ( ProfileActivationException e )\n        {\n            throw new ProjectBuildingException( projectId, \"Failed to determine active profiles\", pomFile, e );\n        }\n        remoteRepositories.addAll( projectBuilderConfiguration.getRemoteRepositories() );\n\n        File parentFile = null;\n        int lineageCount = 0;\n        if ( domainModel.getParentId() != null )\n        {\n            List<DomainModel> mavenParents;\n            \n            if ( isParentLocal( domainModel.getRelativePathOfParent(), pomFile.getParentFile() ) )\n            {\n                mavenParents = getDomainModelParentsFromLocalPath( domainModel, localRepository, remoteRepositories, pomFile.getParentFile(), projectBuilderConfiguration );\n            }\n            else\n            {\n                mavenParents = getDomainModelParentsFromRepository( domainModel, localRepository, remoteRepositories );\n            }\n\n            if ( mavenParents.size() > 0 )\n            {\n                DomainModel dm = mavenParents.get( 0 );\n                parentFile = dm.getFile();\n                domainModel.setParentFile( parentFile );\n                lineageCount = mavenParents.size();\n            }\n\n            domainModels.addAll( mavenParents );\n        }\n\n        for ( DomainModel domain : domainModels )\n        {\n            normalizer.mergeDuplicates( domain.getModel() );\n        }\n\n        domainModels.add( new DomainModel( getSuperModel(), false ) );\n        List<DomainModel> profileModels = new ArrayList<DomainModel>();\n        //Process Profiles\n        for ( DomainModel domain : domainModels )\n        {\n            DomainModel dm = domain;\n\n            if ( !dm.getModel().getProfiles().isEmpty() )\n            {\n                Collection<Profile> profiles;\n                try\n                {\n                    profiles =\n                        profileSelector.getActiveProfiles( dm.getModel().getProfiles(), projectBuilderConfiguration );\n                }\n                catch ( ProfileActivationException e )\n                {\n                    throw new ProjectBuildingException( projectId, \"Failed to determine active profiles\", pomFile, e );\n                }\n                if ( !profiles.isEmpty() )\n                {\n                    for ( Profile p : profiles )\n                    {\n                        logger.debug( \"Merging profile into model: Model = \" + dm.getId() + \", Profile = \" + p.getId() );\n                    }\n                    profileModels.add( ProcessorContext.mergeProfilesIntoModel( profiles, dm ) );\n                }\n                else\n                {\n                    profileModels.add( dm );\n                }\n            }\n            else\n            {\n                profileModels.add( dm );\n            }\n        }\n\n        DomainModel transformedDomainModel = ProcessorContext.build( profileModels, listeners );\n\n        // Lineage count is inclusive to add the POM read in itself.\n        transformedDomainModel.setLineageCount( lineageCount + 1 );\n        transformedDomainModel.setParentFile( parentFile );\n\n        return transformedDomainModel;\n    }","commit_id":"49b8b62ef11cd43239cac116c2d34833e97e4d6c","url":"https://github.com/apache/maven"},{"original_method":"private void scheduleUpdateIndicesList() {\n    myUpdateQueue.queue(new Update(MavenProjectIndicesManager.this) {\n      public void run() {\n        List<MavenIndex> newIndices = MavenIndicesManager.getInstance().ensureIndicesExist(\n          myProject, getLocalRepository(), collectRemoteRepositoriesIdsAndUrls());\n        myProjectIndices = newIndices;\n      }\n    });\n  }","id":51412,"modified_method":"private void scheduleUpdateIndicesList() {\n    scheduleUpdateIndicesList(null);\n  }","commit_id":"c68c3a6ace05ae626ed06b8b6f81743e41c39e43","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Set<Pair<String, String>> collectRemoteRepositoriesIdsAndUrls() {\n    Set<Pair<String, String>> result = new THashSet<Pair<String, String>>();\n    for (MavenRemoteRepository each : getMavenProjectManager().getRemoteRepositories()) {\n      String id = each.getId();\n      String url = each.getUrl();\n\n      result.add(Pair.create(id, url));\n    }\n    return result;\n  }","id":51413,"modified_method":"private Set<Pair<String, String>> collectRemoteRepositoriesIdsAndUrls() {\n    Set<Pair<String, String>> result = new THashSet<Pair<String, String>>();\n    Set<MavenRemoteRepository> remoteRepositories = ContainerUtil.newHashSet(getMavenProjectManager().getRemoteRepositories());\n    for (MavenRepositoryProvider repositoryProvider : MavenRepositoryProvider.EP_NAME.getExtensions()) {\n      ContainerUtil.addAll(remoteRepositories, repositoryProvider.getRemoteRepositories(myProject));\n    }\n    for (MavenRemoteRepository each : remoteRepositories) {\n      String id = each.getId();\n      String url = each.getUrl();\n\n      result.add(Pair.create(id, url));\n    }\n    return result;\n  }","commit_id":"c68c3a6ace05ae626ed06b8b6f81743e41c39e43","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void configureResolver( ModelResolver modelResolver, Model model, DefaultModelProblemCollector problems )\n    {\n        if ( modelResolver == null )\n        {\n            return;\n        }\n\n        problems.setSource( model );\n\n        List<Repository> repositories = model.getRepositories();\n        Collections.reverse( repositories );\n\n        for ( Repository repository : repositories )\n        {\n            try\n            {\n                modelResolver.addRepository( repository );\n            }\n            catch ( InvalidRepositoryException e )\n            {\n                problems.addError( \"Invalid repository \" + repository.getId() + \": \" + e.getMessage(), e );\n            }\n        }\n    }","id":51414,"modified_method":"private void configureResolver( ModelResolver modelResolver, Model model, DefaultModelProblemCollector problems )\n    {\n        if ( modelResolver == null )\n        {\n            return;\n        }\n\n        problems.setSource( model );\n\n        List<Repository> repositories = model.getRepositories();\n\n        for ( Repository repository : repositories )\n        {\n            try\n            {\n                modelResolver.addRepository( repository );\n            }\n            catch ( InvalidRepositoryException e )\n            {\n                problems.addError( \"Invalid repository \" + repository.getId() + \": \" + e.getMessage(), e );\n            }\n        }\n    }","commit_id":"fce4db9c9c292d492ac84a49af1c2a9adc21ac83","url":"https://github.com/apache/maven"},{"original_method":"public RepositoryModelResolver( RepositorySystem repositorySystem, ResolutionErrorHandler resolutionErrorHandler,\n                                    ProjectBuildingRequest projectBuildingRequest, ReactorModelPool reactorModelPool )\n    {\n        if ( repositorySystem == null )\n        {\n            throw new IllegalArgumentException( \"no repository system specified\" );\n        }\n        this.repositorySystem = repositorySystem;\n\n        if ( resolutionErrorHandler == null )\n        {\n            throw new IllegalArgumentException( \"no resolution error handler specified\" );\n        }\n        this.resolutionErrorHandler = resolutionErrorHandler;\n\n        if ( projectBuildingRequest == null )\n        {\n            throw new IllegalArgumentException( \"no project building request specified\" );\n        }\n        this.projectBuildingRequest = projectBuildingRequest;\n\n        if ( projectBuildingRequest.getRemoteRepositories() == null )\n        {\n            throw new IllegalArgumentException( \"no remote repositories specified\" );\n        }\n        this.remoteRepositories = new ArrayList<ArtifactRepository>( projectBuildingRequest.getRemoteRepositories() );\n\n        this.reactorModelPool = reactorModelPool;\n    }","id":51415,"modified_method":"public RepositoryModelResolver( RepositorySystem repositorySystem, ResolutionErrorHandler resolutionErrorHandler,\n                                    ProjectBuildingRequest projectBuildingRequest, ReactorModelPool reactorModelPool )\n    {\n        if ( repositorySystem == null )\n        {\n            throw new IllegalArgumentException( \"no repository system specified\" );\n        }\n        this.repositorySystem = repositorySystem;\n\n        if ( resolutionErrorHandler == null )\n        {\n            throw new IllegalArgumentException( \"no resolution error handler specified\" );\n        }\n        this.resolutionErrorHandler = resolutionErrorHandler;\n\n        if ( projectBuildingRequest == null )\n        {\n            throw new IllegalArgumentException( \"no project building request specified\" );\n        }\n        this.projectBuildingRequest = projectBuildingRequest;\n\n        this.remoteRepositories = new ArrayList<ArtifactRepository>();\n        if ( projectBuildingRequest.getRemoteRepositories() != null )\n        {\n            this.remoteRepositories.addAll( projectBuildingRequest.getRemoteRepositories() );\n        }\n\n        this.repositoryIds = new HashSet<String>();\n\n        this.reactorModelPool = reactorModelPool;\n    }","commit_id":"fce4db9c9c292d492ac84a49af1c2a9adc21ac83","url":"https://github.com/apache/maven"},{"original_method":"public void addRepository( Repository repository )\n        throws InvalidRepositoryException\n    {\n        try\n        {\n            ArtifactRepository repo = repositorySystem.buildArtifactRepository( repository );\n\n            repositorySystem.injectMirror( Arrays.asList( repo ), projectBuildingRequest.getMirrors() );\n\n            repositorySystem.injectProxy( Arrays.asList( repo ), projectBuildingRequest.getProxies() );\n\n            repositorySystem.injectAuthentication( Arrays.asList( repo ), projectBuildingRequest.getServers() );\n\n            remoteRepositories.add( 0, repo );\n\n            remoteRepositories = repositorySystem.getEffectiveRepositories( remoteRepositories );\n        }\n        catch ( Exception e )\n        {\n            throw new InvalidRepositoryException( e.getMessage(), repository, e );\n        }\n    }","id":51416,"modified_method":"public void addRepository( Repository repository )\n        throws InvalidRepositoryException\n    {\n        if ( !repositoryIds.add( repository.getId() ) )\n        {\n            return;\n        }\n\n        try\n        {\n            ArtifactRepository repo = repositorySystem.buildArtifactRepository( repository );\n\n            repositorySystem.injectMirror( Arrays.asList( repo ), projectBuildingRequest.getMirrors() );\n\n            repositorySystem.injectProxy( Arrays.asList( repo ), projectBuildingRequest.getProxies() );\n\n            repositorySystem.injectAuthentication( Arrays.asList( repo ), projectBuildingRequest.getServers() );\n\n            remoteRepositories.add( repo );\n\n            remoteRepositories = repositorySystem.getEffectiveRepositories( remoteRepositories );\n        }\n        catch ( Exception e )\n        {\n            throw new InvalidRepositoryException( e.getMessage(), repository, e );\n        }\n    }","commit_id":"fce4db9c9c292d492ac84a49af1c2a9adc21ac83","url":"https://github.com/apache/maven"},{"original_method":"public ModelResolver newCopy()\n    {\n        return new RepositoryModelResolver( repositorySystem, resolutionErrorHandler, projectBuildingRequest,\n                                            reactorModelPool );\n    }","id":51417,"modified_method":"public ModelResolver newCopy()\n    {\n        return new RepositoryModelResolver( this );\n    }","commit_id":"fce4db9c9c292d492ac84a49af1c2a9adc21ac83","url":"https://github.com/apache/maven"},{"original_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    Module module = ModuleUtil.findModuleForPsiElement(myElement);\n    if (module != null) {\n      String name = TemplateManager.getRelativeName(module, (DjangoTemplateFileImpl)element);\n      if (name != null) {\n        return myElement.replace(PyElementGenerator.getInstance(myElement.getProject()).createStringLiteralFromString(name));\n      }\n    }\n    return myElement;\n  }","id":51418,"modified_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    Module module = ModuleUtil.findModuleForPsiElement(myElement);\n    if (module != null) {\n      String name = DjangoTemplateManager.getRelativeName(module, (DjangoTemplateFileImpl)element);\n      if (name != null) {\n        return myElement.replace(PyElementGenerator.getInstance(myElement.getProject()).createStringLiteralFromString(name));\n      }\n    }\n    return myElement;\n  }","commit_id":"bf1143ba518b47c85a32d53edce75d4f0b6d4cbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<PsiFileSystemItem> computeDefaultContexts() {\n    final PsiFile file = getContainingFile();\n    if (file != null) {\n\n      if (isAbsolutePathReference() && !ApplicationManager.getApplication().isUnitTestMode()) {\n        VirtualFile root = LocalFileSystem.getInstance().getRoot();\n        PsiDirectory directory = file.getManager().findDirectory(root);\n        if (directory != null) {\n          return Lists.<PsiFileSystemItem>newArrayList(directory);\n        }\n      }\n      else {\n        return super.computeDefaultContexts();\n      }\n    }\n\n    return Collections.emptyList();\n  }","id":51419,"modified_method":"@NotNull\n  @Override\n  public Collection<PsiFileSystemItem> computeDefaultContexts() {\n    final PsiFile file = getContainingFile();\n    if (file != null) {\n\n      if (isAbsolutePathReference()) {\n        if (!ApplicationManager.getApplication().isUnitTestMode()) {\n          VirtualFile root = LocalFileSystem.getInstance().getRoot();\n          PsiDirectory directory = file.getManager().findDirectory(root);\n          if (directory != null) {\n            return Lists.<PsiFileSystemItem>newArrayList(directory);\n          }\n        }\n        else {\n          return Lists.newArrayList();\n        }\n      }\n      else {\n        return super.computeDefaultContexts();\n      }\n    }\n\n    return Collections.emptyList();\n  }","commit_id":"bf1143ba518b47c85a32d53edce75d4f0b6d4cbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TemplateFileReference(@NotNull FileReferenceSet fileReferenceSet, TextRange range, int index, String text) {\n    super(fileReferenceSet, range, index, text);\n    myReferenceSet = fileReferenceSet;\n  }","id":51420,"modified_method":"public TemplateFileReference(@NotNull FileReferenceSet fileReferenceSet, TextRange range, int index, String text) {\n    super(fileReferenceSet, range, index, text);\n  }","commit_id":"bf1143ba518b47c85a32d53edce75d4f0b6d4cbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element, boolean absolute) throws IncorrectOperationException {\n    if (!(element instanceof PsiFileSystemItem)) {\n      throw new IncorrectOperationException(\"Cannot bind to element, should be instanceof PsiFileSystemItem: \" + element);\n    }\n\n    final PsiFileSystemItem fileSystemItem = (PsiFileSystemItem)element;\n    VirtualFile dstVFile = fileSystemItem.getVirtualFile();\n    if (dstVFile == null) throw new IncorrectOperationException(\"Cannot bind to non-physical element:\" + element);\n\n    PsiFile file = getElement().getContainingFile();\n    PsiElement contextPsiFile = InjectedLanguageManager.getInstance(file.getProject()).getInjectionHost(file);\n    if (contextPsiFile != null) file = contextPsiFile.getContainingFile(); // use host file!\n    final VirtualFile curVFile = file.getVirtualFile();\n    if (curVFile == null) throw new IncorrectOperationException(\"Cannot bind from non-physical element:\" + file);\n\n    final Project project = element.getProject();\n\n    String newName;\n\n    PsiFileSystemItem curItem = null;\n    PsiFileSystemItem dstItem = null;\n\n    final FileReferenceHelper helper = FileReferenceHelperRegistrar.getNotNullHelper(file);\n\n    PsiFileSystemItem _dstItem = helper.getPsiFileSystemItem(project, dstVFile);\n    PsiFileSystemItem _curItem = helper.getPsiFileSystemItem(project, curVFile);\n    if (_dstItem != null && _curItem != null) {\n      curItem = _curItem;\n      dstItem = _dstItem;\n    }\n\n    final Collection<PsiFileSystemItem> contexts = myReferenceSet.getDefaultContexts();\n    switch (contexts.size()) {\n      case 0:\n        break;\n      default:\n        for (PsiFileSystemItem context : contexts) {\n          final VirtualFile contextFile = context.getVirtualFile();\n          assert contextFile != null;\n          if (VfsUtil.isAncestor(contextFile, dstVFile, true)) {\n            final String path = VfsUtilCore.getRelativePath(dstVFile, contextFile, '/');\n            if (path != null) {\n              return rename(path.replace(\"/\", myReferenceSet.getSeparatorString()));\n            }\n          }\n        }\n    }\n    if (curItem == null) {\n      throw new IncorrectOperationException(\"Cannot find path between files; \" +\n                                            \"src = \" + curVFile.getPresentableUrl() + \"; \" +\n                                            \"dst = \" + dstVFile.getPresentableUrl() + \"; \" +\n                                            \"Contexts: \" + contexts);\n    }\n    if (curItem.equals(dstItem)) {\n      if (getCanonicalText().equals(dstItem.getName())) {\n        return getElement();\n      }\n      return ElementManipulators.getManipulator(getElement()).handleContentChange(getElement(), getRangeInElement(), file.getName());\n    }\n    newName = PsiFileSystemItemUtil.getRelativePath(curItem, dstItem);\n    if (newName == null) {\n      return getElement();\n    }\n\n    return rename(newName);\n  }","id":51421,"modified_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element, boolean absolute) throws IncorrectOperationException {\n    if (!(element instanceof PsiFileSystemItem)) {\n      throw new IncorrectOperationException(\"Cannot bind to element, should be instanceof PsiFileSystemItem: \" + element);\n    }\n\n    final PsiFileSystemItem fileSystemItem = (PsiFileSystemItem)element;\n    VirtualFile dstVFile = fileSystemItem.getVirtualFile();\n    if (dstVFile == null) throw new IncorrectOperationException(\"Cannot bind to non-physical element:\" + element);\n\n    PsiFile file = getElement().getContainingFile();\n    PsiElement contextPsiFile = InjectedLanguageManager.getInstance(file.getProject()).getInjectionHost(file);\n    if (contextPsiFile != null) file = contextPsiFile.getContainingFile(); // use host file!\n    final VirtualFile curVFile = file.getVirtualFile();\n    if (curVFile == null) throw new IncorrectOperationException(\"Cannot bind from non-physical element:\" + file);\n\n    final Project project = element.getProject();\n\n    String newName;\n\n    PsiFileSystemItem curItem = null;\n    PsiFileSystemItem dstItem = null;\n\n    final FileReferenceHelper helper = FileReferenceHelperRegistrar.getNotNullHelper(file);\n\n    PsiFileSystemItem _dstItem = helper.getPsiFileSystemItem(project, dstVFile);\n    PsiFileSystemItem _curItem = helper.getPsiFileSystemItem(project, curVFile);\n    if (_dstItem != null && _curItem != null) {\n      curItem = _curItem;\n      dstItem = _dstItem;\n    }\n\n    final Collection<PsiFileSystemItem> contexts = getFileReferenceSet().getDefaultContexts();\n    switch (contexts.size()) {\n      case 0:\n        break;\n      default:\n        for (PsiFileSystemItem context : contexts) {\n          final VirtualFile contextFile = context.getVirtualFile();\n          assert contextFile != null;\n          if (VfsUtil.isAncestor(contextFile, dstVFile, true)) {\n            final String path = VfsUtilCore.getRelativePath(dstVFile, contextFile, '/');\n            if (path != null) {\n              return rename(path.replace(\"/\", getFileReferenceSet().getSeparatorString()));\n            }\n          }\n        }\n    }\n    if (curItem == null) {\n      throw new IncorrectOperationException(\"Cannot find path between files; \" +\n                                            \"src = \" + curVFile.getPresentableUrl() + \"; \" +\n                                            \"dst = \" + dstVFile.getPresentableUrl() + \"; \" +\n                                            \"Contexts: \" + contexts);\n    }\n    if (curItem.equals(dstItem)) {\n      if (getCanonicalText().equals(dstItem.getName())) {\n        return getElement();\n      }\n      return ElementManipulators.getManipulator(getElement()).handleContentChange(getElement(), getRangeInElement(), file.getName());\n    }\n    newName = PsiFileSystemItemUtil.getRelativePath(curItem, dstItem);\n    if (newName == null) {\n      return getElement();\n    }\n\n    return rename(newName);\n  }","commit_id":"bf1143ba518b47c85a32d53edce75d4f0b6d4cbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAbsolutePathReference() {\n    return super.isAbsolutePathReference() || new File(getPathString()).isAbsolute();\n  }","id":51422,"modified_method":"public boolean isAbsolutePathReference() {\n    if (super.isAbsolutePathReference()) {\n      return true;\n    }\n    final String pathString = getPathString();\n    if (SystemInfo.isWindows && pathString.length() == 2 && Character.isLetter(pathString.charAt(0)) && pathString.charAt(1) == ':') {\n      return true;\n    }\n    return new File(pathString).isAbsolute();\n  }","commit_id":"79bd4fd3e085ede73e64d66bcd991c985344f9cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Collection<PsiFileSystemItem> computeDefaultContexts() {\n    final AntStructuredElement element = getElement();\n    final AntFile antFile = element.getAntFile();\n    if (antFile != null) {\n      VirtualFile vFile = antFile.getContainingPath();\n\n      if (!(element instanceof AntImport)) {\n        final String basedir = element.computeAttributeValue(\"${basedir}\");\n        assert basedir != null;\n        vFile = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(basedir));\n      }\n\n      if (vFile != null) {\n        final PsiDirectory directory = antFile.getViewProvider().getManager().findDirectory(vFile);\n        if (directory != null) {\n          return Collections.<PsiFileSystemItem>singleton(directory);\n        }\n      }\n    }\n    return super.computeDefaultContexts();\n  }","id":51423,"modified_method":"@NotNull\n  public Collection<PsiFileSystemItem> computeDefaultContexts() {\n    final AntStructuredElement element = getElement();\n    final AntFile antFile = element.getAntFile();\n    if (antFile != null) {\n      VirtualFile vFile = antFile.getContainingPath();\n      if (isAbsolutePathReference()) {\n        if (SystemInfo.isWindows) {\n          vFile = ManagingFS.getInstance().findRoot(\"\", LocalFileSystem.getInstance());\n        }    \n        else {\n          vFile = LocalFileSystem.getInstance().findFileByPath(\"/\");\n        }\n      }\n      else {\n        if (!(element instanceof AntImport)) {\n          final String basedir = element.computeAttributeValue(\"${basedir}\");\n          assert basedir != null;\n          vFile = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(basedir));\n        } \n      }\n\n      if (vFile != null) {\n        final PsiDirectory directory = antFile.getViewProvider().getManager().findDirectory(vFile);\n        if (directory != null) {\n          return Collections.<PsiFileSystemItem>singleton(directory);\n        }\n      }\n    }\n    return super.computeDefaultContexts();\n  }","commit_id":"79bd4fd3e085ede73e64d66bcd991c985344f9cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String[] list(final VirtualFile file) {\n    if (file.getParent() == null) {\n      final File[] roots = File.listRoots();\n      if (roots.length == 1 && roots[0].getName().length() == 0) {\n        return roots[0].list();\n      }\n    }\n\n    final String[] names = convertToIOFile(file).list();\n    return names != null ? names : ArrayUtil.EMPTY_STRING_ARRAY;\n  }","id":51424,"modified_method":"public String[] list(final VirtualFile file) {\n    if (file.getParent() == null) {\n      final File[] roots = File.listRoots();\n      if (roots.length == 1 && roots[0].getName().length() == 0) {\n        return roots[0].list();\n      }\n      final String[] names = new String[roots.length];\n      for (int i = 0; i < names.length; i++) {\n        String name = roots[i].getPath();\n        if (name.endsWith(File.separator)) {\n          name = name.substring(0, name.length() - File.separator.length());\n        }\n        names[i] = name;        \n      }\n      return names;\n    }\n    final String[] names = convertToIOFile(file).list();\n    return names != null ? names : ArrayUtil.EMPTY_STRING_ARRAY;\n  }","commit_id":"79bd4fd3e085ede73e64d66bcd991c985344f9cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ResolveResult[] innerResolve() {\n    final String text = getText();\n    final Collection<PsiFileSystemItem> contexts = getContexts();\n    final Collection<ResolveResult> result = new ArrayList<ResolveResult>(contexts.size());\n\n    for (final PsiFileSystemItem context : contexts) {\n      if (text.length() == 0 && !myFileReferenceSet.isEndingSlashNotAllowed() && isLast() || \".\".equals(text) || \"/\".equals(text)) {\n        result.add(new PsiElementResolveResult(context));\n      } else {\n        final FileReferenceHelper<PsiFileSystemItem> helper = FileReferenceHelperRegistrar.getHelper(context);\n        if (helper != null) {\n          if (\"..\".equals(text)) {\n            final PsiFileSystemItem resolved = helper.getParentDirectory(getElement().getProject(), context);\n            if (resolved != null) {\n              result.add(new PsiElementResolveResult(resolved));\n            }\n          } else {\n            helper.processVariants(context, new BaseScopeProcessor() {\n              public boolean execute(final PsiElement element, final PsiSubstitutor substitutor) {\n                PsiFileSystemItem item = (PsiFileSystemItem)element;\n                if (equalsTo(item.getName())) {\n                  result.add(new PsiElementResolveResult(item));\n                  return false;\n                }\n                return true;\n              }\n            });\n          }\n        }\n      }\n    }\n    final int resultCount = result.size();\n    return resultCount > 0 ? result.toArray(new ResolveResult[resultCount]) : ResolveResult.EMPTY_ARRAY;\n  }","id":51425,"modified_method":"protected ResolveResult[] innerResolve() {\n    final String text = getText();\n    final Collection<PsiFileSystemItem> contexts = getContexts();\n    final Collection<ResolveResult> result = new ArrayList<ResolveResult>(contexts.size());\n\n    for (final PsiFileSystemItem context : contexts) {\n      if (text.length() == 0 && !myFileReferenceSet.isEndingSlashNotAllowed() && isLast() || \".\".equals(text) || \"/\".equals(text)) {\n        result.add(new PsiElementResolveResult(context));\n      } else {\n        final FileReferenceHelper<PsiFileSystemItem> helper = FileReferenceHelperRegistrar.getHelper(context);\n        if (helper != null) {\n          if (\"..\".equals(text)) {\n            final PsiFileSystemItem resolved = helper.getParentDirectory(getElement().getProject(), context);\n            if (resolved != null) {\n              result.add(new PsiElementResolveResult(resolved));\n            }\n          } else {\n            helper.processVariants(context, new BaseScopeProcessor() {\n              public boolean execute(final PsiElement element, final PsiSubstitutor substitutor) {\n                final String name = ((PsiFileSystemItem)element).getName();\n                final boolean nameEquals =\n                  myFileReferenceSet.isCaseSensitive() ? getText().equals(name) : getText().compareToIgnoreCase(name) == 0;\n                if (nameEquals) {\n                  result.add(new PsiElementResolveResult(element));\n                  return false;\n                }\n                return true;\n              }\n            });\n          }\n        }\n      }\n    }\n    final int resultCount = result.size();\n    return resultCount > 0 ? result.toArray(new ResolveResult[resultCount]) : ResolveResult.EMPTY_ARRAY;\n  }","commit_id":"ecd4c6005f3525db697bf92c6e6fb54ae167cc53","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processVariants(@NotNull final PsiScopeProcessor processor) {\n    for (PsiFileSystemItem context : getContexts()) {\n      final FileReferenceHelper<PsiFileSystemItem> helper = FileReferenceHelperRegistrar.getHelper(context);\n      if (helper != null && !helper.processVariants(context, processor)) return;\n    }\n  }","id":51426,"modified_method":"private void processVariants(@NotNull final PsiScopeProcessor processor) {\n    for (PsiFileSystemItem context : getContexts()) {\n      final FileReferenceHelper<PsiFileSystemItem> helper = FileReferenceHelperRegistrar.getHelper(context);\n      if (helper != null && !helper.processVariants(context, processor)) return;\n    }\n  }","commit_id":"ecd4c6005f3525db697bf92c6e6fb54ae167cc53","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public FileReference getContextReference() {\n    return myIndex > 0 ? myFileReferenceSet.getReference(myIndex - 1) : null;\n  }","id":51427,"modified_method":"@Nullable\n  private FileReference getContextReference() {\n    return myIndex > 0 ? myFileReferenceSet.getReference(myIndex - 1) : null;\n  }","commit_id":"ecd4c6005f3525db697bf92c6e6fb54ae167cc53","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Collection<PsiFileSystemItem> getDefaultContexts(PsiElement element) {\n    Project project = element.getProject();\n    PsiFile file = element.getContainingFile();\n    if (file == null) {\n      LOG.assertTrue(false, \"Invalid element: \" + element);\n    }\n\n    if (!file.isPhysical()) file = file.getOriginalFile();\n    if (file == null) return Collections.emptyList();\n    if (myOptions != null) {\n      final Function<PsiFile, PsiFileSystemItem> value = DEFAULT_PATH_EVALUATOR_OPTION.getValue(myOptions);\n\n      if (value != null) {\n        final PsiFileSystemItem result = value.fun(file);\n        return result == null ? Collections.<PsiFileSystemItem>emptyList() : Collections.singleton(result);\n      }\n    }\n\n\n    PsiFileSystemItem result = null;\n    if (isAbsolutePathReference()) {\n      result = getAbsoluteTopLevelDirLocation(file);\n    }\n    else {\n      if (myUseIncludingJspFileAsContext) {\n        JspFile jspFile = PsiUtil.getJspFile(file);\n        if (jspFile != null) {\n          final JspContextManager manager = JspContextManager.getInstance(project);\n          JspFile contextFile = manager.getContextFile(jspFile);\n          Set<JspFile> visited = new HashSet<JspFile>();\n          while (contextFile != null && !visited.contains(jspFile)) {\n            visited.add(jspFile);\n            jspFile = contextFile;\n            contextFile = manager.getContextFile(jspFile);\n          }\n          file = jspFile;\n        }\n      }\n\n      final List<FileReferenceHelper> helpers = FileReferenceHelperRegistrar.getHelpers();\n      for (final FileReferenceHelper helper : helpers) {\n        final PsiFileSystemItem item = helper.getContainingDirectory(file);\n        if (item != null) {\n          result = item;\n          break;\n        }\n      }\n    }\n\n    return result == null ? Collections.<PsiFileSystemItem>emptyList() : Collections.singleton(result);\n  }","id":51428,"modified_method":"@NotNull\n  public Collection<PsiFileSystemItem> getDefaultContexts(PsiElement element) {\n    Project project = element.getProject();\n    PsiFile file = element.getContainingFile();\n    if (file == null) {\n      LOG.assertTrue(false, \"Invalid element: \" + element);\n    }\n\n    if (!file.isPhysical()) file = file.getOriginalFile();\n    if (file == null) return Collections.emptyList();\n    \n    if (myOptions != null) {\n      final Function<PsiFile, PsiFileSystemItem> value = DEFAULT_PATH_EVALUATOR_OPTION.getValue(myOptions);\n\n      if (value != null) {\n        final PsiFileSystemItem result = value.fun(file);\n        return result == null ? Collections.<PsiFileSystemItem>emptyList() : Collections.singleton(result);\n      }\n    }\n\n\n    PsiFileSystemItem result = null;\n    if (isAbsolutePathReference()) {\n      return ContainerUtil.createMaybeSingletonList(getAbsoluteTopLevelDirLocation(file));\n    }\n    if (myUseIncludingJspFileAsContext) {\n      JspFile jspFile = PsiUtil.getJspFile(file);\n      if (jspFile != null) {\n        final JspContextManager manager = JspContextManager.getInstance(project);\n        JspFile contextFile = manager.getContextFile(jspFile);\n        Set<JspFile> visited = new HashSet<JspFile>();\n        while (contextFile != null && !visited.contains(jspFile)) {\n          visited.add(jspFile);\n          jspFile = contextFile;\n          contextFile = manager.getContextFile(jspFile);\n        }\n        file = jspFile;\n      }\n    }\n\n    final List<FileReferenceHelper> helpers = FileReferenceHelperRegistrar.getHelpers();\n    for (final FileReferenceHelper helper : helpers) {\n      final PsiFileSystemItem item = helper.getContainingDirectory(file);\n      if (item != null) {\n        result = item;\n        break;\n      }\n    }\n\n    return result == null ? Collections.<PsiFileSystemItem>emptyList() : Collections.singleton(result);\n  }","commit_id":"ecd4c6005f3525db697bf92c6e6fb54ae167cc53","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void changeListRemoved(final ChangeList list) {\n    try {\n      myClient.doRemoveFromChangelist(getPathsFromChanges(list.getChanges()), SVNDepth.EMPTY, null);\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n    }\n  }","id":51429,"modified_method":"public void changeListRemoved(final ChangeList list) {\n    final File[] files = getPathsFromChanges(list.getChanges());\n    if (files.length > 0) {\n      try {\n        myClient.doRemoveFromChangelist(files, SVNDepth.EMPTY, null);\n      }\n      catch (SVNException e) {\n        LOG.info(e);\n      }\n    }\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void changeListRenamed(final ChangeList list, final String oldName) {\n    if (! ((LocalChangeList) list).isDefault()) {\n      try {\n        myClient.doAddToChangelist(getPathsFromChanges(list.getChanges()), SVNDepth.EMPTY, list.getName(), null);\n      }\n      catch (SVNException e) {\n        LOG.info(e);\n      }\n    }\n  }","id":51430,"modified_method":"public void changeListRenamed(final ChangeList list, final String oldName) {\n    if (! ((LocalChangeList) list).isDefault()) {\n      final File[] files = getPathsFromChanges(list.getChanges());\n      if (files.length > 0) {\n        try {\n          myClient.doAddToChangelist(files, SVNDepth.EMPTY, list.getName(), null);\n        }\n        catch (SVNException e) {\n          LOG.info(e);\n        }\n      }\n    }\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void defaultListChanged(final ChangeList oldDefaultList, final ChangeList newDefaultList) {\n    // to track list addition\n    changeListRenamed(oldDefaultList, null);\n    changeListRemoved(newDefaultList);\n  }","id":51431,"modified_method":"public void defaultListChanged(final ChangeList oldDefaultList, final ChangeList newDefaultList) {\n    // to track list addition\n    changeListRenamed(oldDefaultList, null);\n    changeListRemoved(newDefaultList);\n    ChangeListManager.getInstance(myProject).getDefaultChangeList().setReadOnly(true);\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static File[] getPathsFromChanges(final Collection<Change> changes) {\n    final List<File> paths = new ArrayList<File>();\n    for (Change change : changes) {\n      if (change.getBeforeRevision() != null) {\n        paths.add(change.getBeforeRevision().getFile().getIOFile());\n      }\n      if (change.getAfterRevision() != null) {\n        paths.add(change.getAfterRevision().getFile().getIOFile());\n      }\n    }\n    return paths.toArray(new File[paths.size()]);\n  }","id":51432,"modified_method":"private File[] getPathsFromChanges(final Collection<Change> changes) {\n    final List<File> paths = new ArrayList<File>();\n    for (Change change : changes) {\n      if ((change.getBeforeRevision() != null) && (isUnderSvn(change.getBeforeRevision().getFile()))) {\n        paths.add(change.getBeforeRevision().getFile().getIOFile());\n      }\n      if ((change.getAfterRevision() != null) && (isUnderSvn(change.getAfterRevision().getFile()))) {\n        paths.add(change.getAfterRevision().getFile().getIOFile());\n      }\n    }\n    return paths.toArray(new File[paths.size()]);\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void changeListUpdateDone() {\n  }","id":51433,"modified_method":"public void changeListUpdateDone() {\n    ChangeListManager.getInstance(myProject).getDefaultChangeList().setReadOnly(true);\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void changesMoved(final Collection<Change> changes, final ChangeList fromList, final ChangeList toList) {\n    final String[] fromLists = ((LocalChangeList) fromList).isDefault() ? null : new String[] {fromList.getName()};\n    try {\n      myClient.doAddToChangelist(getPathsFromChanges(changes), SVNDepth.EMPTY, toList.getName(), fromLists);\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n    }\n  }","id":51434,"modified_method":"public void changesMoved(final Collection<Change> changes, final ChangeList fromList, final ChangeList toList) {\n    final String[] fromLists = ((LocalChangeList) fromList).isDefault() ? null : new String[] {fromList.getName()};\n    final File[] files = getPathsFromChanges(changes);\n    if (files.length > 0) {\n      try {\n        myClient.doAddToChangelist(files, SVNDepth.EMPTY, toList.getName(), fromLists);\n      }\n      catch (SVNException e) {\n        LOG.info(e);\n      }\n    }\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SvnChangelistListener(final SVNChangelistClient client) {\n    myClient = client;\n  }","id":51435,"modified_method":"public SvnChangelistListener(final Project project, final SVNChangelistClient client) {\n    myProject = project;\n    myClient = client;\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SvnVcs(Project project, SvnConfiguration svnConfiguration) {\n    super(project);\n    LOG.debug(\"ct\");\n    myConfiguration = svnConfiguration;\n\n    dumpFileStatus(FileStatus.ADDED);\n    dumpFileStatus(FileStatus.DELETED);\n    dumpFileStatus(FileStatus.MERGE);\n    dumpFileStatus(FileStatus.MODIFIED);\n    dumpFileStatus(FileStatus.NOT_CHANGED);\n    dumpFileStatus(FileStatus.UNKNOWN);\n\n    dumpFileStatus(SvnFileStatus.REPLACED);\n    dumpFileStatus(SvnFileStatus.EXTERNAL);\n    dumpFileStatus(SvnFileStatus.OBSTRUCTED);\n\n    myEntriesFileListener = new SvnEntriesFileListener(project);\n\n    final ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(project);\n    myAddConfirmation = vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, this);\n    myDeleteConfirmation = vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.REMOVE, this);\n    myCheckoutOptions = vcsManager.getStandardOption(VcsConfiguration.StandardOption.CHECKOUT, this);\n\n    myRootsInfo = new SvnFileUrlMappingRefresher(new SvnFileUrlMappingImpl(myProject, this));\n\n    final SvnBranchConfigurationManager.SvnSupportOptions supportOptions =\n      SvnBranchConfigurationManager.getInstance(myProject).getSupportOptions();\n    upgradeTo15(supportOptions);\n    changeListSynchronizationIdeaVersionToNative(supportOptions);\n\n    ChangeListManager.getInstance(myProject).addChangeListListener(new SvnChangelistListener(createChangelistClient()));\n  }","id":51436,"modified_method":"public SvnVcs(Project project, SvnConfiguration svnConfiguration) {\n    super(project);\n    LOG.debug(\"ct\");\n    myConfiguration = svnConfiguration;\n\n    dumpFileStatus(FileStatus.ADDED);\n    dumpFileStatus(FileStatus.DELETED);\n    dumpFileStatus(FileStatus.MERGE);\n    dumpFileStatus(FileStatus.MODIFIED);\n    dumpFileStatus(FileStatus.NOT_CHANGED);\n    dumpFileStatus(FileStatus.UNKNOWN);\n\n    dumpFileStatus(SvnFileStatus.REPLACED);\n    dumpFileStatus(SvnFileStatus.EXTERNAL);\n    dumpFileStatus(SvnFileStatus.OBSTRUCTED);\n\n    myEntriesFileListener = new SvnEntriesFileListener(project);\n\n    final ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(project);\n    myAddConfirmation = vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, this);\n    myDeleteConfirmation = vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.REMOVE, this);\n    myCheckoutOptions = vcsManager.getStandardOption(VcsConfiguration.StandardOption.CHECKOUT, this);\n\n    myRootsInfo = new SvnFileUrlMappingRefresher(new SvnFileUrlMappingImpl(myProject, this));\n\n    final SvnBranchConfigurationManager.SvnSupportOptions supportOptions =\n      SvnBranchConfigurationManager.getInstance(myProject).getSupportOptions();\n    upgradeTo15(supportOptions);\n    changeListSynchronizationIdeaVersionToNative(supportOptions);\n\n    myChangeListListener = new SvnChangelistListener(myProject, createChangelistClient());\n    ChangeListManager.getInstance(myProject).addChangeListListener(myChangeListListener);\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void deactivate() {\n    VirtualFileManager.getInstance().removeVirtualFileListener(myEntriesFileListener);\n    SvnApplicationSettings.getInstance().svnDeactivated();\n    new DefaultSVNRepositoryPool(null, null).shutdownConnections(true);\n    if (myCommittedChangesProvider != null) {\n      myCommittedChangesProvider.deactivate();\n    }\n    super.deactivate();\n  }","id":51437,"modified_method":"@Override\n  public void deactivate() {\n    VirtualFileManager.getInstance().removeVirtualFileListener(myEntriesFileListener);\n    SvnApplicationSettings.getInstance().svnDeactivated();\n    new DefaultSVNRepositoryPool(null, null).shutdownConnections(true);\n    if (myCommittedChangesProvider != null) {\n      myCommittedChangesProvider.deactivate();\n    }\n    ChangeListManager.getInstance(myProject).removeChangeListListener(myChangeListListener);\n    super.deactivate();\n  }","commit_id":"188e886f6e1b97f7dff948c9a75ca8882e910c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate, String version,\n\t\t\tString description, int status)\n\t\tthrows SystemException {\n\n\t\tlong fileVersionId = counterLocalService.increment();\n\n\t\tDLFileVersion fileVersion = dlFileVersionPersistence.create(\n\t\t\tfileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setGroupId(fileEntry.getGroupId());\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(modifiedDate);\n\t\tfileVersion.setFolderId(fileEntry.getFolderId());\n\t\tfileVersion.setName(fileEntry.getName());\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(fileEntry.getModifiedDate());\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\t}","id":51438,"modified_method":"protected DLFileVersion addFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate, String version,\n\t\t\tString description, int status)\n\t\tthrows SystemException {\n\n\t\tlong fileVersionId = counterLocalService.increment();\n\n\t\tDLFileVersion fileVersion = dlFileVersionPersistence.create(\n\t\t\tfileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setGroupId(fileEntry.getGroupId());\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(modifiedDate);\n\t\tfileVersion.setFolderId(fileEntry.getFolderId());\n\t\tfileVersion.setName(fileEntry.getName());\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(fileEntry.getModifiedDate());\n\n\t\treturn dlFileVersionPersistence.update(fileVersion, false);\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry addFileEntry(\n\t\t\tString uuid, long userId, long groupId, long folderId, String name,\n\t\t\tString title, String description, String versionDescription,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, folderId, title, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tfileEntry.setUuid(uuid);\n\t\tfileEntry.setGroupId(groupId);\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\t}\n\t\telse {\n\t\t\tfileEntry.setVersion(StringPool.BLANK);\n\t\t}\n\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\taddFileVersion(\n\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\tDLFileEntryConstants.DEFAULT_VERSION, null,\n\t\t\tserviceContext.getStatus());\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.DL_FILE_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, fileEntry.getUserName(), DLFileEntry.class.getName(),\n\t\t\t\tfileEntryId, StatusConstants.APPROVED);\n\t\t}\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tfileEntryId, fileEntry.getLuceneProperties(),\n\t\t\tfileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileEntryId, fileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":51439,"modified_method":"public DLFileEntry addFileEntry(\n\t\t\tString uuid, long userId, long groupId, long folderId, String name,\n\t\t\tString title, String description, String versionDescription,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, folderId, title, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tfileEntry.setUuid(uuid);\n\t\tfileEntry.setGroupId(groupId);\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\t}\n\t\telse {\n\t\t\tfileEntry.setVersion(StringPool.BLANK);\n\t\t}\n\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\tDLFileVersion fileVersion = addFileVersion(\n\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\tDLFileEntryConstants.DEFAULT_VERSION, null,\n\t\t\tserviceContext.getStatus());\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.DL_FILE_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, fileEntry.getUserName(), DLFileEntry.class.getName(),\n\t\t\t\tfileEntryId, StatusConstants.APPROVED);\n\t\t}\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tfileEntryId, fileEntry.getLuceneProperties(),\n\t\t\tfileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileVersion.getFileVersionId(),\n\t\t\t\t\tfileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateWorkflowStatus(\n\t\t\tlong userId, long fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\t// File version\n\n\t\tDLFileVersion fileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\tfileEntry.getName());\n\n\t\tfileVersion.setStatus(serviceContext.getStatus());\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(new Date());\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileVersion.getVersion(),\n\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION) < 0)) {\n\n\t\t\tfileVersion.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\t}\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\t// File entry\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) < 0)) {\n\n\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\t\telse if (!fileVersion.isApproved() &&\n\t\t\t\t (DLUtil.compareVersions(\n\t\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tString newVersion = DLFileEntryConstants.DEFAULT_VERSION;\n\n\t\t\tif (DLUtil.compareVersions(\n\t\t\t\t\tfileVersion.getVersion(), newVersion) > 1) {\n\n\t\t\t\tList<DLFileVersion> approvedFileVersions =\n\t\t\t\t\tdlFileVersionPersistence.findByG_F_N_S(\n\t\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\t\tfileEntry.getName(), StatusConstants.APPROVED);\n\n\t\t\t\tif (!approvedFileVersions.isEmpty()) {\n\t\t\t\t\tnewVersion = approvedFileVersions.get(0).getVersion();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileEntry.setPendingVersion(fileVersion.getVersion());\n\t\t\tfileEntry.setVersion(newVersion);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\ttrue);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\tfalse);\n\t\t}\n\n\t\t// Social\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tif (fileVersion.getVersion().equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.ADD_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.UPDATE_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(DLFileEntry.class);\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tindexer.reindex(fileEntry);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tindexer.delete(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":51440,"modified_method":"public DLFileEntry updateWorkflowStatus(\n\t\t\tlong userId, long fileVersionId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File Version\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileVersion fileVersion = dlFileVersionPersistence.findByPrimaryKey(\n\t\t\tfileVersionId);\n\n\t\tfileVersion.setStatus(serviceContext.getStatus());\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(new Date());\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\t// File entry\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tfileVersion.getGroupId(), fileVersion.getFolderId(),\n\t\t\tfileVersion.getName());\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) < 0)) {\n\n\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\t\telse if (!fileVersion.isApproved() &&\n\t\t\t\t (DLUtil.compareVersions(\n\t\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tString newVersion = DLFileEntryConstants.DEFAULT_VERSION;\n\n\t\t\tif (DLUtil.compareVersions(\n\t\t\t\t\tfileVersion.getVersion(), newVersion) > 1) {\n\n\t\t\t\tList<DLFileVersion> approvedFileVersions =\n\t\t\t\t\tdlFileVersionPersistence.findByG_F_N_S(\n\t\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\t\tfileEntry.getName(), StatusConstants.APPROVED);\n\n\t\t\t\tif (!approvedFileVersions.isEmpty()) {\n\t\t\t\t\tnewVersion = approvedFileVersions.get(0).getVersion();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileEntry.setPendingVersion(fileVersion.getVersion());\n\t\t\tfileEntry.setVersion(newVersion);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\ttrue);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\tfalse);\n\t\t}\n\n\t\t// Social\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tif (fileVersion.getVersion().equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntry.getFileEntryId(), DLActivityKeys.ADD_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntry.getFileEntryId(),\n\t\t\t\t\tDLActivityKeys.UPDATE_FILE_ENTRY, StringPool.BLANK, 0);\n\t\t\t}\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(DLFileEntry.class);\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tindexer.reindex(fileEntry);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tindexer.delete(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, String sourceFileName, String title,\n\t\t\tString description, String versionDescription, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = name;\n\t\t\t}\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tvalidate(\n\t\t\tgroupId, folderId, newFolderId, name, title, sourceFileName, is);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Move file entry\n\n\t\tif (folderId != newFolderId) {\n\t\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\t\tif (dlLocalService.hasFile(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId),\n\t\t\t\t\tname, StringPool.BLANK)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\t\tnewFileEntryId);\n\n\t\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\t\tList<DLFileVersion> fileVersions =\n\t\t\t\tdlFileVersionPersistence.findByG_F_N(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setGroupId(fileVersion.getGroupId());\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\t\tnewFileVersion.setStatusDate(\n\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t\t}\n\n\t\t\tdlFileShortcutLocalService.updateFileShortcuts(\n\t\t\t\tgroupId, folderId, name, newFolderId, name);\n\n\t\t\t// Resources\n\n\t\t\tResource resource = resourceLocalService.getResource(\n\t\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tString.valueOf(fileEntry.getFileEntryId()));\n\n\t\t\tresource.setPrimKey(String.valueOf(newFileEntryId));\n\n\t\t\tresourcePersistence.update(resource, false);\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByG_TF_TN(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t\t}\n\n\t\t\t// Expando\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// Ratings\n\n\t\t\tRatingsStats stats = ratingsStatsLocalService.getStats(\n\t\t\t\tDLFileEntry.class.getName(), oldFileEntryId);\n\n\t\t\tstats.setClassPK(newFileEntryId);\n\n\t\t\tratingsStatsPersistence.update(stats, false);\n\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\tDLFileEntry.class.getName());\n\n\t\t\tList<RatingsEntry> entries = ratingsEntryPersistence.findByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tfor (RatingsEntry entry : entries) {\n\t\t\t\tentry.setClassPK(newFileEntryId);\n\n\t\t\t\tratingsEntryPersistence.update(entry, false);\n\t\t\t}\n\n\t\t\t// Message boards\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tif (discussion != null) {\n\t\t\t\tdiscussion.setClassPK(newFileEntryId);\n\n\t\t\t\tmbDiscussionPersistence.update(discussion, false);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// File\n\n\t\t\tdlService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfileEntry = newFileEntry;\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tfileEntry, majorVersion, serviceContext.getStatus());\n\n\t\tif (is == null) {\n\t\t\tfileEntry.setVersion(version);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), fileEntry.getRepositoryId(), name);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name,\n\t\t\t\tfalse, version, name, fileEntry.getFileEntryId(),\n\t\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\t\tserviceContext, is);\n\n\t\t\treturn fileEntry;\n\t\t}\n\n\t\tif (Validator.isNotNull(fileEntry.getPendingVersion())) {\n\t\t\tupdateFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now), version,\n\t\t\t\tversionDescription, serviceContext.getStatus());\n\t\t}\n\t\telse {\n\t\t\taddFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now), version,\n\t\t\t\tversionDescription, serviceContext.getStatus());\n\t\t}\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\n\t\tif (serviceContext.getStatus() == StatusConstants.DRAFT) {\n\t\t\tfileEntry.setPendingVersion(version);\n\t\t}\n\t\telse if (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(version);\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\t\t}\n\t\telse {\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\t\t}\n\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Folder\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// File\n\n\t\ttry {\n\t\t\tdlService.deleteFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getRepositoryId(), name, version);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tversion, sourceFileName, fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\tserviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\t\tfileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":51441,"modified_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, String sourceFileName, String title,\n\t\t\tString description, String versionDescription, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = name;\n\t\t\t}\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tvalidate(\n\t\t\tgroupId, folderId, newFolderId, name, title, sourceFileName, is);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Move file entry\n\n\t\tif (folderId != newFolderId) {\n\t\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\t\tif (dlLocalService.hasFile(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId),\n\t\t\t\t\tname, StringPool.BLANK)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\t\tnewFileEntryId);\n\n\t\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\t\tList<DLFileVersion> fileVersions =\n\t\t\t\tdlFileVersionPersistence.findByG_F_N(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setGroupId(fileVersion.getGroupId());\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\t\tnewFileVersion.setStatusDate(\n\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t\t}\n\n\t\t\tdlFileShortcutLocalService.updateFileShortcuts(\n\t\t\t\tgroupId, folderId, name, newFolderId, name);\n\n\t\t\t// Resources\n\n\t\t\tResource resource = resourceLocalService.getResource(\n\t\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tString.valueOf(fileEntry.getFileEntryId()));\n\n\t\t\tresource.setPrimKey(String.valueOf(newFileEntryId));\n\n\t\t\tresourcePersistence.update(resource, false);\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByG_TF_TN(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t\t}\n\n\t\t\t// Expando\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// Ratings\n\n\t\t\tRatingsStats stats = ratingsStatsLocalService.getStats(\n\t\t\t\tDLFileEntry.class.getName(), oldFileEntryId);\n\n\t\t\tstats.setClassPK(newFileEntryId);\n\n\t\t\tratingsStatsPersistence.update(stats, false);\n\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\tDLFileEntry.class.getName());\n\n\t\t\tList<RatingsEntry> entries = ratingsEntryPersistence.findByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tfor (RatingsEntry entry : entries) {\n\t\t\t\tentry.setClassPK(newFileEntryId);\n\n\t\t\t\tratingsEntryPersistence.update(entry, false);\n\t\t\t}\n\n\t\t\t// Message boards\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tif (discussion != null) {\n\t\t\t\tdiscussion.setClassPK(newFileEntryId);\n\n\t\t\t\tmbDiscussionPersistence.update(discussion, false);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// File\n\n\t\t\tdlService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfileEntry = newFileEntry;\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tfileEntry, majorVersion, serviceContext.getStatus());\n\n\t\tif (is == null) {\n\t\t\tfileEntry.setVersion(version);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), fileEntry.getRepositoryId(), name);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name,\n\t\t\t\tfalse, version, name, fileEntry.getFileEntryId(),\n\t\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\t\tserviceContext, is);\n\n\t\t\treturn fileEntry;\n\t\t}\n\n\t\tDLFileVersion fileVersion;\n\n\t\tif (Validator.isNotNull(fileEntry.getPendingVersion())) {\n\t\t\tfileVersion = updateFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now), version,\n\t\t\t\tversionDescription, serviceContext.getStatus());\n\t\t}\n\t\telse {\n\t\t\tfileVersion =\n\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\tfileEntry.getName());\n\n\t\t\tif (DLUtil.compareVersions(\n\t\t\t\t\tversion, fileVersion.getVersion()) <= 0) {\n\n\t\t\t\tversion = getNextVersion(\n\t\t\t\t\tfileVersion.getVersion(), majorVersion);\n\t\t\t}\n\n\t\t\tfileVersion = addFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\tversion, versionDescription, serviceContext.getStatus());\n\t\t}\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\n\t\tif (serviceContext.getStatus() == StatusConstants.DRAFT) {\n\t\t\tfileEntry.setPendingVersion(version);\n\t\t}\n\t\telse if (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(version);\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\t\t}\n\t\telse {\n\t\t\tfileEntry.setPendingVersion(StringPool.BLANK);\n\t\t}\n\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Folder\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// File\n\n\t\ttry {\n\t\t\tdlService.deleteFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getRepositoryId(), name, version);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tversion, sourceFileName, fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\tserviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileVersion.getFileVersionId(),\n\t\t\t\t\tfileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getNextVersion(\n\t\tDLFileEntry fileEntry, boolean majorVersion, int status) {\n\n\t\tif ((status == StatusConstants.DRAFT) &&\n\t\t\tValidator.isNotNull(fileEntry.getPendingVersion())) {\n\n\t\t\treturn fileEntry.getPendingVersion();\n\t\t}\n\n\t\tif (Validator.isNull(fileEntry.getVersion())) {\n\t\t\treturn DLFileEntryConstants.DEFAULT_VERSION;\n\t\t}\n\n\t\tint[] versionParts = StringUtil.split(\n\t\t\tfileEntry.getVersion(), StringPool.PERIOD, 0);\n\n\t\tif (majorVersion) {\n\t\t\tversionParts[0]++;\n\t\t\tversionParts[1] = 0;\n\t\t}\n\t\telse {\n\t\t\tversionParts[1]++;\n\t\t}\n\n\t\treturn versionParts[0] + StringPool.PERIOD + versionParts[1];\n\t}","id":51442,"modified_method":"protected String getNextVersion(\n\t\tDLFileEntry fileEntry, boolean majorVersion, int status) {\n\n\t\tif ((status == StatusConstants.DRAFT) &&\n\t\t\tValidator.isNotNull(fileEntry.getPendingVersion())) {\n\n\t\t\treturn fileEntry.getPendingVersion();\n\t\t}\n\n\t\tif (Validator.isNull(fileEntry.getVersion())) {\n\t\t\treturn DLFileEntryConstants.DEFAULT_VERSION;\n\t\t}\n\n\t\treturn getNextVersion(fileEntry.getVersion(), majorVersion);\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate, String version,\n\t\t\tString description, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileVersion fileVersion =\n\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\tfileEntry.getName(), fileEntry.getPendingVersion());\n\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(modifiedDate);\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\t}","id":51443,"modified_method":"protected DLFileVersion updateFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate, String version,\n\t\t\tString description, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileVersion fileVersion =\n\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\tfileEntry.getName(), fileEntry.getPendingVersion());\n\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(modifiedDate);\n\n\t\treturn dlFileVersionPersistence.update(fileVersion, false);\n\t}","commit_id":"2588148cc659f041ac31b3e874b3f7b00966b2d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"cim\", \"cim-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"integration.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"integration.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.cim.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.cim.name\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.cim.nocim\" ), textBlocks[1].getText() );\n    }","id":51444,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"cim\", \"cim-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"integration.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"integration.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.cim.name\" ),\n            getString( \"report.cim.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.cim.name\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.cim.nocim\" ), textBlocks[1].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependencies\", \"dependencies-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependencies.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependencies.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.dependencies.title\" ), response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( webTables.length, 1 );\n\n        assertEquals( webTables[0].getColumnCount(), 5 );\n        assertEquals( webTables[0].getRowCount(), 1 + getTestMavenProject().getDependencies().size() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependencies.title\" ), textBlocks[0].getText() );\n        assertEquals( \"test\", textBlocks[1].getText() );\n        assertEquals( getString( \"report.dependencies.intro.test\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.dependencies.transitive.title\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.dependencies.transitive.nolist\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.dependencies.graph.title\" ), textBlocks[5].getText() );\n        assertEquals( getString( \"report.dependencies.graph.tree.title\" ), textBlocks[6].getText() );\n        assertEquals( getString( \"report.dependencies.graph.tables.licenses\" ), textBlocks[7].getText() );\n    }","id":51445,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependencies\", \"dependencies-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependencies.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependencies.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.dependencies.name\" ),\n            getString( \"report.dependencies.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( webTables.length, 1 );\n\n        assertEquals( webTables[0].getColumnCount(), 5 );\n        assertEquals( webTables[0].getRowCount(), 1 + getTestMavenProject().getDependencies().size() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependencies.title\" ), textBlocks[0].getText() );\n        assertEquals( \"test\", textBlocks[1].getText() );\n        assertEquals( getString( \"report.dependencies.intro.test\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.dependencies.transitive.title\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.dependencies.transitive.nolist\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.dependencies.graph.title\" ), textBlocks[5].getText() );\n        assertEquals( getString( \"report.dependencies.graph.tree.title\" ), textBlocks[6].getText() );\n        assertEquals( getString( \"report.dependencies.graph.tables.licenses\" ), textBlocks[7].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependency-convergence\", \"dependency-convergence-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependency-convergence.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependency-convergence.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.dependency-convergence.reactor.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependency-convergence.reactor.name\" ), textBlocks[0].getText() );\n    }","id":51446,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependency-convergence\", \"dependency-convergence-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependency-convergence.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependency-convergence.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.dependency-convergence.name\" ),\n            getString( \"report.dependency-convergence.reactor.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependency-convergence.reactor.name\" ), textBlocks[0].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependency-management\", \"dependency-management-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependency-management.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependency-management.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.dependencyManagement.title\" ), response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( webTables.length, 1 );\n\n        assertEquals( webTables[0].getColumnCount(), 5 );\n        assertEquals( webTables[0].getRowCount(),\n                      1 + getTestMavenProject().getDependencyManagement().getDependencies().size() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependencyManagement.title\" ), textBlocks[0].getText() );\n        assertEquals( \"test\", textBlocks[1].getText() );\n    }","id":51447,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"dependency-management\", \"dependency-management-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"dependency-management.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"dependency-management.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.dependencyManagement.name\" ),\n            getString( \"report.dependencyManagement.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( webTables.length, 1 );\n\n        assertEquals( webTables[0].getColumnCount(), 5 );\n        assertEquals( webTables[0].getRowCount(),\n                      1 + getTestMavenProject().getDependencyManagement().getDependencies().size() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.dependencyManagement.title\" ), textBlocks[0].getText() );\n        assertEquals( \"test\", textBlocks[1].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"issue-tracking\", \"issue-tracking-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"issue-tracking.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"issue-tracking.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.issuetracking.title\" ), response.getTitle() );\n\n        // Test the links\n        WebLink[] weblinks = response.getLinks();\n        assertEquals( 3, weblinks.length );\n\n        assertEquals( \"JIRA\", weblinks[1].getText() );\n\n        assertEquals( \"http://localhost/jira\", weblinks[2].getText() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.issuetracking.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( \"This project uses JIRA a J2EE-based, issue tracking and project management application.\", textBlocks[1].getText() ); // due to link pattern\n        assertEquals( getString( \"report.issuetracking.name\" ), textBlocks[2].getText() );\n    }","id":51448,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"issue-tracking\", \"issue-tracking-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"issue-tracking.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"issue-tracking.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.issuetracking.name\" ),\n            getString( \"report.issuetracking.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the links\n        WebLink[] weblinks = response.getLinks();\n        assertEquals( 3, weblinks.length );\n\n        assertEquals( \"JIRA\", weblinks[1].getText() );\n\n        assertEquals( \"http://localhost/jira\", weblinks[2].getText() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.issuetracking.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( \"This project uses JIRA a J2EE-based, issue tracking and project management application.\", textBlocks[1].getText() ); // due to link pattern\n        assertEquals( getString( \"report.issuetracking.name\" ), textBlocks[2].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"license\", \"license-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"license.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"license.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.license.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.license.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.license.overview.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.license.name\" ), textBlocks[2].getText() );\n        assertEquals( \"The Apache Software License, Version 2.0\", textBlocks[3].getText() );\n\n        // only 1 link in default report\n        final WebLink[] links = response.getLinks();\n        assertEquals( 1, links.length );\n        assertEquals( \"http://maven.apache.org/\", links[0].getURLString() );\n    }","id":51449,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"license\", \"license-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"license.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"license.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.license.name\" ),\n            getString( \"report.license.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.license.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.license.overview.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.license.name\" ), textBlocks[2].getText() );\n        assertEquals( \"The Apache Software License, Version 2.0\", textBlocks[3].getText() );\n\n        // only 1 link in default report\n        final WebLink[] links = response.getLinks();\n        assertEquals( 1, links.length );\n        assertEquals( \"http://maven.apache.org/\", links[0].getURLString() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testReportLinksOnly()\n        throws Exception\n    {\n        generateReport( \"license\", \"license-plugin-config-linkonly.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"license.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"license.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.license.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.license.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.license.overview.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.license.name\" ), textBlocks[2].getText() );\n        assertEquals( \"The Apache Software License, Version 2.0\", textBlocks[3].getText() );\n\n        // here's our specific test\n        final WebLink[] links = response.getLinks();\n        assertEquals( 2, links.length );\n        assertEquals( \"http://maven.apache.org/\", links[0].getURLString() );\n        assertEquals( \"http://www.apache.org/licenses/LICENSE-2.0.txt\", links[1].getURLString() );\n        assertEquals( \"http://www.apache.org/licenses/LICENSE-2.0.txt\", links[1].getText() );\n    }","id":51450,"modified_method":"public void testReportLinksOnly()\n        throws Exception\n    {\n        generateReport( \"license\", \"license-plugin-config-linkonly.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"license.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"license.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.license.name\" ),\n            getString( \"report.license.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.license.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.license.overview.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.license.name\" ), textBlocks[2].getText() );\n        assertEquals( \"The Apache Software License, Version 2.0\", textBlocks[3].getText() );\n\n        // here's our specific test\n        final WebLink[] links = response.getLinks();\n        assertEquals( 2, links.length );\n        assertEquals( \"http://maven.apache.org/\", links[0].getURLString() );\n        assertEquals( \"http://www.apache.org/licenses/LICENSE-2.0.txt\", links[1].getURLString() );\n        assertEquals( \"http://www.apache.org/licenses/LICENSE-2.0.txt\", links[1].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"mailing-list\", \"mailing-list-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"mail-lists.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"mail-lists.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.mailing-lists.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.mailing-lists.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.mailing-lists.intro\" ), textBlocks[1].getText() );\n    }","id":51451,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"mailing-list\", \"mailing-list-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"mail-lists.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"mail-lists.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.mailing-lists.name\" ),\n            getString( \"report.mailing-lists.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.mailing-lists.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.mailing-lists.intro\" ), textBlocks[1].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"modules\", \"modules-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"modules.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"modules.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.modules.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( 2, textBlocks.length );\n        assertEquals( getString( \"report.modules.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.modules.intro\" ), textBlocks[1].getText() );\n\n        String[][] cellTexts = response.getTables()[0].asText();\n        assertEquals( 3, cellTexts.length );\n        assertEquals( 2, cellTexts[0].length );\n        assertEquals( getString( \"report.modules.header.name\" ), cellTexts[0][0] );\n        assertEquals( getString( \"report.modules.header.description\" ), cellTexts[0][1] );\n        assertEquals( \"project1\", cellTexts[1][0] );\n        assertEquals( \"-\", cellTexts[1][1] );\n        assertEquals( \"project2\", cellTexts[2][0] );\n        assertEquals( \"project2 description\", cellTexts[2][1] );\n    }","id":51452,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"modules\", \"modules-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"modules.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"modules.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.modules.name\" ),\n            getString( \"report.modules.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( 2, textBlocks.length );\n        assertEquals( getString( \"report.modules.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.modules.intro\" ), textBlocks[1].getText() );\n\n        String[][] cellTexts = response.getTables()[0].asText();\n        assertEquals( 3, cellTexts.length );\n        assertEquals( 2, cellTexts[0].length );\n        assertEquals( getString( \"report.modules.header.name\" ), cellTexts[0][0] );\n        assertEquals( getString( \"report.modules.header.description\" ), cellTexts[0][1] );\n        assertEquals( \"project1\", cellTexts[1][0] );\n        assertEquals( \"-\", cellTexts[1][1] );\n        assertEquals( \"project2\", cellTexts[2][0] );\n        assertEquals( \"project2 description\", cellTexts[2][1] );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"plugin-management\", \"plugin-management-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"plugin-management.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"plugin-management.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.pluginManagement.title\" ), response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( 1, webTables.length );\n\n        assertEquals( 3, webTables[0].getColumnCount() );\n        assertEquals( 3, webTables[0].getRowCount() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.pluginManagement.title\" ), textBlocks[0].getText() );\n    }","id":51453,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"plugin-management\", \"plugin-management-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"plugin-management.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"plugin-management.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.pluginManagement.name\" ),\n            getString( \"report.pluginManagement.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the tables\n        WebTable[] webTables = response.getTables();\n        assertEquals( 1, webTables.length );\n\n        assertEquals( 3, webTables[0].getColumnCount() );\n        assertEquals( 3, webTables[0].getRowCount() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.pluginManagement.title\" ), textBlocks[0].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"index\", \"index-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"index.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"index.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.index.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.index.title\" ) + \" \" + getTestMavenProject().getName(),\n                      textBlocks[0].getText() );\n        assertEquals( getString( \"report.index.nodescription\" ), textBlocks[1].getText() );\n    }","id":51454,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"index\", \"index-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"index.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"index.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        // Index does not have a 'name' but 'title' only\n        String expectedTitle = prepareTitle( getString( \"report.index.title\" ),\n            getString( \"report.index.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n        assertEquals( getString( \"report.index.title\" ) + \" \" + getTestMavenProject().getName(),\n                      textBlocks[0].getText() );\n        assertEquals( getString( \"report.index.nodescription\" ), textBlocks[1].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"summary\", \"summary-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"project-summary.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"project-summary.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.summary.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( getString( \"report.summary.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.summary.general.title\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.summary.organization.title\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.summary.noorganization\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.summary.build.title\" ), textBlocks[4].getText() );\n    }","id":51455,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"summary\", \"summary-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"project-summary.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"project-summary.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.summary.name\" ),\n            getString( \"report.summary.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( getString( \"report.summary.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.summary.general.title\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.summary.organization.title\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.summary.noorganization\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.summary.build.title\" ), textBlocks[4].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"scm\", \"scm-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"source-repository.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"source-repository.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.scm.title\" ), response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( textBlocks.length, 6 );\n\n        assertEquals( getString( \"report.scm.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.scm.general.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.scm.webaccess.title\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.scm.webaccess.nourl\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.scm.accessbehindfirewall.title\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.scm.accessbehindfirewall.general.intro\" ), textBlocks[5].getText() );\n    }","id":51456,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        generateReport( \"scm\", \"scm-plugin-config.xml\" );\n        assertTrue( \"Test html generated\", getGeneratedReport( \"source-repository.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"source-repository.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.scm.name\" ),\n            getString( \"report.scm.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( textBlocks.length, 6 );\n\n        assertEquals( getString( \"report.scm.overview.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.scm.general.intro\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.scm.webaccess.title\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.scm.webaccess.nourl\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.scm.accessbehindfirewall.title\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.scm.accessbehindfirewall.general.intro\" ), textBlocks[5].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/resources/plugin-configs/\" + \"project-team-plugin-config.xml\" );\n        AbstractProjectInfoReport mojo  = createReportMojo( \"project-team\", pluginXmlFile );\n        setVariableValueToObject( mojo, \"showAvatarImages\", Boolean.TRUE );\n       generateReport( mojo, pluginXmlFile);\n        assertTrue( \"Test html generated\", getGeneratedReport( \"team-list.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"team-list.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        assertEquals( getString( \"report.team-list.title\" ), response.getTitle() );\n\n        assertTrue( response.getText().contains( \"gravatar\" ));\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( textBlocks.length, 7 );\n\n        assertEquals( getString( \"report.team-list.intro.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.team-list.intro.description1\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.team-list.intro.description2\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.team-list.developers.title\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.team-list.developers.intro\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.team-list.contributors.title\" ), textBlocks[5].getText() );\n        assertEquals( getString( \"report.team-list.nocontributor\" ), textBlocks[6].getText() );\n    }","id":51457,"modified_method":"/**\n     * Test report\n     *\n     * @throws Exception if any\n     */\n    public void testReport()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/resources/plugin-configs/\" + \"project-team-plugin-config.xml\" );\n        AbstractProjectInfoReport mojo  = createReportMojo( \"project-team\", pluginXmlFile );\n        setVariableValueToObject( mojo, \"showAvatarImages\", Boolean.TRUE );\n       generateReport( mojo, pluginXmlFile);\n        assertTrue( \"Test html generated\", getGeneratedReport( \"team-list.html\" ).exists() );\n\n        URL reportURL = getGeneratedReport( \"team-list.html\" ).toURI().toURL();\n        assertNotNull( reportURL );\n\n        // HTTPUnit\n        WebRequest request = new GetMethodWebRequest( reportURL.toString() );\n        WebResponse response = WEB_CONVERSATION.getResponse( request );\n\n        // Basic HTML tests\n        assertTrue( response.isHTML() );\n        assertTrue( response.getContentLength() > 0 );\n\n        // Test the Page title\n        String expectedTitle = prepareTitle( getString( \"report.team-list.name\" ),\n            getString( \"report.team-list.title\" ) );\n        assertEquals( expectedTitle, response.getTitle() );\n\n        assertTrue( response.getText().contains( \"gravatar\" ));\n\n        // Test the texts\n        TextBlock[] textBlocks = response.getTextBlocks();\n\n        assertEquals( textBlocks.length, 7 );\n\n        assertEquals( getString( \"report.team-list.intro.title\" ), textBlocks[0].getText() );\n        assertEquals( getString( \"report.team-list.intro.description1\" ), textBlocks[1].getText() );\n        assertEquals( getString( \"report.team-list.intro.description2\" ), textBlocks[2].getText() );\n        assertEquals( getString( \"report.team-list.developers.title\" ), textBlocks[3].getText() );\n        assertEquals( getString( \"report.team-list.developers.intro\" ), textBlocks[4].getText() );\n        assertEquals( getString( \"report.team-list.contributors.title\" ), textBlocks[5].getText() );\n        assertEquals( getString( \"report.team-list.nocontributor\" ), textBlocks[6].getText() );\n    }","commit_id":"7df886acdf38b995ad20c552f025de48c93a8fb8","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public FieldData cache(FieldDataType type, IndexReader reader, String fieldName) throws IOException {\n        Cache<String, FieldData> fieldDataCache = cache.get(reader.getCoreCacheKey());\n        if (fieldDataCache == null) {\n            synchronized (creationMutex) {\n                fieldDataCache = cache.get(reader.getCoreCacheKey());\n                if (fieldDataCache == null) {\n                    fieldDataCache = buildFieldDataMap();\n                    ((SegmentReader) reader).addCoreClosedListener(this);\n                    cache.put(reader.getCoreCacheKey(), fieldDataCache);\n                }\n            }\n        }\n        FieldData fieldData = fieldDataCache.getIfPresent(fieldName);\n        if (fieldData == null) {\n            synchronized (fieldDataCache) {\n                fieldData = fieldDataCache.getIfPresent(fieldName);\n                if (fieldData == null) {\n                    try {\n                        long time = System.nanoTime();\n                        fieldData = FieldData.load(type, reader, fieldName);\n                        fieldDataCache.put(fieldName, fieldData);\n                        long took = System.nanoTime() - time;\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"loaded field [{}] for reader [{}], took [{}], took_millis [{}]\", fieldName, reader, TimeValue.timeValueNanos(took), took / 1000);\n                        }\n                    } catch (OutOfMemoryError e) {\n                        logger.warn(\"loading field [\" + fieldName + \"] caused out of memory failure\", e);\n                        final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\"loading field [\" + fieldName + \"] caused out of memory failure\");\n                        outOfMemoryError.initCause(e);\n                        throw outOfMemoryError;\n                    }\n                }\n            }\n        }\n        return fieldData;\n    }","id":51458,"modified_method":"@Override\n    public FieldData cache(FieldDataType type, IndexReader reader, String fieldName) throws IOException {\n        Cache<String, FieldData> fieldDataCache = cache.get(reader.getCoreCacheKey());\n        if (fieldDataCache == null) {\n            synchronized (creationMutex) {\n                fieldDataCache = cache.get(reader.getCoreCacheKey());\n                if (fieldDataCache == null) {\n                    fieldDataCache = buildFieldDataMap();\n                    if (reader instanceof SegmentReader) {\n                        ((SegmentReader) reader).addCoreClosedListener(this);\n                    }\n                    cache.put(reader.getCoreCacheKey(), fieldDataCache);\n                }\n            }\n        }\n        FieldData fieldData = fieldDataCache.getIfPresent(fieldName);\n        if (fieldData == null) {\n            synchronized (fieldDataCache) {\n                fieldData = fieldDataCache.getIfPresent(fieldName);\n                if (fieldData == null) {\n                    try {\n                        long time = System.nanoTime();\n                        fieldData = FieldData.load(type, reader, fieldName);\n                        fieldDataCache.put(fieldName, fieldData);\n                        long took = System.nanoTime() - time;\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"loaded field [{}] for reader [{}], took [{}], took_millis [{}]\", fieldName, reader, TimeValue.timeValueNanos(took), took / 1000);\n                        }\n                    } catch (OutOfMemoryError e) {\n                        logger.warn(\"loading field [\" + fieldName + \"] caused out of memory failure\", e);\n                        final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\"loading field [\" + fieldName + \"] caused out of memory failure\");\n                        outOfMemoryError.initCause(e);\n                        throw outOfMemoryError;\n                    }\n                }\n            }\n        }\n        return fieldData;\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized void addQuery(String name, Query query) {\n        Preconditions.checkArgument(query != null, \"query must be provided for percolate request\");\n        this.queries = MapBuilder.newMapBuilder(queries).put(name, query).immutableMap();\n    }","id":51459,"modified_method":"private synchronized void addQuery(String name, Query query) {\n        Preconditions.checkArgument(query != null, \"query must be provided for percolate request\");\n        this.queries = MapBuilder.newMapBuilder(queries).put(name, query).immutableMap();\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Response percolate(DocAndQueryRequest request) throws ElasticSearchException {\n        // first, parse the source doc into a MemoryIndex\n        final CustomMemoryIndex memoryIndex = new CustomMemoryIndex();\n\n        // TODO: This means percolation does not support nested docs...\n        for (Fieldable field : request.doc().rootDoc().getFields()) {\n            if (!field.isIndexed()) {\n                continue;\n            }\n            // no need to index the UID field\n            if (field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            TokenStream tokenStream = field.tokenStreamValue();\n            if (tokenStream != null) {\n                memoryIndex.addField(field.name(), tokenStream, field.getBoost());\n            } else {\n                Reader reader = field.readerValue();\n                if (reader != null) {\n                    try {\n                        memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), reader), field.getBoost() * request.doc().rootDoc().getBoost());\n                    } catch (IOException e) {\n                        throw new MapperParsingException(\"Failed to analyze field [\" + field.name() + \"]\", e);\n                    }\n                } else {\n                    String value = field.stringValue();\n                    if (value != null) {\n                        try {\n                            memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), new FastStringReader(value)), field.getBoost() * request.doc().rootDoc().getBoost());\n                        } catch (IOException e) {\n                            throw new MapperParsingException(\"Failed to analyze field [\" + field.name() + \"]\", e);\n                        }\n                    }\n                }\n            }\n        }\n\n        final IndexSearcher searcher = memoryIndex.createSearcher();\n\n        List<String> matches = new ArrayList<String>();\n        if (request.query() == null) {\n            Lucene.ExistsCollector collector = new Lucene.ExistsCollector();\n            for (Map.Entry<String, Query> entry : queries.entrySet()) {\n                collector.reset();\n                try {\n                    searcher.search(entry.getValue(), collector);\n                } catch (IOException e) {\n                    logger.warn(\"[\" + entry.getKey() + \"] failed to execute query\", e);\n                }\n\n                if (collector.exists()) {\n                    matches.add(entry.getKey());\n                }\n            }\n        } else {\n            IndexService percolatorIndex = indicesService.indexService(PercolatorService.INDEX_NAME);\n            if (percolatorIndex == null) {\n                throw new PercolateIndexUnavailable(new Index(PercolatorService.INDEX_NAME));\n            }\n            if (percolatorIndex.numberOfShards() == 0) {\n                throw new PercolateIndexUnavailable(new Index(PercolatorService.INDEX_NAME));\n            }\n            IndexShard percolatorShard = percolatorIndex.shard(0);\n            Engine.Searcher percolatorSearcher = percolatorShard.searcher();\n            try {\n                percolatorSearcher.searcher().search(request.query(), new QueryCollector(logger, queries, searcher, percolatorIndex, matches));\n            } catch (IOException e) {\n                logger.warn(\"failed to execute\", e);\n            } finally {\n                percolatorSearcher.release();\n            }\n        }\n\n        indexCache.clear(searcher.getIndexReader());\n\n        return new Response(matches, request.doc().mappersAdded());\n    }","id":51460,"modified_method":"public Response percolate(DocAndQueryRequest request) throws ElasticSearchException {\n        // first, parse the source doc into a MemoryIndex\n        final CustomMemoryIndex memoryIndex = new CustomMemoryIndex();\n\n        // TODO: This means percolation does not support nested docs...\n        for (Fieldable field : request.doc().rootDoc().getFields()) {\n            if (!field.isIndexed()) {\n                continue;\n            }\n            // no need to index the UID field\n            if (field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            TokenStream tokenStream = field.tokenStreamValue();\n            if (tokenStream != null) {\n                memoryIndex.addField(field.name(), tokenStream, field.getBoost());\n            } else {\n                Reader reader = field.readerValue();\n                if (reader != null) {\n                    try {\n                        memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), reader), field.getBoost() * request.doc().rootDoc().getBoost());\n                    } catch (IOException e) {\n                        throw new MapperParsingException(\"Failed to analyze field [\" + field.name() + \"]\", e);\n                    }\n                } else {\n                    String value = field.stringValue();\n                    if (value != null) {\n                        try {\n                            memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), new FastStringReader(value)), field.getBoost() * request.doc().rootDoc().getBoost());\n                        } catch (IOException e) {\n                            throw new MapperParsingException(\"Failed to analyze field [\" + field.name() + \"]\", e);\n                        }\n                    }\n                }\n            }\n        }\n\n        final IndexSearcher searcher = memoryIndex.createSearcher();\n        List<String> matches = new ArrayList<String>();\n\n        try {\n            if (request.query() == null) {\n                Lucene.ExistsCollector collector = new Lucene.ExistsCollector();\n                for (Map.Entry<String, Query> entry : queries.entrySet()) {\n                    collector.reset();\n                    try {\n                        searcher.search(entry.getValue(), collector);\n                    } catch (IOException e) {\n                        logger.warn(\"[\" + entry.getKey() + \"] failed to execute query\", e);\n                    }\n\n                    if (collector.exists()) {\n                        matches.add(entry.getKey());\n                    }\n                }\n            } else {\n                IndexService percolatorIndex = indicesService.indexService(PercolatorService.INDEX_NAME);\n                if (percolatorIndex == null) {\n                    throw new PercolateIndexUnavailable(new Index(PercolatorService.INDEX_NAME));\n                }\n                if (percolatorIndex.numberOfShards() == 0) {\n                    throw new PercolateIndexUnavailable(new Index(PercolatorService.INDEX_NAME));\n                }\n                IndexShard percolatorShard = percolatorIndex.shard(0);\n                Engine.Searcher percolatorSearcher = percolatorShard.searcher();\n                try {\n                    percolatorSearcher.searcher().search(request.query(), new QueryCollector(logger, queries, searcher, percolatorIndex, matches));\n                } catch (IOException e) {\n                    logger.warn(\"failed to execute\", e);\n                } finally {\n                    percolatorSearcher.release();\n                }\n            }\n        } finally {\n            // explicitly clear the reader, since we can only register on callback on SegmentReader\n            indexCache.clear(searcher.getIndexReader());\n        }\n\n        return new Response(matches, request.doc().mappersAdded());\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@BeforeClass\n    public void buildPercolatorService() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.cache.filter.type\", \"none\")\n                .build();\n        Index index = new Index(\"test\");\n        Injector injector = new ModulesBuilder().add(\n                new SettingsModule(settings),\n                new ThreadPoolModule(settings),\n                new ScriptModule(settings),\n                new IndicesQueriesModule(),\n                new MapperServiceModule(),\n                new IndexSettingsModule(index, settings),\n                new IndexCacheModule(settings),\n                new AnalysisModule(settings),\n                new IndexEngineModule(settings),\n                new SimilarityModule(settings),\n                new IndexQueryParserModule(settings),\n                new IndexNameModule(index),\n                new AbstractModule() {\n                    @Override\n                    protected void configure() {\n                        bind(PercolatorExecutor.class).asEagerSingleton();\n                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));\n                    }\n                }\n        ).createInjector();\n\n        percolatorExecutor = injector.getInstance(PercolatorExecutor.class);\n    }","id":51461,"modified_method":"@BeforeClass\n    public void buildPercolatorService() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                //.put(\"index.cache.filter.type\", \"none\")\n                .build();\n        Index index = new Index(\"test\");\n        Injector injector = new ModulesBuilder().add(\n                new SettingsModule(settings),\n                new ThreadPoolModule(settings),\n                new ScriptModule(settings),\n                new IndicesQueriesModule(),\n                new MapperServiceModule(),\n                new IndexSettingsModule(index, settings),\n                new IndexCacheModule(settings),\n                new AnalysisModule(settings),\n                new IndexEngineModule(settings),\n                new SimilarityModule(settings),\n                new IndexQueryParserModule(settings),\n                new IndexNameModule(index),\n                new AbstractModule() {\n                    @Override\n                    protected void configure() {\n                        bind(PercolatorExecutor.class).asEagerSingleton();\n                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));\n                    }\n                }\n        ).createInjector();\n\n        percolatorExecutor = injector.getInstance(PercolatorExecutor.class);\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimplePercolator() throws Exception {\n        // introduce the doc\n        XContentBuilder doc = XContentFactory.jsonBuilder().startObject().startObject(\"doc\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject();\n        byte[] source = doc.copiedBytes();\n\n        XContentBuilder docWithType = XContentFactory.jsonBuilder().startObject().startObject(\"doc\").startObject(\"type1\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject().endObject();\n        byte[] sourceWithType = docWithType.copiedBytes();\n\n        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(0));\n\n        // add a query\n        percolatorExecutor.addQuery(\"test1\", termQuery(\"field2\", \"value\"));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItem(\"test1\"));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", sourceWithType));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItem(\"test1\"));\n\n        percolatorExecutor.addQuery(\"test2\", termQuery(\"field1\", 1));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(2));\n        assertThat(percolate.matches(), hasItems(\"test1\", \"test2\"));\n\n\n        percolatorExecutor.removeQuery(\"test2\");\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItems(\"test1\"));\n    }","id":51462,"modified_method":"@Test\n    public void testSimplePercolator() throws Exception {\n        // introduce the doc\n        XContentBuilder doc = XContentFactory.jsonBuilder().startObject().startObject(\"doc\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject();\n        byte[] source = doc.copiedBytes();\n\n        XContentBuilder docWithType = XContentFactory.jsonBuilder().startObject().startObject(\"doc\").startObject(\"type1\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject().endObject();\n        byte[] sourceWithType = docWithType.copiedBytes();\n\n        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(0));\n\n        // add a query\n        percolatorExecutor.addQuery(\"test1\", termQuery(\"field2\", \"value\"));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItem(\"test1\"));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", sourceWithType));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItem(\"test1\"));\n\n        percolatorExecutor.addQuery(\"test2\", termQuery(\"field1\", 1));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(2));\n        assertThat(percolate.matches(), hasItems(\"test1\", \"test2\"));\n\n\n        percolatorExecutor.removeQuery(\"test2\");\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItems(\"test1\"));\n\n        // add a range query (cached)\n        // add a query\n        percolatorExecutor.addQuery(\"test1\", constantScoreQuery(FilterBuilders.rangeFilter(\"field2\").from(\"value\").includeLower(true)));\n\n        percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(\"type1\", source));\n        assertThat(percolate.matches(), hasSize(1));\n        assertThat(percolate.matches(), hasItem(\"test1\"));\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public BloomFilter filter(IndexReader reader, String fieldName, boolean asyncLoad) {\n        int currentNumDocs = reader.numDocs();\n        if (currentNumDocs == 0) {\n            return BloomFilter.EMPTY;\n        }\n        ConcurrentMap<String, BloomFilterEntry> fieldCache = cache.get(reader.getCoreCacheKey());\n        if (fieldCache == null) {\n            synchronized (creationMutex) {\n                fieldCache = cache.get(reader.getCoreCacheKey());\n                if (fieldCache == null) {\n                    ((SegmentReader) reader).addCoreClosedListener(this);\n                    fieldCache = ConcurrentCollections.newConcurrentMap();\n                    cache.put(reader.getCoreCacheKey(), fieldCache);\n                }\n            }\n        }\n        BloomFilterEntry filter = fieldCache.get(fieldName);\n        if (filter == null) {\n            synchronized (fieldCache) {\n                filter = fieldCache.get(fieldName);\n                if (filter == null) {\n                    filter = new BloomFilterEntry(currentNumDocs, BloomFilter.NONE);\n                    fieldCache.put(fieldName, filter);\n                    // now, do the async load of it...\n                    if (currentNumDocs < maxSize) {\n                        filter.loading.set(true);\n                        BloomFilterLoader loader = new BloomFilterLoader(reader, fieldName);\n                        if (asyncLoad) {\n                            threadPool.executor(ThreadPool.Names.CACHE).execute(loader);\n                        } else {\n                            loader.run();\n                            filter = fieldCache.get(fieldName);\n                        }\n                    }\n                }\n            }\n        }\n        // if we too many deletes, we need to reload the bloom filter so it will be more effective\n        if (filter.numDocs > 1000 && filter.numDocs < maxSize && (currentNumDocs / filter.numDocs) < 0.6) {\n            if (filter.loading.compareAndSet(false, true)) {\n                // do the async loading\n                BloomFilterLoader loader = new BloomFilterLoader(reader, fieldName);\n                if (asyncLoad) {\n                    threadPool.executor(ThreadPool.Names.CACHE).execute(loader);\n                } else {\n                    loader.run();\n                    filter = fieldCache.get(fieldName);\n                }\n            }\n        }\n        return filter.filter;\n    }","id":51463,"modified_method":"@Override\n    public BloomFilter filter(IndexReader reader, String fieldName, boolean asyncLoad) {\n        int currentNumDocs = reader.numDocs();\n        if (currentNumDocs == 0) {\n            return BloomFilter.EMPTY;\n        }\n        ConcurrentMap<String, BloomFilterEntry> fieldCache = cache.get(reader.getCoreCacheKey());\n        if (fieldCache == null) {\n            synchronized (creationMutex) {\n                fieldCache = cache.get(reader.getCoreCacheKey());\n                if (fieldCache == null) {\n                    if (reader instanceof SegmentReader) {\n                        ((SegmentReader) reader).addCoreClosedListener(this);\n                    }\n                    fieldCache = ConcurrentCollections.newConcurrentMap();\n                    cache.put(reader.getCoreCacheKey(), fieldCache);\n                }\n            }\n        }\n        BloomFilterEntry filter = fieldCache.get(fieldName);\n        if (filter == null) {\n            synchronized (fieldCache) {\n                filter = fieldCache.get(fieldName);\n                if (filter == null) {\n                    filter = new BloomFilterEntry(currentNumDocs, BloomFilter.NONE);\n                    fieldCache.put(fieldName, filter);\n                    // now, do the async load of it...\n                    if (currentNumDocs < maxSize) {\n                        filter.loading.set(true);\n                        BloomFilterLoader loader = new BloomFilterLoader(reader, fieldName);\n                        if (asyncLoad) {\n                            threadPool.executor(ThreadPool.Names.CACHE).execute(loader);\n                        } else {\n                            loader.run();\n                            filter = fieldCache.get(fieldName);\n                        }\n                    }\n                }\n            }\n        }\n        // if we too many deletes, we need to reload the bloom filter so it will be more effective\n        if (filter.numDocs > 1000 && filter.numDocs < maxSize && (currentNumDocs / filter.numDocs) < 0.6) {\n            if (filter.loading.compareAndSet(false, true)) {\n                // do the async loading\n                BloomFilterLoader loader = new BloomFilterLoader(reader, fieldName);\n                if (asyncLoad) {\n                    threadPool.executor(ThreadPool.Names.CACHE).execute(loader);\n                } else {\n                    loader.run();\n                    filter = fieldCache.get(fieldName);\n                }\n            }\n        }\n        return filter.filter;\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@SuppressWarnings({\"StringEquality\"})\n    @Override\n    public void refresh(IndexReader[] readers) throws Exception {\n        // do a quick check for the common case, that all are there\n        if (refreshNeeded(readers)) {\n            synchronized (idReaders) {\n                if (!refreshNeeded(readers)) {\n                    return;\n                }\n\n                // do the refresh\n\n                Map<Object, Map<String, TypeBuilder>> builders = new HashMap<Object, Map<String, TypeBuilder>>();\n\n                // first, go over and load all the id->doc map for all types\n                for (IndexReader reader : readers) {\n                    if (idReaders.containsKey(reader.getCoreCacheKey())) {\n                        // no need, continue\n                        continue;\n                    }\n\n                    ((SegmentReader) reader).addCoreClosedListener(this);\n                    HashMap<String, TypeBuilder> readerBuilder = new HashMap<String, TypeBuilder>();\n                    builders.put(reader.getCoreCacheKey(), readerBuilder);\n\n                    String field = StringHelper.intern(UidFieldMapper.NAME);\n                    TermDocs termDocs = reader.termDocs();\n                    TermEnum termEnum = reader.terms(new Term(field));\n                    try {\n                        do {\n                            Term term = termEnum.term();\n                            if (term == null || term.field() != field) break;\n                            // TODO we can optimize this, since type is the prefix, and we get terms ordered\n                            // so, only need to move to the next type once its different\n                            Uid uid = Uid.createUid(term.text());\n\n                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());\n                            if (typeBuilder == null) {\n                                typeBuilder = new TypeBuilder(reader);\n                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);\n                            }\n\n                            BytesWrap idAsBytes = checkIfCanReuse(builders, new BytesWrap(uid.id()));\n                            termDocs.seek(termEnum);\n                            while (termDocs.next()) {\n                                // when traversing, make sure to ignore deleted docs, so the key->docId will be correct\n                                if (!reader.isDeleted(termDocs.doc())) {\n                                    typeBuilder.idToDoc.put(idAsBytes, termDocs.doc());\n                                }\n                            }\n                        } while (termEnum.next());\n                    } finally {\n                        termDocs.close();\n                        termEnum.close();\n                    }\n                }\n\n                // now, go and load the docId->parentId map\n\n                for (IndexReader reader : readers) {\n                    if (idReaders.containsKey(reader.getCoreCacheKey())) {\n                        // no need, continue\n                        continue;\n                    }\n\n                    Map<String, TypeBuilder> readerBuilder = builders.get(reader.getCoreCacheKey());\n\n                    String field = StringHelper.intern(ParentFieldMapper.NAME);\n                    TermDocs termDocs = reader.termDocs();\n                    TermEnum termEnum = reader.terms(new Term(field));\n                    try {\n                        do {\n                            Term term = termEnum.term();\n                            if (term == null || term.field() != field) break;\n                            // TODO we can optimize this, since type is the prefix, and we get terms ordered\n                            // so, only need to move to the next type once its different\n                            Uid uid = Uid.createUid(term.text());\n\n                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());\n                            if (typeBuilder == null) {\n                                typeBuilder = new TypeBuilder(reader);\n                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);\n                            }\n\n                            BytesWrap idAsBytes = checkIfCanReuse(builders, new BytesWrap(uid.id()));\n                            boolean added = false; // optimize for when all the docs are deleted for this id\n\n                            termDocs.seek(termEnum);\n                            while (termDocs.next()) {\n                                // ignore deleted docs while we are at it\n                                if (!reader.isDeleted(termDocs.doc())) {\n                                    if (!added) {\n                                        typeBuilder.parentIdsValues.add(idAsBytes);\n                                        added = true;\n                                    }\n                                    typeBuilder.parentIdsOrdinals[termDocs.doc()] = typeBuilder.t;\n                                }\n                            }\n                            if (added) {\n                                typeBuilder.t++;\n                            }\n                        } while (termEnum.next());\n                    } finally {\n                        termDocs.close();\n                        termEnum.close();\n                    }\n                }\n\n\n                // now, build it back\n                for (Map.Entry<Object, Map<String, TypeBuilder>> entry : builders.entrySet()) {\n                    MapBuilder<String, SimpleIdReaderTypeCache> types = MapBuilder.newMapBuilder();\n                    for (Map.Entry<String, TypeBuilder> typeBuilderEntry : entry.getValue().entrySet()) {\n                        types.put(typeBuilderEntry.getKey(), new SimpleIdReaderTypeCache(typeBuilderEntry.getKey(),\n                                typeBuilderEntry.getValue().idToDoc,\n                                typeBuilderEntry.getValue().parentIdsValues.toArray(new BytesWrap[typeBuilderEntry.getValue().parentIdsValues.size()]),\n                                typeBuilderEntry.getValue().parentIdsOrdinals));\n                    }\n                    SimpleIdReaderCache readerCache = new SimpleIdReaderCache(entry.getKey(), types.immutableMap());\n                    idReaders.put(readerCache.readerCacheKey(), readerCache);\n                }\n            }\n        }\n    }","id":51464,"modified_method":"@SuppressWarnings({\"StringEquality\"})\n    @Override\n    public void refresh(IndexReader[] readers) throws Exception {\n        // do a quick check for the common case, that all are there\n        if (refreshNeeded(readers)) {\n            synchronized (idReaders) {\n                if (!refreshNeeded(readers)) {\n                    return;\n                }\n\n                // do the refresh\n\n                Map<Object, Map<String, TypeBuilder>> builders = new HashMap<Object, Map<String, TypeBuilder>>();\n\n                // first, go over and load all the id->doc map for all types\n                for (IndexReader reader : readers) {\n                    if (idReaders.containsKey(reader.getCoreCacheKey())) {\n                        // no need, continue\n                        continue;\n                    }\n\n                    if (reader instanceof SegmentReader) {\n                        ((SegmentReader) reader).addCoreClosedListener(this);\n                    }\n                    HashMap<String, TypeBuilder> readerBuilder = new HashMap<String, TypeBuilder>();\n                    builders.put(reader.getCoreCacheKey(), readerBuilder);\n\n                    String field = StringHelper.intern(UidFieldMapper.NAME);\n                    TermDocs termDocs = reader.termDocs();\n                    TermEnum termEnum = reader.terms(new Term(field));\n                    try {\n                        do {\n                            Term term = termEnum.term();\n                            if (term == null || term.field() != field) break;\n                            // TODO we can optimize this, since type is the prefix, and we get terms ordered\n                            // so, only need to move to the next type once its different\n                            Uid uid = Uid.createUid(term.text());\n\n                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());\n                            if (typeBuilder == null) {\n                                typeBuilder = new TypeBuilder(reader);\n                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);\n                            }\n\n                            BytesWrap idAsBytes = checkIfCanReuse(builders, new BytesWrap(uid.id()));\n                            termDocs.seek(termEnum);\n                            while (termDocs.next()) {\n                                // when traversing, make sure to ignore deleted docs, so the key->docId will be correct\n                                if (!reader.isDeleted(termDocs.doc())) {\n                                    typeBuilder.idToDoc.put(idAsBytes, termDocs.doc());\n                                }\n                            }\n                        } while (termEnum.next());\n                    } finally {\n                        termDocs.close();\n                        termEnum.close();\n                    }\n                }\n\n                // now, go and load the docId->parentId map\n\n                for (IndexReader reader : readers) {\n                    if (idReaders.containsKey(reader.getCoreCacheKey())) {\n                        // no need, continue\n                        continue;\n                    }\n\n                    Map<String, TypeBuilder> readerBuilder = builders.get(reader.getCoreCacheKey());\n\n                    String field = StringHelper.intern(ParentFieldMapper.NAME);\n                    TermDocs termDocs = reader.termDocs();\n                    TermEnum termEnum = reader.terms(new Term(field));\n                    try {\n                        do {\n                            Term term = termEnum.term();\n                            if (term == null || term.field() != field) break;\n                            // TODO we can optimize this, since type is the prefix, and we get terms ordered\n                            // so, only need to move to the next type once its different\n                            Uid uid = Uid.createUid(term.text());\n\n                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());\n                            if (typeBuilder == null) {\n                                typeBuilder = new TypeBuilder(reader);\n                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);\n                            }\n\n                            BytesWrap idAsBytes = checkIfCanReuse(builders, new BytesWrap(uid.id()));\n                            boolean added = false; // optimize for when all the docs are deleted for this id\n\n                            termDocs.seek(termEnum);\n                            while (termDocs.next()) {\n                                // ignore deleted docs while we are at it\n                                if (!reader.isDeleted(termDocs.doc())) {\n                                    if (!added) {\n                                        typeBuilder.parentIdsValues.add(idAsBytes);\n                                        added = true;\n                                    }\n                                    typeBuilder.parentIdsOrdinals[termDocs.doc()] = typeBuilder.t;\n                                }\n                            }\n                            if (added) {\n                                typeBuilder.t++;\n                            }\n                        } while (termEnum.next());\n                    } finally {\n                        termDocs.close();\n                        termEnum.close();\n                    }\n                }\n\n\n                // now, build it back\n                for (Map.Entry<Object, Map<String, TypeBuilder>> entry : builders.entrySet()) {\n                    MapBuilder<String, SimpleIdReaderTypeCache> types = MapBuilder.newMapBuilder();\n                    for (Map.Entry<String, TypeBuilder> typeBuilderEntry : entry.getValue().entrySet()) {\n                        types.put(typeBuilderEntry.getKey(), new SimpleIdReaderTypeCache(typeBuilderEntry.getKey(),\n                                typeBuilderEntry.getValue().idToDoc,\n                                typeBuilderEntry.getValue().parentIdsValues.toArray(new BytesWrap[typeBuilderEntry.getValue().parentIdsValues.size()]),\n                                typeBuilderEntry.getValue().parentIdsOrdinals));\n                    }\n                    SimpleIdReaderCache readerCache = new SimpleIdReaderCache(entry.getKey(), types.immutableMap());\n                    idReaders.put(readerCache.readerCacheKey(), readerCache);\n                }\n            }\n        }\n    }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            Object filterKey = filter;\n            if (filter instanceof CacheKeyFilter) {\n                filterKey = ((CacheKeyFilter) filter).cacheKey();\n            }\n            FilterCacheKey cacheKey = new FilterCacheKey(cache.index().name(), reader.getCoreCacheKey(), filterKey);\n            Cache<FilterCacheKey, FilterCacheValue<DocSet>> innerCache = cache.indicesFilterCache.cache();\n\n            FilterCacheValue<DocSet> cacheValue = innerCache.getIfPresent(cacheKey);\n            if (cacheValue == null) {\n                if (!cache.seenReaders.containsKey(reader.getCoreCacheKey())) {\n                    Boolean previous = cache.seenReaders.putIfAbsent(reader.getCoreCacheKey(), Boolean.TRUE);\n                    if (previous == null) {\n                        ((SegmentReader) reader).addCoreClosedListener(cache);\n                        cache.seenReadersCount.inc();\n                    }\n                }\n\n                DocIdSet docIdSet = filter.getDocIdSet(reader);\n                DocSet docSet = FilterCacheValue.cacheable(reader, docIdSet);\n                cacheValue = new FilterCacheValue<DocSet>(docSet);\n                // we might put the same one concurrently, that's fine, it will be replaced and the removal\n                // will be called\n                cache.totalMetric.inc(cacheValue.value().sizeInBytes());\n                innerCache.put(cacheKey, cacheValue);\n            }\n\n            return cacheValue.value() == DocSet.EMPTY_DOC_SET ? null : cacheValue.value();\n        }","id":51465,"modified_method":"@Override\n        public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            Object filterKey = filter;\n            if (filter instanceof CacheKeyFilter) {\n                filterKey = ((CacheKeyFilter) filter).cacheKey();\n            }\n            FilterCacheKey cacheKey = new FilterCacheKey(cache.index().name(), reader.getCoreCacheKey(), filterKey);\n            Cache<FilterCacheKey, FilterCacheValue<DocSet>> innerCache = cache.indicesFilterCache.cache();\n\n            FilterCacheValue<DocSet> cacheValue = innerCache.getIfPresent(cacheKey);\n            if (cacheValue == null) {\n                if (!cache.seenReaders.containsKey(reader.getCoreCacheKey())) {\n                    Boolean previous = cache.seenReaders.putIfAbsent(reader.getCoreCacheKey(), Boolean.TRUE);\n                    if (previous == null && (reader instanceof SegmentReader)) {\n                        ((SegmentReader) reader).addCoreClosedListener(cache);\n                        cache.seenReadersCount.inc();\n                    }\n                }\n\n                DocIdSet docIdSet = filter.getDocIdSet(reader);\n                DocSet docSet = FilterCacheValue.cacheable(reader, docIdSet);\n                cacheValue = new FilterCacheValue<DocSet>(docSet);\n                // we might put the same one concurrently, that's fine, it will be replaced and the removal\n                // will be called\n                cache.totalMetric.inc(cacheValue.value().sizeInBytes());\n                innerCache.put(cacheKey, cacheValue);\n            }\n\n            return cacheValue.value() == DocSet.EMPTY_DOC_SET ? null : cacheValue.value();\n        }","commit_id":"aeae38025803eead4424a7abd90d16b62021fadc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  protected Result calculateResult(@NotNull Expression[] params, ExpressionContext context, boolean quick) {\n    String text = getTextResult(params, context, true);\n    if (StringUtil.isNotEmpty(text)) {\n      return new TextResult(convertString(text));\n    }\n    return null;\n  }","id":51466,"modified_method":"@Override\n  protected Result calculateResult(@NotNull Expression[] params, ExpressionContext context, boolean quick) {\n    String text = getTextResult(params, context, true);\n    return text != null ? new TextResult(!text.isEmpty() ? convertString(text) : \"\") : null;\n  }","commit_id":"bbb62009a823bb3dff92bf625c885e420905b396","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ToolsGroup readScheme(final Document document) throws InvalidDataException, IOException, JDOMException {\n    Element root = document.getRootElement();\n    if (root == null || !TOOL_SET.equals(root.getName())){\n      throw new InvalidDataException();\n    }\n\n    String groupName = root.getAttributeValue(ATTRIBUTE_NAME);\n    ToolsGroup result = new ToolsGroup(groupName);\n\n    for (final Object o : root.getChildren(TOOL)) {\n      Element element = (Element)o;\n\n      Tool tool = new Tool();\n      tool.setName(ToolManager.convertString(element.getAttributeValue(NAME)));\n      tool.setDescription(ToolManager.convertString(element.getAttributeValue(DESCRIPTION)));\n      tool.setShownInMainMenu(Boolean.valueOf(element.getAttributeValue(SHOW_IN_MAIN_MENU)).booleanValue());\n      tool.setShownInEditor(Boolean.valueOf(element.getAttributeValue(SHOW_IN_EDITOR)).booleanValue());\n      tool.setShownInProjectViews(Boolean.valueOf(element.getAttributeValue(SHOW_IN_PROJECT)).booleanValue());\n      tool.setShownInSearchResultsPopup(Boolean.valueOf(element.getAttributeValue(SHOW_IN_SEARCH_POPUP)).booleanValue());\n      tool.setEnabled(!Boolean.valueOf(element.getAttributeValue(DISABLED)).booleanValue());\n      tool.setUseConsole(Boolean.valueOf(element.getAttributeValue(USE_CONSOLE)).booleanValue());\n      tool.setFilesSynchronizedAfterRun(Boolean.valueOf(element.getAttributeValue(SYNCHRONIZE_AFTER_EXECUTION)).booleanValue());\n\n      Element exec = element.getChild(EXEC);\n      if (exec != null) {\n        for (final Object o1 : exec.getChildren(ELEMENT_OPTION)) {\n          Element optionElement = (Element)o1;\n\n          String name = optionElement.getAttributeValue(ATTRIBUTE_NAME);\n          String value = optionElement.getAttributeValue(ATTRIBUTE_VALUE);\n\n          if (WORKING_DIRECTORY.equals(name)) {\n            if (value != null) {\n              String appHome = PathManager.getHomePath().replace(File.separatorChar, '/');\n              tool.setWorkingDirectory(StringUtil.replace(value, APPLICATION_HOME_MACRO, appHome));\n            }\n          }\n          if (COMMAND.equals(name)) {\n            tool.setProgram(ToolManager.convertString(value));\n          }\n          if (PARAMETERS.equals(name)) {\n            tool.setParameters(ToolManager.convertString(value));\n          }\n        }\n      }\n\n      for (final Object o2 : element.getChildren(FILTER)) {\n        Element childNode = (Element)o2;\n\n        FilterInfo filterInfo = new FilterInfo();\n        filterInfo.readExternal(childNode);\n        tool.addOutputFilter(filterInfo);\n      }\n\n      tool.setGroup(groupName);\n      result.addElement(tool);\n    }\n\n    return result;\n\n  }","id":51467,"modified_method":"public ToolsGroup readScheme(final Document document) throws InvalidDataException, IOException, JDOMException {\n    Element root = document.getRootElement();\n    if (root == null || !TOOL_SET.equals(root.getName())){\n      throw new InvalidDataException();\n    }\n\n    String groupName = root.getAttributeValue(ATTRIBUTE_NAME);\n    ToolsGroup result = new ToolsGroup(groupName);\n\n    final PathMacroManager macroManager = PathMacroManager.getInstance(ApplicationManager.getApplication());\n\n    for (final Object o : root.getChildren(TOOL)) {\n      Element element = (Element)o;\n\n      Tool tool = new Tool();\n      tool.setName(ToolManager.convertString(element.getAttributeValue(NAME)));\n      tool.setDescription(ToolManager.convertString(element.getAttributeValue(DESCRIPTION)));\n      tool.setShownInMainMenu(Boolean.valueOf(element.getAttributeValue(SHOW_IN_MAIN_MENU)).booleanValue());\n      tool.setShownInEditor(Boolean.valueOf(element.getAttributeValue(SHOW_IN_EDITOR)).booleanValue());\n      tool.setShownInProjectViews(Boolean.valueOf(element.getAttributeValue(SHOW_IN_PROJECT)).booleanValue());\n      tool.setShownInSearchResultsPopup(Boolean.valueOf(element.getAttributeValue(SHOW_IN_SEARCH_POPUP)).booleanValue());\n      tool.setEnabled(!Boolean.valueOf(element.getAttributeValue(DISABLED)).booleanValue());\n      tool.setUseConsole(Boolean.valueOf(element.getAttributeValue(USE_CONSOLE)).booleanValue());\n      tool.setFilesSynchronizedAfterRun(Boolean.valueOf(element.getAttributeValue(SYNCHRONIZE_AFTER_EXECUTION)).booleanValue());\n\n      Element exec = element.getChild(EXEC);\n      if (exec != null) {\n        for (final Object o1 : exec.getChildren(ELEMENT_OPTION)) {\n          Element optionElement = (Element)o1;\n\n          String name = optionElement.getAttributeValue(ATTRIBUTE_NAME);\n          String value = optionElement.getAttributeValue(ATTRIBUTE_VALUE);\n\n          if (WORKING_DIRECTORY.equals(name)) {\n            if (value != null) {\n              final String replace = macroManager.expandPath(value).replace('/', File.separatorChar);\n              tool.setWorkingDirectory(replace);\n            }\n          }\n          if (COMMAND.equals(name)) {\n            tool.setProgram(macroManager.expandPath(ToolManager.convertString(value)));\n          }\n          if (PARAMETERS.equals(name)) {\n            tool.setParameters(macroManager.expandPath(ToolManager.convertString(value)));\n          }\n        }\n      }\n\n      for (final Object o2 : element.getChildren(FILTER)) {\n        Element childNode = (Element)o2;\n\n        FilterInfo filterInfo = new FilterInfo();\n        filterInfo.readExternal(childNode);\n        tool.addOutputFilter(filterInfo);\n      }\n\n      tool.setGroup(groupName);\n      result.addElement(tool);\n    }\n\n    return result;\n\n  }","commit_id":"1bcfc15049ea9a1c3032b2787448176bc9c6e1ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void saveTool(Tool tool, Element groupElement) {\n    Element element = new Element(TOOL);\n    if (tool.getName() != null) {\n      element.setAttribute(NAME, tool.getName());\n    }\n    if (tool.getDescription() != null) {\n      element.setAttribute(DESCRIPTION, tool.getDescription());\n    }\n\n    element.setAttribute(SHOW_IN_MAIN_MENU, Boolean.toString(tool.isShownInMainMenu()));\n    element.setAttribute(SHOW_IN_EDITOR, Boolean.toString(tool.isShownInEditor()));\n    element.setAttribute(SHOW_IN_PROJECT, Boolean.toString(tool.isShownInProjectViews()));\n    element.setAttribute(SHOW_IN_SEARCH_POPUP, Boolean.toString(tool.isShownInSearchResultsPopup()));\n    element.setAttribute(DISABLED, Boolean.toString(!tool.isEnabled()));\n    element.setAttribute(USE_CONSOLE, Boolean.toString(tool.isUseConsole()));\n    element.setAttribute(SYNCHRONIZE_AFTER_EXECUTION, Boolean.toString(tool.synchronizeAfterExecution()));\n\n    Element taskElement = new Element(EXEC);\n\n    Element option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, COMMAND);\n    if (tool.getProgram() != null ) {\n      option.setAttribute(ATTRIBUTE_VALUE, tool.getProgram());\n    }\n\n    option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, PARAMETERS);\n    if (tool.getParameters() != null ) {\n      option.setAttribute(ATTRIBUTE_VALUE, tool.getParameters());\n    }\n\n    option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, WORKING_DIRECTORY);\n    if (tool.getWorkingDirectory() != null ) {\n      String appHome = PathManager.getHomePath().replace(File.separatorChar, '/');\n      option.setAttribute(ATTRIBUTE_VALUE, StringUtil.replace(tool.getWorkingDirectory(), appHome, APPLICATION_HOME_MACRO));\n    }\n\n    element.addContent(taskElement);\n\n    FilterInfo[] filters = tool.getOutputFilters();\n    for (FilterInfo filter : filters) {\n      Element filterElement = new Element(FILTER);\n      filter.writeExternal(filterElement);\n      element.addContent(filterElement);\n    }\n\n    groupElement.addContent(element);\n  }","id":51468,"modified_method":"private void saveTool(Tool tool, Element groupElement) {\n    Element element = new Element(TOOL);\n    if (tool.getName() != null) {\n      element.setAttribute(NAME, tool.getName());\n    }\n    if (tool.getDescription() != null) {\n      element.setAttribute(DESCRIPTION, tool.getDescription());\n    }\n\n    element.setAttribute(SHOW_IN_MAIN_MENU, Boolean.toString(tool.isShownInMainMenu()));\n    element.setAttribute(SHOW_IN_EDITOR, Boolean.toString(tool.isShownInEditor()));\n    element.setAttribute(SHOW_IN_PROJECT, Boolean.toString(tool.isShownInProjectViews()));\n    element.setAttribute(SHOW_IN_SEARCH_POPUP, Boolean.toString(tool.isShownInSearchResultsPopup()));\n    element.setAttribute(DISABLED, Boolean.toString(!tool.isEnabled()));\n    element.setAttribute(USE_CONSOLE, Boolean.toString(tool.isUseConsole()));\n    element.setAttribute(SYNCHRONIZE_AFTER_EXECUTION, Boolean.toString(tool.synchronizeAfterExecution()));\n\n    Element taskElement = new Element(EXEC);\n\n    final PathMacroManager macroManager = PathMacroManager.getInstance(ApplicationManager.getApplication());\n\n    Element option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, COMMAND);\n    if (tool.getProgram() != null ) {\n      option.setAttribute(ATTRIBUTE_VALUE, macroManager.collapsePath(tool.getProgram()));\n    }\n\n    option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, PARAMETERS);\n    if (tool.getParameters() != null ) {\n      option.setAttribute(ATTRIBUTE_VALUE, macroManager.collapsePath(tool.getParameters()));\n    }\n\n    option = new Element(ELEMENT_OPTION);\n    taskElement.addContent(option);\n    option.setAttribute(ATTRIBUTE_NAME, WORKING_DIRECTORY);\n    if (tool.getWorkingDirectory() != null ) {\n      option.setAttribute(ATTRIBUTE_VALUE, macroManager.collapsePath(tool.getWorkingDirectory()).replace(File.separatorChar, '/'));\n    }\n\n    element.addContent(taskElement);\n\n    FilterInfo[] filters = tool.getOutputFilters();\n    for (FilterInfo filter : filters) {\n      Element filterElement = new Element(FILTER);\n      filter.writeExternal(filterElement);\n      element.addContent(filterElement);\n    }\n\n    groupElement.addContent(element);\n  }","commit_id":"1bcfc15049ea9a1c3032b2787448176bc9c6e1ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Evaluetes does <tt>timestamp<\/tt> is in the given time period.\n     *\n     * @param timestamp Date\n     * @param startDate Date the start of the period\n     * @param endDate Date the end of the period\n     * @return boolean\n     */\n    static boolean isInPeriod(Date timestamp, Date startDate, Date endDate)\n    {\n        if(startDate == null)\n        {\n            if(endDate == null)\n                return true;\n            else\n                return timestamp.before(endDate);\n        }\n        else\n        {\n            if(endDate == null)\n                return timestamp.after(startDate);\n            else\n                return\n                    timestamp.after(startDate) && timestamp.before(endDate);\n        }\n    }","id":51469,"modified_method":"/**\n     * Evaluetes does <tt>timestamp<\/tt> is in the given time period.\n     *\n     * @param timestamp Date\n     * @param startDate Date the start of the period\n     * @param endDate Date the end of the period\n     * @return boolean\n     */\n    static boolean isInPeriod(Date timestamp, Date startDate, Date endDate)\n    {\n        Long startLong;\n        Long endLong;\n        Long tsLong = timestamp.getTime();\n\n        if(startDate == null)\n            startLong = Long.MIN_VALUE;\n        else\n            startLong = startDate.getTime();\n\n        if(endDate == null)\n            endLong = Long.MAX_VALUE;\n        else\n            endLong = endDate.getTime();\n\n        return startLong <= tsLong && tsLong < endLong;\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Used to limit the files if any starting or ending date exist\n     * So only few files to be searched.\n     *\n     * @param filelist Iterator\n     * @param startDate Date\n     * @param endDate Date\n     * @param reverseOrder reverse order of files\n     * @return Vector\n     */\n    static Vector<String> filterFilesByDate(\n        Iterator<String> filelist, Date startDate, Date endDate,\n        final boolean reverseOrder)\n    {\n        if(startDate == null && endDate == null)\n        {\n            // no filtering needed then just return the same list\n            Vector<String> result = new Vector<String>();\n            while (filelist.hasNext())\n            {\n                result.add(filelist.next());\n            }\n\n            Collections.sort(result, new Comparator<String>() {\n\n                public int compare(String o1, String o2)\n                {\n                    if(reverseOrder)\n                        return o2.compareTo(o1);\n                    else\n                        return o1.compareTo(o2);\n                }\n            });\n\n            return result;\n        }\n        // first convert all files to long\n        TreeSet<Long> files = new TreeSet<Long>();\n        while (filelist.hasNext())\n        {\n            String filename = filelist.next();\n\n            files.add(\n                Long.parseLong(filename.substring(0, filename.length() - 4)));\n        }\n\n        TreeSet<Long> resultAsLong = new TreeSet<Long>();\n\n        // Temporary fix of a NoSuchElementException\n        if(files.size() == 0)\n        {\n            Vector<String> result = new Vector<String>();\n            Iterator<Long> iter = resultAsLong.iterator();\n\n            while (iter.hasNext())\n            {\n                Long item = iter.next();\n                result.add(item.toString() + \".xml\");\n            }\n            return result;\n        }\n\n        // if there is no startDate limit only to end date\n        if(startDate == null)\n        {\n            Long endLong = Long.valueOf(endDate.getTime());\n            files.add(endLong);\n\n            resultAsLong.addAll(files.subSet(files.first(), endLong));\n\n            resultAsLong.remove(endLong);\n        }\n        else if(endDate == null)\n        {\n            // end date is null get all the inclusive the one record before the startdate\n            Long startLong = Long.valueOf(startDate.getTime());\n\n            if(files.size() > 0 &&\n               (startLong.longValue() < (files.first()).longValue()))\n            {\n                // if the start date is before any existing file date\n                // then return all the files\n                resultAsLong = files;\n            }\n            else\n            {\n                files.add(startLong);\n\n                resultAsLong.addAll(files.subSet(startLong, files.last()));\n                resultAsLong.add(files.last());\n\n                // here we must get and the element before startLong\n                resultAsLong.add(files.subSet(files.first(), startLong).last());\n                resultAsLong.remove(startLong);\n            }\n        }\n        else\n        {\n            // if both are present we must return all the elements between\n            // the two dates and the one before the start date\n            Long startLong = Long.valueOf(startDate.getTime());\n            Long endLong = Long.valueOf(endDate.getTime());\n            files.add(startLong);\n            files.add(endLong);\n\n            resultAsLong.addAll(files.subSet(startLong, endLong));\n\n            // here we must get and the element before startLong\n            SortedSet<Long> theFirstToStart\n                = files.subSet(files.first(), startLong);\n            if(!theFirstToStart.isEmpty())\n                resultAsLong.add(theFirstToStart.last());\n\n            resultAsLong.remove(startLong);\n            resultAsLong.remove(endLong);\n        }\n\n        Vector<String> result = new Vector<String>();\n\n        Iterator<Long> iter = resultAsLong.iterator();\n        while (iter.hasNext())\n        {\n            Long item = iter.next();\n            result.add(item.toString() + \".xml\");\n        }\n\n        Collections.sort(result, new Comparator<String>() {\n\n            public int compare(String o1, String o2)\n            {\n                if(reverseOrder)\n                    return o2.compareTo(o1);\n                else\n                    return o1.compareTo(o2);\n            }\n        });\n\n        return result;\n    }","id":51470,"modified_method":"/**\n     * Used to limit the files if any starting or ending date exist\n     * So only few files to be searched.\n     *\n     * @param filelist Iterator\n     * @param startDate Date\n     * @param endDate Date\n     * @param reverseOrder reverse order of files\n     * @return Vector\n     */\n    static Vector<String> filterFilesByDate(\n        Iterator<String> filelist, Date startDate, Date endDate,\n        final boolean reverseOrder)\n    {\n        if(startDate == null && endDate == null)\n        {\n            // no filtering needed then just return the same list\n            Vector<String> result = new Vector<String>();\n            while (filelist.hasNext())\n            {\n                result.add(filelist.next());\n            }\n\n            Collections.sort(result, new Comparator<String>() {\n\n                public int compare(String o1, String o2)\n                {\n                    if(reverseOrder)\n                        return o2.compareTo(o1);\n                    else\n                        return o1.compareTo(o2);\n                }\n            });\n\n            return result;\n        }\n        // first convert all files to long\n        TreeSet<Long> files = new TreeSet<Long>();\n        while (filelist.hasNext())\n        {\n            String filename = filelist.next();\n\n            files.add(\n                Long.parseLong(filename.substring(0, filename.length() - 4)));\n        }\n\n        TreeSet<Long> resultAsLong = new TreeSet<Long>();\n\n        // Temporary fix of a NoSuchElementException\n        if(files.size() == 0)\n        {\n            return new Vector<String>();\n        }\n\n        Long startLong;\n        Long endLong;\n\n        if(startDate == null)\n            startLong = Long.MIN_VALUE;\n        else\n            startLong = startDate.getTime();\n\n        if(endDate == null)\n            endLong = Long.MAX_VALUE;\n        else\n            endLong = endDate.getTime();\n\n        // get all records inclusive the one before the startdate\n        for(Long f : files)\n        {\n            if(startLong <= f\n               && f <= endLong)\n            {\n                resultAsLong.add(f);\n            }\n        }\n\n        // get the subset before the start date, to get its last element\n        // if exists\n        if(!files.isEmpty() && files.first() <= startLong)\n        {\n            SortedSet<Long> setBeforeTheInterval =\n                files.subSet(files.first(), true, startLong, true);\n            if(!setBeforeTheInterval.isEmpty())\n                resultAsLong.add(setBeforeTheInterval.last());\n        }\n\n        Vector<String> result = new Vector<String>();\n\n        Iterator<Long> iter = resultAsLong.iterator();\n        while (iter.hasNext())\n        {\n            Long item = iter.next();\n            result.add(item.toString() + \".xml\");\n        }\n\n        Collections.sort(result, new Comparator<String>() {\n\n            public int compare(String o1, String o2)\n            {\n                if(reverseOrder)\n                    return o2.compareTo(o1);\n                else\n                    return o1.compareTo(o2);\n            }\n        });\n\n        return result;\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * tests all read methods (finders)\n     */\n    public void readRecordsFromMultiChat()\n    {\n        ChatRoom room = null;\n\n        try\n        {\n            room = mockMultiChat.findRoom(TEST_ROOM_NAME);\n\n        }catch(Exception ex)\n        {\n            fail(\"Cannot find room!\" + ex.getMessage());\n        }\n\n        /**\n         * This matches all written messages, they are minimum 5\n         */\n        Collection<EventObject> rs\n            = msgHistoryService.findByKeyword(room, \"test\");\n\n        assertTrue(\"Nothing found findByKeyword \", !rs.isEmpty());\n\n        List<String> msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        /**\n         * Will test case sensitive and insensitive search\n         */\n        rs = msgHistoryService.findByKeyword(room, \"Test\", false);\n\n        assertTrue(\"Nothing found findByKeyword caseINsensitive search\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        rs = msgHistoryService.findByKeyword(room, \"Test\", true);\n\n        assertFalse(\"Something found by findByKeyword casesensitive search\", !rs.isEmpty());\n\n        /**\n         * This must match also many messages, as tests are run many times\n         * but the minimum is 3\n         */\n        rs = msgHistoryService.findByEndDate(room, controlDate2);\n\n        assertTrue(\"Nothing found findByEndDate\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByEndDate\", msgs.size() >= 3);\n\n        /**\n         * This must find also many messages but atleast one\n         */\n        rs = msgHistoryService.findByKeywords(\n            room,\n            new String[]{\"test\", \"word2\"});\n\n        assertTrue(\"Nothing found findByKeywords\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertTrue(\"Messages too few - findByKeywords\", msgs.size() >= 1);\n\n        /**\n         * Nothing to be found\n         */\n        rs = msgHistoryService.findByKeywords(\n            room,\n            new String[]{\"test1\", \"word2\"});\n\n        assertFalse(\"Something found findByKeywords\", !rs.isEmpty());\n\n        /**\n         * must find 2 messages\n         */\n        rs = msgHistoryService.findByPeriod(\n            room, controlDate1, controlDate2);\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertEquals(\"Messages must be 2\", msgs.size(), 2);\n\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n\n        /**\n         * must find 1 record\n         */\n        rs = msgHistoryService.findByPeriod(\n            room, controlDate1, controlDate2, new String[]{\"word2\"});\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertEquals(\"Messages must be 1\", msgs.size(), 1);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n\n        /**\n         * must find 2 records\n         */\n        rs = msgHistoryService.findByStartDate(room, controlDate2);\n\n        assertTrue(\"Nothing found findByStartDate\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 2\", msgs.size(), 2);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the last 3 messages\n         */\n        rs = msgHistoryService.findLast(room, 3);\n\n        assertTrue(\"Nothing found 8\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the 3 messages after controlDate1\n         */\n        rs = msgHistoryService.findFirstMessagesAfter(room, controlDate1, 3);\n\n        assertTrue(\"Nothing found 9\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n\n        /**\n         * Must return exactly the 3 messages before controlDate2\n         */\n        rs = msgHistoryService.findLastMessagesBefore(room, controlDate2, 3);\n\n        assertTrue(\"Nothing found 10\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[0].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n    }","id":51471,"modified_method":"/**\n     * tests all read methods (finders)\n     */\n    public void readRecordsFromMultiChat()\n    {\n        ChatRoom room = null;\n\n        try\n        {\n            room = mockMultiChat.findRoom(TEST_ROOM_NAME);\n\n        }catch(Exception ex)\n        {\n            fail(\"Cannot find room!\" + ex.getMessage());\n        }\n\n        /**\n         * This matches all written messages, they are minimum 5\n         */\n        Collection<EventObject> rs\n            = msgHistoryService.findByKeyword(room, \"test\");\n\n        assertTrue(\"Nothing found findByKeyword \", !rs.isEmpty());\n\n        List<String> msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        /**\n         * Will test case sensitive and insensitive search\n         */\n        rs = msgHistoryService.findByKeyword(room, \"Test\", false);\n\n        assertTrue(\"Nothing found findByKeyword caseINsensitive search\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        rs = msgHistoryService.findByKeyword(room, \"Test\", true);\n\n        assertFalse(\"Something found by findByKeyword casesensitive search\", !rs.isEmpty());\n\n        /**\n         * This must match also many messages, as tests are run many times\n         * but the minimum is 3\n         */\n        rs = msgHistoryService.findByEndDate(room, controlDate2);\n\n        assertTrue(\"Nothing found findByEndDate\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertTrue(\"Messages too few - findByEndDate\", msgs.size() >= 3);\n\n        /**\n         * This must find also many messages but atleast one\n         */\n        rs = msgHistoryService.findByKeywords(\n            room,\n            new String[]{\"test\", \"word2\"});\n\n        assertTrue(\"Nothing found findByKeywords\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertTrue(\"Messages too few - findByKeywords\", msgs.size() >= 1);\n\n        /**\n         * Nothing to be found\n         */\n        rs = msgHistoryService.findByKeywords(\n            room,\n            new String[]{\"test1\", \"word2\"});\n\n        assertFalse(\"Something found findByKeywords\", !rs.isEmpty());\n\n        /**\n         * must find 2 messages\n         */\n        rs = msgHistoryService.findByPeriod(\n            room, controlDate1, controlDate2);\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertEquals(\"Messages must be 2\",  2, msgs.size());\n\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n\n        /**\n         * must find 1 record\n         */\n        rs = msgHistoryService.findByPeriod(\n            room, controlDate1, controlDate2, new String[]{\"word2\"});\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getChatMessages(rs);\n\n        assertEquals(\"Messages must be 1\", 1, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n\n        /**\n         * must find 2 records\n         */\n        rs = msgHistoryService.findByStartDate(room, controlDate2);\n\n        assertTrue(\"Nothing found findByStartDate\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 2\", 2, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the last 3 messages\n         */\n        rs = msgHistoryService.findLast(room, 3);\n\n        assertTrue(\"Nothing found 8\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the 3 messages after controlDate1\n         */\n        rs = msgHistoryService.findFirstMessagesAfter(room, controlDate1, 3);\n\n        assertTrue(\"Nothing found 9\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n\n        /**\n         * Must return exactly the 3 messages before controlDate2\n         */\n        rs = msgHistoryService.findLastMessagesBefore(room, controlDate2, 3);\n\n        assertTrue(\"Nothing found 10\", !rs.isEmpty());\n        msgs = getChatMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[0].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * tests all read methods (finders)\n     */\n    public void readRecords()\n    {\n        /**\n         * This matches all written messages, they are minimum 5\n         */\n        Collection<EventObject> rs\n            = msgHistoryService.findByKeyword(testMetaContact, \"test\");\n\n        assertTrue(\"Nothing found findByKeyword \", !rs.isEmpty());\n\n        List<String> msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        /**\n         * Will test case sensitive and insensitive search\n         */\n        rs = msgHistoryService.findByKeyword(testMetaContact, \"Test\", false);\n\n        assertTrue(\n            \"Nothing found findByKeyword caseINsensitive search\",\n            !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        rs = msgHistoryService.findByKeyword(testMetaContact, \"Test\", true);\n\n        assertFalse(\n            \"Something found by findByKeyword casesensitive search\",\n            !rs.isEmpty());\n\n        /**\n         * This must match also many messages, as tests are run many times\n         * but the minimum is 3\n         */\n        rs = msgHistoryService.findByEndDate(testMetaContact, controlDate2);\n\n        assertTrue(\"Nothing found findByEndDate\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByEndDate\", msgs.size() >= 3);\n\n        /**\n         * This must find also many messages but atleast one\n         */\n        rs = msgHistoryService.findByKeywords(\n            testMetaContact,\n            new String[]{\"test\", \"word2\"});\n\n        assertTrue(\"Nothing found findByKeywords\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertTrue(\"Messages too few - findByKeywords\", msgs.size() >= 1);\n\n        /**\n         * Nothing to be found\n         */\n        rs = msgHistoryService.findByKeywords(\n            testMetaContact,\n            new String[]{\"test1\", \"word2\"});\n\n        assertFalse(\"Something found findByKeywords\", !rs.isEmpty());\n\n        /**\n         * must find 2 messages\n         */\n        rs = msgHistoryService.findByPeriod(\n            testMetaContact, controlDate1, controlDate2);\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertEquals(\"Messages must be 2\", msgs.size(), 2);\n\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n\n        /**\n         * must find 1 record\n         */\n        rs = msgHistoryService.findByPeriod(\n            testMetaContact, controlDate1, controlDate2, new String[]{\"word2\"});\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertEquals(\"Messages must be 1\", msgs.size(), 1);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n\n        /**\n         * must find 2 records\n         */\n        rs = msgHistoryService.findByStartDate(testMetaContact, controlDate2);\n\n        assertTrue(\"Nothing found findByStartDate\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 2\", msgs.size(), 2);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the last 3 messages\n         */\n        rs = msgHistoryService.findLast(testMetaContact, 3);\n\n        assertTrue(\"Nothing found 8\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the 3 messages after controlDate1\n         */\n        rs = msgHistoryService.findFirstMessagesAfter(testMetaContact, controlDate1, 3);\n\n        assertTrue(\"Nothing found 9\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n\n        /**\n         * Must return exactly the 3 messages before controlDate2\n         */\n        rs = msgHistoryService.findLastMessagesBefore(testMetaContact, controlDate2, 3);\n\n        assertTrue(\"Nothing found 10\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", msgs.size(), 3);\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[0].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n    }","id":51472,"modified_method":"/**\n     * tests all read methods (finders)\n     */\n    public void readRecords()\n    {\n        /**\n         * This matches all written messages, they are minimum 5\n         */\n        Collection<EventObject> rs\n            = msgHistoryService.findByKeyword(testMetaContact, \"test\");\n\n        assertTrue(\"Nothing found findByKeyword \", !rs.isEmpty());\n\n        List<String> msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        /**\n         * Will test case sensitive and insensitive search\n         */\n        rs = msgHistoryService.findByKeyword(testMetaContact, \"Test\", false);\n\n        assertTrue(\n            \"Nothing found findByKeyword caseINsensitive search\",\n            !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByKeyword\", msgs.size() >= 5);\n\n        rs = msgHistoryService.findByKeyword(testMetaContact, \"Test\", true);\n\n        assertFalse(\n            \"Something found by findByKeyword casesensitive search\",\n            !rs.isEmpty());\n\n        /**\n         * This must match also many messages, as tests are run many times\n         * but the minimum is 3\n         */\n        rs = msgHistoryService.findByEndDate(testMetaContact, controlDate2);\n\n        assertTrue(\"Nothing found findByEndDate\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertTrue(\"Messages too few - findByEndDate\", msgs.size() >= 3);\n\n        /**\n         * This must find also many messages but atleast one\n         */\n        rs = msgHistoryService.findByKeywords(\n            testMetaContact,\n            new String[]{\"test\", \"word2\"});\n\n        assertTrue(\"Nothing found findByKeywords\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertTrue(\"Messages too few - findByKeywords\", msgs.size() >= 1);\n\n        /**\n         * Nothing to be found\n         */\n        rs = msgHistoryService.findByKeywords(\n            testMetaContact,\n            new String[]{\"test1\", \"word2\"});\n\n        assertFalse(\"Something found findByKeywords\", !rs.isEmpty());\n\n        /**\n         * must find 2 messages\n         */\n        rs = msgHistoryService.findByPeriod(\n            testMetaContact, controlDate1, controlDate2);\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertEquals(\"Messages must be 2\", 2, msgs.size());\n\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n\n        /**\n         * must find 1 record\n         */\n        rs = msgHistoryService.findByPeriod(\n            testMetaContact, controlDate1, controlDate2, new String[]{\"word2\"});\n\n        assertTrue(\"Nothing found findByPeriod\", !rs.isEmpty());\n\n        msgs = getMessages(rs);\n\n        assertEquals(\"Messages must be 1\", 1, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n\n        /**\n         * must find 2 records\n         */\n        rs = msgHistoryService.findByStartDate(testMetaContact, controlDate2);\n\n        assertTrue(\"Nothing found findByStartDate\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 2\", 2, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the last 3 messages\n         */\n        rs = msgHistoryService.findLast(testMetaContact, 3);\n\n        assertTrue(\"Nothing found 8\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[4].getContent()));\n\n        /**\n         * Must return exactly the 3 messages after controlDate1\n         */\n        rs = msgHistoryService.findFirstMessagesAfter(testMetaContact, controlDate1, 3);\n\n        assertTrue(\"Nothing found 9\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[3].getContent()));\n\n        /**\n         * Must return exactly the 3 messages before controlDate2\n         */\n        rs = msgHistoryService.findLastMessagesBefore(testMetaContact, controlDate2, 3);\n\n        assertTrue(\"Nothing found 10\", !rs.isEmpty());\n        msgs = getMessages(rs);\n        assertEquals(\"Messages must be 3\", 3, msgs.size());\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[0].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[1].getContent()));\n        assertTrue(\"Message no found\",\n                   msgs.contains(messagesToSend[2].getContent()));\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     *  First send the messages\n     */\n    public void writeRecords()\n    {\n\n        logger.info(\"write records \");\n\n        assertNotNull(\"No metacontact\", testMetaContact);\n\n        // First deliver message, so they are stored by the message history service\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[0]);\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[0]);\n\n        TestMsgHistoryService.controlDate1 = new Date();\n\n        Object lock = new Object();\n        synchronized (lock)\n        {\n            // wait a moment\n            try\n            {\n                lock.wait(200);\n            }\n            catch (InterruptedException ex)\n            {\n            }\n        }\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[1]);\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[2]);\n\n        TestMsgHistoryService.controlDate2 = new Date();\n        synchronized (lock)\n        {\n            // wait a moment\n            try\n            {\n                lock.wait(200);\n            }\n            catch (InterruptedException ex)\n            {\n            }\n        }\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[3]);\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[4]);\n\n    }","id":51473,"modified_method":"/**\n     *  First send the messages\n     */\n    public void writeRecords()\n    {\n\n        logger.info(\"write records \");\n\n        assertNotNull(\"No metacontact\", testMetaContact);\n\n        // First deliver message, so they are stored by the message history service\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[0]);\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[0]);\n\n        TestMsgHistoryService.controlDate1 = new Date();\n        logger.info(\"controlDate1:\" + controlDate1.getTime());\n\n        Object lock = new Object();\n        synchronized (lock)\n        {\n            // wait a moment\n            try\n            {\n                lock.wait(200);\n            }\n            catch (InterruptedException ex)\n            {\n            }\n        }\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[1]);\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[2]);\n\n        TestMsgHistoryService.controlDate2 = new Date();\n        logger.info(\"controlDate2:\" + controlDate1.getTime());\n        synchronized (lock)\n        {\n            // wait a moment\n            try\n            {\n                lock.wait(200);\n            }\n            catch (InterruptedException ex)\n            {\n            }\n        }\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_1, messagesToSend[3]);\n\n        mockBImOpSet.deliverMessage(TEST_CONTACT_NAME_2, messagesToSend[4]);\n\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void writeRecordsToMultiChat()\n    {\n        try\n        {\n            ChatRoom room = mockMultiChat.createChatRoom(\"test_room\", null);\n            room.join();\n\n//            ChatRoom room = mockMultiChat.findRoom(TEST_ROOM_NAME);\n//            room.joinAs(TEST_CONTACT_NAME);\n\n            // First deliver message, so they are stored by the message history service\n            room.sendMessage(messagesToSend[0]);\n\n            TestMsgHistoryService.controlDate1 = new Date();\n\n            waitWrite(200);\n            \n\n            room.sendMessage(messagesToSend[1]);\n\n            waitWrite(200);\n            \n            room.sendMessage(messagesToSend[2]);\n\n            TestMsgHistoryService.controlDate2 = new Date();\n            \n            waitWrite(200);\n\n            room.sendMessage(messagesToSend[3]);\n            \n            waitWrite(200);\n            \n            room.sendMessage(messagesToSend[4]);\n            \n            waitWrite(200);\n        }\n        catch(OperationFailedException ex)\n        {\n            fail(\"Failed to create room : \" + ex.getMessage());\n            logger.error(\"Failed to create room\", ex);\n        }\n        catch(OperationNotSupportedException ex)\n        {\n            fail(\"Failed to create room : \" + ex.getMessage());\n            logger.error(\"Failed to create room\", ex);\n        }\n    }","id":51474,"modified_method":"public void writeRecordsToMultiChat()\n    {\n        try\n        {\n            ChatRoom room = mockMultiChat.createChatRoom(\"test_room\", null);\n            room.join();\n\n//            ChatRoom room = mockMultiChat.findRoom(TEST_ROOM_NAME);\n//            room.joinAs(TEST_CONTACT_NAME);\n\n            // First deliver message, so they are stored by the message history service\n            room.sendMessage(messagesToSend[0]);\n\n            waitWrite(100);\n\n            TestMsgHistoryService.controlDate1 = new Date();\n            logger.info(\"controlDate1:\" + controlDate1.getTime());\n\n            waitWrite(100);\n\n            room.sendMessage(messagesToSend[1]);\n\n            waitWrite(100);\n\n            room.sendMessage(messagesToSend[2]);\n\n            TestMsgHistoryService.controlDate2 = new Date();\n            logger.info(\"controlDate2:\" + controlDate2.getTime());\n\n            waitWrite(100);\n\n            room.sendMessage(messagesToSend[3]);\n\n            waitWrite(100);\n\n            room.sendMessage(messagesToSend[4]);\n\n            waitWrite(100);\n        }\n        catch(OperationFailedException ex)\n        {\n            fail(\"Failed to create room : \" + ex.getMessage());\n            logger.error(\"Failed to create room\", ex);\n        }\n        catch(OperationNotSupportedException ex)\n        {\n            fail(\"Failed to create room : \" + ex.getMessage());\n            logger.error(\"Failed to create room\", ex);\n        }\n    }","commit_id":"e130c9ece95aadd5c156f05259144c5b695e457c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void testUpdateBinary() {\n        try {\n            BinaryResource binaryResource = (BinaryResource)\n                    testCollection.createResource(\"test.xml\", \"BinaryResource\");\n            binaryResource.setContent(binFile);\n            testCollection.storeResource(binaryResource);\n\n            Resource resource = testCollection.getResource(\"test.xml\");\n            assertNotNull(resource);\n            System.out.println(\"Content:\\n\" + resource.getContent().toString());\n            \n            XMLResource xmlResource = (XMLResource) testCollection.createResource(\"test.xml\", \"XMLResource\");\n            xmlResource.setContent(xmlFile);\n            testCollection.storeResource(xmlResource);\n\n            resource = testCollection.getResource(\"test.xml\");\n            assertNotNull(resource);\n            System.out.println(\"Content:\\n\" + resource.getContent().toString());\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":51475,"modified_method":"public void testUpdateBinary() {\n        try {\n            for (int i = 0; i < REPEAT; i++) {\n                BinaryResource binaryResource = (BinaryResource)\n                        testCollection.createResource(\"test.xml\", \"BinaryResource\");\n                binaryResource.setContent(binFile);\n                testCollection.storeResource(binaryResource);\n\n                Resource resource = testCollection.getResource(\"test.xml\");\n                assertNotNull(resource);\n                System.out.println(\"Content:\\n\" + resource.getContent().toString());\n\n                XMLResource xmlResource = (XMLResource) testCollection.createResource(\"test.xml\", \"XMLResource\");\n                xmlResource.setContent(xmlFile);\n                testCollection.storeResource(xmlResource);\n\n                resource = testCollection.getResource(\"test.xml\");\n                assertNotNull(resource);\n                System.out.println(\"Content:\\n\" + resource.getContent().toString());\n            }\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","commit_id":"376b19f952ab92f03c4526170da6b0a12eef7535","url":"https://github.com/eXist-db/exist"},{"original_method":"public static void main(String[] args) {\n        TestRunner.run(BinaryResourceUpdateTest.class);\n    }","id":51476,"modified_method":"public static void main(String[] args) {\n        BasicConfigurator.configure();\n        TestRunner.run(BinaryResourceUpdateTest.class);\n    }","commit_id":"376b19f952ab92f03c4526170da6b0a12eef7535","url":"https://github.com/eXist-db/exist"},{"original_method":"private IndexInfo validateXMLResourceInternal(Txn transaction, DBBroker broker, XmldbURI docUri, ValidateBlock doValidate)\n    throws EXistException, PermissionDeniedException, TriggerException, SAXException, LockException {\n        \n        checkConfiguration(transaction, broker, docUri);\n\n        if (broker.isReadOnly()) throw new PermissionDeniedException(\"Database is read-only\");\n        DocumentImpl document, oldDoc = null;\n        boolean oldDocLocked = false;\n        try {\n            getLock().acquire(Lock.WRITE_LOCK);\n            oldDoc = (DocumentImpl) documents.get(docUri.getRawCollectionPath());\n            document = new DocumentImpl(broker, this, docUri);\n            \n            if (oldDoc == null) {\n                CollectionConfiguration config = getConfiguration(broker);\n                if (config != null) {\n                    document.setPermissions(config.getDefResPermissions());\n                }\n            } else\n                document.setPermissions(oldDoc.getPermissions().getPermissions());\n            \n            checkPermissions(transaction, broker, oldDoc);\n            manageDocumentInformation(broker, oldDoc, document );\n            \n            Indexer indexer = new Indexer(broker, transaction);\n            IndexInfo info = new IndexInfo(indexer);\n            indexer.setDocument(document);\n            addObserversToIndexer(broker, indexer);\n            indexer.setValidating(true);\n            \n            // if !triggersEnabled, setupTriggers will return null anyway, so no need to check\n            info.setTrigger(\n                    setupTriggers(broker, docUri, oldDoc != null),\n                    oldDoc == null ? Trigger.STORE_DOCUMENT_EVENT : Trigger.UPDATE_DOCUMENT_EVENT);\n            \n             info.prepareTrigger(broker, transaction, getURI().append(docUri), oldDoc);\n            \n            LOG.debug(\"Scanning document \" + getURI().append(docUri));\n            doValidate.run(info);\n            \n            // new document is valid: remove old document\n            if (oldDoc != null) {\n                LOG.debug(\"removing old document \" + oldDoc.getFileURI());\n                oldDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                oldDocLocked = true;\n                if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE)\n                    broker.removeBinaryResource(transaction, (BinaryDocument) oldDoc);\n                else\n                    broker.removeXMLResource(transaction, oldDoc, false);\n                oldDoc.copyOf(document);\n                indexer.setDocumentObject(oldDoc);\n                oldDocLocked = false;\t\t// old has become new at this point\n                document = oldDoc;\n            } else {\n                document.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                document.setDocId(broker.getNextResourceId(transaction, this));\n                addDocument(transaction, broker, document);\n            }\n            \n            indexer.setValidating(false);\n            info.postValidateTrigger();\n            return info;\n        } finally {\n            if (oldDocLocked) oldDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n            getLock().release();\n        }\n    }","id":51477,"modified_method":"private IndexInfo validateXMLResourceInternal(Txn transaction, DBBroker broker, XmldbURI docUri, ValidateBlock doValidate)\n    throws EXistException, PermissionDeniedException, TriggerException, SAXException, LockException {\n        \n        checkConfiguration(transaction, broker, docUri);\n\n        if (broker.isReadOnly()) throw new PermissionDeniedException(\"Database is read-only\");\n        DocumentImpl document, oldDoc = null;\n        boolean oldDocLocked = false;\n        try {\n            getLock().acquire(Lock.WRITE_LOCK);\n            oldDoc = (DocumentImpl) documents.get(docUri.getRawCollectionPath());\n            document = new DocumentImpl(broker, this, docUri);\n            \n            if (oldDoc == null) {\n                CollectionConfiguration config = getConfiguration(broker);\n                if (config != null) {\n                    document.setPermissions(config.getDefResPermissions());\n                }\n            } else\n                document.setPermissions(oldDoc.getPermissions().getPermissions());\n            \n            checkPermissions(transaction, broker, oldDoc);\n            manageDocumentInformation(broker, oldDoc, document );\n            \n            Indexer indexer = new Indexer(broker, transaction);\n            IndexInfo info = new IndexInfo(indexer);\n            indexer.setDocument(document);\n            addObserversToIndexer(broker, indexer);\n            indexer.setValidating(true);\n            \n            // if !triggersEnabled, setupTriggers will return null anyway, so no need to check\n            info.setTrigger(\n                    setupTriggers(broker, docUri, oldDoc != null),\n                    oldDoc == null ? Trigger.STORE_DOCUMENT_EVENT : Trigger.UPDATE_DOCUMENT_EVENT);\n            \n             info.prepareTrigger(broker, transaction, getURI().append(docUri), oldDoc);\n            \n            LOG.debug(\"Scanning document \" + getURI().append(docUri));\n            doValidate.run(info);\n            \n            // new document is valid: remove old document\n            if (oldDoc != null) {\n                LOG.debug(\"removing old document \" + oldDoc.getFileURI());\n                oldDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                oldDocLocked = true;\n                if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE) {\n                    broker.removeBinaryResource(transaction, (BinaryDocument) oldDoc);\n                    documents.remove(oldDoc.getFileURI().getRawCollectionPath());\n                    document.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                    document.setDocId(broker.getNextResourceId(transaction, this));\n                    addDocument(transaction, broker, document);\n                } else {\n                    broker.removeXMLResource(transaction, oldDoc, false);\n                    oldDoc.copyOf(document);\n                    indexer.setDocumentObject(oldDoc);\n                    oldDocLocked = false;\t\t// old has become new at this point\n                    document = oldDoc;\n                }\n            } else {\n                document.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                document.setDocId(broker.getNextResourceId(transaction, this));\n                addDocument(transaction, broker, document);\n            }\n            \n            indexer.setValidating(false);\n            info.postValidateTrigger();\n            return info;\n        } finally {\n            if (oldDocLocked) oldDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n            getLock().release();\n        }\n    }","commit_id":"376b19f952ab92f03c4526170da6b0a12eef7535","url":"https://github.com/eXist-db/exist"},{"original_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test suite for org.exist.xmldb.test\");\n\t\t//$JUnit-BEGIN$\n\t\tsuite.addTest(new TestSuite(CreateCollectionsTest.class));\n\t\tsuite.addTest(new TestSuite(ResourceTest.class));\n//\t\tsuite.addTest(new TestSuite(ResourceSetTest.class));\n\t\tsuite.addTest(new TestSuite(TestEXistXMLSerialize.class));\n\t\tsuite.addTest(new TestSuite(CopyMoveTest.class));\n        suite.addTest(new TestSuite(ContentAsDOMTest.class));\n//        suite.addTest(new TestSuite(MultiDBTest.class));\n        suite.addTestSuite(XmldbURITest.class);\n        suite.addTestSuite(CollectionConfigurationTest.class);\n        suite.addTestSuite(CollectionTest.class);\n\t\t//$JUnit-END$\n\t\treturn suite;\n\t}","id":51478,"modified_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test suite for org.exist.xmldb.test\");\n\t\t//$JUnit-BEGIN$\n\t\tsuite.addTest(new TestSuite(CreateCollectionsTest.class));\n\t\tsuite.addTest(new TestSuite(ResourceTest.class));\n        suite.addTest(new TestSuite(BinaryResourceUpdateTest.class));\n//\t\tsuite.addTest(new TestSuite(ResourceSetTest.class));\n\t\tsuite.addTest(new TestSuite(TestEXistXMLSerialize.class));\n\t\tsuite.addTest(new TestSuite(CopyMoveTest.class));\n        suite.addTest(new TestSuite(ContentAsDOMTest.class));\n//        suite.addTest(new TestSuite(MultiDBTest.class));\n        suite.addTestSuite(XmldbURITest.class);\n        suite.addTestSuite(CollectionConfigurationTest.class);\n        suite.addTestSuite(CollectionTest.class);\n\t\t//$JUnit-END$\n\t\treturn suite;\n\t}","commit_id":"376b19f952ab92f03c4526170da6b0a12eef7535","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testPoll() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\tPollStatus up = PollStatus.available(1234);\n\t\texpect(m_pollService.poll(m_pollerConfiguration.getFirstService()))\n\t\t\t\t.andReturn(up);\n\n\t\tm_backEnd.reportResult(1, m_pollerConfiguration.getFirstId(), up);\n\n\t\tServicePollStateChangedEvent e = new ServicePollStateChangedEvent(\n\t\t\t\tm_pollerConfiguration.getFirstService(), 0);\n\t\tm_polledServiceListener.pollStateChange(eq(e));\n\t\texpectLastCall().atLeastOnce();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addServicePollStateChangedListener(m_polledServiceListener);\n\n\t\tm_frontEnd.pollService(m_pollerConfiguration.getFirstId());\n\n\t\tServicePollState pollState = m_frontEnd\n\t\t\t\t.getServicePollState(m_pollerConfiguration.getFirstId());\n\n\t\tverifyMocks();\n\n\t\tassertEquals(PollStatus.SERVICE_AVAILABLE, pollState.getLastPoll()\n\t\t\t\t.getStatusCode());\n\n\t}","id":51479,"modified_method":"public void testPoll() throws Exception {\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipatePollService();\n\t\t\n\t\tanticipateGetServicePollState();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.pollService(pollConfig().getFirstId());\n\n\t\tServicePollState pollState = m_frontEnd\n\t\t\t\t.getServicePollState(pollConfig().getFirstId());\n\n\t\tverifyMocks();\n\n\t\tassertEquals(PollStatus.SERVICE_AVAILABLE, pollState.getLastPoll()\n\t\t\t\t.getStatusCode());\n\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testNotYetRegistered() throws Exception {\n\t\tsetRegisteredId(null);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51480,"modified_method":"public void testNotYetRegistered() throws Exception {\n\t\tsetRegisteredId(null);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testRegisterNewMonitor() throws Exception {\n\n\t\tInteger monitorId = null;\n\n\t\tanticipateAfterPropertiesSet();\n\n\t\tanticapteIsRegistered();\n\n\t\t// register a new monitor and save the id\n\t\texpect(m_backEnd.registerLocationMonitor(\"OAK\")).andReturn(1);\n\t\tm_settings.setMonitorId(1);\n\t\tPropertyChangeEvent registrationEvent = new PropertyChangeEvent(\n\t\t\t\tm_frontEnd, \"registered\", false, true);\n\t\tm_registrationListener.propertyChange(eq(registrationEvent));\n\n\t\t// another call to isRegistered;\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addPropertyChangeListener(m_registrationListener);\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tm_frontEnd.register(\"OAK\");\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\n\t}","id":51481,"modified_method":"public void testRegisterNewMonitor() throws Exception {\n\n\t\tanticipateAfterPropertiesSet();\n\n\t\tanticipateIsRegistered();\n\t\t\n\t\tanticiapateRegister();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tm_frontEnd.register(\"OAK\");\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void testIsRegistered(Integer monitorId,\n\t\t\tboolean expectedIsRegistered) {\n\t\tsetRegisteredId(monitorId);\n\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tassertEquals(\"Unexpected value for isRegistered\", expectedIsRegistered,\n\t\t\t\tm_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51482,"modified_method":"private void testIsRegistered(Integer monitorId, boolean expectedIsRegistered) {\n\t\tsetRegisteredId(monitorId);\n\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tassertEquals(\"Unexpected value for isRegistered\", \n\t\t\t\texpectedIsRegistered,\n\t\t\t\tm_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testStop() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\tm_backEnd.pollerStopping(1);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isStarted());\n\n\t\tm_frontEnd.stop();\n\n\t\tassertFalse(m_frontEnd.isStarted());\n\n\t\tverifyMocks();\n\t}","id":51483,"modified_method":"public void testStop() throws Exception {\n\t\t\n\t\tsetRegistered();\n\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateStop();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isStarted());\n\n\t\tm_frontEnd.stop();\n\n\t\tassertFalse(m_frontEnd.isStarted());\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void appendTo(StringBuffer buffer) {\n\t\t\tbuffer.append(m_expected);\n\t\t}","id":51484,"modified_method":"public void appendTo(StringBuffer buffer) {\n\t\t\tbuffer.append(m_expected);\n\t\t\tbuffer.append(\" property=\");\n\t\t\tbuffer.append(m_expected.getPropertyName());\n\t\t\tbuffer.append(\", oldValue=\");\n\t\t\tbuffer.append(m_expected.getOldValue());\n\t\t\tbuffer.append(\", newValue=\");\n\t\t\tbuffer.append(m_expected.getNewValue());\n\t\t\t\n\t\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testAlreadyRegistered() throws Exception {\n\n\t\tsetRegisteredId(1);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51485,"modified_method":"public void testAlreadyRegistered() throws Exception {\n\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticipateAfterPropertiesSet() {\n\t\tanticapteIsRegistered();\n\n\t\tif (getRegisteredId() == null)\n\t\t\treturn;\n\n\t\tanticipateStart(getRegisteredId());\n\n\t\tanticipatePollServiceSetMonitorLocators();\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.getPollerConfiguration(1)).andReturn(pollConfig());\n\n\t\tm_pollService.initialize(isA(PolledService.class));\n\t\texpectLastCall().times(pollConfig().getPolledServices().length);\n\n\t}","id":51486,"modified_method":"private void anticipateAfterPropertiesSet() {\n\t\tanticipateIsRegistered();\n\n\t\tif (getRegisteredId() == null)\n\t\t\treturn;\n\n\t\tanticipateInitializePollState();\n\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticapteIsRegistered() {\n\t\tanticipateGetMonitorId();\n\t}","id":51487,"modified_method":"private void anticipateIsRegistered() {\n\t\tanticipateGetMonitorId();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\n\t\tm_backEnd = createMock(PollerBackEnd.class);\n\t\tm_settings = createMock(PollerSettings.class);\n\t\tm_pollService = createMock(PollService.class);\n\t\tm_registrationListener = createMock(PropertyChangeListener.class);\n\t\tm_polledServiceListener = createMock(ServicePollStateChangedListener.class);\n\t\tm_configChangeListener = createMock(ConfigurationChangedListener.class);\n\n\t\tm_pollerConfiguration = new DemoPollerConfiguration();\n\n\t\tm_frontEnd = new DefaultPollerFrontEnd();\n\t\tm_frontEnd.setPollerBackEnd(m_backEnd);\n\t\tm_frontEnd.setPollerSettings(m_settings);\n\t\tm_frontEnd.setPollService(m_pollService);\n\n\t}","id":51488,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\n\t\tm_backEnd = createMock(PollerBackEnd.class);\n\t\tm_settings = createMock(PollerSettings.class);\n\t\tm_pollService = createMock(PollService.class);\n\t\tm_registrationListener = createMock(PropertyChangeListener.class);\n\t\tm_polledServiceListener = createMock(ServicePollStateChangedListener.class);\n\t\tm_configChangeListener = createMock(ConfigurationChangedListener.class);\n\n\t\tsetPollConfig(new DemoPollerConfiguration());\n\t\tm_oldPollerConfiguration = null;\n\n\t\tm_frontEnd = new DefaultPollerFrontEnd();\n\t\tm_frontEnd.setPollerBackEnd(m_backEnd);\n\t\tm_frontEnd.setPollerSettings(m_settings);\n\t\tm_frontEnd.setPollService(m_pollService);\n\t\t\n\t\tm_frontEnd.addConfigurationChangedListener(m_configChangeListener);\n\t\tm_frontEnd.addPropertyChangeListener(m_registrationListener);\n\t\tm_frontEnd.addServicePollStateChangedListener(m_polledServiceListener);\n\t\t\n\t\tm_serviceStatus = PollStatus.available(1234L);\n\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean matches(Object argument) {\n\t\t\tPropertyChangeEvent actual = (PropertyChangeEvent) argument;\n\t\t\tif (m_expected == null) {\n\t\t\t\treturn actual == null;\n\t\t\t}\n\n\t\t\treturn (m_expected.getSource() == actual.getSource()\n\t\t\t\t\t&& m_expected.getPropertyName().equals(\n\t\t\t\t\t\t\tactual.getPropertyName())\n\t\t\t\t\t&& m_expected.getOldValue().equals(actual.getOldValue()) && m_expected\n\t\t\t\t\t.getNewValue().equals(actual.getNewValue()));\n\t\t}","id":51489,"modified_method":"public boolean matches(Object argument) {\n\t\t\tPropertyChangeEvent actual = (PropertyChangeEvent) argument;\n\t\t\tif (m_expected == actual) return true;\n\t\t\t\n\t\t\tif (m_expected == null) {\n\t\t\t\treturn actual == null;\n\t\t\t}\n\n\t\t\treturn (m_expected.getSource() == actual.getSource()\n\t\t\t\t\t&& m_expected.getPropertyName().equals(actual.getPropertyName())\n\t\t\t\t\t&& nullSafeEquals(m_expected.getOldValue(), actual.getOldValue()) \n\t\t\t\t\t&& nullSafeEquals(m_expected.getNewValue(), actual.getNewValue()));\n\t\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSetInitialPollTime() throws Exception {\n\n\t\tDate start = new Date(1200000000000L);\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tint polledServiceId = m_pollerConfiguration.getFirstId();\n\n\t\tm_frontEnd.setInitialPollTime(polledServiceId, start);\n\n\t\tassertEquals(start, m_frontEnd.getServicePollState(polledServiceId)\n\t\t\t\t.getNextPollTime());\n\n\t\tverifyMocks();\n\t}","id":51490,"modified_method":"public void testSetInitialPollTime() throws Exception {\n\n\t\tDate start = new Date(1200000000000L);\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\n\t\tint polledServiceId = pollConfig().getFirstId();\n\n\t\tanticipateSetInitialPollTime();\n\n\t\tanticipateGetServicePollState();\n\n//\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n//\n//\t\tanticipateNewConfig(pollConfig());\n//\n//\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\n\t\tm_frontEnd.setInitialPollTime(polledServiceId, start);\n\n\t\tassertEquals(start, m_frontEnd.getServicePollState(polledServiceId)\n\t\t\t\t.getNextPollTime());\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testConfigCheck() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\texpect(\n\t\t\t\tm_backEnd.pollerCheckingIn(1, m_pollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp())).andReturn(\n\t\t\t\tMonitorStatus.CONFIG_CHANGED);\n\n\t\tDemoPollerConfiguration newPollerConfiguration = new DemoPollerConfiguration();\n\t\tanticipateNewConfig(newPollerConfiguration);\n\n\t\tPropertyChangeEvent e = new PropertyChangeEvent(m_frontEnd,\n\t\t\t\t\"configuration\", m_pollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp(), newPollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp());\n\t\tm_configChangeListener.configurationChanged(eq(e));\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addConfigurationChangedListener(m_configChangeListener);\n\n\t\tm_frontEnd.checkConfig();\n\n\t\tverifyMocks();\n\t}","id":51491,"modified_method":"public void testConfigCheck() throws Exception {\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tsetPollConfig(new DemoPollerConfiguration());\n\t\t\n\t\tanticipateCheckConfig();\n\t\t\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.checkConfig();\n\n\t\tverifyMocks();\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticipateStart(Integer monitorId) {\n\t\tanticapteIsRegistered();\n\n\t\tif (monitorId == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.pollerStarting(monitorId, getPollerDetails()))\n\t\t\t\t.andReturn(true);\n\n\t}","id":51492,"modified_method":"private void anticipateStart() {\n\t\tif (m_started) return;\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\tif (getRegisteredId() == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.pollerStarting(getRegisteredId(), getPollerDetails()))\n\t\t\t\t.andReturn(true);\n\t\t\n\t\tm_started = true;\n\n\t}","commit_id":"b6fb431b4191cab25c9f2bb738ef7c95791d9f75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSetInitialPollTime() throws Exception {\n\n\t\tDate start = new Date(1200000000000L);\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tint polledServiceId = m_pollerConfiguration.getFirstId();\n\n\t\tm_frontEnd.setInitialPollTime(polledServiceId, start);\n\n\t\tassertEquals(start, m_frontEnd.getServicePollState(polledServiceId)\n\t\t\t\t.getNextPollTime());\n\n\t\tverifyMocks();\n\t}","id":51493,"modified_method":"public void testSetInitialPollTime() throws Exception {\n\n\t\tDate start = new Date(1200000000000L);\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\n\t\tint polledServiceId = pollConfig().getFirstId();\n\n\t\tanticipateSetInitialPollTime();\n\n\t\tanticipateGetServicePollState();\n\n//\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n//\n//\t\tanticipateNewConfig(pollConfig());\n//\n//\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\n\t\tm_frontEnd.setInitialPollTime(polledServiceId, start);\n\n\t\tassertEquals(start, m_frontEnd.getServicePollState(polledServiceId)\n\t\t\t\t.getNextPollTime());\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean matches(Object argument) {\n\t\t\tPropertyChangeEvent actual = (PropertyChangeEvent) argument;\n\t\t\tif (m_expected == null) {\n\t\t\t\treturn actual == null;\n\t\t\t}\n\n\t\t\treturn (m_expected.getSource() == actual.getSource()\n\t\t\t\t\t&& m_expected.getPropertyName().equals(\n\t\t\t\t\t\t\tactual.getPropertyName())\n\t\t\t\t\t&& m_expected.getOldValue().equals(actual.getOldValue()) && m_expected\n\t\t\t\t\t.getNewValue().equals(actual.getNewValue()));\n\t\t}","id":51494,"modified_method":"public boolean matches(Object argument) {\n\t\t\tPropertyChangeEvent actual = (PropertyChangeEvent) argument;\n\t\t\tif (m_expected == actual) return true;\n\t\t\t\n\t\t\tif (m_expected == null) {\n\t\t\t\treturn actual == null;\n\t\t\t}\n\n\t\t\treturn (m_expected.getSource() == actual.getSource()\n\t\t\t\t\t&& m_expected.getPropertyName().equals(actual.getPropertyName())\n\t\t\t\t\t&& nullSafeEquals(m_expected.getOldValue(), actual.getOldValue()) \n\t\t\t\t\t&& nullSafeEquals(m_expected.getNewValue(), actual.getNewValue()));\n\t\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticipateAfterPropertiesSet() {\n\t\tanticapteIsRegistered();\n\n\t\tif (getRegisteredId() == null)\n\t\t\treturn;\n\n\t\tanticipateStart(getRegisteredId());\n\n\t\tanticipatePollServiceSetMonitorLocators();\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.getPollerConfiguration(1)).andReturn(pollConfig());\n\n\t\tm_pollService.initialize(isA(PolledService.class));\n\t\texpectLastCall().times(pollConfig().getPolledServices().length);\n\n\t}","id":51495,"modified_method":"private void anticipateAfterPropertiesSet() {\n\t\tanticipateIsRegistered();\n\n\t\tif (getRegisteredId() == null)\n\t\t\treturn;\n\n\t\tanticipateInitializePollState();\n\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testNotYetRegistered() throws Exception {\n\t\tsetRegisteredId(null);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51496,"modified_method":"public void testNotYetRegistered() throws Exception {\n\t\tsetRegisteredId(null);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testRegisterNewMonitor() throws Exception {\n\n\t\tInteger monitorId = null;\n\n\t\tanticipateAfterPropertiesSet();\n\n\t\tanticapteIsRegistered();\n\n\t\t// register a new monitor and save the id\n\t\texpect(m_backEnd.registerLocationMonitor(\"OAK\")).andReturn(1);\n\t\tm_settings.setMonitorId(1);\n\t\tPropertyChangeEvent registrationEvent = new PropertyChangeEvent(\n\t\t\t\tm_frontEnd, \"registered\", false, true);\n\t\tm_registrationListener.propertyChange(eq(registrationEvent));\n\n\t\t// another call to isRegistered;\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addPropertyChangeListener(m_registrationListener);\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tm_frontEnd.register(\"OAK\");\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\n\t}","id":51497,"modified_method":"public void testRegisterNewMonitor() throws Exception {\n\n\t\tanticipateAfterPropertiesSet();\n\n\t\tanticipateIsRegistered();\n\t\t\n\t\tanticiapateRegister();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertFalse(m_frontEnd.isRegistered());\n\n\t\tm_frontEnd.register(\"OAK\");\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void testIsRegistered(Integer monitorId,\n\t\t\tboolean expectedIsRegistered) {\n\t\tsetRegisteredId(monitorId);\n\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tassertEquals(\"Unexpected value for isRegistered\", expectedIsRegistered,\n\t\t\t\tm_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51498,"modified_method":"private void testIsRegistered(Integer monitorId, boolean expectedIsRegistered) {\n\t\tsetRegisteredId(monitorId);\n\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tassertEquals(\"Unexpected value for isRegistered\", \n\t\t\t\texpectedIsRegistered,\n\t\t\t\tm_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\n\t\tm_backEnd = createMock(PollerBackEnd.class);\n\t\tm_settings = createMock(PollerSettings.class);\n\t\tm_pollService = createMock(PollService.class);\n\t\tm_registrationListener = createMock(PropertyChangeListener.class);\n\t\tm_polledServiceListener = createMock(ServicePollStateChangedListener.class);\n\t\tm_configChangeListener = createMock(ConfigurationChangedListener.class);\n\n\t\tm_pollerConfiguration = new DemoPollerConfiguration();\n\n\t\tm_frontEnd = new DefaultPollerFrontEnd();\n\t\tm_frontEnd.setPollerBackEnd(m_backEnd);\n\t\tm_frontEnd.setPollerSettings(m_settings);\n\t\tm_frontEnd.setPollService(m_pollService);\n\n\t}","id":51499,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\n\t\tm_backEnd = createMock(PollerBackEnd.class);\n\t\tm_settings = createMock(PollerSettings.class);\n\t\tm_pollService = createMock(PollService.class);\n\t\tm_registrationListener = createMock(PropertyChangeListener.class);\n\t\tm_polledServiceListener = createMock(ServicePollStateChangedListener.class);\n\t\tm_configChangeListener = createMock(ConfigurationChangedListener.class);\n\n\t\tsetPollConfig(new DemoPollerConfiguration());\n\t\tm_oldPollerConfiguration = null;\n\n\t\tm_frontEnd = new DefaultPollerFrontEnd();\n\t\tm_frontEnd.setPollerBackEnd(m_backEnd);\n\t\tm_frontEnd.setPollerSettings(m_settings);\n\t\tm_frontEnd.setPollService(m_pollService);\n\t\t\n\t\tm_frontEnd.addConfigurationChangedListener(m_configChangeListener);\n\t\tm_frontEnd.addPropertyChangeListener(m_registrationListener);\n\t\tm_frontEnd.addServicePollStateChangedListener(m_polledServiceListener);\n\t\t\n\t\tm_serviceStatus = PollStatus.available(1234L);\n\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPoll() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\tPollStatus up = PollStatus.available(1234);\n\t\texpect(m_pollService.poll(m_pollerConfiguration.getFirstService()))\n\t\t\t\t.andReturn(up);\n\n\t\tm_backEnd.reportResult(1, m_pollerConfiguration.getFirstId(), up);\n\n\t\tServicePollStateChangedEvent e = new ServicePollStateChangedEvent(\n\t\t\t\tm_pollerConfiguration.getFirstService(), 0);\n\t\tm_polledServiceListener.pollStateChange(eq(e));\n\t\texpectLastCall().atLeastOnce();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addServicePollStateChangedListener(m_polledServiceListener);\n\n\t\tm_frontEnd.pollService(m_pollerConfiguration.getFirstId());\n\n\t\tServicePollState pollState = m_frontEnd\n\t\t\t\t.getServicePollState(m_pollerConfiguration.getFirstId());\n\n\t\tverifyMocks();\n\n\t\tassertEquals(PollStatus.SERVICE_AVAILABLE, pollState.getLastPoll()\n\t\t\t\t.getStatusCode());\n\n\t}","id":51500,"modified_method":"public void testPoll() throws Exception {\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipatePollService();\n\t\t\n\t\tanticipateGetServicePollState();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.pollService(pollConfig().getFirstId());\n\n\t\tServicePollState pollState = m_frontEnd\n\t\t\t\t.getServicePollState(pollConfig().getFirstId());\n\n\t\tverifyMocks();\n\n\t\tassertEquals(PollStatus.SERVICE_AVAILABLE, pollState.getLastPoll()\n\t\t\t\t.getStatusCode());\n\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticapteIsRegistered() {\n\t\tanticipateGetMonitorId();\n\t}","id":51501,"modified_method":"private void anticipateIsRegistered() {\n\t\tanticipateGetMonitorId();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testStop() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\tm_backEnd.pollerStopping(1);\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isStarted());\n\n\t\tm_frontEnd.stop();\n\n\t\tassertFalse(m_frontEnd.isStarted());\n\n\t\tverifyMocks();\n\t}","id":51502,"modified_method":"public void testStop() throws Exception {\n\t\t\n\t\tsetRegistered();\n\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateStop();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isStarted());\n\n\t\tm_frontEnd.stop();\n\n\t\tassertFalse(m_frontEnd.isStarted());\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void appendTo(StringBuffer buffer) {\n\t\t\tbuffer.append(m_expected);\n\t\t}","id":51503,"modified_method":"public void appendTo(StringBuffer buffer) {\n\t\t\tbuffer.append(m_expected);\n\t\t\tbuffer.append(\" property=\");\n\t\t\tbuffer.append(m_expected.getPropertyName());\n\t\t\tbuffer.append(\", oldValue=\");\n\t\t\tbuffer.append(m_expected.getOldValue());\n\t\t\tbuffer.append(\", newValue=\");\n\t\t\tbuffer.append(m_expected.getNewValue());\n\t\t\t\n\t\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testAlreadyRegistered() throws Exception {\n\n\t\tsetRegisteredId(1);\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticapteIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","id":51504,"modified_method":"public void testAlreadyRegistered() throws Exception {\n\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tassertTrue(m_frontEnd.isRegistered());\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testConfigCheck() throws Exception {\n\n\t\texpect(m_settings.getMonitorId()).andReturn(1).atLeastOnce();\n\n\t\tanticipateNewConfig(pollConfig());\n\n\t\texpect(m_backEnd.pollerStarting(1, getPollerDetails())).andReturn(true);\n\n\t\texpect(\n\t\t\t\tm_backEnd.pollerCheckingIn(1, m_pollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp())).andReturn(\n\t\t\t\tMonitorStatus.CONFIG_CHANGED);\n\n\t\tDemoPollerConfiguration newPollerConfiguration = new DemoPollerConfiguration();\n\t\tanticipateNewConfig(newPollerConfiguration);\n\n\t\tPropertyChangeEvent e = new PropertyChangeEvent(m_frontEnd,\n\t\t\t\t\"configuration\", m_pollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp(), newPollerConfiguration\n\t\t\t\t\t\t.getConfigurationTimestamp());\n\t\tm_configChangeListener.configurationChanged(eq(e));\n\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.addConfigurationChangedListener(m_configChangeListener);\n\n\t\tm_frontEnd.checkConfig();\n\n\t\tverifyMocks();\n\t}","id":51505,"modified_method":"public void testConfigCheck() throws Exception {\n\t\t\n\t\tsetRegistered();\n\t\t\n\t\tanticipateAfterPropertiesSet();\n\t\t\n\t\tsetPollConfig(new DemoPollerConfiguration());\n\t\t\n\t\tanticipateCheckConfig();\n\t\t\n\t\treplayMocks();\n\n\t\tm_frontEnd.afterPropertiesSet();\n\n\t\tm_frontEnd.checkConfig();\n\n\t\tverifyMocks();\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void anticipateStart(Integer monitorId) {\n\t\tanticapteIsRegistered();\n\n\t\tif (monitorId == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.pollerStarting(monitorId, getPollerDetails()))\n\t\t\t\t.andReturn(true);\n\n\t}","id":51506,"modified_method":"private void anticipateStart() {\n\t\tif (m_started) return;\n\t\t\n\t\tanticipateIsRegistered();\n\n\t\tif (getRegisteredId() == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tanticipateGetMonitorId();\n\n\t\texpect(m_backEnd.pollerStarting(getRegisteredId(), getPollerDetails()))\n\t\t\t\t.andReturn(true);\n\t\t\n\t\tm_started = true;\n\n\t}","commit_id":"aa1cbfdb505582c0c23639c77fdf2d3fa161b908","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected boolean top() {\n        return ((Boolean)stack.getLast()).booleanValue();\n    }","id":51507,"modified_method":"private boolean top() {\n        return ((Boolean)stack.getLast()).booleanValue();\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void push(boolean b) {\n        stack.addLast(Boolean.valueOf(b));\n    }","id":51508,"modified_method":"private void push(boolean b) {\n        stack.addLast(Boolean.valueOf(b));\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void saveUpdatedProperties(File propertiesFile, Properties props) throws FileNotFoundException, IOException {\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileOutputStream = new FileOutputStream(propertiesFile);\n            props.store(fileOutputStream, null);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.flush();\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                log().error(\"performUpdate: Error closing file.\", e);\n            }\n        }\n    }","id":51509,"modified_method":"private void saveUpdatedProperties(File propertiesFile, Properties props) throws FileNotFoundException, IOException {\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileOutputStream = new FileOutputStream(propertiesFile);\n            props.store(fileOutputStream, null);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.flush();\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                log().error(\"performUpdate: Error closing file.\", e);\n            }\n        }\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeGroup(AttributeGroup group) {\n        pop();\n    }","id":51510,"modified_method":"public void completeGroup(AttributeGroup group) {\n        popShouldPersist();\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitAttribute(Attribute attribute) {\n        if (top() && attribute.shouldPersist(m_params))\n            attribute.storeAttribute(this);\n    }","id":51511,"modified_method":"public void visitAttribute(Attribute attribute) {\n        pushShouldPersist(attribute);\n        storeAttribute(attribute);\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitGroup(AttributeGroup group) {\n        boolean shouldPersist = top() && group.shouldPersist(m_params);\n        push(shouldPersist);\n    }","id":51512,"modified_method":"public void visitGroup(AttributeGroup group) {\n        pushShouldPersist(group);\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitResource(CollectionResource resource) {\n        push(resource.shouldPersist(m_params));\n    }","id":51513,"modified_method":"public void visitResource(CollectionResource resource) {\n        pushShouldPersist(resource);\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Properties getCurrentProperties(File propertiesFile) throws FileNotFoundException, IOException {\n        Properties props = new Properties();\n    \n        FileInputStream fileInputStream = null;\n        //Preload existing data\n        if (propertiesFile.exists()) {\n            try {\n                fileInputStream = new FileInputStream(propertiesFile);\n                props.load(fileInputStream);\n            } finally {\n                try {\n                    if (fileInputStream != null) fileInputStream.close();\n                } catch (IOException e) {\n                    log().error(\"performUpdate: Error closing file.\", e);\n                }\n            }\n        }\n        return props;\n    }","id":51514,"modified_method":"private Properties getCurrentProperties(File propertiesFile) throws FileNotFoundException, IOException {\n        Properties props = new Properties();\n    \n        FileInputStream fileInputStream = null;\n        //Preload existing data\n        if (propertiesFile.exists()) {\n            try {\n                fileInputStream = new FileInputStream(propertiesFile);\n                props.load(fileInputStream);\n            } finally {\n                try {\n                    if (fileInputStream != null) fileInputStream.close();\n                } catch (IOException e) {\n                    log().error(\"performUpdate: Error closing file.\", e);\n                }\n            }\n        }\n        return props;\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected boolean pop() {\n        boolean top = top();\n        stack.removeLast();\n        return top;\n    }","id":51515,"modified_method":"private boolean pop() {\n        boolean top = top();\n        stack.removeLast();\n        return top;\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void commitBuilder() {\n        String name = m_builder.getName();\n        try {\n            m_builder.commit();\n            m_builder = null;\n        } catch (RrdException e) {\n            log().error(\"Unable to persist data for group \"+name, e);\n    \n        }\n    }","id":51516,"modified_method":"protected void commitBuilder() {\n        String name = m_builder.getName();\n        try {\n            m_builder.commit();\n            m_builder = null;\n        } catch (RrdException e) {\n            log().error(\"Unable to persist data for \"+name, e);\n    \n        }\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeResource(CollectionResource resource) {\n        pop();\n    }","id":51517,"modified_method":"public void completeResource(CollectionResource resource) {\n        popShouldPersist();\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitGroup(AttributeGroup group) {\n        super.visitGroup(group);\n        createBuilder(group.getResource(), group.getName(), group.getGroupType().getAttributeTypes());\n    }","id":51518,"modified_method":"public void visitGroup(AttributeGroup group) {\n        pushShouldPersist(group);\n        if (shouldPersist()) \n            createBuilder(group.getResource(), group.getName(), group.getGroupType().getAttributeTypes());\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeGroup(AttributeGroup group) {\n        commitBuilder();\n        super.completeGroup(group);\n    }","id":51519,"modified_method":"public void completeGroup(AttributeGroup group) {\n        if (shouldPersist()) commitBuilder();\n        popShouldPersist();\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeAttribute(Attribute attribute) {\n        commitBuilder();\n        super.completeAttribute(attribute);\n\n    }","id":51520,"modified_method":"public void completeAttribute(Attribute attribute) {\n        if (shouldPersist()) commitBuilder();\n        popShouldPersist();\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitAttribute(Attribute attribute) {\n        super.visitAttribute(attribute);\n        log().debug(\"Should persist for \"+attribute+\" is \"+top());\n        createBuilder(attribute.getResource(), attribute.getName(), attribute.getAttributeType());\n    }","id":51521,"modified_method":"public void visitAttribute(Attribute attribute) {\n        pushShouldPersist(attribute);\n        if (shouldPersist()) {\n            createBuilder(attribute.getResource(), attribute.getName(), attribute.getAttributeType());\n            storeAttribute(attribute);\n        }\n    }","commit_id":"d8ef2b6db460eb42f56ed68e998cfd1f3ae0f7b8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Properties getCurrentProperties(File propertiesFile) throws FileNotFoundException, IOException {\n        Properties props = new Properties();\n    \n        FileInputStream fileInputStream = null;\n        //Preload existing data\n        if (propertiesFile.exists()) {\n            try {\n                fileInputStream = new FileInputStream(propertiesFile);\n                props.load(fileInputStream);\n            } finally {\n                try {\n                    if (fileInputStream != null) fileInputStream.close();\n                } catch (IOException e) {\n                    log().error(\"performUpdate: Error closing file.\", e);\n                }\n            }\n        }\n        return props;\n    }","id":51522,"modified_method":"private Properties getCurrentProperties(File propertiesFile) throws FileNotFoundException, IOException {\n        Properties props = new Properties();\n    \n        FileInputStream fileInputStream = null;\n        //Preload existing data\n        if (propertiesFile.exists()) {\n            try {\n                fileInputStream = new FileInputStream(propertiesFile);\n                props.load(fileInputStream);\n            } finally {\n                try {\n                    if (fileInputStream != null) fileInputStream.close();\n                } catch (IOException e) {\n                    log().error(\"performUpdate: Error closing file.\", e);\n                }\n            }\n        }\n        return props;\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeGroup(AttributeGroup group) {\n        pop();\n    }","id":51523,"modified_method":"public void completeGroup(AttributeGroup group) {\n        popShouldPersist();\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void push(boolean b) {\n        stack.addLast(Boolean.valueOf(b));\n    }","id":51524,"modified_method":"private void push(boolean b) {\n        stack.addLast(Boolean.valueOf(b));\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitAttribute(Attribute attribute) {\n        if (top() && attribute.shouldPersist(m_params))\n            attribute.storeAttribute(this);\n    }","id":51525,"modified_method":"public void visitAttribute(Attribute attribute) {\n        pushShouldPersist(attribute);\n        storeAttribute(attribute);\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeResource(CollectionResource resource) {\n        pop();\n    }","id":51526,"modified_method":"public void completeResource(CollectionResource resource) {\n        popShouldPersist();\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void commitBuilder() {\n        String name = m_builder.getName();\n        try {\n            m_builder.commit();\n            m_builder = null;\n        } catch (RrdException e) {\n            log().error(\"Unable to persist data for group \"+name, e);\n    \n        }\n    }","id":51527,"modified_method":"protected void commitBuilder() {\n        String name = m_builder.getName();\n        try {\n            m_builder.commit();\n            m_builder = null;\n        } catch (RrdException e) {\n            log().error(\"Unable to persist data for \"+name, e);\n    \n        }\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void saveUpdatedProperties(File propertiesFile, Properties props) throws FileNotFoundException, IOException {\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileOutputStream = new FileOutputStream(propertiesFile);\n            props.store(fileOutputStream, null);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.flush();\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                log().error(\"performUpdate: Error closing file.\", e);\n            }\n        }\n    }","id":51528,"modified_method":"private void saveUpdatedProperties(File propertiesFile, Properties props) throws FileNotFoundException, IOException {\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileOutputStream = new FileOutputStream(propertiesFile);\n            props.store(fileOutputStream, null);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.flush();\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                log().error(\"performUpdate: Error closing file.\", e);\n            }\n        }\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitGroup(AttributeGroup group) {\n        boolean shouldPersist = top() && group.shouldPersist(m_params);\n        push(shouldPersist);\n    }","id":51529,"modified_method":"public void visitGroup(AttributeGroup group) {\n        pushShouldPersist(group);\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitResource(CollectionResource resource) {\n        push(resource.shouldPersist(m_params));\n    }","id":51530,"modified_method":"public void visitResource(CollectionResource resource) {\n        pushShouldPersist(resource);\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected boolean pop() {\n        boolean top = top();\n        stack.removeLast();\n        return top;\n    }","id":51531,"modified_method":"private boolean pop() {\n        boolean top = top();\n        stack.removeLast();\n        return top;\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected boolean top() {\n        return ((Boolean)stack.getLast()).booleanValue();\n    }","id":51532,"modified_method":"private boolean top() {\n        return ((Boolean)stack.getLast()).booleanValue();\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitGroup(AttributeGroup group) {\n        super.visitGroup(group);\n        createBuilder(group.getResource(), group.getName(), group.getGroupType().getAttributeTypes());\n    }","id":51533,"modified_method":"public void visitGroup(AttributeGroup group) {\n        pushShouldPersist(group);\n        if (shouldPersist()) \n            createBuilder(group.getResource(), group.getName(), group.getGroupType().getAttributeTypes());\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeGroup(AttributeGroup group) {\n        commitBuilder();\n        super.completeGroup(group);\n    }","id":51534,"modified_method":"public void completeGroup(AttributeGroup group) {\n        if (shouldPersist()) commitBuilder();\n        popShouldPersist();\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void completeAttribute(Attribute attribute) {\n        commitBuilder();\n        super.completeAttribute(attribute);\n\n    }","id":51535,"modified_method":"public void completeAttribute(Attribute attribute) {\n        if (shouldPersist()) commitBuilder();\n        popShouldPersist();\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visitAttribute(Attribute attribute) {\n        super.visitAttribute(attribute);\n        log().debug(\"Should persist for \"+attribute+\" is \"+top());\n        createBuilder(attribute.getResource(), attribute.getName(), attribute.getAttributeType());\n    }","id":51536,"modified_method":"public void visitAttribute(Attribute attribute) {\n        pushShouldPersist(attribute);\n        if (shouldPersist()) {\n            createBuilder(attribute.getResource(), attribute.getName(), attribute.getAttributeType());\n            storeAttribute(attribute);\n        }\n    }","commit_id":"d1ca94d99b8862e3fbcecb95ee475fd5ef3d0cef","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void doDelete(HttpServletRequest request,\n      HttpServletResponse response)\n  throws IOException, ServletException {\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 2 && pathSegments[0].toLowerCase().equals(TABLES) && pathSegments[1].length() > 0) {\n      tableHandler.doDelete(request, response, pathSegments);\n      return;\n    } else if (pathSegments.length >= 3 && pathSegments[0].length() > 0) {\n      // must be at least two path segments (table name and row or scanner)\n      if (pathSegments[1].toLowerCase().equals(SCANNER) &&\n          pathSegments.length == 3 && pathSegments[2].length() > 0) {\n        // DELETE to a scanner requires at least three path segments\n        scannerHandler.doDelete(request, response, pathSegments);\n        return;\n      } else if (pathSegments[1].toLowerCase().equals(ROW) &&\n          pathSegments.length >= 3) {\n        rowHandler.doDelete(request, response, pathSegments);\n        return;\n      }\n    }\n    \n    // if we reach this point, then no handler exists for this request.\n    GenericHandler.doNotFound(response, \"No handler\");\n  }","id":51537,"modified_method":"protected void doDelete(HttpServletRequest request,\n      HttpServletResponse response)\n  throws IOException, ServletException {\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 1 && pathSegments[0].length() > 0) {\n      // if it only has only table name\n      tableHandler.doDelete(request, response, pathSegments);\n      return;\n    } else if (pathSegments.length >= 3 && pathSegments[0].length() > 0) {\n      // must be at least two path segments (table name and row or scanner)\n      if (pathSegments[1].toLowerCase().equals(SCANNER) &&\n          pathSegments.length == 3 && pathSegments[2].length() > 0) {\n        // DELETE to a scanner requires at least three path segments\n        scannerHandler.doDelete(request, response, pathSegments);\n        return;\n      } else if (pathSegments[1].toLowerCase().equals(ROW) &&\n          pathSegments.length >= 3) {\n        rowHandler.doDelete(request, response, pathSegments);\n        return;\n      }\n    }\n    \n    // if we reach this point, then no handler exists for this request.\n    GenericHandler.doNotFound(response, \"No handler\");\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"protected void doPost(HttpServletRequest request, HttpServletResponse response)\n  throws IOException, ServletException {\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 1 && pathSegments[0].toLowerCase().equals(TABLES)) {\n      tableHandler.doPost(request, response, pathSegments);\n      return;\n    } else {\n      // there should be at least two path segments (table name and row or\n      // scanner)\n      if (pathSegments.length >= 2 && pathSegments[0].length() > 0) {\n        if (pathSegments[1].toLowerCase().equals(SCANNER)\n            && pathSegments.length >= 2) {\n          scannerHandler.doPost(request, response, pathSegments);\n          return;\n        } else if (pathSegments[1].toLowerCase().equals(ROW)\n            && pathSegments.length >= 3) {\n          rowHandler.doPost(request, response, pathSegments);\n          return;\n        } else if (pathSegments[0].toLowerCase().equals(TABLES) && pathSegments[1].length() > 0 \n            && (pathSegments[2].toLowerCase().equals(TableHandler.DISABLE) || pathSegments[2].toLowerCase().equals(TableHandler.ENABLE))) {\n          tableHandler.doPost(request, response, pathSegments);\n          return;\n        }\n      }\n    }\n\n    // if we get to this point, then no handler was matched this request.\n    GenericHandler.doNotFound(response, \"No handler for \" + request.getPathInfo());\n  }","id":51538,"modified_method":"protected void doPost(HttpServletRequest request, HttpServletResponse response)\n  throws IOException, ServletException {\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 0 || pathSegments[0].length() <= 0) {\n      // if it was a root request, it must be a create table request\n      tableHandler.doPost(request, response, pathSegments);\n      return;\n    } else {\n      // there should be at least two path segments (table name and row or\n      // scanner or disable/enable operation)\n      if (pathSegments.length >= 2 && pathSegments[0].length() > 0) {\n        if (pathSegments[1].toLowerCase().equals(SCANNER)\n            && pathSegments.length >= 2) {\n          scannerHandler.doPost(request, response, pathSegments);\n          return;\n        } else if (pathSegments[1].toLowerCase().equals(ROW)\n            && pathSegments.length >= 3) {\n          rowHandler.doPost(request, response, pathSegments);\n          return;\n        } else if ((pathSegments[1].toLowerCase().equals(TableHandler.DISABLE) || pathSegments[1].toLowerCase().equals(TableHandler.ENABLE))\n            && pathSegments.length == 2) {\n          tableHandler.doPost(request, response, pathSegments);\n          return;\n        }\n      }\n    }\n\n    // if we get to this point, then no handler was matched this request.\n    GenericHandler.doNotFound(response, \"No handler for \" + request.getPathInfo());\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"protected void doPut(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    // Equate PUT with a POST.\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 2 && pathSegments[0].toLowerCase().equals(TABLES) && pathSegments[1].length() > 0) {\n      tableHandler.doPut(request, response, pathSegments);\n    } else {\n      doPost(request, response);\n    }\n  }","id":51539,"modified_method":"protected void doPut(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    String [] pathSegments = getPathSegments(request);\n    \n    if (pathSegments.length == 1 && pathSegments[0].length() > 0) {\n      // if it has only table name\n      tableHandler.doPut(request, response, pathSegments);\n    } else {\n      // Equate PUT with a POST.\n      doPost(request, response);\n    }\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"private void updateTableXml(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException,\n      ServletException {\n    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory\n        .newInstance();\n    // ignore all comments inside the xml file\n    docBuilderFactory.setIgnoringComments(true);\n\n    DocumentBuilder builder = null;\n    Document doc = null;\n\n    try {\n      builder = docBuilderFactory.newDocumentBuilder();\n      doc = builder.parse(request.getInputStream());\n    } catch (javax.xml.parsers.ParserConfigurationException e) {\n      throw new ServletException(e);\n    } catch (org.xml.sax.SAXException e) {\n      throw new ServletException(e);\n    }\n\n    try {\n      String tableName = pathSegments[1];\n\n      NodeList columnfamily_nodes = doc.getElementsByTagName(\"columnfamily\");\n      for (int i = 0; i < columnfamily_nodes.getLength(); i++) {\n        Element columnfamily = (Element) columnfamily_nodes.item(i);\n        HColumnDescriptor hcd = putColumnFamilyXml(columnfamily);\n        admin.modifyColumn(tableName, hcd.getNameAsString(), hcd);\n      }\n    } catch (Exception e) {\n      throw new ServletException(e);\n    }\n  }","id":51540,"modified_method":"private void updateTableXml(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException,\n      ServletException {\n    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory\n        .newInstance();\n    // ignore all comments inside the xml file\n    docBuilderFactory.setIgnoringComments(true);\n\n    DocumentBuilder builder = null;\n    Document doc = null;\n\n    try {\n      builder = docBuilderFactory.newDocumentBuilder();\n      doc = builder.parse(request.getInputStream());\n    } catch (javax.xml.parsers.ParserConfigurationException e) {\n      throw new ServletException(e);\n    } catch (org.xml.sax.SAXException e) {\n      throw new ServletException(e);\n    }\n\n    try {\n      String tableName = pathSegments[0];\n\n      NodeList columnfamily_nodes = doc.getElementsByTagName(\"columnfamily\");\n      for (int i = 0; i < columnfamily_nodes.getLength(); i++) {\n        Element columnfamily = (Element) columnfamily_nodes.item(i);\n        HColumnDescriptor hcd = putColumnFamilyXml(columnfamily);\n        admin.modifyColumn(tableName, hcd.getNameAsString(), hcd);\n      }\n    } catch (Exception e) {\n      throw new ServletException(e);\n    }\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"public void doPost(HttpServletRequest request, HttpServletResponse response, \n    String[] pathSegments)\n  throws ServletException, IOException {\n    if (pathSegments.length == 1) {\n      // if it's a creation operation\n      putTable(request, response, pathSegments);\n    } else {\n      // if it's a disable operation or enable operation\n      String tableName = pathSegments[1];      \n      if (pathSegments[2].toLowerCase().equals(DISABLE)) {\n        admin.disableTable(tableName);\n      } else if (pathSegments[2].toLowerCase().equals(ENABLE)) {\n        admin.enableTable(tableName);\n      }\n      response.setStatus(202);\n    }\n  }","id":51541,"modified_method":"public void doPost(HttpServletRequest request, HttpServletResponse response, \n    String[] pathSegments)\n  throws ServletException, IOException {\n    if (pathSegments.length == 0 || pathSegments[0].length() <= 0) {\n      // if it's a creation operation\n      putTable(request, response, pathSegments);\n    } else {\n      // if it's a disable operation or enable operation\n      String tableName = pathSegments[0];      \n      if (pathSegments[1].toLowerCase().equals(DISABLE)) {\n        admin.disableTable(tableName);\n      } else if (pathSegments[1].toLowerCase().equals(ENABLE)) {\n        admin.enableTable(tableName);\n      }\n      response.setStatus(202);\n    }\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"private void deleteTable(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException {\n    String tableName = pathSegments[1];\n    admin.deleteTable(tableName);\n    response.setStatus(202);\n  }","id":51542,"modified_method":"private void deleteTable(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException {\n    String tableName = pathSegments[0];\n    admin.deleteTable(tableName);\n    response.setStatus(202);\n  }","commit_id":"6cb9d9ff7fa8ba9636d49eb42c105202f5ff3315","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n\tpublic Folder moveFolder(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(Folder.class);\n\n\t\ttry {\n\t\t\tLocalRepository sourceLocalRepository = getFolderLocalRepository(\n\t\t\t\tfolderId);\n\n\t\t\tLocalRepository destinationLocalRepository =\n\t\t\t\tgetFolderLocalRepository(\n\t\t\t\t\tparentFolderId, serviceContext.getScopeGroupId());\n\n\t\t\tif (parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tFolder toFolder = destinationLocalRepository.getFolder(\n\t\t\t\t\tparentFolderId);\n\n\t\t\t\tif (toFolder.isMountPoint()) {\n\t\t\t\t\tdestinationLocalRepository = getLocalRepository(\n\t\t\t\t\t\ttoFolder.getRepositoryId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFolder folder = null;\n\n\t\t\tif (sourceLocalRepository.getRepositoryId() ==\n\t\t\t\t\tdestinationLocalRepository.getRepositoryId()) {\n\n\t\t\t\t// Move file entries within repository\n\n\t\t\t\tfolder = sourceLocalRepository.moveFolder(\n\t\t\t\t\tuserId, folderId, parentFolderId, serviceContext);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Move file entries between repositories\n\n\t\t\t\tfolder = moveFolders(\n\t\t\t\t\tuserId, folderId, parentFolderId, sourceLocalRepository,\n\t\t\t\t\tdestinationLocalRepository, serviceContext);\n\t\t\t}\n\n\t\t\treturn folder;\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(Folder.class);\n\t\t}\n\t}","id":51543,"modified_method":"@Override\n\tpublic Folder moveFolder(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(Folder.class);\n\n\t\ttry {\n\t\t\tLocalRepository sourceLocalRepository = getFolderLocalRepository(\n\t\t\t\tfolderId);\n\n\t\t\tLocalRepository destinationLocalRepository =\n\t\t\t\tgetFolderLocalRepository(\n\t\t\t\t\tparentFolderId, serviceContext.getScopeGroupId());\n\n\t\t\tif (parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tFolder toFolder = destinationLocalRepository.getFolder(\n\t\t\t\t\tparentFolderId);\n\n\t\t\t\tif (toFolder.isMountPoint()) {\n\t\t\t\t\tdestinationLocalRepository = getLocalRepository(\n\t\t\t\t\t\ttoFolder.getRepositoryId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sourceLocalRepository.getRepositoryId() ==\n\t\t\t\t\tdestinationLocalRepository.getRepositoryId()) {\n\n\t\t\t\t// Move file entries within repository\n\n\t\t\t\treturn sourceLocalRepository.moveFolder(\n\t\t\t\t\tuserId, folderId, parentFolderId, serviceContext);\n\t\t\t}\n\n\t\t\t// Move file entries between repositories\n\n\t\t\treturn moveFolders(\n\t\t\t\tuserId, folderId, parentFolderId, sourceLocalRepository,\n\t\t\t\tdestinationLocalRepository, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(Folder.class);\n\t\t}\n\t}","commit_id":"bb80f03db3e376a3f56494aea17f0f5f8c6b5868","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Moves the file entry to the new folder.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  fileEntryId the primary key of the file entry\n\t * @param  newFolderId the primary key of the new folder\n\t * @param  serviceContext the service context to be applied\n\t * @return the file entry\n\t * @throws PortalException if the file entry or the new folder could not be\n\t *         found\n\t */\n\t@Override\n\tpublic FileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(FileEntry.class);\n\n\t\ttry {\n\t\t\tLocalRepository fromLocalRepository = getFileEntryLocalRepository(\n\t\t\t\tfileEntryId);\n\t\t\tLocalRepository toLocalRepository = getFolderLocalRepository(\n\t\t\t\tnewFolderId, serviceContext.getScopeGroupId());\n\n\t\t\tif (fromLocalRepository.getRepositoryId() ==\n\t\t\t\t\ttoLocalRepository.getRepositoryId()) {\n\n\t\t\t\t// Move file entries within repository\n\n\t\t\t\tFileEntry fileEntry = fromLocalRepository.moveFileEntry(\n\t\t\t\t\tuserId, fileEntryId, newFolderId, serviceContext);\n\n\t\t\t\treturn fileEntry;\n\t\t\t}\n\n\t\t\t// Move file entries between repositories\n\n\t\t\treturn moveFileEntries(\n\t\t\t\tuserId, fileEntryId, newFolderId, fromLocalRepository,\n\t\t\t\ttoLocalRepository, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(FileEntry.class);\n\t\t}\n\t}","id":51544,"modified_method":"/**\n\t * Moves the file entry to the new folder.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  fileEntryId the primary key of the file entry\n\t * @param  newFolderId the primary key of the new folder\n\t * @param  serviceContext the service context to be applied\n\t * @return the file entry\n\t * @throws PortalException if the file entry or the new folder could not be\n\t *         found\n\t */\n\t@Override\n\tpublic FileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(FileEntry.class);\n\n\t\ttry {\n\t\t\tLocalRepository fromLocalRepository = getFileEntryLocalRepository(\n\t\t\t\tfileEntryId);\n\t\t\tLocalRepository toLocalRepository = getFolderLocalRepository(\n\t\t\t\tnewFolderId, serviceContext.getScopeGroupId());\n\n\t\t\tif (fromLocalRepository.getRepositoryId() ==\n\t\t\t\t\ttoLocalRepository.getRepositoryId()) {\n\n\t\t\t\t// Move file entries within repository\n\n\t\t\t\treturn fromLocalRepository.moveFileEntry(\n\t\t\t\t\tuserId, fileEntryId, newFolderId, serviceContext);\n\t\t\t}\n\n\t\t\t// Move file entries between repositories\n\n\t\t\treturn moveFileEntries(\n\t\t\t\tuserId, fileEntryId, newFolderId, fromLocalRepository,\n\t\t\t\ttoLocalRepository, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(FileEntry.class);\n\t\t}\n\t}","commit_id":"bb80f03db3e376a3f56494aea17f0f5f8c6b5868","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected LocalRepository getFolderLocalRepository(\n\t\t\tlong folderId, long groupId)\n\t\tthrows PortalException {\n\n\t\tLocalRepository localRepository = null;\n\n\t\tif (folderId == DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tlocalRepository = getLocalRepository(groupId);\n\t\t}\n\t\telse {\n\t\t\tlocalRepository = getFolderLocalRepository(folderId);\n\t\t}\n\n\t\treturn localRepository;\n\t}","id":51545,"modified_method":"protected LocalRepository getFolderLocalRepository(\n\t\t\tlong folderId, long groupId)\n\t\tthrows PortalException {\n\n\t\tif (folderId == DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\treturn getLocalRepository(groupId);\n\t\t}\n\n\t\treturn getFolderLocalRepository(folderId);\n\t}","commit_id":"bb80f03db3e376a3f56494aea17f0f5f8c6b5868","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic JournalFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException {\n\n\t\t// Folder\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\tthrow new TrashEntryException();\n\t\t}\n\n\t\tString title = folder.getName();\n\n\t\tfolder = updateStatus(\n\t\t\tuserId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\tUnicodeProperties typeSettingsProperties = new UnicodeProperties();\n\n\t\ttypeSettingsProperties.put(\"title\", folder.getName());\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.addTrashEntry(\n\t\t\tuserId, folder.getGroupId(), JournalFolder.class.getName(),\n\t\t\tfolder.getFolderId(), folder.getUuid(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, null, typeSettingsProperties);\n\n\t\tfolder.setName(TrashUtil.getTrashTitle(trashEntry.getEntryId()));\n\n\t\tjournalFolderPersistence.update(folder);\n\n\t\t// Folders and articles\n\n\t\tList<Object> foldersAndArticles =\n\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tmoveDependentsToTrash(foldersAndArticles, trashEntry.getEntryId());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", title);\n\n\t\tSocialActivityManagerUtil.addActivity(\n\t\t\tuserId, folder, SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\treturn folder;\n\t}","id":51546,"modified_method":"@Override\n\tpublic JournalFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException {\n\n\t\t// Folder\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\tthrow new TrashEntryException();\n\t\t}\n\n\t\tString title = folder.getName();\n\n\t\tfolder = updateStatus(\n\t\t\tuserId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\tUnicodeProperties typeSettingsProperties = new UnicodeProperties();\n\n\t\ttypeSettingsProperties.put(\"title\", folder.getName());\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.addTrashEntry(\n\t\t\tuserId, folder.getGroupId(), JournalFolder.class.getName(),\n\t\t\tfolder.getFolderId(), folder.getUuid(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, null, typeSettingsProperties);\n\n\t\tfolder.setName(TrashUtil.getTrashTitle(trashEntry.getEntryId()));\n\n\t\tjournalFolderPersistence.update(folder);\n\n\t\t// Folders and articles\n\n\t\tList<Object> foldersAndArticles =\n\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tmoveDependentsToTrash(foldersAndArticles, trashEntry.getEntryId());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", title);\n\n\t\tSocialActivityManagerUtil.addActivity(\n\t\t\tuserId, folder, SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t// Index\n\n\t\tIndexer<JournalFolder> indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tJournalFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","commit_id":"32b31341f7e09c5ce77e606bc9f9ce86d11c4efc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic JournalFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (!folder.isInTrash()) {\n\t\t\tthrow new RestoreEntryException(\n\t\t\t\tRestoreEntryException.INVALID_STATUS);\n\t\t}\n\n\t\tif (folder.isInTrashExplicitly()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\n\t\t\t// Folder\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\tJournalFolder.class.getName(), folderId);\n\n\t\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\tstatus = trashVersion.getStatus();\n\t\t\t}\n\n\t\t\tupdateStatus(userId, folder, status);\n\n\t\t\t// Trash\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t}\n\n\t\t\t// Folders and articles\n\n\t\t\tList<Object> foldersAndArticles =\n\t\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH);\n\n\t\t\trestoreDependentsFromTrash(foldersAndArticles);\n\t\t}\n\n\t\treturn journalFolderLocalService.moveFolder(\n\t\t\tfolderId, parentFolderId, serviceContext);\n\t}","id":51547,"modified_method":"@Override\n\tpublic JournalFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (!folder.isInTrash()) {\n\t\t\tthrow new RestoreEntryException(\n\t\t\t\tRestoreEntryException.INVALID_STATUS);\n\t\t}\n\n\t\tif (folder.isInTrashExplicitly()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\n\t\t\t// Folder\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\tJournalFolder.class.getName(), folderId);\n\n\t\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\tstatus = trashVersion.getStatus();\n\t\t\t}\n\n\t\t\tupdateStatus(userId, folder, status);\n\n\t\t\t// Trash\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t}\n\n\t\t\t// Folders and articles\n\n\t\t\tList<Object> foldersAndArticles =\n\t\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH);\n\n\t\t\trestoreDependentsFromTrash(foldersAndArticles);\n\t\t}\n\n\t\tfolder = journalFolderLocalService.moveFolder(\n\t\t\tfolderId, parentFolderId, serviceContext);\n\n\t\t// Index\n\n\t\tIndexer<JournalFolder> indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tJournalFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","commit_id":"32b31341f7e09c5ce77e606bc9f9ce86d11c4efc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic JournalFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException {\n\n\t\t// Folder\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\tthrow new TrashEntryException();\n\t\t}\n\n\t\tString title = folder.getName();\n\n\t\tfolder = updateStatus(\n\t\t\tuserId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\tUnicodeProperties typeSettingsProperties = new UnicodeProperties();\n\n\t\ttypeSettingsProperties.put(\"title\", folder.getName());\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.addTrashEntry(\n\t\t\tuserId, folder.getGroupId(), JournalFolder.class.getName(),\n\t\t\tfolder.getFolderId(), folder.getUuid(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, null, typeSettingsProperties);\n\n\t\tfolder.setName(TrashUtil.getTrashTitle(trashEntry.getEntryId()));\n\n\t\tjournalFolderPersistence.update(folder);\n\n\t\t// Folders and articles\n\n\t\tList<Object> foldersAndArticles =\n\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tmoveDependentsToTrash(foldersAndArticles, trashEntry.getEntryId());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", title);\n\n\t\tSocialActivityManagerUtil.addActivity(\n\t\t\tuserId, folder, SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t// Index\n\n\t\tIndexer<JournalFolder> indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tJournalFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","id":51548,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic JournalFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException {\n\n\t\t// Folder\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\tthrow new TrashEntryException();\n\t\t}\n\n\t\tString title = folder.getName();\n\n\t\tfolder = updateStatus(\n\t\t\tuserId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\tUnicodeProperties typeSettingsProperties = new UnicodeProperties();\n\n\t\ttypeSettingsProperties.put(\"title\", folder.getName());\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.addTrashEntry(\n\t\t\tuserId, folder.getGroupId(), JournalFolder.class.getName(),\n\t\t\tfolder.getFolderId(), folder.getUuid(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, null, typeSettingsProperties);\n\n\t\tfolder.setName(TrashUtil.getTrashTitle(trashEntry.getEntryId()));\n\n\t\tjournalFolderPersistence.update(folder);\n\n\t\t// Folders and articles\n\n\t\tList<Object> foldersAndArticles =\n\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tmoveDependentsToTrash(foldersAndArticles, trashEntry.getEntryId());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", title);\n\n\t\tSocialActivityManagerUtil.addActivity(\n\t\t\tuserId, folder, SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\treturn folder;\n\t}","commit_id":"ad209d20ab84193a8f2c80335abab3c66ff22566","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic JournalFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (!folder.isInTrash()) {\n\t\t\tthrow new RestoreEntryException(\n\t\t\t\tRestoreEntryException.INVALID_STATUS);\n\t\t}\n\n\t\tif (folder.isInTrashExplicitly()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\n\t\t\t// Folder\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\tJournalFolder.class.getName(), folderId);\n\n\t\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\tstatus = trashVersion.getStatus();\n\t\t\t}\n\n\t\t\tupdateStatus(userId, folder, status);\n\n\t\t\t// Trash\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t}\n\n\t\t\t// Folders and articles\n\n\t\t\tList<Object> foldersAndArticles =\n\t\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH);\n\n\t\t\trestoreDependentsFromTrash(foldersAndArticles);\n\t\t}\n\n\t\tfolder = journalFolderLocalService.moveFolder(\n\t\t\tfolderId, parentFolderId, serviceContext);\n\n\t\t// Index\n\n\t\tIndexer<JournalFolder> indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tJournalFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","id":51549,"modified_method":"@Override\n\tpublic JournalFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (!folder.isInTrash()) {\n\t\t\tthrow new RestoreEntryException(\n\t\t\t\tRestoreEntryException.INVALID_STATUS);\n\t\t}\n\n\t\tif (folder.isInTrashExplicitly()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\n\t\t\t// Folder\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\tJournalFolder.class.getName(), folderId);\n\n\t\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\tstatus = trashVersion.getStatus();\n\t\t\t}\n\n\t\t\tupdateStatus(userId, folder, status);\n\n\t\t\t// Trash\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t}\n\n\t\t\t// Folders and articles\n\n\t\t\tList<Object> foldersAndArticles =\n\t\t\t\tjournalFolderLocalService.getFoldersAndArticles(\n\t\t\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH);\n\n\t\t\trestoreDependentsFromTrash(foldersAndArticles);\n\t\t}\n\n\t\treturn journalFolderLocalService.moveFolder(\n\t\t\tfolderId, parentFolderId, serviceContext);\n\t}","commit_id":"ad209d20ab84193a8f2c80335abab3c66ff22566","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString[] urls = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"urls\"), \"\\n\");\n\t\tint entriesPerFeed = ParamUtil.getInteger(req, \"entriesPerFeed\", 4);\n\n\t\tprefs.setValues(\"urls\", urls);\n\t\tprefs.setValue(\"items-per-channel\", String.valueOf(entriesPerFeed));\n\n\t\ttry {\n\t\t\tprefs.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(req, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\t}","id":51550,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString[] urls = req.getParameterValues(\"url\");\n\t\tString[] titles = req.getParameterValues(\"title\");\n\t\tint entriesPerFeed = ParamUtil.getInteger(req, \"entriesPerFeed\", 4);\n\n\t\tif (urls != null && titles != null) {\n\t\t\tprefs.setValues(\"urls\", urls);\n\t\t\tprefs.setValues(\"titles\", titles);\n\t\t}\n\t\telse {\n\t\t\tprefs.setValues(\"urls\", new String[0]);\n\t\t\tprefs.setValues(\"titles\", new String[0]);\n\t\t}\n\t\tprefs.setValue(\"items-per-channel\", String.valueOf(entriesPerFeed));\n\n\t\ttry {\n\t\t\tprefs.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(req, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\t}","commit_id":"a25c23fc694ca0e1ed13e875753e4cf7cebb6aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] zips = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"zips\"), \"\\n\");\n\n\t\tboolean fahrenheit = ParamUtil.get(actionRequest, \"fahrenheit\", true);\n\n\t\tpreferences.setValues(\"zips\", zips);\n\t\tpreferences.setValue(\"fahrenheit\", String.valueOf(fahrenheit));\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest, portletConfig.getPortletName() + \".doEdit\");\n\t}","id":51551,"modified_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] zips = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"zips\"), \"\\n\");\n\n\t\tboolean fahrenheit = ParamUtil.get(actionRequest, \"fahrenheit\", true);\n\t\t\n\t\tPortletMode portletMode = actionResponse.getPortletMode();\n\t\tif(portletMode.equals(LiferayPortletMode.EDIT_GUEST)){\n\t\t\tpreferences.setValues(\"guest-zips\", zips);\n\t\t\tpreferences.setValue(\"guest-fahrenheit\", String.valueOf(fahrenheit));\n\t\t}else{\n\t\t\tpreferences.setValues(\"zips\", zips);\n\t\t\tpreferences.setValue(\"fahrenheit\", String.valueOf(fahrenheit));\n\t\t}\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest, portletConfig.getPortletName() + \".doEdit\");\n\t}","commit_id":"0773dc657ad4283dbf981bdd01ea091e2393c589","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tif (actionRequest.getPortletMode().equals(PortletMode.EDIT)) {\n\t\t\tupdatePreferences(actionRequest, actionResponse);\n\t\t}\n\t}","id":51552,"modified_method":"public void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tupdatePreferences(actionRequest, actionResponse);\n\n\t}","commit_id":"0773dc657ad4283dbf981bdd01ea091e2393c589","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = PortletConfigurationLayoutUtil.getLayout(themeDisplay);\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPermissionUtil.check(\n\t\t\tthemeDisplay.getPermissionChecker(), themeDisplay.getScopeGroupId(),\n\t\t\tlayout, portletResource, ActionKeys.CONFIGURATION);\n\n\t\tUnicodeProperties properties = PropertiesParamUtil.getProperties(\n\t\t\tactionRequest, _parameterNamePrefix);\n\n\t\tSettings settings = getSettings(actionRequest);\n\n\t\tfor (Map.Entry<String, String> entry : properties.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tString value = entry.getValue();\n\n\t\t\tsettings.setValue(name, value);\n\t\t}\n\n\t\tMap<String, String[]> portletPreferencesMap =\n\t\t\t(Map<String, String[]>)actionRequest.getAttribute(\n\t\t\t\tWebKeys.PORTLET_PREFERENCES_MAP);\n\n\t\tif (portletPreferencesMap != null) {\n\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\tportletPreferencesMap.entrySet()) {\n\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tsettings.setValues(name, values);\n\t\t\t}\n\t\t}\n\n\t\tpostProcess(themeDisplay.getCompanyId(), actionRequest, settings);\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\ttry {\n\t\t\t\tsettings.store();\n\t\t\t}\n\t\t\tcatch (ValidatorException ve) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tPortalUtil.getPortletId(actionRequest) +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\t\tportletResource);\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tPortalUtil.getPortletId(actionRequest) +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\n\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t}\n\t\t}\n\t}","id":51553,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = PortletConfigurationLayoutUtil.getLayout(themeDisplay);\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPermissionUtil.check(\n\t\t\tthemeDisplay.getPermissionChecker(), themeDisplay.getScopeGroupId(),\n\t\t\tlayout, portletResource, ActionKeys.CONFIGURATION);\n\n\t\tUnicodeProperties properties = PropertiesParamUtil.getProperties(\n\t\t\tactionRequest, _parameterNamePrefix);\n\n\t\tSettings settings = getSettings(actionRequest);\n\n\t\tfor (Map.Entry<String, String> entry : properties.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tString value = entry.getValue();\n\n\t\t\tString oldValue = settings.getValue(name, null);\n\n\t\t\tif (!StringUtil.equalsIgnoreBreakLine(value, oldValue)) {\n\t\t\t\tsettings.setValue(name, value);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, String[]> portletPreferencesMap =\n\t\t\t(Map<String, String[]>)actionRequest.getAttribute(\n\t\t\t\tWebKeys.PORTLET_PREFERENCES_MAP);\n\n\t\tif (portletPreferencesMap != null) {\n\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\tportletPreferencesMap.entrySet()) {\n\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tString[] oldValues = settings.getValues(name, null);\n\n\t\t\t\tif (!Validator.equals(values, oldValues)) {\n\t\t\t\t\tsettings.setValues(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpostProcess(themeDisplay.getCompanyId(), actionRequest, settings);\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\ttry {\n\t\t\t\tsettings.store();\n\t\t\t}\n\t\t\tcatch (ValidatorException ve) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tPortalUtil.getPortletId(actionRequest) +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\t\tportletResource);\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tPortalUtil.getPortletId(actionRequest) +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\n\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t}\n\t\t}\n\t}","commit_id":"15cbecdd01bec29770f5ac86e1a94253a866200c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setMirror(@NotNull TreeElement element) {\n    setMirrorCheckingType(element, null);\n\n    PsiClass mirror = (PsiClass)SourceTreeToPsiMap.treeElementToPsi(element);\n\n    final PsiDocComment docComment = getDocComment();\n    if (docComment != null) {\n        ((ClsElementImpl)docComment).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getDocComment()));\n    }\n      ((ClsElementImpl)getModifierList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getModifierList()));\n      ((ClsElementImpl)getNameIdentifier()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getNameIdentifier()));\n    if (!isAnnotationType() && !isEnum()) {\n        ((ClsElementImpl)getExtendsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getExtendsList()));\n    }\n      ((ClsElementImpl)getImplementsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getImplementsList()));\n      ((ClsElementImpl)getTypeParameterList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getTypeParameterList()));\n\n    PsiField[] fields = getFields();\n    PsiField[] mirrorFields = mirror.getFields();\n    if (LOG.assertTrue(fields.length == mirrorFields.length)) {\n      for (int i = 0; i < fields.length; i++) {\n          ((ClsElementImpl)fields[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorFields[i]));\n      }\n    }\n\n    PsiMethod[] methods = getMethods();\n    PsiMethod[] mirrorMethods = mirror.getMethods();\n    if (LOG.assertTrue(methods.length == mirrorMethods.length)) {\n      for (int i = 0; i < methods.length; i++) {\n          ((ClsElementImpl)methods[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorMethods[i]));\n      }\n    }\n\n    PsiClass[] classes = getInnerClasses();\n    PsiClass[] mirrorClasses = mirror.getInnerClasses();\n    if (LOG.assertTrue(classes.length == mirrorClasses.length)) {\n      for (int i = 0; i < classes.length; i++) {\n          ((ClsElementImpl)classes[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorClasses[i]));\n      }\n    }\n  }","id":51554,"modified_method":"public void setMirror(@NotNull TreeElement element) {\n    setMirrorCheckingType(element, null);\n\n    PsiClass mirror = SourceTreeToPsiMap.treeToPsiNotNull(element);\n\n    PsiDocComment docComment = getDocComment();\n    if (docComment != null) {\n      ((ClsElementImpl)docComment).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getDocComment()));\n    }\n    ((ClsElementImpl)getModifierList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getModifierList()));\n    ((ClsElementImpl)getNameIdentifier()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getNameIdentifier()));\n    if (!isAnnotationType() && !isEnum()) {\n      ((ClsElementImpl)getExtendsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getExtendsList()));\n    }\n    ((ClsElementImpl)getImplementsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getImplementsList()));\n    ((ClsElementImpl)getTypeParameterList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getTypeParameterList()));\n\n    Ref<Boolean> extLog = Ref.create(true);\n\n    PsiField[] fields = getFields();\n    PsiField[] mirrorFields = mirror.getFields();\n    if (fields.length == mirrorFields.length) {\n      for (int i = 0; i < fields.length; i++) {\n        ((ClsElementImpl)fields[i]).setMirror(SourceTreeToPsiMap.psiToTreeNotNull(mirrorFields[i]));\n      }\n    }\n    else {\n      log(this, mirror, \"fields:\" + fields.length + \"!=\" + mirrorFields.length, extLog);\n    }\n\n    PsiMethod[] methods = getMethods();\n    PsiMethod[] mirrorMethods = mirror.getMethods();\n    if (methods.length == mirrorMethods.length) {\n      for (int i = 0; i < methods.length; i++) {\n        ((ClsElementImpl)methods[i]).setMirror(SourceTreeToPsiMap.psiToTreeNotNull(mirrorMethods[i]));\n      }\n    }\n    else {\n      log(this, mirror, \"methods:\" + methods.length + \"!=\" + mirrorMethods.length, extLog);\n    }\n\n    PsiClass[] classes = getInnerClasses();\n    PsiClass[] mirrorClasses = mirror.getInnerClasses();\n    if (classes.length == mirrorClasses.length) {\n      for (int i = 0; i < classes.length; i++) {\n        ((ClsElementImpl)classes[i]).setMirror(SourceTreeToPsiMap.psiToTreeNotNull(mirrorClasses[i]));\n      }\n    }\n    else {\n      log(this, mirror, \"classes:\" + classes.length + \"!=\" + mirrorClasses.length, extLog);\n    }\n  }","commit_id":"a2d7ac1d50fe9297270acfbb3b7ad5235214cb3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public PsiElement resolveToDeclarationPsiElement(JetReferenceExpression referenceExpression) {\n        return descriptorToDeclarations.get(resolveReferenceExpression(referenceExpression));\n    }","id":51555,"modified_method":"@Override\n    public PsiElement resolveToDeclarationPsiElement(JetReferenceExpression referenceExpression) {\n        DeclarationDescriptor declarationDescriptor = resolveReferenceExpression(referenceExpression);\n        if (declarationDescriptor == null) {\n            return null;\n        }\n        return descriptorToDeclarations.get(declarationDescriptor.getOriginal());\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void recordDeclarationResolution(@NotNull PsiElement declaration, @NotNull DeclarationDescriptor descriptor) {\n        descriptorToDeclarations.put(descriptor, declaration);\n        declarationsToDescriptors.put(declaration, descriptor);\n    }","id":51556,"modified_method":"@Override\n    public void recordDeclarationResolution(@NotNull PsiElement declaration, @NotNull DeclarationDescriptor descriptor) {\n        descriptorToDeclarations.put(descriptor.getOriginal(), declaration);\n        declarationsToDescriptors.put(declaration, descriptor.getOriginal());\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable @IfNotParsed\n    public JetExpression getRight() {\n        ASTNode node = getOperationTokenNode();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetExpression) {\n                return (JetExpression) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","id":51557,"modified_method":"@Nullable @IfNotParsed\n    public JetExpression getRight() {\n        ASTNode node = getOperationReference().getNode().getTreeNext();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetExpression) {\n                return (JetExpression) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ASTNode getOperationTokenNode() {\n        ASTNode operationNode = getNode().findChildByType(JetTokens.OPERATIONS);\n        assert operationNode != null;\n        return operationNode;\n    }","id":51558,"modified_method":"@NotNull\n    public JetReferenceExpression getOperationReference() {\n        return (JetReferenceExpression) findChildByType(JetNodeTypes.OPERATION_REFERENCE);\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable @IfNotParsed\n    public JetTypeReference getRight() {\n        ASTNode node = getOperationTokenNode();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetTypeReference) {\n                return (JetTypeReference) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","id":51559,"modified_method":"@Nullable @IfNotParsed\n    public JetTypeReference getRight() {\n        ASTNode node = getOperationReference().getNode();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetTypeReference) {\n                return (JetTypeReference) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ASTNode getOperationTokenNode() {\n        ASTNode operationNode = getNode().findChildByType(JetTokens.OPERATIONS);\n        assert operationNode != null;\n        return operationNode;\n    }","id":51560,"modified_method":"@NotNull\n    public JetReferenceExpression getOperationReference() {\n        return (JetReferenceExpression) findChildByType(JetNodeTypes.OPERATION_REFERENCE);\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseBinaryExpression(Precedence precedence) {\n//        System.out.println(precedence.name() + \" at \" + myBuilder.getTokenText());\n\n        PsiBuilder.Marker expression = mark();\n\n        precedence.parseHigherPrecedence(this);\n\n        while (!myBuilder.newlineBeforeCurrentToken() && atSet(precedence.getOperations())) {\n            IElementType operation = tt();\n            advance(); // operation\n\n            JetNodeType resultType = precedence.parseRightHandSide(operation, this);\n            expression.done(resultType);\n             expression = expression.precede();\n        }\n\n        expression.drop();\n    }","id":51561,"modified_method":"private void parseBinaryExpression(Precedence precedence) {\n//        System.out.println(precedence.name() + \" at \" + myBuilder.getTokenText());\n\n        PsiBuilder.Marker expression = mark();\n\n        precedence.parseHigherPrecedence(this);\n\n        while (!myBuilder.newlineBeforeCurrentToken() && atSet(precedence.getOperations())) {\n            IElementType operation = tt();\n\n            PsiBuilder.Marker operationReference = mark();\n            advance(); // operation\n            operationReference.done(OPERATION_REFERENCE);\n\n            JetNodeType resultType = precedence.parseRightHandSide(operation, this);\n            expression.done(resultType);\n             expression = expression.precede();\n        }\n\n        expression.drop();\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable @IfNotParsed\n    public String getReferencedName() {\n        ASTNode node = getNode().findChildByType(REFERENCE_TOKENS);\n        return node == null ? null : node.getText();\n    }","id":51562,"modified_method":"@Nullable @IfNotParsed\n    public String getReferencedName() {\n        PsiElement referencedNameElement = getReferencedNameElement();\n        return referencedNameElement == null ? null : referencedNameElement.getNode().getText();\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public PsiReference getReference() {\n        if (getReferencedName() == null) return null;\n        return new PsiReference() {\n            @Override\n            public PsiElement getElement() {\n                return findChildByType(REFERENCE_TOKENS);\n            }\n\n            @Override\n            public TextRange getRangeInElement() {\n                return new TextRange(0, getElement().getTextLength());\n            }\n\n            @Override\n            public PsiElement resolve() {\n                PsiElement element = getElement();\n                JetFile file = PsiTreeUtil.getParentOfType(element, JetFile.class);\n                BindingContext bindingContext = AnalyzingUtils.analyzeFile(file, ErrorHandler.DO_NOTHING);\n                PsiElement psiElement = bindingContext.resolveToDeclarationPsiElement(JetReferenceExpression.this);\n                return psiElement == null\n                        ? file\n                        : psiElement;\n            }\n\n            @NotNull\n            @Override\n            public String getCanonicalText() {\n                return getReferencedName();\n            }\n\n            @Override\n            public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n                throw new IncorrectOperationException();\n            }\n\n            @Override\n            public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n                throw new IncorrectOperationException();\n            }\n\n            @Override\n            public boolean isReferenceTo(PsiElement element) {\n                return resolve() == element;\n            }\n\n            @NotNull\n            @Override\n            public Object[] getVariants() {\n                return EMPTY_ARRAY;\n            }\n\n            @Override\n            public boolean isSoft() {\n                return false;\n            }\n        };\n    }","id":51563,"modified_method":"@Override\n    public PsiReference getReference() {\n        if (getReferencedName() == null) return null;\n        return new PsiReference() {\n            @Override\n            public PsiElement getElement() {\n                return getReferencedNameElement();\n            }\n\n            @Override\n            public TextRange getRangeInElement() {\n                return new TextRange(0, getElement().getTextLength());\n            }\n\n            @Override\n            public PsiElement resolve() {\n                PsiElement element = getElement();\n                JetFile file = PsiTreeUtil.getParentOfType(element, JetFile.class);\n                BindingContext bindingContext = AnalyzingUtils.analyzeFile(file, ErrorHandler.DO_NOTHING);\n                PsiElement psiElement = bindingContext.resolveToDeclarationPsiElement(JetReferenceExpression.this);\n                return psiElement == null\n                        ? file\n                        : psiElement;\n            }\n\n            @NotNull\n            @Override\n            public String getCanonicalText() {\n                return getReferencedName();\n            }\n\n            @Override\n            public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n                throw new IncorrectOperationException();\n            }\n\n            @Override\n            public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n                throw new IncorrectOperationException();\n            }\n\n            @Override\n            public boolean isReferenceTo(PsiElement element) {\n                return resolve() == element;\n            }\n\n            @NotNull\n            @Override\n            public Object[] getVariants() {\n                return EMPTY_ARRAY;\n            }\n\n            @Override\n            public boolean isSoft() {\n                return false;\n            }\n        };\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable @IfNotParsed\n    public PsiElement getReferencedNameElement() {\n        return findChildByType(REFERENCE_TOKENS);\n    }","id":51564,"modified_method":"@Nullable @IfNotParsed\n    public PsiElement getReferencedNameElement() {\n        PsiElement element = findChildByType(REFERENCE_TOKENS);\n        if (element == null) {\n            element = findChildByType(JetExpressionParsing.ALL_OPERATIONS);\n        }\n        return element;\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public Type getType(@NotNull final JetScope scope, @NotNull JetExpression expression, final boolean preferBlock) {\n        final Type[] result = new Type[1];\n        expression.accept(new JetVisitor() {\n            @Override\n            public void visitReferenceExpression(JetReferenceExpression expression) {\n                // TODO : other members\n                // TODO : type substitutions???\n                String referencedName = expression.getReferencedName();\n                PropertyDescriptor property = scope.getProperty(referencedName);\n                if (property != null) {\n                    trace.recordReferenceResolution(expression, property);\n                    result[0] = property.getType();\n                    return;\n                } else {\n                    NamespaceDescriptor namespace = scope.getNamespace(referencedName);\n                    if (namespace != null) {\n                        trace.recordReferenceResolution(expression, namespace);\n                        result[0] = namespace.getNamespaceType();\n                        return;\n                    }\n                }\n                semanticServices.getErrorHandler().unresolvedReference(expression);\n            }\n\n            @Override\n            public void visitFunctionLiteralExpression(JetFunctionLiteralExpression expression) {\n                if (preferBlock && !expression.hasParameterSpecification()) {\n                    result[0] = getBlockReturnedType(scope, expression.getBody());\n                    return;\n                }\n\n                JetTypeReference returnTypeRef = expression.getReturnTypeRef();\n\n                JetTypeReference receiverTypeRef = expression.getReceiverTypeRef();\n                final Type receiverType;\n                if (receiverTypeRef != null) {\n                    receiverType = typeResolver.resolveType(scope, receiverTypeRef);\n                } else {\n                    receiverType = scope.getThisType();\n                }\n\n                List<JetElement> body = expression.getBody();\n                final Map<String, PropertyDescriptor> parameterDescriptors = new HashMap<String, PropertyDescriptor>();\n                List<Type> parameterTypes = new ArrayList<Type>();\n                for (JetParameter parameter : expression.getParameters()) {\n                    JetTypeReference typeReference = parameter.getTypeReference();\n                    if (typeReference == null) {\n                        throw new UnsupportedOperationException(\"Type inference for parameters is not implemented yet\");\n                    }\n                    PropertyDescriptor propertyDescriptor = classDescriptorResolver.resolvePropertyDescriptor(scope, parameter);\n                    parameterDescriptors.put(parameter.getName(), propertyDescriptor);\n                    parameterTypes.add(propertyDescriptor.getType());\n                }\n                Type returnType;\n                if (returnTypeRef != null) {\n                    returnType = typeResolver.resolveType(scope, returnTypeRef);\n                } else {\n                    WritableScope writableScope = new WritableScope(scope);\n                    for (PropertyDescriptor propertyDescriptor : parameterDescriptors.values()) {\n                        writableScope.addPropertyDescriptor(propertyDescriptor);\n                    }\n                    writableScope.setThisType(receiverType);\n                    returnType = getBlockReturnedType(writableScope, body);\n                }\n                result[0] = JetStandardClasses.getFunctionType(null, receiverTypeRef == null ? null : receiverType, parameterTypes, returnType);\n            }\n\n            @Override\n            public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n                result[0] = getType(scope, expression.getExpression(), false);\n            }\n\n            @Override\n            public void visitConstantExpression(JetConstantExpression expression) {\n                IElementType elementType = expression.getNode().getElementType();\n                JetStandardLibrary standardLibrary = semanticServices.getStandardLibrary();\n                if (elementType == JetNodeTypes.INTEGER_CONSTANT) {\n                    result[0] = standardLibrary.getIntType();\n                } else if (elementType == JetNodeTypes.LONG_CONSTANT) {\n                    result[0] = standardLibrary.getLongType();\n                } else if (elementType == JetNodeTypes.FLOAT_CONSTANT) {\n                    String text = expression.getText();\n                    assert text.length() > 0;\n                    char lastChar = text.charAt(text.length() - 1);\n                    if (lastChar == 'f' || lastChar == 'F') {\n                        result[0] = standardLibrary.getFloatType();\n                    } else {\n                        result[0] = standardLibrary.getDoubleType();\n                    }\n                } else if (elementType == JetNodeTypes.BOOLEAN_CONSTANT) {\n                    result[0] = standardLibrary.getBooleanType();\n                } else if (elementType == JetNodeTypes.CHARACTER_CONSTANT) {\n                    result[0] = standardLibrary.getCharType();\n                } else if (elementType == JetNodeTypes.STRING_CONSTANT) {\n                    result[0] = standardLibrary.getStringType();\n                } else if (elementType == JetNodeTypes.NULL) {\n                    result[0] = JetStandardClasses.getNullableNothingType();\n                } else {\n                    throw new IllegalArgumentException(\"Unsupported constant: \" + expression);\n                }\n            }\n\n            @Override\n            public void visitThrowExpression(JetThrowExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitReturnExpression(JetReturnExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitBreakExpression(JetBreakExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitContinueExpression(JetContinueExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitTypeofExpression(JetTypeofExpression expression) {\n                throw new UnsupportedOperationException(\"Return some reflection interface\"); // TODO\n            }\n\n            @Override\n            public void visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression) {\n                if (expression.getOperationSign() == JetTokens.COLON) {\n                    Type actualType = getType(scope, expression.getLeft(), false);\n                    Type expectedType = typeResolver.resolveType(scope, expression.getRight());\n                    if (JetTypeChecker.INSTANCE.isSubtypeOf(actualType, expectedType)) {\n                        result[0] = expectedType;\n                        return;\n                    } else {\n                         // TODO\n                        throw new UnsupportedOperationException(\"Type mismatch: expected \" + expectedType + \" but found \" + actualType);\n                    }\n                }\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitIfExpression(JetIfExpression expression) {\n                // TODO : check condition type\n                // TODO : change types according to is and nullability checks\n                JetExpression elseBranch = expression.getElse();\n                if (elseBranch == null) {\n                    // TODO : type-check the branch\n                    result[0] = JetStandardClasses.getUnitType();\n                } else {\n                    Type thenType = getType(scope, expression.getThen(), true);\n                    Type elseType = getType(scope, elseBranch, true);\n                    result[0] = JetTypeChecker.INSTANCE.commonSupertype(Arrays.asList(thenType, elseType));\n                }\n            }\n\n            @Override\n            public void visitWhenExpression(JetWhenExpression expression) {\n                // TODO :change scope according to the bound value in the when header\n                List<Type> expressions = new ArrayList<Type>();\n                collectAllReturnTypes(expression, scope, expressions);\n                result[0] = JetTypeChecker.INSTANCE.commonSupertype(expressions);\n            }\n\n            @Override\n            public void visitTryExpression(JetTryExpression expression) {\n                JetExpression tryBlock = expression.getTryBlock();\n                List<JetCatchClause> catchClauses = expression.getCatchClauses();\n                JetFinallySection finallyBlock = expression.getFinallyBlock();\n                List<Type> types = new ArrayList<Type>();\n                if (finallyBlock == null) {\n                    for (JetCatchClause catchClause : catchClauses) {\n                        // TODO: change scope here\n                        types.add(getType(scope, catchClause.getCatchBody(), true));\n                    }\n                } else {\n                    types.add(getType(scope, finallyBlock.getFinalExpression(), true));\n                }\n                types.add(getType(scope, tryBlock, true));\n                result[0] = JetTypeChecker.INSTANCE.commonSupertype(types);\n            }\n\n            @Override\n            public void visitTupleExpression(JetTupleExpression expression) {\n                List<JetExpression> entries = expression.getEntries();\n                List<Type> types = new ArrayList<Type>();\n                for (JetExpression entry : entries) {\n                    types.add(getType(scope, entry, false));\n                }\n                // TODO : labels\n                result[0] = JetStandardClasses.getTupleType(types);\n            }\n\n            @Override\n            public void visitThisExpression(JetThisExpression expression) {\n                // TODO : qualified this, e.g. Foo.this<Bar>\n                Type thisType = scope.getThisType();\n                JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();\n                if (superTypeQualifier != null) {\n                    // This cast must be safe (assuming the PSI doesn't contain errors)\n                    JetUserType typeElement = (JetUserType) superTypeQualifier.getTypeElement();\n                    ClassDescriptor superclass = typeResolver.resolveClass(scope, typeElement);\n                    Collection<? extends Type> supertypes = thisType.getConstructor().getSupertypes();\n                    Map<TypeConstructor, TypeProjection> substitutionContext = TypeSubstitutor.INSTANCE.getSubstitutionContext(thisType);\n                    for (Type declaredSupertype : supertypes) {\n                        if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {\n                            result[0] = TypeSubstitutor.INSTANCE.substitute(substitutionContext, declaredSupertype, Variance.INVARIANT);\n                            break;\n                        }\n                    }\n                    assert result[0] != null;\n                } else {\n                    result[0] = thisType;\n                }\n            }\n\n            @Override\n            public void visitBlockExpression(JetBlockExpression expression) {\n                result[0] = getBlockReturnedType(scope, expression.getStatements());\n            }\n\n            @Override\n            public void visitLoopExpression(JetLoopExpression expression) {\n                result[0] = JetStandardClasses.getUnitType();\n            }\n\n            @Override\n            public void visitNewExpression(JetNewExpression expression) {\n                // TODO : type argument inference\n                JetTypeReference typeReference = expression.getTypeReference();\n                result[0] = typeResolver.resolveType(scope, typeReference);\n            }\n\n            @Override\n            public void visitDotQualifiedExpression(JetDotQualifiedExpression expression) {\n                // TODO : functions\n                JetExpression receiverExpression = expression.getReceiverExpression();\n                JetExpression selectorExpression = expression.getSelectorExpression();\n                Type receiverType = getType(scope, receiverExpression, false);\n                if (receiverType != null) { // TODO : review\n                    JetScope compositeScope = new ScopeWithReceiver(scope, receiverType);\n                    result[0] = getType(compositeScope, selectorExpression, false);\n                }\n            }\n\n            @Override\n            public void visitCallExpression(JetCallExpression expression) {\n                JetExpression calleeExpression = expression.getCalleeExpression();\n\n                // 1) ends with a name -> (scope, name) to look up\n                // 2) ends with something else -> just check types\n\n                // TODO : check somewhere that these are NOT projections\n                List<JetTypeProjection> typeArguments = expression.getTypeArguments();\n\n                List<JetArgument> valueArguments = expression.getValueArguments();\n                boolean someNamed = false;\n                for (JetArgument argument : valueArguments) {\n                    if (argument.isNamed()) {\n                        someNamed = true;\n                        break;\n                    }\n                }\n                List<JetExpression> functionLiteralArguments = expression.getFunctionLiteralArguments();\n\n//                JetExpression functionLiteralArgument = functionLiteralArguments.isEmpty() ? null : functionLiteralArguments.get(0);\n                // TODO : must be a check\n                assert functionLiteralArguments.size() <= 1;\n\n                OverloadDomain overloadDomain = getOverloadDomain(scope, calleeExpression);\n                if (someNamed) {\n                    // TODO : check that all are named\n                    throw new UnsupportedOperationException(); // TODO\n\n//                    result[0] = overloadDomain.getFunctionDescriptorForNamedArguments(typeArguments, valueArguments, functionLiteralArgument);\n                } else {\n                    List<JetExpression> positionedValueArguments = new ArrayList<JetExpression>();\n                    for (JetArgument argument : valueArguments) {\n                        positionedValueArguments.add(argument.getArgumentExpression());\n                    }\n\n                    positionedValueArguments.addAll(functionLiteralArguments);\n\n                    List<Type> types = new ArrayList<Type>();\n                    for (JetTypeProjection projection : typeArguments) {\n                        // TODO : check that there's no projection\n                        types.add(typeResolver.resolveType(scope, projection.getTypeReference()));\n                    }\n\n                    List<Type> valueArgumentTypes = new ArrayList<Type>();\n                    for (JetExpression valueArgument : positionedValueArguments) {\n                        valueArgumentTypes.add(getType(scope, valueArgument, false));\n                    }\n\n                    FunctionDescriptor functionDescriptor = overloadDomain.getFunctionDescriptorForPositionedArguments(types, valueArgumentTypes);\n                    if (functionDescriptor != null) {\n                        result[0] = functionDescriptor.getUnsubstitutedReturnType();\n                    }\n                }\n            }\n\n            @Override\n            public void visitJetElement(JetElement elem) {\n                throw new IllegalArgumentException(\"Unsupported element: \" + elem);\n            }\n        });\n        if (result[0] != null) {\n            trace.recordExpressionType(expression, result[0]);\n        }\n        return result[0];\n    }","id":51565,"modified_method":"@Nullable\n    public Type getType(@NotNull final JetScope scope, @NotNull JetExpression expression, final boolean preferBlock) {\n        final Type[] result = new Type[1];\n        expression.accept(new JetVisitor() {\n            @Override\n            public void visitReferenceExpression(JetReferenceExpression expression) {\n                // TODO : other members\n                // TODO : type substitutions???\n                String referencedName = expression.getReferencedName();\n                PropertyDescriptor property = scope.getProperty(referencedName);\n                if (property != null) {\n                    trace.recordReferenceResolution(expression, property);\n                    result[0] = property.getType();\n                    return;\n                } else {\n                    NamespaceDescriptor namespace = scope.getNamespace(referencedName);\n                    if (namespace != null) {\n                        trace.recordReferenceResolution(expression, namespace);\n                        result[0] = namespace.getNamespaceType();\n                        return;\n                    }\n                }\n                semanticServices.getErrorHandler().unresolvedReference(expression);\n            }\n\n            @Override\n            public void visitFunctionLiteralExpression(JetFunctionLiteralExpression expression) {\n                if (preferBlock && !expression.hasParameterSpecification()) {\n                    result[0] = getBlockReturnedType(scope, expression.getBody());\n                    return;\n                }\n\n                JetTypeReference returnTypeRef = expression.getReturnTypeRef();\n\n                JetTypeReference receiverTypeRef = expression.getReceiverTypeRef();\n                final Type receiverType;\n                if (receiverTypeRef != null) {\n                    receiverType = typeResolver.resolveType(scope, receiverTypeRef);\n                } else {\n                    receiverType = scope.getThisType();\n                }\n\n                List<JetElement> body = expression.getBody();\n                final Map<String, PropertyDescriptor> parameterDescriptors = new HashMap<String, PropertyDescriptor>();\n                List<Type> parameterTypes = new ArrayList<Type>();\n                for (JetParameter parameter : expression.getParameters()) {\n                    JetTypeReference typeReference = parameter.getTypeReference();\n                    if (typeReference == null) {\n                        throw new UnsupportedOperationException(\"Type inference for parameters is not implemented yet\");\n                    }\n                    PropertyDescriptor propertyDescriptor = classDescriptorResolver.resolvePropertyDescriptor(scope, parameter);\n                    parameterDescriptors.put(parameter.getName(), propertyDescriptor);\n                    parameterTypes.add(propertyDescriptor.getType());\n                }\n                Type returnType;\n                if (returnTypeRef != null) {\n                    returnType = typeResolver.resolveType(scope, returnTypeRef);\n                } else {\n                    WritableScope writableScope = new WritableScope(scope);\n                    for (PropertyDescriptor propertyDescriptor : parameterDescriptors.values()) {\n                        writableScope.addPropertyDescriptor(propertyDescriptor);\n                    }\n                    writableScope.setThisType(receiverType);\n                    returnType = getBlockReturnedType(writableScope, body);\n                }\n                result[0] = JetStandardClasses.getFunctionType(null, receiverTypeRef == null ? null : receiverType, parameterTypes, returnType);\n            }\n\n            @Override\n            public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n                result[0] = getType(scope, expression.getExpression(), false);\n            }\n\n            @Override\n            public void visitConstantExpression(JetConstantExpression expression) {\n                IElementType elementType = expression.getNode().getElementType();\n                JetStandardLibrary standardLibrary = semanticServices.getStandardLibrary();\n                if (elementType == JetNodeTypes.INTEGER_CONSTANT) {\n                    result[0] = standardLibrary.getIntType();\n                } else if (elementType == JetNodeTypes.LONG_CONSTANT) {\n                    result[0] = standardLibrary.getLongType();\n                } else if (elementType == JetNodeTypes.FLOAT_CONSTANT) {\n                    String text = expression.getText();\n                    assert text.length() > 0;\n                    char lastChar = text.charAt(text.length() - 1);\n                    if (lastChar == 'f' || lastChar == 'F') {\n                        result[0] = standardLibrary.getFloatType();\n                    } else {\n                        result[0] = standardLibrary.getDoubleType();\n                    }\n                } else if (elementType == JetNodeTypes.BOOLEAN_CONSTANT) {\n                    result[0] = standardLibrary.getBooleanType();\n                } else if (elementType == JetNodeTypes.CHARACTER_CONSTANT) {\n                    result[0] = standardLibrary.getCharType();\n                } else if (elementType == JetNodeTypes.STRING_CONSTANT) {\n                    result[0] = standardLibrary.getStringType();\n                } else if (elementType == JetNodeTypes.NULL) {\n                    result[0] = JetStandardClasses.getNullableNothingType();\n                } else {\n                    throw new IllegalArgumentException(\"Unsupported constant: \" + expression);\n                }\n            }\n\n            @Override\n            public void visitThrowExpression(JetThrowExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitReturnExpression(JetReturnExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitBreakExpression(JetBreakExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitContinueExpression(JetContinueExpression expression) {\n                result[0] = JetStandardClasses.getNothingType();\n            }\n\n            @Override\n            public void visitTypeofExpression(JetTypeofExpression expression) {\n                throw new UnsupportedOperationException(\"Return some reflection interface\"); // TODO\n            }\n\n            @Override\n            public void visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression) {\n                if (expression.getOperationReference().getReferencedNameElementType() == JetTokens.COLON) {\n                    Type actualType = getType(scope, expression.getLeft(), false);\n                    Type expectedType = typeResolver.resolveType(scope, expression.getRight());\n                    if (JetTypeChecker.INSTANCE.isSubtypeOf(actualType, expectedType)) {\n                        result[0] = expectedType;\n                        return;\n                    } else {\n                         // TODO\n                        throw new UnsupportedOperationException(\"Type mismatch: expected \" + expectedType + \" but found \" + actualType);\n                    }\n                }\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitIfExpression(JetIfExpression expression) {\n                // TODO : check condition type\n                // TODO : change types according to is and nullability checks\n                JetExpression elseBranch = expression.getElse();\n                if (elseBranch == null) {\n                    // TODO : type-check the branch\n                    result[0] = JetStandardClasses.getUnitType();\n                } else {\n                    Type thenType = getType(scope, expression.getThen(), true);\n                    Type elseType = getType(scope, elseBranch, true);\n                    result[0] = JetTypeChecker.INSTANCE.commonSupertype(Arrays.asList(thenType, elseType));\n                }\n            }\n\n            @Override\n            public void visitWhenExpression(JetWhenExpression expression) {\n                // TODO :change scope according to the bound value in the when header\n                List<Type> expressions = new ArrayList<Type>();\n                collectAllReturnTypes(expression, scope, expressions);\n                result[0] = JetTypeChecker.INSTANCE.commonSupertype(expressions);\n            }\n\n            @Override\n            public void visitTryExpression(JetTryExpression expression) {\n                JetExpression tryBlock = expression.getTryBlock();\n                List<JetCatchClause> catchClauses = expression.getCatchClauses();\n                JetFinallySection finallyBlock = expression.getFinallyBlock();\n                List<Type> types = new ArrayList<Type>();\n                if (finallyBlock == null) {\n                    for (JetCatchClause catchClause : catchClauses) {\n                        // TODO: change scope here\n                        types.add(getType(scope, catchClause.getCatchBody(), true));\n                    }\n                } else {\n                    types.add(getType(scope, finallyBlock.getFinalExpression(), true));\n                }\n                types.add(getType(scope, tryBlock, true));\n                result[0] = JetTypeChecker.INSTANCE.commonSupertype(types);\n            }\n\n            @Override\n            public void visitTupleExpression(JetTupleExpression expression) {\n                List<JetExpression> entries = expression.getEntries();\n                List<Type> types = new ArrayList<Type>();\n                for (JetExpression entry : entries) {\n                    types.add(getType(scope, entry, false));\n                }\n                // TODO : labels\n                result[0] = JetStandardClasses.getTupleType(types);\n            }\n\n            @Override\n            public void visitThisExpression(JetThisExpression expression) {\n                // TODO : qualified this, e.g. Foo.this<Bar>\n                Type thisType = scope.getThisType();\n                JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();\n                if (superTypeQualifier != null) {\n                    // This cast must be safe (assuming the PSI doesn't contain errors)\n                    JetUserType typeElement = (JetUserType) superTypeQualifier.getTypeElement();\n                    ClassDescriptor superclass = typeResolver.resolveClass(scope, typeElement);\n                    Collection<? extends Type> supertypes = thisType.getConstructor().getSupertypes();\n                    Map<TypeConstructor, TypeProjection> substitutionContext = TypeSubstitutor.INSTANCE.getSubstitutionContext(thisType);\n                    for (Type declaredSupertype : supertypes) {\n                        if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {\n                            result[0] = TypeSubstitutor.INSTANCE.substitute(substitutionContext, declaredSupertype, Variance.INVARIANT);\n                            break;\n                        }\n                    }\n                    assert result[0] != null;\n                } else {\n                    result[0] = thisType;\n                }\n            }\n\n            @Override\n            public void visitBlockExpression(JetBlockExpression expression) {\n                result[0] = getBlockReturnedType(scope, expression.getStatements());\n            }\n\n            @Override\n            public void visitLoopExpression(JetLoopExpression expression) {\n                result[0] = JetStandardClasses.getUnitType();\n            }\n\n            @Override\n            public void visitNewExpression(JetNewExpression expression) {\n                // TODO : type argument inference\n                JetTypeReference typeReference = expression.getTypeReference();\n                result[0] = typeResolver.resolveType(scope, typeReference);\n            }\n\n            @Override\n            public void visitDotQualifiedExpression(JetDotQualifiedExpression expression) {\n                // TODO : functions\n                JetExpression receiverExpression = expression.getReceiverExpression();\n                JetExpression selectorExpression = expression.getSelectorExpression();\n                Type receiverType = getType(scope, receiverExpression, false);\n                if (receiverType != null) { // TODO : review\n                    JetScope compositeScope = new ScopeWithReceiver(scope, receiverType);\n                    result[0] = getType(compositeScope, selectorExpression, false);\n                }\n            }\n\n            @Override\n            public void visitCallExpression(JetCallExpression expression) {\n                JetExpression calleeExpression = expression.getCalleeExpression();\n\n                // 1) ends with a name -> (scope, name) to look up\n                // 2) ends with something else -> just check types\n\n                // TODO : check somewhere that these are NOT projections\n                List<JetTypeProjection> typeArguments = expression.getTypeArguments();\n\n                List<JetArgument> valueArguments = expression.getValueArguments();\n                boolean someNamed = false;\n                for (JetArgument argument : valueArguments) {\n                    if (argument.isNamed()) {\n                        someNamed = true;\n                        break;\n                    }\n                }\n                List<JetExpression> functionLiteralArguments = expression.getFunctionLiteralArguments();\n\n//                JetExpression functionLiteralArgument = functionLiteralArguments.isEmpty() ? null : functionLiteralArguments.get(0);\n                // TODO : must be a check\n                assert functionLiteralArguments.size() <= 1;\n\n                OverloadDomain overloadDomain = getOverloadDomain(scope, calleeExpression);\n                if (someNamed) {\n                    // TODO : check that all are named\n                    throw new UnsupportedOperationException(); // TODO\n\n//                    result[0] = overloadDomain.getFunctionDescriptorForNamedArguments(typeArguments, valueArguments, functionLiteralArgument);\n                } else {\n                    List<Type> types = new ArrayList<Type>();\n                    for (JetTypeProjection projection : typeArguments) {\n                        // TODO : check that there's no projection\n                        types.add(typeResolver.resolveType(scope, projection.getTypeReference()));\n                    }\n\n                    List<JetExpression> positionedValueArguments = new ArrayList<JetExpression>();\n                    for (JetArgument argument : valueArguments) {\n                        positionedValueArguments.add(argument.getArgumentExpression());\n                    }\n\n                    positionedValueArguments.addAll(functionLiteralArguments);\n\n                    List<Type> valueArgumentTypes = new ArrayList<Type>();\n                    for (JetExpression valueArgument : positionedValueArguments) {\n                        valueArgumentTypes.add(getType(scope, valueArgument, false));\n                    }\n\n                    FunctionDescriptor functionDescriptor = overloadDomain.getFunctionDescriptorForPositionedArguments(types, valueArgumentTypes);\n                    if (functionDescriptor != null) {\n                        result[0] = functionDescriptor.getUnsubstitutedReturnType();\n                    }\n                }\n            }\n\n            @Override\n            public void visitBinaryExpression(JetBinaryExpression expression) {\n                JetReferenceExpression operationSign = expression.getOperationReference();\n\n                IElementType operationType = operationSign.getReferencedNameElementType();\n                if (operationType == JetTokens.IDENTIFIER) {\n                    result[0] = getTypeForBinaryCall(expression, operationSign.getReferencedName(), scope);\n                }\n                else if (operationType == JetTokens.PLUS) {\n                    result[0] = getTypeForBinaryCall(expression, \"plus\", scope);\n                } else {\n                    throw new UnsupportedOperationException(); // TODO\n                }\n            }\n\n            @Override\n            public void visitJetElement(JetElement elem) {\n                throw new IllegalArgumentException(\"Unsupported element: \" + elem);\n            }\n\n            private Type getTypeForBinaryCall(JetBinaryExpression expression, String name, JetScope scope) {\n                JetReferenceExpression operationSign = expression.getOperationReference();\n                JetExpression left = expression.getLeft();\n                Type leftType = getType(scope, left, false);\n                JetExpression right = expression.getRight();\n                Type rightType = getType(scope, right, false);\n                OverloadDomain overloadDomain = OverloadResolver.INSTANCE.getOverloadDomain(leftType, scope, name);\n                overloadDomain = wrapForTracing(overloadDomain, operationSign);\n                FunctionDescriptor functionDescriptor = overloadDomain.getFunctionDescriptorForPositionedArguments(Collections.<Type>emptyList(), Collections.singletonList(rightType));\n                if (functionDescriptor != null) {\n                    return functionDescriptor.getUnsubstitutedReturnType();\n                }\n                return null;\n            }\n        });\n        if (result[0] != null) {\n            trace.recordExpressionType(expression, result[0]);\n        }\n        return result[0];\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private OverloadDomain getOverloadDomain(final JetScope scope, JetExpression calleeExpression) {\n        final OverloadDomain[] result = new OverloadDomain[1];\n        final JetReferenceExpression[] reference = new JetReferenceExpression[1];\n        calleeExpression.accept(new JetVisitor() {\n\n            @Override\n            public void visitHashQualifiedExpression(JetHashQualifiedExpression expression) {\n                // a#b -- create a domain for all overloads of b in a\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitPredicateExpression(JetPredicateExpression expression) {\n                // overload lookup for checking, but the type is receiver's type + nullable\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitQualifiedExpression(JetQualifiedExpression expression) {\n                // . or ?.\n                JetExpression selectorExpression = expression.getSelectorExpression();\n                if (selectorExpression instanceof JetReferenceExpression) {\n                    JetReferenceExpression referenceExpression = (JetReferenceExpression) selectorExpression;\n\n                    Type receiverType = getType(scope, expression.getReceiverExpression(), false);\n                    if (receiverType != null) {\n                        result[0] = OverloadResolver.INSTANCE.getOverloadDomain(receiverType, scope, referenceExpression.getReferencedName());\n                        reference[0] = referenceExpression;\n                    }\n                } else {\n                    throw new UnsupportedOperationException(); // TODO\n                }\n            }\n\n            @Override\n            public void visitReferenceExpression(JetReferenceExpression expression) {\n                // a -- create a hierarchical lookup domain for this.a\n                result[0] = OverloadResolver.INSTANCE.getOverloadDomain(null, scope, expression.getReferencedName());\n                reference[0] = expression;\n            }\n\n            @Override\n            public void visitExpression(JetExpression expression) {\n                // <e> create a dummy domain for the type of e\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitJetElement(JetElement elem) {\n                throw new IllegalArgumentException(\"Unsupported element: \" + elem);\n            }\n        });\n        if (result[0] == null) return OverloadDomain.EMPTY;\n        return new OverloadDomain() {\n            @Override\n            public FunctionDescriptor getFunctionDescriptorForNamedArguments(@NotNull List<Type> typeArguments, @NotNull Map<String, Type> valueArgumentTypes, @Nullable Type functionLiteralArgumentType) {\n                FunctionDescriptor descriptor = result[0].getFunctionDescriptorForNamedArguments(typeArguments, valueArgumentTypes, functionLiteralArgumentType);\n                if (descriptor != null) {\n                    trace.recordReferenceResolution(reference[0], descriptor);\n                } else {\n                    semanticServices.getErrorHandler().unresolvedReference(reference[0]);\n                }\n                return descriptor;\n            }\n\n            @Override\n            public FunctionDescriptor getFunctionDescriptorForPositionedArguments(@NotNull List<Type> typeArguments, @NotNull List<Type> positionedValueArgumentTypes) {\n                FunctionDescriptor descriptor = result[0].getFunctionDescriptorForPositionedArguments(typeArguments, positionedValueArgumentTypes);\n                if (descriptor != null) {\n                    trace.recordReferenceResolution(reference[0], descriptor);\n                } else {\n                    semanticServices.getErrorHandler().unresolvedReference(reference[0]);\n                }\n                return descriptor;\n            }\n        };\n    }","id":51566,"modified_method":"private OverloadDomain getOverloadDomain(final JetScope scope, JetExpression calleeExpression) {\n        final OverloadDomain[] result = new OverloadDomain[1];\n        final JetReferenceExpression[] reference = new JetReferenceExpression[1];\n        calleeExpression.accept(new JetVisitor() {\n\n            @Override\n            public void visitHashQualifiedExpression(JetHashQualifiedExpression expression) {\n                // a#b -- create a domain for all overloads of b in a\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitPredicateExpression(JetPredicateExpression expression) {\n                // overload lookup for checking, but the type is receiver's type + nullable\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitQualifiedExpression(JetQualifiedExpression expression) {\n                // . or ?.\n                JetExpression selectorExpression = expression.getSelectorExpression();\n                if (selectorExpression instanceof JetReferenceExpression) {\n                    JetReferenceExpression referenceExpression = (JetReferenceExpression) selectorExpression;\n\n                    Type receiverType = getType(scope, expression.getReceiverExpression(), false);\n                    if (receiverType != null) {\n                        result[0] = OverloadResolver.INSTANCE.getOverloadDomain(receiverType, scope, referenceExpression.getReferencedName());\n                        reference[0] = referenceExpression;\n                    }\n                } else {\n                    throw new UnsupportedOperationException(); // TODO\n                }\n            }\n\n            @Override\n            public void visitReferenceExpression(JetReferenceExpression expression) {\n                // a -- create a hierarchical lookup domain for this.a\n                result[0] = OverloadResolver.INSTANCE.getOverloadDomain(null, scope, expression.getReferencedName());\n                reference[0] = expression;\n            }\n\n            @Override\n            public void visitExpression(JetExpression expression) {\n                // <e> create a dummy domain for the type of e\n                throw new UnsupportedOperationException(); // TODO\n            }\n\n            @Override\n            public void visitJetElement(JetElement elem) {\n                throw new IllegalArgumentException(\"Unsupported element: \" + elem);\n            }\n        });\n        return wrapForTracing(result[0], reference[0]);\n    }","commit_id":"82261a2c2e2dad1023a3163cdefddff563b8b481","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void writeCallExpression(JSCallExpression expression, PrimitiveAmfOutputStream out, BaseWriter writer,\n                                          ValueReferenceResolver valueReferenceResolver) throws InvalidPropertyException {\n    final JSReferenceExpression methodExpression = (JSReferenceExpression)expression.getMethodExpression();\n    final JSFunction function = (JSFunction)resolveReferenceExpression(methodExpression, true);\n    final JSExpression[] arguments;\n    final int rollbackPosition;\n    final int start;\n    if (function.isConstructor()) {\n      arguments = expression.getArguments();\n      final JSClass jsClass = (JSClass)function.getParent();\n      // text=\"{new String('newString')}\"\n      writer.newInstance(jsClass.getQualifiedName(), arguments.length, true);\n      rollbackPosition = out.allocateShort();\n      start = out.size();\n    }\n    else {\n      out.write(ExpressionMessageTypes.CALL);\n      rollbackPosition = out.allocateShort();\n      start = out.size();\n      // text=\"{resourceManager.getString('core', 'viewSource')}\"\n      JSReferenceExpression qualifier = (JSReferenceExpression)methodExpression.getQualifier();\n      while (qualifier != null) {\n        writer.classOrPropertyName(qualifier.getReferencedName());\n        qualifier = (JSReferenceExpression)qualifier.getQualifier();\n      }\n\n      out.write(0);\n\n      writer.classOrPropertyName(function.getName());\n\n      if (function.isGetProperty()) {\n        out.write(-1);\n        return;\n      }\n      else {\n        arguments = expression.getArguments();\n        out.write(arguments.length);\n      }\n    }\n\n    for (JSExpression argument : arguments) {\n      writeExpression(argument, out, writer, valueReferenceResolver);\n    }\n\n    out.putShort(out.size() - start, rollbackPosition);\n  }","id":51567,"modified_method":"private static void writeCallExpression(JSCallExpression expression, PrimitiveAmfOutputStream out, BaseWriter writer,\n                                          ValueReferenceResolver valueReferenceResolver) throws InvalidPropertyException {\n    final JSReferenceExpression methodExpression = (JSReferenceExpression)expression.getMethodExpression();\n    final PsiElement psiElement = resolveReferenceExpression(methodExpression, true);\n    final JSExpression[] arguments;\n    if (psiElement instanceof JSClass) {\n      // IDEA-74060, {Number('20')}\n      arguments = expression.getArguments();\n      assert arguments.length == 1;\n      writeExpression(arguments[0], out, writer, valueReferenceResolver);\n      return;\n    }\n\n    final JSFunction function = (JSFunction)psiElement;\n    final int rollbackPosition;\n    final int start;\n    if (function.isConstructor()) {\n      arguments = expression.getArguments();\n      final JSClass jsClass = (JSClass)function.getParent();\n      // text=\"{new String('newString')}\"\n      writer.newInstance(jsClass.getQualifiedName(), arguments.length, true);\n      rollbackPosition = out.allocateShort();\n      start = out.size();\n    }\n    else {\n      out.write(ExpressionMessageTypes.CALL);\n      rollbackPosition = out.allocateShort();\n      start = out.size();\n      // text=\"{resourceManager.getString('core', 'viewSource')}\"\n      JSReferenceExpression qualifier = (JSReferenceExpression)methodExpression.getQualifier();\n      while (qualifier != null) {\n        writer.classOrPropertyName(qualifier.getReferencedName());\n        qualifier = (JSReferenceExpression)qualifier.getQualifier();\n      }\n\n      out.write(0);\n\n      writer.classOrPropertyName(function.getName());\n\n      if (function.isGetProperty()) {\n        out.write(-1);\n        return;\n      }\n      else {\n        arguments = expression.getArguments();\n        out.write(arguments.length);\n      }\n    }\n\n    for (JSExpression argument : arguments) {\n      writeExpression(argument, out, writer, valueReferenceResolver);\n    }\n\n    out.putShort(out.size() - start, rollbackPosition);\n  }","commit_id":"7e29ff2932a5ebcb2788e05ea20c555650d926d4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public void visitCallExpression(JetCallExpression expression) {\n        JetExpression callee = expression.getCalleeExpression();\n\n        if (callee instanceof JetSimpleNameExpression) {\n            DeclarationDescriptor funDescriptor = bindingContext.resolveReferenceExpression((JetSimpleNameExpression) callee);\n            if (funDescriptor instanceof FunctionDescriptor) {\n                final DeclarationDescriptor functionParent = funDescriptor.getContainingDeclaration();\n                if (isNumberPrimitive(functionParent)) {\n                    if (funDescriptor.getName().equals(\"inv\")) {\n                        final StackValue value = myStack.pop();  // HACK we rely on the dot reference handler to put it on the stack\n                        final Type asmType = expressionType(expression);\n                        value.put(asmType, v);\n                        generateInv(asmType);\n                        return;\n                    }\n                }\n\n                ensureReceiverOnStack(expression);\n\n                PsiElement declarationPsiElement = bindingContext.getDeclarationPsiElement(funDescriptor);\n                Method methodDescriptor;\n                if (declarationPsiElement instanceof PsiMethod) {\n                    PsiMethod psiMethod = (PsiMethod) declarationPsiElement;\n                    methodDescriptor = getMethodDescriptor(psiMethod);\n                    pushMethodArguments(expression, methodDescriptor);\n\n                    final boolean isStatic = psiMethod.hasModifierProperty(PsiModifier.STATIC);\n                    v.visitMethodInsn(isStatic ? Opcodes.INVOKESTATIC : Opcodes.INVOKEVIRTUAL,\n                            JetTypeMapper.jvmName(psiMethod.getContainingClass()),\n                            methodDescriptor.getName(),\n                            methodDescriptor.getDescriptor());\n                }\n                else {\n                    if (functionParent instanceof NamespaceDescriptor && declarationPsiElement instanceof JetFunction) {\n                        methodDescriptor = typeMapper.mapSignature((JetFunction) declarationPsiElement);\n                        pushMethodArguments(expression, methodDescriptor);\n                        final String owner = NamespaceCodegen.getJVMClassName(DescriptorUtil.getFQName(functionParent));\n                        v.invokestatic(owner, methodDescriptor.getName(), methodDescriptor.getDescriptor());\n                    }\n                    else {\n                        throw new UnsupportedOperationException(\"don't know how to generate call to \" + declarationPsiElement);\n                    }\n                }\n                if (methodDescriptor.getReturnType() != Type.VOID_TYPE) {\n                    myStack.push(StackValue.onStack(methodDescriptor.getReturnType()));\n                }\n            }\n            else {\n                throw new CompilationException();\n            }\n        }\n        else {\n            throw new UnsupportedOperationException(\"Don't know how to generate a call\");\n        }\n    }","id":51568,"modified_method":"@Override\n    public void visitCallExpression(JetCallExpression expression) {\n        JetExpression callee = expression.getCalleeExpression();\n\n        if (callee instanceof JetSimpleNameExpression) {\n            DeclarationDescriptor funDescriptor = bindingContext.resolveReferenceExpression((JetSimpleNameExpression) callee);\n            if (funDescriptor instanceof FunctionDescriptor) {\n                final DeclarationDescriptor functionParent = funDescriptor.getContainingDeclaration();\n                if (isNumberPrimitive(functionParent)) {\n                    if (funDescriptor.getName().equals(\"inv\")) {\n                        final StackValue value = myStack.pop();  // HACK we rely on the dot reference handler to put it on the stack\n                        final Type asmType = expressionType(expression);\n                        value.put(asmType, v);\n                        generateInv(asmType);\n                        return;\n                    }\n                }\n\n                ensureReceiverOnStack(expression);\n\n                PsiElement declarationPsiElement = bindingContext.getDeclarationPsiElement(funDescriptor);\n                Method methodDescriptor;\n                if (declarationPsiElement instanceof PsiMethod) {\n                    PsiMethod psiMethod = (PsiMethod) declarationPsiElement;\n                    methodDescriptor = getMethodDescriptor(psiMethod);\n                    pushMethodArguments(expression, methodDescriptor);\n\n                    final boolean isStatic = psiMethod.hasModifierProperty(PsiModifier.STATIC);\n                    v.visitMethodInsn(isStatic ? Opcodes.INVOKESTATIC : Opcodes.INVOKEVIRTUAL,\n                            JetTypeMapper.jvmName(psiMethod.getContainingClass()),\n                            methodDescriptor.getName(),\n                            methodDescriptor.getDescriptor());\n                }\n                else {\n                    methodDescriptor = typeMapper.mapSignature((JetFunction) declarationPsiElement);\n                    pushMethodArguments(expression, methodDescriptor);\n                    if (functionParent instanceof NamespaceDescriptor && declarationPsiElement instanceof JetFunction) {\n                        final String owner = NamespaceCodegen.getJVMClassName(DescriptorUtil.getFQName(functionParent));\n                        v.invokestatic(owner, methodDescriptor.getName(), methodDescriptor.getDescriptor());\n                    }\n                    else if (functionParent instanceof ClassDescriptor && declarationPsiElement instanceof JetFunction) {\n                        final String owner = JetTypeMapper.jvmNameForInterface((ClassDescriptor) functionParent);\n                        v.invokeinterface(owner, methodDescriptor.getName(), methodDescriptor.getDescriptor());\n                    }\n                    else {\n                        throw new UnsupportedOperationException(\"don't know how to generate call to \" + declarationPsiElement);\n                    }\n                }\n                if (methodDescriptor.getReturnType() != Type.VOID_TYPE) {\n                    myStack.push(StackValue.onStack(methodDescriptor.getReturnType()));\n                }\n            }\n            else {\n                throw new CompilationException();\n            }\n        }\n        else {\n            throw new UnsupportedOperationException(\"Don't know how to generate a call\");\n        }\n    }","commit_id":"d19c1c165b1897b0c4ed3634a2fc544ed2ae4ad7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void visitNewExpression(JetNewExpression expression) {\n        final JetUserType constructorType = (JetUserType) expression.getTypeReference().getTypeElement();\n        final JetSimpleNameExpression constructorReference = constructorType.getReferenceExpression();\n        final PsiElement declaration = bindingContext.getDeclarationPsiElement(bindingContext.resolveReferenceExpression(constructorReference));\n        if (declaration instanceof PsiMethod) {\n            final PsiMethod constructor = (PsiMethod) declaration;\n            PsiClass javaClass = constructor.getContainingClass();\n            Type type = JetTypeMapper.psiClassType(javaClass);\n            v.anew(type);\n            v.dup();\n            final Method constructorDescriptor = getMethodDescriptor(constructor);\n            pushMethodArguments(expression, constructorDescriptor);\n            v.invokespecial(JetTypeMapper.jvmName(javaClass), \"<init>\", constructorDescriptor.getDescriptor());\n            myStack.push(StackValue.onStack(type));\n            return;\n        }\n\n        throw new UnsupportedOperationException(\"don't know how to generate this new expression\");\n    }","id":51569,"modified_method":"@Override\n    public void visitNewExpression(JetNewExpression expression) {\n        final JetUserType constructorType = (JetUserType) expression.getTypeReference().getTypeElement();\n        final JetSimpleNameExpression constructorReference = constructorType.getReferenceExpression();\n        DeclarationDescriptor constructorDescriptor = bindingContext.resolveReferenceExpression(constructorReference);\n        final PsiElement declaration = bindingContext.getDeclarationPsiElement(constructorDescriptor);\n        if (declaration instanceof PsiMethod) {\n            final PsiMethod constructor = (PsiMethod) declaration;\n            PsiClass javaClass = constructor.getContainingClass();\n            Type type = JetTypeMapper.psiClassType(javaClass);\n            v.anew(type);\n            v.dup();\n            final Method jvmConstructor = getMethodDescriptor(constructor);\n            pushMethodArguments(expression, jvmConstructor);\n            v.invokespecial(JetTypeMapper.jvmName(javaClass), \"<init>\", jvmConstructor.getDescriptor());\n            myStack.push(StackValue.onStack(type));\n            return;\n        }\n        else if (constructorDescriptor instanceof ConstructorDescriptor) {\n            ClassDescriptor classDecl = (ClassDescriptor) constructorDescriptor.getContainingDeclaration();\n            Type type = JetTypeMapper.jetImplementationType(classDecl);\n            v.anew(type);\n            v.dup();\n\n            Method method = typeMapper.mapConstructorSignature((ConstructorDescriptor) constructorDescriptor);\n            pushMethodArguments(expression, method);\n            v.invokespecial(JetTypeMapper.jvmNameForImplementation(classDecl), \"<init>\", method.getDescriptor());\n            myStack.push(StackValue.onStack(type));\n            return;\n        }\n\n        throw new UnsupportedOperationException(\"don't know how to generate this new expression\");\n    }","commit_id":"d19c1c165b1897b0c4ed3634a2fc544ed2ae4ad7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public void describeItems(LinkedHashMap<LookupElement, StringBuilder> map, ProcessingContext context) {\n    final THashSet<LookupElement> lifted = new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY);\n    liftShorterElements(new ArrayList<LookupElement>(map.keySet()), lifted, context);\n    if (!lifted.isEmpty()) {\n      for (LookupElement element : map.keySet()) {\n        final StringBuilder builder = map.get(element);\n        if (builder.length() > 0) {\n          builder.append(\", \");\n        }\n\n        builder.append(\"liftShorter=\").append(lifted.contains(element));\n      }\n    }\n    myNext.describeItems(map, context);\n  }","id":51570,"modified_method":"@Override\n  public void describeItems(LinkedHashMap<LookupElement, StringBuilder> map, ProcessingContext context) {\n    final THashSet<LookupElement> lifted = new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY);\n    CollectionFactory.arrayList(liftShorterElements(new ArrayList<LookupElement>(map.keySet()), lifted, context));\n    if (!lifted.isEmpty()) {\n      for (LookupElement element : map.keySet()) {\n        final StringBuilder builder = map.get(element);\n        if (builder.length() > 0) {\n          builder.append(\", \");\n        }\n\n        builder.append(\"liftShorter=\").append(lifted.contains(element));\n      }\n    }\n    myNext.describeItems(map, context);\n  }","commit_id":"1e520db69b79cc0b5c51d8f03285cf11d4ca3b68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<LookupElement> liftShorterElements(Iterable<LookupElement> source, THashSet<LookupElement> lifted, ProcessingContext context) {\n    final Set<LookupElement> srcSet = new THashSet<LookupElement>(source instanceof Collection ? ((Collection)source).size() : myCount, TObjectHashingStrategy.IDENTITY);\n    ContainerUtil.addAll(srcSet, source);\n    final Set<LookupElement> processed = new THashSet<LookupElement>(srcSet.size(), TObjectHashingStrategy.IDENTITY);\n\n    final Set<LookupElement[]> arraysProcessed = new THashSet<LookupElement[]>(myInterned.size(), TObjectHashingStrategy.IDENTITY);\n\n    boolean forSorting = context.get(CompletionLookupArranger.PURE_RELEVANCE) != Boolean.TRUE;\n    final List<LookupElement> result = new ArrayList<LookupElement>(srcSet.size());\n    for (LookupElement element : myNext.classify(source, context)) {\n      if (processed.add(element)) {\n        List<LookupElement> shorter = addShorterElements(srcSet, processed, arraysProcessed, null, myToLiftForPreselection.get(element));\n        if (forSorting) {\n          shorter = addShorterElements(srcSet, processed, arraysProcessed, shorter, myToLiftForSorting.get(element));\n        }\n        if (shorter != null) {\n          lifted.addAll(shorter);\n          ContainerUtil.addAll(result, myNext.classify(shorter, context));\n        }\n        result.add(element);\n      }\n    }\n    return result;\n  }","id":51571,"modified_method":"private Iterable<LookupElement> liftShorterElements(final Iterable<LookupElement> source,\n                                                      @Nullable final THashSet<LookupElement> lifted, final ProcessingContext context) {\n    final Set<LookupElement> srcSet = new THashSet<LookupElement>(source instanceof Collection ? ((Collection)source).size() : myCount, TObjectHashingStrategy.IDENTITY);\n    ContainerUtil.addAll(srcSet, source);\n    final Set<LookupElement> processed = new THashSet<LookupElement>(srcSet.size(), TObjectHashingStrategy.IDENTITY);\n\n    final Set<LookupElement[]> arraysProcessed = new THashSet<LookupElement[]>(myInterned.size(), TObjectHashingStrategy.IDENTITY);\n\n    final boolean forSorting = context.get(CompletionLookupArranger.PURE_RELEVANCE) != Boolean.TRUE;\n    final Iterable<LookupElement> next = myNext.classify(source, context);\n    return new Iterable<LookupElement>() {\n      @Override\n      public Iterator<LookupElement> iterator() {\n        Iterator<LookupElement> base = FilteringIterator.create(next.iterator(), new Condition<LookupElement>() {\n          @Override\n          public boolean value(LookupElement element) {\n            return processed.add(element);\n          }\n        });\n        return new FlatteningIterator<LookupElement, LookupElement>(base) {\n          @Override\n          protected Iterator<LookupElement> createValueIterator(LookupElement element) {\n            List<LookupElement> shorter = addShorterElements(srcSet, processed, arraysProcessed, null, myToLiftForPreselection.get(element));\n            if (forSorting) {\n              shorter = addShorterElements(srcSet, processed, arraysProcessed, shorter, myToLiftForSorting.get(element));\n            }\n            if (shorter != null) {\n              if (lifted != null) {\n                lifted.addAll(shorter);\n              }\n              return ContainerUtil.concat(myNext.classify(shorter, context), Collections.singletonList(element)).iterator();\n            }\n            return Collections.singletonList(element).iterator();\n          }\n        };\n      }\n    };\n  }","commit_id":"1e520db69b79cc0b5c51d8f03285cf11d4ca3b68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Iterable<LookupElement> classify(Iterable<LookupElement> source, ProcessingContext context) {\n    return liftShorterElements(source, new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY), context);\n  }","id":51572,"modified_method":"@Override\n  public Iterable<LookupElement> classify(Iterable<LookupElement> source, ProcessingContext context) {\n    return liftShorterElements(source, null, context);\n  }","commit_id":"1e520db69b79cc0b5c51d8f03285cf11d4ca3b68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract Iterable<List<T>> classify(List<T> source);","id":51573,"modified_method":"public abstract Iterable<T> classify(List<T> source);","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T> Classifier<T> listClassifier() {\n    return new Classifier<T>() {\n      @Override\n      public void addElement(T t) {\n      }\n\n      @Override\n      public Iterable<List<T>> classify(List<T> source) {\n        return Collections.singleton(source);\n      }\n\n      @Override\n      public void describeItems(LinkedHashMap<T, StringBuilder> map) {\n      }\n    };\n  }","id":51574,"modified_method":"public static <T> Classifier<T> listClassifier() {\n    return new Classifier<T>() {\n      @Override\n      public void addElement(T t) {\n      }\n\n      @Override\n      public Iterable<T> classify(List<T> source) {\n        return source;\n      }\n\n      @Override\n      public void describeItems(LinkedHashMap<T, StringBuilder> map) {\n      }\n    };\n  }","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Iterable<List<T>> classify(List<T> source) {\n    List<List<T>> result = new ArrayList<List<T>>();\n    for (List<T> list : groupByWeights(source).values()) {\n      ContainerUtil.addAll(result, myNext.classify(list));\n    }\n    return result;\n  }","id":51575,"modified_method":"@Override\n  public Iterable<T> classify(List<T> source) {\n    List<T> result = new ArrayList<T>();\n    for (List<T> list : groupByWeights(source).values()) {\n      ContainerUtil.addAll(result, myNext.classify(list));\n    }\n    return result;\n  }","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Pair<List<LookupElement>, Integer> arrangeItems(@NotNull Lookup lookup) {\n    List<LookupElement> items = matchingItems(lookup);\n    Collections.sort(items, new Comparator<LookupElement>() {\n      public int compare(LookupElement o1, LookupElement o2) {\n        //noinspection unchecked\n        return mySortingWeights.get(o1).compareTo(mySortingWeights.get(o2));\n      }\n    });\n\n    MultiMap<CompletionSorterImpl, LookupElement> inputBySorter = groupInputBySorter(items);\n\n    final List<LookupElement> byRelevance = new ArrayList<LookupElement>();\n    for (CompletionSorterImpl sorter : myClassifiers.keySet()) {\n      for (List<LookupElement> elements : myClassifiers.get(sorter).classify((List<LookupElement>)inputBySorter.get(sorter))) {\n        byRelevance.addAll(elements);\n      }\n    }\n\n    LinkedHashSet<LookupElement> model = new LinkedHashSet<LookupElement>();\n    addPrefixItems(lookup, model, true, byRelevance);\n    addPrefixItems(lookup, model, false, byRelevance);\n\n    myFrozenItems.retainAll(items);\n    model.addAll(myFrozenItems);\n\n    if (!isAlphaSorted()) {\n      for (int i = 0; i < byRelevance.size() && model.size() < MAX_PREFERRED_COUNT; i++) {\n        model.add(byRelevance.get(i));\n      }\n      LookupElement lastSelection = lookup.getCurrentItem();\n      if (items.contains(lastSelection)) {\n        model.add(lastSelection);\n      }\n    }\n\n    myFrozenItems.clear();\n\n    if (((LookupImpl)lookup).isShown()) {\n      myFrozenItems.addAll(model);\n    }\n\n    if (isAlphaSorted()) {\n      Collections.sort(items, new Comparator<LookupElement>() {\n        @Override\n        public int compare(LookupElement o1, LookupElement o2) {\n          return o1.getLookupString().compareToIgnoreCase(o2.getLookupString());\n        }\n      });\n      model.addAll(items);\n    } else  {\n      model.addAll(byRelevance);\n    }\n    ArrayList<LookupElement> listModel = new ArrayList<LookupElement>(model);\n\n    return new Pair<List<LookupElement>, Integer>(listModel, getItemToSelect(lookup, byRelevance, listModel));\n  }","id":51576,"modified_method":"@Override\n  public Pair<List<LookupElement>, Integer> arrangeItems(@NotNull Lookup lookup) {\n    List<LookupElement> items = matchingItems(lookup);\n    Collections.sort(items, new Comparator<LookupElement>() {\n      public int compare(LookupElement o1, LookupElement o2) {\n        //noinspection unchecked\n        return mySortingWeights.get(o1).compareTo(mySortingWeights.get(o2));\n      }\n    });\n\n    MultiMap<CompletionSorterImpl, LookupElement> inputBySorter = groupInputBySorter(items);\n\n    final List<LookupElement> byRelevance = new ArrayList<LookupElement>();\n    for (CompletionSorterImpl sorter : myClassifiers.keySet()) {\n      ContainerUtil.addAll(byRelevance, myClassifiers.get(sorter).classify((List<LookupElement>)inputBySorter.get(sorter)));\n    }\n\n    LinkedHashSet<LookupElement> model = new LinkedHashSet<LookupElement>();\n    addPrefixItems(lookup, model, true, byRelevance);\n    addPrefixItems(lookup, model, false, byRelevance);\n\n    myFrozenItems.retainAll(items);\n    model.addAll(myFrozenItems);\n\n    if (!isAlphaSorted()) {\n      for (int i = 0; i < byRelevance.size() && model.size() < MAX_PREFERRED_COUNT; i++) {\n        model.add(byRelevance.get(i));\n      }\n      LookupElement lastSelection = lookup.getCurrentItem();\n      if (items.contains(lastSelection)) {\n        model.add(lastSelection);\n      }\n    }\n\n    myFrozenItems.clear();\n\n    if (((LookupImpl)lookup).isShown()) {\n      myFrozenItems.addAll(model);\n    }\n\n    if (isAlphaSorted()) {\n      Collections.sort(items, new Comparator<LookupElement>() {\n        @Override\n        public int compare(LookupElement o1, LookupElement o2) {\n          return o1.getLookupString().compareToIgnoreCase(o2.getLookupString());\n        }\n      });\n      model.addAll(items);\n    } else  {\n      model.addAll(byRelevance);\n    }\n    ArrayList<LookupElement> listModel = new ArrayList<LookupElement>(model);\n\n    return new Pair<List<LookupElement>, Integer>(listModel, getItemToSelect(lookup, byRelevance, listModel));\n  }","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Iterable<List<LookupElement>> classify(List<LookupElement> source) {\n    return liftShorterElements(source, new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY));\n  }","id":51577,"modified_method":"@Override\n  public Iterable<LookupElement> classify(List<LookupElement> source) {\n    return liftShorterElements(source, new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY));\n  }","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Iterable<List<LookupElement>> liftShorterElements(List<LookupElement> source, THashSet<LookupElement> lifted) {\n    final Set<LookupElement> srcSet = new THashSet<LookupElement>(source, TObjectHashingStrategy.IDENTITY);\n    final Iterable<List<LookupElement>> classified = myNext.classify(source);\n    final Set<LookupElement> processed = new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY);\n\n    final ArrayList<List<LookupElement>> result = new ArrayList<List<LookupElement>>();\n    for (List<LookupElement> list : classified) {\n      final ArrayList<LookupElement> group = new ArrayList<LookupElement>();\n      for (LookupElement element : list) {\n        assert srcSet.contains(element) : myNext;\n        if (processed.add(element)) {\n          for (String prefix : getSortedPrefixes(element)) {\n            List<LookupElement> shorter = new SmartList<LookupElement>();\n            for (LookupElement shorterElement : myElements.get(prefix)) {\n              if (srcSet.contains(shorterElement) && processed.add(shorterElement)) {\n                shorter.add(shorterElement);\n              }\n            }\n\n            lifted.addAll(shorter);\n\n            final Iterable<List<LookupElement>> shorterClassified = myNext.classify(shorter);\n            if (group.isEmpty()) {\n              ContainerUtil.addAll(result, shorterClassified);\n            } else {\n              group.addAll(ContainerUtil.flatten(shorterClassified));\n            }\n\n          }\n\n          group.add(element);\n        }\n      }\n      result.add(group);\n    }\n    return result;\n  }","id":51578,"modified_method":"private List<LookupElement> liftShorterElements(List<LookupElement> source, THashSet<LookupElement> lifted) {\n    final Set<LookupElement> srcSet = new THashSet<LookupElement>(source, TObjectHashingStrategy.IDENTITY);\n    final Set<LookupElement> processed = new THashSet<LookupElement>(TObjectHashingStrategy.IDENTITY);\n\n    final List<LookupElement> result = new ArrayList<LookupElement>();\n    for (LookupElement element : myNext.classify(source)) {\n      assert srcSet.contains(element) : myNext;\n      if (processed.add(element)) {\n        for (String prefix : getSortedPrefixes(element)) {\n          List<LookupElement> shorter = new SmartList<LookupElement>();\n          for (LookupElement shorterElement : myElements.get(prefix)) {\n            if (srcSet.contains(shorterElement) && processed.add(shorterElement)) {\n              shorter.add(shorterElement);\n            }\n          }\n\n          lifted.addAll(shorter);\n\n          ContainerUtil.addAll(result, myNext.classify(shorter));\n        }\n        result.add(element);\n      }\n    }\n    return result;\n  }","commit_id":"52c8ed922d0b938c19b31037caa9a2605160a782","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public synchronized void received(String streamName, long dataSize) {\n    AtomicLong value = streamSizes.get(streamName);\n    if (value == null) {\n      value = streamSizes.putIfAbsent(streamName, new AtomicLong(dataSize));\n      if (value != null) {\n        // This is the first time that we've seen this stream, we subscribe to generation changes\n        truncationSubscriptions.add(streamCoordinatorClient.addListener(streamName, new StreamPropertyListener() {\n          @Override\n          public void generationChanged(String streamName, int generation) {\n            // Handle stream truncation by resetting the size aggregated so far\n            streamSizes.replace(streamName, new AtomicLong(0));\n          }\n        }));\n      }\n    }\n    if (value != null) {\n      value.addAndGet(dataSize);\n    }\n  }","id":51579,"modified_method":"@Override\n  public synchronized void received(String streamName, long dataSize) {\n    AtomicLong value = streamSizes.get(streamName);\n    if (value == null) {\n      value = streamSizes.putIfAbsent(streamName, new AtomicLong(dataSize));\n      if (value == null) {\n        // This is the first time that we've seen this stream, we subscribe to generation changes to track truncation\n        truncationSubscriptions.add(streamCoordinatorClient.addListener(streamName, new StreamPropertyListener() {\n          @Override\n          public void generationChanged(String streamName, int generation) {\n            // Handle stream truncation by resetting the size aggregated so far\n            streamSizes.replace(streamName, new AtomicLong(0));\n          }\n        }));\n      }\n    }\n    if (value != null) {\n      value.addAndGet(dataSize);\n    }\n  }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"protected StreamSizeAggregator(String streamName, long baseCount) {\n      this.streamWriterSizes = Maps.newHashMap();\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n\n      this.truncationSubscription = getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          reset();\n        }\n      });\n    }","id":51580,"modified_method":"protected StreamSizeAggregator(String streamName, long baseCount) {\n      this.streamWriterSizes = Maps.newHashMap();\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n    }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Perform aggregation on the Streams described by the {@code streamNames}, and no other Streams.\n   * If aggregation was previously done on other Streams, those must be cancelled.\n   *\n   * @param streamNames names of the streams to perform data sizes aggregation on\n   */\n  private void aggregate(Set<String> streamNames) {\n    Set<String> existingAggregators = Sets.newHashSet(aggregators.keySet());\n    for (String streamName : streamNames) {\n      if (existingAggregators.remove(streamName)) {\n        continue;\n      }\n\n      long filesSize = 0;\n      try {\n        StreamConfig config = streamAdmin.getConfig(streamName);\n        filesSize = StreamUtils.fetchStreamFilesSize(config);\n      } catch (IOException e) {\n        LOG.error(\"Could not compute sizes of files for stream {}\", streamName);\n      }\n\n      StreamSizeAggregator streamSizeAggregator = new StreamSizeAggregator(streamName, filesSize);\n      aggregators.put(streamName, streamSizeAggregator);\n    }\n\n    // Stop aggregating the heartbeats we used to listen to before the call to that method,\n    // but don't anymore\n    for (String outdatedStream : existingAggregators) {\n      StreamSizeAggregator aggregator = aggregators.remove(outdatedStream);\n      aggregator.cancel();\n    }\n  }","id":51581,"modified_method":"/**\n   * Perform aggregation on the Streams described by the {@code streamNames}, and no other Streams.\n   * If aggregation was previously done on other Streams, those must be cancelled.\n   *\n   * @param streamNames names of the streams to perform data sizes aggregation on\n   */\n  private void aggregate(Set<String> streamNames) {\n    Set<String> existingAggregators = Sets.newHashSet(aggregators.keySet());\n    for (String streamName : streamNames) {\n      if (existingAggregators.remove(streamName)) {\n        continue;\n      }\n\n      long filesSize = 0;\n      try {\n        StreamConfig config = streamAdmin.getConfig(streamName);\n        filesSize = StreamUtils.fetchStreamFilesSize(config);\n      } catch (IOException e) {\n        LOG.error(\"Could not compute sizes of files for stream {}\", streamName);\n      }\n      createSizeAggregator(streamName, filesSize);\n    }\n\n    // Stop aggregating the heartbeats we used to listen to before the call to that method,\n    // but don't anymore\n    for (String outdatedStream : existingAggregators) {\n      StreamSizeAggregator aggregator = aggregators.remove(outdatedStream);\n      if (aggregator != null) {\n        aggregator.cancel();\n      }\n    }\n  }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void doShutdown() throws Exception {\n    for (Aggregator aggregator : aggregators.values()) {\n      aggregator.cancel();\n    }\n  }","id":51582,"modified_method":"@Override\n  protected void doShutdown() throws Exception {\n    for (StreamSizeAggregator streamSizeAggregator : aggregators.values()) {\n      streamSizeAggregator.cancel();\n    }\n  }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      aggregators.put(streamSpec.getName(), new Aggregator(streamSpec.getName(), filesSize));\n    }\n  }","id":51583,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize);\n    }\n  }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      Aggregator aggregator = aggregators.get(streamSpec.getName());\n      if (aggregator == null) {\n        // First time that we see this Stream here\n        aggregator = new Aggregator(streamSpec.getName(), 0);\n        aggregators.put(streamSpec.getName(), aggregator);\n      }\n      aggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","id":51584,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0);\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","commit_id":"75797d1d08393da3a74feda53977da7a20d346f8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      aggregators.put(streamSpec.getName(), new Aggregator(streamSpec.getName(), filesSize));\n    }\n  }","id":51585,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize, config.getNotificationThresholdMB());\n    }\n  }","commit_id":"816a6aaef5c25e8eb712a261d5717040dca22f03","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public LocalStreamService(CConfiguration cConf,\n                            StreamCoordinatorClient streamCoordinatorClient,\n                            StreamFileJanitorService janitorService,\n                            StreamMetaStore streamMetaStore,\n                            StreamAdmin streamAdmin,\n                            StreamWriterSizeCollector streamWriterSizeCollector,\n                            NotificationService notificationService) {\n    super(streamCoordinatorClient, janitorService);\n    this.cConf = cConf;\n    this.streamAdmin = streamAdmin;\n    this.streamMetaStore = streamMetaStore;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.notificationService = notificationService;\n    this.aggregators = Maps.newConcurrentMap();\n    this.isInit = true;\n  }","id":51586,"modified_method":"@Inject\n  public LocalStreamService(StreamCoordinatorClient streamCoordinatorClient,\n                            StreamFileJanitorService janitorService,\n                            StreamMetaStore streamMetaStore,\n                            StreamAdmin streamAdmin,\n                            StreamWriterSizeCollector streamWriterSizeCollector,\n                            NotificationService notificationService) {\n    super(streamCoordinatorClient, janitorService);\n    this.streamAdmin = streamAdmin;\n    this.streamMetaStore = streamMetaStore;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.notificationService = notificationService;\n    this.aggregators = Maps.newConcurrentMap();\n    this.isInit = true;\n  }","commit_id":"816a6aaef5c25e8eb712a261d5717040dca22f03","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      Aggregator aggregator = aggregators.get(streamSpec.getName());\n      if (aggregator == null) {\n        // First time that we see this Stream here\n        aggregator = new Aggregator(streamSpec.getName(), 0);\n        aggregators.put(streamSpec.getName(), aggregator);\n      }\n      aggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","id":51587,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0, config.getNotificationThresholdMB());\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","commit_id":"816a6aaef5c25e8eb712a261d5717040dca22f03","url":"https://github.com/caskdata/cdap"},{"original_method":"public void writeContent(OutputStream procOS, File file) throws IOException {\r\n\t    // this writes the input stream to either another output stream or\r\n\t    // a file or both.\r\n\t    FileOutputStream bufferOS = null;\r\n\t    if (file != null) bufferOS = new FileOutputStream(file);\r\n\t    writeContentX(procOS, bufferOS, httpc.this.clientInput);\r\n\t    if (bufferOS != null) {\r\n\t\tbufferOS.close();\r\n\t\tif (file.length() == 0) file.delete();\r\n\t    }\r\n\t}","id":51588,"modified_method":"public void writeContent(OutputStream procOS, File file) throws IOException {\r\n\t    // this writes the input stream to either another output stream or\r\n\t    // a file or both.\r\n\t    FileOutputStream bufferOS = null;\r\n        try {        \r\n\t\t    if (file != null) bufferOS = new FileOutputStream(file);\r\n\t\t    writeContentX(procOS, bufferOS, httpc.this.clientInput);\r\n        } finally {\r\n\t\t    if (bufferOS != null) {\r\n\t\t\t\tbufferOS.close();\r\n\t\t\t\tif (file.length() == 0) file.delete();\r\n\t\t    }\r\n        }\r\n\t}","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void close() {\r\n\t// closes the connection\r\n\ttry {\r\n\t    clientInput.close();\r\n\t    clientOutput.close();\r\n\t    socket.close();\r\n\t} catch (IOException e) {}\r\n    }","id":51589,"modified_method":"public void close() {\r\n\t\t// closes the connection\r\n\t\ttry {\r\n\t\t    this.clientInput.close();\r\n\t\t    this.clientOutput.close();\r\n\t\t    this.socket.close();\r\n\t\t} catch (IOException e) {}\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, PushbackInputStream body) throws IOException {\r\n\r\n\tString userAgent = (String) requestHeader.get(\"USER-AGENT\");\r\n\tif (userAgent == null) userAgent = \"\";\r\n\tuserAgent = userAgent.trim().toLowerCase();\r\n\t//userAgent = \"portalmmm n400i\"; // debug\r\n\t//boolean iMode = (userAgent.startsWith(\"portalmmm\"));\r\n\t//if (iMode) System.out.println(\"DETECTED IMODE\");\r\n\r\n\t//System.out.println(\"HTTPD-REQUEST FROM CLIENT: \" + userAgent); // DEBUG\r\n\r\n\t// prepare response\r\n\tString method = conProp.getProperty(\"METHOD\");\r\n\tString path = conProp.getProperty(\"PATH\");\r\n\tString argsString = conProp.getProperty(\"ARGS\"); // is null if no args were given\r\n\r\n\t// check hack attacks in path\r\n\tif (path.indexOf(\"..\") >= 0) {\r\n\t    out.write((\"HTTP/1.0 403 bad path\\r\\n\").getBytes());\r\n\t    out.write((\"\\r\\n\").getBytes());\r\n\t    out.flush();\r\n\t    return;\r\n\t}\r\n\r\n        // check permission/granted access\r\n        if ((path.endsWith(\"_p.html\")) &&\r\n            ((adminAccountBase64MD5 = switchboard.getConfig(\"adminAccountBase64MD5\", \"\")).length() != 0)) {\r\n            // authentication required\r\n            String auth = (String) requestHeader.get(\"Authorization\");\r\n            if (auth == null) {\r\n                // no authorization given in response. Ask for that\r\n                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                out.write((\"WWW-Authenticate: Basic realm=\\\"admin log-in\\\"\\r\\n\").getBytes());\r\n                out.write((\"\\r\\n\").getBytes());\r\n                out.flush();\r\n                return;\r\n            } else if (adminAccountBase64MD5.equals(serverCodings.standardCoder.encodeMD5Hex(auth.trim().substring(6)))) {\r\n\t\t// remove brute-force flag\r\n\t\tserverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n\t    } else {\r\n                // a wrong authentication was given. Ask again\r\n                String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                //try {Thread.currentThread().sleep(3000);} catch (InterruptedException e) {} // add a delay to make brute-force harder\r\n\t\tserverCore.bfHost.put(clientIP, \"sleep\");\r\n                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                out.write((\"WWW-Authenticate: Basic realm=\\\"admin log-in\\\"\\r\\n\").getBytes());\r\n                out.write((\"\\r\\n\").getBytes());\r\n                out.flush();\r\n                //System.out.println(\"httpd bfHosts=\" + serverCore.bfHost.toString());\r\n                return;\r\n            }\r\n\t}\r\n\r\n\t// parse arguments\r\n\tserverObjects args = new serverObjects();\r\n\tint argc;\r\n\tif (argsString == null) {\r\n\t    // no args here, maybe a POST with multipart extension\r\n\t    int length;\r\n\t    //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n\t    if ((method.equals(\"POST\")) &&\r\n\t\t(requestHeader.containsKey(\"CONTENT-LENGTH\"))) {\r\n\t\t// if its a POST, it can be either multipart or as args in the body\r\n\t\tlength = Integer.parseInt((String) requestHeader.get(\"CONTENT-LENGTH\"));\r\n\t\tif ((requestHeader.containsKey(\"CONTENT-TYPE\")) &&\r\n\t\t    (((String) requestHeader.get(\"CONTENT-TYPE\")).toLowerCase().startsWith(\"multipart\"))) {\r\n\t\t    // parse multipart\r\n                    HashMap files = httpd.parseMultipart(requestHeader, args, body, length);\r\n                    // integrate these files into the args\r\n                    if (files != null) {\r\n                        Iterator fit = files.entrySet().iterator();\r\n                        Map.Entry entry;\r\n                        while (fit.hasNext()) {\r\n                            entry = (Map.Entry) fit.next();\r\n                            args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                        }\r\n                    }\r\n\t\t    argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n\t\t} else {\r\n\t\t    // parse args in body\r\n\t\t    argc = httpd.parseArgs(args, body, length);\r\n\t\t}\r\n\t    } else {\r\n\t\t// no args\r\n\t\targsString = null;\r\n\t\targs = null;\r\n\t\targc = 0;\r\n\t    }\r\n\t} else {\r\n\t    // simple args in URL (stuff after the \"?\")\r\n\t    argc = httpd.parseArgs(args, argsString);\r\n\t}\r\n\t\r\n\t//if (args != null) System.out.println(\"***ARGS=\" + args.toString()); // DEBUG\r\n\r\n\t// check for cross site scripting - attacks in request arguments\r\n\tif (argc > 0) {\r\n\t    // check all values for occurrences of script values\r\n\t    Enumeration e = args.elements(); // enumeration of values\r\n\t    Object val;\r\n\t    while (e.hasMoreElements()) {\r\n\t\tval = e.nextElement();\r\n\t\tif ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n\t\t    // deny request\r\n\t\t    out.write((\"HTTP/1.0 403 bad post values\\r\\n\").getBytes());\r\n\t\t    out.write((\"\\r\\n\").getBytes());\r\n\t\t    out.flush();\r\n\t\t    return;\r\n\t\t}\r\n\t    }\r\n\t}\r\n\r\n\t// we are finished with parsing\r\n\t// the result of value hand-over is in args and argc\r\n\tif (path.length() == 0) {\r\n\t    textMessage(out, 400, \"Bad Request\\r\\n\");\r\n\t    out.flush();\r\n\t    return;\r\n\t}\r\n\r\n\tDate filedate;\r\n\tlong filelength;\r\n\tFile rc = null;\r\n\ttry {\r\n\t    // locate the file\r\n\t    if (!(path.startsWith(\"/\"))) {\r\n\t\t// attach leading slash\r\n\t\tpath = \"/\" + path;\r\n\t    }\r\n            \r\n            // find defaults\r\n            File file = null;\r\n            String testpath = path;\r\n            if (path.endsWith(\"/\")) {\r\n\t\t// attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    file = new File(htRootPath, testpath);\r\n                    if (!(file.exists())) file = new File(htDocsPath, testpath);\r\n                    if (file.exists()) {path = testpath; break;}\r\n                }\r\n\t    } else {\r\n               file = new File(htRootPath, path);\r\n               if (!(file.exists())) file = new File(htDocsPath, path);\r\n            }\r\n            \r\n            /*\r\n\t    if ((iMode) && (path.endsWith(\".html\"))) {\r\n\t\tfile = new File(htRootPath, path.substring(0, path.length() - 4) + \"ihtml\");\r\n\t\tif (!(file.exists())) file = new File(htDocsPath, path.substring(0, path.length() - 4) + \"ihtml\");\r\n\t\tif (!(file.exists())) file = new File(htRootPath, path);\r\n\t\tif (!(file.exists())) file = new File(htDocsPath, path);\r\n\t\t//System.out.println(\"IMODE PATH = \" + file.toString());\r\n\t    }\r\n            */\r\n            \r\n\t    if ((file.exists()) && (file.canRead())) {\r\n\t\t// we have found a file that can be written to the client\r\n\t\t// if this file uses templates, then we use the template\r\n\t\t// re-write - method to create an result\r\n\t\tserverObjects tp = new serverObjects();\r\n\t\tfiledate = new Date(file.lastModified());\r\n                String mimeType = mimeTable.getProperty(conProp.getProperty(\"EXT\",\"\"),\"text/html\");\r\n                byte[] result;\r\n\t\tif (path.endsWith(\"html\") || \r\n                    path.endsWith(\"xml\") || \r\n                    path.endsWith(\"rss\") || \r\n                    path.endsWith(\"csv\") ||\r\n                    path.endsWith(\"pac\")) {\r\n\t\t    rc = rewriteClassFile(file);\r\n\t\t    if (rc != null) {\r\n\t\t\t// CGI-class: call the class to create a property for rewriting\r\n\t\t\ttry {\r\n\t\t\t    requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(\"PATH\", path);\r\n\t\t\t    // in case that there are no args given, args = null or empty hashmap\r\n\t\t\t    tp = (serverObjects) rewriteMethod(rc).invoke(null, new Object[] {requestHeader, args, switchboard});\r\n\t\t\t    // if no args given , then tp will be an empty Hashtable object (not null)\r\n\t\t\t    if (tp == null) tp = new serverObjects();\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(\"AUTHENTICATE\")) {\r\n                                String account = tp.get(\"AUTHENTICATE\", \"\");\r\n                                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                                out.write((\"WWW-Authenticate: Basic realm=\\\"\" + account + \"\\\"\\r\\n\").getBytes());\r\n                                out.write((\"\\r\\n\").getBytes());\r\n                                out.flush();\r\n                                return;\r\n                            }\r\n\t\t\t    // add the application version to every rewrite table\r\n\t\t\t    tp.put(\"version\", switchboard.getConfig(\"version\", \"\"));\r\n\t\t\t    tp.put(\"uptime\", ((System.currentTimeMillis() - Long.parseLong(switchboard.getConfig(\"startupTime\",\"0\"))) / 1000) / 60); // uptime in minutes\r\n\t\t\t    //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n\t\t\t} catch (InvocationTargetException e) {\r\n\t\t\t    System.out.println(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n\t\t\t\t\t       e.getMessage() +\r\n\t\t\t\t\t       \" target exception at \" + rc + \": \" +\r\n\t\t\t\t\t       e.getTargetException().toString() + \":\" +\r\n\t\t\t\t\t       e.getTargetException().getMessage());\r\n\t\t\t    e.printStackTrace();\r\n\t\t\t    rc = null;\r\n\t\t\t}\r\n                        filedate = new Date(System.currentTimeMillis());\r\n\t\t    }\r\n\t\t    // read templates\r\n\t\t    tp.putAll(templates);\r\n\t\t    // rewrite the file\r\n\t\t    ByteArrayOutputStream o = new ByteArrayOutputStream();\r\n                    FileInputStream fis = new FileInputStream(file);\r\n\t\t    httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n\t\t    o.close();\r\n                    result = o.toByteArray();\r\n\t\t} else { // no html\r\n                    // write the file to the client\r\n                    result = serverFileUtils.read(file);\r\n                }\r\n                // check mime type again using the result array: these are 'magics'\r\n                if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n                else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n                else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                // write the array to the client\r\n                respondHeader(out, 200, mimeType, result.length, filedate, null, null);\r\n                Thread.currentThread().sleep(200); // this solved the message problem (!!)\r\n                serverFileUtils.write(result, out);\r\n\t    } else {\r\n\t\ttextMessage(out, 404, \"404 File not Found\\r\\n\"); // would be a possible vuln to return original the original path\r\n\t    }\r\n\t} catch (Exception e) {\r\n\t    //textMessage(out, 503, \"Exception with query: \" + path + \"; '\" + e.toString() + \":\" + e.getMessage() + \"'\\r\\n\");\r\n\t    //e.printStackTrace();\r\n\t    System.out.println(\"ERROR: Exception with query: \" + path + \"; '\" + e.toString() + \":\" + e.getMessage() + \"'\\r\\n\");\r\n\t}\r\n\tout.flush();\r\n        if (!(requestHeader.get(\"Connection\", \"close\").equals(\"keep-alive\"))) {\r\n          // wait a little time until everything closes so that clients can read from the streams/sockets\r\n          try {Thread.currentThread().sleep(1000);} catch (InterruptedException e) {}\r\n        }\r\n    }","id":51590,"modified_method":"public void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, PushbackInputStream body) throws IOException {\r\n\r\n\tString userAgent = (String) requestHeader.get(\"USER-AGENT\");\r\n\tif (userAgent == null) userAgent = \"\";\r\n\tuserAgent = userAgent.trim().toLowerCase();\r\n\t//userAgent = \"portalmmm n400i\"; // debug\r\n\t//boolean iMode = (userAgent.startsWith(\"portalmmm\"));\r\n\t//if (iMode) System.out.println(\"DETECTED IMODE\");\r\n\r\n\t//System.out.println(\"HTTPD-REQUEST FROM CLIENT: \" + userAgent); // DEBUG\r\n\r\n\t// prepare response\r\n\tString method = conProp.getProperty(\"METHOD\");\r\n\tString path = conProp.getProperty(\"PATH\");\r\n\tString argsString = conProp.getProperty(\"ARGS\"); // is null if no args were given\r\n\r\n\t// check hack attacks in path\r\n\tif (path.indexOf(\"..\") >= 0) {\r\n\t    out.write((\"HTTP/1.0 403 bad path\\r\\n\").getBytes());\r\n\t    out.write((\"\\r\\n\").getBytes());\r\n\t    out.flush();\r\n\t    return;\r\n\t}\r\n\r\n        // check permission/granted access\r\n        if ((path.endsWith(\"_p.html\")) &&\r\n            ((adminAccountBase64MD5 = switchboard.getConfig(\"adminAccountBase64MD5\", \"\")).length() != 0)) {\r\n            // authentication required\r\n            String auth = (String) requestHeader.get(\"Authorization\");\r\n            if (auth == null) {\r\n                // no authorization given in response. Ask for that\r\n                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                out.write((\"WWW-Authenticate: Basic realm=\\\"admin log-in\\\"\\r\\n\").getBytes());\r\n                out.write((\"\\r\\n\").getBytes());\r\n                out.flush();\r\n                return;\r\n            } else if (adminAccountBase64MD5.equals(serverCodings.standardCoder.encodeMD5Hex(auth.trim().substring(6)))) {\r\n\t\t// remove brute-force flag\r\n\t\tserverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n\t    } else {\r\n                // a wrong authentication was given. Ask again\r\n                String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                //try {Thread.currentThread().sleep(3000);} catch (InterruptedException e) {} // add a delay to make brute-force harder\r\n\t\tserverCore.bfHost.put(clientIP, \"sleep\");\r\n                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                out.write((\"WWW-Authenticate: Basic realm=\\\"admin log-in\\\"\\r\\n\").getBytes());\r\n                out.write((\"\\r\\n\").getBytes());\r\n                out.flush();\r\n                //System.out.println(\"httpd bfHosts=\" + serverCore.bfHost.toString());\r\n                return;\r\n            }\r\n\t}\r\n\r\n\t// parse arguments\r\n\tserverObjects args = new serverObjects();\r\n\tint argc;\r\n\tif (argsString == null) {\r\n\t    // no args here, maybe a POST with multipart extension\r\n\t    int length;\r\n\t    //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n\t    if ((method.equals(\"POST\")) &&\r\n\t\t(requestHeader.containsKey(\"CONTENT-LENGTH\"))) {\r\n\t\t// if its a POST, it can be either multipart or as args in the body\r\n\t\tlength = Integer.parseInt((String) requestHeader.get(\"CONTENT-LENGTH\"));\r\n\t\tif ((requestHeader.containsKey(\"CONTENT-TYPE\")) &&\r\n\t\t    (((String) requestHeader.get(\"CONTENT-TYPE\")).toLowerCase().startsWith(\"multipart\"))) {\r\n\t\t    // parse multipart\r\n                    HashMap files = httpd.parseMultipart(requestHeader, args, body, length);\r\n                    // integrate these files into the args\r\n                    if (files != null) {\r\n                        Iterator fit = files.entrySet().iterator();\r\n                        Map.Entry entry;\r\n                        while (fit.hasNext()) {\r\n                            entry = (Map.Entry) fit.next();\r\n                            args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                        }\r\n                    }\r\n\t\t    argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n\t\t} else {\r\n\t\t    // parse args in body\r\n\t\t    argc = httpd.parseArgs(args, body, length);\r\n\t\t}\r\n\t    } else {\r\n\t\t// no args\r\n\t\targsString = null;\r\n\t\targs = null;\r\n\t\targc = 0;\r\n\t    }\r\n\t} else {\r\n\t    // simple args in URL (stuff after the \"?\")\r\n\t    argc = httpd.parseArgs(args, argsString);\r\n\t}\r\n\t\r\n\t//if (args != null) System.out.println(\"***ARGS=\" + args.toString()); // DEBUG\r\n\r\n\t// check for cross site scripting - attacks in request arguments\r\n\tif (argc > 0) {\r\n\t    // check all values for occurrences of script values\r\n\t    Enumeration e = args.elements(); // enumeration of values\r\n\t    Object val;\r\n\t    while (e.hasMoreElements()) {\r\n\t\tval = e.nextElement();\r\n\t\tif ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n\t\t    // deny request\r\n\t\t    out.write((\"HTTP/1.0 403 bad post values\\r\\n\").getBytes());\r\n\t\t    out.write((\"\\r\\n\").getBytes());\r\n\t\t    out.flush();\r\n\t\t    return;\r\n\t\t}\r\n\t    }\r\n\t}\r\n\r\n\t// we are finished with parsing\r\n\t// the result of value hand-over is in args and argc\r\n\tif (path.length() == 0) {\r\n\t    textMessage(out, 400, \"Bad Request\\r\\n\");\r\n\t    out.flush();\r\n\t    return;\r\n\t}\r\n\r\n\tDate filedate;\r\n\tlong filelength;\r\n\tFile rc = null;\r\n\ttry {\r\n\t    // locate the file\r\n\t    if (!(path.startsWith(\"/\"))) {\r\n\t\t// attach leading slash\r\n\t\tpath = \"/\" + path;\r\n\t    }\r\n            \r\n            // find defaults\r\n            File file = null;\r\n            String testpath = path;\r\n            if (path.endsWith(\"/\")) {\r\n\t\t// attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    file = new File(htRootPath, testpath);\r\n                    if (!(file.exists())) file = new File(htDocsPath, testpath);\r\n                    if (file.exists()) {path = testpath; break;}\r\n                }\r\n\t    } else {\r\n               file = new File(htRootPath, path);\r\n               if (!(file.exists())) file = new File(htDocsPath, path);\r\n            }\r\n            \r\n            /*\r\n\t    if ((iMode) && (path.endsWith(\".html\"))) {\r\n\t\tfile = new File(htRootPath, path.substring(0, path.length() - 4) + \"ihtml\");\r\n\t\tif (!(file.exists())) file = new File(htDocsPath, path.substring(0, path.length() - 4) + \"ihtml\");\r\n\t\tif (!(file.exists())) file = new File(htRootPath, path);\r\n\t\tif (!(file.exists())) file = new File(htDocsPath, path);\r\n\t\t//System.out.println(\"IMODE PATH = \" + file.toString());\r\n\t    }\r\n            */\r\n            \r\n\t    if ((file.exists()) && (file.canRead())) {\r\n\t\t// we have found a file that can be written to the client\r\n\t\t// if this file uses templates, then we use the template\r\n\t\t// re-write - method to create an result\r\n\t\tserverObjects tp = new serverObjects();\r\n\t\tfiledate = new Date(file.lastModified());\r\n                String mimeType = mimeTable.getProperty(conProp.getProperty(\"EXT\",\"\"),\"text/html\");\r\n                byte[] result;\r\n\t\tif (path.endsWith(\"html\") || \r\n                    path.endsWith(\"xml\") || \r\n                    path.endsWith(\"rss\") || \r\n                    path.endsWith(\"csv\") ||\r\n                    path.endsWith(\"pac\")) {\r\n\t\t    rc = rewriteClassFile(file);\r\n\t\t    if (rc != null) {\r\n\t\t\t// CGI-class: call the class to create a property for rewriting\r\n\t\t\ttry {\r\n\t\t\t    requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(\"PATH\", path);\r\n\t\t\t    // in case that there are no args given, args = null or empty hashmap\r\n\t\t\t    tp = (serverObjects) rewriteMethod(rc).invoke(null, new Object[] {requestHeader, args, switchboard});\r\n\t\t\t    // if no args given , then tp will be an empty Hashtable object (not null)\r\n\t\t\t    if (tp == null) tp = new serverObjects();\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(\"AUTHENTICATE\")) {\r\n                                String account = tp.get(\"AUTHENTICATE\", \"\");\r\n                                out.write((\"HTTP/1.1 401 log-in required\\r\\n\").getBytes());\r\n                                out.write((\"WWW-Authenticate: Basic realm=\\\"\" + account + \"\\\"\\r\\n\").getBytes());\r\n                                out.write((\"\\r\\n\").getBytes());\r\n                                out.flush();\r\n                                return;\r\n                            }\r\n\t\t\t    // add the application version to every rewrite table\r\n\t\t\t    tp.put(\"version\", switchboard.getConfig(\"version\", \"\"));\r\n\t\t\t    tp.put(\"uptime\", ((System.currentTimeMillis() - Long.parseLong(switchboard.getConfig(\"startupTime\",\"0\"))) / 1000) / 60); // uptime in minutes\r\n\t\t\t    //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n\t\t\t} catch (InvocationTargetException e) {\r\n\t\t\t    System.out.println(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n\t\t\t\t\t       e.getMessage() +\r\n\t\t\t\t\t       \" target exception at \" + rc + \": \" +\r\n\t\t\t\t\t       e.getTargetException().toString() + \":\" +\r\n\t\t\t\t\t       e.getTargetException().getMessage());\r\n\t\t\t    e.printStackTrace();\r\n\t\t\t    rc = null;\r\n\t\t\t}\r\n                        filedate = new Date(System.currentTimeMillis());\r\n\t\t    }\r\n\t\t    // read templates\r\n\t\t    tp.putAll(templates);\r\n\t\t    // rewrite the file\r\n\t\t    ByteArrayOutputStream o = null;\r\n            FileInputStream fis = null;\r\n            try {\r\n\t            o = new ByteArrayOutputStream();\r\n\t            fis = new FileInputStream(file);\r\n\t\t\t    httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n\t            result = o.toByteArray();\r\n            } finally {\r\n                if (o != null) try {o.close();} catch(Exception e) {}\r\n                if (fis != null) try {fis.close();} catch(Exception e) {}\r\n            }\r\n                    \r\n\t\t} else { // no html\r\n                    // write the file to the client\r\n                    result = serverFileUtils.read(file);\r\n                }\r\n                // check mime type again using the result array: these are 'magics'\r\n                if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n                else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n                else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                // write the array to the client\r\n                respondHeader(out, 200, mimeType, result.length, filedate, null, null);\r\n                Thread.currentThread().sleep(200); // this solved the message problem (!!)\r\n                serverFileUtils.write(result, out);\r\n\t    } else {\r\n\t\ttextMessage(out, 404, \"404 File not Found\\r\\n\"); // would be a possible vuln to return original the original path\r\n\t    }\r\n\t} catch (Exception e) {\r\n\t    //textMessage(out, 503, \"Exception with query: \" + path + \"; '\" + e.toString() + \":\" + e.getMessage() + \"'\\r\\n\");\r\n\t    //e.printStackTrace();\r\n\t    System.out.println(\"ERROR: Exception with query: \" + path + \"; '\" + e.toString() + \":\" + e.getMessage() + \"'\\r\\n\");\r\n\t}\r\n\tout.flush();\r\n        if (!(requestHeader.get(\"Connection\", \"close\").equals(\"keep-alive\"))) {\r\n          // wait a little time until everything closes so that clients can read from the streams/sockets\r\n          try {Thread.currentThread().sleep(1000);} catch (InterruptedException e) {}\r\n        }\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public httpdFileHandler(serverSwitch switchboard) {\r\n\tthis.switchboard = switchboard;\r\n\r\n\tif (mimeTable == null) {\r\n\t    // load the mime table\r\n\t    mimeTable = new Properties();\r\n            String mimeTablePath = switchboard.getConfig(\"mimeConfig\",\"\");\r\n            try {\r\n\t\tserverLog.logSystem(\"HTTPDFiles\", \"Loading mime mapping file \" + mimeTablePath);\r\n\t\tmimeTable.load(new FileInputStream(new File(switchboard.getRootPath(), mimeTablePath)));\r\n\t    } catch (Exception e) {\r\n\t\tserverLog.logError(\"HTTPDFiles\", \"ERROR: path to configuration file or configuration invalid\\n\" + e);\r\n\t\tSystem.exit(1);\r\n\t    }\r\n\t}\r\n        \r\n        // create default files array\r\n        defaultFiles = switchboard.getConfig(\"defaultFiles\",\"index.html\").split(\",\");\r\n        if (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\r\n        \r\n        // create a htRootPath: system pages\r\n        if (htRootPath == null) {\r\n            htRootPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htRootPath\",\"htroot\"));\r\n            if (!(htRootPath.exists())) htRootPath.mkdir();\r\n        }\r\n        \r\n        // create a htDocsPath: user defined pages\r\n        if (htDocsPath == null) {\r\n            htDocsPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htDocsPath\", \"htdocs\"));\r\n            if (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n        }\r\n\r\n        // create a htTemplatePath\r\n        if (htTemplatePath == null) {\r\n            htTemplatePath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htTemplatePath\",\"htroot/env/templates\"));\r\n            if (!(htTemplatePath.exists())) htTemplatePath.mkdir();\r\n        }\r\n        \r\n        if (templates == null) templates = loadTemplates(htTemplatePath);\r\n\r\n\t// create a class loader\r\n        if (provider == null) {\r\n\t    provider = new serverClassLoader(/*this.getClass().getClassLoader()*/);\r\n\t    // debug\r\n\t    /*\r\n\t    Package[] ps = ((cachedClassLoader) provider).packages();\r\n\t    for (int i = 0; i < ps.length; i++) System.out.println(\"PACKAGE IN PROVIDER: \" + ps[i].toString());\r\n\t    */\r\n\t}\r\n\tadminAccountBase64MD5 = null;\r\n        \r\n        serverLog.logSystem(\"HTTPDFileHandler\", \"File Handler Initialized\");\r\n    }","id":51591,"modified_method":"public httpdFileHandler(serverSwitch switchboard) {\r\n\t\tthis.switchboard = switchboard;\r\n\t\r\n\t\tif (this.mimeTable == null) {\r\n\t\t\t// load the mime table\r\n\t\t\tthis.mimeTable = new Properties();\r\n\t\t\tString mimeTablePath = switchboard.getConfig(\"mimeConfig\",\"\");\r\n\t        FileInputStream mimeTableInputStream = null;\r\n\t\t\ttry {\r\n\t\t\t\tserverLog.logSystem(\"HTTPDFiles\", \"Loading mime mapping file \" + mimeTablePath);\r\n\t            mimeTableInputStream = new FileInputStream(new File(switchboard.getRootPath(), mimeTablePath));\r\n\t\t\t\tthis.mimeTable.load(mimeTableInputStream);\r\n\t\t\t} catch (Exception e) {\r\n\t            if (mimeTableInputStream != null) try { mimeTableInputStream.close(); } catch (Exception e1) {}\r\n\t\t\t\tserverLog.logError(\"HTTPDFiles\", \"ERROR: path to configuration file or configuration invalid\\n\" + e);\r\n\t\t\t\tSystem.exit(1);\r\n\t\t    }\r\n\t\t}\r\n        \r\n\t\t// create default files array\r\n\t\tdefaultFiles = switchboard.getConfig(\"defaultFiles\",\"index.html\").split(\",\");\r\n\t\tif (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\r\n        \r\n\t\t// create a htRootPath: system pages\r\n\t\tif (htRootPath == null) {\r\n\t\t\thtRootPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htRootPath\",\"htroot\"));\r\n\t\t\tif (!(htRootPath.exists())) htRootPath.mkdir();\r\n\t\t}\r\n        \r\n\t\t// create a htDocsPath: user defined pages\r\n\t\tif (htDocsPath == null) {\r\n\t\t\thtDocsPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htDocsPath\", \"htdocs\"));\r\n\t\t\tif (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n\t\t}\r\n\r\n\t\t// create a htTemplatePath\r\n\t\tif (htTemplatePath == null) {\r\n\t\t\thtTemplatePath = new File(switchboard.getRootPath(), switchboard.getConfig(\"htTemplatePath\",\"htroot/env/templates\"));\r\n\t\t\tif (!(htTemplatePath.exists())) htTemplatePath.mkdir();\r\n\t\t}\r\n        \r\n        if (templates == null) templates = loadTemplates(htTemplatePath);\r\n\r\n\t\t// create a class loader\r\n\t\tif (provider == null) {\r\n\t\t\tprovider = new serverClassLoader(/*this.getClass().getClassLoader()*/);\r\n\t\t\t// debug\r\n\t\t\t/*\r\n\t\t\tPackage[] ps = ((cachedClassLoader) provider).packages();\r\n\t\t\tfor (int i = 0; i < ps.length; i++) System.out.println(\"PACKAGE IN PROVIDER: \" + ps[i].toString());\r\n\t\t\t*/\r\n\t\t}\r\n\t\tadminAccountBase64MD5 = null;\r\n        \r\n\t\tserverLog.logSystem(\"HTTPDFileHandler\", \"File Handler Initialized\");\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static TreeMap loadMap(String mapname, String filename, String sep) {\r\n\tTreeMap map = new TreeMap();\r\n\ttry {\r\n\t    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\r\n\t    String line;\r\n\t    int pos;\r\n\t    while ((line = br.readLine()) != null) {\r\n\t\tline = line.trim();\r\n\t\tif ((line.length() > 0) && (!(line.startsWith(\"#\"))) && ((pos = line.indexOf(sep)) > 0))\r\n\t\t    map.put(line.substring(0, pos).trim().toLowerCase(), line.substring(pos + sep.length()).trim());\r\n\t    }\r\n\t    br.close();\r\n\t    serverLog.logInfo(\"PROXY\", \"read \" + mapname + \" map from file \" + filename);\r\n\t} catch (IOException e) {}\r\n\treturn map;\r\n    }","id":51592,"modified_method":"private static TreeMap loadMap(String mapname, String filename, String sep) {\r\n\t\tTreeMap map = new TreeMap();\r\n        BufferedReader br = null;\r\n\t\ttry {\r\n\t\t    br = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\r\n\t\t    String line;\r\n\t\t    int pos;\r\n\t\t    while ((line = br.readLine()) != null) {\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif ((line.length() > 0) && (!(line.startsWith(\"#\"))) && ((pos = line.indexOf(sep)) > 0))\r\n\t\t\t\t    map.put(line.substring(0, pos).trim().toLowerCase(), line.substring(pos + sep.length()).trim());\r\n\t\t    }\r\n\t\t    serverLog.logInfo(\"PROXY\", \"read \" + mapname + \" map from file \" + filename);\r\n\t\t} catch (IOException e) {            \r\n\t\t} finally {\r\n            if (br != null) try { br.close(); } catch (Exception e) {}\r\n\t\t}\r\n\t\treturn map;\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void doGet(Properties conProp, httpHeader requestHeader, OutputStream respond) throws IOException {\r\n\t// prepare response\r\n\t// conProp      : a collection of properties about the connection, like URL\r\n\t// requestHeader : The header lines of the connection from the request\r\n\t// args         : the argument values of a connection, like &-values in GET and values within boundaries in POST\r\n\t// files        : files within POST boundaries, same key as in args\r\n\r\n\tif (yacyTrigger) de.anomic.yacy.yacyCore.triggerOnlineAction();\r\n\r\n\tDate requestDate = new Date(); // remember the time...\r\n\tString method = conProp.getProperty(\"METHOD\");\r\n\tString host = conProp.getProperty(\"HOST\");\r\n\tString path = conProp.getProperty(\"PATH\"); // always starts with leading '/'\r\n\tString args = conProp.getProperty(\"ARGS\"); // may be null if no args were given\r\n\tString ip = conProp.getProperty(\"CLIENTIP\"); // the ip from the connecting peer\r\n\r\n\tint port;\r\n\tint pos;\r\n\r\n\tif ((pos = host.indexOf(\":\")) < 0) {\r\n\t    port = 80;\r\n\t} else {\r\n\t    port = Integer.parseInt(host.substring(pos + 1));\r\n\t    host = host.substring(0, pos);\r\n\t}\r\n        \r\n        String ext;\r\n        if ((pos = path.lastIndexOf('.')) < 0) {\r\n            ext = \"\";\r\n        } else {\r\n            ext = path.substring(pos + 1).toLowerCase();\r\n        }\r\n\r\n\tURL url = null;\r\n\ttry {\r\n\t    if (args == null)\r\n\t\turl = new URL(\"http\", host, port, path);\r\n\t    else\r\n\t\turl = new URL(\"http\", host, port, path + \"?\" + args);\r\n\t} catch (MalformedURLException e) {\r\n\t    serverLog.logError(\"PROXY\", \"ERROR: internal error with url generation: host=\" +\r\n\t\t\t       host + \", port=\" + port + \", path=\" + path + \", args=\" + args);\r\n\t    url = null;\r\n\t}\r\n\t//System.out.println(\"GENERATED URL:\" + url.toString()); // debug\r\n\r\n\t// check the blacklist\r\n\t// blacklist idea inspired by [AS]:\r\n\t// respond a 404 for all AGIS (\"all you get is shit\") servers\r\n\tString hostlow = host.toLowerCase();\r\n        if (blacklistedURL(hostlow, path)) {\r\n            try {\r\n                respondHeader(respond,\"404 Not Found (AGIS)\", new httpHeader(null));\r\n                respond.write((\"404 (generated): URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\\r\\n\").getBytes());\r\n                respond.flush();\r\n                serverLog.logInfo(\"PROXY\", \"AGIS blocking of host '\" + hostlow + \"'\"); // debug\r\n                return;\r\n            } catch (Exception ee) {}\r\n        }\r\n        \r\n        // handle outgoing cookies\r\n        handleOutgoingCookies(requestHeader, host, ip);\r\n        \r\n        // set another userAgent, if not yellowlisted\r\n        if ((yellowList != null) && (!(yellowList.contains(domain(hostlow))))) {\r\n            // change the User-Agent\r\n            requestHeader.put(\"User-Agent\", userAgent);\r\n        }\r\n        \r\n        // set a scraper and a htmlFilter\r\n        OutputStream hfos = null;\r\n        htmlFilterContentScraper scraper = null;\r\n        \r\n        // resolve yacy and yacyh domains\r\n        String yAddress = yacyCore.seedDB.resolveYacyAddress(host);\r\n        \r\n        // re-calc the url path\r\n        String remotePath = (args == null) ? path : (path + \"?\" + args); // with leading '/'\r\n        \r\n        // attach possible yacy-sublevel-domain\r\n        if ((yAddress != null) &&\r\n\t    ((pos = yAddress.indexOf(\"/\")) >= 0) &&\r\n\t    (!(remotePath.startsWith(\"/env\"))) // this is the special path, staying always at root-level\r\n\t    ) remotePath = yAddress.substring(pos) + remotePath;\r\n        \r\n        // decide wether to use a cache entry or connect to the network\r\n        File cacheFile = cacheManager.getCachePath(url);\r\n        String urlHash = plasmaCrawlLURL.urlHash(url);\r\n        httpHeader cachedResponseHeader = null;\r\n        boolean cacheExists = ((cacheFile.exists()) && (cacheFile.isFile()) &&\r\n\t\t\t       ((cachedResponseHeader = cacheManager.getCachedResponse(urlHash)) != null));\r\n        \r\n        // why are files unzipped upon arrival? why not zip all files in cache?\r\n        // This follows from the following premises\r\n        // (a) no file shall be unzip-ed more than once to prevent unnessesary computing time\r\n        // (b) old cache entries shall be comparable with refill-entries to detect/distiguish case 3+4\r\n        // (c) the indexing mechanism needs files unzip-ed, a schedule could do that later\r\n        // case b and c contradicts, if we use a scheduler, because files in a stale cache would be unzipped\r\n        // and the newly arrival would be zipped and would have to be unzipped upon load. But then the\r\n        // scheduler is superfluous. Therefore the only reminding case is\r\n        // (d) cached files shall be either all zipped or unzipped\r\n        // case d contradicts with a, because files need to be unzipped for indexing. Therefore\r\n        // the only remaining case is to unzip files right upon load. Thats what we do here.\r\n        \r\n        // finally use existing cache if appropriate\r\n        // here we must decide weather or not to save the data\r\n        // to a cache\r\n        // we distinguish four CACHE STATE cases:\r\n        // 1. cache fill\r\n        // 2. cache fresh - no refill\r\n        // 3. cache stale - refill - necessary\r\n        // 4. cache stale - refill - superfluous\r\n        // in two of these cases we trigger a scheduler to handle newly arrived files:\r\n        // case 1 and case 3\r\n        plasmaHTCache.Entry cacheEntry;\r\n        if ((cacheExists) &&\r\n            ((cacheEntry = cacheManager.newEntry(requestDate, 0, url, requestHeader, \"200 OK\",\r\n                                          cachedResponseHeader, null,\r\n                                          switchboard.defaultProxyProfile)).shallUseCache())) {\r\n            // we respond on the request by using the cache, the cache is fresh\r\n            \r\n            try {\r\n                // replace date field in old header by actual date, this is according to RFC\r\n                cachedResponseHeader.put(\"Date\", httpc.dateString(httpc.nowDate()));\r\n                \r\n                // maybe the content length is missing\r\n                if (!(cachedResponseHeader.containsKey(\"CONTENT-LENGTH\")))\r\n                    cachedResponseHeader.put(\"CONTENT-LENGTH\", Long.toString(cacheFile.length()));\r\n                \r\n                // check if we can send a 304 instead the complete content\r\n                if (requestHeader.containsKey(\"IF-MODIFIED-SINCE\")) {\r\n                    // conditional request: freshness of cache for that condition was already\r\n                    // checked within shallUseCache(). Now send only a 304 response\r\n                    log.logInfo(\"CACHE HIT/304 \" + cacheFile.toString());\r\n                    \r\n                    // send cached header with replaced date and added length\r\n                    respondHeader(respond, \"304 OK\", cachedResponseHeader); // respond with 'not modified'\r\n                    \r\n                } else {\r\n                    // unconditional request: send content of cache\r\n                    log.logInfo(\"CACHE HIT/203 \" + cacheFile.toString());\r\n                    \r\n                    // send cached header with replaced date and added length\r\n                    respondHeader(respond, \"203 OK\", cachedResponseHeader); // respond with 'non-authoritative'\r\n                    \r\n                    // make a transformer\r\n                    if ((!(transformer.isIdentityTransformer())) &&\r\n                        ((ext == null) || (!(switchboard.extensionBlack.contains(ext)))) &&\r\n                        ((cachedResponseHeader == null) || (httpd.isTextMime(cachedResponseHeader.mime(), switchboard.mimeWhite)))) {\r\n                        hfos = new htmlFilterOutputStream(respond, null, transformer, (ext.length() == 0));\r\n                    } else {\r\n                        hfos = respond;\r\n                    }\r\n                    \r\n                    // send also the complete body now from the cache\r\n                    // simply read the file and transfer to out socket\r\n                    InputStream is = new FileInputStream(cacheFile);\r\n                    byte[] buffer = new byte[2048];\r\n                    int l;\r\n                    while ((l = is.read(buffer)) > 0) {hfos.write(buffer, 0, l);}\r\n                    is.close();\r\n                    if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                }\r\n                // that's it!\r\n            } catch (SocketException e) {\r\n                // this happens if the client stops loading the file\r\n                // we do nothing here\r\n                respondError(respond, \"111 socket error: \" + e.getMessage(), 1, url.toString());\r\n            }\r\n            respond.flush();\r\n            return;\r\n        }\r\n        \r\n        // the cache does either not exist or is (supposed to be) stale\r\n        long sizeBeforeDelete = -1;\r\n        if (cacheExists) {\r\n            // delete the cache\r\n            sizeBeforeDelete = cacheFile.length();\r\n            cacheFile.delete();\r\n        }\r\n        \r\n        // take a new file from the server\r\n        httpc remote = null;\r\n        httpc.response res = null;\r\n        \r\n        try {\r\n            // open the connection\r\n            if (yAddress == null) {\r\n                remote = newhttpc(host, port, timeout);\r\n            } else {\r\n                remote = newhttpc(yAddress, timeout);\r\n            }\r\n            //System.out.println(\"HEADER: CLIENT TO PROXY = \" + requestHeader.toString()); // DEBUG\r\n            \r\n            // send request\r\n            res = remote.GET(remotePath, requestHeader);\r\n            long contentLength = res.responseHeader.contentLength();\r\n            \r\n            // reserver cache entry\r\n            cacheEntry = cacheManager.newEntry(requestDate, 0, url, requestHeader, res.status, res.responseHeader, null, switchboard.defaultProxyProfile);\r\n            \r\n            // handle file types\r\n            if (((ext == null) || (!(switchboard.extensionBlack.contains(ext)))) &&\r\n                (httpd.isTextMime(res.responseHeader.mime(), switchboard.mimeWhite))) {\r\n\t\t// this is a file that is a possible candidate for parsing by the indexer\r\n                if (transformer.isIdentityTransformer()) {\r\n\t\t    log.logDebug(\"create passthrough (parse candidate) for url \" + url);\r\n                    // no transformation, only passthrough\r\n\t\t    // this is especially the case if the bluelist is empty\r\n\t\t    // in that case, the content is not scraped here but later\r\n                    hfos = respond;\r\n                } else {\r\n                    // make a scraper and transformer\r\n\t\t    log.logDebug(\"create scraper for url \" + url);\r\n                    scraper = new htmlFilterContentScraper(url);\r\n                    hfos = new htmlFilterOutputStream(respond, scraper, transformer, (ext.length() == 0));\r\n                    if (((htmlFilterOutputStream) hfos).binarySuspect()) {\r\n                        scraper = null; // forget it, may be rubbish\r\n                        log.logDebug(\"Content of \" + url + \" is probably binary. deleted scraper.\");\r\n                    }\r\n                    cacheEntry.scraper = scraper;\r\n                }\r\n            } else {\r\n                log.logDebug(\"Resource \" + url + \" has wrong extension (\" + ext + \") or wrong mime-type (\" + res.responseHeader.mime() + \"). not scraped\");\r\n                scraper = null;\r\n                hfos = respond;\r\n                cacheEntry.scraper = scraper;\r\n            }\r\n            \r\n            // handle incoming cookies\r\n            handleIncomingCookies(res.responseHeader, host, ip);\r\n            \r\n            // request has been placed and result has been returned. work off response\r\n            try {\r\n                respondHeader(respond, res.status, res.responseHeader);\r\n                String storeError;\r\n                if ((storeError = cacheEntry.shallStoreCache()) == null) {\r\n                    // we write a new cache entry\r\n                    if ((contentLength > 0) && // known\r\n                        (contentLength < 1048576)) {// 1 MB\r\n                        // ok, we don't write actually into a file, only to RAM, and schedule writing the file.\r\n                        byte[] cacheArray = res.writeContent(hfos);\r\n\t\t\tlog.logDebug(\"writeContent of \" + url + \" produced cacheArray = \" + ((cacheArray == null) ? \"null\" : (\"size=\" + cacheArray.length)));\r\n\r\n                        if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                        \r\n                        if (sizeBeforeDelete == -1) {\r\n                            // totally fresh file\r\n                            cacheEntry.status = plasmaHTCache.CACHE_FILL; // it's an insert\r\n                            cacheManager.stackProcess(cacheEntry, cacheArray);\r\n                        } else if (sizeBeforeDelete == cacheArray.length) {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheArray = null;\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_BAD;\r\n                            cacheManager.stackProcess(cacheEntry); // unnecessary update\r\n                        } else {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_GOOD;\r\n                            cacheManager.stackProcess(cacheEntry, cacheArray); // necessary update, write response header to cache\r\n                        }\r\n                    } else {\r\n                        // the file is too big to cache it in the ram, or the size is unknown\r\n\t\t\t// write to file right here.\r\n                        cacheFile.getParentFile().mkdirs();\r\n                        res.writeContent(hfos, cacheFile);\r\n                        if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n\t\t\tlog.logDebug(\"for write-file of \" + url + \": contentLength = \" + contentLength + \", sizeBeforeDelete = \" + sizeBeforeDelete);\r\n                        if (sizeBeforeDelete == -1) {\r\n                            // totally fresh file\r\n                            cacheEntry.status = plasmaHTCache.CACHE_FILL; // it's an insert\r\n                            cacheManager.stackProcess(cacheEntry);\r\n                        } else if (sizeBeforeDelete == cacheFile.length()) {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_BAD;\r\n                            cacheManager.stackProcess(cacheEntry); // unnecessary update\r\n                        } else {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_GOOD;\r\n                            cacheManager.stackProcess(cacheEntry); // necessary update, write response header to cache\r\n                        }\r\n\t\t\t// beware! all these writings will not fill the cacheEntry.cacheArray\r\n\t\t\t// that means they are not available for the indexer (except they are scraped before)\r\n                    }\r\n                } else {\r\n                    // no caching\r\n                    log.logDebug(cacheFile.toString() + \" not cached: \" + storeError);\r\n                    res.writeContent(hfos, null);\r\n                    if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                    if (sizeBeforeDelete == -1) {\r\n                        // no old file and no load. just data passing\r\n                        cacheEntry.status = plasmaHTCache.CACHE_PASSING;\r\n                        cacheManager.stackProcess(cacheEntry);\r\n                    } else {\r\n                        // before we came here we deleted a cache entry\r\n                        cacheEntry.status = plasmaHTCache.CACHE_STALE_NO_RELOAD;\r\n                        cacheManager.stackProcess(cacheEntry);\r\n                    }\r\n                }\r\n            } catch (SocketException e) {\r\n                // this may happen if the client suddenly closes its connection\r\n                // maybe the user has stopped loading\r\n                // in that case, we are not responsible and just forget it\r\n                // but we clean the cache also, since it may be only partial\r\n                // and most possible corrupted\r\n                if (cacheFile.exists()) cacheFile.delete();\r\n                respondHeader(respond,\"404 client unexpectedly closed connection\", new httpHeader(null));\r\n            } catch (IOException e) {\r\n\t\t// can have various reasons\r\n                if (cacheFile.exists()) cacheFile.delete();\r\n\t\tif (e.getMessage().indexOf(\"Corrupt GZIP trailer\") >= 0) {\r\n\t\t    // just do nothing, we leave it this way\r\n                    log.logDebug(\"ignoring bad gzip trail for URL \" + url + \" (\" + e.getMessage() + \")\");\r\n\t\t} else {\r\n\t\t    respondHeader(respond,\"404 client unexpectedly closed connection\", new httpHeader(null));\r\n                    log.logDebug(\"IOError for URL \" + url + \" (\" + e.getMessage() + \") - responded 404\");\r\n\t\t    e.printStackTrace();\r\n\t\t}\r\n            }\r\n            remote.close();\r\n        } catch (Exception e) {\r\n            // this may happen if the targeted host does not exist or anything with the\r\n            // remote server was wrong.\r\n            // in any case, sending a 404 is appropriate\r\n            try {\r\n                if ((e.toString().indexOf(\"unknown host\")) > 0) {\r\n                    respondHeader(respond,\"404 unknown host\", new httpHeader(null));\r\n                } else {\r\n                    respondHeader(respond,\"404 Not Found\", new httpHeader(null));\r\n                    respond.write((\"Exception occurred:\\r\\n\").getBytes());\r\n                    respond.write((e.toString() + \"\\r\\n\").getBytes());\r\n                    respond.write((\"[TRACE: \").getBytes());\r\n                    e.printStackTrace(new PrintStream(respond));\r\n                    respond.write((\"]\\r\\n\").getBytes());\r\n                }\r\n            } catch (Exception ee) {}\r\n        } finally {\r\n            if (remote != null) httpc.returnInstance(remote);\r\n        }\r\n        respond.flush();\r\n    }","id":51593,"modified_method":"public void doGet(Properties conProp, httpHeader requestHeader, OutputStream respond) throws IOException {\r\n\t// prepare response\r\n\t// conProp      : a collection of properties about the connection, like URL\r\n\t// requestHeader : The header lines of the connection from the request\r\n\t// args         : the argument values of a connection, like &-values in GET and values within boundaries in POST\r\n\t// files        : files within POST boundaries, same key as in args\r\n\r\n\tif (yacyTrigger) de.anomic.yacy.yacyCore.triggerOnlineAction();\r\n\r\n\tDate requestDate = new Date(); // remember the time...\r\n\tString method = conProp.getProperty(\"METHOD\");\r\n\tString host = conProp.getProperty(\"HOST\");\r\n\tString path = conProp.getProperty(\"PATH\"); // always starts with leading '/'\r\n\tString args = conProp.getProperty(\"ARGS\"); // may be null if no args were given\r\n\tString ip = conProp.getProperty(\"CLIENTIP\"); // the ip from the connecting peer\r\n\r\n\tint port;\r\n\tint pos;\r\n\r\n\tif ((pos = host.indexOf(\":\")) < 0) {\r\n\t    port = 80;\r\n\t} else {\r\n\t    port = Integer.parseInt(host.substring(pos + 1));\r\n\t    host = host.substring(0, pos);\r\n\t}\r\n        \r\n        String ext;\r\n        if ((pos = path.lastIndexOf('.')) < 0) {\r\n            ext = \"\";\r\n        } else {\r\n            ext = path.substring(pos + 1).toLowerCase();\r\n        }\r\n\r\n\tURL url = null;\r\n\ttry {\r\n\t    if (args == null)\r\n\t\turl = new URL(\"http\", host, port, path);\r\n\t    else\r\n\t\turl = new URL(\"http\", host, port, path + \"?\" + args);\r\n\t} catch (MalformedURLException e) {\r\n\t    serverLog.logError(\"PROXY\", \"ERROR: internal error with url generation: host=\" +\r\n\t\t\t       host + \", port=\" + port + \", path=\" + path + \", args=\" + args);\r\n\t    url = null;\r\n\t}\r\n\t//System.out.println(\"GENERATED URL:\" + url.toString()); // debug\r\n\r\n\t// check the blacklist\r\n\t// blacklist idea inspired by [AS]:\r\n\t// respond a 404 for all AGIS (\"all you get is shit\") servers\r\n\tString hostlow = host.toLowerCase();\r\n        if (blacklistedURL(hostlow, path)) {\r\n            try {\r\n                respondHeader(respond,\"404 Not Found (AGIS)\", new httpHeader(null));\r\n                respond.write((\"404 (generated): URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\\r\\n\").getBytes());\r\n                respond.flush();\r\n                serverLog.logInfo(\"PROXY\", \"AGIS blocking of host '\" + hostlow + \"'\"); // debug\r\n                return;\r\n            } catch (Exception ee) {}\r\n        }\r\n        \r\n        // handle outgoing cookies\r\n        handleOutgoingCookies(requestHeader, host, ip);\r\n        \r\n        // set another userAgent, if not yellowlisted\r\n        if ((yellowList != null) && (!(yellowList.contains(domain(hostlow))))) {\r\n            // change the User-Agent\r\n            requestHeader.put(\"User-Agent\", userAgent);\r\n        }\r\n        \r\n        // set a scraper and a htmlFilter\r\n        OutputStream hfos = null;\r\n        htmlFilterContentScraper scraper = null;\r\n        \r\n        // resolve yacy and yacyh domains\r\n        String yAddress = yacyCore.seedDB.resolveYacyAddress(host);\r\n        \r\n        // re-calc the url path\r\n        String remotePath = (args == null) ? path : (path + \"?\" + args); // with leading '/'\r\n        \r\n        // attach possible yacy-sublevel-domain\r\n        if ((yAddress != null) &&\r\n\t    ((pos = yAddress.indexOf(\"/\")) >= 0) &&\r\n\t    (!(remotePath.startsWith(\"/env\"))) // this is the special path, staying always at root-level\r\n\t    ) remotePath = yAddress.substring(pos) + remotePath;\r\n        \r\n        // decide wether to use a cache entry or connect to the network\r\n        File cacheFile = cacheManager.getCachePath(url);\r\n        String urlHash = plasmaCrawlLURL.urlHash(url);\r\n        httpHeader cachedResponseHeader = null;\r\n        boolean cacheExists = ((cacheFile.exists()) && (cacheFile.isFile()) &&\r\n\t\t\t       ((cachedResponseHeader = cacheManager.getCachedResponse(urlHash)) != null));\r\n        \r\n        // why are files unzipped upon arrival? why not zip all files in cache?\r\n        // This follows from the following premises\r\n        // (a) no file shall be unzip-ed more than once to prevent unnessesary computing time\r\n        // (b) old cache entries shall be comparable with refill-entries to detect/distiguish case 3+4\r\n        // (c) the indexing mechanism needs files unzip-ed, a schedule could do that later\r\n        // case b and c contradicts, if we use a scheduler, because files in a stale cache would be unzipped\r\n        // and the newly arrival would be zipped and would have to be unzipped upon load. But then the\r\n        // scheduler is superfluous. Therefore the only reminding case is\r\n        // (d) cached files shall be either all zipped or unzipped\r\n        // case d contradicts with a, because files need to be unzipped for indexing. Therefore\r\n        // the only remaining case is to unzip files right upon load. Thats what we do here.\r\n        \r\n        // finally use existing cache if appropriate\r\n        // here we must decide weather or not to save the data\r\n        // to a cache\r\n        // we distinguish four CACHE STATE cases:\r\n        // 1. cache fill\r\n        // 2. cache fresh - no refill\r\n        // 3. cache stale - refill - necessary\r\n        // 4. cache stale - refill - superfluous\r\n        // in two of these cases we trigger a scheduler to handle newly arrived files:\r\n        // case 1 and case 3\r\n        plasmaHTCache.Entry cacheEntry;\r\n        if ((cacheExists) &&\r\n            ((cacheEntry = cacheManager.newEntry(requestDate, 0, url, requestHeader, \"200 OK\",\r\n                                          cachedResponseHeader, null,\r\n                                          switchboard.defaultProxyProfile)).shallUseCache())) {\r\n            // we respond on the request by using the cache, the cache is fresh\r\n            \r\n            try {\r\n                // replace date field in old header by actual date, this is according to RFC\r\n                cachedResponseHeader.put(\"Date\", httpc.dateString(httpc.nowDate()));\r\n                \r\n                // maybe the content length is missing\r\n                if (!(cachedResponseHeader.containsKey(\"CONTENT-LENGTH\")))\r\n                    cachedResponseHeader.put(\"CONTENT-LENGTH\", Long.toString(cacheFile.length()));\r\n                \r\n                // check if we can send a 304 instead the complete content\r\n                if (requestHeader.containsKey(\"IF-MODIFIED-SINCE\")) {\r\n                    // conditional request: freshness of cache for that condition was already\r\n                    // checked within shallUseCache(). Now send only a 304 response\r\n                    log.logInfo(\"CACHE HIT/304 \" + cacheFile.toString());\r\n                    \r\n                    // send cached header with replaced date and added length\r\n                    respondHeader(respond, \"304 OK\", cachedResponseHeader); // respond with 'not modified'\r\n                    \r\n                } else {\r\n                    // unconditional request: send content of cache\r\n                    log.logInfo(\"CACHE HIT/203 \" + cacheFile.toString());\r\n                    \r\n                    // send cached header with replaced date and added length\r\n                    respondHeader(respond, \"203 OK\", cachedResponseHeader); // respond with 'non-authoritative'\r\n                    \r\n                    // make a transformer\r\n                    if ((!(transformer.isIdentityTransformer())) &&\r\n                        ((ext == null) || (!(switchboard.extensionBlack.contains(ext)))) &&\r\n                        ((cachedResponseHeader == null) || (httpd.isTextMime(cachedResponseHeader.mime(), switchboard.mimeWhite)))) {\r\n                        hfos = new htmlFilterOutputStream(respond, null, transformer, (ext.length() == 0));\r\n                    } else {\r\n                        hfos = respond;\r\n                    }\r\n                    \r\n                    // send also the complete body now from the cache\r\n                    // simply read the file and transfer to out socket\r\n                    InputStream is = null;\r\n                    try {\r\n\t                    is = new FileInputStream(cacheFile);\r\n\t                    byte[] buffer = new byte[2048];\r\n\t                    int l;\r\n\t                    while ((l = is.read(buffer)) > 0) {hfos.write(buffer, 0, l);}\r\n                    } finally {\r\n                        if (is != null) try { is.close(); } catch (Exception e) {}\r\n                    }\r\n                    if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                }\r\n                // that's it!\r\n            } catch (SocketException e) {\r\n                // this happens if the client stops loading the file\r\n                // we do nothing here\r\n                respondError(respond, \"111 socket error: \" + e.getMessage(), 1, url.toString());\r\n            }\r\n            respond.flush();\r\n            return;\r\n        }\r\n        \r\n        // the cache does either not exist or is (supposed to be) stale\r\n        long sizeBeforeDelete = -1;\r\n        if (cacheExists) {\r\n            // delete the cache\r\n            sizeBeforeDelete = cacheFile.length();\r\n            cacheFile.delete();\r\n        }\r\n        \r\n        // take a new file from the server\r\n        httpc remote = null;\r\n        httpc.response res = null;\r\n        \r\n        try {\r\n            // open the connection\r\n            if (yAddress == null) {\r\n                remote = newhttpc(host, port, timeout);\r\n            } else {\r\n                remote = newhttpc(yAddress, timeout);\r\n            }\r\n            //System.out.println(\"HEADER: CLIENT TO PROXY = \" + requestHeader.toString()); // DEBUG\r\n            \r\n            // send request\r\n            res = remote.GET(remotePath, requestHeader);\r\n            long contentLength = res.responseHeader.contentLength();\r\n            \r\n            // reserver cache entry\r\n            cacheEntry = cacheManager.newEntry(requestDate, 0, url, requestHeader, res.status, res.responseHeader, null, switchboard.defaultProxyProfile);\r\n            \r\n            // handle file types\r\n            if (((ext == null) || (!(switchboard.extensionBlack.contains(ext)))) &&\r\n                (httpd.isTextMime(res.responseHeader.mime(), switchboard.mimeWhite))) {\r\n\t\t\t\t// this is a file that is a possible candidate for parsing by the indexer\r\n                if (transformer.isIdentityTransformer()) {\r\n\t\t\t\t\tlog.logDebug(\"create passthrough (parse candidate) for url \" + url);\r\n\t\t\t\t\t// no transformation, only passthrough\r\n\t\t\t\t\t// this is especially the case if the bluelist is empty\r\n\t\t\t\t\t// in that case, the content is not scraped here but later\r\n                    hfos = respond;\r\n                } else {\r\n                    // make a scraper and transformer\r\n\t\t\t\t\tlog.logDebug(\"create scraper for url \" + url);\r\n                    scraper = new htmlFilterContentScraper(url);\r\n                    hfos = new htmlFilterOutputStream(respond, scraper, transformer, (ext.length() == 0));\r\n                    if (((htmlFilterOutputStream) hfos).binarySuspect()) {\r\n                        scraper = null; // forget it, may be rubbish\r\n                        log.logDebug(\"Content of \" + url + \" is probably binary. deleted scraper.\");\r\n                    }\r\n                    cacheEntry.scraper = scraper;\r\n                }\r\n            } else {\r\n                log.logDebug(\"Resource \" + url + \" has wrong extension (\" + ext + \") or wrong mime-type (\" + res.responseHeader.mime() + \"). not scraped\");\r\n                scraper = null;\r\n                hfos = respond;\r\n                cacheEntry.scraper = scraper;\r\n            }\r\n            \r\n            // handle incoming cookies\r\n            handleIncomingCookies(res.responseHeader, host, ip);\r\n            \r\n            // request has been placed and result has been returned. work off response\r\n            try {\r\n                respondHeader(respond, res.status, res.responseHeader);\r\n                String storeError;\r\n                if ((storeError = cacheEntry.shallStoreCache()) == null) {\r\n                    // we write a new cache entry\r\n                    if ((contentLength > 0) && // known\r\n                        (contentLength < 1048576)) {// 1 MB\r\n                        // ok, we don't write actually into a file, only to RAM, and schedule writing the file.\r\n                        byte[] cacheArray = res.writeContent(hfos);\r\n\t\t\t\t\t\tlog.logDebug(\"writeContent of \" + url + \" produced cacheArray = \" + ((cacheArray == null) ? \"null\" : (\"size=\" + cacheArray.length)));\r\n\r\n                        if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                        \r\n                        if (sizeBeforeDelete == -1) {\r\n                            // totally fresh file\r\n                            cacheEntry.status = plasmaHTCache.CACHE_FILL; // it's an insert\r\n                            cacheManager.stackProcess(cacheEntry, cacheArray);\r\n                        } else if (sizeBeforeDelete == cacheArray.length) {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheArray = null;\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_BAD;\r\n                            cacheManager.stackProcess(cacheEntry); // unnecessary update\r\n                        } else {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_GOOD;\r\n                            cacheManager.stackProcess(cacheEntry, cacheArray); // necessary update, write response header to cache\r\n                        }\r\n                    } else {\r\n                        // the file is too big to cache it in the ram, or the size is unknown\r\n\t\t\t\t\t\t// write to file right here.\r\n                        cacheFile.getParentFile().mkdirs();\r\n                        res.writeContent(hfos, cacheFile);\r\n                        if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n\t\t\t\t\t\tlog.logDebug(\"for write-file of \" + url + \": contentLength = \" + contentLength + \", sizeBeforeDelete = \" + sizeBeforeDelete);\r\n                        if (sizeBeforeDelete == -1) {\r\n                            // totally fresh file\r\n                            cacheEntry.status = plasmaHTCache.CACHE_FILL; // it's an insert\r\n                            cacheManager.stackProcess(cacheEntry);\r\n                        } else if (sizeBeforeDelete == cacheFile.length()) {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_BAD;\r\n                            cacheManager.stackProcess(cacheEntry); // unnecessary update\r\n                        } else {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheEntry.status = plasmaHTCache.CACHE_STALE_RELOAD_GOOD;\r\n                            cacheManager.stackProcess(cacheEntry); // necessary update, write response header to cache\r\n                        }\r\n\t\t\t\t\t\t// beware! all these writings will not fill the cacheEntry.cacheArray\r\n\t\t\t\t\t\t// that means they are not available for the indexer (except they are scraped before)\r\n                    }\r\n                } else {\r\n                    // no caching\r\n                    log.logDebug(cacheFile.toString() + \" not cached: \" + storeError);\r\n                    res.writeContent(hfos, null);\r\n                    if (hfos instanceof htmlFilterOutputStream) ((htmlFilterOutputStream) hfos).finalize();\r\n                    if (sizeBeforeDelete == -1) {\r\n                        // no old file and no load. just data passing\r\n                        cacheEntry.status = plasmaHTCache.CACHE_PASSING;\r\n                        cacheManager.stackProcess(cacheEntry);\r\n                    } else {\r\n                        // before we came here we deleted a cache entry\r\n                        cacheEntry.status = plasmaHTCache.CACHE_STALE_NO_RELOAD;\r\n                        cacheManager.stackProcess(cacheEntry);\r\n                    }\r\n                }\r\n            } catch (SocketException e) {\r\n                // this may happen if the client suddenly closes its connection\r\n                // maybe the user has stopped loading\r\n                // in that case, we are not responsible and just forget it\r\n                // but we clean the cache also, since it may be only partial\r\n                // and most possible corrupted\r\n                if (cacheFile.exists()) cacheFile.delete();\r\n                respondHeader(respond,\"404 client unexpectedly closed connection\", new httpHeader(null));\r\n            } catch (IOException e) {\r\n\t\t\t\t// can have various reasons\r\n                if (cacheFile.exists()) cacheFile.delete();\r\n\t\t\t\tif (e.getMessage().indexOf(\"Corrupt GZIP trailer\") >= 0) {\r\n\t\t\t\t    // just do nothing, we leave it this way\r\n\t\t\t\t\tlog.logDebug(\"ignoring bad gzip trail for URL \" + url + \" (\" + e.getMessage() + \")\");\r\n\t\t\t\t} else {\r\n\t\t\t\t    respondHeader(respond,\"404 client unexpectedly closed connection\", new httpHeader(null));\r\n\t\t\t\t\tlog.logDebug(\"IOError for URL \" + url + \" (\" + e.getMessage() + \") - responded 404\");\r\n\t\t\t\t    e.printStackTrace();\r\n\t\t\t\t}\r\n            }\r\n        } catch (Exception e) {\r\n            // this may happen if the targeted host does not exist or anything with the\r\n            // remote server was wrong.\r\n            // in any case, sending a 404 is appropriate\r\n            try {\r\n                if ((e.toString().indexOf(\"unknown host\")) > 0) {\r\n                    respondHeader(respond,\"404 unknown host\", new httpHeader(null));\r\n                } else {\r\n                    respondHeader(respond,\"404 Not Found\", new httpHeader(null));\r\n                    respond.write((\"Exception occurred:\\r\\n\").getBytes());\r\n                    respond.write((e.toString() + \"\\r\\n\").getBytes());\r\n                    respond.write((\"[TRACE: \").getBytes());\r\n                    e.printStackTrace(new PrintStream(respond));\r\n                    respond.write((\"]\\r\\n\").getBytes());\r\n                }\r\n            } catch (Exception ee) {}\r\n        } finally {\r\n            if (remote != null) httpc.returnInstance(remote);\r\n        }\r\n        respond.flush();\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void respondError(OutputStream respond, String origerror, int errorcase, String url) {\r\n        try {\r\n            // set rewrite values\r\n            serverObjects tp = new serverObjects();\r\n            tp.put(\"errormessage\", errorcase);\r\n            tp.put(\"httperror\", origerror);\r\n            tp.put(\"url\", url);\r\n            \r\n            // rewrite the file\r\n            File file = new File(htRootPath, \"/proxymsg/error.html\");\r\n            byte[] result;\r\n            ByteArrayOutputStream o = new ByteArrayOutputStream();\r\n            FileInputStream fis = new FileInputStream(file);\r\n            httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n            o.close();\r\n            result = o.toByteArray();\r\n            \r\n            // return header\r\n            httpHeader header = new httpHeader();\r\n            header.put(\"Date\", httpc.dateString(httpc.nowDate()));\r\n            header.put(\"Content-type\", \"text/html\");\r\n            header.put(\"Content-length\", \"\" + o.size());\r\n            header.put(\"Pragma\", \"no-cache\");\r\n            \r\n            // write the array to the client\r\n            respondHeader(respond, origerror, header);\r\n            serverFileUtils.write(result, respond);\r\n            respond.flush();\r\n        } catch (IOException e) {\r\n            \r\n        }\r\n    }","id":51594,"modified_method":"private void respondError(OutputStream respond, String origerror, int errorcase, String url) {\r\n        FileInputStream fis = null;\r\n        try {\r\n            // set rewrite values\r\n            serverObjects tp = new serverObjects();\r\n            tp.put(\"errormessage\", errorcase);\r\n            tp.put(\"httperror\", origerror);\r\n            tp.put(\"url\", url);\r\n            \r\n            // rewrite the file\r\n            File file = new File(htRootPath, \"/proxymsg/error.html\");\r\n            byte[] result;\r\n            ByteArrayOutputStream o = new ByteArrayOutputStream();\r\n            fis = new FileInputStream(file);\r\n            httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n            o.close();\r\n            result = o.toByteArray();\r\n            \r\n            // return header\r\n            httpHeader header = new httpHeader();\r\n            header.put(\"Date\", httpc.dateString(httpc.nowDate()));\r\n            header.put(\"Content-type\", \"text/html\");\r\n            header.put(\"Content-length\", \"\" + o.size());\r\n            header.put(\"Pragma\", \"no-cache\");\r\n            \r\n            // write the array to the client\r\n            respondHeader(respond, origerror, header);\r\n            serverFileUtils.write(result, respond);\r\n            respond.flush();\r\n        } catch (IOException e) {            \r\n        } finally {\r\n\t\t\tif (fis != null) try { fis.close(); } catch (Exception e) {}\r\n        }\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static TreeMap loadBlacklist(String mapname, String filenames, String sep) {\r\n\tTreeMap map = new TreeMap();\r\n        if (switchboard == null) return map; // not initialized yet\r\n\tFile listsPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"listsPath\", \"DATA/LISTS\"));\r\n        String filenamesarray[] = filenames.split(\",\");\r\n\tString filename = \"\";\r\n\tif(filenamesarray.length >0)\r\n\t    for(int i = 0; i < filenamesarray.length; i++)\r\n\t\tmap.putAll(loadMap(mapname, (new File(listsPath, filenamesarray[i])).toString(), sep));\r\n\treturn map;\r\n    }","id":51595,"modified_method":"public static TreeMap loadBlacklist(String mapname, String filenames, String sep) {\r\n\t\tTreeMap map = new TreeMap();\r\n\t\tif (switchboard == null) return map; // not initialized yet\r\n\t\tFile listsPath = new File(switchboard.getRootPath(), switchboard.getConfig(\"listsPath\", \"DATA/LISTS\"));\r\n\t\tString filenamesarray[] = filenames.split(\",\");\r\n\r\n\t\tif(filenamesarray.length >0)\r\n\t\t\tfor(int i = 0; i < filenamesarray.length; i++)\r\n\t\t\t\tmap.putAll(loadMap(mapname, (new File(listsPath, filenamesarray[i])).toString(), sep));\r\n\t\treturn map;\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static HashSet loadSet(String setname, String filename) {\r\n\tHashSet set = new HashSet();\r\n\ttry {\r\n\t    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\r\n\t    String line;\r\n\t    while ((line = br.readLine()) != null) {\r\n\t\tline = line.trim();\r\n\t\tif ((line.length() > 0) && (!(line.startsWith(\"#\")))) set.add(line.trim().toLowerCase());\r\n\t    }\r\n\t    br.close();\r\n\t    serverLog.logInfo(\"PROXY\", \"read \" + setname + \" set from file \" + filename);\r\n\t} catch (IOException e) {}\r\n\treturn set;\r\n    }","id":51596,"modified_method":"private static HashSet loadSet(String setname, String filename) {\r\n\t\tHashSet set = new HashSet();\r\n        BufferedReader br = null;\r\n\t\ttry {\r\n\t\t    br = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\r\n\t\t    String line;\r\n\t\t    while ((line = br.readLine()) != null) {\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif ((line.length() > 0) && (!(line.startsWith(\"#\")))) set.add(line.trim().toLowerCase());\r\n\t\t    }\r\n\t\t    br.close();\r\n\t\t    serverLog.logInfo(\"PROXY\", \"read \" + setname + \" set from file \" + filename);\r\n\t\t} catch (IOException e) {\r\n\t\t} finally {\r\n            if (br != null) try { br.close(); } catch (Exception e) {}\r\n\t\t}\r\n\t\treturn set;\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void copy(InputStream source, File dest) throws IOException {\r\n        FileOutputStream fos = new FileOutputStream(dest);\r\n        copy(source, fos);\r\n        fos.close();\r\n    }","id":51597,"modified_method":"public static void copy(InputStream source, File dest) throws IOException {\r\n        FileOutputStream fos = null;\r\n        try {\r\n\t\t\tfos = new FileOutputStream(dest);\r\n\t\t\tcopy(source, fos);\r\n        } finally {\r\n\t\t\tif (fos != null) try {fos.close();} catch (Exception e) {}\r\n        }\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void copy(File source, File dest) throws IOException {\r\n        FileInputStream fis = new FileInputStream(source);\r\n        FileOutputStream fos = new FileOutputStream(dest);\r\n        copy(fis, fos);\r\n        fis.close();\r\n        fos.close();\r\n    }","id":51598,"modified_method":"public static void copy(File source, File dest) throws IOException {\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n\t        fis = new FileInputStream(source);\r\n\t        fos = new FileOutputStream(dest);\r\n\t        copy(fis, fos);\r\n        } finally {\r\n            if (fis != null) try {fis.close();} catch (Exception e) {}\r\n            if (fos != null) try {fos.close();} catch (Exception e) {}            \r\n        }\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static byte[] read(File source) throws IOException {\r\n        byte[] buffer = new byte[(int) source.length()];\r\n        InputStream fis = new FileInputStream(source);\r\n        int p = 0;\r\n        int c;\r\n\twhile ((c = fis.read(buffer, p, buffer.length - p)) > 0) p += c;\r\n\tfis.close();\r\n        return buffer;\r\n    }","id":51599,"modified_method":"public static byte[] read(File source) throws IOException {\r\n\t\tbyte[] buffer = new byte[(int) source.length()];\r\n\t\tInputStream fis = null;\r\n        try {\r\n\t        fis = new FileInputStream(source);\r\n\t\t\tint p = 0, c;\r\n\t\t\twhile ((c = fis.read(buffer, p, buffer.length - p)) > 0) p += c;\r\n        } finally {\r\n            if (fis != null) try { fis.close(); } catch (Exception e) {}\r\n        }\r\n\t\treturn buffer;\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void copy(File source, OutputStream dest) throws IOException {\r\n\tInputStream fis = new FileInputStream(source);\r\n        copy(fis, dest);\r\n\tfis.close();\r\n    }","id":51600,"modified_method":"public static void copy(File source, OutputStream dest) throws IOException {\r\n\t\tInputStream fis = null;\r\n        try {\r\n\t\t\tfis = new FileInputStream(source);\r\n\t\t\tcopy(fis, dest);\r\n        } finally {\r\n            if (fis != null) try { fis.close(); } catch (Exception e) {}\r\n        }\r\n    }","commit_id":"cbdc499ba656aa68f85304c978ddf09600862c62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, InputStream body) throws IOException {\r\n        \r\n        this.connectionProperties = conProp;\r\n        \r\n        String path = null;\r\n        try {\r\n            // getting some connection properties            \r\n            String method = conProp.getProperty(httpHeader.CONNECTION_PROP_METHOD);\r\n            path = conProp.getProperty(httpHeader.CONNECTION_PROP_PATH);\r\n            String argsString = conProp.getProperty(httpHeader.CONNECTION_PROP_ARGS); // is null if no args were given\r\n            String httpVersion= conProp.getProperty(httpHeader.CONNECTION_PROP_HTTP_VER);\r\n            \r\n            // check hack attacks in path\r\n            if (path.indexOf(\"..\") >= 0) {\r\n                httpd.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\r\n                return;\r\n            }\r\n            \r\n            // url decoding of path\r\n            try {\r\n                path = URLDecoder.decode(path, \"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                // This should never occur\r\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\r\n            }\r\n            \r\n            // check permission/granted access\r\n            String authorization = (String) requestHeader.get(httpHeader.AUTHORIZATION);\r\n            String adminAccountBase64MD5 = switchboard.getConfig(\"adminAccountBase64MD5\", \"\");\r\n            \r\n            int pos = path.lastIndexOf(\".\");\r\n            \r\n            if ((path.substring(0,(pos==-1)?path.length():pos)).endsWith(\"_p\") && (adminAccountBase64MD5.length() != 0)) {\r\n                //authentication required\r\n                //userDB\r\n                if(sb.userDB.hasAdminRight(authorization, conProp.getProperty(\"CLIENTIP\"), requestHeader.getHeaderCookies())){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //static\r\n                }else if(authorization != null && sb.staticAdminAuthenticated(authorization.trim().substring(6))==4){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //no auth\r\n                }else if (authorization == null) {\r\n                    // no authorization given in response. Ask for that\r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    //httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    serverObjects tp=new serverObjects();\r\n                    tp.put(\"returnto\", path);\r\n                    //TODO: separate errorpage Wrong Login / No Login\r\n                    httpd.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, headers);\r\n                    return;\r\n                } else {\r\n                    // a wrong authentication was given or the userDB user does not have admin access. Ask again\r\n                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                    serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                    if (attempts == null)\r\n                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                    else\r\n                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n    \r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    return;\r\n                }\r\n            }\r\n        \r\n        \r\n            // parse arguments\r\n            serverObjects args = new serverObjects();\r\n            int argc;\r\n            if (argsString == null) {\r\n                // no args here, maybe a POST with multipart extension\r\n                int length = 0;\r\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n                if (method.equals(httpHeader.METHOD_POST)) {\r\n    \r\n                    GZIPInputStream gzipBody = null;\r\n                    if (requestHeader.containsKey(httpHeader.CONTENT_LENGTH)) {\r\n                        length = Integer.parseInt((String) requestHeader.get(httpHeader.CONTENT_LENGTH));\r\n                    } else if (requestHeader.gzip()) {\r\n                        length = -1;\r\n                        gzipBody = new GZIPInputStream(body);\r\n                    }\r\n    //                } else {\r\n    //                    httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null); \r\n    //                    return;\r\n    //                }\r\n                    \r\n                    // if its a POST, it can be either multipart or as args in the body\r\n                    if ((requestHeader.containsKey(httpHeader.CONTENT_TYPE)) &&\r\n                            (((String) requestHeader.get(httpHeader.CONTENT_TYPE)).toLowerCase().startsWith(\"multipart\"))) {\r\n                        // parse multipart\r\n                        HashMap files = httpd.parseMultipart(requestHeader, args, (gzipBody!=null)?gzipBody:body, length);\r\n                        // integrate these files into the args\r\n                        if (files != null) {\r\n                            Iterator fit = files.entrySet().iterator();\r\n                            Map.Entry entry;\r\n                            while (fit.hasNext()) {\r\n                                entry = (Map.Entry) fit.next();\r\n                                args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                            }\r\n                        }\r\n                        argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n                    } else {\r\n                        // parse args in body\r\n                        argc = httpd.parseArgs(args, (gzipBody!=null)?gzipBody:body, length);\r\n                    }\r\n                } else {\r\n                    // no args\r\n                    argsString = null;\r\n                    args = null;\r\n                    argc = 0;\r\n                }\r\n            } else {\r\n                // simple args in URL (stuff after the \"?\")\r\n                argc = httpd.parseArgs(args, argsString);\r\n            }\r\n        \r\n            // check for cross site scripting - attacks in request arguments\r\n            if (argc > 0) {\r\n                // check all values for occurrences of script values\r\n                Enumeration e = args.elements(); // enumeration of values\r\n                Object val;\r\n                while (e.hasMoreElements()) {\r\n                    val = e.nextElement();\r\n                    if ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n                        // deny request\r\n                        httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        \r\n            // we are finished with parsing\r\n            // the result of value hand-over is in args and argc\r\n            if (path.length() == 0) {\r\n                httpd.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\r\n                out.flush();\r\n                return;\r\n            }\r\n            File targetClass=null;\r\n\r\n            // locate the file\r\n            if (!(path.startsWith(\"/\"))) path = \"/\" + path; // attach leading slash\r\n            File   targetFile  = getLocalizedFile(path);\r\n            String targetExt   = conProp.getProperty(\"EXT\",\"\");\r\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\r\n            if (path.endsWith(\"/\")) {\r\n                String testpath;\r\n                // attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    targetFile = getOverlayedFile(testpath);\r\n                    targetClass=getOverlayedClass(testpath);\r\n                    if (targetFile.exists()) {\r\n                        path = testpath;\r\n                        break;\r\n                    }\r\n                }\r\n                //no defaultfile, send a dirlisting\r\n                if(targetFile == null || !targetFile.exists()){\r\n                    targetFile = getOverlayedFile(\"/htdocsdefault/dir.html\");\r\n                    targetClass=getOverlayedClass(\"/htdocsdefault/dir.html\");\r\n                    if(! (( targetFile != null && targetFile.exists()) && ( targetClass != null && targetClass.exists())) ){\r\n                        httpd.sendRespondError(this.connectionProperties,out,3,500,\"dir.html or dir.class not found.\",null,null);\r\n                    }\r\n                }\r\n            }else{\r\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\r\n                    if ( !(targetFile.exists()) && !((path.endsWith(\"png\")||path.endsWith(\"gif\")||path.endsWith(\".stream\"))&&targetClass!=null ) ){\r\n                        targetFile = new File(htDocsPath, path);\r\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\r\n                    }\r\n                \r\n            }\r\n            \r\n            //File targetClass = rewriteClassFile(targetFile);\r\n            //We need tp here\r\n            serverObjects tp = new serverObjects();\r\n            Date targetDate;\r\n            boolean nocache = false;\r\n            \r\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\r\n                // call an image-servlet to produce an on-the-fly - generated image\r\n                Object img = null;\r\n                try {\r\n                    requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                    requestHeader.put(\"PATH\", path);\r\n                    // in case that there are no args given, args = null or empty hashmap\r\n                    img = invokeServlet(targetClass, requestHeader, args);\r\n                } catch (InvocationTargetException e) {\r\n                    this.theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                    e.getMessage() +\r\n                    \" target exception at \" + targetClass + \": \" +\r\n                    e.getTargetException().toString() + \":\" +\r\n                    e.getTargetException().getMessage() +\r\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\",e);\r\n                    targetClass = null;\r\n                }\r\n                if (img == null) {\r\n                    // error with image generation; send file-not-found\r\n                    httpd.sendRespondError(this.connectionProperties,out,3,404,\"File not Found\",null,null);\r\n                } else {\r\n                    if (img instanceof ymagePainter) {\r\n                        ymagePainter yp = (ymagePainter) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        // ymagePNGEncoderJDE jde = new\r\n                        // ymagePNGEncoderJDE((ymageMatrixPainter) yp,\r\n                        // ymagePNGEncoderJDE.FILTER_NONE, 0);\r\n                        // byte[] result = jde.pngEncode();\r\n                        ImageIO.write(ymagePNGEncoderAWT.toImage(\r\n                                        (ymageMatrixPainter) yp, true),\r\n                                        targetExt, baos);\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(this.connectionProperties, out,\r\n                                httpVersion, 200, null, mimeType,\r\n                                result.length, targetDate, null, null, null,\r\n                                null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                    if (img instanceof Image) {\r\n                        Image i = (Image) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        int width = i.getWidth(null);\r\n                        int height = i.getHeight(null);\r\n                        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null); \r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        ImageIO.write(bi, targetExt, baos);\r\n\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(this.connectionProperties, out,\r\n                                httpVersion, 200, null, mimeType,\r\n                                result.length, targetDate, null, null, null,\r\n                                null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                }\r\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\r\n                // call rewrite-class\r\n                requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                requestHeader.put(\"PATH\", path);\r\n                requestHeader.put(\"INPUTSTREAM\", body);\r\n                requestHeader.put(\"OUTPUTSTREAM\", out);\r\n             \r\n                httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, 200, null);                \r\n                \r\n                // in case that there are no args given, args = null or empty hashmap\r\n                /* serverObjects tp = (serverObjects) */ invokeServlet(targetClass, requestHeader, args);\r\n                this.forceConnectionClose();\r\n                return;                \r\n            } else if ((targetFile.exists()) && (targetFile.canRead())) {\r\n                // we have found a file that can be written to the client\r\n                // if this file uses templates, then we use the template\r\n                // re-write - method to create an result\r\n                String mimeType = mimeTable.getProperty(targetExt,\"text/html\");\r\n                byte[] result;\r\n                boolean zipContent = requestHeader.acceptGzip() && httpd.shallTransportZipped(\".\" + conProp.getProperty(\"EXT\",\"\"));\r\n                if (path.endsWith(\"html\") || \r\n                        path.endsWith(\"xml\") || \r\n                        path.endsWith(\"rss\") || \r\n                        path.endsWith(\"csv\") ||\r\n                        path.endsWith(\"pac\") ||\r\n                        path.endsWith(\"src\") ||\r\n                        path.endsWith(\"/\")) {\r\n                            \r\n                    /*targetFile = getLocalizedFile(path);\r\n\t\t\t\t\tif (!(targetFile.exists())) {\r\n\t\t                // try to find that file in the htDocsPath\r\n\t\t\t\t        File trialFile = new File(htDocsPath, path);\r\n\t\t\t\t\t\tif (trialFile.exists()) targetFile = trialFile;\r\n\t\t            }*/\r\n            \r\n                    \r\n                    // call rewrite-class\r\n                   \r\n                    if (targetClass == null) {\r\n                        targetDate = new Date(targetFile.lastModified());\r\n                    } else {\r\n                        // CGI-class: call the class to create a property for rewriting\r\n                        try {\r\n                            requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(\"PATH\", path);\r\n                            // in case that there are no args given, args = null or empty hashmap\r\n                            tp = (serverObjects) invokeServlet(targetClass, requestHeader, args);\r\n                            // if no args given , then tp will be an empty Hashtable object (not null)\r\n                            if (tp == null) tp = new serverObjects();\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(\"AUTHENTICATE\")) {\r\n                                // handle brute-force protection\r\n                                if (authorization != null) {\r\n                                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                                    serverLog.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                                    if (attempts == null)\r\n                                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                                    else\r\n                                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n                                }\r\n                                // send authentication request to browser\r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + tp.get(\"AUTHENTICATE\", \"\") + \"\\\"\");\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                                return;\r\n                            } else if (tp.containsKey(\"LOCATION\")) {\r\n                                String location = tp.get(\"LOCATION\",\"\");\r\n                                if (location.length() == 0) location = path;\r\n                                \r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.setCookieVector(tp.getOutgoingHeader().getCookieVector()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n                                headers.put(httpHeader.LOCATION,location);\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,302,headers);\r\n                                return;\r\n                            }\r\n                            // add the application version, the uptime and the client name to every rewrite table\r\n                            tp.put(\"version\", switchboard.getConfig(\"version\", \"\"));\r\n                            tp.put(\"uptime\", ((System.currentTimeMillis() - Long.parseLong(switchboard.getConfig(\"startupTime\",\"0\"))) / 1000) / 60); // uptime in minutes\r\n                            tp.put(\"clientname\", switchboard.getConfig(\"peerName\", \"anomic\"));\r\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n                        } catch (InvocationTargetException e) {\r\n                            if (e.getCause() instanceof InterruptedException) {\r\n                                throw new InterruptedException(e.getCause().getMessage());\r\n                            }                            \r\n                            \r\n                            this.theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                                    e.getMessage() +\r\n                                    \" target exception at \" + targetClass + \": \" +\r\n                                    e.getTargetException().toString() + \":\" +\r\n                                    e.getTargetException().getMessage(),e);\r\n                            targetClass = null;\r\n                            throw e;\r\n                        }\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                    }\r\n                    // read templates\r\n                    tp.putAll(templates);\r\n                    \r\n                    // rewrite the file\r\n                    serverByteBuffer o = null;\r\n                    InputStream fis = null;\r\n                    GZIPOutputStream zippedOut = null;\r\n                    try {\r\n                        // do fileCaching here\r\n                        byte[] templateContent = null;\r\n                        if (useTemplateCache) {\r\n                            long fileSize = targetFile.length();\r\n                            if (fileSize <= 512*1024) {\r\n                                SoftReference ref = (SoftReference) templateCache.get(targetFile);\r\n                                if (ref != null) {\r\n                                    templateContent = (byte[]) ref.get();\r\n                                    if (templateContent == null) \r\n                                        templateCache.remove(targetFile);                               \r\n                                }\r\n                                \r\n                                if (templateContent == null) {\r\n                                    // loading the content of the template file into a byte array\r\n                                    templateContent = serverFileUtils.read(targetFile);\r\n                                    \r\n                                    // storing the content into the cache\r\n                                    ref = new SoftReference(templateContent);\r\n                                    templateCache.put(targetFile,ref);\r\n                                    if (this.theLogger.isLoggable(Level.FINEST))\r\n                                        this.theLogger.logFinest(\"Cache MISS for file \" + targetFile);\r\n                                } else {\r\n                                    if (this.theLogger.isLoggable(Level.FINEST))\r\n                                        this.theLogger.logFinest(\"Cache HIT for file \" + targetFile);\r\n                                }\r\n                                \r\n                                // creating an inputstream needed by the template rewrite function\r\n                                fis = new ByteArrayInputStream(templateContent);                            \r\n                                templateContent = null;\r\n                            } else {\r\n                                fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                            }\r\n                        } else {\r\n                            fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                        }\r\n                        \r\n                        //use the page template\r\n                        String supertemplate=\"\";\r\n                        if(tp.containsKey(\"SUPERTEMPLATE\")){\r\n                            supertemplate=(String) tp.get(\"SUPERTEMPLATE\");\r\n                        }\r\n                        //if(sb.getConfig(\"usePageTemplate\", \"false\").equals(\"true\")){    \r\n                        if(!supertemplate.equals(\"\")){\r\n                            o = new serverByteBuffer();\r\n                            /*File pageFile=getOverlayedFile(\"/env/page.html\");\r\n                            File pageClass=getOverlayedClass(\"/env/page.html\");*/\r\n                            File pageFile=getOverlayedFile(supertemplate);\r\n                            File pageClass=getOverlayedClass(supertemplate);\r\n                            if(pageFile != null && pageFile.exists()){\r\n                                //warning: o,tp and fis are reused\r\n                                httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n                                \r\n                                if (pageClass != null && pageClass.exists()) \r\n                                    tp = (serverObjects) invokeServlet(pageClass, requestHeader, args);\r\n                                else\r\n                                    tp = new serverObjects();\r\n                                tp.put(\"page\", o.toString());\r\n                                fis=new BufferedInputStream(new FileInputStream(pageFile));\r\n                                \r\n                            }\r\n                        }\r\n                            \r\n                        o = new serverByteBuffer();\r\n                        if (zipContent) zippedOut = new GZIPOutputStream(o);\r\n                        httpTemplate.writeTemplate(fis, (zipContent) ? (OutputStream)zippedOut: (OutputStream)o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        if (zipContent) {\r\n                            zippedOut.finish();\r\n                            zippedOut.flush();\r\n                            zippedOut.close();\r\n                            zippedOut = null;\r\n                        }\r\n                        \r\n                        result = o.toByteArray();\r\n                        \r\n                        if (this.md5Digest != null) {\r\n                            this.md5Digest.reset();\r\n                            this.md5Digest.update(result);\r\n                            byte[] digest = this.md5Digest.digest();\r\n                            StringBuffer digestString = new StringBuffer();\r\n                            for ( int i = 0; i < digest.length; i++ )\r\n                                digestString.append(Integer.toHexString( digest[i]&0xff));\r\n\r\n                        }                        \r\n                    } finally {\r\n                        if (zippedOut != null) try {zippedOut.close();} catch(Exception e) {}\r\n                        if (o != null) try {o.close(); o = null;} catch(Exception e) {}\r\n                        if (fis != null) try {fis.close(); fis=null;} catch(Exception e) {}\r\n                    }\r\n                    \r\n                    // write the array to the client\r\n                    long contentLength     = result.length;\r\n                    String contentEncoding = (zipContent)?\"gzip\":null;\r\n                    httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, 200, null, mimeType, contentLength, targetDate, null, tp.getOutgoingHeader(), contentEncoding, null, nocache);\r\n                    if (! method.equals(httpHeader.METHOD_HEAD)) {\r\n                        Thread.sleep(200); // this solved the message problem (!!)\r\n                        serverFileUtils.write(result, out);\r\n                    }                    \r\n                    \r\n                } else { // no html\r\n                    \r\n                    int statusCode = 200;\r\n                    int rangeStartOffset = 0;\r\n                    httpHeader header = new httpHeader();\r\n                    \r\n                    // adding the accept ranges header\r\n                    header.put(httpHeader.ACCEPT_RANGES, \"bytes\");\r\n                    \r\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\r\n                    String targetMD5 = null;\r\n                    File targetMd5File = new File(targetFile + \".md5\");\r\n                    try {\r\n                        if (targetMd5File.exists()) {\r\n                            //String description = null;\r\n                            targetMD5 = new String(serverFileUtils.read(targetMd5File));\r\n                            pos = targetMD5.indexOf('\\n');\r\n                           if (pos >= 0) {\r\n                               //description = targetMD5.substring(pos + 1);\r\n                               targetMD5 = targetMD5.substring(0, pos);\r\n                           }         \r\n                           \r\n                           // using the checksum as ETAG header\r\n                           header.put(httpHeader.ETAG, targetMD5);\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }                        \r\n                    \r\n                    if (requestHeader.containsKey(httpHeader.RANGE)) {\r\n                        Object ifRange = requestHeader.ifRange();\r\n                        if ((ifRange == null)||\r\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\r\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\r\n                            String rangeHeaderVal = ((String) requestHeader.get(httpHeader.RANGE)).trim();\r\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\r\n                                String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\r\n                                String[] ranges = rangesVal.split(\",\");\r\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\r\n                                    rangeStartOffset = Integer.valueOf(ranges[0].substring(0,ranges[0].length()-1)).intValue();\r\n                                    statusCode = 206;\r\n                                    if (header == null) header = new httpHeader();\r\n                                    header.put(httpHeader.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // write the file to the client\r\n                    targetDate = new Date(targetFile.lastModified());\r\n                    long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\r\n                    String contentEncoding  = (zipContent)?\"gzip\":null;\r\n                    String transferEncoding = (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1))?null:(zipContent)?\"chunked\":null;\r\n                    if (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1) && zipContent) forceConnectionClose();\r\n                    \r\n                    httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, null, header, contentEncoding, transferEncoding, nocache);\r\n                \r\n                    if (!method.equals(httpHeader.METHOD_HEAD)) {                        \r\n                        httpChunkedOutputStream chunkedOut = null;\r\n                        GZIPOutputStream zipped = null;\r\n                        OutputStream newOut = out;\r\n                        \r\n                        if (transferEncoding != null) {\r\n                            chunkedOut = new httpChunkedOutputStream(newOut);\r\n                            newOut = chunkedOut;\r\n                        }\r\n                        if (contentEncoding != null) {\r\n                            zipped = new GZIPOutputStream(newOut);\r\n                            newOut = zipped;\r\n                        }\r\n                        \r\n                        serverFileUtils.copyRange(targetFile,newOut,rangeStartOffset);\r\n                        \r\n                        if (zipped != null) {\r\n                            zipped.flush();\r\n                            zipped.finish();\r\n                        }\r\n                        if (chunkedOut != null) {\r\n                            chunkedOut.finish();\r\n                        }\r\n                    }   \r\n                    \r\n                    // check mime type again using the result array: these are 'magics'\r\n//                    if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                    //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                }\r\n            } else {\r\n                httpd.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\r\n                return;\r\n            }\r\n        } catch (Exception e) {     \r\n            try {\r\n                // doing some errorhandling ...\r\n                int httpStatusCode = 400; \r\n                String httpStatusText = null; \r\n                StringBuffer errorMessage = new StringBuffer(); \r\n                Exception errorExc = null;            \r\n                \r\n                String errorMsg = e.getMessage();\r\n                if (\r\n                        (e instanceof InterruptedException) ||\r\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\r\n                   ) {\r\n                    errorMessage.append(\"Interruption detected while processing query.\");\r\n                    httpStatusCode = 503;\r\n                } else {\r\n                    if ((errorMsg != null) && \r\n                        (\r\n                           errorMsg.startsWith(\"Broken pipe\") || \r\n                           errorMsg.startsWith(\"Connection reset\") ||\r\n                           errorMsg.startsWith(\"Software caused connection abort\")                           \r\n                       )) {\r\n                        // client closed the connection, so we just end silently\r\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\r\n                    } else if ((errorMsg != null) && (errorMsg.startsWith(\"Connection timed out\"))) {\r\n                        errorMessage.append(\"Connection timed out.\");\r\n                    } else {\r\n                        errorMessage.append(\"Unexpected error while processing query.\");\r\n                        httpStatusCode = 500;\r\n                        errorExc = e;\r\n                    }\r\n                }\r\n                \r\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\r\n                            .append(\"\\nQuery:   \").append(path)\r\n                            .append(\"\\nClient:  \").append(conProp.getProperty(httpHeader.CONNECTION_PROP_CLIENTIP,\"unknown\")) \r\n                            .append(\"\\nReason:  \").append(e.toString());    \r\n                \r\n                if (!conProp.containsKey(httpHeader.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                    // sending back an error message to the client \r\n                    // if we have not already send an http header\r\n                    httpd.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(),errorExc);\r\n                } else {\r\n                    // otherwise we close the connection\r\n                    this.forceConnectionClose();\r\n                }    \r\n                \r\n                // if it is an unexpected error we log it \r\n                if (httpStatusCode == 500) {\r\n                    this.theLogger.logWarning(errorMessage.toString(),e);\r\n                }\r\n                \r\n            } catch (Exception ee) {\r\n                this.forceConnectionClose();\r\n            }            \r\n            \r\n        } finally {\r\n            try {out.flush();}catch (Exception e) {}\r\n            if (((String)requestHeader.get(httpHeader.CONNECTION, \"close\")).indexOf(\"keep-alive\") == -1) {\r\n                // wait a little time until everything closes so that clients can read from the streams/sockets\r\n                try {Thread.sleep(1000);} catch (InterruptedException e) {}\r\n            }\r\n        }\r\n    }","id":51601,"modified_method":"public void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, InputStream body) throws IOException {\r\n        \r\n        this.connectionProperties = conProp;\r\n        \r\n        String path = null;\r\n        try {\r\n            // getting some connection properties            \r\n            String method = conProp.getProperty(httpHeader.CONNECTION_PROP_METHOD);\r\n            path = conProp.getProperty(httpHeader.CONNECTION_PROP_PATH);\r\n            String argsString = conProp.getProperty(httpHeader.CONNECTION_PROP_ARGS); // is null if no args were given\r\n            String httpVersion= conProp.getProperty(httpHeader.CONNECTION_PROP_HTTP_VER);\r\n            \r\n            // check hack attacks in path\r\n            if (path.indexOf(\"..\") >= 0) {\r\n                httpd.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\r\n                return;\r\n            }\r\n            \r\n            // url decoding of path\r\n            try {\r\n                path = URLDecoder.decode(path, \"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                // This should never occur\r\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\r\n            }\r\n            \r\n            // check permission/granted access\r\n            String authorization = (String) requestHeader.get(httpHeader.AUTHORIZATION);\r\n            String adminAccountBase64MD5 = switchboard.getConfig(\"adminAccountBase64MD5\", \"\");\r\n            \r\n            int pos = path.lastIndexOf(\".\");\r\n            \r\n            if ((path.substring(0,(pos==-1)?path.length():pos)).endsWith(\"_p\") && (adminAccountBase64MD5.length() != 0)) {\r\n                //authentication required\r\n                //userDB\r\n                if(sb.userDB.hasAdminRight(authorization, conProp.getProperty(\"CLIENTIP\"), requestHeader.getHeaderCookies())){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //static\r\n                }else if(authorization != null && sb.staticAdminAuthenticated(authorization.trim().substring(6))==4){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //no auth\r\n                }else if (authorization == null) {\r\n                    // no authorization given in response. Ask for that\r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    //httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    serverObjects tp=new serverObjects();\r\n                    tp.put(\"returnto\", path);\r\n                    //TODO: separate errorpage Wrong Login / No Login\r\n                    httpd.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, headers);\r\n                    return;\r\n                } else {\r\n                    // a wrong authentication was given or the userDB user does not have admin access. Ask again\r\n                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                    serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                    if (attempts == null)\r\n                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                    else\r\n                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n    \r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    return;\r\n                }\r\n            }\r\n        \r\n        \r\n            // parse arguments\r\n            serverObjects args = new serverObjects();\r\n            int argc;\r\n            if (argsString == null) {\r\n                // no args here, maybe a POST with multipart extension\r\n                int length = 0;\r\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n                if (method.equals(httpHeader.METHOD_POST)) {\r\n    \r\n                    GZIPInputStream gzipBody = null;\r\n                    if (requestHeader.containsKey(httpHeader.CONTENT_LENGTH)) {\r\n                        length = Integer.parseInt((String) requestHeader.get(httpHeader.CONTENT_LENGTH));\r\n                    } else if (requestHeader.gzip()) {\r\n                        length = -1;\r\n                        gzipBody = new GZIPInputStream(body);\r\n                    }\r\n    //                } else {\r\n    //                    httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null); \r\n    //                    return;\r\n    //                }\r\n                    \r\n                    // if its a POST, it can be either multipart or as args in the body\r\n                    if ((requestHeader.containsKey(httpHeader.CONTENT_TYPE)) &&\r\n                            (((String) requestHeader.get(httpHeader.CONTENT_TYPE)).toLowerCase().startsWith(\"multipart\"))) {\r\n                        // parse multipart\r\n                        HashMap files = httpd.parseMultipart(requestHeader, args, (gzipBody!=null)?gzipBody:body, length);\r\n                        // integrate these files into the args\r\n                        if (files != null) {\r\n                            Iterator fit = files.entrySet().iterator();\r\n                            Map.Entry entry;\r\n                            while (fit.hasNext()) {\r\n                                entry = (Map.Entry) fit.next();\r\n                                args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                            }\r\n                        }\r\n                        argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n                    } else {\r\n                        // parse args in body\r\n                        argc = httpd.parseArgs(args, (gzipBody!=null)?gzipBody:body, length);\r\n                    }\r\n                } else {\r\n                    // no args\r\n                    argsString = null;\r\n                    args = null;\r\n                    argc = 0;\r\n                }\r\n            } else {\r\n                // simple args in URL (stuff after the \"?\")\r\n                argc = httpd.parseArgs(args, argsString);\r\n            }\r\n        \r\n            // check for cross site scripting - attacks in request arguments\r\n            if (argc > 0) {\r\n                // check all values for occurrences of script values\r\n                Enumeration e = args.elements(); // enumeration of values\r\n                Object val;\r\n                while (e.hasMoreElements()) {\r\n                    val = e.nextElement();\r\n                    if ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n                        // deny request\r\n                        httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        \r\n            // we are finished with parsing\r\n            // the result of value hand-over is in args and argc\r\n            if (path.length() == 0) {\r\n                httpd.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\r\n                out.flush();\r\n                return;\r\n            }\r\n            File targetClass=null;\r\n\r\n            // locate the file\r\n            if (!(path.startsWith(\"/\"))) path = \"/\" + path; // attach leading slash\r\n            File   targetFile  = getLocalizedFile(path);\r\n            String targetExt   = conProp.getProperty(\"EXT\",\"\");\r\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\r\n            if (path.endsWith(\"/\")) {\r\n                String testpath;\r\n                // attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    targetFile = getOverlayedFile(testpath);\r\n                    targetClass=getOverlayedClass(testpath);\r\n                    if (targetFile.exists()) {\r\n                        path = testpath;\r\n                        break;\r\n                    }\r\n                }\r\n                //no defaultfile, send a dirlisting\r\n                if(targetFile == null || !targetFile.exists()){\r\n                    targetFile = getOverlayedFile(\"/htdocsdefault/dir.html\");\r\n                    targetClass=getOverlayedClass(\"/htdocsdefault/dir.html\");\r\n                    if(! (( targetFile != null && targetFile.exists()) && ( targetClass != null && targetClass.exists())) ){\r\n                        httpd.sendRespondError(this.connectionProperties,out,3,500,\"dir.html or dir.class not found.\",null,null);\r\n                    }\r\n                }\r\n            }else{\r\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\r\n                    if ( !(targetFile.exists()) && !((path.endsWith(\"png\")||path.endsWith(\"gif\")||path.endsWith(\".stream\"))&&targetClass!=null ) ){\r\n                        targetFile = new File(htDocsPath, path);\r\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\r\n                    }\r\n                \r\n            }\r\n            \r\n            //File targetClass = rewriteClassFile(targetFile);\r\n            //We need tp here\r\n            serverObjects tp = new serverObjects();\r\n            Date targetDate;\r\n            boolean nocache = false;\r\n            \r\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\r\n                // call an image-servlet to produce an on-the-fly - generated image\r\n                Object img = null;\r\n                try {\r\n                    requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                    requestHeader.put(\"PATH\", path);\r\n                    // in case that there are no args given, args = null or empty hashmap\r\n                    img = invokeServlet(targetClass, requestHeader, args);\r\n                } catch (InvocationTargetException e) {\r\n                    this.theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                    e.getMessage() +\r\n                    \" target exception at \" + targetClass + \": \" +\r\n                    e.getTargetException().toString() + \":\" +\r\n                    e.getTargetException().getMessage() +\r\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\",e);\r\n                    targetClass = null;\r\n                }\r\n                if (img == null) {\r\n                    // error with image generation; send file-not-found\r\n                    httpd.sendRespondError(this.connectionProperties,out,3,404,\"File not Found\",null,null);\r\n                } else {\r\n                    if (img instanceof ymagePainter) {\r\n                        ymagePainter yp = (ymagePainter) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        // ymagePNGEncoderJDE jde = new\r\n                        // ymagePNGEncoderJDE((ymageMatrixPainter) yp,\r\n                        // ymagePNGEncoderJDE.FILTER_NONE, 0);\r\n                        // byte[] result = jde.pngEncode();\r\n                        ImageIO.write(ymagePNGEncoderAWT.toImage(\r\n                                        (ymageMatrixPainter) yp, true),\r\n                                        targetExt, baos);\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(this.connectionProperties, out,\r\n                                httpVersion, 200, null, mimeType,\r\n                                result.length, targetDate, null, null, null,\r\n                                null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                    if (img instanceof Image) {\r\n                        Image i = (Image) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        int width = i.getWidth(null);\r\n                        int height = i.getHeight(null);\r\n                        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null); \r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        ImageIO.write(bi, targetExt, baos);\r\n\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(this.connectionProperties, out,\r\n                                httpVersion, 200, null, mimeType,\r\n                                result.length, targetDate, null, null, null,\r\n                                null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                }\r\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\r\n                // call rewrite-class\r\n                requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                requestHeader.put(\"PATH\", path);\r\n                requestHeader.put(\"INPUTSTREAM\", body);\r\n                requestHeader.put(\"OUTPUTSTREAM\", out);\r\n             \r\n                httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, 200, null);                \r\n                \r\n                // in case that there are no args given, args = null or empty hashmap\r\n                /* serverObjects tp = (serverObjects) */ invokeServlet(targetClass, requestHeader, args);\r\n                this.forceConnectionClose();\r\n                return;                \r\n            } else if ((targetFile.exists()) && (targetFile.canRead())) {\r\n                // we have found a file that can be written to the client\r\n                // if this file uses templates, then we use the template\r\n                // re-write - method to create an result\r\n                String mimeType = mimeTable.getProperty(targetExt,\"text/html\");\r\n                byte[] result;\r\n                boolean zipContent = requestHeader.acceptGzip() && httpd.shallTransportZipped(\".\" + conProp.getProperty(\"EXT\",\"\"));\r\n                if (path.endsWith(\"html\") || \r\n                        path.endsWith(\"xml\") || \r\n                        path.endsWith(\"rss\") || \r\n                        path.endsWith(\"csv\") ||\r\n                        path.endsWith(\"pac\") ||\r\n                        path.endsWith(\"src\") ||\r\n                        path.endsWith(\"/\")) {\r\n                            \r\n                    /*targetFile = getLocalizedFile(path);\r\n\t\t\t\t\tif (!(targetFile.exists())) {\r\n\t\t                // try to find that file in the htDocsPath\r\n\t\t\t\t        File trialFile = new File(htDocsPath, path);\r\n\t\t\t\t\t\tif (trialFile.exists()) targetFile = trialFile;\r\n\t\t            }*/\r\n            \r\n                    \r\n                    // call rewrite-class\r\n                   \r\n                    if (targetClass == null) {\r\n                        targetDate = new Date(targetFile.lastModified());\r\n                    } else {\r\n                        // CGI-class: call the class to create a property for rewriting\r\n                        try {\r\n                            requestHeader.put(\"CLIENTIP\", conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(\"PATH\", path);\r\n                            // in case that there are no args given, args = null or empty hashmap\r\n                            tp = (serverObjects) invokeServlet(targetClass, requestHeader, args);\r\n                            // if no args given , then tp will be an empty Hashtable object (not null)\r\n                            if (tp == null) tp = new serverObjects();\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(\"AUTHENTICATE\")) {\r\n                                // handle brute-force protection\r\n                                if (authorization != null) {\r\n                                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                                    serverLog.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                                    if (attempts == null)\r\n                                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                                    else\r\n                                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n                                }\r\n                                // send authentication request to browser\r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + tp.get(\"AUTHENTICATE\", \"\") + \"\\\"\");\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                                return;\r\n                            } else if (tp.containsKey(\"LOCATION\")) {\r\n                                String location = tp.get(\"LOCATION\",\"\");\r\n                                if (location.length() == 0) location = path;\r\n                                \r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.setCookieVector(tp.getOutgoingHeader().getCookieVector()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n                                headers.put(httpHeader.LOCATION,location);\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,302,headers);\r\n                                return;\r\n                            }\r\n                            // add the application version, the uptime and the client name to every rewrite table\r\n                            tp.put(\"version\", switchboard.getConfig(\"version\", \"\"));\r\n                            tp.put(\"uptime\", ((System.currentTimeMillis() - Long.parseLong(switchboard.getConfig(\"startupTime\",\"0\"))) / 1000) / 60); // uptime in minutes\r\n                            tp.put(\"clientname\", switchboard.getConfig(\"peerName\", \"anomic\"));\r\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n                        } catch (InvocationTargetException e) {\r\n                            if (e.getCause() instanceof InterruptedException) {\r\n                                throw new InterruptedException(e.getCause().getMessage());\r\n                            }                            \r\n                            \r\n                            this.theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                                    e.getMessage() +\r\n                                    \" target exception at \" + targetClass + \": \" +\r\n                                    e.getTargetException().toString() + \":\" +\r\n                                    e.getTargetException().getMessage(),e);\r\n                            targetClass = null;\r\n                            throw e;\r\n                        }\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                    }\r\n                    // read templates\r\n                    tp.putAll(templates);\r\n                    \r\n                    // rewrite the file\r\n                    serverByteBuffer o = null;\r\n                    InputStream fis = null;\r\n                    GZIPOutputStream zippedOut = null;\r\n                    try {\r\n                        // do fileCaching here\r\n                        byte[] templateContent = null;\r\n                        if (useTemplateCache) {\r\n                            long fileSize = targetFile.length();\r\n                            if (fileSize <= 512*1024) {\r\n                                SoftReference ref = (SoftReference) templateCache.get(targetFile);\r\n                                if (ref != null) {\r\n                                    templateContent = (byte[]) ref.get();\r\n                                    if (templateContent == null) \r\n                                        templateCache.remove(targetFile);                               \r\n                                }\r\n                                \r\n                                if (templateContent == null) {\r\n                                    // loading the content of the template file into a byte array\r\n                                    templateContent = serverFileUtils.read(targetFile);\r\n                                    \r\n                                    // storing the content into the cache\r\n                                    ref = new SoftReference(templateContent);\r\n                                    templateCache.put(targetFile,ref);\r\n                                    if (this.theLogger.isLoggable(Level.FINEST))\r\n                                        this.theLogger.logFinest(\"Cache MISS for file \" + targetFile);\r\n                                } else {\r\n                                    if (this.theLogger.isLoggable(Level.FINEST))\r\n                                        this.theLogger.logFinest(\"Cache HIT for file \" + targetFile);\r\n                                }\r\n                                \r\n                                // creating an inputstream needed by the template rewrite function\r\n                                fis = new ByteArrayInputStream(templateContent);                            \r\n                                templateContent = null;\r\n                            } else {\r\n                                fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                            }\r\n                        } else {\r\n                            fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                        }\r\n                        \r\n                        //use the page template\r\n                        String supertemplate=\"\";\r\n                        if(tp.containsKey(\"SUPERTEMPLATE\")){\r\n                            supertemplate=(String) tp.get(\"SUPERTEMPLATE\");\r\n                        }\r\n                        //if(sb.getConfig(\"usePageTemplate\", \"false\").equals(\"true\")){    \r\n                        if(!supertemplate.equals(\"\")){\r\n                            File pageFile=getOverlayedFile(supertemplate); //typically /env/page.html\r\n                            File pageClass=getOverlayedClass(supertemplate);\r\n                            if(pageFile != null && pageFile.exists()){\r\n                                //warning: o,tp and fis are reused\r\n                                //this replaces the normal template function (below), and the\r\n                                //normal function is used for supertemplates.\r\n                                \r\n                                //search for header Data\r\n                                //XXX: This part may be slow :-(\r\n                                BufferedReader br=new BufferedReader(new InputStreamReader(fis));\r\n                                String line;\r\n                                boolean inheader=false;\r\n                                StringBuffer header=new StringBuffer();\r\n                                StringBuffer content=new StringBuffer();\r\n                                String content_s,header_s;\r\n                                while((line=br.readLine())!=null){\r\n                                    if(!inheader){\r\n                                        if(line.startsWith(\"<!--HEADER\")){\r\n                                            inheader=true;\r\n                                        }else{\r\n                                            content.append(line);\r\n                                        }\r\n                                    }else{\r\n                                        if(line.endsWith(\"HEADER-->\")){\r\n                                            inheader=false;\r\n                                        }else{\r\n                                            header.append(line);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                \r\n                                //tp is from the servlet, fis is the content-only from the servlet\r\n                                //this resolvs templates in both header and content\r\n                                o = new serverByteBuffer();\r\n                                fis=new ByteArrayInputStream(content.toString().getBytes());\r\n                                httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n                                content_s=o.toString();\r\n                                o = new serverByteBuffer();\r\n                                fis=new ByteArrayInputStream(header.toString().getBytes());\r\n                                httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes());\r\n                                header_s=o.toString();\r\n                                \r\n                                //further processing of page.html (via page.class)?\r\n                                if (pageClass != null && pageClass.exists()) \r\n                                    tp = (serverObjects) invokeServlet(pageClass, requestHeader, args);\r\n                                else\r\n                                    tp = new serverObjects();\r\n                                tp.put(\"header\", header_s);\r\n                                tp.put(\"page\", content_s);\r\n                                fis=new BufferedInputStream(new FileInputStream(pageFile));\r\n                                \r\n                            }\r\n                        }\r\n                            \r\n                        o = new serverByteBuffer();\r\n                        if (zipContent) zippedOut = new GZIPOutputStream(o);\r\n                        httpTemplate.writeTemplate(fis, (zipContent) ? (OutputStream)zippedOut: (OutputStream)o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        if (zipContent) {\r\n                            zippedOut.finish();\r\n                            zippedOut.flush();\r\n                            zippedOut.close();\r\n                            zippedOut = null;\r\n                        }\r\n                        \r\n                        result = o.toByteArray();\r\n                        \r\n                        if (this.md5Digest != null) {\r\n                            this.md5Digest.reset();\r\n                            this.md5Digest.update(result);\r\n                            byte[] digest = this.md5Digest.digest();\r\n                            StringBuffer digestString = new StringBuffer();\r\n                            for ( int i = 0; i < digest.length; i++ )\r\n                                digestString.append(Integer.toHexString( digest[i]&0xff));\r\n\r\n                        }                        \r\n                    } finally {\r\n                        if (zippedOut != null) try {zippedOut.close();} catch(Exception e) {}\r\n                        if (o != null) try {o.close(); o = null;} catch(Exception e) {}\r\n                        if (fis != null) try {fis.close(); fis=null;} catch(Exception e) {}\r\n                    }\r\n                    \r\n                    // write the array to the client\r\n                    long contentLength     = result.length;\r\n                    String contentEncoding = (zipContent)?\"gzip\":null;\r\n                    httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, 200, null, mimeType, contentLength, targetDate, null, tp.getOutgoingHeader(), contentEncoding, null, nocache);\r\n                    if (! method.equals(httpHeader.METHOD_HEAD)) {\r\n                        Thread.sleep(200); // this solved the message problem (!!)\r\n                        serverFileUtils.write(result, out);\r\n                    }                    \r\n                    \r\n                } else { // no html\r\n                    \r\n                    int statusCode = 200;\r\n                    int rangeStartOffset = 0;\r\n                    httpHeader header = new httpHeader();\r\n                    \r\n                    // adding the accept ranges header\r\n                    header.put(httpHeader.ACCEPT_RANGES, \"bytes\");\r\n                    \r\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\r\n                    String targetMD5 = null;\r\n                    File targetMd5File = new File(targetFile + \".md5\");\r\n                    try {\r\n                        if (targetMd5File.exists()) {\r\n                            //String description = null;\r\n                            targetMD5 = new String(serverFileUtils.read(targetMd5File));\r\n                            pos = targetMD5.indexOf('\\n');\r\n                           if (pos >= 0) {\r\n                               //description = targetMD5.substring(pos + 1);\r\n                               targetMD5 = targetMD5.substring(0, pos);\r\n                           }         \r\n                           \r\n                           // using the checksum as ETAG header\r\n                           header.put(httpHeader.ETAG, targetMD5);\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }                        \r\n                    \r\n                    if (requestHeader.containsKey(httpHeader.RANGE)) {\r\n                        Object ifRange = requestHeader.ifRange();\r\n                        if ((ifRange == null)||\r\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\r\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\r\n                            String rangeHeaderVal = ((String) requestHeader.get(httpHeader.RANGE)).trim();\r\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\r\n                                String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\r\n                                String[] ranges = rangesVal.split(\",\");\r\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\r\n                                    rangeStartOffset = Integer.valueOf(ranges[0].substring(0,ranges[0].length()-1)).intValue();\r\n                                    statusCode = 206;\r\n                                    if (header == null) header = new httpHeader();\r\n                                    header.put(httpHeader.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // write the file to the client\r\n                    targetDate = new Date(targetFile.lastModified());\r\n                    long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\r\n                    String contentEncoding  = (zipContent)?\"gzip\":null;\r\n                    String transferEncoding = (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1))?null:(zipContent)?\"chunked\":null;\r\n                    if (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1) && zipContent) forceConnectionClose();\r\n                    \r\n                    httpd.sendRespondHeader(this.connectionProperties, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, null, header, contentEncoding, transferEncoding, nocache);\r\n                \r\n                    if (!method.equals(httpHeader.METHOD_HEAD)) {                        \r\n                        httpChunkedOutputStream chunkedOut = null;\r\n                        GZIPOutputStream zipped = null;\r\n                        OutputStream newOut = out;\r\n                        \r\n                        if (transferEncoding != null) {\r\n                            chunkedOut = new httpChunkedOutputStream(newOut);\r\n                            newOut = chunkedOut;\r\n                        }\r\n                        if (contentEncoding != null) {\r\n                            zipped = new GZIPOutputStream(newOut);\r\n                            newOut = zipped;\r\n                        }\r\n                        \r\n                        serverFileUtils.copyRange(targetFile,newOut,rangeStartOffset);\r\n                        \r\n                        if (zipped != null) {\r\n                            zipped.flush();\r\n                            zipped.finish();\r\n                        }\r\n                        if (chunkedOut != null) {\r\n                            chunkedOut.finish();\r\n                        }\r\n                    }   \r\n                    \r\n                    // check mime type again using the result array: these are 'magics'\r\n//                    if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                    //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                }\r\n            } else {\r\n                httpd.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\r\n                return;\r\n            }\r\n        } catch (Exception e) {     \r\n            try {\r\n                // doing some errorhandling ...\r\n                int httpStatusCode = 400; \r\n                String httpStatusText = null; \r\n                StringBuffer errorMessage = new StringBuffer(); \r\n                Exception errorExc = null;            \r\n                \r\n                String errorMsg = e.getMessage();\r\n                if (\r\n                        (e instanceof InterruptedException) ||\r\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\r\n                   ) {\r\n                    errorMessage.append(\"Interruption detected while processing query.\");\r\n                    httpStatusCode = 503;\r\n                } else {\r\n                    if ((errorMsg != null) && \r\n                        (\r\n                           errorMsg.startsWith(\"Broken pipe\") || \r\n                           errorMsg.startsWith(\"Connection reset\") ||\r\n                           errorMsg.startsWith(\"Software caused connection abort\")                           \r\n                       )) {\r\n                        // client closed the connection, so we just end silently\r\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\r\n                    } else if ((errorMsg != null) && (errorMsg.startsWith(\"Connection timed out\"))) {\r\n                        errorMessage.append(\"Connection timed out.\");\r\n                    } else {\r\n                        errorMessage.append(\"Unexpected error while processing query.\");\r\n                        httpStatusCode = 500;\r\n                        errorExc = e;\r\n                    }\r\n                }\r\n                \r\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\r\n                            .append(\"\\nQuery:   \").append(path)\r\n                            .append(\"\\nClient:  \").append(conProp.getProperty(httpHeader.CONNECTION_PROP_CLIENTIP,\"unknown\")) \r\n                            .append(\"\\nReason:  \").append(e.toString());    \r\n                \r\n                if (!conProp.containsKey(httpHeader.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                    // sending back an error message to the client \r\n                    // if we have not already send an http header\r\n                    httpd.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(),errorExc);\r\n                } else {\r\n                    // otherwise we close the connection\r\n                    this.forceConnectionClose();\r\n                }    \r\n                \r\n                // if it is an unexpected error we log it \r\n                if (httpStatusCode == 500) {\r\n                    this.theLogger.logWarning(errorMessage.toString(),e);\r\n                }\r\n                \r\n            } catch (Exception ee) {\r\n                this.forceConnectionClose();\r\n            }            \r\n            \r\n        } finally {\r\n            try {out.flush();}catch (Exception e) {}\r\n            if (((String)requestHeader.get(httpHeader.CONNECTION, \"close\")).indexOf(\"keep-alive\") == -1) {\r\n                // wait a little time until everything closes so that clients can read from the streams/sockets\r\n                try {Thread.sleep(1000);} catch (InterruptedException e) {}\r\n            }\r\n        }\r\n    }","commit_id":"a29b4d4fb52b450076c58897b7bcee21a50db075","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(\r\n        final RequestHeader header,\r\n        final serverObjects post,\r\n        final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n\r\n        // check if the basic configuration was accessed before and forward\r\n        prop.put(\"forwardToConfigBasic\", 0);\r\n        if ( (post == null || !post.containsKey(\"noforward\"))\r\n            && sb.getConfig(\"server.servlets.submitted\", \"\").indexOf(\"ConfigBasic.html\", 0) < 0\r\n            && Seed.isDefaultPeerName(sb.peers.mySeed().getName()) ) {\r\n            // forward to ConfigBasic\r\n            prop.put(\"forwardToConfigBasic\", 1);\r\n        }\r\n        if ( post != null ) {\r\n            post.remove(\"noforward\");\r\n        }\r\n\r\n        if ( post != null && !post.isEmpty() ) {\r\n            if ( sb.adminAuthenticated(header) < 2 ) {\r\n            \tprop.authenticationRequired();\r\n                return prop;\r\n            }\r\n            boolean redirect = false;\r\n            if ( post.containsKey(\"login\") ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            } else if ( post.containsKey(\"pauseCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"user demand on Status.html\");\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"user demand on Status.html\");\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"continueCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"ResetTraffic\") ) {\r\n                ByteCount.resetCount();\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"popup\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"popup\");\r\n                sb.setConfig(\"browserPopUpTrigger\", trigger_enabled);\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"tray\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"tray\");\r\n                sb.setConfig(\"trayIcon\", trigger_enabled);\r\n                redirect = true;\r\n            }\r\n\r\n            if ( redirect ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            }\r\n        }\r\n\r\n        // update seed info\r\n        //sb.updateMySeed(); // don't do this here. if Solr is stuck, this makes it worse. And it prevents that we can click on the Thread Dump menu.\r\n\r\n        final boolean adminaccess = sb.adminAuthenticated(header) >= 2;\r\n        if ( adminaccess ) {\r\n            prop.put(\"showPrivateTable\", \"1\");\r\n            prop.put(\"privateStatusTable\", \"Status_p.inc\");\r\n        } else {\r\n            prop.put(\"showPrivateTable\", \"0\");\r\n            prop.put(\"privateStatusTable\", \"\");\r\n        }\r\n\r\n        // password protection\r\n        if ( (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty())\r\n            && (!sb.getConfigBool(SwitchboardConstants.ADMIN_ACCOUNT_FOR_LOCALHOST, false)) ) {\r\n            prop.put(\"protection\", \"0\"); // not protected\r\n            prop.put(\"urgentSetPassword\", \"1\");\r\n        } else {\r\n            prop.put(\"protection\", \"1\"); // protected\r\n        }\r\n\r\n        if ( sb.getConfigBool(SwitchboardConstants.ADMIN_ACCOUNT_FOR_LOCALHOST, false) ) {\r\n            prop.put(\"unrestrictedLocalAccess\", 1);\r\n        }\r\n\r\n        // resource observer status\r\n        if ( adminaccess ) {\r\n            if ( !sb.observer.getDiskAvailable() ) {\r\n                final String minFree = Formatter.bytesToString(sb.observer.getMinFreeDiskSteadystate());\r\n                prop.put(\"warningDiskSpaceLow\", \"1\");\r\n                prop.put(\"warningDiskSpaceLow_minSpace\", minFree);\r\n            }\r\n            if ( !sb.observer.getMemoryAvailable() ) {\r\n                final String minFree =\r\n                    Formatter.bytesToString(sb.observer.getMinFreeMemory() * 1024L * 1024L);\r\n                prop.put(\"warningMemoryLow\", \"1\");\r\n                prop.put(\"warningMemoryLow_minSpace\", minFree);\r\n            }\r\n\r\n        }\r\n\r\n        // version information\r\n        //final String versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\r\n        final String versionstring =\r\n            yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision();\r\n        prop.put(\"versionpp\", versionstring);\r\n\r\n        // place some more hints\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() == 0) {\r\n            prop.put(\"hintCrawlStart\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 500) {\r\n            prop.put(\"hintCrawlMonitor\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && \"intranet|webportal|allip\".indexOf(env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\")) >= 0) {\r\n            prop.put(\"hintSupport\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\r\n            prop.put(\"warningCrawlPaused\", \"1\");\r\n        }\r\n\r\n        // hostname and port\r\n        final String extendedPortString = sb.getConfig(\"port\", \"8090\");\r\n        final int pos = extendedPortString.indexOf(':', 0);\r\n        prop.put(\"port\", extendedPortString);\r\n        if ( pos != -1 ) {\r\n            prop.put(\"extPortFormat\", \"1\");\r\n            prop.putHTML(\"extPortFormat_extPort\", extendedPortString);\r\n        } else {\r\n            prop.put(\"extPortFormat\", \"0\");\r\n        }\r\n        final InetAddress hostIP = Domains.myPublicLocalIP();\r\n        prop.put(\"host\", hostIP != null ? hostIP.getHostAddress() : \"Unkown IP\");\r\n\r\n        // ssl support\r\n        prop.put(\"sslSupport\", sb.getConfig(\"keyStore\", \"\").isEmpty() || !sb.getConfigBool(\"server.https\", false) ? 0 : 1);\r\n        if (sb.getConfigBool(\"server.https\", false)) prop.put(\"sslSupport_sslPort\", sb.getHttpServer().getSslPort());\r\n        \r\n        // proxy information\r\n        if ( sb.getConfigBool(\"remoteProxyUse\", false) ) {\r\n            prop.put(\"remoteProxy\", \"1\");\r\n            prop.putXML(\"remoteProxy_host\", sb.getConfig(\"remoteProxyHost\", \"<unknown>\"));\r\n            prop.putXML(\"remoteProxy_port\", sb.getConfig(\"remoteProxyPort\", \"<unknown>\"));\r\n            prop.put(\"remoteProxy_4Yacy\", sb.getConfigBool(\"remoteProxyUse4Yacy\", true) ? \"0\" : \"1\");\r\n        } else {\r\n            prop.put(\"remoteProxy\", \"0\"); // not used\r\n        }\r\n        prop.put(\"info_isTransparentProxy\", sb.getConfigBool(\"isTransparentProxy\", false) ? \"0\" : \"1\");\r\n        prop.put(\"info_proxyURL\", sb.getConfigBool(\"proxyURL\", false) ? \"0\" : \"1\");\r\n        \r\n        // peer information\r\n        String thisHash = \"\";\r\n        final String thisName = sb.peers.mySeed().getName();\r\n        if ( sb.peers.mySeed() == null ) {\r\n            thisHash = \"not assigned\";\r\n            prop.put(\"peerAddress\", \"0\"); // not assigned\r\n            prop.put(\"peerStatistics\", \"0\"); // unknown\r\n        } else {\r\n            final long uptime = 60000 * sb.peers.mySeed().getLong(Seed.UPTIME, 0L);\r\n            prop.put(\"peerStatistics\", \"1\");\r\n            prop.put(\"peerStatistics_uptime\", PeerActions.formatInterval(uptime));\r\n            prop.putNum(\"peerStatistics_pagesperminute\", sb.peers.mySeed().getPPM());\r\n            prop.putNum(\r\n                \"peerStatistics_queriesperhour\",\r\n                Math.round(6000d * sb.peers.mySeed().getQPM()) / 100d);\r\n            prop.putNum(\"peerStatistics_links\", sb.peers.mySeed().getLinkCount());\r\n            prop.put(\"peerStatistics_words\", Formatter.number(sb.peers.mySeed().getWordCount()));\r\n            prop.putNum(\"peerStatistics_disconnects\", sb.peers.peerActions.disconnects);\r\n            prop.put(\"peerStatistics_connects\", Formatter.number(sb.peers.mySeed().get(Seed.CCOUNT, \"0\")));\r\n            thisHash = sb.peers.mySeed().hash;\r\n            if ( sb.peers.mySeed().getPublicAddress() == null ) {\r\n                prop.put(\"peerAddress\", \"0\"); // not assigned + instructions\r\n                prop.put(\"warningGoOnline\", \"1\");\r\n            } else {\r\n                prop.put(\"peerAddress\", \"1\"); // Address\r\n                prop.put(\"peerAddress_address\", sb.peers.mySeed().getPublicAddress());\r\n                prop.putXML(\"peerAddress_peername\", sb.peers.mySeed().getName().toLowerCase());\r\n            }\r\n        }\r\n        final String peerStatus =\r\n            ((sb.peers.mySeed() == null) ? Seed.PEERTYPE_VIRGIN : sb.peers.mySeed().get(\r\n                Seed.PEERTYPE,\r\n                Seed.PEERTYPE_VIRGIN));\r\n\r\n        if ( Seed.PEERTYPE_VIRGIN.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"0\");\r\n            prop.put(\"urgentStatusVirgin\", \"1\");\r\n        } else if ( Seed.PEERTYPE_JUNIOR.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"1\");\r\n            prop.put(\"warningStatusJunior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_SENIOR.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"2\");\r\n            prop.put(\"hintStatusSenior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_PRINCIPAL.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"3\");\r\n            prop.put(\"hintStatusPrincipal\", \"1\");\r\n            prop.putHTML(\"hintStatusPrincipal_seedURL\", sb.peers.mySeed().get(Seed.SEEDLISTURL, \"?\"));\r\n        }\r\n        prop.putHTML(\"peerName\", thisName);\r\n        prop.put(\"hash\", thisHash);\r\n\r\n        final String seedUploadMethod = sb.getConfig(\"seedUploadMethod\", \"\");\r\n        if ( !\"none\".equalsIgnoreCase(seedUploadMethod)\r\n            || (\"\".equals(seedUploadMethod) && (sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 || sb\r\n                .getConfig(\"seedFilePath\", \"\")\r\n                .length() > 0)) ) {\r\n            if ( \"\".equals(seedUploadMethod) ) {\r\n                if ( sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"Ftp\");\r\n                }\r\n                if ( sb.getConfig(\"seedFilePath\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"File\");\r\n                }\r\n            }\r\n\r\n            if ( \"ftp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedFTPServer\", \"\"));\r\n            } else if ( \"scp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedScpServer\", \"\"));\r\n            } else if ( \"file\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"2\"); // enabled\r\n                prop.putHTML(\"seedServer_seedFile\", sb.getConfig(\"seedFilePath\", \"\"));\r\n            }\r\n            prop.put(\r\n                \"seedServer_lastUpload\",\r\n                PeerActions.formatInterval(System.currentTimeMillis() - sb.peers.lastSeedUpload_timeStamp));\r\n        } else {\r\n            prop.put(SEEDSERVER, \"0\"); // disabled\r\n        }\r\n\r\n        if ( sb.peers != null && sb.peers.sizeConnected() > 0 ) {\r\n            prop.put(\"otherPeers\", \"1\");\r\n            prop.putNum(\"otherPeers_num\", sb.peers.sizeConnected());\r\n        } else {\r\n            prop.put(\"otherPeers\", \"0\"); // not online\r\n        }\r\n\r\n        if ( !sb.getConfigBool(\"browserPopUpTrigger\", false) ) {\r\n            prop.put(\"popup\", \"0\");\r\n        } else {\r\n            prop.put(\"popup\", \"1\");\r\n        }\r\n\r\n        if ( !OS.isWindows ) {\r\n            prop.put(\"tray\", \"2\");\r\n        } else if ( !sb.getConfigBool(\"trayIcon\", false) ) {\r\n            prop.put(\"tray\", \"0\");\r\n        } else {\r\n            prop.put(\"tray\", \"1\");\r\n        }\r\n\r\n        // memory usage and system attributes\r\n        prop.put(\"usedMemory\", Formatter.bytesToString(MemoryControl.used()));\r\n        prop.put(\"maxMemory\", Formatter.bytesToString(MemoryControl.maxMemory()));\r\n        prop.put(\"usedDisk\", Formatter.bytesToString(sb.observer.getSizeOfDataPath(true)));\r\n        prop.put(\"freeDisk\", Formatter.bytesToString(sb.observer.getUsableSpace()));\r\n        prop.put(\"processors\", WorkflowProcessor.availableCPU);\r\n        prop.put(\"load\", Memory.load());\r\n\r\n        // proxy traffic\r\n        //prop.put(\"trafficIn\",bytesToString(httpdByteCountInputStream.getGlobalCount()));\r\n        prop.put(\"trafficProxy\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.PROXY)));\r\n        prop.put(\"trafficCrawler\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.CRAWLER)));\r\n\r\n        // connection information\r\n        final YaCyHttpServer httpd =  sb.getHttpServer();\r\n\r\n        prop.putNum(\"connectionsActive\", httpd.getJobCount());\r\n        prop.putNum(\"connectionsMax\", httpd.getMaxSessionCount());\r\n\r\n        // Queue information\r\n        final int loaderJobCount = sb.crawlQueues.activeWorkerEntries().size();\r\n        final int loaderMaxCount = sb.getConfigInt(SwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX, 10);\r\n        final int loaderPercent = (loaderMaxCount == 0) ? 0 : loaderJobCount * 100 / loaderMaxCount;\r\n        prop.putNum(\"loaderQueueSize\", loaderJobCount);\r\n        prop.putNum(\"loaderQueueMax\", loaderMaxCount);\r\n        prop.put(\"loaderQueuePercent\", (loaderPercent > 100) ? 100 : loaderPercent);\r\n\r\n        prop.putNum(\"localCrawlQueueSize\", sb\r\n            .getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            .getJobCount());\r\n        prop.put(\"localCrawlPaused\", sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            ? \"1\"\r\n            : \"0\");\r\n\r\n        prop.putNum(\r\n            \"remoteTriggeredCrawlQueueSize\",\r\n            sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL).getJobCount());\r\n        prop.put(\r\n            \"remoteTriggeredCrawlPaused\",\r\n            sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL) ? \"1\" : \"0\");\r\n\r\n        prop.putNum(\"stackCrawlQueueSize\", sb.crawlStacker.size());\r\n\r\n        // return rewrite properties\r\n        prop.put(\"date\", (new Date()).toString());\r\n        return prop;\r\n    }","id":51602,"modified_method":"public static serverObjects respond(\r\n        final RequestHeader header,\r\n        final serverObjects post,\r\n        final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n\r\n        // check if the basic configuration was accessed before and forward\r\n        prop.put(\"forwardToConfigBasic\", 0);\r\n        if ((post == null || !post.containsKey(\"noforward\")) && sb.getConfig(\"server.servlets.called\", \"\").indexOf(\"ConfigBasic.html\", 0) < 0) {\r\n            // forward to ConfigBasic\r\n            prop.put(\"forwardToConfigBasic\", 1);\r\n        }\r\n        if ( post != null ) {\r\n            post.remove(\"noforward\");\r\n        }\r\n\r\n        if ( post != null && !post.isEmpty() ) {\r\n            if ( sb.adminAuthenticated(header) < 2 ) {\r\n            \tprop.authenticationRequired();\r\n                return prop;\r\n            }\r\n            boolean redirect = false;\r\n            if ( post.containsKey(\"login\") ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            } else if ( post.containsKey(\"pauseCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"user demand on Status.html\");\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"user demand on Status.html\");\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"continueCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"ResetTraffic\") ) {\r\n                ByteCount.resetCount();\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"popup\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"popup\");\r\n                sb.setConfig(\"browserPopUpTrigger\", trigger_enabled);\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"tray\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"tray\");\r\n                sb.setConfig(\"trayIcon\", trigger_enabled);\r\n                redirect = true;\r\n            }\r\n\r\n            if ( redirect ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            }\r\n        }\r\n\r\n        // update seed info\r\n        //sb.updateMySeed(); // don't do this here. if Solr is stuck, this makes it worse. And it prevents that we can click on the Thread Dump menu.\r\n\r\n        final boolean adminaccess = sb.adminAuthenticated(header) >= 2;\r\n        if ( adminaccess ) {\r\n            prop.put(\"showPrivateTable\", \"1\");\r\n            prop.put(\"privateStatusTable\", \"Status_p.inc\");\r\n        } else {\r\n            prop.put(\"showPrivateTable\", \"0\");\r\n            prop.put(\"privateStatusTable\", \"\");\r\n        }\r\n\r\n        // password protection\r\n        if ( (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty())\r\n            && (!sb.getConfigBool(SwitchboardConstants.ADMIN_ACCOUNT_FOR_LOCALHOST, false)) ) {\r\n            prop.put(\"protection\", \"0\"); // not protected\r\n            prop.put(\"urgentSetPassword\", \"1\");\r\n        } else {\r\n            prop.put(\"protection\", \"1\"); // protected\r\n        }\r\n\r\n        if ( sb.getConfigBool(SwitchboardConstants.ADMIN_ACCOUNT_FOR_LOCALHOST, false) ) {\r\n            prop.put(\"unrestrictedLocalAccess\", 1);\r\n        }\r\n\r\n        // resource observer status\r\n        if ( adminaccess ) {\r\n            if ( !sb.observer.getDiskAvailable() ) {\r\n                final String minFree = Formatter.bytesToString(sb.observer.getMinFreeDiskSteadystate());\r\n                prop.put(\"warningDiskSpaceLow\", \"1\");\r\n                prop.put(\"warningDiskSpaceLow_minSpace\", minFree);\r\n            }\r\n            if ( !sb.observer.getMemoryAvailable() ) {\r\n                final String minFree =\r\n                    Formatter.bytesToString(sb.observer.getMinFreeMemory() * 1024L * 1024L);\r\n                prop.put(\"warningMemoryLow\", \"1\");\r\n                prop.put(\"warningMemoryLow_minSpace\", minFree);\r\n            }\r\n\r\n        }\r\n\r\n        // version information\r\n        //final String versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\r\n        final String versionstring =\r\n            yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision();\r\n        prop.put(\"versionpp\", versionstring);\r\n\r\n        // place some more hints\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() == 0) {\r\n            prop.put(\"hintCrawlStart\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 500) {\r\n            prop.put(\"hintCrawlMonitor\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && \"intranet|webportal|allip\".indexOf(env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\")) >= 0) {\r\n            prop.put(\"hintSupport\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\r\n            prop.put(\"warningCrawlPaused\", \"1\");\r\n        }\r\n\r\n        // hostname and port\r\n        final String extendedPortString = sb.getConfig(\"port\", \"8090\");\r\n        final int pos = extendedPortString.indexOf(':', 0);\r\n        prop.put(\"port\", extendedPortString);\r\n        if ( pos != -1 ) {\r\n            prop.put(\"extPortFormat\", \"1\");\r\n            prop.putHTML(\"extPortFormat_extPort\", extendedPortString);\r\n        } else {\r\n            prop.put(\"extPortFormat\", \"0\");\r\n        }\r\n        final InetAddress hostIP = Domains.myPublicLocalIP();\r\n        prop.put(\"host\", hostIP != null ? hostIP.getHostAddress() : \"Unkown IP\");\r\n\r\n        // ssl support\r\n        prop.put(\"sslSupport\", sb.getConfig(\"keyStore\", \"\").isEmpty() || !sb.getConfigBool(\"server.https\", false) ? 0 : 1);\r\n        if (sb.getConfigBool(\"server.https\", false)) prop.put(\"sslSupport_sslPort\", sb.getHttpServer().getSslPort());\r\n        \r\n        // proxy information\r\n        if ( sb.getConfigBool(\"remoteProxyUse\", false) ) {\r\n            prop.put(\"remoteProxy\", \"1\");\r\n            prop.putXML(\"remoteProxy_host\", sb.getConfig(\"remoteProxyHost\", \"<unknown>\"));\r\n            prop.putXML(\"remoteProxy_port\", sb.getConfig(\"remoteProxyPort\", \"<unknown>\"));\r\n            prop.put(\"remoteProxy_4Yacy\", sb.getConfigBool(\"remoteProxyUse4Yacy\", true) ? \"0\" : \"1\");\r\n        } else {\r\n            prop.put(\"remoteProxy\", \"0\"); // not used\r\n        }\r\n        prop.put(\"info_isTransparentProxy\", sb.getConfigBool(\"isTransparentProxy\", false) ? \"0\" : \"1\");\r\n        prop.put(\"info_proxyURL\", sb.getConfigBool(\"proxyURL\", false) ? \"0\" : \"1\");\r\n        \r\n        // peer information\r\n        String thisHash = \"\";\r\n        final String thisName = sb.peers.mySeed().getName();\r\n        if ( sb.peers.mySeed() == null ) {\r\n            thisHash = \"not assigned\";\r\n            prop.put(\"peerAddress\", \"0\"); // not assigned\r\n            prop.put(\"peerStatistics\", \"0\"); // unknown\r\n        } else {\r\n            final long uptime = 60000 * sb.peers.mySeed().getLong(Seed.UPTIME, 0L);\r\n            prop.put(\"peerStatistics\", \"1\");\r\n            prop.put(\"peerStatistics_uptime\", PeerActions.formatInterval(uptime));\r\n            prop.putNum(\"peerStatistics_pagesperminute\", sb.peers.mySeed().getPPM());\r\n            prop.putNum(\r\n                \"peerStatistics_queriesperhour\",\r\n                Math.round(6000d * sb.peers.mySeed().getQPM()) / 100d);\r\n            prop.putNum(\"peerStatistics_links\", sb.peers.mySeed().getLinkCount());\r\n            prop.put(\"peerStatistics_words\", Formatter.number(sb.peers.mySeed().getWordCount()));\r\n            prop.putNum(\"peerStatistics_disconnects\", sb.peers.peerActions.disconnects);\r\n            prop.put(\"peerStatistics_connects\", Formatter.number(sb.peers.mySeed().get(Seed.CCOUNT, \"0\")));\r\n            thisHash = sb.peers.mySeed().hash;\r\n            if ( sb.peers.mySeed().getPublicAddress() == null ) {\r\n                prop.put(\"peerAddress\", \"0\"); // not assigned + instructions\r\n                prop.put(\"warningGoOnline\", \"1\");\r\n            } else {\r\n                prop.put(\"peerAddress\", \"1\"); // Address\r\n                prop.put(\"peerAddress_address\", sb.peers.mySeed().getPublicAddress());\r\n                prop.putXML(\"peerAddress_peername\", sb.peers.mySeed().getName().toLowerCase());\r\n            }\r\n        }\r\n        final String peerStatus =\r\n            ((sb.peers.mySeed() == null) ? Seed.PEERTYPE_VIRGIN : sb.peers.mySeed().get(\r\n                Seed.PEERTYPE,\r\n                Seed.PEERTYPE_VIRGIN));\r\n\r\n        if ( Seed.PEERTYPE_VIRGIN.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"0\");\r\n            prop.put(\"urgentStatusVirgin\", \"1\");\r\n        } else if ( Seed.PEERTYPE_JUNIOR.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"1\");\r\n            prop.put(\"warningStatusJunior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_SENIOR.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"2\");\r\n            prop.put(\"hintStatusSenior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_PRINCIPAL.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"3\");\r\n            prop.put(\"hintStatusPrincipal\", \"1\");\r\n            prop.putHTML(\"hintStatusPrincipal_seedURL\", sb.peers.mySeed().get(Seed.SEEDLISTURL, \"?\"));\r\n        }\r\n        prop.putHTML(\"peerName\", thisName);\r\n        prop.put(\"hash\", thisHash);\r\n\r\n        final String seedUploadMethod = sb.getConfig(\"seedUploadMethod\", \"\");\r\n        if ( !\"none\".equalsIgnoreCase(seedUploadMethod)\r\n            || (\"\".equals(seedUploadMethod) && (sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 || sb\r\n                .getConfig(\"seedFilePath\", \"\")\r\n                .length() > 0)) ) {\r\n            if ( \"\".equals(seedUploadMethod) ) {\r\n                if ( sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"Ftp\");\r\n                }\r\n                if ( sb.getConfig(\"seedFilePath\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"File\");\r\n                }\r\n            }\r\n\r\n            if ( \"ftp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedFTPServer\", \"\"));\r\n            } else if ( \"scp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedScpServer\", \"\"));\r\n            } else if ( \"file\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"2\"); // enabled\r\n                prop.putHTML(\"seedServer_seedFile\", sb.getConfig(\"seedFilePath\", \"\"));\r\n            }\r\n            prop.put(\r\n                \"seedServer_lastUpload\",\r\n                PeerActions.formatInterval(System.currentTimeMillis() - sb.peers.lastSeedUpload_timeStamp));\r\n        } else {\r\n            prop.put(SEEDSERVER, \"0\"); // disabled\r\n        }\r\n\r\n        if ( sb.peers != null && sb.peers.sizeConnected() > 0 ) {\r\n            prop.put(\"otherPeers\", \"1\");\r\n            prop.putNum(\"otherPeers_num\", sb.peers.sizeConnected());\r\n        } else {\r\n            prop.put(\"otherPeers\", \"0\"); // not online\r\n        }\r\n\r\n        if ( !sb.getConfigBool(\"browserPopUpTrigger\", false) ) {\r\n            prop.put(\"popup\", \"0\");\r\n        } else {\r\n            prop.put(\"popup\", \"1\");\r\n        }\r\n\r\n        if ( !OS.isWindows ) {\r\n            prop.put(\"tray\", \"2\");\r\n        } else if ( !sb.getConfigBool(\"trayIcon\", false) ) {\r\n            prop.put(\"tray\", \"0\");\r\n        } else {\r\n            prop.put(\"tray\", \"1\");\r\n        }\r\n\r\n        // memory usage and system attributes\r\n        prop.put(\"usedMemory\", Formatter.bytesToString(MemoryControl.used()));\r\n        prop.put(\"maxMemory\", Formatter.bytesToString(MemoryControl.maxMemory()));\r\n        prop.put(\"usedDisk\", Formatter.bytesToString(sb.observer.getSizeOfDataPath(true)));\r\n        prop.put(\"freeDisk\", Formatter.bytesToString(sb.observer.getUsableSpace()));\r\n        prop.put(\"processors\", WorkflowProcessor.availableCPU);\r\n        prop.put(\"load\", Memory.load());\r\n\r\n        // proxy traffic\r\n        //prop.put(\"trafficIn\",bytesToString(httpdByteCountInputStream.getGlobalCount()));\r\n        prop.put(\"trafficProxy\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.PROXY)));\r\n        prop.put(\"trafficCrawler\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.CRAWLER)));\r\n\r\n        // connection information\r\n        final YaCyHttpServer httpd =  sb.getHttpServer();\r\n\r\n        prop.putNum(\"connectionsActive\", httpd.getJobCount());\r\n        prop.putNum(\"connectionsMax\", httpd.getMaxSessionCount());\r\n\r\n        // Queue information\r\n        final int loaderJobCount = sb.crawlQueues.activeWorkerEntries().size();\r\n        final int loaderMaxCount = sb.getConfigInt(SwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX, 10);\r\n        final int loaderPercent = (loaderMaxCount == 0) ? 0 : loaderJobCount * 100 / loaderMaxCount;\r\n        prop.putNum(\"loaderQueueSize\", loaderJobCount);\r\n        prop.putNum(\"loaderQueueMax\", loaderMaxCount);\r\n        prop.put(\"loaderQueuePercent\", (loaderPercent > 100) ? 100 : loaderPercent);\r\n\r\n        prop.putNum(\"localCrawlQueueSize\", sb\r\n            .getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            .getJobCount());\r\n        prop.put(\"localCrawlPaused\", sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            ? \"1\"\r\n            : \"0\");\r\n\r\n        prop.putNum(\r\n            \"remoteTriggeredCrawlQueueSize\",\r\n            sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL).getJobCount());\r\n        prop.put(\r\n            \"remoteTriggeredCrawlPaused\",\r\n            sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL) ? \"1\" : \"0\");\r\n\r\n        prop.putNum(\"stackCrawlQueueSize\", sb.crawlStacker.size());\r\n\r\n        // return rewrite properties\r\n        prop.put(\"date\", (new Date()).toString());\r\n        return prop;\r\n    }","commit_id":"39b641d6cd82a9ca3bd2ab584435544a940e9093","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected RequestHeader generateLegacyRequestHeader(HttpServletRequest request, String target, String targetExt) {\r\n        RequestHeader legacyRequestHeader = ProxyHandler.convertHeaderFromJetty(request);\r\n\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, request.getRemoteAddr());\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, target);\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, targetExt);\r\n\r\n        if (legacyRequestHeader.containsKey(RequestHeader.AUTHORIZATION)) {\r\n            if (HttpServletRequest.BASIC_AUTH.equalsIgnoreCase(request.getAuthType())) {\r\n            } else {\r\n                // handle DIGEST auth for legacyHeader (create username:md5pwdhash\r\n                if (request.getUserPrincipal() != null) {\r\n                    String userpassEncoded = request.getHeader(RequestHeader.AUTHORIZATION); // e.g. \"Basic AdminMD5hash\"\r\n                    if (userpassEncoded != null) {\r\n                        if (request.isUserInRole(AccessRight.ADMIN_RIGHT.toString()) && !Switchboard.getSwitchboard().getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5,\"\").isEmpty()) {\r\n                            // fake admin authentication for legacyRequestHeader (as e.g. DIGEST is not supported by legacyRequestHeader)\r\n                            legacyRequestHeader.put(RequestHeader.AUTHORIZATION, HttpServletRequest.BASIC_AUTH + \" \"\r\n                                    + Switchboard.getSwitchboard().getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\"));\r\n                        } else {\r\n                            // fake Basic auth header for Digest auth  (Basic username:md5pwdhash)\r\n                            String username = request.getRemoteUser();\r\n                            Entry user = Switchboard.getSwitchboard().userDB.getEntry(username);\r\n                            if (user != null) {\r\n                                legacyRequestHeader.put(RequestHeader.AUTHORIZATION, HttpServletRequest.BASIC_AUTH + \" \"\r\n                                        + username + \":\" + user.getMD5EncodedUserPwd());\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return legacyRequestHeader;\r\n    }","id":51603,"modified_method":"protected RequestHeader generateLegacyRequestHeader(HttpServletRequest request, String target, String targetExt) {\r\n        RequestHeader legacyRequestHeader = ProxyHandler.convertHeaderFromJetty(request);\r\n\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, request.getRemoteAddr());\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, target);\r\n        legacyRequestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, targetExt);\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n        if (legacyRequestHeader.containsKey(RequestHeader.AUTHORIZATION)) {\r\n            if (HttpServletRequest.BASIC_AUTH.equalsIgnoreCase(request.getAuthType())) {\r\n            } else {\r\n                // handle DIGEST auth for legacyHeader (create username:md5pwdhash\r\n                if (request.getUserPrincipal() != null) {\r\n                    String userpassEncoded = request.getHeader(RequestHeader.AUTHORIZATION); // e.g. \"Basic AdminMD5hash\"\r\n                    if (userpassEncoded != null) {\r\n                        if (request.isUserInRole(AccessRight.ADMIN_RIGHT.toString()) && !sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5,\"\").isEmpty()) {\r\n                            // fake admin authentication for legacyRequestHeader (as e.g. DIGEST is not supported by legacyRequestHeader)\r\n                            legacyRequestHeader.put(RequestHeader.AUTHORIZATION, HttpServletRequest.BASIC_AUTH + \" \"\r\n                                    + sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\"));\r\n                        } else {\r\n                            // fake Basic auth header for Digest auth  (Basic username:md5pwdhash)\r\n                            String username = request.getRemoteUser();\r\n                            Entry user = sb.userDB.getEntry(username);\r\n                            if (user != null) {\r\n                                legacyRequestHeader.put(RequestHeader.AUTHORIZATION, HttpServletRequest.BASIC_AUTH + \" \"\r\n                                        + username + \":\" + user.getMD5EncodedUserPwd());\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return legacyRequestHeader;\r\n    }","commit_id":"39b641d6cd82a9ca3bd2ab584435544a940e9093","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void handleTemplate(String target,  HttpServletRequest request,\r\n            HttpServletResponse response) throws IOException, ServletException {\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n\r\n        String localeSelection = Switchboard.getSwitchboard().getConfig(\"locale.language\", \"default\");\r\n        File targetFile = getLocalizedFile(target, localeSelection);\r\n        File targetClass = rewriteClassFile(_resourceBase.addPath(target).getFile());\r\n        String targetExt = target.substring(target.lastIndexOf('.') + 1);\r\n\r\n        if ((targetClass != null)) {\r\n            serverObjects args = new serverObjects();\r\n            Enumeration<String> argNames = request.getParameterNames();\r\n            while (argNames.hasMoreElements()) {\r\n                String argName = argNames.nextElement();\r\n                args.put(argName, request.getParameter(argName));\r\n            }\r\n            //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\r\n            //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \r\n            Enumeration<String> attNames = request.getAttributeNames();\r\n            while (attNames.hasMoreElements()) {\r\n                String argName = attNames.nextElement();\r\n                args.put(argName, request.getAttribute(argName).toString());\r\n            }          \r\n            RequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\r\n            // add multipart-form fields to parameter\r\n            if (ServletFileUpload.isMultipartContent(request)) {\r\n                //TODO:   added quickfix to support gzip encoded content\r\n                //        using existing HTTPDemon.parseMultipart()\r\n                final String bodyEncoding = request.getHeader(HeaderFramework.CONTENT_ENCODING);\r\n                if (HeaderFramework.CONTENT_ENCODING_GZIP.equalsIgnoreCase(bodyEncoding)) {\r\n                    HTTPDemon.parseMultipart(legacyRequestHeader, args, request.getInputStream());\r\n                } else {\r\n                    parseMultipart(request, args);\r\n                }\r\n            }\r\n            // eof modification to read attribute\r\n            Object tmp;\r\n            try {\r\n                if (args.isEmpty()) {\r\n                    // yacy servlets typically test for args != null (but not for args .isEmpty())\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, null); \r\n                } else {\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, args);\r\n                }\r\n            } catch (InvocationTargetException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            } catch (IllegalArgumentException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            } catch (IllegalAccessException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            }\r\n\r\n            if (tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\r\n\r\n                net.yacy.cora.util.ByteBuffer result = null;\r\n\r\n                if (tmp instanceof RasterPlotter) {\r\n                    final RasterPlotter yp = (RasterPlotter) tmp;\r\n                    // send an image to client\r\n                    result = RasterPlotter.exportImage(yp.getImage(), \"png\");\r\n                } else if (tmp instanceof EncodedImage) {\r\n                    final EncodedImage yp = (EncodedImage) tmp;\r\n                    result = yp.getImage();\r\n                } else if (tmp instanceof Image) {\r\n                    final Image i = (Image) tmp;\r\n\r\n                    // generate an byte array from the generated image\r\n                    int width = i.getWidth(null);\r\n                    if (width < 0) {\r\n                        width = 96; // bad hack\r\n                    }\r\n                    int height = i.getHeight(null);\r\n                    if (height < 0) {\r\n                        height = 96; // bad hack\r\n                    }\r\n                    final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                    bi.createGraphics().drawImage(i, 0, 0, width, height, null);\r\n                    result = RasterPlotter.exportImage(bi, targetExt);\r\n                }\r\n\r\n                final String mimeType = Classification.ext2mime(targetExt, MimeTypes.TEXT_HTML);\r\n                response.setContentType(mimeType);\r\n                response.setContentLength(result.length());\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n\r\n                result.writeTo(response.getOutputStream());\r\n                result.close();\r\n                return;\r\n            }\r\n\r\n            servletProperties templatePatterns;\r\n            if (tmp == null) {\r\n                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                templatePatterns = new servletProperties();\r\n            } else if (tmp instanceof servletProperties) {\r\n                templatePatterns = (servletProperties) tmp;\r\n            } else {\r\n                templatePatterns = new servletProperties((serverObjects) tmp);\r\n            }\r\n     \r\n            // handle YaCy http commands\r\n            // handle action auth: check if the servlets requests authentication\r\n            if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\r\n                if (!request.authenticate(response)) {\r\n                    return;\r\n                }\r\n            //handle action forward\r\n            } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\r\n                String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\r\n\r\n                if (location.isEmpty()) {\r\n                    location = request.getPathInfo();\r\n                }\r\n                //TODO: handle equivalent of this from httpdfilehandler\r\n                // final ResponseHeader headers = getDefaultHeaders(request.getPathInfo());\r\n                // headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n\r\n                response.setHeader(HeaderFramework.LOCATION, location);\r\n                response.setStatus(HttpServletResponse.SC_FOUND);\r\n                return;\r\n            }\r\n            \r\n            // add the application version, the uptime and the client name to every rewrite table\r\n            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\r\n            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() - serverCore.startupTime) / 1000) / 60); // uptime in minutes\r\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\r\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\r\n            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n            Seed myPeer = sb.peers.mySeed();\r\n            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\r\n            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\r\n            templatePatterns.put(\"p2p\", sb.getConfigBool(SwitchboardConstants.DHT_ENABLED, true) || !sb.isRobinsonMode() ? 1 : 0);\r\n            templatePatterns.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n            templatePatterns.put(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n            \r\n            if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\r\n                String mimeType = Classification.ext2mime(targetExt, MimeTypes.TEXT_HTML);\r\n\r\n                InputStream fis;\r\n                long fileSize = targetFile.length();\r\n\r\n                if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\r\n                    // read file completely into ram, avoid that too many files are open at the same time\r\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\r\n                } else {\r\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                }\r\n\r\n                // set response header\r\n                response.setContentType(mimeType);\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n                ByteArrayOutputStream bas = new ByteArrayOutputStream(4096);\r\n                // apply templates\r\n                TemplateEngine.writeTemplate(fis, bas, templatePatterns, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));                \r\n                fis.close();\r\n                // handle SSI\r\n                parseSSI (bas.toByteArray(),request,response);\r\n            }\r\n        }\r\n    }","id":51604,"modified_method":"protected void handleTemplate(String target,  HttpServletRequest request,\r\n            HttpServletResponse response) throws IOException, ServletException {\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n\r\n        String localeSelection = sb.getConfig(\"locale.language\", \"default\");\r\n        File targetFile = getLocalizedFile(target, localeSelection);\r\n        File targetClass = rewriteClassFile(_resourceBase.addPath(target).getFile());\r\n        String targetExt = target.substring(target.lastIndexOf('.') + 1);\r\n\r\n        if ((targetClass != null)) {\r\n            serverObjects args = new serverObjects();\r\n            Enumeration<String> argNames = request.getParameterNames();\r\n            while (argNames.hasMoreElements()) {\r\n                String argName = argNames.nextElement();\r\n                args.put(argName, request.getParameter(argName));\r\n            }\r\n            //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\r\n            //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \r\n            Enumeration<String> attNames = request.getAttributeNames();\r\n            while (attNames.hasMoreElements()) {\r\n                String argName = attNames.nextElement();\r\n                args.put(argName, request.getAttribute(argName).toString());\r\n            }          \r\n            RequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\r\n            // add multipart-form fields to parameter\r\n            if (ServletFileUpload.isMultipartContent(request)) {\r\n                //TODO:   added quickfix to support gzip encoded content\r\n                //        using existing HTTPDemon.parseMultipart()\r\n                final String bodyEncoding = request.getHeader(HeaderFramework.CONTENT_ENCODING);\r\n                if (HeaderFramework.CONTENT_ENCODING_GZIP.equalsIgnoreCase(bodyEncoding)) {\r\n                    HTTPDemon.parseMultipart(legacyRequestHeader, args, request.getInputStream());\r\n                } else {\r\n                    parseMultipart(request, args);\r\n                }\r\n            }\r\n            // eof modification to read attribute\r\n            Object tmp;\r\n            try {\r\n                if (args.isEmpty()) {\r\n                    // yacy servlets typically test for args != null (but not for args .isEmpty())\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, null); \r\n                } else {\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, args);\r\n                }\r\n            } catch (InvocationTargetException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            } catch (IllegalArgumentException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            } catch (IllegalAccessException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException();\r\n            }\r\n\r\n            if (tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\r\n\r\n                net.yacy.cora.util.ByteBuffer result = null;\r\n\r\n                if (tmp instanceof RasterPlotter) {\r\n                    final RasterPlotter yp = (RasterPlotter) tmp;\r\n                    // send an image to client\r\n                    result = RasterPlotter.exportImage(yp.getImage(), \"png\");\r\n                } else if (tmp instanceof EncodedImage) {\r\n                    final EncodedImage yp = (EncodedImage) tmp;\r\n                    result = yp.getImage();\r\n                } else if (tmp instanceof Image) {\r\n                    final Image i = (Image) tmp;\r\n\r\n                    // generate an byte array from the generated image\r\n                    int width = i.getWidth(null);\r\n                    if (width < 0) {\r\n                        width = 96; // bad hack\r\n                    }\r\n                    int height = i.getHeight(null);\r\n                    if (height < 0) {\r\n                        height = 96; // bad hack\r\n                    }\r\n                    final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                    bi.createGraphics().drawImage(i, 0, 0, width, height, null);\r\n                    result = RasterPlotter.exportImage(bi, targetExt);\r\n                }\r\n\r\n                final String mimeType = Classification.ext2mime(targetExt, MimeTypes.TEXT_HTML);\r\n                response.setContentType(mimeType);\r\n                response.setContentLength(result.length());\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n\r\n                result.writeTo(response.getOutputStream());\r\n                result.close();\r\n                return;\r\n            }\r\n\r\n            servletProperties templatePatterns;\r\n            if (tmp == null) {\r\n                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                templatePatterns = new servletProperties();\r\n            } else if (tmp instanceof servletProperties) {\r\n                templatePatterns = (servletProperties) tmp;\r\n            } else {\r\n                templatePatterns = new servletProperties((serverObjects) tmp);\r\n            }\r\n     \r\n            // handle YaCy http commands\r\n            // handle action auth: check if the servlets requests authentication\r\n            if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\r\n                if (!request.authenticate(response)) {\r\n                    return;\r\n                }\r\n            //handle action forward\r\n            } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\r\n                String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\r\n\r\n                if (location.isEmpty()) {\r\n                    location = request.getPathInfo();\r\n                }\r\n                //TODO: handle equivalent of this from httpdfilehandler\r\n                // final ResponseHeader headers = getDefaultHeaders(request.getPathInfo());\r\n                // headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n\r\n                response.setHeader(HeaderFramework.LOCATION, location);\r\n                response.setStatus(HttpServletResponse.SC_FOUND);\r\n                return;\r\n            }\r\n\r\n            if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\r\n                \r\n                sb.setConfig(\"server.servlets.called\", appendPath(sb.getConfig(\"server.servlets.called\", \"\"), target));\r\n                if (args != null && args.size() > 0) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), target));\r\n\r\n                // add the application version, the uptime and the client name to every rewrite table\r\n                templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\r\n                templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() - serverCore.startupTime) / 1000) / 60); // uptime in minutes\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\r\n                templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n                Seed myPeer = sb.peers.mySeed();\r\n                templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\r\n                templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\r\n                templatePatterns.put(\"navigation-p2p\", sb.getConfigBool(SwitchboardConstants.DHT_ENABLED, true) || !sb.isRobinsonMode() ? 1 : 0);\r\n                templatePatterns.put(\"navigation-crawlmonitor\", sb.getConfig(\"server.servlets.submitted\", \"\").indexOf(\"Crawler_p\") >= 0);\r\n                templatePatterns.put(\"navigation-advanced\", sb.getConfig(\"server.servlets.submitted\", \"\").indexOf(\"Config\") >= 0  || sb.getConfig(\"server.servlets.called\", \"\").indexOf(\"CrawlStart\") >= 0);\r\n                templatePatterns.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                templatePatterns.put(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                \r\n                String mimeType = Classification.ext2mime(targetExt, MimeTypes.TEXT_HTML);\r\n\r\n                InputStream fis;\r\n                long fileSize = targetFile.length();\r\n\r\n                if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\r\n                    // read file completely into ram, avoid that too many files are open at the same time\r\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\r\n                } else {\r\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                }\r\n\r\n                // set response header\r\n                response.setContentType(mimeType);\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n                ByteArrayOutputStream bas = new ByteArrayOutputStream(4096);\r\n                // apply templates\r\n                TemplateEngine.writeTemplate(fis, bas, templatePatterns, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));                \r\n                fis.close();\r\n                // handle SSI\r\n                parseSSI (bas.toByteArray(),request,response);\r\n            }\r\n        }\r\n    }","commit_id":"39b641d6cd82a9ca3bd2ab584435544a940e9093","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\r\n    public void init() throws UnavailableException {\r\n        _htDocsPath = Switchboard.getSwitchboard().htDocsPath;\r\n        _htLocalePath = Switchboard.getSwitchboard().getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\");\r\n        \r\n        _servletContext = getServletContext();\r\n\r\n        _mimeTypes = new MimeTypes(); \r\n        String tmpstr = this.getServletContext().getInitParameter(\"welcomeFile\");\r\n        if (tmpstr == null) { \r\n            _welcomes = HTTPDFileHandler.defaultFiles;\r\n        } else {\r\n            _welcomes = new String[]{tmpstr,\"index.html\"};\r\n        }\r\n        _acceptRanges = getInitBoolean(\"acceptRanges\", _acceptRanges);\r\n        _dirAllowed = getInitBoolean(\"dirAllowed\", _dirAllowed);\r\n        _pathInfoOnly = getInitBoolean(\"pathInfoOnly\", _pathInfoOnly);\r\n\r\n        Resource.setDefaultUseCaches(false); // caching is handled internally (prevent double caching)\r\n\r\n        String rb = getInitParameter(\"resourceBase\");\r\n        try {\r\n            if (rb != null) {\r\n                _resourceBase = Resource.newResource(rb);\r\n            } else {\r\n                _resourceBase = Resource.newResource(Switchboard.getSwitchboard().getConfig(SwitchboardConstants.HTROOT_PATH, SwitchboardConstants.HTROOT_PATH_DEFAULT)); //default\r\n            }\r\n        } catch (IOException e) {\r\n            ConcurrentLog.severe(\"FILEHANDLER\", \"YaCyDefaultServlet: resource base (htRootPath) missing\");\r\n            ConcurrentLog.logException(e);\r\n            throw new UnavailableException(e.toString());\r\n        }\r\n        if (ConcurrentLog.isFine(\"FILEHANDLER\")) {\r\n            ConcurrentLog.fine(\"FILEHANDLER\",\"YaCyDefaultServlet: resource base = \" + _resourceBase);\r\n        }\r\n        templateMethodCache = new ConcurrentHashMap<File, SoftReference<Method>>();\r\n    }","id":51605,"modified_method":"@Override\r\n    public void init() throws UnavailableException {\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n        _htDocsPath = sb.htDocsPath;\r\n        _htLocalePath = sb.getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\");\r\n        \r\n        _servletContext = getServletContext();\r\n\r\n        _mimeTypes = new MimeTypes(); \r\n        String tmpstr = this.getServletContext().getInitParameter(\"welcomeFile\");\r\n        if (tmpstr == null) { \r\n            _welcomes = HTTPDFileHandler.defaultFiles;\r\n        } else {\r\n            _welcomes = new String[]{tmpstr,\"index.html\"};\r\n        }\r\n        _acceptRanges = getInitBoolean(\"acceptRanges\", _acceptRanges);\r\n        _dirAllowed = getInitBoolean(\"dirAllowed\", _dirAllowed);\r\n        _pathInfoOnly = getInitBoolean(\"pathInfoOnly\", _pathInfoOnly);\r\n\r\n        Resource.setDefaultUseCaches(false); // caching is handled internally (prevent double caching)\r\n\r\n        String rb = getInitParameter(\"resourceBase\");\r\n        try {\r\n            if (rb != null) {\r\n                _resourceBase = Resource.newResource(rb);\r\n            } else {\r\n                _resourceBase = Resource.newResource(sb.getConfig(SwitchboardConstants.HTROOT_PATH, SwitchboardConstants.HTROOT_PATH_DEFAULT)); //default\r\n            }\r\n        } catch (IOException e) {\r\n            ConcurrentLog.severe(\"FILEHANDLER\", \"YaCyDefaultServlet: resource base (htRootPath) missing\");\r\n            ConcurrentLog.logException(e);\r\n            throw new UnavailableException(e.toString());\r\n        }\r\n        if (ConcurrentLog.isFine(\"FILEHANDLER\")) {\r\n            ConcurrentLog.fine(\"FILEHANDLER\",\"YaCyDefaultServlet: resource base = \" + _resourceBase);\r\n        }\r\n        templateMethodCache = new ConcurrentHashMap<File, SoftReference<Method>>();\r\n    }","commit_id":"39b641d6cd82a9ca3bd2ab584435544a940e9093","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Nullable\n  static TypeConversionDescriptor getFilterDescriptor(PsiMethod method) {\n    LOG.assertTrue(\"filter\".equals(method.getName()));\n\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return null;\n    final PsiParameter parameter = parameters[0];\n    final PsiType type = parameter.getType();\n    if (!(type instanceof PsiClassType)) return null;\n    final PsiClass resolvedClass = ((PsiClassType)type).resolve();\n    if (resolvedClass == null) return null;\n    if (CommonClassNames.JAVA_LANG_CLASS.equals(resolvedClass.getQualifiedName())) {\n      return new GuavaFilterInstanceOfConversionDescriptor();\n    }\n    else if (GuavaPredicateConversionRule.GUAVA_PREDICATE.equals(resolvedClass.getQualifiedName())) {\n      return new GuavaTypeConversionDescriptor(\"$it$.filter($p$)\", \"$it$.\" + StreamApiConstants.FILTER + \"($p$)\");\n    }\n    return null;\n  }","id":51606,"modified_method":"@Nullable\n  static TypeConversionDescriptor getFilterDescriptor(PsiMethod method) {\n    LOG.assertTrue(\"filter\".equals(method.getName()));\n\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return null;\n    final PsiParameter parameter = parameters[0];\n    final PsiType type = parameter.getType();\n    if (!(type instanceof PsiClassType)) return null;\n    final PsiClass resolvedClass = ((PsiClassType)type).resolve();\n    if (resolvedClass == null) return null;\n    if (CommonClassNames.JAVA_LANG_CLASS.equals(resolvedClass.getQualifiedName())) {\n      return new GuavaFilterInstanceOfConversionDescriptor();\n    }\n    else if (GuavaLambda.PREDICATE.getClassQName().equals(resolvedClass.getQualifiedName())) {\n      return new GuavaTypeConversionDescriptor(\"$it$.filter($p$)\", \"$it$.\" + StreamApiConstants.FILTER + \"($p$)\");\n    }\n    return null;\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getFunctionReturnType(PsiExpression functionExpression) {\n    if (functionExpression instanceof PsiFunctionalExpression) {\n      return LambdaUtil.getFunctionalInterfaceReturnType((PsiFunctionalExpression)functionExpression);\n    }\n    PsiType currentType = functionExpression.getType();\n    if (currentType == null) return null;\n\n    while (true) {\n      if (LambdaUtil.isFunctionalType(currentType)) {\n        return LambdaUtil.getFunctionalInterfaceReturnType(currentType);\n      }\n      final PsiType[] superTypes = currentType.getSuperTypes();\n      currentType = null;\n      for (PsiType type : superTypes) {\n        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);\n        if (aClass != null && InheritanceUtil.isInheritor(aClass, GuavaFunctionConversionRule.GUAVA_FUNCTION)) {\n          currentType = type;\n          break;\n        }\n      }\n      if (currentType == null) {\n        return null;\n      }\n    }\n  }","id":51607,"modified_method":"@Nullable\n  public static PsiType getFunctionReturnType(PsiExpression functionExpression) {\n    if (functionExpression instanceof PsiFunctionalExpression) {\n      return LambdaUtil.getFunctionalInterfaceReturnType((PsiFunctionalExpression)functionExpression);\n    }\n    PsiType currentType = functionExpression.getType();\n    if (currentType == null) return null;\n\n    while (true) {\n      if (LambdaUtil.isFunctionalType(currentType)) {\n        return LambdaUtil.getFunctionalInterfaceReturnType(currentType);\n      }\n      final PsiType[] superTypes = currentType.getSuperTypes();\n      currentType = null;\n      for (PsiType type : superTypes) {\n        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);\n        if (aClass != null && InheritanceUtil.isInheritor(aClass, GuavaLambda.FUNCTION.getClassQName())) {\n          currentType = type;\n          break;\n        }\n      }\n      if (currentType == null) {\n        return null;\n      }\n    }\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n    return new JavaElementVisitor() {\n      private final AtomicNotNullLazyValue<Map<String, PsiClass>> myGuavaClassConversions =\n        new AtomicNotNullLazyValue<Map<String, PsiClass>>() {\n          @NotNull\n          @Override\n          protected Map<String, PsiClass> compute() {\n            Map<String, PsiClass> map = new HashMap<String, PsiClass>();\n            for (TypeConversionRule rule : TypeConversionRule.EP_NAME.getExtensions()) {\n              if (rule instanceof BaseGuavaTypeConversionRule) {\n                final String fromClass = ((BaseGuavaTypeConversionRule)rule).ruleFromClass();\n                final String toClass = ((BaseGuavaTypeConversionRule)rule).ruleToClass();\n\n                final Project project = holder.getProject();\n                final JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n                final PsiClass targetClass = javaPsiFacade.findClass(toClass, GlobalSearchScope.allScope(project));\n\n                if (targetClass != null) {\n                  map.put(fromClass, targetClass);\n                }\n              }\n            }\n            return map;\n          }\n        };\n\n      @Override\n      public void visitVariable(PsiVariable variable) {\n        if (!checkVariables) return;\n        final PsiType type = variable.getType();\n        PsiType targetType = getConversionClassType(type);\n        if (targetType != null) {\n          holder.registerProblem(variable.getNameIdentifier(),\n                                 PROBLEM_DESCRIPTION,\n                                 new MigrateGuavaTypeFix(variable, targetType));\n        }\n      }\n\n      @Override\n      public void visitMethod(PsiMethod method) {\n        super.visitMethod(method);\n        if (!checkReturnTypes) return;\n        final PsiType targetType = getConversionClassType(method.getReturnType());\n        if (targetType != null) {\n          final PsiTypeElement typeElement = method.getReturnTypeElement();\n          if (typeElement != null) {\n            holder.registerProblem(typeElement,\n                                   PROBLEM_DESCRIPTION,\n                                   new MigrateGuavaTypeFix(method, targetType));\n          }\n        }\n      }\n\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n        checkFluentIterableGenerationMethod(expression);\n        checkPredicatesUtilityMethod(expression);\n      }\n\n      private void checkPredicatesUtilityMethod(PsiMethodCallExpression expression) {\n        if (GuavaPredicateConversionRule.isPredicates(expression)) {\n          final PsiClassType initialType = (PsiClassType)expression.getType();\n          PsiClassType targetType = createTargetType(initialType);\n          if (targetType == null) return;\n          holder.registerProblem(expression.getMethodExpression().getReferenceNameElement(),\n                                 PROBLEM_DESCRIPTION,\n                                 new MigrateGuavaTypeFix(expression, targetType));\n        }\n      }\n\n      private void checkFluentIterableGenerationMethod(PsiMethodCallExpression expression) {\n        if (!checkChains) return;\n        if (!isFluentIterableFromCall(expression)) return;\n\n        final PsiMethodCallExpression chain = findGuavaMethodChain(expression);\n        if (chain == null) {\n          return;\n        }\n\n        PsiClassType initialType = (PsiClassType)chain.getType();\n        LOG.assertTrue(initialType != null);\n        PsiClassType targetType = createTargetType(initialType);\n        if (targetType == null) return;\n\n        PsiElement highlightedElement = chain;\n        if (chain.getParent() instanceof PsiReferenceExpression && chain.getParent().getParent() instanceof PsiMethodCallExpression) {\n          highlightedElement = chain.getParent().getParent();\n        }\n        holder.registerProblem(highlightedElement, PROBLEM_DESCRIPTION, new MigrateGuavaTypeFix(chain, targetType));\n      }\n\n      @Nullable\n      private PsiClassType createTargetType(PsiClassType initialType) {\n        PsiClass resolvedClass = initialType.resolve();\n        PsiClass target;\n        if (resolvedClass == null || (target = myGuavaClassConversions.getValue().get(resolvedClass.getQualifiedName())) == null) {\n          return null;\n        }\n        return addTypeParameters(initialType, initialType.resolveGenerics(), target);\n      }\n\n      private PsiType getConversionClassType(PsiType initialType) {\n        if (initialType == null) return null;\n        final PsiType type = initialType.getDeepComponentType();\n        if (type instanceof PsiClassType) {\n          final PsiClassType.ClassResolveResult resolveResult = ((PsiClassType)type).resolveGenerics();\n          final PsiClass psiClass = resolveResult.getElement();\n          if (psiClass != null) {\n            final String qName = psiClass.getQualifiedName();\n            final PsiClass targetClass = myGuavaClassConversions.getValue().get(qName);\n            if (targetClass != null) {\n              final PsiClassType createdType = addTypeParameters(type, resolveResult, targetClass);\n              return initialType instanceof PsiArrayType ? wrapAsArray((PsiArrayType)initialType, createdType) : createdType;\n            }\n          }\n        }\n        return null;\n      }\n\n      ;\n\n      private PsiType wrapAsArray(PsiArrayType initial, PsiType created) {\n        PsiArrayType result = new PsiArrayType(created);\n        while (initial.getComponentType() instanceof PsiArrayType) {\n          initial = (PsiArrayType)initial.getComponentType();\n          result = new PsiArrayType(result);\n        }\n        return result;\n      }\n\n      private boolean isFluentIterableFromCall(PsiMethodCallExpression expression) {\n        PsiMethod method = expression.resolveMethod();\n        if (method == null || !GuavaFluentIterableConversionRule.CHAIN_HEAD_METHODS.contains(method.getName())) {\n          return false;\n        }\n        PsiClass aClass = method.getContainingClass();\n        return aClass != null && GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(aClass.getQualifiedName());\n      }\n\n      private PsiMethodCallExpression findGuavaMethodChain(PsiMethodCallExpression expression) {\n        PsiMethodCallExpression chain = expression;\n        while (true) {\n          final PsiMethodCallExpression current = PsiTreeUtil.getParentOfType(chain, PsiMethodCallExpression.class);\n          if (current != null && current.getMethodExpression().getQualifierExpression() == chain) {\n            final PsiMethod method = current.resolveMethod();\n            if (method == null) {\n              return chain;\n            }\n            if (FLUENT_ITERABLE_STOP_METHODS.getValue().contains(method.getName())) {\n              return null;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(containingClass.getQualifiedName())\n                                             || GuavaOptionalConversionRule.GUAVA_OPTIONAL.equals(containingClass.getQualifiedName()))) {\n              return chain;\n            }\n            final PsiType returnType = method.getReturnType();\n            final PsiClass returnClass = PsiTypesUtil.getPsiClass(returnType);\n            if (returnClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(returnClass.getQualifiedName())\n                                    || GuavaOptionalConversionRule.GUAVA_OPTIONAL.equals(returnClass.getQualifiedName()))) {\n              return chain;\n            }\n            if (GuavaTypeConversionDescriptor.isIterable(current)) {\n              return chain;\n            }\n          }\n          else {\n            return chain;\n          }\n          chain = current;\n        }\n      }\n\n      @NotNull\n      private PsiClassType addTypeParameters(PsiType currentType,\n                                             PsiClassType.ClassResolveResult currentTypeResolveResult,\n                                             PsiClass targetClass) {\n        final Map<PsiTypeParameter, PsiType> substitutionMap = currentTypeResolveResult.getSubstitutor().getSubstitutionMap();\n        final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(holder.getProject());\n        if (substitutionMap.size() == 1) {\n          return elementFactory.createType(targetClass, ContainerUtil.getFirstItem(substitutionMap.values()));\n        }\n        else {\n          LOG.assertTrue(substitutionMap.size() == 2);\n          LOG.assertTrue(GuavaFunctionConversionRule.JAVA_UTIL_FUNCTION_FUNCTION.equals(targetClass.getQualifiedName()));\n          final PsiType returnType = LambdaUtil.getFunctionalInterfaceReturnType(currentType);\n          final List<PsiType> types = new ArrayList<PsiType>(substitutionMap.values());\n          types.remove(returnType);\n          final PsiType parameterType = types.get(0);\n          return elementFactory.createType(targetClass, parameterType, returnType);\n        }\n      }\n    };\n  }","id":51608,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n    return new JavaElementVisitor() {\n      private final AtomicNotNullLazyValue<Map<String, PsiClass>> myGuavaClassConversions =\n        new AtomicNotNullLazyValue<Map<String, PsiClass>>() {\n          @NotNull\n          @Override\n          protected Map<String, PsiClass> compute() {\n            Map<String, PsiClass> map = new HashMap<String, PsiClass>();\n            for (TypeConversionRule rule : TypeConversionRule.EP_NAME.getExtensions()) {\n              if (rule instanceof BaseGuavaTypeConversionRule) {\n                final String fromClass = ((BaseGuavaTypeConversionRule)rule).ruleFromClass();\n                final String toClass = ((BaseGuavaTypeConversionRule)rule).ruleToClass();\n\n                final Project project = holder.getProject();\n                final JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n                final PsiClass targetClass = javaPsiFacade.findClass(toClass, GlobalSearchScope.allScope(project));\n\n                if (targetClass != null) {\n                  map.put(fromClass, targetClass);\n                }\n              }\n            }\n            return map;\n          }\n        };\n\n      @Override\n      public void visitVariable(PsiVariable variable) {\n        if (!checkVariables) return;\n        final PsiType type = variable.getType();\n        PsiType targetType = getConversionClassType(type);\n        if (targetType != null) {\n          holder.registerProblem(variable.getNameIdentifier(),\n                                 PROBLEM_DESCRIPTION,\n                                 new MigrateGuavaTypeFix(variable, targetType));\n        }\n      }\n\n      @Override\n      public void visitMethod(PsiMethod method) {\n        super.visitMethod(method);\n        if (!checkReturnTypes) return;\n        final PsiType targetType = getConversionClassType(method.getReturnType());\n        if (targetType != null) {\n          final PsiTypeElement typeElement = method.getReturnTypeElement();\n          if (typeElement != null) {\n            holder.registerProblem(typeElement,\n                                   PROBLEM_DESCRIPTION,\n                                   new MigrateGuavaTypeFix(method, targetType));\n          }\n        }\n      }\n\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n        checkFluentIterableGenerationMethod(expression);\n        checkPredicatesUtilityMethod(expression);\n      }\n\n      private void checkPredicatesUtilityMethod(PsiMethodCallExpression expression) {\n        if (GuavaPredicateConversionRule.isPredicates(expression)) {\n          final PsiClassType initialType = (PsiClassType)expression.getType();\n          PsiClassType targetType = createTargetType(initialType);\n          if (targetType == null) return;\n          holder.registerProblem(expression.getMethodExpression().getReferenceNameElement(),\n                                 PROBLEM_DESCRIPTION,\n                                 new MigrateGuavaTypeFix(expression, targetType));\n        }\n      }\n\n      private void checkFluentIterableGenerationMethod(PsiMethodCallExpression expression) {\n        if (!checkChains) return;\n        if (!isFluentIterableFromCall(expression)) return;\n\n        final PsiMethodCallExpression chain = findGuavaMethodChain(expression);\n        if (chain == null) {\n          return;\n        }\n\n        PsiClassType initialType = (PsiClassType)chain.getType();\n        LOG.assertTrue(initialType != null);\n        PsiClassType targetType = createTargetType(initialType);\n        if (targetType == null) return;\n\n        PsiElement highlightedElement = chain;\n        if (chain.getParent() instanceof PsiReferenceExpression && chain.getParent().getParent() instanceof PsiMethodCallExpression) {\n          highlightedElement = chain.getParent().getParent();\n        }\n        holder.registerProblem(highlightedElement, PROBLEM_DESCRIPTION, new MigrateGuavaTypeFix(chain, targetType));\n      }\n\n      @Nullable\n      private PsiClassType createTargetType(PsiClassType initialType) {\n        PsiClass resolvedClass = initialType.resolve();\n        PsiClass target;\n        if (resolvedClass == null || (target = myGuavaClassConversions.getValue().get(resolvedClass.getQualifiedName())) == null) {\n          return null;\n        }\n        return addTypeParameters(initialType, initialType.resolveGenerics(), target);\n      }\n\n      private PsiType getConversionClassType(PsiType initialType) {\n        if (initialType == null) return null;\n        final PsiType type = initialType.getDeepComponentType();\n        if (type instanceof PsiClassType) {\n          final PsiClassType.ClassResolveResult resolveResult = ((PsiClassType)type).resolveGenerics();\n          final PsiClass psiClass = resolveResult.getElement();\n          if (psiClass != null) {\n            final String qName = psiClass.getQualifiedName();\n            final PsiClass targetClass = myGuavaClassConversions.getValue().get(qName);\n            if (targetClass != null) {\n              final PsiClassType createdType = addTypeParameters(type, resolveResult, targetClass);\n              return initialType instanceof PsiArrayType ? wrapAsArray((PsiArrayType)initialType, createdType) : createdType;\n            }\n          }\n        }\n        return null;\n      }\n\n      ;\n\n      private PsiType wrapAsArray(PsiArrayType initial, PsiType created) {\n        PsiArrayType result = new PsiArrayType(created);\n        while (initial.getComponentType() instanceof PsiArrayType) {\n          initial = (PsiArrayType)initial.getComponentType();\n          result = new PsiArrayType(result);\n        }\n        return result;\n      }\n\n      private boolean isFluentIterableFromCall(PsiMethodCallExpression expression) {\n        PsiMethod method = expression.resolveMethod();\n        if (method == null || !GuavaFluentIterableConversionRule.CHAIN_HEAD_METHODS.contains(method.getName())) {\n          return false;\n        }\n        PsiClass aClass = method.getContainingClass();\n        return aClass != null && GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(aClass.getQualifiedName());\n      }\n\n      private PsiMethodCallExpression findGuavaMethodChain(PsiMethodCallExpression expression) {\n        PsiMethodCallExpression chain = expression;\n        while (true) {\n          final PsiMethodCallExpression current = PsiTreeUtil.getParentOfType(chain, PsiMethodCallExpression.class);\n          if (current != null && current.getMethodExpression().getQualifierExpression() == chain) {\n            final PsiMethod method = current.resolveMethod();\n            if (method == null) {\n              return chain;\n            }\n            if (FLUENT_ITERABLE_STOP_METHODS.getValue().contains(method.getName())) {\n              return null;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(containingClass.getQualifiedName())\n                                             || GuavaOptionalConversionRule.GUAVA_OPTIONAL.equals(containingClass.getQualifiedName()))) {\n              return chain;\n            }\n            final PsiType returnType = method.getReturnType();\n            final PsiClass returnClass = PsiTypesUtil.getPsiClass(returnType);\n            if (returnClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(returnClass.getQualifiedName())\n                                    || GuavaOptionalConversionRule.GUAVA_OPTIONAL.equals(returnClass.getQualifiedName()))) {\n              return chain;\n            }\n            if (GuavaTypeConversionDescriptor.isIterable(current)) {\n              return chain;\n            }\n          }\n          else {\n            return chain;\n          }\n          chain = current;\n        }\n      }\n\n      @NotNull\n      private PsiClassType addTypeParameters(PsiType currentType,\n                                             PsiClassType.ClassResolveResult currentTypeResolveResult,\n                                             PsiClass targetClass) {\n        final Map<PsiTypeParameter, PsiType> substitutionMap = currentTypeResolveResult.getSubstitutor().getSubstitutionMap();\n        final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(holder.getProject());\n        if (substitutionMap.size() == 1) {\n          return elementFactory.createType(targetClass, ContainerUtil.getFirstItem(substitutionMap.values()));\n        }\n        else {\n          LOG.assertTrue(substitutionMap.size() == 2);\n          LOG.assertTrue(GuavaLambda.FUNCTION.getJavaAnalogueClassQName().equals(targetClass.getQualifiedName()));\n          final PsiType returnType = LambdaUtil.getFunctionalInterfaceReturnType(currentType);\n          final List<PsiType> types = new ArrayList<PsiType>(substitutionMap.values());\n          types.remove(returnType);\n          final PsiType parameterType = types.get(0);\n          return elementFactory.createType(targetClass, parameterType, returnType);\n        }\n      }\n    };\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected TypeConversionDescriptorBase findConversionForMethod(@Nullable PsiType from,\n                                                                 @Nullable PsiType to,\n                                                                 @NotNull PsiMethod method,\n                                                                 @NotNull String methodName,\n                                                                 PsiExpression context,\n                                                                 TypeMigrationLabeler labeler) {\n    if (!(context instanceof PsiMethodCallExpression)) {\n      if (\"or\".equals(methodName)) {\n        PsiMethodCallExpression methodCallExpression = null;\n        if (context.getParent() instanceof PsiMethodCallExpression) {\n          methodCallExpression = (PsiMethodCallExpression)context.getParent();\n        }\n        if (methodCallExpression == null) {\n          return null;\n        }\n        final PsiClass aClass = getParameterClass(method);\n        if (aClass != null) {\n          final String qName = aClass.getQualifiedName();\n          if (GUAVA_OPTIONAL.equals(qName)) {\n            TypeConversionDescriptor descriptor =\n              new TypeConversionDescriptor(null, \"java.util.Optional.ofNullable($val$.orElseGet($o$::get))\") {\n                @Override\n                public PsiExpression replace(PsiExpression expression, TypeEvaluator evaluator) {\n                  setStringToReplace(\"$val$.or(\" +\n                                     GuavaOptionalConversionUtil.simplifyParameterPattern((PsiMethodCallExpression)expression)\n                                     + \")\");\n                  return super.replace(expression, evaluator);\n                }\n              };\n            if (to != null) {\n              descriptor.withConversionType(to);\n            }\n            return descriptor;\n          }\n          return GuavaSupplierConversionRule.GUAVA_SUPPLIER.equals(qName)\n                 ? new GuavaTypeConversionDescriptor(\"$val$.or($other$)\", \"$val$.orElseGet($other$)\")\n                 : new TypeConversionDescriptor(\"$val$.or($other$)\", \"$val$.orElse($other$)\");\n        }\n        return null;\n      }\n      else if (\"transform\".equals(methodName)) {\n        final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)(context.getParent());\n        final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n        if (arguments.length != 1) {\n          return null;\n        }\n        final PsiExpression functionArgument = arguments[0];\n        final TypeConversionDescriptor descriptor = new GuavaTypeConversionDescriptor(\"$val$.transform($fun$)\", \"$val$.map($fun$)\");\n        final PsiType typeParameter = GuavaConversionUtil.getFunctionReturnType(functionArgument);\n        if (typeParameter == null) {\n          return descriptor;\n        }\n        final String rawOptionalType = JAVA_OPTIONAL + \"<\" + typeParameter.getCanonicalText(false) + \">\";\n        return descriptor.withConversionType(JavaPsiFacade.getElementFactory(method.getProject()).createTypeFromText(rawOptionalType, context));\n      }\n      return null;\n    }\n    final PsiClass aClass = method.getContainingClass();\n    if (aClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(aClass.getQualifiedName()) ||\n                            GUAVA_OPTIONAL.equals(aClass.getQualifiedName()))) {\n      return null;\n    }\n    return GuavaFluentIterableConversionRule.buildCompoundDescriptor((PsiMethodCallExpression) context, to, labeler);\n  }","id":51609,"modified_method":"@Nullable\n  @Override\n  protected TypeConversionDescriptorBase findConversionForMethod(@Nullable PsiType from,\n                                                                 @Nullable PsiType to,\n                                                                 @NotNull PsiMethod method,\n                                                                 @NotNull String methodName,\n                                                                 PsiExpression context,\n                                                                 TypeMigrationLabeler labeler) {\n    if (!(context instanceof PsiMethodCallExpression)) {\n      if (\"or\".equals(methodName)) {\n        PsiMethodCallExpression methodCallExpression = null;\n        if (context.getParent() instanceof PsiMethodCallExpression) {\n          methodCallExpression = (PsiMethodCallExpression)context.getParent();\n        }\n        if (methodCallExpression == null) {\n          return null;\n        }\n        final PsiClass aClass = getParameterClass(method);\n        if (aClass != null) {\n          final String qName = aClass.getQualifiedName();\n          if (GUAVA_OPTIONAL.equals(qName)) {\n            TypeConversionDescriptor descriptor =\n              new TypeConversionDescriptor(null, \"java.util.Optional.ofNullable($val$.orElseGet($o$::get))\") {\n                @Override\n                public PsiExpression replace(PsiExpression expression, TypeEvaluator evaluator) {\n                  setStringToReplace(\"$val$.or(\" +\n                                     GuavaOptionalConversionUtil.simplifyParameterPattern((PsiMethodCallExpression)expression)\n                                     + \")\");\n                  return super.replace(expression, evaluator);\n                }\n              };\n            if (to != null) {\n              descriptor.withConversionType(to);\n            }\n            return descriptor;\n          }\n          return GuavaLambda.SUPPLIER.getClassQName().equals(qName)\n                 ? new GuavaTypeConversionDescriptor(\"$val$.or($other$)\", \"$val$.orElseGet($other$)\")\n                 : new TypeConversionDescriptor(\"$val$.or($other$)\", \"$val$.orElse($other$)\");\n        }\n        return null;\n      }\n      else if (\"transform\".equals(methodName)) {\n        final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)(context.getParent());\n        final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n        if (arguments.length != 1) {\n          return null;\n        }\n        final PsiExpression functionArgument = arguments[0];\n        final TypeConversionDescriptor descriptor = new GuavaTypeConversionDescriptor(\"$val$.transform($fun$)\", \"$val$.map($fun$)\");\n        final PsiType typeParameter = GuavaConversionUtil.getFunctionReturnType(functionArgument);\n        if (typeParameter == null) {\n          return descriptor;\n        }\n        final String rawOptionalType = JAVA_OPTIONAL + \"<\" + typeParameter.getCanonicalText(false) + \">\";\n        return descriptor.withConversionType(JavaPsiFacade.getElementFactory(method.getProject()).createTypeFromText(rawOptionalType, context));\n      }\n      return null;\n    }\n    final PsiClass aClass = method.getContainingClass();\n    if (aClass == null || !(GuavaFluentIterableConversionRule.FLUENT_ITERABLE.equals(aClass.getQualifiedName()) ||\n                            GUAVA_OPTIONAL.equals(aClass.getQualifiedName()))) {\n      return null;\n    }\n    return GuavaFluentIterableConversionRule.buildCompoundDescriptor((PsiMethodCallExpression) context, to, labeler);\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {\n      String newExpressionString =\n        adjust(((PsiMethodCallExpression)expression).getArgumentList().getExpressions()[0], true, myTargetType, evaluator) + \".negate()\";\n\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiMethodReferenceExpression) {\n        expression = replaceTypeCast(expression, parent);\n      }\n      else if (!isJavaPredicate(parent, evaluator)) {\n        newExpressionString += \"::test\";\n      }\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());\n      PsiExpression convertedExpression =\n        (PsiExpression)expression.replace(elementFactory.createExpressionFromText(newExpressionString, expression));\n      convertedExpression = convertedExpression.getParent() instanceof PsiMethodReferenceExpression\n                            ? (PsiExpression)convertedExpression.getParent().replace(convertedExpression)\n                            : convertedExpression;\n      final PsiElement maybeTypeCast = convertedExpression.getParent();\n      if (maybeTypeCast instanceof PsiTypeCastExpression && RedundantCastUtil.isCastRedundant((PsiTypeCastExpression)maybeTypeCast)) {\n        convertedExpression = (PsiExpression)maybeTypeCast.replace(((PsiTypeCastExpression)maybeTypeCast).getOperand());\n      }\n      return convertedExpression;\n    }","id":51610,"modified_method":"@Override\n    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {\n      String newExpressionString =\n        GuavaConversionUtil.adjust(((PsiMethodCallExpression)expression).getArgumentList().getExpressions()[0], true, myTargetType, evaluator).getText() + \".negate()\";\n\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiMethodReferenceExpression) {\n        expression = replaceTypeCast(expression, parent);\n      }\n      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {\n        newExpressionString += \"::test\";\n      }\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());\n      PsiExpression convertedExpression =\n        (PsiExpression)expression.replace(elementFactory.createExpressionFromText(newExpressionString, expression));\n      convertedExpression = convertedExpression.getParent() instanceof PsiMethodReferenceExpression\n                            ? (PsiExpression)convertedExpression.getParent().replace(convertedExpression)\n                            : convertedExpression;\n      final PsiElement maybeTypeCast = convertedExpression.getParent();\n      if (maybeTypeCast instanceof PsiTypeCastExpression && RedundantCastUtil.isCastRedundant((PsiTypeCastExpression)maybeTypeCast)) {\n        convertedExpression = (PsiExpression)maybeTypeCast.replace(((PsiTypeCastExpression)maybeTypeCast).getOperand());\n      }\n      return convertedExpression;\n    }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  static TypeConversionDescriptorBase tryConvertIfPredicates(PsiMethod method, PsiExpression context) {\n    final String name = method.getName();\n    if (name.equals(\"alwaysTrue\") || name.equals(\"alwaysFalse\")) {\n      return new TypeConversionDescriptorWithLocalVariable(name, \"$x$ -> \" + name.contains(\"True\") + \"\");\n    }\n    else if (name.equals(\"isNull\") || name.equals(\"notNull\")) {\n      final String operation = name.equals(\"isNull\") ? \"==\" : \"!=\";\n      return new TypeConversionDescriptorWithLocalVariable(name, \"$x$ -> $x$\" + operation + \" null\");\n    }\n    else if (name.equals(\"equalTo\")) {\n      return new TypeConversionDescriptorWithLocalVariable(\"equalTo\", \"$x$ -> java.util.Objects.equals($x$, $v$)\");\n    }\n    if (!isConvertablePredicatesMethod(method)) return null;\n    if (PREDICATES_AND_OR.contains(name) && canMigrateAndOrOr((PsiMethodCallExpression)context)) {\n      return new AndOrOrConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaPredicateConversionRule.JAVA_PREDICATE, context.getType(), context));\n    }\n    else if (PREDICATES_NOT.equals(name)) {\n      return new NotConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaPredicateConversionRule.JAVA_PREDICATE, context.getType(), context));\n    }\n    return null;\n  }","id":51611,"modified_method":"@Nullable\n  static TypeConversionDescriptorBase tryConvertIfPredicates(PsiMethod method, PsiExpression context) {\n    final String name = method.getName();\n    if (name.equals(\"alwaysTrue\") || name.equals(\"alwaysFalse\")) {\n      return new TypeConversionDescriptorWithLocalVariable(name, \"$x$ -> \" + name.contains(\"True\") + \"\");\n    }\n    else if (name.equals(\"isNull\") || name.equals(\"notNull\")) {\n      final String operation = name.equals(\"isNull\") ? \"==\" : \"!=\";\n      return new TypeConversionDescriptorWithLocalVariable(name, \"$x$ -> $x$\" + operation + \" null\");\n    }\n    else if (name.equals(\"equalTo\")) {\n      return new TypeConversionDescriptorWithLocalVariable(\"equalTo\", \"$x$ -> java.util.Objects.equals($x$, $v$)\");\n    }\n    if (!isConvertablePredicatesMethod(method)) return null;\n    if (PREDICATES_AND_OR.contains(name) && canMigrateAndOrOr((PsiMethodCallExpression)context)) {\n      return new AndOrOrConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));\n    }\n    else if (PREDICATES_NOT.equals(name)) {\n      return new NotConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));\n    }\n    return null;\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {\n      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;\n      final String methodName = methodCall.getMethodExpression().getReferenceName();\n\n      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());\n      if (arguments.length == 1) {\n        return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(adjust(arguments[0], true, myTargetType, evaluator), expression));\n      }\n      LOG.assertTrue(arguments.length != 0);\n      StringBuilder replaceBy = new StringBuilder();\n      for (int i = 1; i < arguments.length; i++) {\n        PsiExpression argument = arguments[i];\n        replaceBy.append(\".\").append(methodName).append(\"(\").append(adjust(argument, false, myTargetType, evaluator)).append(\")\");\n      }\n      replaceBy.insert(0, adjust(arguments[0], true, myTargetType, evaluator));\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiMethodReferenceExpression) {\n        expression = replaceTypeCast(expression, parent);\n      }\n      else if (!isJavaPredicate(parent, evaluator)) {\n        replaceBy.append(\"::test\");\n      }\n      return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(replaceBy.toString(), expression));\n    }","id":51612,"modified_method":"@Override\n    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {\n      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;\n      final String methodName = methodCall.getMethodExpression().getReferenceName();\n\n      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());\n      if (arguments.length == 1) {\n        return (PsiExpression)expression.replace(GuavaConversionUtil.adjust(arguments[0], true, myTargetType, evaluator));\n      }\n      LOG.assertTrue(arguments.length != 0);\n      StringBuilder replaceBy = new StringBuilder();\n      for (int i = 1; i < arguments.length; i++) {\n        PsiExpression argument = arguments[i];\n        replaceBy.append(\".\").append(methodName).append(\"(\").append(GuavaConversionUtil.adjust(argument, false, myTargetType, evaluator).getText()).append(\")\");\n      }\n      replaceBy.insert(0, GuavaConversionUtil.adjust(arguments[0], true, myTargetType, evaluator).getText());\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiMethodReferenceExpression) {\n        expression = replaceTypeCast(expression, parent);\n      }\n      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {\n        replaceBy.append(\"::test\");\n      }\n      return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(replaceBy.toString(), expression));\n    }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiExpression replaceTypeCast(PsiExpression expression, PsiElement parent) {\n    final PsiElement parParent = parent.getParent();\n    if (parParent instanceof PsiTypeCastExpression) {\n      final PsiTypeElement typeElement = ((PsiTypeCastExpression)parParent).getCastType();\n      if (typeElement != null) {\n        final PsiType type = typeElement.getType();\n        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);\n        if (aClass != null && GuavaPredicateConversionRule.JAVA_PREDICATE.equals(aClass.getQualifiedName())) {\n          expression = (PsiExpression)parParent.replace(expression);\n        }\n      }\n    }\n    return expression;\n  }","id":51613,"modified_method":"private static PsiExpression replaceTypeCast(PsiExpression expression, PsiElement parent) {\n    final PsiElement parParent = parent.getParent();\n    if (parParent instanceof PsiTypeCastExpression) {\n      final PsiTypeElement typeElement = ((PsiTypeCastExpression)parParent).getCastType();\n      if (typeElement != null) {\n        final PsiType type = typeElement.getType();\n        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);\n        if (aClass != null && GuavaLambda.PREDICATE.equals(aClass.getQualifiedName())) {\n          expression = (PsiExpression)parParent.replace(expression);\n        }\n      }\n    }\n    return expression;\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiExpression replace(PsiExpression expression, TypeEvaluator evaluator) throws IncorrectOperationException {\n    LOG.assertTrue(expression instanceof PsiMethodCallExpression);\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;\n    setReplaceByString(myReplaceByStringSource + (isIterable(methodCall) ? \".collect(java.util.stream.Collectors.toList())\" : \"\"));\n    if (myConvertParameterAsLambda) {\n      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n      if (arguments.length == 1) {\n        final PsiExpression functionArg = arguments[0];\n        convertParameter(functionArg, evaluator);\n      }\n    }\n    return super.replace(expression, evaluator);\n  }","id":51614,"modified_method":"@Override\n  public PsiExpression replace(PsiExpression expression, TypeEvaluator evaluator) throws IncorrectOperationException {\n    LOG.assertTrue(expression instanceof PsiMethodCallExpression);\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;\n    setReplaceByString(myReplaceByStringSource + (isIterable(methodCall) ? \".collect(java.util.stream.Collectors.toList())\" : \"\"));\n    if (myConvertParameterAsLambda) {\n      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();\n      if (arguments.length == 1) {\n        GuavaConversionUtil.adjust(arguments[0], false, null, evaluator);\n      }\n    }\n    return super.replace(expression, evaluator);\n  }","commit_id":"1eddae8d58037e638e40c97c82420b4d4005140f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void outputColumnsXml(final XMLOutputter outputter,\n      final Map<Text, byte[]> m)\n  throws IllegalStateException, IllegalArgumentException, IOException {\n    for (Map.Entry<Text, byte[]> e: m.entrySet()) {\n      outputter.startTag(COLUMN);\n      doElement(outputter, \"name\", e.getKey().toString());\n      // We don't know String from binary data so we always base64 encode.\n      doElement(outputter, \"value\",\n        org.apache.hadoop.hbase.util.Base64.encodeBytes(e.getValue()));\n      outputter.endTag();\n    }\n  }","id":51615,"modified_method":"protected void outputColumnsXml(final XMLOutputter outputter,\n      final Map<Text, byte[]> m)\n  throws IllegalStateException, IllegalArgumentException, IOException {\n    for (Map.Entry<Text, byte[]> e: m.entrySet()) {\n      outputter.startTag(COLUMN);\n      doElement(outputter, \"name\", \n        org.apache.hadoop.hbase.util.Base64.encodeBytes(\n          e.getKey().getBytes()));\n      // We don't know String from binary data so we always base64 encode.\n      doElement(outputter, \"value\",\n        org.apache.hadoop.hbase.util.Base64.encodeBytes(e.getValue()));\n      outputter.endTag();\n    }\n  }","commit_id":"07eb878e5aaa93df5396d2601323150d26b23760","url":"https://github.com/apache/hbase"},{"original_method":"private void outputScannerEntryXML(final HttpServletResponse response,\n    final ScannerRecord sr)\n  throws IOException {\n    HStoreKey key = sr.getKey();\n    \n    // respond with a 200 and Content-type: text/xml\n    setResponseHeader(response, 200, ContentType.XML.toString());\n    \n    // setup an xml outputter\n    XMLOutputter outputter = getXMLOutputter(response.getWriter());\n    \n    outputter.startTag(ROW);\n    \n    // write the row key\n    doElement(outputter, \"name\", key.getRow().toString());\n    \n    // Normally no column is supplied when scanning.\n    if (key.getColumn() != null &&\n        key.getColumn().getLength() > 0) {\n      doElement(outputter, \"key-column\", key.getColumn().toString());\n    }\n    \n    doElement(outputter, \"timestamp\", Long.toString(key.getTimestamp()));\n    \n    outputColumnsXml(outputter, sr.getValue());\n    outputter.endTag();\n    outputter.endDocument();\n    outputter.getWriter().close();\n  }","id":51616,"modified_method":"private void outputScannerEntryXML(final HttpServletResponse response,\n    final ScannerRecord sr)\n  throws IOException {\n    HStoreKey key = sr.getKey();\n    \n    // respond with a 200 and Content-type: text/xml\n    setResponseHeader(response, 200, ContentType.XML.toString());\n    \n    // setup an xml outputter\n    XMLOutputter outputter = getXMLOutputter(response.getWriter());\n    \n    outputter.startTag(ROW);\n    \n    // write the row key\n    doElement(outputter, \"name\", \n      org.apache.hadoop.hbase.util.Base64.encodeBytes(key.getRow().getBytes()));\n    \n    // Normally no column is supplied when scanning.\n    if (key.getColumn() != null &&\n        key.getColumn().getLength() > 0) {\n      doElement(outputter, \"key-column\", \n        org.apache.hadoop.hbase.util.Base64.encodeBytes(\n          key.getColumn().getBytes()));\n    }\n    \n    doElement(outputter, \"timestamp\", Long.toString(key.getTimestamp()));\n    \n    outputColumnsXml(outputter, sr.getValue());\n    outputter.endTag();\n    outputter.endDocument();\n    outputter.getWriter().close();\n  }","commit_id":"07eb878e5aaa93df5396d2601323150d26b23760","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n        StringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getNumberOfTargets() > 1){\n            sb.append(target.getNumberOfTargets()).append(\" target \").append(target.getTargetName()).append(\" get \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" gets \");\n        }\n        String p = power.toString();\n        if(!p.startsWith(\"-\")) {\n            sb.append(\"+\");\n        }\n        sb.append(p).append(\"/\");\n        String t = toughness.toString();\n        if(!t.startsWith(\"-\")){\n            if(p.startsWith(\"-\")) {\n                sb.append(\"-\");\n            }\n            else {\n                sb.append(\"+\");\n            }\n        }\n        sb.append(t);\n        if (duration != Duration.WhileOnBattlefield) {\n            sb.append(\" \").append(duration.toString());\n        }\n        String message = null;\n        String fixedPart = null;\n        if (t.equals(\"X\")) {\n            message = toughness.getMessage();\n            fixedPart = \", where X is \";\n        } else if (p.equals(\"X\")) {\n            message = power.getMessage();\n            fixedPart = \", where X is \";\n        } else if (!power.getMessage().isEmpty()) {\n            message = power.getMessage();\n            fixedPart = \" for each \";\n        } else if (!toughness.getMessage().isEmpty()) {\n            message = toughness.getMessage();\n            fixedPart = \" for each \";\n        }\n        if (message != null && !message.isEmpty() && fixedPart != null) {\n            sb.append(fixedPart).append(message);\n        }\n        return sb.toString();\n    }","id":51617,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n        StringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getMaxNumberOfTargets() > 1){\n            if (target.getNumberOfTargets() < target.getNumberOfTargets()) {\n                sb.append(\"up to \");\n            }\n            sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(\" target \").append(target.getTargetName()).append(\" get \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" gets \");\n        }\n        String p = power.toString();\n        if(!p.startsWith(\"-\")) {\n            sb.append(\"+\");\n        }\n        sb.append(p).append(\"/\");\n        String t = toughness.toString();\n        if(!t.startsWith(\"-\")){\n            if(p.startsWith(\"-\")) {\n                sb.append(\"-\");\n            }\n            else {\n                sb.append(\"+\");\n            }\n        }\n        sb.append(t);\n        if (duration != Duration.WhileOnBattlefield) {\n            sb.append(\" \").append(duration.toString());\n        }\n        String message = null;\n        String fixedPart = null;\n        if (t.equals(\"X\")) {\n            message = toughness.getMessage();\n            fixedPart = \", where X is \";\n        } else if (p.equals(\"X\")) {\n            message = power.getMessage();\n            fixedPart = \", where X is \";\n        } else if (!power.getMessage().isEmpty()) {\n            message = power.getMessage();\n            fixedPart = \" for each \";\n        } else if (!toughness.getMessage().isEmpty()) {\n            message = toughness.getMessage();\n            fixedPart = \" for each \";\n        }\n        if (message != null && !message.isEmpty() && fixedPart != null) {\n            sb.append(fixedPart).append(message);\n        }\n        return sb.toString();\n    }","commit_id":"ea0b24fea04d3795727f7c246810988a7d065e62","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            Cards cards = new CardsImpl(Zone.PICK);\r\n\r\n            boolean properCardFound = false;\r\n            int count = Math.min(player.getLibrary().size(), 5);\r\n            for (int i = 0; i < count; i++) {\r\n                Card card = player.getLibrary().removeFromTop(game);\r\n                if (card != null) {\r\n                    cards.add(card);\r\n                    if (filterPutInHand.match(card, source.getSourceId(), source.getControllerId(), game)) {\r\n                        properCardFound = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!cards.isEmpty()) {\r\n                player.revealCards(\"Grisly Salvage\", cards, game);\r\n                TargetCard target = new TargetCard(Zone.PICK, filterPutInHand);\r\n                if (properCardFound && player.choose(Outcome.DrawCard, cards, target, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        cards.remove(card);\r\n                        card.moveToZone(Zone.HAND, source.getId(), game, false);\r\n                    }\r\n\r\n                }\r\n\r\n                for (UUID cardId : cards) {\r\n                    Card card = game.getCard(cardId);\r\n                    if (card != null) {\r\n                        card.moveToZone(Zone.GRAVEYARD, source.getId(), game, true);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":51618,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            Cards cards = new CardsImpl(Zone.PICK);\r\n\r\n            boolean properCardFound = false;\r\n            int count = Math.min(player.getLibrary().size(), 5);\r\n            for (int i = 0; i < count; i++) {\r\n                Card card = player.getLibrary().removeFromTop(game);\r\n                if (card != null) {\r\n                    cards.add(card);\r\n                    if (filterPutInHand.match(card, source.getSourceId(), source.getControllerId(), game)) {\r\n                        properCardFound = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!cards.isEmpty()) {\r\n                player.revealCards(\"Grisly Salvage\", cards, game);\r\n                TargetCard target = new TargetCard(Zone.PICK, filterPutInHand);\r\n                if (properCardFound && player.choose(Outcome.DrawCard, cards, target, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        cards.remove(card);\r\n                        card.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n                    }\r\n\r\n                }\r\n\r\n                for (UUID cardId : cards) {\r\n                    Card card = game.getCard(cardId);\r\n                    if (card != null) {\r\n                        card.moveToZone(Zone.GRAVEYARD, source.getSourceId(), game, true);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"ea0b24fea04d3795727f7c246810988a7d065e62","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic String getText(Mode mode) {\n\t\tStringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getNumberOfTargets() > 1){\n            sb.append(target.getNumberOfTargets()).append(\" target \").append(target.getTargetName()).append(\" gain \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" gains \");\n        }\n\t\tsb.append(ability.getRule()).append(\" \").append(duration.toString());\n\t\treturn sb.toString();\n\t}","id":51619,"modified_method":"@Override\n\tpublic String getText(Mode mode) {\n\t\tStringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getNumberOfTargets() > 1){\n            if (target.getNumberOfTargets() < target.getMaxNumberOfTargets()) {\n                sb.append(\"Up to\");\n            }\n            sb.append(target.getMaxNumberOfTargets()).append(\" target \").append(target.getTargetName()).append(\" gain \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" gains \");\n        }\n\t\tsb.append(ability.getRule()).append(\" \").append(duration.toString());\n\t\treturn sb.toString();\n\t}","commit_id":"182d63607829820c8d36a48c8e7614a2b7369530","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic String getText(Mode mode) {\n\t\tTarget target = mode.getTargets().get(0);\n\t\tif (target.getNumberOfTargets() > 1)\n\t\t\treturn \"untap \" + target.getNumberOfTargets() + \" target \" + mode.getTargets().get(0).getTargetName() + \"s\";\n\t\telse\n\t\t\treturn \"untap target \" + mode.getTargets().get(0).getTargetName();\n\t}","id":51620,"modified_method":"@Override\n    public String getText(Mode mode) {\n        Target target = mode.getTargets().get(0);\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Untap \");\n        if (target.getNumberOfTargets() == 0) {\n            sb.append(\"up to \");\n        }\n\n        if (target.getMaxNumberOfTargets() > 1 || target.getNumberOfTargets() == 0) {\n            sb.append(target.getMaxNumberOfTargets()).append(\" target \").append(target.getTargetName()).append(\"s\");\n        } else {\n            sb.append(\"target \").append(target.getTargetName());\n        }\n\n        return sb.toString();\n    }","commit_id":"662e05e765ea299db8708567f6a2b4b91a210e67","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n  public boolean isInsideUndoableCommand() {\n    return false;\n  }","id":51621,"modified_method":"@Override\n  public boolean isInsideUndoableCommand() {\n    return ModelAccess.instance().isInsideCommand();\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doTestIncrementalGeneration(final Project p, final SModel originalModel, final ModelChangeRunnable... changeModel) throws IOException {\n    String randomName = \"testxw\" + Math.abs(UUID.randomUUID().getLeastSignificantBits()) + \".\" + originalModel.getModule().getModuleName();\n    String randomId = UUID.randomUUID().toString();\n    final TestModule tm = new TestModule(randomName, randomId, originalModel.getModule());\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        MPSModuleRepository.getInstance().registerModule(tm, myOwner);\n      }\n    });\n\n    final SModel[] descr1 = new SModel[]{null};\n    try {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          descr1[0] = tm.createModel(originalModel);\n          tm.publish(descr1[0]);\n        }\n      });\n      final SModel descr = descr1[0];\n\n      File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n      if (generatorCaches.exists()) {\n        Assert.assertTrue(FileUtil.delete(generatorCaches));\n      }\n      Assert.assertTrue(\"cannot create caches folder\", generatorCaches.mkdir());\n\n      final MyIncrementalGenerationStrategy incrementalStrategy = new MyIncrementalGenerationStrategy(descr,\n          new FileBasedGenerationCacheContainer(generatorCaches));\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          incrementalStrategy.buildHash();\n        }\n      });\n      List<String> hashes = new ArrayList<String>();\n      hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));\n\n      // Stage 1. Regenerate\n\n      GenerationOptions options = GenerationOptions.getDefaults()\n          .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler(p);\n      GenerationFacade.generateModels(p,\n          Collections.singletonList(descr), ModuleContext.create(descr, p),\n          generationHandler,\n          new EmptyProgressMonitor(), new TestMessageHandler(), options,\n          new TransientModelsProvider(p, null));\n\n      Map<String, String> generated = replaceInContent(generationHandler.getGeneratedContent(),\n          new String[]{randomName, originalModel.getModule().getModuleName()},\n          new String[]{randomId, originalModel.getModule().getModuleReference().getModuleId().toString()});\n      assertNoDiff(generationHandler.getExistingContent(), generated);\n\n      // Stage 2. Modify model\n\n      Map<String, String> incrementalGenerationResults = generationHandler.getGeneratedContent();\n      List<Long> time = new ArrayList<Long>();\n      Assert.assertTrue(changeModel.length > 0);\n      for (final ModelChangeRunnable r : changeModel) {\n\n        ThreadUtils.runInUIThreadAndWait(new Runnable() {\n          @Override\n          public void run() {\n            p.getModelAccess().executeCommand(new Runnable() {\n              @Override\n              public void run() {\n                r.run(descr);\n              }\n            });\n          }\n        });\n\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            incrementalStrategy.buildHash();\n          }\n        });\n        hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));\n        Assert.assertNotNull(generationHandler.getLastDependencies());\n        incrementalStrategy.setDependencies(generationHandler.getLastDependencies());\n\n        // Stage 3. Generate incrementally\n\n        options = GenerationOptions.getDefaults()\n            .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n        generationHandler = new IncrementalTestGenerationHandler(p, incrementalGenerationResults);\n        generationHandler.checkIncremental(options);\n        long start = System.nanoTime();\n        GenerationFacade.generateModels(p,\n            Collections.singletonList(descr), ModuleContext.create(descr, p),\n            generationHandler,\n            new EmptyProgressMonitor(), new TestMessageHandler(), options,\n            new TransientModelsProvider(p, null));\n        time.add(System.nanoTime() - start);\n\n        incrementalGenerationResults = generationHandler.getGeneratedContent();\n        assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n      }\n\n      // Stage 4. Regenerate. Check incremental results.\n\n      incrementalStrategy.setDependencies(null);\n      options = GenerationOptions.getDefaults()\n          .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(p, incrementalGenerationResults);\n      long start = System.nanoTime();\n      GenerationFacade.generateModels(p,\n          Collections.singletonList(descr), ModuleContext.create(descr, p),\n          generationHandler,\n          new EmptyProgressMonitor(), new TestMessageHandler(), options,\n          new TransientModelsProvider(p, null));\n      time.add(System.nanoTime() - start);\n\n      assertNoDiff(incrementalGenerationResults, generationHandler.getGeneratedContent());\n\n      PerformanceMessenger.getInstance().reportPercent(\"incrementalGeneration\", (time.get(time.size() - 2)) / 1000000,\n          (time.get(time.size() - 1)) / 1000000);\n\n      if (DEBUG) {\n        long regen = time.remove(time.size() - 1);\n        System.out.print(\"Full cycle: \" + regen / 1000000 / 1000.);\n        for (long l : time) {\n          System.out.print(\", incremental: \" + l / 1000000 / 1000.);\n        }\n        System.out.println();\n      }\n    } finally {\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          MPSModuleRepository.getInstance().unregisterModule(tm, myOwner);\n        }\n      });\n    }\n  }","id":51622,"modified_method":"protected void doTestIncrementalGeneration(final Project p, final SModel originalModel, final ModelChangeRunnable... changeModel) throws IOException {\n    String randomName = \"testxw\" + Math.abs(UUID.randomUUID().getLeastSignificantBits()) + \".\" + originalModel.getModule().getModuleName();\n    String randomId = UUID.randomUUID().toString();\n    final TestModule tm = new TestModule(randomName, randomId, originalModel.getModule());\n    p.getModelAccess().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        MPSModuleRepository.getInstance().registerModule(tm, myOwner);\n      }\n    });\n\n    final SModel[] descr1 = new SModel[]{null};\n    try {\n      p.getModelAccess().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          descr1[0] = tm.createModel(originalModel);\n          tm.publish(descr1[0]);\n        }\n      });\n      final SModel descr = descr1[0];\n\n      File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n      if (generatorCaches.exists()) {\n        Assert.assertTrue(FileUtil.delete(generatorCaches));\n      }\n      Assert.assertTrue(\"cannot create caches folder\", generatorCaches.mkdir());\n\n      final MyIncrementalGenerationStrategy incrementalStrategy = new MyIncrementalGenerationStrategy(descr,\n          new FileBasedGenerationCacheContainer(generatorCaches));\n      p.getModelAccess().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          incrementalStrategy.buildHash();\n        }\n      });\n      List<String> hashes = new ArrayList<String>();\n      hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));\n\n      // Stage 1. Regenerate\n\n      GenerationOptions options = GenerationOptions.getDefaults()\n          .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler(p);\n      GenerationFacade.generateModels(p,\n          Collections.singletonList(descr), ModuleContext.create(descr, p),\n          generationHandler,\n          new EmptyProgressMonitor(), new TestMessageHandler(), options,\n          new TransientModelsProvider(p, null));\n\n      Map<String, String> generated = replaceInContent(generationHandler.getGeneratedContent(),\n          new String[]{randomName, originalModel.getModule().getModuleName()},\n          new String[]{randomId, originalModel.getModule().getModuleReference().getModuleId().toString()});\n      assertNoDiff(generationHandler.getExistingContent(), generated);\n\n      // Stage 2. Modify model\n\n      Map<String, String> incrementalGenerationResults = generationHandler.getGeneratedContent();\n      List<Long> time = new ArrayList<Long>();\n      Assert.assertTrue(changeModel.length > 0);\n      for (final ModelChangeRunnable r : changeModel) {\n\n        ThreadUtils.runInUIThreadAndWait(new Runnable() {\n          @Override\n          public void run() {\n            p.getModelAccess().executeCommand(new Runnable() {\n              @Override\n              public void run() {\n                r.run(descr);\n              }\n            });\n          }\n        });\n\n        p.getModelAccess().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            incrementalStrategy.buildHash();\n          }\n        });\n        hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));\n        Assert.assertNotNull(generationHandler.getLastDependencies());\n        incrementalStrategy.setDependencies(generationHandler.getLastDependencies());\n\n        // Stage 3. Generate incrementally\n\n        options = GenerationOptions.getDefaults()\n            .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n        generationHandler = new IncrementalTestGenerationHandler(p, incrementalGenerationResults);\n        generationHandler.checkIncremental(options);\n        long start = System.nanoTime();\n        GenerationFacade.generateModels(p,\n            Collections.singletonList(descr), ModuleContext.create(descr, p),\n            generationHandler,\n            new EmptyProgressMonitor(), new TestMessageHandler(), options,\n            new TransientModelsProvider(p, null));\n        time.add(System.nanoTime() - start);\n\n        incrementalGenerationResults = generationHandler.getGeneratedContent();\n        assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n      }\n\n      // Stage 4. Regenerate. Check incremental results.\n\n      incrementalStrategy.setDependencies(null);\n      options = GenerationOptions.getDefaults()\n          .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(p, incrementalGenerationResults);\n      long start = System.nanoTime();\n      GenerationFacade.generateModels(p,\n          Collections.singletonList(descr), ModuleContext.create(descr, p),\n          generationHandler,\n          new EmptyProgressMonitor(), new TestMessageHandler(), options,\n          new TransientModelsProvider(p, null));\n      time.add(System.nanoTime() - start);\n\n      assertNoDiff(incrementalGenerationResults, generationHandler.getGeneratedContent());\n\n      PerformanceMessenger.getInstance().reportPercent(\"incrementalGeneration\", (time.get(time.size() - 2)) / 1000000,\n          (time.get(time.size() - 1)) / 1000000);\n\n      if (DEBUG) {\n        long regen = time.remove(time.size() - 1);\n        System.out.print(\"Full cycle: \" + regen / 1000000 / 1000.);\n        for (long l : time) {\n          System.out.print(\", incremental: \" + l / 1000000 / 1000.);\n        }\n        System.out.println();\n      }\n    } finally {\n      p.getModelAccess().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          MPSModuleRepository.getInstance().unregisterModule(tm, myOwner);\n        }\n      });\n    }\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void testBaseLanguageStructure() throws IOException {\n    final Project p = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(p, \"jetbrains.mps.baseLanguage.structure\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"Expression\");\n          Assert.assertNotNull(\"No root in model\", root);\n          SNodeAccessUtil.setProperty(root, SNodeUtil.property_INamedConcept_name, \"ReExpression\");\n        }\n      });\n\n    cleanup(p);\n  }","id":51623,"modified_method":"/**\n   * Passes when runs alone, (with CCE in SNode.setProperty due to TestModule$TestSModelDescriptor !instanceof EditableSModel)\n   */\n  @Test\n  public void testBaseLanguageStructure() throws IOException {\n    myProject = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(myProject, \"jetbrains.mps.baseLanguage.structure\");\n\n    doTestIncrementalGeneration(myProject, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"Expression\");\n          Assert.assertNotNull(\"No root in model\", root);\n          SNodeAccessUtil.setProperty(root, SNodeUtil.property_INamedConcept_name, \"ReExpression\");\n        }\n      });\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void testIdeActions() throws IOException {\n    final Project p = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(p, \"jetbrains.mps.ide.actions\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"GoToFile\");\n          Assert.assertNotNull(\"No root in model\", root);\n          SNodeAccessUtil.setProperty(root, SNodeUtil.property_INamedConcept_name, \"GoToFile2\");\n        }\n      });\n\n    cleanup(p);\n  }","id":51624,"modified_method":"/**\n   * Fails with diff: ConceptMethodCallUtils tells whether to use reflection for non-virtual method based on module instanceof Solution\n   * However, during test, j.m.ide.actions is inside TestModule, which is not a Solution, hence calls to non-virtual methods are generated differently.\n   */\n  @Test\n  public void testIdeActions() throws IOException {\n    myProject = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(myProject, \"jetbrains.mps.ide.actions\");\n\n    doTestIncrementalGeneration(myProject, descr,\n        new ModelChangeRunnable() {\n          @Override\n          public void run(SModel descr) {\n            SModel model = descr;\n            SNode root = SModelOperations.getRootByName(model, \"GoToFile\");\n            Assert.assertNotNull(\"No root in model\", root);\n            SNodeAccessUtil.setProperty(root, SNodeUtil.property_INamedConcept_name, \"GoToFile2\");\n          }\n        });\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void testIncSolution1() throws IOException {\n    final Project p = loadProject(new File(System.getProperty(\"user.dir\") + \"/languages/languageDesign/generator\"));\n    SModel descr = findModel(p, \"test_Closure\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"User\");\n          Assert.assertNotNull(\"No root in model\", root);\n\n          SNode found = null;\n          for(SNode md : root.getChildren(\"member\")) {\n            if(md.getName().equals(\"testRename2\") && md.getConcept().getQualifiedName().equals(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) {\n              found = md;\n            }\n          }\n          Assert.assertNotNull(\"no method in class\", found);\n          SNodeAccessUtil.setProperty(found, SNodeUtil.property_INamedConcept_name, \"testRename3\");\n        }\n      });\n\n    cleanup(p);\n  }","id":51625,"modified_method":"/**\n   * Passes (with IllegalStateException: Event outside of a command and TestModule$TestSModelDescriptor !instanceof EditableSModel).\n   */\n  @Test\n  public void testIncSolution1() throws IOException {\n    myProject = loadProject(new File(System.getProperty(\"user.dir\") + \"/languages/languageDesign/generator\"));\n    SModel descr = findModel(myProject, \"test_Closure\");\n\n    doTestIncrementalGeneration(myProject, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"User\");\n          Assert.assertNotNull(\"No root in model\", root);\n\n          SNode found = null;\n          for(SNode md : root.getChildren(\"member\")) {\n            if(md.getName().equals(\"testRename2\") && md.getConcept().getQualifiedName().equals(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) {\n              found = md;\n            }\n          }\n          Assert.assertNotNull(\"no method in class\", found);\n          SNodeAccessUtil.setProperty(found, SNodeUtil.property_INamedConcept_name, \"testRename3\");\n        }\n      });\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void testBaseLanguageEditor() throws IOException {\n    final Project p = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(p, \"jetbrains.mps.baseLanguage.editor\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        @Override\n        public void run(SModel descr) {\n          SModel model = descr;\n          SNode root = SModelOperations.getRootByName(model,\"StatementList_Editor\");\n          Assert.assertNotNull(\"No root in model\", root);\n          descr.removeRootNode(root);\n        }\n      });\n\n    cleanup(p);\n  }","id":51626,"modified_method":"/**\n   * Fails with UnsupportedOperationException in SModelBase.removeRootNode\n   */\n  @Test\n  public void testBaseLanguageEditor() throws IOException {\n    myProject = loadProject(new File(System.getProperty(\"user.dir\")));\n    SModel descr = findModel(myProject, \"jetbrains.mps.baseLanguage.editor\");\n\n    doTestIncrementalGeneration(myProject, descr,\n        new ModelChangeRunnable() {\n          @Override\n          public void run(SModel descr) {\n            SModel model = descr;\n            SNode root = SModelOperations.getRootByName(model, \"StatementList_Editor\");\n            Assert.assertNotNull(\"No root in model\", root);\n            descr.removeRootNode(root);\n          }\n        });\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public jetbrains.mps.smodel.SModel createModel() {\n      Document document = ModelPersistence.saveModel(((SModelBase) myToCopy).getSModel());\n      Element rootElement = document.getRootElement();\n      rootElement.setAttribute(ModelPersistence.MODEL_UID, getReference().toString());\n      String modelContent = JDOMUtil.asString(document);\n      try {\n        return ModelPersistence.readModel(modelContent, false);\n      } catch (ModelReadException e) {\n        return new StubModel(PersistenceFacade.getInstance().createModelReference(myLongName), e);\n      }\n    }","id":51627,"modified_method":"@Override\n    public jetbrains.mps.smodel.SModel createModel() {\n      if (!myToCopy.isLoaded()) {\n        // we are going to access internal/implementation model which might be in a partially-loaded\n        // state (only public API guarantees proper loading). With partial model, we could face odd\n        // issues (e.g. incomplete set of implicit imports as implementation node's concepts are not considered)\n        myToCopy.load();\n      }\n      Document document = ModelPersistence.saveModel(((SModelBase) myToCopy).getSModel());\n      Element rootElement = document.getRootElement();\n      rootElement.setAttribute(ModelPersistence.MODEL_UID, getReference().toString());\n      String modelContent = JDOMUtil.asString(document);\n      try {\n        return ModelPersistence.readModel(modelContent, false);\n      } catch (ModelReadException e) {\n        return new StubModel(PersistenceFacade.getInstance().createModelReference(myLongName), e);\n      }\n    }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SModel resolveInDependencies(SModelId reference) {\n    boolean own = myModels.keySet().contains(SModelStereotype.withoutStereotype(reference.getModelName()));\n    if (!own) return super.resolveInDependencies(reference);\n    return myModels.get(reference.getModelName());\n  }","id":51628,"modified_method":"@Override\n  public SModel resolveInDependencies(SModelId reference) {\n    boolean own = reference.getModelName() != null && myModels.keySet().contains(SModelStereotype.withoutStereotype(reference.getModelName()));\n    if (!own) return super.resolveInDependencies(reference);\n    return myModels.get(reference.getModelName());\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Set<SLanguage> getUsedLanguages() {\n    //todo make scope more precise. Was left untouched since Evgeny wrote this class\n    return (Set)CollectionUtil.filter(Language.class, IterableUtil.asSet(MPSModuleRepository.getInstance().getModules()));\n  }","id":51629,"modified_method":"@Override\n  public Set<SLanguage> getUsedLanguages() {\n    return myPeer.getUsedLanguages();\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Iterable<SDependency> getDeclaredDependencies() {\n    //todo make scope more precise. Was left untouched since Evgeny wrote this class\n    return (Iterable)MPSModuleRepository.getInstance().getModules();\n  }","id":51630,"modified_method":"@Override\n  public Iterable<SDependency> getDeclaredDependencies() {\n    return myPeer.getDeclaredDependencies();\n  }","commit_id":"50b367535c04529a4d12eca7b295e6861f26c62f","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @return Returns the interruption check statement.\n     */\n    protected Statement createInterruptStatement() {\n        return new IfStatement(\n                new BooleanExpression(\n                        createCondition()\n                ),\n                new ThrowStatement(\n                        new ConstructorCallExpression(thrownExceptionType,\n                                new ArgumentListExpression(new ConstantExpression(getErrorMessage())))\n                ),\n                EmptyStatement.INSTANCE\n        );\n    }","id":51631,"modified_method":"/**\n     * @return Returns the interruption check statement.\n     */\n    protected Statement createInterruptStatement() {\n        return ifS(createCondition(),\n                throwS(\n                        ctorX(thrownExceptionType, args(constX(getErrorMessage())))\n                )\n        );\n    }","commit_id":"fbb2ae8575ba71f0270455d0f4e78c4c9eedfa5b","url":"https://github.com/apache/groovy"},{"original_method":"private Statement checkFinalArgNotOverridden(ClassNode cNode, FieldNode fNode) {\n        final String name = fNode.getName();\n        Expression value = findArg(name);\n        return ifS(\n                notX(equalsNullX(value)),\n                new ThrowStatement(ctorX(READONLYEXCEPTION_TYPE,\n                        args(constX(name), constX(cNode.getName()))\n                )));\n    }","id":51632,"modified_method":"private Statement checkFinalArgNotOverridden(ClassNode cNode, FieldNode fNode) {\n        final String name = fNode.getName();\n        Expression value = findArg(name);\n        return ifS(\n                notX(equalsNullX(value)),\n                throwS(ctorX(READONLYEXCEPTION_TYPE,\n                        args(constX(name), constX(cNode.getName()))\n                )));\n    }","commit_id":"fbb2ae8575ba71f0270455d0f4e78c4c9eedfa5b","url":"https://github.com/apache/groovy"},{"original_method":"private Statement throwAssertionFailedError(AnnotationNode annotationNode) {\n        ThrowStatement throwStatement = new ThrowStatement(\n                new ConstructorCallExpression(ASSERTION_FAILED_ERROR_TYPE,\n                        new ArgumentListExpression(\n                                new ConstantExpression(\"Method is marked with @NotYetImplemented but passes unexpectedly\"))));\n\n        throwStatement.setSourcePosition(annotationNode);\n\n        return throwStatement;\n    }","id":51633,"modified_method":"private Statement throwAssertionFailedError(AnnotationNode annotationNode) {\n        Statement throwStatement = throwS(\n                ctorX(ASSERTION_FAILED_ERROR_TYPE,\n                        args(constX(\"Method is marked with @NotYetImplemented but passes unexpectedly\"))));\n        throwStatement.setSourcePosition(annotationNode);\n\n        return throwStatement;\n    }","commit_id":"fbb2ae8575ba71f0270455d0f4e78c4c9eedfa5b","url":"https://github.com/apache/groovy"},{"original_method":"private void createConstructor(ClassNode classNode, FieldNode field, String propertyName, boolean isStrict) {\r\n        final List<ConstructorNode> cNodes = classNode.getDeclaredConstructors();\r\n        ConstructorNode foundNoArg = null;\r\n        for (ConstructorNode cNode : cNodes) {\r\n            final Parameter[] parameters = cNode.getParameters();\r\n            if (parameters == null || parameters.length == 0) {\r\n                foundNoArg = cNode;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isStrict && !cNodes.isEmpty()) {\n            for (ConstructorNode cNode : cNodes) {\r\n                addError(\"@Singleton didn't expect to find one or more additional constructors: remove constructor(s) or set strict=false\", cNode);\r\n            }\r\n        }\r\n\r\n        if (foundNoArg == null) {\r\n            final BlockStatement body = new BlockStatement();\r\n            body.addStatement(ifS(\r\n                    notNullX(varX(field)),\r\n                    new ThrowStatement(\r\n                            ctorX(make(RuntimeException.class),\r\n                                    args(constX(\"Can't instantiate singleton \" + classNode.getName() + \". Use \" + classNode.getName() + \".\" + propertyName))))\r\n            ));\r\n            classNode.addConstructor(new ConstructorNode(ACC_PRIVATE, body));\r\n        }\r\n    }","id":51634,"modified_method":"private void createConstructor(ClassNode classNode, FieldNode field, String propertyName, boolean isStrict) {\r\n        final List<ConstructorNode> cNodes = classNode.getDeclaredConstructors();\r\n        ConstructorNode foundNoArg = null;\r\n        for (ConstructorNode cNode : cNodes) {\r\n            final Parameter[] parameters = cNode.getParameters();\r\n            if (parameters == null || parameters.length == 0) {\r\n                foundNoArg = cNode;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isStrict && !cNodes.isEmpty()) {\r\n            for (ConstructorNode cNode : cNodes) {\r\n                addError(\"@Singleton didn't expect to find one or more additional constructors: remove constructor(s) or set strict=false\", cNode);\r\n            }\r\n        }\r\n\r\n        if (foundNoArg == null) {\r\n            final BlockStatement body = new BlockStatement();\r\n            body.addStatement(ifS(\r\n                    notNullX(varX(field)),\r\n                    throwS(\r\n                            ctorX(make(RuntimeException.class),\r\n                                    args(constX(\"Can't instantiate singleton \" + classNode.getName() + \". Use \" + classNode.getName() + \".\" + propertyName))))\r\n            ));\r\n            classNode.addConstructor(new ConstructorNode(ACC_PRIVATE, body));\r\n        }\r\n    }","commit_id":"fbb2ae8575ba71f0270455d0f4e78c4c9eedfa5b","url":"https://github.com/apache/groovy"},{"original_method":"private static BlockStatement illegalArgumentBlock(String message) {\r\n        return block(\r\n                new ThrowStatement(ctorX(make(IllegalArgumentException.class), args(constX(message)))));\r\n    }","id":51635,"modified_method":"private static BlockStatement illegalArgumentBlock(String message) {\r\n        return block(throwS(ctorX(make(IllegalArgumentException.class), args(constX(message)))));\r\n    }","commit_id":"fbb2ae8575ba71f0270455d0f4e78c4c9eedfa5b","url":"https://github.com/apache/groovy"},{"original_method":"/**\r\n     * @see RuleBase\r\n     */\r\n    public synchronized StatefulSession newStatefulSession(final boolean keepReference) {\r\n        if ( this.config.isSequential() ) {\r\n            throw new RuntimeException( \"Cannot have a stateful rule session, with sequential configuration set to true\" );\r\n        }\r\n        ReteooStatefulSession session = null;\r\n\r\n        synchronized ( this.pkgs ) {\r\n            ExecutorService executor = this.config.getExecutorService();\r\n            session = new ReteooStatefulSession( nextWorkingMemoryCounter(),\r\n                                                 this,\r\n                                                 executor );\r\n\r\n            executor.setCommandExecutor( new CommandExecutor( session ) );\r\n\r\n            if ( keepReference ) {\r\n                super.addStatefulSession( session );\r\n            }\r\n\r\n            final InitialFactHandle handle = new InitialFactHandle( session.getFactHandleFactory().newFactHandle( new InitialFactHandleDummyObject() ) );\r\n\r\n            session.queueWorkingMemoryAction( new WorkingMemoryReteAssertAction( handle,\r\n                                                                                 false,\r\n                                                                                 true,\r\n                                                                                 null,\r\n                                                                                 null ) );\r\n        }\r\n        \r\n        // setup event listener for fireAllRules on rulebase modifications\r\n        FireAllRulesBeforeUnlockEventListener listener =  new DefaultFireAllRulesBeforeUnlockEventListener();\r\n        listener.setSession( session );\r\n        addEventListener( listener );\r\n        \r\n        return session;\r\n    }","id":51636,"modified_method":"/**\r\n     * @see RuleBase\r\n     */\r\n    public synchronized StatefulSession newStatefulSession(final boolean keepReference) {\r\n        if ( this.config.isSequential() ) {\r\n            throw new RuntimeException( \"Cannot have a stateful rule session, with sequential configuration set to true\" );\r\n        }\r\n        ReteooStatefulSession session = null;\r\n\r\n        synchronized ( this.pkgs ) {\r\n            ExecutorService executor = this.config.getExecutorService();\r\n            session = new ReteooStatefulSession( nextWorkingMemoryCounter(),\r\n                                                 this,\r\n                                                 executor );\r\n\r\n            executor.setCommandExecutor( new CommandExecutor( session ) );\r\n\r\n            if ( keepReference ) {\r\n                super.addStatefulSession( session );\r\n            }\r\n\r\n            final InitialFactHandle handle = new InitialFactHandle( session.getFactHandleFactory().newFactHandle( new InitialFactHandleDummyObject() ) );\r\n\r\n            session.queueWorkingMemoryAction( new WorkingMemoryReteAssertAction( handle,\r\n                                                                                 false,\r\n                                                                                 true,\r\n                                                                                 null,\r\n                                                                                 null ) );\r\n        }\r\n        \r\n        if ( this.updateListenerFactory == null ) {\r\n            this.updateListenerFactory = new RuleBaseUpdateListenerFactory();\r\n        }\r\n\r\n        String listenerName = this.config.getRuleBaseUpdateHandler();\r\n        if ( listenerName != null && listenerName.length() > 0 ) {\r\n            RuleBaseUpdateListener listener = this.updateListenerFactory.createListener( listenerName, session );\r\n            addEventListener( listener );\r\n        }\r\n        \r\n        return session;\r\n    }","commit_id":"824361a709f26936e403d6fd16eb7d69a8acd57f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private boolean determineShadowProxy(String userValue) {\n        if ( userValue != null ) {\n            return Boolean.valueOf( userValue ).booleanValue();\n        } else {\n            if ( this.isSequential() ) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }","id":51637,"modified_method":"private boolean determineShadowProxy(String userValue) {\n        if ( this.isSequential() ) {\n            // sequential never needs shadowing, so always override\n            return false;\n        }\n        \n        if ( userValue != null ) {\n            return Boolean.valueOf( userValue ).booleanValue();\n        } else {\n            return true;\n        }\n    }","commit_id":"824361a709f26936e403d6fd16eb7d69a8acd57f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void init(ClassLoader classLoader,\n                      Properties properties) {\n        this.immutable = false;\n\n        if ( classLoader != null ) {\n            this.classLoader = classLoader;\n        } else if ( Thread.currentThread().getContextClassLoader() != null ) {\n            this.classLoader = Thread.currentThread().getContextClassLoader();\n        } else {\n            this.classLoader = this.getClass().getClassLoader();\n        }\n\n        this.chainedProperties = new ChainedProperties( \"rulebase.conf\" );\n\n        if ( properties != null ) {\n            this.chainedProperties.addProperties( properties );\n        }\n\n        setSequentialAgenda( SequentialAgenda.determineSequentialAgenda( this.chainedProperties.getProperty( \"drools.sequential.agenda\",\n                                                                                                             \"sequential\" ) ) );\n\n        setSequential( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.sequential\",\n                                                                            \"false\" ) ).booleanValue() );\n\n        setMaintainTms( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.maintainTms\",\n                                                                             \"true\" ) ).booleanValue() );\n\n        setRemoveIdentities( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.removeIdentities\",\n                                                                                  \"false\" ) ).booleanValue() );\n\n        setAlphaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.alphaMemory\",\n                                                                             \"false\" ) ).booleanValue() );\n\n        setShareAlphaNodes( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.shareAlphaNodes\",\n                                                                                 \"true\" ) ).booleanValue() );\n\n        setShareBetaNodes( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.shareBetaNodes\",\n                                                                                \"true\" ) ).booleanValue() );\n\n        setAlphaNodeHashingThreshold( Integer.parseInt( this.chainedProperties.getProperty( \"drools.alphaNodeHashingThreshold\",\n                                                                                            \"3\" ) ) );\n\n        setCompositeKeyDepth( Integer.parseInt( this.chainedProperties.getProperty( \"drools.compositeKeyDepth\",\n                                                                                    \"3\" ) ) );\n\n        setIndexLeftBetaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.indexLeftBetaMemory\",\n                                                                                     \"true\" ) ).booleanValue() );\n        setIndexRightBetaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.indexRightBetaMemory\",\n                                                                                      \"true\" ) ).booleanValue() );\n\n        setAssertBehaviour( AssertBehaviour.determineAssertBehaviour( this.chainedProperties.getProperty( \"drools.assertBehaviour\",\n                                                                                                          \"identity\" ) ) );\n        setLogicalOverride( LogicalOverride.determineLogicalOverride( this.chainedProperties.getProperty( \"drools.logicalOverride\",\n                                                                                                          \"discard\" ) ) );\n\n        setExecutorService( RuleBaseConfiguration.determineExecutorService( this.chainedProperties.getProperty( \"drools.executorService\",\n                                                                                                                \"org.drools.concurrent.DefaultExecutorService\" ) ) );\n\n        setConsequenceExceptionHandler( RuleBaseConfiguration.determineConsequenceExceptionHandler( this.chainedProperties.getProperty( \"drools.consequenceExceptionHandler\",\n                                                                                                                                        \"org.drools.base.DefaultConsequenceExceptionHandler\" ) ) );\n\n        setConflictResolver( RuleBaseConfiguration.determineConflictResolver( this.chainedProperties.getProperty( \"drools.conflictResolver\",\n                                                                                                                  \"org.drools.conflict.DepthConflictResolver\" ) ) );\n\n        setShadowProxy( determineShadowProxy( this.chainedProperties.getProperty( \"drools.shadowproxy\",\n                                                                                  null ) ) );\n\n        setShadowProxyExcludes( this.chainedProperties.getProperty( \"drools.shadowProxyExcludes\",\n                                                                    \"\" ) );\n    }","id":51638,"modified_method":"private void init(ClassLoader classLoader,\n                      Properties properties) {\n        this.immutable = false;\n\n        if ( classLoader != null ) {\n            this.classLoader = classLoader;\n        } else if ( Thread.currentThread().getContextClassLoader() != null ) {\n            this.classLoader = Thread.currentThread().getContextClassLoader();\n        } else {\n            this.classLoader = this.getClass().getClassLoader();\n        }\n\n        this.chainedProperties = new ChainedProperties( \"rulebase.conf\" );\n\n        if ( properties != null ) {\n            this.chainedProperties.addProperties( properties );\n        }\n\n        setSequentialAgenda( SequentialAgenda.determineSequentialAgenda( this.chainedProperties.getProperty( \"drools.sequential.agenda\",\n                                                                                                             \"sequential\" ) ) );\n\n        setSequential( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.sequential\",\n                                                                            \"false\" ) ).booleanValue() );\n\n        setMaintainTms( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.maintainTms\",\n                                                                             \"true\" ) ).booleanValue() );\n\n        setRemoveIdentities( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.removeIdentities\",\n                                                                                  \"false\" ) ).booleanValue() );\n\n        setAlphaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.alphaMemory\",\n                                                                             \"false\" ) ).booleanValue() );\n\n        setShareAlphaNodes( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.shareAlphaNodes\",\n                                                                                 \"true\" ) ).booleanValue() );\n\n        setShareBetaNodes( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.shareBetaNodes\",\n                                                                                \"true\" ) ).booleanValue() );\n\n        setAlphaNodeHashingThreshold( Integer.parseInt( this.chainedProperties.getProperty( \"drools.alphaNodeHashingThreshold\",\n                                                                                            \"3\" ) ) );\n\n        setCompositeKeyDepth( Integer.parseInt( this.chainedProperties.getProperty( \"drools.compositeKeyDepth\",\n                                                                                    \"3\" ) ) );\n\n        setIndexLeftBetaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.indexLeftBetaMemory\",\n                                                                                     \"true\" ) ).booleanValue() );\n        setIndexRightBetaMemory( Boolean.valueOf( this.chainedProperties.getProperty( \"drools.indexRightBetaMemory\",\n                                                                                      \"true\" ) ).booleanValue() );\n\n        setAssertBehaviour( AssertBehaviour.determineAssertBehaviour( this.chainedProperties.getProperty( \"drools.assertBehaviour\",\n                                                                                                          \"identity\" ) ) );\n        setLogicalOverride( LogicalOverride.determineLogicalOverride( this.chainedProperties.getProperty( \"drools.logicalOverride\",\n                                                                                                          \"discard\" ) ) );\n\n        setExecutorService( RuleBaseConfiguration.determineExecutorService( this.chainedProperties.getProperty( \"drools.executorService\",\n                                                                                                                \"org.drools.concurrent.DefaultExecutorService\" ) ) );\n\n        setConsequenceExceptionHandler( RuleBaseConfiguration.determineConsequenceExceptionHandler( this.chainedProperties.getProperty( \"drools.consequenceExceptionHandler\",\n                                                                                                                                        \"org.drools.base.DefaultConsequenceExceptionHandler\" ) ) );\n        \n        setRuleBaseUpdateHandler( this.chainedProperties.getProperty( \"drools.ruleBaseUpdateHandler\",\n                                                                      \"org.drools.base.FireAllRulesRuleBaseUpdateListener\" ) );        \n\n        setConflictResolver( RuleBaseConfiguration.determineConflictResolver( this.chainedProperties.getProperty( \"drools.conflictResolver\",\n                                                                                                                  \"org.drools.conflict.DepthConflictResolver\" ) ) );\n\n        // sequential mode always overrides and sets this to false\n        setShadowProxy( determineShadowProxy( this.chainedProperties.getProperty( \"drools.shadowproxy\",\n                                                                                  \"true\" ) ) );\n\n        setShadowProxyExcludes( this.chainedProperties.getProperty( \"drools.shadowProxyExcludes\",\n                                                                    \"\" ) );\n    }","commit_id":"824361a709f26936e403d6fd16eb7d69a8acd57f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JcrResourceListener(final String startPath,\n                    final String mountPrefix,\n                    final SlingRepository repository,\n                    final BundleContext bundleContext)\n    throws RepositoryException {\n        boolean foundClass = false;\n        try {\n            this.getClass().getClassLoader().loadClass(JackrabbitEvent.class.getName());\n            foundClass = true;\n        } catch (final Throwable t) {\n            // we ignore this\n        }\n        this.hasJackrabbitEventClass = foundClass;\n        this.startPath = startPath;\n        this.mountPrefix = mountPrefix;\n        this.bundleContext = bundleContext;\n\n        this.eventAdminTracker = new ServiceTracker(bundleContext, EventAdmin.class.getName(), null);\n        this.eventAdminTracker.open();\n\n        this.session = repository.loginAdministrative(null);\n        try {\n            session.getWorkspace().getObservationManager().addEventListener(this,\n                            Event.NODE_ADDED|Event.NODE_REMOVED|Event.PROPERTY_ADDED|Event.PROPERTY_CHANGED|Event.PROPERTY_REMOVED,\n                            this.startPath, true, null, null, false);\n        } catch (final RepositoryException re) {\n            session.logout();\n            throw re;\n        }\n\n        this.osgiEventQueue = new LinkedBlockingQueue<Dictionary<String,Object>>();\n        final Thread oeqt = new Thread(new Runnable() {\n            public void run() {\n                processOsgiEventQueue();\n            }\n        }, \"Apache Sling JCR Resource Event Queue Processor for path '\" + this.startPath + \"'\");\n        oeqt.start();\n    }","id":51639,"modified_method":"public JcrResourceListener(\n                    final String mountPrefix,\n                    final ObservationListenerSupport support)\n    throws RepositoryException {\n        boolean foundClass = false;\n        try {\n            this.getClass().getClassLoader().loadClass(JackrabbitEvent.class.getName());\n            foundClass = true;\n        } catch (final Throwable t) {\n            // we ignore this\n        }\n        this.hasJackrabbitEventClass = foundClass;\n        this.mountPrefix = (mountPrefix == null || mountPrefix.length() == 0 || mountPrefix.equals(\"/\") ? null : mountPrefix);\n\n        this.support = support;\n        this.support.getSession().getWorkspace().getObservationManager().addEventListener(this,\n                        Event.NODE_ADDED|Event.NODE_REMOVED|Event.PROPERTY_ADDED|Event.PROPERTY_CHANGED|Event.PROPERTY_REMOVED,\n                        \"/\", true, null, null, false);\n\n        this.osgiEventQueue = new LinkedBlockingQueue<Map<String,Object>>();\n        final Thread oeqt = new Thread(new Runnable() {\n            public void run() {\n                processOsgiEventQueue();\n            }\n        }, \"Apache Sling JCR Resource Event Queue Processor\");\n        oeqt.start();\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create the base OSGi event properties based on the JCR event object\n     */\n    private Dictionary<String, Object> createEventProperties(final Event event) {\n        final Dictionary<String, Object> properties = new Hashtable<String, Object>();\n\n        if (this.isExternal(event)) {\n            properties.put(\"event.application\", \"unknown\");\n        } else {\n            final String userID = event.getUserID();\n            if (userID != null) {\n                properties.put(SlingConstants.PROPERTY_USERID, userID);\n            }\n        }\n\n        return properties;\n    }","id":51640,"modified_method":"/**\n     * Create the base OSGi event properties based on the JCR event object\n     */\n    private Map<String, Object> createEventProperties(final Event event) {\n        final Map<String, Object> properties = new HashMap<String, Object>();\n\n        if (this.isExternal(event)) {\n            properties.put(\"event.application\", \"unknown\");\n        } else {\n            final String userID = event.getUserID();\n            if (userID != null) {\n                properties.put(SlingConstants.PROPERTY_USERID, userID);\n            }\n        }\n\n        return properties;\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Called by the Runnable.run method of the JCR Event Queue processor to\n     * process the {@link #osgiEventQueue} until the\n     * {@link #TERMINATE_PROCESSING} event is received.\n     */\n    void processOsgiEventQueue() {\n        while (true) {\n            final Dictionary<String, Object> event;\n            try {\n                event = this.osgiEventQueue.take();\n            } catch (InterruptedException e) {\n                // interrupted waiting for the event; keep on waiting\n                continue;\n            }\n\n            if (event == null || event == TERMINATE_PROCESSING) {\n                break;\n            }\n\n            try {\n                final EventAdmin localEa = (EventAdmin) this.eventAdminTracker.getService();\n                final ResourceResolver resolver = this.getResourceResolver();\n                if (localEa != null && resolver != null ) {\n                    final String topic = (String) event.remove(EventConstants.EVENT_TOPIC);\n                    final String path = (String) event.get(SlingConstants.PROPERTY_PATH);\n                    Resource resource = resolver.getResource(path);\n                    boolean sendEvent = true;\n                    if (!SlingConstants.TOPIC_RESOURCE_REMOVED.equals(topic)) {\n                        if (resource != null) {\n                            // check if this is a JCR backed resource, otherwise it is not visible!\n                            final Node node = resource.adaptTo(Node.class);\n                            if (node != null) {\n                                // check for nt:file nodes\n                                if (path.endsWith(\"/jcr:content\")) {\n                                    try {\n                                        if (node.getParent().isNodeType(\"nt:file\")) {\n                                            final Resource parentResource = resource.getParent();\n                                            if (parentResource != null) {\n                                                resource = parentResource;\n                                                event.put(SlingConstants.PROPERTY_PATH, resource.getPath());\n                                            }\n                                        }\n                                    } catch (final RepositoryException re) {\n                                        // ignore this\n                                    }\n                                }\n\n                                final String resourceType = resource.getResourceType();\n                                if (resourceType != null) {\n                                    event.put(SlingConstants.PROPERTY_RESOURCE_TYPE, resource.getResourceType());\n                                }\n                                final String resourceSuperType = resource.getResourceSuperType();\n                                if (resourceSuperType != null) {\n                                    event.put(SlingConstants.PROPERTY_RESOURCE_SUPER_TYPE, resource.getResourceSuperType());\n                                }\n                            } else {\n                                // this is not a jcr backed resource\n                                sendEvent = false;\n                            }\n\n                        } else {\n                            // take a quite silent note of not being able to\n                            // resolve the resource\n                            logger.debug(\n                                \"processOsgiEventQueue: Resource at {} not found, which is not expected for an added or modified node\",\n                                path);\n                            sendEvent = false;\n                        }\n                    }\n\n                    if ( sendEvent ) {\n                        localEa.sendEvent(new org.osgi.service.event.Event(topic, event));\n                    }\n                }\n            } catch (final Exception e) {\n                logger.warn(\"processOsgiEventQueue: Unexpected problem processing event \" + event, e);\n            }\n        }\n\n        this.osgiEventQueue.clear();\n    }","id":51641,"modified_method":"/**\n     * Called by the Runnable.run method of the JCR Event Queue processor to\n     * process the {@link #osgiEventQueue} until the\n     * {@link #TERMINATE_PROCESSING} event is received.\n     */\n    void processOsgiEventQueue() {\n        while (true) {\n            final Map<String, Object> event;\n            try {\n                event = this.osgiEventQueue.take();\n            } catch (InterruptedException e) {\n                // interrupted waiting for the event; keep on waiting\n                continue;\n            }\n\n            if (event == null || event == TERMINATE_PROCESSING) {\n                break;\n            }\n\n            try {\n                final EventAdmin localEa = this.support.getEventAdmin();\n                final ResourceResolver resolver = this.support.getResourceResolver();\n                if (localEa != null && resolver != null ) {\n                    final String topic = (String) event.remove(EventConstants.EVENT_TOPIC);\n                    final String path = (String) event.get(SlingConstants.PROPERTY_PATH);\n                    Resource resource = resolver.getResource(path);\n                    boolean sendEvent = true;\n                    if (!SlingConstants.TOPIC_RESOURCE_REMOVED.equals(topic)) {\n                        if (resource != null) {\n                            // check if this is a JCR backed resource, otherwise it is not visible!\n                            final Node node = resource.adaptTo(Node.class);\n                            if (node != null) {\n                                // check for nt:file nodes\n                                if (path.endsWith(\"/jcr:content\")) {\n                                    try {\n                                        if (node.getParent().isNodeType(\"nt:file\")) {\n                                            final Resource parentResource = resource.getParent();\n                                            if (parentResource != null) {\n                                                resource = parentResource;\n                                                event.put(SlingConstants.PROPERTY_PATH, resource.getPath());\n                                            }\n                                        }\n                                    } catch (final RepositoryException re) {\n                                        // ignore this\n                                    }\n                                }\n\n                                final String resourceType = resource.getResourceType();\n                                if (resourceType != null) {\n                                    event.put(SlingConstants.PROPERTY_RESOURCE_TYPE, resource.getResourceType());\n                                }\n                                final String resourceSuperType = resource.getResourceSuperType();\n                                if (resourceSuperType != null) {\n                                    event.put(SlingConstants.PROPERTY_RESOURCE_SUPER_TYPE, resource.getResourceSuperType());\n                                }\n                            } else {\n                                // this is not a jcr backed resource\n                                sendEvent = false;\n                            }\n\n                        } else {\n                            // take a quite silent note of not being able to\n                            // resolve the resource\n                            logger.debug(\n                                \"processOsgiEventQueue: Resource at {} not found, which is not expected for an added or modified node\",\n                                path);\n                            sendEvent = false;\n                        }\n                    }\n\n                    if ( sendEvent ) {\n                        localEa.sendEvent(new org.osgi.service.event.Event(topic, new EventProperties(event)));\n                    }\n                }\n            } catch (final Exception e) {\n                logger.warn(\"processOsgiEventQueue: Unexpected problem processing event \" + event, e);\n            }\n        }\n\n        this.osgiEventQueue.clear();\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n         * @return a {@code Dictionary} with all changes recorded including\n         *         original JCR event information.\n         */\n        public final Dictionary<String, Object> toEventProperties() {\n            return mergeAttributesInto(properties);\n        }","id":51642,"modified_method":"/**\n         * @return a {@code Dictionary} with all changes recorded including\n         *         original JCR event information.\n         */\n        public final Map<String, Object> toEventProperties() {\n            return mergeAttributesInto(properties);\n        }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"public ChangedAttributes(final Dictionary<String, Object> properties) {\n            this.properties = properties;\n        }","id":51643,"modified_method":"public ChangedAttributes(final Map<String, Object> properties) {\n            this.properties = properties;\n        }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n     */\n    public void onEvent(final EventIterator events) {\n        // if the event admin is currently not available, we just skip this\n        final EventAdmin localEA = (EventAdmin) this.eventAdminTracker.getService();\n        if ( localEA == null ) {\n            return;\n        }\n        final Map<String, Dictionary<String, Object>> addedEvents = new HashMap<String, Dictionary<String, Object>>();\n        final Map<String, ChangedAttributes> changedEvents = new HashMap<String, ChangedAttributes>();\n        final Map<String, Dictionary<String, Object>> removedEvents = new HashMap<String, Dictionary<String, Object>>();\n        while ( events.hasNext() ) {\n            final Event event = events.nextEvent();\n            try {\n                final String eventPath;\n                if ( this.mountPrefix != null ) {\n                    eventPath = this.mountPrefix + event.getPath();\n                } else {\n                    eventPath = event.getPath();\n                }\n                if ( event.getType() == Event.PROPERTY_ADDED\n                     || event.getType() == Event.PROPERTY_REMOVED\n                     || event.getType() == Event.PROPERTY_CHANGED ) {\n                    final int lastSlash = eventPath.lastIndexOf('/');\n                    final String nodePath = eventPath.substring(0, lastSlash);\n                    final String propName = eventPath.substring(lastSlash + 1);\n                    this.updateChangedEvent(changedEvents, nodePath, event, propName);\n\n                } else if ( event.getType() == Event.NODE_ADDED ) {\n                    addedEvents.put(eventPath, createEventProperties(event));\n\n                } else if ( event.getType() == Event.NODE_REMOVED) {\n                    // remove is the strongest operation, therefore remove all removed\n                    // paths from added\n                    addedEvents.remove(eventPath);\n                    removedEvents.put(eventPath, createEventProperties(event));\n                }\n            } catch (final RepositoryException e) {\n                logger.error(\"Error during modification: {}\", e.getMessage());\n            }\n        }\n\n        for (final Entry<String, Dictionary<String, Object>> e : removedEvents.entrySet()) {\n            // Launch an OSGi event\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_REMOVED,\n                null);\n        }\n\n        for (final Entry<String, Dictionary<String, Object>> e : addedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_ADDED,\n                changedEvents.remove(e.getKey()));\n        }\n\n        // Send the changed events.\n        for (final Entry<String, ChangedAttributes> e : changedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue().toEventProperties(), SlingConstants.TOPIC_RESOURCE_CHANGED, null);\n        }\n    }","id":51644,"modified_method":"/**\n     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n     */\n    public void onEvent(final EventIterator events) {\n        // if the event admin is currently not available, we just skip this\n        final EventAdmin localEA = this.support.getEventAdmin();\n        if ( localEA == null ) {\n            return;\n        }\n        final Map<String, Map<String, Object>> addedEvents = new HashMap<String, Map<String, Object>>();\n        final Map<String, ChangedAttributes> changedEvents = new HashMap<String, ChangedAttributes>();\n        final Map<String, Map<String, Object>> removedEvents = new HashMap<String, Map<String, Object>>();\n        while ( events.hasNext() ) {\n            final Event event = events.nextEvent();\n            try {\n                final String eventPath;\n                if ( this.mountPrefix != null ) {\n                    eventPath = this.mountPrefix + event.getPath();\n                } else {\n                    eventPath = event.getPath();\n                }\n                if ( event.getType() == Event.PROPERTY_ADDED\n                     || event.getType() == Event.PROPERTY_REMOVED\n                     || event.getType() == Event.PROPERTY_CHANGED ) {\n                    final int lastSlash = eventPath.lastIndexOf('/');\n                    final String nodePath = eventPath.substring(0, lastSlash);\n                    final String propName = eventPath.substring(lastSlash + 1);\n                    this.updateChangedEvent(changedEvents, nodePath, event, propName);\n\n                } else if ( event.getType() == Event.NODE_ADDED ) {\n                    addedEvents.put(eventPath, createEventProperties(event));\n\n                } else if ( event.getType() == Event.NODE_REMOVED) {\n                    // remove is the strongest operation, therefore remove all removed\n                    // paths from added\n                    addedEvents.remove(eventPath);\n                    removedEvents.put(eventPath, createEventProperties(event));\n                }\n            } catch (final RepositoryException e) {\n                logger.error(\"Error during modification: {}\", e.getMessage());\n            }\n        }\n\n        for (final Entry<String, Map<String, Object>> e : removedEvents.entrySet()) {\n            // Launch an OSGi event\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_REMOVED,\n                null);\n        }\n\n        for (final Entry<String, Map<String, Object>> e : addedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_ADDED,\n                changedEvents.remove(e.getKey()));\n        }\n\n        // Send the changed events.\n        for (final Entry<String, ChangedAttributes> e : changedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue().toEventProperties(), SlingConstants.TOPIC_RESOURCE_CHANGED, null);\n        }\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Send an OSGi event based on a JCR Observation Event.\n     *\n     * @param path The path too the node where the event occurred.\n     * @param properties The base properties for this event.\n     * @param topic The topic that should be used for the OSGi event.\n     */\n    private void sendOsgiEvent(final String path,\n            final Dictionary<String, Object> properties,\n            final String topic,\n            final ChangedAttributes changedAttributes) {\n\n        if (changedAttributes != null) {\n            changedAttributes.mergeAttributesInto(properties);\n        }\n\n        // set the path (might have been changed for nt:file content)\n        properties.put(SlingConstants.PROPERTY_PATH, path);\n        properties.put(EventConstants.EVENT_TOPIC, topic);\n\n        // enqueue event for dispatching\n        this.osgiEventQueue.offer(properties);\n    }","id":51645,"modified_method":"/**\n     * Send an OSGi event based on a JCR Observation Event.\n     *\n     * @param path The path too the node where the event occurred.\n     * @param properties The base properties for this event.\n     * @param topic The topic that should be used for the OSGi event.\n     */\n    private void sendOsgiEvent(final String path,\n            final Map<String, Object> properties,\n            final String topic,\n            final ChangedAttributes changedAttributes) {\n\n        if (changedAttributes != null) {\n            changedAttributes.mergeAttributesInto(properties);\n        }\n\n        // set the path (might have been changed for nt:file content)\n        properties.put(SlingConstants.PROPERTY_PATH, path);\n        properties.put(EventConstants.EVENT_TOPIC, topic);\n\n        // enqueue event for dispatching\n        this.osgiEventQueue.offer(properties);\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n         * Merges lists of added, changed, and removed properties to the given\n         * non-{@code null} {@code properties} and returns that object.\n         *\n         * @param properties The {@code Dictionary} to add the attribute lists\n         *            to.\n         * @return The {@code properties} object is returned.\n         */\n        public final Dictionary<String, Object> mergeAttributesInto(final Dictionary<String, Object> properties) {\n            if ( addedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_ADDED_ATTRIBUTES, addedAttributes.toArray(new String[addedAttributes.size()]));\n            }\n            if ( changedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_CHANGED_ATTRIBUTES, changedAttributes.toArray(new String[changedAttributes.size()]));\n            }\n            if ( removedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_REMOVED_ATTRIBUTES, removedAttributes.toArray(new String[removedAttributes.size()]));\n            }\n            return properties;\n        }","id":51646,"modified_method":"/**\n         * Merges lists of added, changed, and removed properties to the given\n         * non-{@code null} {@code properties} and returns that object.\n         *\n         * @param properties The {@code Dictionary} to add the attribute lists\n         *            to.\n         * @return The {@code properties} object is returned.\n         */\n        public final Map<String, Object> mergeAttributesInto(final Map<String, Object> properties) {\n            if ( addedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_ADDED_ATTRIBUTES, addedAttributes.toArray(new String[addedAttributes.size()]));\n            }\n            if ( changedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_CHANGED_ATTRIBUTES, changedAttributes.toArray(new String[changedAttributes.size()]));\n            }\n            if ( removedAttributes != null )  {\n                properties.put(SlingConstants.PROPERTY_REMOVED_ATTRIBUTES, removedAttributes.toArray(new String[removedAttributes.size()]));\n            }\n            return properties;\n        }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setUp() throws RepositoryException, InvalidSyntaxException {\n        ObservationManager observationManager = mock(ObservationManager.class);\n\n        Workspace workspace = mock(Workspace.class);\n        when(workspace.getObservationManager()).thenReturn(observationManager);\n\n        Session session = mock(Session.class);\n        when(session.getWorkspace()).thenReturn(workspace);\n\n        SlingRepository repository = mock(SlingRepository.class);\n        when(repository.loginAdministrative(null)).thenReturn(session);\n\n        EventAdmin eventAdmin = mock(EventAdmin.class);\n        ServiceReference serviceRef = mock(ServiceReference.class);\n        ServiceReference[] serviceRefs = new ServiceReference[]{serviceRef};\n        BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.getServiceReferences(anyString(), anyString())).thenReturn(serviceRefs);\n        when(bundleContext.getService(serviceRef)).thenReturn(eventAdmin);\n\n        jcrResourceListener = new JcrResourceListener(\"/\", \"/\", repository, bundleContext);\n\n        Event event = mock(MockEvent.class);\n        events = mock(EventIterator.class);\n        when(events.hasNext()).thenReturn(true);\n        when(event.getPath()).thenCallRealMethod();\n        when(event.getType()).thenReturn(Event.NODE_ADDED);\n        when(events.nextEvent()).thenReturn(event);\n    }","id":51647,"modified_method":"@Before\n    public void setUp() throws RepositoryException, InvalidSyntaxException {\n        ObservationManager observationManager = mock(ObservationManager.class);\n\n        Workspace workspace = mock(Workspace.class);\n        when(workspace.getObservationManager()).thenReturn(observationManager);\n\n        Session session = mock(Session.class);\n        when(session.getWorkspace()).thenReturn(workspace);\n\n        SlingRepository repository = mock(SlingRepository.class);\n        when(repository.loginAdministrative(null)).thenReturn(session);\n\n        EventAdmin eventAdmin = mock(EventAdmin.class);\n        ServiceReference serviceRef = mock(ServiceReference.class);\n        ServiceReference[] serviceRefs = new ServiceReference[]{serviceRef};\n        BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.getServiceReferences(anyString(), anyString())).thenReturn(serviceRefs);\n        when(bundleContext.getService(serviceRef)).thenReturn(eventAdmin);\n\n        jcrResourceListener = new JcrResourceListener(\"/\", new ObservationListenerSupport(bundleContext, repository));\n\n        Event event = mock(MockEvent.class);\n        events = mock(EventIterator.class);\n        when(events.hasNext()).thenReturn(true);\n        when(event.getPath()).thenCallRealMethod();\n        when(event.getType()).thenReturn(Event.NODE_ADDED);\n        when(events.nextEvent()).thenReturn(event);\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        RepositoryUtil.startRepository();\n        final Session adminSession = RepositoryUtil.getRepository().loginAdministrative(null);\n        RepositoryUtil.registerSlingNodeTypes(adminSession);\n        adminSession.logout();\n    }","id":51648,"modified_method":"@Before\n    public void setUp() throws Exception {\n        RepositoryUtil.startRepository();\n        this.adminSession = RepositoryUtil.getRepository().loginAdministrative(null);\n        RepositoryUtil.registerSlingNodeTypes(adminSession);\n        final ResourceResolver resolver = Mockito.mock(ResourceResolver.class);\n        Mockito.when(resolver.adaptTo(Mockito.any(Class.class))).thenReturn(this.adminSession);\n        Mockito.when(resolver.getResource(Mockito.anyString())).thenReturn(new JcrTestNodeResource(resolver, this.adminSession.getNode(\"/\"), null));\n\n        final ResourceResolverFactory factory = Mockito.mock(ResourceResolverFactory.class);\n        Mockito.when(factory.getAdministrativeResourceResolver(Mockito.anyMap())).thenReturn(resolver);\n\n        final EventAdmin mockEA = new EventAdmin() {\n\n            public void postEvent(final Event event) {\n                addEvent(event);\n            }\n\n            public void sendEvent(final Event event) {\n                addEvent(event);\n            }\n        };\n\n        final ServiceTracker tracker = mock(ServiceTracker.class);\n        when(tracker.getService()).thenReturn(mockEA);\n\n        final BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.createFilter(any(String.class))).thenReturn(null);\n        when(bundleContext.getServiceReference(any(String.class))).thenReturn(null);\n        when(bundleContext.getService(null)).thenReturn(mockEA);\n\n        this.listener = new SynchronousJcrResourceListener(RepositoryUtil.getRepository(),\n                        bundleContext, resolver, tracker);\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void tearDown() throws Exception {\n        super.tearDown();\n        RepositoryUtil.stopRepository();\n    }","id":51649,"modified_method":"@After\n    public void tearDown() throws Exception {\n        if ( adminSession != null ) {\n            adminSession.logout();\n            adminSession = null;\n        }\n        RepositoryUtil.stopRepository();\n        if ( listener != null ) {\n            listener.dispose();\n            listener = null;\n        }\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"@Deactivate\n    protected void deactivate() {\n        if ( this.listener != null ) {\n            this.listener.deactivate();\n            this.listener = null;\n        }\n    }","id":51650,"modified_method":"@Deactivate\n    protected void deactivate() {\n        if ( this.listener != null ) {\n            try {\n                this.listener.close();\n            } catch (final IOException e) {\n                // ignore this as the method above does not throw it\n            }\n            this.listener = null;\n        }\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"@Activate\n    protected void activate(final ComponentContext context) throws RepositoryException {\n\n        SlingRepository repository = (SlingRepository) context.locateService(REPOSITORY_REFERNENCE_NAME,\n            this.repositoryReference);\n        if (repository == null) {\n            // concurrent unregistration of SlingRepository service\n            // don't care, this component is going to be deactivated\n            // so we just stop working\n            log.warn(\"activate: Activation failed because SlingRepository may have been unregistered concurrently\");\n            return;\n        }\n\n        final String root = PropertiesUtil.toString(context.getProperties().get(ResourceProvider.ROOTS), \"/\");\n\n        this.repository = repository;\n        this.listener = new JcrResourceListener(root, null, this.repository, context.getBundleContext());\n    }","id":51651,"modified_method":"@Activate\n    protected void activate(final ComponentContext context) throws RepositoryException {\n\n        SlingRepository repository = (SlingRepository) context.locateService(REPOSITORY_REFERNENCE_NAME,\n            this.repositoryReference);\n        if (repository == null) {\n            // concurrent unregistration of SlingRepository service\n            // don't care, this component is going to be deactivated\n            // so we just stop working\n            log.warn(\"activate: Activation failed because SlingRepository may have been unregistered concurrently\");\n            return;\n        }\n\n        this.repository = repository;\n        // check for Oak\n        final boolean optimizeForOak = PropertiesUtil.toBoolean(context.getProperties().get(PROPERTY_OPTIMIZE_FOR_OAK), DEFAULT_OPTIMIZE_FOR_OAK);\n        boolean isOak = false;\n        if ( optimizeForOak ) {\n            final String repoDesc = this.repository.getDescriptor(Repository.REP_NAME_DESC);\n            if ( repoDesc != null && repoDesc.toLowerCase().contains(\" oak\") ) {\n                if ( this.executor != null ) {\n                    isOak = true;\n                } else {\n                   log.error(\"Detected Oak based repository but no executor service available! Unable to use improved JCR Resource listener\");\n                }\n            }\n        }\n        final String root = PropertiesUtil.toString(context.getProperties().get(ResourceProvider.ROOTS), \"/\");\n        final ObservationListenerSupport support = new ObservationListenerSupport(context.getBundleContext(), repository);\n        boolean closeSupport = true;\n        try {\n            if ( isOak ) {\n                try {\n                    this.listener = new OakResourceListener(root, support, context.getBundleContext(), executor);\n                    log.info(\"Detected Oak based repository. Using improved JCR Resource Listener\");\n                } catch ( final RepositoryException re ) {\n                    throw re;\n                } catch ( final Throwable t ) {\n                    log.error(\"Unable to instantiate improved JCR Resource listener for Oak. Using fallback.\", t);\n                }\n            }\n            if ( this.listener == null ) {\n                this.listener = new JcrResourceListener(root, support);\n            }\n            closeSupport = false;\n        } finally {\n            if ( closeSupport ) {\n                support.dispose();\n            }\n        }\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"public SynchronousJcrResourceListener(\n            ResourceResolverFactory factory,\n            SlingRepository repo,\n            BundleContext bundleContext,\n            final ResourceResolver resolver,\n            final ServiceTracker tracker)\n            throws LoginException, RepositoryException, NoSuchFieldException {\n        super(\"/\", null, repo, bundleContext);\n        PrivateAccessor.setField(this, \"resourceResolver\", resolver);\n        PrivateAccessor.setField(this, \"eventAdminTracker\", tracker);\n    }","id":51652,"modified_method":"public SynchronousJcrResourceListener(\n            final SlingRepository repo,\n            final BundleContext bundleContext,\n            final ResourceResolver resolver,\n            final ServiceTracker tracker)\n            throws LoginException, RepositoryException, NoSuchFieldException {\n        super(\"/\", new ObservationListenerSupport(bundleContext, repo));\n        PrivateAccessor.setField(this.support, \"resourceResolver\", resolver);\n        PrivateAccessor.setField(this.support, \"eventAdminTracker\", tracker);\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"public void dispose() {\n        this.deactivate();\n    }","id":51653,"modified_method":"public void dispose() {\n        try {\n            this.close();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"14bbcde69d6c775b31fd4f7c00c8e5749cb7aa4f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Register a servant.\n     * \n     * @param url the URL associated with the servant\n     * @param handler notified on incoming HTTP requests\n     */\n    @SuppressWarnings(\"deprecation\")\n    public synchronized void addServant(URL url, JettyHTTPHandler handler) {\n        if (server == null) {\n            DefaultHandler defaultHandler = null;\n            // create a new jetty server instance if there is no server there            \n            server = new Server();\n            if (bus != null && bus.getExtension(InstrumentationManager.class) != null) {\n                MBeanServer mbs =  bus.getExtension(InstrumentationManager.class).getMBeanServer();\n                if (mbs != null) {\n                    try {\n                        Class<?> cls = ClassLoaderUtils.loadClass(\"org.mortbay.management.MBeanContainer\", \n                                                              getClass());\n                        Container.Listener listener \n                            = (Container.Listener)cls.getConstructor(MBeanServer.class).newInstance(mbs);\n                        server.getContainer().addEventListener(listener);\n                    } catch (Throwable ex) {\n                        //ignore - just won't instrument jetty.  Probably don't have the\n                        //jetty-management jar available\n                    }\n                }\n            }\n            if (connector == null) {\n                connector = connectorFactory.createConnector(getHost(), getPort());\n                if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(\"connector.host: \" \n                              + connector.getHost() == null \n                                ? \"null\" \n                                : \"\\\"\" + connector.getHost() + \"\\\"\");\n                    LOG.finer(\"connector.port: \" + connector.getPort());\n                }\n            } \n            server.addConnector(connector);            \n            if (handlers != null && handlers.size() > 0) {\n                HandlerList handlerList = new HandlerList();\n                for (Handler h : handlers) {\n                    // filting the jetty default handler \n                    // which should not be added at this point\n                    if (h instanceof DefaultHandler) {\n                        defaultHandler = (DefaultHandler) h;\n                    } else {\n                        handlerList.addHandler(h);\n                    }\n                }\n                server.addHandler(handlerList);\n            }\n            contexts = new ContextHandlerCollection();\n            server.addHandler(contexts);\n            if (defaultHandler != null) {\n                server.addHandler(defaultHandler);\n            }\n            try {                \n                setReuseAddress(connector);\n                server.start();\n               \n                AbstractConnector aconn = (AbstractConnector) connector;\n                if (isSetThreadingParameters()) {\n                    if (aconn.getThreadPool() instanceof org.mortbay.thread.BoundedThreadPool) {\n                        org.mortbay.thread.BoundedThreadPool pool \n                            = (org.mortbay.thread.BoundedThreadPool)aconn.getThreadPool();\n                        if (getThreadingParameters().isSetMinThreads()) {\n                            pool.setMinThreads(getThreadingParameters().getMinThreads());\n                        }\n                        if (getThreadingParameters().isSetMaxThreads()) {\n                            pool.setMaxThreads(getThreadingParameters().getMaxThreads());\n                        }\n                    } else if (aconn.getThreadPool() instanceof QueuedThreadPool) {\n                        QueuedThreadPool pool = (QueuedThreadPool)aconn.getThreadPool();\n                        if (getThreadingParameters().isSetMinThreads()) {\n                            pool.setMinThreads(getThreadingParameters().getMinThreads());\n                        }\n                        if (getThreadingParameters().isSetMaxThreads()) {\n                            pool.setMaxThreads(getThreadingParameters().getMaxThreads());\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"START_UP_SERVER_FAILED_MSG\", new Object[] {e.getMessage()});\n                //problem starting server\n                try {                    \n                    server.stop();\n                    server.destroy();\n                } catch (Exception ex) {\n                    //ignore - probably wasn't fully started anyway\n                }\n                server = null;\n                throw new Fault(new Message(\"START_UP_SERVER_FAILED_MSG\", LOG, e.getMessage()), e);\n            }\n        }        \n        \n        String contextName = HttpUriMapper.getContextName(url.getPath());            \n        ContextHandler context = new ContextHandler();\n        context.setContextPath(contextName);\n        \n        // bind the jetty http handler with the context handler        \n        context.setHandler(handler);\n        if (isSessionSupport) {            \n            HashSessionManager sessionManager = new HashSessionManager();\n            SessionHandler sessionHandler = new SessionHandler(sessionManager);\n            HashSessionIdManager idManager = new HashSessionIdManager();\n            sessionManager.setIdManager(idManager);            \n            context.addHandler(sessionHandler);           \n        }\n        contexts.addHandler(context);\n        \n        ServletContext sc = context.getServletContext();\n        handler.setServletContext(sc);\n       \n        final String smap = HttpUriMapper.getResourceBase(url.getPath());\n        handler.setName(smap);\n        \n        if (contexts.isStarted()) {           \n            try {                \n                context.start();\n            } catch (Exception ex) {\n                LOG.log(Level.WARNING, \"ADD_HANDLER_FAILED_MSG\", new Object[] {ex.getMessage()});\n            }\n        }\n        \n            \n        ++servantCount;\n    }","id":51654,"modified_method":"/**\n     * Register a servant.\n     * \n     * @param url the URL associated with the servant\n     * @param handler notified on incoming HTTP requests\n     */\n    @SuppressWarnings(\"deprecation\")\n    public synchronized void addServant(URL url, JettyHTTPHandler handler) {\n        if (server == null) {\n            DefaultHandler defaultHandler = null;\n            // create a new jetty server instance if there is no server there            \n            server = new Server();\n            \n            Container.Listener mBeanContainer = factory.getMBeanContainer();\n            if (mBeanContainer != null) {\n                server.getContainer().addEventListener(mBeanContainer);\n            }\n            \n            if (connector == null) {\n                connector = connectorFactory.createConnector(getHost(), getPort());\n                if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(\"connector.host: \" \n                              + connector.getHost() == null \n                                ? \"null\" \n                                : \"\\\"\" + connector.getHost() + \"\\\"\");\n                    LOG.finer(\"connector.port: \" + connector.getPort());\n                }\n            } \n            server.addConnector(connector);            \n            if (handlers != null && handlers.size() > 0) {\n                HandlerList handlerList = new HandlerList();\n                for (Handler h : handlers) {\n                    // filting the jetty default handler \n                    // which should not be added at this point\n                    if (h instanceof DefaultHandler) {\n                        defaultHandler = (DefaultHandler) h;\n                    } else {\n                        handlerList.addHandler(h);\n                    }\n                }\n                server.addHandler(handlerList);\n            }\n            contexts = new ContextHandlerCollection();\n            server.addHandler(contexts);\n            if (defaultHandler != null) {\n                server.addHandler(defaultHandler);\n            }\n            try {                \n                setReuseAddress(connector);\n                server.start();\n               \n                AbstractConnector aconn = (AbstractConnector) connector;\n                if (isSetThreadingParameters()) {\n                    if (aconn.getThreadPool() instanceof org.mortbay.thread.BoundedThreadPool) {\n                        org.mortbay.thread.BoundedThreadPool pool \n                            = (org.mortbay.thread.BoundedThreadPool)aconn.getThreadPool();\n                        if (getThreadingParameters().isSetMinThreads()) {\n                            pool.setMinThreads(getThreadingParameters().getMinThreads());\n                        }\n                        if (getThreadingParameters().isSetMaxThreads()) {\n                            pool.setMaxThreads(getThreadingParameters().getMaxThreads());\n                        }\n                    } else if (aconn.getThreadPool() instanceof QueuedThreadPool) {\n                        QueuedThreadPool pool = (QueuedThreadPool)aconn.getThreadPool();\n                        if (getThreadingParameters().isSetMinThreads()) {\n                            pool.setMinThreads(getThreadingParameters().getMinThreads());\n                        }\n                        if (getThreadingParameters().isSetMaxThreads()) {\n                            pool.setMaxThreads(getThreadingParameters().getMaxThreads());\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"START_UP_SERVER_FAILED_MSG\", new Object[] {e.getMessage()});\n                //problem starting server\n                try {                    \n                    server.stop();\n                    server.destroy();\n                } catch (Exception ex) {\n                    //ignore - probably wasn't fully started anyway\n                }\n                server = null;\n                throw new Fault(new Message(\"START_UP_SERVER_FAILED_MSG\", LOG, e.getMessage()), e);\n            }\n        }        \n        \n        String contextName = HttpUriMapper.getContextName(url.getPath());            \n        ContextHandler context = new ContextHandler();\n        context.setContextPath(contextName);\n        \n        // bind the jetty http handler with the context handler        \n        context.setHandler(handler);\n        if (isSessionSupport) {            \n            HashSessionManager sessionManager = new HashSessionManager();\n            SessionHandler sessionHandler = new SessionHandler(sessionManager);\n            HashSessionIdManager idManager = new HashSessionIdManager();\n            sessionManager.setIdManager(idManager);            \n            context.addHandler(sessionHandler);           \n        }\n        contexts.addHandler(context);\n        \n        ServletContext sc = context.getServletContext();\n        handler.setServletContext(sc);\n       \n        final String smap = HttpUriMapper.getResourceBase(url.getPath());\n        handler.setName(smap);\n        \n        if (contexts.isStarted()) {           \n            try {                \n                context.start();\n            } catch (Exception ex) {\n                LOG.log(Level.WARNING, \"ADD_HANDLER_FAILED_MSG\", new Object[] {ex.getMessage()});\n            }\n        }\n        \n            \n        ++servantCount;\n    }","commit_id":"002294f9ef529076b7da4b0093f5b1dd65b25be1","url":"https://github.com/apache/cxf"},{"original_method":"public void postShutdown() {\n        //shut down the jetty server in the portMap\n        // To avoid the CurrentModificationException, \n        // do not use portMap.vaules directly       \n        JettyHTTPServerEngine[] engines = portMap.values().toArray(new JettyHTTPServerEngine[0]);\n        for (JettyHTTPServerEngine engine : engines) {\n            engine.shutdown();\n        }\n        // clean up the collections\n        threadingParametersMap.clear();\n        tlsParametersMap.clear();\n    }","id":51655,"modified_method":"public void postShutdown() {\n        // shut down the jetty server in the portMap\n        // To avoid the CurrentModificationException, \n        // do not use portMap.vaules directly       \n        JettyHTTPServerEngine[] engines = portMap.values().toArray(new JettyHTTPServerEngine[0]);\n        for (JettyHTTPServerEngine engine : engines) {\n            engine.shutdown();\n        }\n        // clean up the collections\n        threadingParametersMap.clear();\n        tlsParametersMap.clear();\n        mBeanContainer = null;\n    }","commit_id":"002294f9ef529076b7da4b0093f5b1dd65b25be1","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSetHandlers() throws Exception {\n        URL url = new URL(\"http://localhost:9235/hello/test\");\n        JettyHTTPTestHandler handler1 = new JettyHTTPTestHandler(\"string1\", true);\n        JettyHTTPTestHandler handler2 = new JettyHTTPTestHandler(\"string2\", true);\n\n        JettyHTTPServerEngine engine = new JettyHTTPServerEngine();\n        engine.setPort(9235);\n\n        List<Handler> handlers = new ArrayList<Handler>();\n        handlers.add(handler1);\n        engine.setHandlers(handlers);\n        engine.finalizeConfig();\n\n        engine.addServant(url, handler2);\n        String response = null;\n        try {\n            response = getResponse(url.toString());\n            assertEquals(\"the jetty http handler1 did not take effect\", response, \"string1string2\");\n        } catch (Exception ex) {\n            fail(\"Can't get the reponse from the server \" + ex);\n        }\n        engine.stop();\n    }","id":51656,"modified_method":"@Test\n    public void testSetHandlers() throws Exception {\n        URL url = new URL(\"http://localhost:9235/hello/test\");\n        JettyHTTPTestHandler handler1 = new JettyHTTPTestHandler(\"string1\", true);\n        JettyHTTPTestHandler handler2 = new JettyHTTPTestHandler(\"string2\", true);\n\n        JettyHTTPServerEngine engine = new JettyHTTPServerEngine();\n        engine.setPort(9235);\n        engine.setJettyHTTPServerEngineFactory(factory);\n\n        List<Handler> handlers = new ArrayList<Handler>();\n        handlers.add(handler1);\n        engine.setHandlers(handlers);\n        engine.finalizeConfig();\n\n        engine.addServant(url, handler2);\n        String response = null;\n        try {\n            response = getResponse(url.toString());\n            assertEquals(\"the jetty http handler1 did not take effect\", response, \"string1string2\");\n        } catch (Exception ex) {\n            fail(\"Can't get the reponse from the server \" + ex);\n        }\n        engine.stop();\n    }","commit_id":"002294f9ef529076b7da4b0093f5b1dd65b25be1","url":"https://github.com/apache/cxf"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        control = EasyMock.createNiceControl();\n        bus = control.createMock(Bus.class);\n        \n        Configurer configurer = new ConfigurerImpl();\n        bus.getExtension(Configurer.class);\n        EasyMock.expectLastCall().andReturn(configurer).anyTimes();\n\n        control.replay();\n\n        factory = new JettyHTTPServerEngineFactory();\n        factory.setBus(bus);\n\n    }","id":51657,"modified_method":"@Before\n    public void setUp() throws Exception {\n        control = EasyMock.createNiceControl();\n        bus = control.createMock(Bus.class);\n        \n        Configurer configurer = new ConfigurerImpl();\n        bus.getExtension(Configurer.class);\n        EasyMock.expectLastCall().andReturn(configurer).anyTimes();\n        \n        InstrumentationManager iManager = control.createMock(InstrumentationManager.class);\n        iManager.getMBeanServer();\n        EasyMock.expectLastCall().andReturn(ManagementFactory.getPlatformMBeanServer()).anyTimes();\n        \n        bus.getExtension(InstrumentationManager.class);\n        EasyMock.expectLastCall().andReturn(iManager).anyTimes();\n        \n        control.replay();\n\n        factory = new JettyHTTPServerEngineFactory();\n        factory.setBus(bus);\n\n    }","commit_id":"002294f9ef529076b7da4b0093f5b1dd65b25be1","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testaddServants() throws Exception {\n        String urlStr = \"http://localhost:9234/hello/test\";\n        String urlStr2 = \"http://localhost:9234/hello233/test\";\n        JettyHTTPServerEngine engine =\n            factory.createJettyHTTPServerEngine(9234, \"http\");\n        JettyHTTPTestHandler handler1 = new JettyHTTPTestHandler(\"string1\", true);\n        JettyHTTPTestHandler handler2 = new JettyHTTPTestHandler(\"string2\", true);\n        engine.addServant(new URL(urlStr), handler1);\n        String response = null;\n        response = getResponse(urlStr);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string1\");\n\n        engine.addServant(new URL(urlStr), handler2);\n        response = getResponse(urlStr);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string1string2\");\n        engine.addServant(new URL(urlStr2), handler2);\n        engine.removeServant(new URL(urlStr));\n        engine.shutdown();\n        response = getResponse(urlStr2);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string2\");\n        // set the get request\n        factory.destroyForPort(9234);\n\n    }","id":51658,"modified_method":"@Test\n    public void testaddServants() throws Exception {\n        String urlStr = \"http://localhost:9234/hello/test\";\n        String urlStr2 = \"http://localhost:9234/hello233/test\";\n        JettyHTTPServerEngine engine =\n            factory.createJettyHTTPServerEngine(9234, \"http\");\n        JettyHTTPTestHandler handler1 = new JettyHTTPTestHandler(\"string1\", true);\n        JettyHTTPTestHandler handler2 = new JettyHTTPTestHandler(\"string2\", true);\n        engine.addServant(new URL(urlStr), handler1);\n        String response = null;\n        response = getResponse(urlStr);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string1\");\n\n        engine.addServant(new URL(urlStr), handler2);\n        response = getResponse(urlStr);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string1string2\");\n        engine.addServant(new URL(urlStr2), handler2);\n        \n        Set<ObjectName>  s = ManagementFactory.getPlatformMBeanServer().\n            queryNames(new ObjectName(\"org.mortbay.jetty:type=server,*\"), null);\n        assertEquals(\"Could not find 1 Jetty Server: \" + s, 1, s.size());\n        \n        engine.removeServant(new URL(urlStr));\n        engine.shutdown();\n        response = getResponse(urlStr2);\n        assertEquals(\"The jetty http handler did not take effect\", response, \"string2\");\n        // set the get request\n        factory.destroyForPort(9234);\n\n    }","commit_id":"002294f9ef529076b7da4b0093f5b1dd65b25be1","url":"https://github.com/apache/cxf"},{"original_method":"public void observationThroughput(final Repository repository, ObservationManager observationManager)\n            throws RepositoryException, InterruptedException, ExecutionException {\n        long t = 0;\n        final AtomicInteger eventCount = new AtomicInteger();\n        final AtomicInteger nodeCount = new AtomicInteger();\n\n        EventListener listener = new EventListener() {\n            @Override\n            public void onEvent(EventIterator events) {\n                for (; events.hasNext(); events.nextEvent()) {\n                    eventCount.incrementAndGet();\n                }\n            }\n        };\n\n        try {\n            observationManager.addEventListener(listener, EVENT_TYPES, \"/\", true, null, null, false);\n            Future<?> createNodes = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                private final Session session = repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n\n                @Override\n                public void run() {\n                    try {\n                        Node testRoot = session.getRootNode().addNode(\"observationBenchmark\");\n                        createChildren(testRoot, 100);\n                        for (Node m : JcrUtils.getChildNodes(testRoot)) {\n                            createChildren(m, 100);\n                            for (Node n : JcrUtils.getChildNodes(m)) {\n                                createChildren(n, 5);\n                            }\n                        }\n                        session.save();\n                    } catch (RepositoryException e) {\n                        throw new RuntimeException(e);\n                    } finally {\n                        session.logout();\n                    }\n                }\n\n                private void createChildren(Node node, int count) throws RepositoryException {\n                    for (int c = 0; c < count; c++) {\n                        node.addNode(\"n\" + c);\n                        if (nodeCount.incrementAndGet() % SAVE_INTERVAL == 0) {\n                            node.getSession().save();\n                        }\n                    }\n                }\n            });\n\n            System.out.println(\"ms      #node   nodes/s #event  event/s event ratio\");\n            while (!createNodes.isDone() || (eventCount.get() < nodeCount.get() * EVENTS_PER_NODE)) {\n                long t0 = System.currentTimeMillis();\n                Thread.sleep(OUTPUT_RESOLUTION);\n                t += System.currentTimeMillis() - t0;\n\n                int nc = nodeCount.get();\n                int ec = eventCount.get();\n\n                double nps = (double) nc / t * 1000;\n                double eps = (double) ec / t * 1000;\n                double epn = (double) ec / nc / EVENTS_PER_NODE;\n\n                System.out.format(\"%7d %7d %7.1f %7d %7.1f %1.2f%n\", t, nc, nps, ec, eps, epn);\n            }\n            createNodes.get();\n        } finally {\n            observationManager.removeEventListener(listener);\n        }\n    }","id":51659,"modified_method":"public void observationThroughput(final Repository repository, ObservationManager observationManager)\n            throws RepositoryException, InterruptedException, ExecutionException {\n        long t = 0;\n        final AtomicInteger eventCount = new AtomicInteger();\n        final AtomicInteger nodeCount = new AtomicInteger();\n\n        EventListener[] listeners = new Listener[LISTENER_COUNT];\n\n        try {\n            for (int k = 0; k < LISTENER_COUNT; k++) {\n                listeners[k] = new Listener(eventCount);\n                observationManager.addEventListener(listeners[k], EVENT_TYPES, \"/\", true, null, null, false);\n            }\n\n            Future<?> createNodes = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                private final Session session = repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n\n                @Override\n                public void run() {\n                    try {\n                        Node testRoot = session.getRootNode().addNode(\"observationBenchmark\");\n                        createChildren(testRoot, 100);\n                        for (Node m : JcrUtils.getChildNodes(testRoot)) {\n                            createChildren(m, 100);\n                            for (Node n : JcrUtils.getChildNodes(m)) {\n                                createChildren(n, 5);\n                            }\n                        }\n                        session.save();\n                    } catch (RepositoryException e) {\n                        throw new RuntimeException(e);\n                    } finally {\n                        session.logout();\n                    }\n                }\n\n                private void createChildren(Node node, int count) throws RepositoryException {\n                    for (int c = 0; c < count; c++) {\n                        node.addNode(\"n\" + c);\n                        if (nodeCount.incrementAndGet() % SAVE_INTERVAL == 0) {\n                            node.getSession().save();\n                        }\n                    }\n                }\n            });\n\n            System.out.println(\"ms      #node   nodes/s #event  event/s event ratio\");\n            while (!createNodes.isDone() || (eventCount.get() < nodeCount.get() * EVENTS_PER_NODE)) {\n                long t0 = System.currentTimeMillis();\n                Thread.sleep(OUTPUT_RESOLUTION);\n                t += System.currentTimeMillis() - t0;\n\n                int nc = nodeCount.get();\n                int ec = eventCount.get() / LISTENER_COUNT;\n\n                double nps = (double) nc / t * 1000;\n                double eps = (double) ec / t * 1000;\n                double epn = (double) ec / nc / EVENTS_PER_NODE;\n\n                System.out.format(\"%7d %7d %7.1f %7d %7.1f %1.2f%n\", t, nc, nps, ec, eps, epn);\n            }\n            createNodes.get();\n        } finally {\n            for (int k = 0; k < LISTENER_COUNT; k++) {\n                observationManager.removeEventListener(listeners[k]);\n            }\n        }\n    }","commit_id":"a5ef965e1045fd183c1a64bf4c18148ddd697b07","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Activate this component.\n     * @param props The configuration properties.\n     */\n    @Activate\n    protected void activate(final Map<String, Object> props) throws RepositoryException {\n        this.repositoryPath = PropertiesUtil.toString(props.get(CONFIG_PROPERTY_REPOSITORY_PATH), DEFAULT_REPOSITORY_PATH);\n        this.idNodePath = repositoryPath + '/' + Environment.APPLICATION_ID;\n\n        // create the background session and register a listener\n        this.backgroundSession = this.environment.createAdminSession();\n        this.updateLastModified();\n        this.backgroundSession.getWorkspace().getObservationManager().addEventListener(this,\n                javax.jcr.observation.Event.PROPERTY_CHANGED\n                |javax.jcr.observation.Event.NODE_ADDED,\n                this.repositoryPath,\n                true,\n                null,\n                null,\n                true);\n        logger.info(\"Apache Sling Versioning Manager started on instance {}\", Environment.APPLICATION_ID);\n        synchronized ( this.backgroundSession ) {\n            this.unlock(Environment.APPLICATION_ID);\n        }\n        this.scanExistingNodes();\n\n        this.update(props);\n    }","id":51660,"modified_method":"/**\n     * Activate this component.\n     * @param props The configuration properties.\n     */\n    @Activate\n    protected void activate(final Map<String, Object> props) throws RepositoryException {\n        this.repositoryPath = PropertiesUtil.toString(props.get(CONFIG_PROPERTY_REPOSITORY_PATH), DEFAULT_REPOSITORY_PATH);\n        this.idNodePath = repositoryPath + '/' + Environment.APPLICATION_ID;\n\n        // create the background session and register a listener\n        synchronized ( this.backgroundLock ) {\n            this.backgroundSession = this.environment.createAdminSession();\n            this.updateLastModified();\n            this.backgroundSession.getWorkspace().getObservationManager().addEventListener(this,\n                    javax.jcr.observation.Event.PROPERTY_CHANGED\n                    |javax.jcr.observation.Event.NODE_ADDED,\n                    this.repositoryPath,\n                    true,\n                    null,\n                    null,\n                    true);\n            logger.info(\"Apache Sling Versioning Manager started on instance {}\", Environment.APPLICATION_ID);\n            this.unlock(Environment.APPLICATION_ID);\n        }\n        this.scanExistingNodes();\n\n        this.update(props);\n    }","commit_id":"e0841bd9df67481b8863b7a4bd5c8894e43547c2","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this component.\n     */\n    @Deactivate\n    protected void deactivate() {\n        this.running = false;\n        if ( this.backgroundSession != null ) {\n            synchronized ( this.backgroundLock ) {\n                this.logger.debug(\"Shutting down background session.\");\n                try {\n                    this.backgroundSession.getWorkspace().getObservationManager().removeEventListener(this);\n                } catch (RepositoryException e) {\n                    // we just ignore it\n                    this.logger.warn(\"Unable to remove event listener.\", e);\n                }\n                this.backgroundSession.logout();\n                this.backgroundSession = null;\n            }\n        }\n        logger.info(\"Apache Sling Versioning Manager stopped on instance {}\", Environment.APPLICATION_ID);\n    }","id":51661,"modified_method":"/**\n     * Deactivate this component.\n     */\n    @Deactivate\n    protected void deactivate() {\n        this.running = false;\n        synchronized ( this.backgroundLock ) {\n            if ( this.backgroundSession != null ) {\n                this.logger.debug(\"Shutting down background session.\");\n                try {\n                    this.backgroundSession.getWorkspace().getObservationManager().removeEventListener(this);\n                } catch (RepositoryException e) {\n                    // we just ignore it\n                    this.logger.warn(\"Unable to remove event listener.\", e);\n                }\n                this.backgroundSession.logout();\n                this.backgroundSession = null;\n            }\n        }\n        logger.info(\"Apache Sling Versioning Manager stopped on instance {}\", Environment.APPLICATION_ID);\n    }","commit_id":"e0841bd9df67481b8863b7a4bd5c8894e43547c2","url":"https://github.com/apache/sling"},{"original_method":"public static void showDetailsPopup(final Project project, final CommittedChangeList changeList) {\n    StringBuilder detailsBuilder = new StringBuilder(\"<html><body>\");\n    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);\n    final AbstractVcs vcs = changeList.getVcs();\n    if (vcs != null) {\n      CachingCommittedChangesProvider provider = vcs.getCachingCommittedChangesProvider();\n      if (provider != null && provider.getChangelistTitle() != null) {\n        detailsBuilder.append(provider.getChangelistTitle()).append(\" #\").append(changeList.getNumber()).append(\"<br>\");\n      }\n    }\n    detailsBuilder.append(\"Committed by <b>\").append(changeList.getCommitterName()).append(\"<\/b> at \");\n    detailsBuilder.append(dateFormat.format(changeList.getCommitDate())).append(\"<br>\");\n    detailsBuilder.append(XmlStringUtil.escapeString(changeList.getComment()).replace(\"\\n\", \"<br>\"));\n    detailsBuilder.append(\"<\/body><\/html>\");\n\n    JEditorPane editorPane = new JEditorPane(UIUtil.HTML_MIME, detailsBuilder.toString());\n    editorPane.setEditable(false);\n    editorPane.setBackground(HintUtil.INFORMATION_COLOR);\n    editorPane.select(0, 0);\n    JScrollPane scrollPane = new JScrollPane(editorPane);\n    final JBPopup hint =\n      JBPopupFactory.getInstance().createComponentPopupBuilder(scrollPane, editorPane)\n        .setDimensionServiceKey(project, \"changelist.details.popup\", false)\n        .setResizable(true)\n        .setMovable(true)\n        .setRequestFocus(true)\n        .setTitle(VcsBundle.message(\"changelist.details.title\"))\n        .createPopup();\n    hint.showInBestPositionFor(DataManager.getInstance().getDataContext());\n  }","id":51662,"modified_method":"public static void showDetailsPopup(final Project project, final CommittedChangeList changeList) {\n    StringBuilder detailsBuilder = new StringBuilder(\"<html><body>\");\n    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);\n    final AbstractVcs vcs = changeList.getVcs();\n    if (vcs != null) {\n      CachingCommittedChangesProvider provider = vcs.getCachingCommittedChangesProvider();\n      if (provider != null && provider.getChangelistTitle() != null) {\n        detailsBuilder.append(provider.getChangelistTitle()).append(\" #\").append(changeList.getNumber()).append(\"<br>\");\n      }\n    }\n    detailsBuilder.append(\"Committed by <b>\").append(changeList.getCommitterName()).append(\"<\/b> at \");\n    detailsBuilder.append(dateFormat.format(changeList.getCommitDate())).append(\"<br>\");\n    String comment = XmlStringUtil.escapeString(changeList.getComment());\n    comment = ourHtmlPattern.matcher(comment).replaceAll(\"<a href=\\\"$0\\\">$0<\/a>\");\n\n    IssueNavigationConfiguration config = IssueNavigationConfiguration.getInstance(project);\n    for(IssueNavigationLink link: config.getLinks()) {\n      Pattern pattern = Pattern.compile(link.getIssueRegexp());\n      comment = pattern.matcher(comment).replaceAll(\"<a href=\\\"\" + link.getLinkRegexp() + \"\\\">$0<\/a>\");\n    }\n\n    detailsBuilder.append(comment.replace(\"\\n\", \"<br>\"));\n    detailsBuilder.append(\"<\/body><\/html>\");\n\n    JEditorPane editorPane = new JEditorPane(UIUtil.HTML_MIME, detailsBuilder.toString());\n    editorPane.setEditable(false);\n    editorPane.setBackground(HintUtil.INFORMATION_COLOR);\n    editorPane.select(0, 0);\n    editorPane.addHyperlinkListener(new HyperlinkListener() {\n      public void hyperlinkUpdate(final HyperlinkEvent e) {\n        if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n          BrowserUtil.launchBrowser(e.getDescription());\n        }\n      }\n    });\n    JScrollPane scrollPane = new JScrollPane(editorPane);\n    final JBPopup hint =\n      JBPopupFactory.getInstance().createComponentPopupBuilder(scrollPane, editorPane)\n        .setDimensionServiceKey(project, \"changelist.details.popup\", false)\n        .setResizable(true)\n        .setMovable(true)\n        .setRequestFocus(true)\n        .setTitle(VcsBundle.message(\"changelist.details.title\"))\n        .createPopup();\n    hint.showInBestPositionFor(DataManager.getInstance().getDataContext());\n  }","commit_id":"b0aa6ecec4828ccf94fc98ef3006a2839c9bf791","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"<T> SummaryBuilder add(String key, T value) {\n      return _add(key, StringUtils.escapeString(String.valueOf(value),\n          StringUtils.ESCAPE_CHAR, charsToEscape));\n    }","id":51663,"modified_method":"<T> SummaryBuilder add(String key, T value) {\n      String escapedString = StringUtils.escapeString(String.valueOf(value), \n          StringUtils.ESCAPE_CHAR, charsToEscape).replaceAll(\"\\n\", \"\\\\\\\\n\")\n                                                 .replaceAll(\"\\r\", \"\\\\\\\\r\");\n      return _add(key, escapedString);\n    }","commit_id":"cbf1c72d1b0af2f20dcf995524c4c68c07388482","url":"https://github.com/apache/hadoop"},{"original_method":"<T> SummaryBuilder add(String key, T value) {\n        return _add(key, StringUtils.escapeString(String.valueOf(value),\n                    StringUtils.ESCAPE_CHAR, charsToEscape));\n      }","id":51664,"modified_method":"<T> SummaryBuilder add(String key, T value) {\n        String escapedString = StringUtils.escapeString(String.valueOf(value),\n            StringUtils.ESCAPE_CHAR, charsToEscape).replaceAll(\"\\n\", \"\\\\\\\\n\")\n            .replaceAll(\"\\r\", \"\\\\\\\\r\");\n        return _add(key, escapedString);\n      }","commit_id":"135700a611738d4a1c090c35551a19884b88c6d6","url":"https://github.com/apache/hadoop"},{"original_method":"public byte[] loadContent() throws IOException, VcsException {\n    if (!myOperation.isLoaded()) {\n      CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n      executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"), myOperation),\n                                 CvsOperationExecutorCallback.EMPTY);\n      CvsResult result = executor.getResult();\n      if (result.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      if (result.hasErrors()) {\n        throw result.composeError();\n      }\n      if (isDeleted()){\n        throw new VcsException(CvsBundle.message(\"message.text.revision.was.deleted.from.repository\", myOperation.getRevisionString()));\n      }\n    }\n    return getContent();\n  }","id":51665,"modified_method":"public byte[] loadContent() throws IOException, VcsException {\n    if (!myOperation.isLoaded()) {\n      CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n      executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"), myOperation),\n                                 CvsOperationExecutorCallback.EMPTY);\n      CvsResult result = executor.getResult();\n      if (result.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      if (result.hasErrors()) {\n        throw result.composeError();\n      }\n    }\n    return getContent();\n  }","commit_id":"5c964ca6fc6ccbec383e39fd0fdd6863d5e405b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected byte[] loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, myRevision);\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (result.hasErrors()) {\n      throw result.composeError();\n    }\n    if (!operation.isLoaded()) {\n      throw new VcsException(\"Network problem\");\n    }\n\n    final byte[] fileBytes = operation.getFileBytes();\n    if (operation.isDeleted()) {\n      throw new VcsException(CvsBundle.message(\"message.text.revision.was.deleted.from.repository\", myRevision.getRevision()));\n    }\n    return fileBytes;\n  }","id":51666,"modified_method":"protected byte[] loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, myRevision);\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (result.hasErrors()) {\n      throw result.composeError();\n    }\n    if (!operation.isLoaded()) {\n      throw new VcsException(\"Network problem\");\n    }\n\n    return operation.getFileBytes();\n  }","commit_id":"5c964ca6fc6ccbec383e39fd0fdd6863d5e405b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public byte[] loadContent() throws IOException, VcsException {\n    myComparableCvsRevisionOnOperation.loadContent();\n    if (!isLoaded()) {\n      throw new VcsException(CvsBundle.message(\"exception.text.cannot.load.revision\", getRevisionNumber()));\n    }\n    if (fileNotFound()) {\n      throw new VcsException(CvsBundle.message(\"exception.text.cannot.find.revision\", getRevisionNumber()));\n    }\n\n    if (isDeleted()) {\n      throw new VcsException(CvsBundle.message(\"message.text.revision.was.deleted.from.repository\", getRevisionNumber()));\n    }\n    return myComparableCvsRevisionOnOperation.getContent();\n  }","id":51667,"modified_method":"public byte[] loadContent() throws IOException, VcsException {\n    myComparableCvsRevisionOnOperation.loadContent();\n    if (!isLoaded()) {\n      throw new VcsException(CvsBundle.message(\"exception.text.cannot.load.revision\", getRevisionNumber()));\n    }\n    if (fileNotFound()) {\n      throw new VcsException(CvsBundle.message(\"exception.text.cannot.find.revision\", getRevisionNumber()));\n    }\n\n    return myComparableCvsRevisionOnOperation.getContent();\n  }","commit_id":"5c964ca6fc6ccbec383e39fd0fdd6863d5e405b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized byte[] getFileBytes() {\n    if (myFileBytes == null) {\n      myFileBytes = loadFileBytes();\n    }\n    return myFileBytes;\n  }","id":51668,"modified_method":"public synchronized byte[] getFileBytes() {\n    if (myFileBytes == null) {\n      if (myState == DELETED) return ArrayUtil.EMPTY_BYTE_ARRAY;\n      myFileBytes = loadFileBytes();\n    }\n    return myFileBytes;\n  }","commit_id":"5c964ca6fc6ccbec383e39fd0fdd6863d5e405b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized byte[] loadFileBytes() {\n    if (myState != LOADING) {\n      LOG.error(\"state = \" + String.valueOf(myState));\n    }\n    if (myReader.isEmpty()) {\n      myState = DELETED;\n      return null;\n    }\n    else {\n      myState = SUCCESSFULLY_LOADED;\n      return myReader.getReadContent();\n    }\n  }","id":51669,"modified_method":"private synchronized byte[] loadFileBytes() {\n    if (myState != LOADING) {\n      LOG.error(\"state = \" + String.valueOf(myState));\n    }\n    if (myReader.isEmpty()) {\n      myState = DELETED;\n      return ArrayUtil.EMPTY_BYTE_ARRAY;\n    }\n    else {\n      myState = SUCCESSFULLY_LOADED;\n      return myReader.getReadContent();\n    }\n  }","commit_id":"5c964ca6fc6ccbec383e39fd0fdd6863d5e405b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void showDiff(final DiffProvider diffProvider,\n                        final VcsRevisionNumber revisionNumber,\n                        final VirtualFile selectedFile,\n                        final Project project) {\n    try {\n      final VcsFileContent fileRevision = diffProvider.createFileContent(revisionNumber, selectedFile);\n      if (fileRevision != null) {\n        fileRevision.loadContent();\n\n        if (selectedFile.getFileType().isBinary()) {\n          if (Arrays.equals(selectedFile.contentsToByteArray(), fileRevision.getContent())) {\n            Messages.showInfoMessage(VcsBundle.message(\"message.text.binary.versions.are.identical\"), VcsBundle.message(\"message.title.diff\"));\n          } else {\n            Messages.showInfoMessage(VcsBundle.message(\"message.text.binary.versions.are.different\"), VcsBundle.message(\"message.title.diff\"));\n          }\n          return;\n        }\n\n        final SimpleDiffRequest request =\n        new SimpleDiffRequest(project, selectedFile.getPresentableUrl());\n        final SimpleContent content1 = new SimpleContent(new String(fileRevision.getContent(), selectedFile.getCharset().name()), selectedFile.getFileType());\n        final DocumentContent content2 = new DocumentContent(project, FileDocumentManager.getInstance().getDocument(selectedFile));\n\n        final VcsRevisionNumber currentRevision = diffProvider.getCurrentRevision(selectedFile);\n\n        if (revisionNumber.compareTo(currentRevision) > 0) {\n          request.setContents(content2, content1);\n          request.setContentTitles(VcsBundle.message(\"diff.title.local\"), revisionNumber.asString());\n        } else {\n          request.setContents(content1, content2);\n          request.setContentTitles(revisionNumber.asString(), VcsBundle.message(\"diff.title.local\"));\n        }\n\n        request.addHint(DiffTool.HINT_SHOW_FRAME);\n        DiffManager.getInstance().getDiffTool().show(request);\n      }\n    }\n    catch (ProcessCanceledException e) {\n      //ignore\n    }\n    catch (VcsException e) {\n      AbstractVcsHelper.getInstance(project).showError(e, VcsBundle.message(\"message.title.diff\"));\n    }\n    catch (IOException e) {\n      AbstractVcsHelper.getInstance(project).showError(new VcsException(e), VcsBundle.message(\"message.title.diff\"));\n    }\n  }","id":51670,"modified_method":"protected static void showDiff(final DiffProvider diffProvider,\n                        final VcsRevisionNumber revisionNumber,\n                        final VirtualFile selectedFile,\n                        final Project project) {\n    try {\n      final ContentRevision fileRevision = diffProvider.createFileContent(revisionNumber, selectedFile);\n      if (fileRevision != null) {\n        final Ref<VcsException> ex = new Ref<VcsException>();\n        ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n          public void run() {\n            try {\n              fileRevision.getContent();\n            }\n            catch (VcsException e) {\n              ex.set(e);\n            }\n          }\n        }, \"Loading content...\", true, project);\n        if (!ex.isNull()) {\n          AbstractVcsHelper.getInstance(project).showError(ex.get(), VcsBundle.message(\"message.title.diff\"));\n          return;\n        }\n\n        if (fileRevision instanceof BinaryContentRevision) {\n          if (Arrays.equals(selectedFile.contentsToByteArray(), ((BinaryContentRevision) fileRevision).getBinaryContent())) {\n            Messages.showInfoMessage(VcsBundle.message(\"message.text.binary.versions.are.identical\"), VcsBundle.message(\"message.title.diff\"));\n          } else {\n            Messages.showInfoMessage(VcsBundle.message(\"message.text.binary.versions.are.different\"), VcsBundle.message(\"message.title.diff\"));\n          }\n          return;\n        }\n\n        final SimpleDiffRequest request =\n        new SimpleDiffRequest(project, selectedFile.getPresentableUrl());\n        final SimpleContent content1 = new SimpleContent(fileRevision.getContent(), selectedFile.getFileType());\n        final DocumentContent content2 = new DocumentContent(project, FileDocumentManager.getInstance().getDocument(selectedFile));\n\n        final VcsRevisionNumber currentRevision = diffProvider.getCurrentRevision(selectedFile);\n\n        if (revisionNumber.compareTo(currentRevision) > 0) {\n          request.setContents(content2, content1);\n          request.setContentTitles(VcsBundle.message(\"diff.title.local\"), revisionNumber.asString());\n        } else {\n          request.setContents(content1, content2);\n          request.setContentTitles(revisionNumber.asString(), VcsBundle.message(\"diff.title.local\"));\n        }\n\n        request.addHint(DiffTool.HINT_SHOW_FRAME);\n        DiffManager.getInstance().getDiffTool().show(request);\n      }\n    }\n    catch (ProcessCanceledException e) {\n      //ignore\n    }\n    catch (VcsException e) {\n      AbstractVcsHelper.getInstance(project).showError(e, VcsBundle.message(\"message.title.diff\"));\n    }\n    catch (IOException e) {\n      AbstractVcsHelper.getInstance(project).showError(new VcsException(e), VcsBundle.message(\"message.title.diff\"));\n    }\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<Change> getChanges() {\n    if (myChanges == null) {\n      myChanges = new ArrayList<Change>();\n      for(RevisionWrapper wrapper: myRevisions) {\n        final Revision revision = wrapper.getRevision();\n        final String state = revision.getState();\n        ContentRevision beforeRevision = isAdded(revision)\n          ? null\n          : new CvsContentRevision(new File(wrapper.getFile()), new CvsRevisionNumber(revision.getNumber()).getPrevNumber().asString(),\n                                   myEnvironment, myProject);\n        ContentRevision afterRevision = (DEAD_STATE.equals(state))\n          ? null\n          : new CvsContentRevision(new File(wrapper.getFile()), revision.getNumber(), myEnvironment, myProject);\n        myChanges.add(new Change(beforeRevision, afterRevision));\n      }\n    }\n    return myChanges;\n  }","id":51671,"modified_method":"public Collection<Change> getChanges() {\n    if (myChanges == null) {\n      myChanges = new ArrayList<Change>();\n      for(RevisionWrapper wrapper: myRevisions) {\n        final Revision revision = wrapper.getRevision();\n        final String state = revision.getState();\n        ContentRevision beforeRevision = isAdded(revision)\n          ? null\n          : new CvsContentRevision(new File(wrapper.getFile()),\n                                   new SimpleRevision(new CvsRevisionNumber(revision.getNumber()).getPrevNumber().asString()),\n                                   myEnvironment, myProject);\n        ContentRevision afterRevision = (DEAD_STATE.equals(state))\n          ? null\n          : new CvsContentRevision(new File(wrapper.getFile()),\n                                   new SimpleRevision(revision.getNumber()),\n                                   myEnvironment, myProject);\n        myChanges.add(new Change(beforeRevision, afterRevision));\n      }\n    }\n    return myChanges;\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CvsContentRevision(final File file,\n                            final String revisionNumber,\n                            final CvsEnvironment environment,\n                            final Project project) {\n    myFile = file;\n    myRevisionNumber= revisionNumber;\n    myEnvironment = environment;\n    myProject = project;\n  }","id":51672,"modified_method":"public CvsContentRevision(final File file,\n                            final RevisionOrDate revision,\n                            final CvsEnvironment environment,\n                            final Project project) {\n    myFile = file;\n    myRevision = revision;\n    myEnvironment = environment;\n    myProject = project;\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myContent == null) {\n      myContent = loadContent();\n    }\n    return myContent;\n  }","id":51673,"modified_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myContent == null) {\n      byte[] content = loadContent();\n      if (content != null) {\n        try {\n          myContent = new String(content, CharsetToolkit.getIDEOptionsCharset().name());\n        }\n        catch(UnsupportedEncodingException ex) {\n          throw new VcsException(ex);\n        }\n      }\n    }\n    return myContent;\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, new SimpleRevision(myRevisionNumber));\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (!result.hasNoErrors()) {\n      throw result.composeError();\n    }\n\n    try {\n      return new String(operation.getFileBytes(), CharsetToolkit.getIDEOptionsCharset().name());\n    }\n    catch (UnsupportedEncodingException e) {\n      throw new VcsException(e);\n    }\n  }","id":51674,"modified_method":"public byte[] loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, myRevision);\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (!result.hasNoErrors()) {\n      throw result.composeError();\n    }\n\n    return operation.getFileBytes();\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public VcsRevisionNumber getRevisionNumber() {\n    return new CvsRevisionNumber(myRevisionNumber);\n  }","id":51675,"modified_method":"@NotNull\n  public VcsRevisionNumber getRevisionNumber() {\n    return myRevision.getCvsRevisionNumber();\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsFileContent createFileContent(final VcsRevisionNumber revisionNumber, VirtualFile selectedFile) {\n    if ((revisionNumber instanceof CvsRevisionNumber)) {\n      final CvsRevisionNumber cvsRevisionNumber = ((CvsRevisionNumber)revisionNumber);\n      final RevisionOrDate versionInfo;\n      if (cvsRevisionNumber.getDateOrRevision() != null) {\n        versionInfo = RevisionOrDateImpl.createOn(cvsRevisionNumber.getDateOrRevision());\n      }\n      else {\n        versionInfo = new SimpleRevision(cvsRevisionNumber.asString());\n      }\n      \n      if (versionInfo != null) {\n        final GetFileContentOperation operation = new GetFileContentOperation(new File(CvsUtil.getModuleName(selectedFile)),\n                                                                              CvsEntriesManager.getInstance()\n                                                                                .getCvsConnectionSettingsFor(selectedFile.getParent()),\n                                                                              versionInfo\n        );\n        return new CvsFileContent(new ComparableVcsRevisionOnOperation(operation, myProject)) {\n          public VcsRevisionNumber getRevisionNumber() {\n            return revisionNumber;\n          }\n        };\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }","id":51676,"modified_method":"public ContentRevision createFileContent(final VcsRevisionNumber revisionNumber, VirtualFile selectedFile) {\n    if ((revisionNumber instanceof CvsRevisionNumber)) {\n      final CvsConnectionSettings settings = CvsEntriesManager.getInstance().getCvsConnectionSettingsFor(selectedFile.getParent());\n      final File file = new File(CvsUtil.getModuleName(selectedFile));\n      final CvsRevisionNumber cvsRevisionNumber = ((CvsRevisionNumber)revisionNumber);\n      final RevisionOrDate versionInfo;\n      if (cvsRevisionNumber.getDateOrRevision() != null) {\n        versionInfo = RevisionOrDateImpl.createOn(cvsRevisionNumber.getDateOrRevision());\n      }\n      else {\n        versionInfo = new SimpleRevision(cvsRevisionNumber.asString());\n      }\n\n      if (selectedFile.getFileType().isBinary()) {\n        return new CvsBinaryContentRevision(file, versionInfo, settings, myProject);\n      }\n      else {\n        return new CvsContentRevision(file, versionInfo, settings, myProject);\n      }\n\n    } else {\n      return null;\n    }\n  }","commit_id":"0045a776d637d39e3d2d7ba22308e1454926ddf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public byte[] loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, myRevision);\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (!result.hasNoErrors()) {\n      throw result.composeError();\n    }\n\n    return operation.getFileBytes();\n  }","id":51677,"modified_method":"public byte[] loadContent() throws VcsException {\n    final GetFileContentOperation operation = new GetFileContentOperation(myFile, myEnvironment, myRevision);\n    CvsOperationExecutor executor = new CvsOperationExecutor(myProject);\n    executor.performActionSync(new CommandCvsHandler(CvsBundle.message(\"operation.name.load.file\"),\n                                                     operation),\n                               CvsOperationExecutorCallback.EMPTY);\n    CvsResult result = executor.getResult();\n    if (result.isCanceled()) {\n      throw new ProcessCanceledException();\n    }\n    if (!result.hasNoErrors()) {\n      throw result.composeError();\n    }\n\n    final byte[] fileBytes = operation.getFileBytes();\n    if (operation.isDeleted()) {\n      throw new VcsException(CvsBundle.message(\"message.text.revision.was.deleted.from.repository\", myRevision.getRevision()));\n    }\n    return fileBytes;\n  }","commit_id":"16cae4ae2c4bc604e015b517d2fc9c3ea66c6801","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getRevision() {\n    return myStickyTag;\n  }","id":51678,"modified_method":"public String getRevision() {\n    if (myStickyTag == null) {\n      return \"HEAD\";\n    }\n    return myStickyTag;\n  }","commit_id":"16cae4ae2c4bc604e015b517d2fc9c3ea66c6801","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void generateAggregatedZip(MavenProject rootProject, List<MavenProject> reactorProjects, Set<MavenProject> pomZipProjects) throws IOException, MojoExecutionException {\n        File projectBaseDir = rootProject.getBasedir();\n        String rootProjectGroupId = rootProject.getGroupId();\n        String rootProjectArtifactId = rootProject.getArtifactId();\n        String rootProjectVersion = rootProject.getVersion();\n\n        String aggregatedZipFileName = \"target/\" + rootProjectArtifactId + \"-\" + rootProjectVersion + \"-app.zip\";\n        File projectOutputFile = new File(projectBaseDir, aggregatedZipFileName);\n        getLog().info(\"Generating \" + projectOutputFile.getAbsolutePath() + \" from root project \" + rootProjectArtifactId);\n        File projectBuildDir = new File(projectBaseDir, reactorProjectOutputPath);\n\n        if (projectOutputFile.exists()) {\n            projectOutputFile.delete();\n        }\n        createAggregatedZip(projectBaseDir, projectBuildDir, reactorProjectOutputPath, projectOutputFile,\n                includeReadMe, pomZipProjects);\n        if (rootProject.getAttachedArtifacts() != null) {\n            // need to remove existing as otherwise we get a WARN\n            Artifact found = null;\n            for (Artifact artifact : rootProject.getAttachedArtifacts()) {\n                if (artifactClassifier != null && artifact.hasClassifier() && artifact.getClassifier().equals(artifactClassifier)) {\n                    found = artifact;\n                    break;\n                }\n            }\n            if (found != null) {\n                rootProject.getAttachedArtifacts().remove(found);\n            }\n        }\n\n        getLog().info(\"Attaching aggregated zip \" + projectOutputFile + \" to root project \" + rootProject.getArtifactId());\n        projectHelper.attachArtifact(rootProject, artifactType, artifactClassifier, projectOutputFile);\n\n        // if we are doing an install goal, then also install the aggregated zip manually\n        // as maven will install the root project first, and then build the reactor projects, and at this point\n        // it does not help to attach artifact to root project, as those artifacts will not be installed\n        // so we need to install manually\n        List<String> activeProfileIds = new ArrayList<>();\n        List<Profile> activeProfiles = rootProject.getActiveProfiles();\n        if (activeProfiles != null) {\n            for (Profile profile : activeProfiles) {\n                String id = profile.getId();\n                if (Strings.isNotBlank(id)) {\n                    activeProfileIds.add(id);\n                }\n            }\n        }\n        if (rootProject.hasLifecyclePhase(\"install\")) {\n            getLog().info(\"Installing aggregated zip \" + projectOutputFile);\n            InvocationRequest request = new DefaultInvocationRequest();\n            request.setBaseDirectory(rootProject.getBasedir());\n            request.setPomFile(new File(\"./pom.xml\"));\n            request.setGoals(Collections.singletonList(\"install:install-file\"));\n            request.setRecursive(false);\n            request.setInteractive(false);\n            request.setProfiles(activeProfileIds);\n\n            Properties props = new Properties();\n            props.setProperty(\"file\", aggregatedZipFileName);\n            props.setProperty(\"groupId\", rootProjectGroupId);\n            props.setProperty(\"artifactId\", rootProjectArtifactId);\n            props.setProperty(\"version\", rootProjectVersion);\n            props.setProperty(\"classifier\", \"app\");\n            props.setProperty(\"packaging\", \"zip\");\n            props.setProperty(\"generatePom\", \"false\");\n            request.setProperties(props);\n\n            getLog().info(\"Installing aggregated zip using: mvn install:install-file\" + serializeMvnProperties(props));\n            Invoker invoker = new DefaultInvoker();\n            try {\n                InvocationResult result = invoker.execute(request);\n                if (result.getExitCode() != 0) {\n                    throw new IllegalStateException(\"Error invoking Maven goal install:install-file\");\n                }\n            } catch (MavenInvocationException e) {\n                throw new MojoExecutionException(\"Error invoking Maven goal install:install-file\", e);\n            }\n        }\n\n        if (rootProject.hasLifecyclePhase(\"deploy\")) {\n\n            if (deploymentRepository == null) {\n                String msg = \"Cannot run deploy phase as Maven project has no <distributionManagement> with the maven url to use for deploying the aggregated zip file\";\n                getLog().warn(msg);\n                throw new MojoExecutionException(msg);\n            }\n\n            getLog().info(\"Deploying aggregated zip \" + projectOutputFile + \" to root project \" + rootProject.getArtifactId());\n            getLog().info(\"Using deploy goal: \" + deployFileGoal + \" with active profiles: \" + activeProfileIds);\n\n            InvocationRequest request = new DefaultInvocationRequest();\n            request.setBaseDirectory(rootProject.getBasedir());\n            request.setPomFile(new File(\"./pom.xml\"));\n            request.setGoals(Collections.singletonList(deployFileGoal));\n            request.setRecursive(false);\n            request.setInteractive(false);\n            request.setProfiles(activeProfileIds);\n\n            Properties props = new Properties();\n            props.setProperty(\"file\", aggregatedZipFileName);\n            props.setProperty(\"groupId\", rootProjectGroupId);\n            props.setProperty(\"artifactId\", rootProjectArtifactId);\n            props.setProperty(\"version\", rootProjectVersion);\n            props.setProperty(\"classifier\", \"app\");\n            props.setProperty(\"packaging\", \"zip\");\n            String deployUrl = deployFileUrl;\n            if (Strings.isNullOrBlank(deployUrl)) {\n                deployUrl = deploymentRepository.getUrl();\n            }\n            props.setProperty(\"url\", deployUrl);\n            props.setProperty(\"repositoryId\", deploymentRepository.getId());\n            props.setProperty(\"generatePom\", \"false\");\n            request.setProperties(props);\n\n            getLog().info(\"Deploying aggregated zip using: mvn deploy:deploy-file\" + serializeMvnProperties(props));\n            Invoker invoker = new DefaultInvoker();\n            try {\n                InvocationResult result = invoker.execute(request);\n                if (result.getExitCode() != 0) {\n                    throw new IllegalStateException(\"Error invoking Maven goal deploy:deploy-file\");\n                }\n            } catch (MavenInvocationException e) {\n                throw new MojoExecutionException(\"Error invoking Maven goal deploy:deploy-file\", e);\n            }\n        }\n    }","id":51679,"modified_method":"protected void generateAggregatedZip(MavenProject rootProject, List<MavenProject> reactorProjects, Set<MavenProject> pomZipProjects) throws IOException, MojoExecutionException {\n        File projectBaseDir = rootProject.getBasedir();\n        String rootProjectGroupId = rootProject.getGroupId();\n        String rootProjectArtifactId = rootProject.getArtifactId();\n        String rootProjectVersion = rootProject.getVersion();\n\n        String aggregatedZipFileName = \"target/\" + rootProjectArtifactId + \"-\" + rootProjectVersion + \"-app.zip\";\n        File projectOutputFile = new File(projectBaseDir, aggregatedZipFileName);\n        getLog().info(\"Generating \" + projectOutputFile.getAbsolutePath() + \" from root project \" + rootProjectArtifactId);\n        File projectBuildDir = new File(projectBaseDir, reactorProjectOutputPath);\n\n        if (projectOutputFile.exists()) {\n            projectOutputFile.delete();\n        }\n        createAggregatedZip(projectBaseDir, projectBuildDir, reactorProjectOutputPath, projectOutputFile,\n                includeReadMe, pomZipProjects);\n        if (rootProject.getAttachedArtifacts() != null) {\n            // need to remove existing as otherwise we get a WARN\n            Artifact found = null;\n            for (Artifact artifact : rootProject.getAttachedArtifacts()) {\n                if (artifactClassifier != null && artifact.hasClassifier() && artifact.getClassifier().equals(artifactClassifier)) {\n                    found = artifact;\n                    break;\n                }\n            }\n            if (found != null) {\n                rootProject.getAttachedArtifacts().remove(found);\n            }\n        }\n\n        getLog().info(\"Attaching aggregated zip \" + projectOutputFile + \" to root project \" + rootProject.getArtifactId());\n        projectHelper.attachArtifact(rootProject, artifactType, artifactClassifier, projectOutputFile);\n\n        // if we are doing an install goal, then also install the aggregated zip manually\n        // as maven will install the root project first, and then build the reactor projects, and at this point\n        // it does not help to attach artifact to root project, as those artifacts will not be installed\n        // so we need to install manually\n        List<String> activeProfileIds = new ArrayList<>();\n        List<Profile> activeProfiles = rootProject.getActiveProfiles();\n        if (activeProfiles != null) {\n            for (Profile profile : activeProfiles) {\n                String id = profile.getId();\n                if (Strings.isNotBlank(id)) {\n                    activeProfileIds.add(id);\n                }\n            }\n        }\n        if (rootProject.hasLifecyclePhase(\"install\")) {\n            getLog().info(\"Installing aggregated zip \" + projectOutputFile);\n            InvocationRequest request = new DefaultInvocationRequest();\n            request.setBaseDirectory(rootProject.getBasedir());\n            request.setPomFile(new File(\"./pom.xml\"));\n            request.setGoals(Collections.singletonList(\"install:install-file\"));\n            request.setRecursive(false);\n            request.setInteractive(false);\n            request.setProfiles(activeProfileIds);\n\n            Properties props = new Properties();\n            props.setProperty(\"file\", aggregatedZipFileName);\n            props.setProperty(\"groupId\", rootProjectGroupId);\n            props.setProperty(\"artifactId\", rootProjectArtifactId);\n            props.setProperty(\"version\", rootProjectVersion);\n            props.setProperty(\"classifier\", \"app\");\n            props.setProperty(\"packaging\", \"zip\");\n            props.setProperty(\"generatePom\", \"false\");\n            request.setProperties(props);\n\n            getLog().info(\"Installing aggregated zip using: mvn install:install-file\" + serializeMvnProperties(props));\n            Invoker invoker = new DefaultInvoker();\n            try {\n                InvocationResult result = invoker.execute(request);\n                if (result.getExitCode() != 0) {\n                    throw new IllegalStateException(\"Error invoking Maven goal install:install-file\");\n                }\n            } catch (MavenInvocationException e) {\n                throw new MojoExecutionException(\"Error invoking Maven goal install:install-file\", e);\n            }\n        }\n\n        if (rootProject.hasLifecyclePhase(\"deploy\")) {\n\n            if (deploymentRepository == null && Strings.isNullOrBlank(altDeploymentRepository)) {\n                String msg = \"Cannot run deploy phase as Maven project has no <distributionManagement> with the maven url to use for deploying the aggregated zip file, neither an altDeploymentRepository property.\";\n                getLog().warn(msg);\n                throw new MojoExecutionException(msg);\n            }\n\n            getLog().info(\"Deploying aggregated zip \" + projectOutputFile + \" to root project \" + rootProject.getArtifactId());\n            getLog().info(\"Using deploy goal: \" + deployFileGoal + \" with active profiles: \" + activeProfileIds);\n\n            InvocationRequest request = new DefaultInvocationRequest();\n            request.setBaseDirectory(rootProject.getBasedir());\n            request.setPomFile(new File(\"./pom.xml\"));\n            request.setGoals(Collections.singletonList(deployFileGoal));\n            request.setRecursive(false);\n            request.setInteractive(false);\n            request.setProfiles(activeProfileIds);\n            request.setProperties(getProject().getProperties());\n\n            Properties props = new Properties();\n            props.setProperty(\"file\", aggregatedZipFileName);\n            props.setProperty(\"groupId\", rootProjectGroupId);\n            props.setProperty(\"artifactId\", rootProjectArtifactId);\n            props.setProperty(\"version\", rootProjectVersion);\n            props.setProperty(\"classifier\", \"app\");\n            props.setProperty(\"packaging\", \"zip\");\n            String deployUrl = null;\n\n            if (! Strings.isNullOrBlank(deployFileUrl)) {\n                deployUrl = deployFileUrl;\n            } else if (altDeploymentRepository != null && altDeploymentRepository.contains(\"::\")) {\n                deployUrl = altDeploymentRepository.substring(altDeploymentRepository.lastIndexOf(\"::\") + 2);\n            } else {\n                deployUrl = deploymentRepository.getUrl();\n            }\n\n            props.setProperty(\"url\", deployUrl);\n            props.setProperty(\"repositoryId\", deploymentRepository.getId());\n            props.setProperty(\"generatePom\", \"false\");\n            request.setProperties(props);\n\n            getLog().info(\"Deploying aggregated zip using: mvn deploy:deploy-file\" + serializeMvnProperties(props));\n            Invoker invoker = new DefaultInvoker();\n            try {\n                InvocationResult result = invoker.execute(request);\n                if (result.getExitCode() != 0) {\n                    throw new IllegalStateException(\"Error invoking Maven goal deploy:deploy-file\");\n                }\n            } catch (MavenInvocationException e) {\n                throw new MojoExecutionException(\"Error invoking Maven goal deploy:deploy-file\", e);\n            }\n        }\n    }","commit_id":"374c36e511fef3c266f64c9d9923dfe5403be7bd","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n         * Configures the builder from the requirements and chosen host configuration\n         */\n        public void configure(SshHostConfiguration sshHostConfig, FabricRequirements requirements, ProfileRequirements profileRequirements, String containerName) {\n            SshConfiguration sshHosts = requirements.getSshConfiguration();\n            host = sshHostConfig.getHostName();\n            if (Strings.isNullOrBlank(host)) {\n                throw new IllegalArgumentException(\"Missing host property in the ssh configuration: \" + sshHostConfig);\n            }\n            path = sshHostConfig.getPath();\n            if (Strings.isNullOrBlank(path)) {\n                if (sshHosts != null) {\n                    path = sshHosts.getDefaultPath();\n                }\n                if (Strings.isNullOrBlank(path)) {\n                    path = DEFAULT_PATH;\n                }\n            }\n            Integer portValue = sshHostConfig.getPort();\n            if (portValue == null) {\n                if (sshHosts != null) {\n                    portValue = sshHosts.getDefaultPort();\n                }\n            }\n            port = portValue != null ? portValue : DEFAULT_SSH_PORT;\n\n            username = sshHostConfig.getUsername();\n            if (Strings.isNullOrBlank(username)) {\n                if (sshHosts != null) {\n                    username = sshHosts.getDefaultUsername();\n                }\n                if (Strings.isNullOrBlank(username)) {\n                    throw new IllegalArgumentException(\"Missing username property in the ssh configuration: \" + sshHostConfig);\n                }\n            }\n\n            password = sshHostConfig.getPassword();\n            if (Strings.isNullOrBlank(password)) {\n                if (sshHosts != null) {\n                    password = sshHosts.getDefaultPassword();\n                }\n                if (Strings.isNullOrBlank(password)) {\n                    throw new IllegalArgumentException(\"Missing password property in the ssh configuration: \" + sshHostConfig);\n                }\n            }\n\n            if (sshHosts != null) {\n                fallbackRepositories = sshHosts.getFallbackRepositories();\n            }\n\n            passPhrase = sshHostConfig.getPassPhrase();\n            if (Strings.isNullOrBlank(passPhrase)) {\n                if (sshHosts != null) {\n                    passPhrase = sshHosts.getDefaultPassPhrase();\n                }\n            }\n\n            privateKeyFile = sshHostConfig.getPrivateKeyFile();\n            if (Strings.isNullOrBlank(privateKeyFile)) {\n                if (sshHosts != null) {\n                    privateKeyFile = sshHosts.getDefaultPrivateKeyFile();\n                }\n                if (Strings.isNullOrBlank(privateKeyFile)) {\n                    privateKeyFile = DEFAULT_PRIVATE_KEY_FILE;\n                }\n            }\n        }","id":51680,"modified_method":"/**\n         * Configures the builder from the requirements and chosen host configuration\n         */\n        public void configure(SshHostConfiguration sshHostConfig, FabricRequirements requirements, ProfileRequirements profileRequirements, String containerName) {\n            SshConfiguration sshHosts = requirements.getSshConfiguration();\n            host = sshHostConfig.getHostName();\n            if (Strings.isNullOrBlank(host)) {\n                throw new IllegalArgumentException(\"Missing host property in the ssh configuration: \" + sshHostConfig);\n            }\n            String preferredAddress = getPreferredAddress();\n            if (Strings.isNullOrBlank(preferredAddress)) {\n                preferredAddress = sshHostConfig.getPreferredAddress();\n                if (Strings.isNullOrBlank(preferredAddress)) {\n                    preferredAddress = host;\n                }\n                preferredAddress(preferredAddress);\n            }\n            path = sshHostConfig.getPath();\n            if (Strings.isNullOrBlank(path)) {\n                if (sshHosts != null) {\n                    path = sshHosts.getDefaultPath();\n                }\n                if (Strings.isNullOrBlank(path)) {\n                    path = DEFAULT_PATH;\n                }\n            }\n            Integer portValue = sshHostConfig.getPort();\n            if (portValue == null) {\n                if (sshHosts != null) {\n                    portValue = sshHosts.getDefaultPort();\n                }\n            }\n            port = portValue != null ? portValue : DEFAULT_SSH_PORT;\n\n            username = sshHostConfig.getUsername();\n            if (Strings.isNullOrBlank(username)) {\n                if (sshHosts != null) {\n                    username = sshHosts.getDefaultUsername();\n                }\n                if (Strings.isNullOrBlank(username)) {\n                    throw new IllegalArgumentException(\"Missing username property in the ssh configuration: \" + sshHostConfig);\n                }\n            }\n\n            password = sshHostConfig.getPassword();\n            if (Strings.isNullOrBlank(password)) {\n                if (sshHosts != null) {\n                    password = sshHosts.getDefaultPassword();\n                }\n            }\n\n            if (sshHosts != null) {\n                fallbackRepositories = sshHosts.getFallbackRepositories();\n            }\n\n            passPhrase = sshHostConfig.getPassPhrase();\n            if (Strings.isNullOrBlank(passPhrase)) {\n                if (sshHosts != null) {\n                    passPhrase = sshHosts.getDefaultPassPhrase();\n                }\n            }\n\n            privateKeyFile = sshHostConfig.getPrivateKeyFile();\n            if (Strings.isNullOrBlank(privateKeyFile)) {\n                if (sshHosts != null) {\n                    privateKeyFile = sshHosts.getDefaultPrivateKeyFile();\n                }\n                if (Strings.isNullOrBlank(privateKeyFile)) {\n                    privateKeyFile = DEFAULT_PRIVATE_KEY_FILE;\n                }\n            }\n        }","commit_id":"a3a5e657b17004ac0229c33d26a534fb27ef14c9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        // if no directory then use workspace\n        if (directory == null) {\n            // must have a workspace location configured\n            Preferences preferences = Preferences.userNodeForPackage(getClass());\n            String location = preferences.get(ArchetypeWorkspace.PREFERENCE_WORKSPACE, null);\n            if (location == null) {\n                System.out.println(\"No workspace location has been set.\");\n                System.out.println(\"Use the archetype-workspace command to set a workspace first.\");\n                System.out.println(\"\");\n                return null;\n            } else {\n                System.out.println(\"Using current workspace: \" + location);\n                directory = location;\n            }\n        } else {\n            System.out.println(\"Using directory as workspace: \" + directory);\n        }\n\n        File target = new File(directory);\n\n        // make sure the directory exists, auto-creating if missing\n        if (!target.exists()) {\n            target.mkdirs();\n        }\n        if (!target.exists() || !target.isDirectory()) {\n            System.err.println(\"Workspace does not exists or is not a directory: \" + directory);\n            return null;\n        }\n\n        Archetype archetype = null;\n\n        // try artifact first\n        if (!isNullOrBlank(archetypeOrFilter)) {\n            archetype = archetypeService.getArchetypeByArtifact(archetypeOrFilter);\n            if (archetype == null) {\n                // then by coordinate\n                archetype = archetypeService.getArchetype(archetypeOrFilter);\n            }\n        }\n\n        // no archetype yet so present a list where the user can select\n        while (archetype == null) {\n            List<Archetype> archetypes = archetypeService.listArchetypes(archetypeOrFilter, true);\n\n            System.out.println(\"Choose archetype:\");\n            Iterator<Archetype> it = archetypes.iterator();\n            int i = 0;\n            while (it.hasNext()) {\n                Archetype select = it.next();\n                System.out.println(String.format(\"%4d: -> %-50s %s\", ++i, select.artifactId, select.description));\n            }\n\n            boolean choosing = true;\n            while (choosing) {\n\n                // default select last\n                String choose = ShellUtils.readLine(session, String.format(\"Choose a number or apply filter (case insensitive): %d: \", i), false);\n                if (Strings.isNullOrBlank(choose)) {\n                    // user pressed enter so we select the last\n                    choose = \"\" + i;\n                }\n\n                try {\n                    int no = Integer.valueOf(choose);\n\n                    // is the number within range\n                    if (no >= 1 && no <= archetypes.size()) {\n                        archetype = archetypes.get(no - 1);\n                        break;\n                    } else {\n                        System.out.println(\"Number \" + no + \" out of range. Please try again!\");\n                        continue;\n                    }\n                } catch (NumberFormatException e) {\n                    // no its a filter, so we use this as filter, and show the list again\n                    archetypeOrFilter = choose;\n                    choosing = false;\n                    archetype = null;\n                }\n            }\n        }\n\n        // okay we have selected an archetype now\n\n        File archetypeFile = fetchArchetype(archetype);\n        if (archetypeFile == null || !archetypeFile.exists()) {\n            System.err.println(\"No archetype found for \\\"\" + archetypeOrFilter + \"\\\" coordinates\");\n            return null;\n        }\n\n        System.out.println(\"----------------------------------------------------------------------------\");\n        System.out.println(\"Using archetype: \" + archetype.artifactId);\n\n        String defaultGroupId = \"io.fabric8\";\n        String defaultArtifactId = archetype.artifactId + \"-example\";\n        String defaultVersion = \"1.0-SNAPSHOT\";\n\n        System.out.println(\"----- Configure archetype -----\");\n        String groupId = ShellUtils.readLine(session, String.format(\"Define value for property 'groupId' (%s): \", defaultGroupId), false);\n        String artifactId = ShellUtils.readLine(session, String.format(\"Define value for property 'artifactId' (%s): \", defaultArtifactId), false);\n        String version = ShellUtils.readLine(session,  String.format(\"Define value for property 'version' (%s): \", defaultVersion), false);\n\n        groupId = isNullOrBlank(groupId) ? defaultGroupId : groupId;\n        artifactId = isNullOrBlank(artifactId) ? defaultArtifactId : artifactId;\n        version = isNullOrBlank(version) ? defaultVersion : version;\n\n        String defaultPackageName = (groupId + \".\" + artifactId).replaceAll(\"-\", \".\");\n        String packageName = ShellUtils.readLine(session, String.format(\"Define value for property 'package' (%s): \", defaultPackageName), false);\n        // use artifact id as default directory name (maven does this also)\n        String defaultDirectoryName = isNullOrBlank(artifactId) ? defaultArtifactId : artifactId;\n        directory = ShellUtils.readLine(session, String.format(\"Define value for property 'directoryName' (%s): \", defaultDirectoryName), false);\n\n        packageName = isNullOrBlank(packageName) ? defaultPackageName : packageName;\n        directory = isNullOrBlank(directory) ? artifactId : directory;\n\n        File childDir = new File(target, directory);\n\n        ArchetypeHelper helper = new ArchetypeHelper(archetypeFile, childDir, groupId, artifactId, version);\n        helper.setPackageName(packageName);\n\n        Map<String, String> properties = helper.parseProperties();\n\n        // show additional properties and ask to use them as-is\n        boolean mustChoose = false;\n        if (!properties.isEmpty()) {\n\n            // check if we must choose if there is an empty value or a value that has a ${ } token so we dont have a default value\n            for (String value : properties.values()) {\n                if (isNullOrBlank(value) || value.contains(\"$\")) {\n                    mustChoose = true;\n                    break;\n                }\n            }\n\n            // if we have fabric.profile as property, then use artifactId as its default suggested value\n            String profile = properties.get(\"fabric8.profile\");\n            if (isNullOrBlank(profile)) {\n                properties.put(\"fabric8.profile\", artifactId);\n                mustChoose = true;\n            }\n\n            if (!mustChoose) {\n                System.out.println(\"----- Additional properties -----\");\n                for (String key : properties.keySet()) {\n                    System.out.println(String.format(\"Using property '%s' (%s): \", key, properties.get(key)));\n                }\n            }\n\n            boolean choosing = true;\n            while (mustChoose || choosing) {\n\n                String confirm = null;\n                if (!mustChoose) {\n                    confirm = ShellUtils.readLine(session, \"Confirm additional properties configuration: (Y): \", false);\n                    confirm = isNullOrBlank(confirm) ? \"Y\" : confirm;\n                }\n\n                if (mustChoose || !\"Y\".equalsIgnoreCase(confirm)) {\n                    // ask for replacement properties suggesting the defaults\n                    if (!properties.isEmpty()) {\n                        System.out.println(\"----- Configure additional properties -----\");\n                        for (String key : properties.keySet()) {\n                            String value = properties.get(key);\n                            // if the value is empty or a token, then do not show any default value\n                            if (isNullOrBlank(value) || value.contains(\"$\")) {\n                                value = \"\";\n                            }\n                            String p = ShellUtils.readLine(session, String.format(\"Define value for property '%s' (%s): \", key, value), false);\n                            p = isNullOrBlank(p) ? value : p;\n                            properties.put(key, p);\n                        }\n                    }\n                    mustChoose = false;\n                } else {\n                    choosing = false;\n                }\n            }\n\n            // set override properties\n            helper.setOverrideProperties(properties);\n        }\n\n        String confirm = ShellUtils.readLine(session, \"Create project: (Y): \", false);\n        confirm = confirm == null || confirm.trim().equals(\"\") ? \"Y\" : confirm;\n\n        if (\"Y\".equalsIgnoreCase(confirm)) {\n            System.out.println(\"----------------------------------------------------------------------------\");\n            System.out.println(String.format(\"Creating project in directory: %s\", childDir.getCanonicalPath()));\n            helper.execute();\n            System.out.println(\"Project created successfully\");\n            System.out.println(\"\");\n        } else {\n            System.out.println(\"----------------------------------------------------------------------------\");\n            System.out.println(\"Creating project aborted!\");\n            System.out.println(\"\");\n        }\n        return null;\n    }","id":51681,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        // if no directory then use workspace\n        if (directory == null) {\n            // must have a workspace location configured\n            Preferences preferences = Preferences.userNodeForPackage(getClass());\n            String location = preferences.get(ArchetypeWorkspace.PREFERENCE_WORKSPACE, null);\n            if (location == null) {\n                System.out.println(\"No workspace location has been set.\");\n                System.out.println(\"Use the archetype-workspace command to set a workspace first.\");\n                System.out.println(\"\");\n                return null;\n            } else {\n                System.out.println(\"Using current workspace: \" + location);\n                directory = location;\n            }\n        } else {\n            System.out.println(\"Using directory as workspace: \" + directory);\n        }\n\n        File target = new File(directory);\n\n        // make sure the directory exists, auto-creating if missing\n        if (!target.exists()) {\n            target.mkdirs();\n        }\n        if (!target.exists() || !target.isDirectory()) {\n            System.err.println(\"Workspace does not exists or is not a directory: \" + directory);\n            return null;\n        }\n\n        Archetype archetype = null;\n\n        // try artifact first\n        if (!isNullOrBlank(archetypeOrFilter)) {\n            archetype = archetypeService.getArchetypeByArtifact(archetypeOrFilter);\n            if (archetype == null) {\n                // then by coordinate\n                archetype = archetypeService.getArchetype(archetypeOrFilter);\n            }\n        }\n\n        // no archetype yet so present a list where the user can select\n        while (archetype == null) {\n            List<Archetype> archetypes = archetypeService.listArchetypes(archetypeOrFilter, true);\n\n            System.out.println(\"Choose archetype:\");\n            Iterator<Archetype> it = archetypes.iterator();\n            int i = 0;\n            while (it.hasNext()) {\n                Archetype select = it.next();\n                System.out.println(String.format(\"%4d: -> %-50s %s\", ++i, select.artifactId, select.description));\n            }\n\n            boolean choosing = true;\n            while (choosing) {\n\n                // default select last\n                String choose = ShellUtils.readLine(session, String.format(\"Choose a number or apply filter (case insensitive): %d: \", i), false);\n                if (Strings.isNullOrBlank(choose)) {\n                    // user pressed enter so we select the last\n                    choose = \"\" + i;\n                }\n\n                try {\n                    int no = Integer.valueOf(choose);\n\n                    // is the number within range\n                    if (no >= 1 && no <= archetypes.size()) {\n                        archetype = archetypes.get(no - 1);\n                        break;\n                    } else {\n                        System.out.println(\"Number \" + no + \" out of range. Please try again!\");\n                        continue;\n                    }\n                } catch (NumberFormatException e) {\n                    // no its a filter, so we use this as filter, and show the list again\n                    archetypeOrFilter = choose;\n                    choosing = false;\n                    archetype = null;\n                }\n            }\n        }\n\n        // okay we have selected an archetype now\n\n        File archetypeFile = fetchArchetype(archetype);\n        if (archetypeFile == null || !archetypeFile.exists()) {\n            System.err.println(\"No archetype found for \\\"\" + archetypeOrFilter + \"\\\" coordinates\");\n            return null;\n        }\n\n        System.out.println(\"----------------------------------------------------------------------------\");\n        System.out.println(\"Using archetype: \" + archetype.artifactId);\n\n        String defaultGroupId = \"io.fabric8\";\n        String defaultArtifactId = archetype.artifactId + \"-example\";\n        String defaultVersion = \"1.0-SNAPSHOT\";\n\n        System.out.println(\"----- Configure archetype -----\");\n        String groupId = ShellUtils.readLine(session, String.format(\"Define value for property 'groupId' (%s): \", defaultGroupId), false);\n        String artifactId = ShellUtils.readLine(session, String.format(\"Define value for property 'artifactId' (%s): \", defaultArtifactId), false);\n        String version = ShellUtils.readLine(session,  String.format(\"Define value for property 'version' (%s): \", defaultVersion), false);\n\n        groupId = isNullOrBlank(groupId) ? defaultGroupId : groupId;\n        artifactId = isNullOrBlank(artifactId) ? defaultArtifactId : artifactId;\n        version = isNullOrBlank(version) ? defaultVersion : version;\n\n        String defaultPackageName = (groupId + \".\" + artifactId).replaceAll(\"-\", \".\");\n        String packageName = ShellUtils.readLine(session, String.format(\"Define value for property 'package' (%s): \", defaultPackageName), false);\n        // use artifact id as default directory name (maven does this also)\n        String defaultDirectoryName = isNullOrBlank(artifactId) ? defaultArtifactId : artifactId;\n        directory = ShellUtils.readLine(session, String.format(\"Define value for property 'directoryName' (%s): \", defaultDirectoryName), false);\n\n        packageName = isNullOrBlank(packageName) ? defaultPackageName : packageName;\n        directory = isNullOrBlank(directory) ? artifactId : directory;\n\n        File childDir = new File(target, directory);\n\n        ArchetypeHelper helper = new ArchetypeHelper(archetypeFile, childDir, groupId, artifactId, version);\n        helper.setPackageName(packageName);\n\n        Map<String, String> properties = helper.parseProperties();\n\n        // if we have fabric8.profile as a property then lets configured it now, as its mandatory\n        // and use artifactId as its default suggested value\n        String profile = null;\n        if (properties.containsKey(\"fabric8.profile\")) {\n            profile = properties.remove(\"fabric8.profile\");\n            String defaultProfile = isNullOrBlank(profile) ? artifactId : profile;\n            String p = ShellUtils.readLine(session, String.format(\"Define value for property 'fabric8.profile' (%s): \", defaultProfile), false);\n            profile = isNullOrBlank(p) ? defaultProfile : p;\n        }\n\n        // show additional properties and ask to use them as-is\n        boolean mustChoose = false;\n        if (!properties.isEmpty()) {\n\n            // check if we must choose if there is an empty value or a value that has a ${ } token so we dont have a default value\n            for (String value : properties.values()) {\n                if (isNullOrBlank(value) || value.contains(\"$\")) {\n                    mustChoose = true;\n                    break;\n                }\n            }\n\n            if (!mustChoose) {\n                System.out.println(\"----- Additional properties -----\");\n                for (String key : properties.keySet()) {\n                    System.out.println(String.format(\"Using property '%s' (%s): \", key, properties.get(key)));\n                }\n            }\n\n            boolean choosing = true;\n            while (mustChoose || choosing) {\n\n                String confirm = null;\n                if (!mustChoose) {\n                    confirm = ShellUtils.readLine(session, \"Confirm additional properties configuration: (Y): \", false);\n                    confirm = isNullOrBlank(confirm) ? \"Y\" : confirm;\n                }\n\n                if (mustChoose || !\"Y\".equalsIgnoreCase(confirm)) {\n                    // ask for replacement properties suggesting the defaults\n                    if (!properties.isEmpty()) {\n                        System.out.println(\"----- Configure additional properties -----\");\n                        for (String key : properties.keySet()) {\n                            String value = properties.get(key);\n                            // if the value is empty or a token, then do not show any default value\n                            if (isNullOrBlank(value) || value.contains(\"$\")) {\n                                value = \"\";\n                            }\n                            String p = ShellUtils.readLine(session, String.format(\"Define value for property '%s' (%s): \", key, value), false);\n                            p = isNullOrBlank(p) ? value : p;\n                            properties.put(key, p);\n                        }\n                    }\n                    mustChoose = false;\n                } else {\n                    choosing = false;\n                }\n            }\n        }\n\n        // remover to include the profile back into properties\n        if (profile != null) {\n            properties.put(\"fabric8.profile\", profile);\n        }\n\n        if (!properties.isEmpty()) {\n            // set override properties\n            helper.setOverrideProperties(properties);\n        }\n\n        String confirm = ShellUtils.readLine(session, \"Create project: (Y): \", false);\n        confirm = confirm == null || confirm.trim().equals(\"\") ? \"Y\" : confirm;\n\n        if (\"Y\".equalsIgnoreCase(confirm)) {\n            System.out.println(\"----------------------------------------------------------------------------\");\n            System.out.println(String.format(\"Creating project in directory: %s\", childDir.getCanonicalPath()));\n            helper.execute();\n            System.out.println(\"Project created successfully\");\n            System.out.println(\"\");\n        } else {\n            System.out.println(\"----------------------------------------------------------------------------\");\n            System.out.println(\"Creating project aborted!\");\n            System.out.println(\"\");\n        }\n        return null;\n    }","commit_id":"a7f878f4cbff28b5d63ff57dd6e0084ffcce1e77","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void shouldAcceptJsonAndStreamingFlagAndProduceStreamedJson()\n    {\n        // given\n        theStartNode = createLinkedList( SHORT_LIST_LENGTH, server.getDatabase() );\n\n        // when\n        JaxRsResponse pagedTraverserResponse = createStreamingPagedTraverserWithTimeoutInMinutesAndPageSize( 60, 1 );\n\n        // then\n        assertNotNull( pagedTraverserResponse.getHeaders().getFirst( \"Content-Type\" ) );\n        assertEquals( \"application/json; stream=true\", pagedTraverserResponse.getHeaders().getFirst( \"Content-Type\" ) );\n    }","id":51682,"modified_method":"@Test\n    public void shouldAcceptJsonAndStreamingFlagAndProduceStreamedJson()\n    {\n        // given\n        theStartNode = createLinkedList( SHORT_LIST_LENGTH, server.getDatabase() );\n\n        // when\n        JaxRsResponse pagedTraverserResponse = createStreamingPagedTraverserWithTimeoutInMinutesAndPageSize( 60, 1 );\n\n\n        System.out.println(pagedTraverserResponse.getHeaders().getFirst( \"Content-Type\" ));\n\n        // then\n        assertNotNull( pagedTraverserResponse.getHeaders().getFirst( \"Content-Type\" ) );\n        assertThat( pagedTraverserResponse.getHeaders().getFirst( \"Content-Type\" ),\n                containsString( \"application/json; charset=UTF-8; stream=true\" ) );\n    }","commit_id":"c3cd4ddba50d1362d9e2e6edb66402cfbeafc613","url":"https://github.com/neo4j/neo4j"},{"original_method":"public GetAssetViaRepositoryTest(org.osid.repository.RepositoryManager repositoryManager, org.w3c.dom.Document document)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// are their assets to test for?\n\t\torg.w3c.dom.NodeList repositoriesNodeList = document.getElementsByTagName(OsidTester.ASSET_VIA_REPOSITORY_TAG);\n\t\tint numRepositories = repositoriesNodeList.getLength();\n\t\tfor (int i=0; i < numRepositories; i++) {\n\t\t\torg.w3c.dom.Element repositoryElement = (org.w3c.dom.Element)repositoriesNodeList.item(i);\n\t\t\tString repositoryIdString = repositoryElement.getAttribute(OsidTester.REPOSITORY_ID_ATTR);\n\t\t\tString assetIdString = repositoryElement.getAttribute(OsidTester.ASSET_ID_ATTR);\n\t\t\tif ( (repositoryIdString != null) && (assetIdString != null) ) {\n\t\t\t\ttry {\n\t\t\t\t\torg.osid.shared.Id repositoryId = Utilities.getIdManager().getId(repositoryIdString);\n\t\t\t\t\torg.osid.shared.Id assetId = Utilities.getIdManager().getId(assetIdString);\n\t\t\t\t\torg.osid.repository.Asset asset = repositoryManager.getRepository(repositoryId).getAsset(assetId);\n\t\t\t\t\tSystem.out.println(\"PASSED: Asset By Id Via Repository \" + repositoryIdString + \" \" + assetIdString);\n\t\t\t\t\t\n\t\t\t\t\t// check asset metadata, if specified\n\t\t\t\t\tAssetMetadataTest amt = new AssetMetadataTest(asset,repositoryElement,\"\");\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\tfail(\"No Repository with the ID \" + repositoryIdString + \" or no Asset with ID \" + assetIdString + \" or ID Manager Failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":51683,"modified_method":"public GetAssetViaRepositoryTest(org.osid.repository.RepositoryManager repositoryManager, org.w3c.dom.Document document)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// are their assets to test for?\n\t\torg.w3c.dom.NodeList repositoriesNodeList = document.getElementsByTagName(OsidTester.ASSET_VIA_REPOSITORY_TAG);\n\t\tint numRepositories = repositoriesNodeList.getLength();\n\t\tfor (int i=0; i < numRepositories; i++) {\n\t\t\torg.w3c.dom.Element repositoryElement = (org.w3c.dom.Element)repositoriesNodeList.item(i);\n\t\t\tString repositoryIdString = repositoryElement.getAttribute(OsidTester.REPOSITORY_ID_ATTR);\n\t\t\tString assetIdString = repositoryElement.getAttribute(OsidTester.ASSET_ID_ATTR);\n\t\t\tif ( (repositoryIdString != null) && (assetIdString != null) ) {\n\t\t\t\ttry {\n\t\t\t\t\torg.osid.shared.Id repositoryId = Utilities.getIdManager().getId(repositoryIdString);\n\t\t\t\t\torg.osid.shared.Id assetId = Utilities.getIdManager().getId(assetIdString);\n\t\t\t\t\torg.osid.repository.Asset asset = repositoryManager.getRepository(repositoryId).getAsset(assetId);\n\t\t\t\t\tSystem.out.println(\"PASSED: Asset By Id Via Repository \" + repositoryIdString + \" \" + assetIdString);\n\t\t\t\t\t\n\t\t\t\t\t// check asset metadata, if specified\n\t\t\t\t\tAssetMetadataTest amt = new AssetMetadataTest(asset,repositoryElement,\"\");\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tif (Utilities.isVerbose()) t.printStackTrace();\n\t\t\t\t\tfail(\"No Repository with the ID \" + repositoryIdString + \" or no Asset with ID \" + assetIdString + \" or ID Manager Failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"50f678c88e34d49aae7854aef36f02a904d63cb3","url":"https://github.com/VUE/VUE"},{"original_method":"public GetRepositoryTest(org.osid.repository.RepositoryManager repositoryManager, org.w3c.dom.Document document)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// are there repositories to test for?\n\t\torg.w3c.dom.NodeList repositoriesNodeList = document.getElementsByTagName(OsidTester.REPOSITORY_BY_ID_TAG);\n\t\tint numRepositories = repositoriesNodeList.getLength();\n\t\tfor (int i=0; i < numRepositories; i++) {\n\t\t\torg.w3c.dom.Element repositoryElement = (org.w3c.dom.Element)repositoriesNodeList.item(i);\n\t\t\tString idString = repositoryElement.getAttribute(OsidTester.ID_ATTR);\n\t\t\tif (idString != null) {\n\t\t\t\ttry {\n\t\t\t\t\torg.osid.shared.Id id = Utilities.getIdManager().getId(idString);\n\t\t\t\t\torg.osid.repository.Repository repository = repositoryManager.getRepository(id);\n\t\t\t\t\tSystem.out.println(\"PASSED: Repository By Id \" + idString);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tfail(\"ID Manager Failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":51684,"modified_method":"public GetRepositoryTest(org.osid.repository.RepositoryManager repositoryManager, org.w3c.dom.Document document)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// are there repositories to test for?\n\t\torg.w3c.dom.NodeList repositoriesNodeList = document.getElementsByTagName(OsidTester.REPOSITORY_BY_ID_TAG);\n\t\tint numRepositories = repositoriesNodeList.getLength();\n\t\tfor (int i=0; i < numRepositories; i++) {\n\t\t\torg.w3c.dom.Element repositoryElement = (org.w3c.dom.Element)repositoriesNodeList.item(i);\n\t\t\tString idString = repositoryElement.getAttribute(OsidTester.ID_ATTR);\n\t\t\tif (idString != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (Utilities.isVerbose()) System.out.println(\"Looking for a repository with id \" + idString);\n\t\t\t\t\torg.osid.shared.Id id = Utilities.getIdManager().getId(idString);\n\t\t\t\t\torg.osid.repository.Repository repository = repositoryManager.getRepository(id);\n\t\t\t\t\tSystem.out.println(\"PASSED: Repository By Id \" + idString);\n\t\t\t\t\t\n\t\t\t\t\t// test metadata, if present\n\t\t\t\t\tRepositoryMetadataTest rmt = new RepositoryMetadataTest(repository,repositoryElement);\n\t\t\t\t} catch (org.osid.repository.RepositoryException rex) {\n\t\t\t\t\tif (Utilities.isVerbose()) rex.printStackTrace();\n\t\t\t\t\tfail(\"No Repository with the ID \" + idString);\n\t\t\t\t} catch (org.osid.id.IdException iex) {\n\t\t\t\t\tif (Utilities.isVerbose()) iex.printStackTrace();\n\t\t\t\t\tfail(\"ID Manager Failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"50f678c88e34d49aae7854aef36f02a904d63cb3","url":"https://github.com/VUE/VUE"},{"original_method":"public RepositoryMetadataTest(org.osid.repository.Repository repository, org.w3c.dom.Element repositoryElement)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// check which attributes to test\n\t\tString expected = Utilities.expectedValue(repositoryElement,DISPLAY_NAME_TAG);\n\t\tif (expected != null) {\n\t\t\tassertEquals(expected,repository.getDisplayName());\n\t\t\tSystem.out.println(\"PASSED: Repository Display Name \" + expected);\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,DESCRIPTION_TAG);\n\t\tif (expected != null) {\n\t\t\tassertEquals(expected,repository.getDescription());\n\t\t\tSystem.out.println(\"PASSED: Repository Description \" + expected);\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,ID_TAG);\n\t\tif (expected != null) {\n\t\t\torg.osid.shared.Id id = repository.getId();\n\t\t\ttry {\n\t\t\t\tString idString = id.getIdString();\n\t\t\t\tassertEquals(expected,idString);\n\t\t\t\tSystem.out.println(\"PASSED: Repository Id \" + expected);\n\t\t\t} catch (org.osid.shared.SharedException iex) {\n\t\t\t\t// ignore since this means something is amiss with Id\n\t\t\t}\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,TYPE_TAG);\n\t\tif (expected != null) {\n\t\t\tassertEquals(expected,Utilities.typeToString(repository.getType()));\n\t\t\tSystem.out.println(\"PASSED: Repository Type \" + expected);\n\t\t}\n\t}","id":51685,"modified_method":"public RepositoryMetadataTest(org.osid.repository.Repository repository, org.w3c.dom.Element repositoryElement)\n\t\tthrows org.osid.repository.RepositoryException, org.xml.sax.SAXParseException\n\t{\n\t\t// check which attributes to test\n\t\tString expected = Utilities.expectedValue(repositoryElement,OsidTester.DISPLAY_NAME_TAG);\n\t\tif (expected != null) {\n\t\t\tif (Utilities.isVerbose()) System.out.println(\"Found display name \" + repository.getDisplayName());\n\t\t\tassertEquals(\"seeking display name \" + expected,expected,repository.getDisplayName());\n\t\t\tSystem.out.println(\"PASSED: Repository Display Name \" + expected);\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,OsidTester.DESCRIPTION_TAG);\n\t\tif (expected != null) {\n\t\t\tif (Utilities.isVerbose()) System.out.println(\"Found description \" + repository.getDescription());\n\t\t\tassertEquals(\"seeking description \" + expected,expected,repository.getDescription());\n\t\t\tSystem.out.println(\"PASSED: Repository Description \" + expected);\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,OsidTester.ID_TAG);\n\t\tif (expected != null) {\n\t\t\torg.osid.shared.Id id = repository.getId();\n\t\t\ttry {\n\t\t\t\tString idString = id.getIdString();\n\t\t\t\tif (Utilities.isVerbose()) System.out.println(\"Found id \" + idString);\n\t\t\t\tassertEquals(\"seeking id \" + expected,expected,idString);\n\t\t\t\tSystem.out.println(\"PASSED: Repository Id \" + expected);\n\t\t\t} catch (org.osid.shared.SharedException iex) {\n\t\t\t\t// ignore since this means something is amiss with Id\n\t\t\t}\n\t\t}\n\t\t\n\t\texpected = Utilities.expectedValue(repositoryElement,OsidTester.TYPE_TAG);\n\t\tif (expected != null) {\n\t\t\tif (Utilities.isVerbose()) System.out.println(\"Found type \" + Utilities.typeToString(repository.getType()));\n\t\t\tassertEquals(\"seeking repository type \" + expected,expected,Utilities.typeToString(repository.getType()));\n\t\t\tSystem.out.println(\"PASSED: Repository Type \" + expected);\n\t\t}\n\t}","commit_id":"50f678c88e34d49aae7854aef36f02a904d63cb3","url":"https://github.com/VUE/VUE"},{"original_method":"public static void deleteVocabularies(HttpPrincipal httpPrincipal,\n\t\tlong[] vocabularyIds)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(AssetVocabularyServiceUtil.class,\n\t\t\t\t\t\"deleteVocabularies\", _deleteVocabulariesParameterTypes3);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tvocabularyIds);\n\n\t\t\ttry {\n\t\t\t\tTunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","id":51686,"modified_method":"public static java.util.List<com.liferay.portlet.asset.model.AssetVocabulary> deleteVocabularies(\n\t\tHttpPrincipal httpPrincipal, long[] vocabularyIds,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(AssetVocabularyServiceUtil.class,\n\t\t\t\t\t\"deleteVocabularies\", _deleteVocabulariesParameterTypes3);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tvocabularyIds, serviceContext);\n\n\t\t\tObject returnObj = null;\n\n\t\t\ttry {\n\t\t\t\treturnObj = TunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\n\t\t\treturn (java.util.List<com.liferay.portlet.asset.model.AssetVocabulary>)returnObj;\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","commit_id":"a151d0556b44a59c7ca57221bb16ee2b261059a7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static XmlConfigurator parse(InputStream stream) throws java.io.IOException {\n        /**\n         * CAUTION: crappy code ahead ! I (bela) am not an XML expert, so the\n         * code below is pretty amateurish... But it seems to work, and it is\n         * executed only on startup, so no perf loss on the critical path. If\n         * somebody wants to improve this, please be my guest.\n         */\n        try {\n            DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n            factory.setValidating(false); //for now\n            DocumentBuilder builder=factory.newDocumentBuilder();\n            Document document=builder.parse(stream);\n\n            // The root element of the document should be the \"config\" element,\n            // but the parser(Element) method checks this so a check is not\n            // needed here.\n            Element configElement=document.getDocumentElement();\n            return parse(configElement);\n        }\n        catch(Exception x) {\n            if(x instanceof java.io.IOException)\n                throw (java.io.IOException)x;\n            else {\n                IOException tmp=new IOException();\n                tmp.initCause(x);\n                throw tmp;\n            }\n        }\n    }","id":51687,"modified_method":"protected static XmlConfigurator parse(InputStream stream) throws java.io.IOException {\n        /**\n         * CAUTION: crappy code ahead ! I (bela) am not an XML expert, so the code below is pretty\n         * amateurish... But it seems to work, and it is executed only on startup, so no perf loss\n         * on the critical path. If somebody wants to improve this, please be my guest.\n         */\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            boolean validation = false;\n            try {\n                String tmp = Util.getProperty(new String[] { Global.XML_VALIDATION }, null, null, false, \"false\");\n                validation = Boolean.valueOf(tmp).booleanValue();\n            } catch (Exception e) {\n                validation = false;\n            }\n            if (validation) {\n                factory.setValidating(true); \n                factory.setNamespaceAware(validation);\n                factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n            } else {\n                factory.setValidating(false);\n            }\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(stream);\n\n            // The root element of the document should be the \"config\" element,\n            // but the parser(Element) method checks this so a check is not\n            // needed here.\n            Element configElement = document.getDocumentElement();\n            return parse(configElement);\n        } catch (Exception x) {\n            if (x instanceof java.io.IOException)\n                throw (java.io.IOException) x;\n            else {\n                IOException tmp = new IOException();\n                tmp.initCause(x);\n                throw tmp;\n            }\n        }\n    }","commit_id":"628a1627442d84f21f8153487f27add0685cfe2f","url":"https://github.com/belaban/JGroups"},{"original_method":"private static SAXParser newSAXParser(URL schema, InputStream schemaStream)\n                throws ParserConfigurationException, SAXException {\n            if (schema == null) {\n                return newNonValidatingSAXParser();\n            }\n            try {\n                SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setNamespaceAware(true);\n                parserFactory.setValidating(true);\n                SAXParser parser = parserFactory.newSAXParser();\n                parser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n                parser.setProperty(JAXP_SCHEMA_SOURCE, schemaStream);\n                parser.getXMLReader().setFeature(XML_NAMESPACE_PREFIXES, true);\n                return parser;\n            } catch (SAXNotRecognizedException ex) {\n                System.err.println(\n                        \"WARNING: problem while setting JAXP validating property on SAXParser... \"\n                                + \"XML validation will not be done: \" + ex.getMessage());\n                return newNonValidatingSAXParser();\n            }\n        }","id":51688,"modified_method":"private static SAXParser newSAXParser(URL schema, InputStream schemaStream)\n                throws ParserConfigurationException, SAXException {\n            if (schema == null) {\n                SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setValidating(false);\n                parserFactory.setNamespaceAware(true);\n                SAXParser parser = parserFactory.newSAXParser();\n                parser.getXMLReader().setFeature(XML_NAMESPACE_PREFIXES, true);\n                return parser;\n            } else {\n                SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setValidating(true);\n                parserFactory.setNamespaceAware(true);\n\n                SAXParser parser = parserFactory.newSAXParser();\n                parser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n                parser.setProperty(JAXP_SCHEMA_SOURCE, schemaStream);\n                parser.getXMLReader().setFeature(XML_NAMESPACE_PREFIXES, true);\n                return parser;\n            }\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"public static void parse(\n                InputSource xmlStream, URL schema, DefaultHandler handler, LexicalHandler lHandler)\n                throws SAXException, IOException, ParserConfigurationException {\n            InputStream schemaStream = null;\n            try {\n                if (schema != null) {\n                    schemaStream = URLHandlerRegistry.getDefault().openStream(schema);\n                }\n                SAXParser parser = newSAXParser(schema, schemaStream);\n\n                if (lHandler != null) {\n                    try {\n                        parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", lHandler);\n                    } catch (SAXException ex) {\n                        System.err.println(\n                                \"WARNING: problem while setting the lexical handler property on SAXParser: \"\n                                        + ex.getMessage());\n                        // continue without the lexical handler\n                    }\n                }\n\n                parser.parse(xmlStream, handler);\n            } finally {\n                if (schemaStream != null) {\n                    try {\n                        schemaStream.close();\n                    } catch (IOException ex) {\n                        // ignored\n                    }\n                }\n            }\n        }","id":51689,"modified_method":"public static void parse(\n                InputSource xmlStream, URL schema, DefaultHandler handler)\n                throws SAXException, IOException, ParserConfigurationException {\n            InputStream schemaStream = null;\n            try {\n                if (schema != null) {\n                    schemaStream = URLHandlerRegistry.getDefault().openStream(schema);\n                }\n                SAXParser parser = newSAXParser(schema, schemaStream);\n                parser.parse(xmlStream, handler);\n            } finally {\n                if (schemaStream != null) {\n                    try {\n                        schemaStream.close();\n                    } catch (IOException ex) {\n                        // ignored\n                    }\n                }\n            }\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"public void parse() throws ParseException, IOException {\n            getResource().withContent(new Action<InputStream>() {\n                public void execute(InputStream inputStream) {\n                    URL schemaURL = validate ? getSchemaURL() : null;\n                    InputSource inSrc = new InputSource(inputStream);\n                    inSrc.setSystemId(descriptorURL.toExternalForm());\n                    try {\n                        ParserHelper.parse(inSrc, schemaURL, Parser.this, null);\n                    } catch (Exception e) {\n                        throw new MetaDataParseException(\"Ivy file\", getResource(), e);\n                    }\n                }\n            });\n            checkErrors();\n            checkConfigurations();\n            replaceConfigurationWildcards();\n            if (!artifactsDeclared) {\n                String[] configurationNames = getMd().getConfigurationsNames();\n                IvyMDArtifact implicitArtifact = new IvyMDArtifact(getMd(), getMd().getModuleRevisionId().getName(), \"jar\", \"jar\");\n                for (String configurationName : configurationNames) {\n                    implicitArtifact.addConfiguration(configurationName);\n                }\n                metaData.addArtifact(implicitArtifact);\n            }\n            checkErrors();\n            getMd().check();\n        }","id":51690,"modified_method":"public void parse() throws ParseException, IOException {\n            getResource().withContent(new Action<InputStream>() {\n                public void execute(InputStream inputStream) {\n                    URL schemaURL = validate ? getSchemaURL() : null;\n                    InputSource inSrc = new InputSource(inputStream);\n                    inSrc.setSystemId(descriptorURL.toExternalForm());\n                    try {\n                        ParserHelper.parse(inSrc, schemaURL, Parser.this);\n                    } catch (Exception e) {\n                        throw new MetaDataParseException(\"Ivy file\", getResource(), e);\n                    }\n                }\n            });\n            checkErrors();\n            checkConfigurations();\n            replaceConfigurationWildcards();\n            if (!artifactsDeclared) {\n                String[] configurationNames = getMd().getConfigurationsNames();\n                IvyMDArtifact implicitArtifact = new IvyMDArtifact(getMd(), getMd().getModuleRevisionId().getName(), \"jar\", \"jar\");\n                for (String configurationName : configurationNames) {\n                    implicitArtifact.addConfiguration(configurationName);\n                }\n                metaData.addArtifact(implicitArtifact);\n            }\n            checkErrors();\n            getMd().check();\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"public static void parse(\n                URL xmlURL, URL schema, DefaultHandler handler, LexicalHandler lHandler)\n                throws SAXException, IOException, ParserConfigurationException {\n            InputStream xmlStream = URLHandlerRegistry.getDefault().openStream(xmlURL);\n            try {\n                InputSource inSrc = new InputSource(xmlStream);\n                inSrc.setSystemId(xmlURL.toExternalForm());\n                parse(inSrc, schema, handler, lHandler);\n            } finally {\n                try {\n                    xmlStream.close();\n                } catch (IOException e) {\n                    // ignored\n                }\n            }\n        }","id":51691,"modified_method":"public static void parse(\n                URL xmlURL, URL schema, DefaultHandler handler)\n                throws SAXException, IOException, ParserConfigurationException {\n            InputStream xmlStream = URLHandlerRegistry.getDefault().openStream(xmlURL);\n            try {\n                InputSource inSrc = new InputSource(xmlStream);\n                inSrc.setSystemId(xmlURL.toExternalForm());\n                parse(inSrc, schema, handler);\n            } finally {\n                try {\n                    xmlStream.close();\n                } catch (IOException e) {\n                    // ignored\n                }\n            }\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"private void includeConfStarted(Attributes attributes)\n                throws SAXException, IOException, ParserConfigurationException, ParseException {\n            URL url = relativeUrlResolver.getURL(descriptorURL, substitute(attributes.getValue(\"file\")), substitute(attributes.getValue(\"url\")));\n            if (url == null) {\n                throw new SAXException(\"include tag must have a file or an url attribute\");\n            }\n\n            // create a new temporary parser to read the configurations from\n            // the specified file.\n            Parser parser = newParser(new UrlExternalResource(url), url);\n            ParserHelper.parse(url , null, parser, null);\n\n            // add the configurations from this temporary parser to this module descriptor\n            Configuration[] configs = parser.getModuleDescriptor().getConfigurations();\n            for (Configuration config : configs) {\n                getMd().addConfiguration(config);\n            }\n            if (parser.getDefaultConfMapping() != null) {\n                LOGGER.debug(\"setting default conf mapping from imported configurations file: \" + parser.getDefaultConfMapping());\n                setDefaultConfMapping(parser.getDefaultConfMapping());\n            }\n            if (parser.getDefaultConf() != null) {\n                LOGGER.debug(\"setting default conf from imported configurations file: \" + parser.getDefaultConf());\n                setDefaultConf(parser.getDefaultConf());\n            }\n            if (parser.getMd().isMappingOverride()) {\n                LOGGER.debug(\"enabling mapping-override from imported configurations file\");\n                getMd().setMappingOverride(true);\n            }\n        }","id":51692,"modified_method":"private void includeConfStarted(Attributes attributes)\n                throws SAXException, IOException, ParserConfigurationException, ParseException {\n            URL url = relativeUrlResolver.getURL(descriptorURL, substitute(attributes.getValue(\"file\")), substitute(attributes.getValue(\"url\")));\n            if (url == null) {\n                throw new SAXException(\"include tag must have a file or an url attribute\");\n            }\n\n            // create a new temporary parser to read the configurations from\n            // the specified file.\n            Parser parser = newParser(new UrlExternalResource(url), url);\n            ParserHelper.parse(url , null, parser);\n\n            // add the configurations from this temporary parser to this module descriptor\n            Configuration[] configs = parser.getModuleDescriptor().getConfigurations();\n            for (Configuration config : configs) {\n                getMd().addConfiguration(config);\n            }\n            if (parser.getDefaultConfMapping() != null) {\n                LOGGER.debug(\"setting default conf mapping from imported configurations file: \" + parser.getDefaultConfMapping());\n                setDefaultConfMapping(parser.getDefaultConfMapping());\n            }\n            if (parser.getDefaultConf() != null) {\n                LOGGER.debug(\"setting default conf from imported configurations file: \" + parser.getDefaultConf());\n                setDefaultConf(parser.getDefaultConf());\n            }\n            if (parser.getMd().isMappingOverride()) {\n                LOGGER.debug(\"enabling mapping-override from imported configurations file\");\n                getMd().setMappingOverride(true);\n            }\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"private String substitute(String name) {\n            return IvyPatternHelper.substituteVariables(name, properties);\n        }","id":51693,"modified_method":"private String substitute(String value) {\n            return IvyPatternHelper.substituteVariables(value, properties);\n        }","commit_id":"3876883185979f00389c5877491b0101729bc424","url":"https://github.com/gradle/gradle"},{"original_method":"protected static XmlConfigurator parse(InputStream stream) throws java.io.IOException {\n        /**\n         * CAUTION: crappy code ahead ! I (bela) am not an XML expert, so the\n         * code below is pretty amateurish... But it seems to work, and it is\n         * executed only on startup, so no perf loss on the critical path. If\n         * somebody wants to improve this, please be my guest.\n         */\n        try {\n            DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n            factory.setValidating(false); //for now\n            DocumentBuilder builder=factory.newDocumentBuilder();\n            Document document=builder.parse(stream);\n\n            // The root element of the document should be the \"config\" element,\n            // but the parser(Element) method checks this so a check is not\n            // needed here.\n            Element configElement=document.getDocumentElement();\n            return parse(configElement);\n        }\n        catch(Exception x) {\n            if(x instanceof java.io.IOException)\n                throw (java.io.IOException)x;\n            else {\n                IOException tmp=new IOException();\n                tmp.initCause(x);\n                throw tmp;\n            }\n        }\n    }","id":51694,"modified_method":"protected static XmlConfigurator parse(InputStream stream) throws java.io.IOException {\n        /**\n         * CAUTION: crappy code ahead ! I (bela) am not an XML expert, so the code below is pretty\n         * amateurish... But it seems to work, and it is executed only on startup, so no perf loss\n         * on the critical path. If somebody wants to improve this, please be my guest.\n         */\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            boolean validation = false;\n            try {\n                String tmp = Util.getProperty(new String[] { Global.XML_VALIDATION }, null, null, false, \"false\");\n                validation = Boolean.valueOf(tmp).booleanValue();\n            } catch (Exception e) {\n                validation = false;\n            }\n            if (validation) {\n                factory.setValidating(true); \n                factory.setNamespaceAware(validation);\n                factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n            } else {\n                factory.setValidating(false);\n            }\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(stream);\n\n            // The root element of the document should be the \"config\" element,\n            // but the parser(Element) method checks this so a check is not\n            // needed here.\n            Element configElement = document.getDocumentElement();\n            return parse(configElement);\n        } catch (Exception x) {\n            if (x instanceof java.io.IOException)\n                throw (java.io.IOException) x;\n            else {\n                IOException tmp = new IOException();\n                tmp.initCause(x);\n                throw tmp;\n            }\n        }\n    }","commit_id":"3276f451dc2b1743a435f76e88790417a57bcd67","url":"https://github.com/belaban/JGroups"},{"original_method":"public Result preprocessEnter(@NotNull PsiFile file,\n                                @NotNull Editor editor,\n                                @NotNull Ref<Integer> caretOffset,\n                                @NotNull Ref<Integer> caretAdvance,\n                                @NotNull DataContext dataContext,\n                                EditorActionHandler originalHandler) {\n    String text = editor.getDocument().getText();\n    if (StringUtil.isEmpty(text)) {\n      return Result.Continue;\n    }\n\n    if (!(file instanceof GroovyFileBase)) {\n      return Result.Continue;\n    }\n\n    final int caret = editor.getCaretModel().getOffset();\n    final EditorHighlighter highlighter = ((EditorEx)editor).getHighlighter();\n    if (caret >= 1 && caret < text.length() && CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {\n      HighlighterIterator iterator = highlighter.createIterator(caret);\n      iterator.retreat();\n      while (!iterator.atEnd() && TokenType.WHITE_SPACE == iterator.getTokenType()) {\n        iterator.retreat();\n      }\n      boolean afterArrow = !iterator.atEnd() && iterator.getTokenType() == mCLOSABLE_BLOCK_OP;\n      if (afterArrow) {\n        originalHandler.execute(editor, dataContext);\n        PsiDocumentManager.getInstance(file.getProject()).commitDocument(editor.getDocument());\n        CodeStyleManager.getInstance(file.getProject()).adjustLineIndent(file, editor.getCaretModel().getOffset());\n      }\n\n      iterator = highlighter.createIterator(editor.getCaretModel().getOffset());\n      while (!iterator.atEnd() && TokenType.WHITE_SPACE == iterator.getTokenType()) {\n        iterator.advance();\n      }\n      if (!iterator.atEnd() && mRCURLY == iterator.getTokenType()) {\n        PsiDocumentManager.getInstance(file.getProject()).commitDocument(editor.getDocument());\n        final PsiElement element = file.findElementAt(iterator.getStart());\n        if (element != null &&\n            element.getNode().getElementType() == mRCURLY &&\n            element.getParent() instanceof GrClosableBlock &&\n            text.length() > caret && afterArrow) {\n          return Result.DefaultForceIndent;\n        }\n      }\n      if (afterArrow) {\n        return Result.Stop;\n      }\n\n      if (editor.isInsertMode() &&\n          !HandlerUtils.isReadOnly(editor) &&\n          !editor.getSelectionModel().hasSelection() &&\n          handleFlyingGeese(editor, caret, dataContext, originalHandler, file)) {\n        return Result.DefaultForceIndent;\n      }\n    }\n\n    if (handleEnter(editor, dataContext, file.getProject(), originalHandler)) {\n      return Result.Stop;\n    }\n    return Result.Continue;\n  }","id":51695,"modified_method":"public Result preprocessEnter(@NotNull PsiFile file,\n                                @NotNull Editor editor,\n                                @NotNull Ref<Integer> caretOffset,\n                                @NotNull Ref<Integer> caretAdvance,\n                                @NotNull DataContext dataContext,\n                                EditorActionHandler originalHandler) {\n    Document document = editor.getDocument();\n    Project project = file.getProject();\n    CaretModel caretModel = editor.getCaretModel();\n\n    String text = document.getText();\n    if (StringUtil.isEmpty(text)) {\n      return Result.Continue;\n    }\n\n    if (!(file instanceof GroovyFileBase)) {\n      return Result.Continue;\n    }\n\n    final int caret = caretModel.getOffset();\n    final EditorHighlighter highlighter = ((EditorEx)editor).getHighlighter();\n    if (caret >= 1 && caret < text.length() && CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {\n      HighlighterIterator iterator = highlighter.createIterator(caret);\n      iterator.retreat();\n      while (!iterator.atEnd() && TokenType.WHITE_SPACE == iterator.getTokenType()) {\n        iterator.retreat();\n      }\n      boolean afterArrow = !iterator.atEnd() && iterator.getTokenType() == mCLOSABLE_BLOCK_OP;\n      if (afterArrow) {\n        originalHandler.execute(editor, dataContext);\n        PsiDocumentManager.getInstance(project).commitDocument(document);\n        CodeStyleManager.getInstance(project).adjustLineIndent(file, caretModel.getOffset());\n      }\n\n      iterator = highlighter.createIterator(caretModel.getOffset());\n      while (!iterator.atEnd() && TokenType.WHITE_SPACE == iterator.getTokenType()) {\n        iterator.advance();\n      }\n      if (!iterator.atEnd() && mRCURLY == iterator.getTokenType()) {\n        PsiDocumentManager.getInstance(project).commitDocument(document);\n        final PsiElement element = file.findElementAt(iterator.getStart());\n        if (element != null &&\n            element.getNode().getElementType() == mRCURLY &&\n            element.getParent() instanceof GrClosableBlock &&\n            text.length() > caret && afterArrow) {\n          return Result.DefaultForceIndent;\n        }\n      }\n      if (afterArrow) {\n        return Result.Stop;\n      }\n\n      if (editor.isInsertMode() &&\n          !HandlerUtils.isReadOnly(editor) &&\n          !editor.getSelectionModel().hasSelection() &&\n          handleFlyingGeese(editor, caret, dataContext, originalHandler, file)) {\n        return Result.DefaultForceIndent;\n      }\n    }\n\n    if (handleEnter(editor, dataContext, project, originalHandler)) return Result.Stop;\n    return Result.Continue;\n  }","commit_id":"c649a54f2277ce6a56b4f8824f0b67494f57a1fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean handleInString(Editor editor, int caretOffset, DataContext dataContext, EditorActionHandler originalHandler) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    final VirtualFile vfile = FileDocumentManager.getInstance().getFile(editor.getDocument());\n    assert vfile != null;\n    PsiFile file = PsiManager.getInstance(project).findFile(vfile);\n\n    Document document = editor.getDocument();\n    String fileText = document.getText();\n    if (fileText.length() == caretOffset) return false;\n\n    if (!checkStringApplicable(editor, caretOffset)) return false;\n    if (file == null) return false;\n\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiElement stringElement = file.findElementAt(caretOffset - 1);\n    if (stringElement == null) return false;\n    ASTNode node = stringElement.getNode();\n    if (node == null) return false;\n\n    // For expression injection in GString like \"abc ${}<caret>  abc\"\n    if (!INNER_STRING_TOKENS.contains(node.getElementType()) && checkGStringInjection(stringElement)) {\n      stringElement = stringElement.getParent().getParent().getNextSibling();\n      if (stringElement == null) return false;\n      node = stringElement.getNode();\n      if (node == null) return false;\n    }\n\n    boolean isInsertIndent = isInsertIndent(caretOffset, stringElement.getTextRange().getStartOffset(), fileText);\n\n    // For simple String literals like 'abcdef'\n    if (mSTRING_LITERAL == node.getElementType()) {\n      if (GroovyEditorActionUtil.isPlainStringLiteral(node)) {\n        TextRange literalRange = stringElement.getTextRange();\n\n        //the case of print '\\<caret>'\n        if (!isSlashBeforeCaret(caretOffset, fileText)) {\n          convertEndToMultiline(literalRange.getEndOffset(), document, fileText, '\\'');\n          document.insertString(literalRange.getStartOffset(), \"''\");\n          editor.getCaretModel().moveToOffset(caretOffset + 2);\n        }\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n      }\n      else {\n        insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      }\n      return true;\n    }\n\n    if (GSTRING_TOKENS.contains(node.getElementType()) ||\n        node.getElementType() == mDOLLAR && node.getTreeParent().getTreeParent().getElementType() == GSTRING) {\n      PsiElement parent = stringElement.getParent();\n      if (node.getElementType() == mGSTRING_LITERAL) {\n        parent = stringElement;\n      }\n      else {\n        while (parent != null && !(parent instanceof GrLiteral)) {\n          parent = parent.getParent();\n        }\n      }\n      if (parent == null) return false;\n      if (GroovyEditorActionUtil.isPlainGString(parent.getNode())) {\n        PsiElement exprSibling = stringElement.getNextSibling();\n        boolean rightFromDollar = exprSibling instanceof GrExpression && exprSibling.getTextRange().getStartOffset() == caretOffset;\n        if (rightFromDollar) caretOffset--;\n        TextRange parentRange = parent.getTextRange();\n        if (rightFromDollar || !isSlashBeforeCaret(caretOffset, fileText)) {\n          convertEndToMultiline(parent.getTextRange().getEndOffset(), document, fileText, '\"');\n          document.insertString(parentRange.getStartOffset(), \"\\\"\\\"\");\n          editor.getCaretModel().moveToOffset(caretOffset + 2);\n        }\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        if (rightFromDollar) {\n          editor.getCaretModel().moveCaretRelatively(1, 0, false, false, true);\n        }\n      }\n      else {\n        insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      }\n      return true;\n    }\n\n    if (REGEX_TOKENS.contains(node.getElementType()) ||\n        node.getElementType() == mDOLLAR && node.getTreeParent().getTreeParent().getElementType() == REGEX) {\n      PsiElement parent = stringElement.getParent();\n      if (node.getElementType() == mREGEX_LITERAL || node.getElementType() == mDOLLAR_SLASH_REGEX_LITERAL) {\n        parent = stringElement;\n      }\n      else {\n        while (parent != null && !(parent instanceof GrLiteral)) {\n          parent = parent.getParent();\n        }\n      }\n      if (parent == null || parent.getLastChild() instanceof PsiErrorElement) return false;\n      PsiElement exprSibling = stringElement.getNextSibling();\n      boolean rightFromDollar = exprSibling instanceof GrExpression && exprSibling.getTextRange().getStartOffset() == caretOffset;\n      if (rightFromDollar) {\n        editor.getCaretModel().moveToOffset(caretOffset - 1);\n      }\n      insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      if (rightFromDollar) {\n        editor.getCaretModel().moveCaretRelatively(1, 0, false, false, true);\n      }\n      return true;\n    }\n\n    return false;\n  }","id":51696,"modified_method":"private static boolean handleInString(Editor editor, int caretOffset, DataContext dataContext, EditorActionHandler originalHandler) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    final VirtualFile vfile = FileDocumentManager.getInstance().getFile(editor.getDocument());\n    assert vfile != null;\n    PsiFile file = PsiManager.getInstance(project).findFile(vfile);\n\n    Document document = editor.getDocument();\n    String fileText = document.getText();\n    if (fileText.length() == caretOffset) return false;\n\n    if (!checkStringApplicable(editor, caretOffset)) return false;\n    if (file == null) return false;\n\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiElement stringElement = file.findElementAt(caretOffset - 1);\n    if (stringElement == null) return false;\n    ASTNode node = stringElement.getNode();\n    if (node == null) return false;\n\n    // For expression injection in GString like \"abc ${}<caret>  abc\"\n    if (!INNER_STRING_TOKENS.contains(node.getElementType()) && checkGStringInjection(stringElement)) {\n      stringElement = stringElement.getParent().getParent().getNextSibling();\n      if (stringElement == null) return false;\n      node = stringElement.getNode();\n      if (node == null) return false;\n    }\n\n    boolean isInsertIndent = isInsertIndent(caretOffset, stringElement.getTextRange().getStartOffset(), fileText);\n\n    // For simple String literals like 'abcdef'\n    CaretModel caretModel = editor.getCaretModel();\n    if (mSTRING_LITERAL == node.getElementType()) {\n      if (GroovyEditorActionUtil.isPlainStringLiteral(node)) {\n\n        //the case of print '\\<caret>'\n        if (isSlashBeforeCaret(caretOffset, fileText)) {\n          EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        }\n        else {\n          EditorModificationUtil.insertStringAtCaret(editor, \"'+\");\n          originalHandler.execute(editor, dataContext);\n          EditorModificationUtil.insertStringAtCaret(editor, \"'\");\n          PsiDocumentManager.getInstance(project).commitDocument(document);\n          CodeStyleManager.getInstance(project).reformatRange(file, caretOffset, caretModel.getOffset());\n        }\n      }\n      else {\n        insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      }\n      return true;\n    }\n\n    if (GSTRING_TOKENS.contains(node.getElementType()) ||\n        node.getElementType() == mDOLLAR && node.getTreeParent().getTreeParent().getElementType() == GSTRING) {\n      PsiElement parent = stringElement.getParent();\n      if (node.getElementType() == mGSTRING_LITERAL) {\n        parent = stringElement;\n      }\n      else {\n        while (parent != null && !(parent instanceof GrLiteral)) {\n          parent = parent.getParent();\n        }\n      }\n      if (parent == null) return false;\n      if (GroovyEditorActionUtil.isPlainGString(parent.getNode())) {\n        PsiElement exprSibling = stringElement.getNextSibling();\n        boolean rightFromDollar = exprSibling instanceof GrExpression && exprSibling.getTextRange().getStartOffset() == caretOffset;\n        if (rightFromDollar) caretOffset--;\n        TextRange parentRange = parent.getTextRange();\n        if (rightFromDollar) {\n          convertEndToMultiline(parent.getTextRange().getEndOffset(), document, fileText, '\"');\n          document.insertString(parentRange.getStartOffset(), \"\\\"\\\"\");\n          caretModel.moveToOffset(caretOffset + 2);\n          EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n          caretModel.moveCaretRelatively(1, 0, false, false, true);\n        }\n        else if (isSlashBeforeCaret(caretOffset, fileText)) {\n          EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        }\n        else {\n          EditorModificationUtil.insertStringAtCaret(editor, \"\\\"+\");\n          originalHandler.execute(editor, dataContext);\n          EditorModificationUtil.insertStringAtCaret(editor, \"\\\"\");\n          PsiDocumentManager.getInstance(project).commitDocument(document);\n          CodeStyleManager.getInstance(project).reformatRange(file, caretOffset, caretModel.getOffset());\n        }\n      }\n      else {\n        insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      }\n      return true;\n    }\n\n    if (REGEX_TOKENS.contains(node.getElementType()) ||\n        node.getElementType() == mDOLLAR && node.getTreeParent().getTreeParent().getElementType() == REGEX) {\n      PsiElement parent = stringElement.getParent();\n      if (node.getElementType() == mREGEX_LITERAL || node.getElementType() == mDOLLAR_SLASH_REGEX_LITERAL) {\n        parent = stringElement;\n      }\n      else {\n        while (parent != null && !(parent instanceof GrLiteral)) {\n          parent = parent.getParent();\n        }\n      }\n      if (parent == null || parent.getLastChild() instanceof PsiErrorElement) return false;\n      PsiElement exprSibling = stringElement.getNextSibling();\n      boolean rightFromDollar = exprSibling instanceof GrExpression && exprSibling.getTextRange().getStartOffset() == caretOffset;\n      if (rightFromDollar) {\n        caretModel.moveToOffset(caretOffset - 1);\n      }\n      insertLineFeedInString(editor, dataContext, originalHandler, isInsertIndent);\n      if (rightFromDollar) {\n        caretModel.moveCaretRelatively(1, 0, false, false, true);\n      }\n      return true;\n    }\n\n    return false;\n  }","commit_id":"c649a54f2277ce6a56b4f8824f0b67494f57a1fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Result preprocessEnter(@NotNull final PsiFile file,\n                                @NotNull final Editor editor,\n                                @NotNull final Ref<Integer> caretOffset,\n                                @NotNull final Ref<Integer> caretAdvance,\n                                @NotNull final DataContext dataContext,\n                                final EditorActionHandler originalHandler) {\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      return Result.Continue;\n    }\n\n    if (!file.getViewProvider().getLanguages().contains(myLanguage)) {\n      return Result.Continue;\n    }\n\n    if (editor.isViewer()) {\n      return Result.Continue;\n    }\n\n    final Document document = editor.getDocument();\n    if (!document.isWritable()) {\n      return Result.Continue;\n    }\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n\n    int caret = editor.getCaretModel().getOffset();\n    if (caret == 0) {\n      return Result.Continue;\n    }\n\n    final int lineNumber = document.getLineNumber(caret);\n    final int previousLineStartOffset = document.getLineStartOffset(lineNumber - 1);\n    final int lineStartOffset = document.getLineStartOffset(lineNumber);\n    final EditorHighlighter highlighter = ((EditorEx)editor).getHighlighter();\n    final HighlighterIterator iterator = highlighter.createIterator(caret - 1);\n    final IElementType type = getNonWhitespaceElementType(iterator, previousLineStartOffset);\n\n    final CharSequence editorCharSequence = editor.getDocument().getCharsSequence();\n    final CharSequence lineIndent =\n      editorCharSequence.subSequence(lineStartOffset, EditorActionUtil.findFirstNonSpaceOffsetOnTheLine(document, lineNumber));\n\n    // Enter in line comment\n    if (type == myLineCommentType) {\n      final String restString = editorCharSequence.subSequence(caret, document.getLineEndOffset(lineNumber)).toString();\n      if (!StringUtil.isEmptyOrSpaces(restString)) {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\" + lineIndent + myLineCommentPrefix);\n        editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(lineNumber + 1, 1));\n        return Result.Stop;\n      }\n    }\n\n    if (myIndentTokens.contains(type)) {\n      return Result.Continue;\n    }\n\n    if (LanguageFormatting.INSTANCE.forLanguage(myLanguage) != null) {\n      return Result.Continue;\n    }\n    EditorModificationUtil.insertStringAtCaret(editor, \"\\n\" + lineIndent);\n    editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(lineNumber + 1, lineIndent.length()));\n    return Result.Stop;\n  }","id":51697,"modified_method":"public Result preprocessEnter(@NotNull final PsiFile file,\n                                @NotNull final Editor editor,\n                                @NotNull final Ref<Integer> caretOffset,\n                                @NotNull final Ref<Integer> caretAdvance,\n                                @NotNull final DataContext dataContext,\n                                final EditorActionHandler originalHandler) {\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      return Result.Continue;\n    }\n\n    if (!file.getViewProvider().getLanguages().contains(myLanguage)) {\n      return Result.Continue;\n    }\n\n    if (editor.isViewer()) {\n      return Result.Continue;\n    }\n\n    final Document document = editor.getDocument();\n    if (!document.isWritable()) {\n      return Result.Continue;\n    }\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n\n    int caret = editor.getCaretModel().getOffset();\n    if (caret == 0) {\n      return Result.Continue;\n    }\n\n    final int lineNumber = document.getLineNumber(caret);\n\n\n    final int lineStartOffset = document.getLineStartOffset(lineNumber);\n    final int previousLineStartOffset = lineNumber > 0 ? document.getLineStartOffset(lineNumber - 1) : lineStartOffset;\n    final EditorHighlighter highlighter = ((EditorEx)editor).getHighlighter();\n    final HighlighterIterator iterator = highlighter.createIterator(caret - 1);\n    final IElementType type = getNonWhitespaceElementType(iterator, previousLineStartOffset);\n\n    final CharSequence editorCharSequence = editor.getDocument().getCharsSequence();\n    final CharSequence lineIndent =\n      editorCharSequence.subSequence(lineStartOffset, EditorActionUtil.findFirstNonSpaceOffsetOnTheLine(document, lineNumber));\n\n    // Enter in line comment\n    if (type == myLineCommentType) {\n      final String restString = editorCharSequence.subSequence(caret, document.getLineEndOffset(lineNumber)).toString();\n      if (!StringUtil.isEmptyOrSpaces(restString)) {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\" + lineIndent + myLineCommentPrefix);\n        editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(lineNumber + 1, 1));\n        return Result.Stop;\n      }\n    }\n\n    if (LanguageFormatting.INSTANCE.forLanguage(myLanguage) != null) {\n      return Result.Continue;\n    }\n    else {\n      if (myIndentTokens.contains(type)) {\n        final String singleIndent = getSingleIndent(file);\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\" + lineIndent + singleIndent);\n        return Result.Stop;\n      }\n\n      EditorModificationUtil.insertStringAtCaret(editor, \"\\n\" + lineIndent);\n      editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(lineNumber + 1, lineIndent.length()));\n      return Result.Stop;\n    }\n  }","commit_id":"988b0e5f7800ab4c06a3140e65e5af9f8079fdbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Build out the Base directory (if needed)\n     * \n     * @return true if base directory was changed, false if left unchanged.\n     * @throws IOException\n     */\n    public boolean build() throws IOException\n    {\n        Modules modules = startArgs.getAllModules();\n        boolean dirty = false;\n\n        String dirSource = \"<add-to-startd>\";\n        String iniSource = \"<add-to-start-ini>\";\n        Selection startDirSelection = new Selection(dirSource);\n        Selection startIniSelection = new Selection(iniSource);\n        \n        Set<String> startDNames = new HashSet<>();\n        startDNames.addAll(startArgs.getAddToStartdIni());\n        Set<String> startIniNames = new HashSet<>();\n        startIniNames.addAll(startArgs.getAddToStartIni());\n\n        int count = 0;\n        count += modules.selectNodes(startDNames,startDirSelection);\n        count += modules.selectNodes(startIniNames,startIniSelection);\n\n        // look for ambiguous declaration found in both places\n        Predicate ambiguousPredicate = new HowSetPredicate(dirSource,iniSource);\n        List<Module> ambiguous = modules.getMatching(ambiguousPredicate);\n\n        if (ambiguous.size() > 0)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"Unable to add \");\n            err.append(ambiguous.size());\n            err.append(\" module\");\n            if (ambiguous.size() > 1)\n            {\n                err.append('s');\n            }\n            err.append(\" (found declared via both --add-to-start and --add-to-startd): [\");\n            for (int i = 0; i < ambiguous.size(); i++)\n            {\n                if (i > 0)\n                {\n                    err.append(\", \");\n                }\n                err.append(ambiguous.get(i).getName());\n            }\n            err.append(']');\n            throw new RuntimeException(err.toString());\n        }\n\n        StartLog.debug(\"Adding %s new module(s)\",count);\n        \n        // Acknowledge Licenses\n        ackLicenses();\n\n        // Collect specific modules to enable\n        // Should match 'how', with no other selections.explicit\n        Predicate startDMatcher = new HowUniquePredicate(dirSource);\n        Predicate startIniMatcher = new HowUniquePredicate(iniSource);\n\n        List<Module> startDModules = modules.getMatching(startDMatcher);\n        List<Module> startIniModules = modules.getMatching(startIniMatcher);\n\n        List<FileArg> files = new ArrayList<FileArg>();\n\n        if (!startDModules.isEmpty())\n        {\n            StartDirBuilder builder = new StartDirBuilder(this);\n            for (Module mod : startDModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        if (!startIniModules.isEmpty())\n        {\n            StartIniBuilder builder = new StartIniBuilder(this);\n            for (Module mod : startIniModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        // Process files\n        files.addAll(startArgs.getFiles());\n        dirty |= processFileResources(files);\n\n        return dirty;\n    }","id":51698,"modified_method":"/**\n     * Build out the Base directory (if needed)\n     * \n     * @return true if base directory was changed, false if left unchanged.\n     * @throws IOException\n     */\n    public boolean build() throws IOException\n    {\n        Modules modules = startArgs.getAllModules();\n        boolean dirty = false;\n\n        String dirSource = \"<add-to-startd>\";\n        String iniSource = \"<add-to-start-ini>\";\n        Selection startDirSelection = new Selection(dirSource);\n        Selection startIniSelection = new Selection(iniSource);\n        \n        List<String> startDNames = new ArrayList<>();\n        startDNames.addAll(startArgs.getAddToStartdIni());\n        List<String> startIniNames = new ArrayList<>();\n        startIniNames.addAll(startArgs.getAddToStartIni());\n\n        int count = 0;\n        count += modules.selectNodes(startDNames,startDirSelection);\n        count += modules.selectNodes(startIniNames,startIniSelection);\n\n        // look for ambiguous declaration found in both places\n        Predicate ambiguousPredicate = new HowSetPredicate(dirSource,iniSource);\n        List<Module> ambiguous = modules.getMatching(ambiguousPredicate);\n\n        if (ambiguous.size() > 0)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"Unable to add \");\n            err.append(ambiguous.size());\n            err.append(\" module\");\n            if (ambiguous.size() > 1)\n            {\n                err.append('s');\n            }\n            err.append(\" (found declared via both --add-to-start and --add-to-startd): [\");\n            for (int i = 0; i < ambiguous.size(); i++)\n            {\n                if (i > 0)\n                {\n                    err.append(\", \");\n                }\n                err.append(ambiguous.get(i).getName());\n            }\n            err.append(']');\n            throw new RuntimeException(err.toString());\n        }\n\n        StartLog.debug(\"Adding %s new module(s)\",count);\n        \n        // Acknowledge Licenses\n        ackLicenses();\n\n        // Collect specific modules to enable\n        // Should match 'how', with no other selections.explicit\n        Predicate startDMatcher = new HowUniquePredicate(dirSource);\n        Predicate startIniMatcher = new HowUniquePredicate(iniSource);\n\n        List<Module> startDModules = modules.getMatching(startDMatcher);\n        List<Module> startIniModules = modules.getMatching(startIniMatcher);\n\n        List<FileArg> files = new ArrayList<FileArg>();\n\n        if (!startDModules.isEmpty())\n        {\n            StartDirBuilder builder = new StartDirBuilder(this);\n            for (Module mod : startDModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        if (!startIniModules.isEmpty())\n        {\n            StartIniBuilder builder = new StartIniBuilder(this);\n            for (Module mod : startIniModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        // Process files\n        files.addAll(startArgs.getFiles());\n        dirty |= processFileResources(files);\n\n        return dirty;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    @Ignore(\"See https://bugs.eclipse.org/451973\")\n    public void testLikeDistro_SetupDemoBase() throws Exception\n    {\n        File basePath = testdir.getEmptyDir();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n\n        cmds.add(\"--add-to-start=continuation,deploy,websocket,ext,resources,client,annotations,jndi,servlets\");\n        cmds.add(\"--add-to-startd=jsp,jstl,http,https\");\n\n        execMain(cmds);\n    }","id":51699,"modified_method":"@Test\n    @Ignore(\"See https://bugs.eclipse.org/451973\")\n    public void testLikeDistro_SetupDemoBase() throws Exception\n    {\n        Path basePath = testdir.getEmptyDir().toPath();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n\n        cmds.add(\"--add-to-start=continuation,deploy,websocket,ext,resources,client,annotations,jndi,servlets\");\n        cmds.add(\"--add-to-startd=jsp,jstl,http,https\");\n\n        execMain(cmds);\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddServerModule() throws Exception\n    {\n        File basePath = testdir.getEmptyDir();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        assertFileExists(basePath,\"start.d/http.ini\");\n        assertFileExists(basePath,\"start.d/server.ini\");\n        \n        // Delete server.ini\n        Path serverIni = basePath.toPath().resolve(\"start.d/server.ini\");\n        Files.deleteIfExists(serverIni);\n        \n        // Attempt to re-add via 'server' module reference\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=server\");\n        execMain(cmds);\n        \n        assertFileExists(basePath,\"start.d/server.ini\");\n    }","id":51700,"modified_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddServerModule() throws Exception\n    {\n        Path basePath = testdir.getEmptyDir().toPath();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        Path httpIni = basePath.resolve(\"start.d/http.ini\");\n        Path serverIni = basePath.resolve(\"start.d/server.ini\");\n        \n        assertThat(\"start.d/http.ini\", httpIni, fileExists());\n        assertThat(\"start.d/server.ini\", serverIni, fileExists());\n        \n        // Delete server.ini\n        Files.deleteIfExists(serverIni);\n        \n        // Attempt to re-add via 'server' module reference\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=server\");\n        execMain(cmds);\n        \n        assertThat(\"start.d/server.ini\", serverIni, fileExists());\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddHttpThenDeployViaStartD() throws Exception\n    {\n        File basePath = testdir.getEmptyDir();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-start=http\");\n        execMain(cmds);\n        \n        assertFileExists(basePath,\"start.ini\");\n        \n        // Now add 'deploy' module.\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=deploy\");\n        execMain(cmds);\n        \n        // The following files should not exist (as its already defined in /start.ini)\n        assertNotFileExists(basePath,\"start.d/server.ini\");\n    }","id":51701,"modified_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddHttpThenDeployViaStartD() throws Exception\n    {\n        Path basePath = testdir.getEmptyDir().toPath();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-start=http\");\n        execMain(cmds);\n        \n        Path startIni = basePath.resolve(\"start.ini\");\n        \n        assertThat(\"start.ini\", startIni, fileExists());\n\n        // Now add 'deploy' module.\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=deploy\");\n        execMain(cmds);\n        \n        // The following files should not exist (as its already defined in /start.ini)\n        Path serverIni = basePath.resolve(\"start.d/server.ini\");\n        assertThat(\"start.d/server.ini\", serverIni, notPathExists());\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testLikeDistro_SetupHome() throws Exception\n    {\n        File basePath = testdir.getEmptyDir();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n\n        cmds.add(\"--add-to-start=deploy,websocket,ext,resources,jsp,jstl,http\");\n\n        execMain(cmds);\n    }","id":51702,"modified_method":"@Test\n    public void testLikeDistro_SetupHome() throws Exception\n    {\n        Path basePath = testdir.getEmptyDir().toPath();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n\n        cmds.add(\"--add-to-start=deploy,websocket,ext,resources,jsp,jstl,http\");\n\n        execMain(cmds);\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public List<String> getBaseCommandLine(File basePath)\n    {\n        List<String> cmds = new ArrayList<String>();\n        cmds.add(\"-Djava.io.tmpdir=\" + MavenTestingUtils.getTargetDir().getAbsolutePath());\n        cmds.add(\"-Djetty.home=\" + MavenTestingUtils.getTestResourceDir(\"dist-home\").getAbsolutePath());\n        cmds.add(\"-Djetty.base=\" + basePath.getAbsolutePath());\n        cmds.add(\"--testing-mode\");\n\n        return cmds;\n    }","id":51703,"modified_method":"public List<String> getBaseCommandLine(Path basePath)\n    {\n        List<String> cmds = new ArrayList<String>();\n        cmds.add(\"-Djava.io.tmpdir=\" + MavenTestingUtils.getTargetDir().getAbsolutePath());\n        cmds.add(\"-Djetty.home=\" + MavenTestingUtils.getTestResourceDir(\"dist-home\").getAbsolutePath());\n        cmds.add(\"-Djetty.base=\" + basePath.normalize().toAbsolutePath().toString());\n        cmds.add(\"--testing-mode\");\n\n        return cmds;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddServerViaHttpModule() throws Exception\n    {\n        File basePath = testdir.getEmptyDir();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        assertFileExists(basePath,\"start.d/http.ini\");\n        assertFileExists(basePath,\"start.d/server.ini\");\n        \n        // Delete server.ini\n        Path serverIni = basePath.toPath().resolve(\"start.d/server.ini\");\n        Files.deleteIfExists(serverIni);\n        \n        // Attempt to re-add via 'http' module reference\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        assertFileExists(basePath,\"start.d/server.ini\");\n    }","id":51704,"modified_method":"/**\n     * Test for https://bugs.eclipse.org/452329\n     */\n    @Test\n    public void testReAddServerViaHttpModule() throws Exception\n    {\n        Path basePath = testdir.getEmptyDir().toPath();\n\n        List<String> cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        Path httpIni = basePath.resolve(\"start.d/http.ini\");\n        Path serverIni = basePath.resolve(\"start.d/server.ini\");\n        \n        assertThat(\"start.d/http.ini\", httpIni, fileExists());\n        assertThat(\"start.d/server.ini\", serverIni, fileExists());\n        \n        // Delete server.ini\n        Files.deleteIfExists(serverIni);\n        \n        // Attempt to re-add via 'http' module reference\n        cmds = getBaseCommandLine(basePath);\n        cmds.add(\"--add-to-startd=http\");\n        execMain(cmds);\n        \n        assertThat(\"start.d/server.ini\", serverIni, fileExists());\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int selectNode(String name, Selection selection)\n    {\n        int count = 0;\n        T node = get(name);\n        if (node == null)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"WARNING: Cannot \").append(selectionTerm);\n            err.append(\" requested \").append(nodeTerm);\n            err.append(\" [\").append(name).append(\"]: not a valid \");\n            err.append(nodeTerm).append(\" name.\");\n            System.err.println(err);\n            return count;\n        }\n\n        count += selectNode(node,selection);\n\n        return count;\n    }","id":51705,"modified_method":"public int selectNode(String name, Selection selection)\n    {\n        int count = 0;\n        T node = get(name);\n        if (node == null)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"Cannot \").append(selectionTerm);\n            err.append(\" requested \").append(nodeTerm);\n            err.append(\" [\").append(name).append(\"]: not a valid \");\n            err.append(nodeTerm).append(\" name.\");\n            StartLog.warn(err.toString());\n            return count;\n        }\n\n        count += selectNode(node,selection);\n\n        return count;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int selectNode(Predicate nodePredicate, Selection selection)\n    {\n        int count = 0;\n        List<T> matches = getMatching(nodePredicate);\n        if (matches.isEmpty())\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"WARNING: Cannot \").append(selectionTerm);\n            err.append(\" requested \").append(nodeTerm);\n            err.append(\"s.  \").append(nodePredicate);\n            err.append(\" returned no matches.\");\n            System.err.println(err);\n            return count;\n        }\n\n        // select them\n        for (T node : matches)\n        {\n            count += selectNode(node,selection);\n        }\n\n        return count;\n    }","id":51706,"modified_method":"public int selectNode(Predicate nodePredicate, Selection selection)\n    {\n        int count = 0;\n        List<T> matches = getMatching(nodePredicate);\n        if (matches.isEmpty())\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"WARNING: Cannot \").append(selectionTerm);\n            err.append(\" requested \").append(nodeTerm);\n            err.append(\"s.  \").append(nodePredicate);\n            err.append(\" returned no matches.\");\n            StartLog.warn(err.toString());\n            return count;\n        }\n\n        // select them\n        for (T node : matches)\n        {\n            count += selectNode(node,selection);\n        }\n\n        return count;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int selectNodes(Collection<String> names, Selection selection)\n    {\n        int count = 0;\n\n        for (String name : names)\n        {\n            count += selectNode(name,selection);\n        }\n\n        return count;\n    }","id":51707,"modified_method":"public int selectNodes(Collection<String> names, Selection selection)\n    {\n        StartLog.debug(\"%s [%s] (via %s)\",toCap(selectionTerm),Utils.join(names,\", \"),selection);\n\n        int count = 0;\n\n        for (String name : names)\n        {\n            T node = get(name);\n            // Node doesn't exist yet (try to resolve it it just-in-time)\n            if (node == null)\n            {\n                StartLog.debug(\"resolving node [%s]\",name);\n                node = resolveNode(name);\n            }\n            // Node still doesn't exist? this is now an invalid graph.\n            if (node == null)\n            {\n                throw new GraphException(\"Missing referenced dependency: \" + name);\n            }\n\n            count += selectNode(name,selection);\n        }\n\n        return count;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private int selectNode(T node, Selection selection)\n    {\n        int count = 0;\n\n        if (node.getSelections().contains(selection))\n        {\n            // Already enabled with this selection.\n            return count;\n        }\n\n        StartLog.debug(\"%s %s: %s (via %s)\",toCap(selectionTerm),nodeTerm,node.getName(),selection);\n\n        boolean newlySelected = node.getSelections().isEmpty();\n\n        // Add self\n        node.addSelection(selection);\n        if (newlySelected)\n        {\n            onNodeSelected(node);\n        }\n        count++;\n\n        // Walk transitive\n        Selection transitive = selection.asTransitive();\n        Set<String> parentNames = new HashSet<>();\n        parentNames.addAll(node.getParentNames());\n        Set<T> parentNodes = resolveNodes(parentNames);\n        for (T parentNode : parentNodes)\n        {\n            count += selectNode(parentNode,transitive);\n        }\n\n        return count;\n    }","id":51708,"modified_method":"private int selectNode(T node, Selection selection)\n    {\n        int count = 0;\n\n        if (node.getSelections().contains(selection))\n        {\n            // Already enabled with this selection.\n            return count;\n        }\n\n        StartLog.debug(\"%s %s: %s (via %s)\",toCap(selectionTerm),nodeTerm,node.getName(),selection);\n\n        boolean newlySelected = node.getSelections().isEmpty();\n\n        // Add self\n        node.addSelection(selection);\n        if (newlySelected)\n        {\n            onNodeSelected(node);\n        }\n        count++;\n\n        // Walk transitive\n        Selection transitive = selection.asTransitive();\n        List<String> parentNames = new ArrayList<>();\n        parentNames.addAll(node.getParentNames());\n\n        count += selectNodes(parentNames,transitive);\n\n        return count;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void expandProperties(Props props)\n    {\n        // Expand Parents\n        Set<String> parents = new HashSet<>();\n        for (String parent : getParentNames())\n        {\n            parents.add(props.expand(parent));\n        }\n        setParentNames(parents);\n    }","id":51709,"modified_method":"public void expandProperties(Props props)\n    {\n        // Expand Parents\n        List<String> parents = new ArrayList<>();\n        for (String parent : getParentNames())\n        {\n            parents.add(props.expand(parent));\n        }\n        setParentNames(parents);\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Modules can have a different logical name than to their filesystem reference. This updates existing references to\n     * the filesystem form to use the logical\n     * name form.\n     * \n     * @param module\n     *            the module that might have other modules referring to it.\n     */\n    private void updateParentReferencesTo(Module module)\n    {\n        if (module.getName().equals(module.getFilesystemRef()))\n        {\n            // nothing to do, its sane already\n            return;\n        }\n\n        for (Module m : getNodes())\n        {\n            Set<String> resolvedParents = new HashSet<>();\n            for (String parent : m.getParentNames())\n            {\n                if (parent.equals(module.getFilesystemRef()))\n                {\n                    // use logical name instead\n                    resolvedParents.add(module.getName());\n                }\n                else\n                {\n                    // use name as-is\n                    resolvedParents.add(parent);\n                }\n            }\n            m.setParentNames(resolvedParents);\n        }\n    }","id":51710,"modified_method":"/**\n     * Modules can have a different logical name than to their filesystem reference. This updates existing references to\n     * the filesystem form to use the logical\n     * name form.\n     * \n     * @param module\n     *            the module that might have other modules referring to it.\n     */\n    private void updateParentReferencesTo(Module module)\n    {\n        if (module.getName().equals(module.getFilesystemRef()))\n        {\n            // nothing to do, its sane already\n            return;\n        }\n\n        for (Module m : getNodes())\n        {\n            List<String> resolvedParents = new ArrayList<>();\n            for (String parent : m.getParentNames())\n            {\n                if (parent.equals(module.getFilesystemRef()))\n                {\n                    // use logical name instead\n                    resolvedParents.add(module.getName());\n                }\n                else\n                {\n                    // use name as-is\n                    resolvedParents.add(parent);\n                }\n            }\n            m.setParentNames(resolvedParents);\n        }\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onNodeSelected(Module module)\n    {\n        args.parseModule(module);\n        module.expandProperties(args.getProperties());\n    }","id":51711,"modified_method":"@Override\n    public void onNodeSelected(Module module)\n    {\n        StartLog.debug(\"on node selected: %s [%s]\",module.getName(),baseHome.toShortForm(module.getFilesystemRef()));\n        args.parseModule(module);\n        module.expandProperties(args.getProperties());\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void addOptionalParentName(String name)\n    {\n        this.optionalParentNames.add(name);\n    }","id":51712,"modified_method":"public void addOptionalParentName(String name)\n    {\n        if (this.optionalParentNames.contains(name))\n        {\n            // skip, name already exists\n            return;\n        }\n        this.optionalParentNames.add(name);\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void addParentName(String name)\n    {\n        this.parentNames.add(name);\n    }","id":51713,"modified_method":"public void addParentName(String name)\n    {\n        if (this.parentNames.contains(name))\n        {\n            // skip, name already exists\n            return;\n        }\n        this.parentNames.add(name);\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Set<String> getParentNames()\n    {\n        return parentNames;\n    }","id":51714,"modified_method":"public List<String> getParentNames()\n    {\n        return parentNames;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void setParentNames(Set<String> parents)\n    {\n        this.parentNames.clear();\n        this.parentEdges.clear();\n        if (parents != null)\n        {\n            this.parentNames.addAll(parents);\n        }\n    }","id":51715,"modified_method":"public void setParentNames(List<String> parents)\n    {\n        this.parentNames.clear();\n        this.parentEdges.clear();\n        if (parents != null)\n        {\n            this.parentNames.addAll(parents);\n        }\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Set<String> getOptionalParentNames()\n    {\n        return optionalParentNames;\n    }","id":51716,"modified_method":"public List<String> getOptionalParentNames()\n    {\n        return optionalParentNames;\n    }","commit_id":"9bd0ce1938ede1b44ae580e66e0f688a1912b1d4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void start() throws Exception {\n        if (started)\n            return;\n        getCluster().addClusterListener(this);\n        if (watchEnabled) {\n            watcher = new WarWatcher(this, new File(getWatchDir()));\n            if (log.isInfoEnabled())\n                log.info(\"Cluster deployment is watching \" + getWatchDir()\n                        + \" for changes.\");\n        }\n\n        // Check to correct engine and host setup\n        host = (Host) getCluster().getContainer();\n        Engine engine = (Engine) host.getParent();\n        try {\n            oname = new ObjectName(engine.getName() + \":type=Deployer,host=\"\n                    + host.getName());\n        } catch (Exception e) {\n            log.error(\"Can't construct MBean object name\" + e);\n        }\n        configBase = new File(System.getProperty(\"catalina.base\"), \"conf\");\n        if (engine != null) {\n            configBase = new File(configBase, engine.getName());\n        }\n        if (host != null) {\n            configBase = new File(configBase, host.getName());\n        }\n\n        // Retrieve the MBean server\n        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();\n\n        started = true;\n        count = 0;\n        if (log.isInfoEnabled())\n            log.info(\"Cluster FarmWarDeployer started.\");\n    }","id":51717,"modified_method":"public void start() throws Exception {\n        if (started)\n            return;\n        getCluster().addClusterListener(this);\n        if (watchEnabled) {\n            watcher = new WarWatcher(this, new File(getWatchDir()));\n            if (log.isInfoEnabled())\n                log.info(\"Cluster deployment is watching \" + getWatchDir()\n                         + \" for changes.\");\n        }\n    \n        // Check to correct engine and host setup\n        Object parent = getCluster().getContainer();\n        Engine engine = null;\n        if ( parent instanceof Host ) {\n            host = (Host) parent;\n            engine = (Engine) host.getParent();\n        }else {\n            engine = (Engine)parent;\n        }\n        try {\n            oname = new ObjectName(engine.getName() + \":type=Deployer,host=\"\n                    + host.getName());\n        } catch (Exception e) {\n            log.error(\"Can't construct MBean object name\" + e);\n        }\n        configBase = new File(System.getProperty(\"catalina.base\"), \"conf\");\n        if (engine != null) {\n            configBase = new File(configBase, engine.getName());\n        } else if (host != null) {\n            configBase = new File(configBase, host.getName());\n        }\n\n        // Retrieve the MBean server\n        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();\n\n        started = true;\n        count = 0;\n        if (log.isInfoEnabled())\n            log.info(\"Cluster FarmWarDeployer started.\");\n    }","commit_id":"ade8f2757e58826ebfe508e92f2b18ad92e7026b","url":"https://github.com/apache/tomcat"},{"original_method":"private void boxAttribute(TypedDeclaration declaration) {\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = null;\n        if (this.shortcutRefined != null\n                && shortcutRefined instanceof Functional) {\n            // This insanity is to work around the fact that the Parameter of a \n            // SpecifierStatement doesn't know the Method being specifed, so \n            // getTopmostRefinedDeclaration() doesn't work\n            int i = 0;\n            outer: for (ParameterList pl :((Functional)shortcutRefined).getParameterLists()) {\n                int j = 0;\n                for (Parameter p : pl.getParameters()) {\n                    if (p == declaration) {\n                        Functional refined = (Functional)CodegenUtil.getTopmostRefinedDeclaration(shortcutRefined);\n                        refinedDeclaration = refined.getParameterLists().get(i).getParameters().get(j);\n                        break outer;\n                    }\n                    j++;\n                }\n                i++;\n            }\n            \n        }\n        if (refinedDeclaration == null) {\n            refinedDeclaration = (TypedDeclaration)CodegenUtil.getTopmostRefinedDeclaration(declaration);\n        }\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        setBoxingState(declaration, refinedDeclaration);\n    }","id":51718,"modified_method":"private void boxAttribute(TypedDeclaration declaration) {\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = null;\n        refinedDeclaration = (TypedDeclaration)CodegenUtil.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        setBoxingState(declaration, refinedDeclaration);\n    }","commit_id":"1741662019b448ab2629d764b80534fd8bc17398","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(SpecifierStatement that) {\n        TypedDeclaration prevShortcutRefined = this.shortcutRefined;\n        if (that.getRefinement()) {\n            this.shortcutRefined = that.getDeclaration();\n        }\n        super.visit(that);\n        if (that.getRefinement()) {\n            this.shortcutRefined = prevShortcutRefined;\n        }\n    }","id":51719,"modified_method":"@Override\n    public void visit(SpecifierStatement that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclaration();\n        if(declaration == null)\n            return;\n        if(declaration instanceof Method)\n            visitMethod((Method) declaration);\n        else if(declaration instanceof Value)\n            visitAttributeOrParameter(declaration);\n    }","commit_id":"1741662019b448ab2629d764b80534fd8bc17398","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"static Declaration getTopmostRefinedDeclaration(Declaration decl){\n        if (decl instanceof Parameter && decl.getContainer() instanceof Class) {\n            // Parameters in a refined class are not considered refinements themselves\n            // We have in find the refined attribute\n            Class c = (Class)decl.getContainer();\n            if (c.isAlias()) {\n                int index = c.getParameterList().getParameters().indexOf(decl);\n                while (c.isAlias()) {\n                    c = c.getExtendedTypeDeclaration();\n                }\n                decl = c.getParameterList().getParameters().get(index);\n            }\n            Declaration refinedDecl = c.getRefinedMember(decl.getName(), null, false);//?? elipses=false??\n            if(refinedDecl != null && refinedDecl != decl) {\n                return getTopmostRefinedDeclaration(refinedDecl);\n            }\n            return decl;\n        } else if(decl instanceof Parameter && decl.getContainer() instanceof Method){\n            // Parameters in a refined method are not considered refinements themselves\n            // so we have to look up the corresponding parameter in the container's refined declaration\n            Method func = (Method)decl.getContainer();\n            Parameter param = (Parameter)decl;\n            Method refinedFunc = (Method) getTopmostRefinedDeclaration((Declaration)decl.getContainer());\n            // shortcut if the functional doesn't override anything\n            if(refinedFunc == decl.getContainer())\n                return decl;\n            if (func.getParameterLists().size() != refinedFunc.getParameterLists().size()) {\n                throw new RuntimeException(\"Different numbers of parameter lists\");\n            }\n            for (int ii = 0; ii < func.getParameterLists().size(); ii++) {\n                if (func.getParameterLists().get(ii).getParameters().size() != refinedFunc.getParameterLists().get(ii).getParameters().size()) {\n                    throw new RuntimeException(\"Different sized parameter lists\");\n                }\n                // find the index of the parameter\n                int index = func.getParameterLists().get(ii).getParameters().indexOf(param);\n                if (index == -1) {\n                    continue;\n                }\n                return refinedFunc.getParameterLists().get(ii).getParameters().get(index);\n            }\n        }\n        Declaration refinedDecl = decl.getRefinedDeclaration();\n        if(refinedDecl != null && refinedDecl != decl)\n            return getTopmostRefinedDeclaration(refinedDecl);\n        return decl;\n    }","id":51720,"modified_method":"static Declaration getTopmostRefinedDeclaration(Declaration decl){\n        if (decl instanceof Parameter && decl.getContainer() instanceof Class) {\n            // Parameters in a refined class are not considered refinements themselves\n            // We have in find the refined attribute\n            Class c = (Class)decl.getContainer();\n            if (c.isAlias()) {\n                int index = c.getParameterList().getParameters().indexOf(decl);\n                while (c.isAlias()) {\n                    c = c.getExtendedTypeDeclaration();\n                }\n                decl = c.getParameterList().getParameters().get(index);\n            }\n            Declaration refinedDecl = c.getRefinedMember(decl.getName(), null, false);//?? elipses=false??\n            if(refinedDecl != null && refinedDecl != decl) {\n                return getTopmostRefinedDeclaration(refinedDecl);\n            }\n            return decl;\n        } else if(decl instanceof Parameter \n                && (decl.getContainer() instanceof Method || decl.getContainer() instanceof Specification)){\n            // Parameters in a refined method are not considered refinements themselves\n            // so we have to look up the corresponding parameter in the container's refined declaration\n            Method func;\n            if(decl.getContainer() instanceof Method)\n                func = (Method)decl.getContainer();\n            else\n                func = (Method) ((Specification)decl.getContainer()).getDeclaration();\n            if(func == null)\n                return decl;\n            Parameter param = (Parameter)decl;\n            Method refinedFunc = (Method) getTopmostRefinedDeclaration(func);\n            // shortcut if the functional doesn't override anything\n            if(refinedFunc == func)\n                return decl;\n            if (func.getParameterLists().size() != refinedFunc.getParameterLists().size()) {\n                // invalid input\n                return decl;\n            }\n            for (int ii = 0; ii < func.getParameterLists().size(); ii++) {\n                if (func.getParameterLists().get(ii).getParameters().size() != refinedFunc.getParameterLists().get(ii).getParameters().size()) {\n                    // invalid input\n                    return decl;\n                }\n                // find the index of the parameter\n                int index = func.getParameterLists().get(ii).getParameters().indexOf(param);\n                if (index == -1) {\n                    continue;\n                }\n                return refinedFunc.getParameterLists().get(ii).getParameters().get(index);\n            }\n        }\n        Declaration refinedDecl = decl.getRefinedDeclaration();\n        if(refinedDecl != null && refinedDecl != decl)\n            return getTopmostRefinedDeclaration(refinedDecl);\n        return decl;\n    }","commit_id":"1741662019b448ab2629d764b80534fd8bc17398","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Start this component and implement the requirements\n     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.\n     *\n     * @exception LifecycleException if this component detects a fatal error\n     *  that prevents this component from being used\n     */\n    @Override\n    protected synchronized void startInternal() throws LifecycleException {\n\n        if (cluster == null) {\n            Container hostContainer = getContainer();\n            // compatibility with JvmRouteBinderValve version 1.1\n            // ( setup at context.xml or context.xml.default )\n            if (!(hostContainer instanceof Host)) {\n                if (log.isWarnEnabled()) {\n                    log.warn(sm.getString(\"jvmRoute.configure.warn\"));\n                }\n                hostContainer = hostContainer.getParent();\n            }\n            if (hostContainer instanceof Host\n                    && ((Host) hostContainer).getCluster() != null) {\n                cluster = (CatalinaCluster) ((Host) hostContainer).getCluster();\n            } else {\n                Container engine = hostContainer.getParent() ;\n                if (engine instanceof Engine\n                        && ((Engine) engine).getCluster() != null) {\n                    cluster = (CatalinaCluster) ((Engine) engine).getCluster();\n                }\n            }\n        }\n\n        if (log.isInfoEnabled()) {\n            log.info(sm.getString(\"jvmRoute.valve.started\"));\n            if (cluster == null) {\n                log.info(sm.getString(\"jvmRoute.noCluster\"));\n            }\n        }\n\n        super.startInternal();\n    }","id":51721,"modified_method":"/**\n     * Start this component and implement the requirements\n     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.\n     *\n     * @exception LifecycleException if this component detects a fatal error\n     *  that prevents this component from being used\n     */\n    @Override\n    protected synchronized void startInternal() throws LifecycleException {\n\n        if (cluster == null) {\n            Cluster containerCluster = getContainer().getCluster();\n            if (containerCluster instanceof CatalinaCluster) {\n                setCluster((CatalinaCluster)containerCluster);\n            }\n        }\n\n        if (log.isInfoEnabled()) {\n            log.info(sm.getString(\"jvmRoute.valve.started\"));\n            if (cluster == null) {\n                log.info(sm.getString(\"jvmRoute.noCluster\"));\n            }\n        }\n\n        super.startInternal();\n    }","commit_id":"2d850ffb3d2ea5cbfba718653136e9653966e0fa","url":"https://github.com/apache/tomcat"},{"original_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTOR, PROBABILITIES, or ROOT\");\n  }","id":51722,"modified_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees.  Trees need to be binarized\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTOR, PROBABILITIES, or ROOT\");\n  }","commit_id":"18dca961074ade328f3b142bc6e5d3aed2ae8154","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String getText(Input inputFormat, String filename) {\n    switch (inputFormat) {\n    case TEXT:\n      return IOUtils.slurpFileNoExceptions(filename);\n    case TREES:\n      try {\n        StringBuilder result = new StringBuilder();\n        FileInputStream fin = new FileInputStream(filename);\n        InputStreamReader isr = new InputStreamReader(fin, \"utf-8\");\n        PennTreeReader reader = new PennTreeReader(isr);\n        Tree tree;\n        while ((tree = reader.readTree()) != null) {\n          result.append(Sentence.listToString(tree.yield()));\n          result.append(\"\\n\");\n        }\n        return result.toString();\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","id":51723,"modified_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static Annotation getAnnotation(Input inputFormat, String filename) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      return annotation;\n    }\n    case TREES:\n      try {\n        StringBuilder result = new StringBuilder();\n        FileInputStream fin = new FileInputStream(filename);\n        InputStreamReader isr = new InputStreamReader(fin, \"utf-8\");\n        PennTreeReader reader = new PennTreeReader(isr);\n        \n        List<CoreMap> sentences = Generics.newArrayList();\n\n        Tree tree;\n        while ((tree = reader.readTree()) != null) {\n          CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n          sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n          sentences.add(sentence);\n        }\n        Annotation annotation = new Annotation(\"\");\n        annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n        return annotation;\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","commit_id":"18dca961074ade328f3b142bc6e5d3aed2ae8154","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    } else if (inputFormat == Input.TREES) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n      props.setProperty(\"tokenize.whitespace\", \"true\");\n    }\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      String text = getText(inputFormat, filename);\n      Annotation annotation = new Annotation(text);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n        System.out.println(sentence);\n        outputTree(System.out, tree, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        String text = getText(inputFormat, file);\n        Annotation annotation = new Annotation(text);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n          pout.println(sentence);\n          outputTree(pout, tree, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n            outputTree(System.out, tree, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","id":51724,"modified_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      props.setProperty(\"annotators\", \"sentiment\");\n      props.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      Annotation annotation = getAnnotation(inputFormat, filename);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n        System.out.println(sentence);\n        outputTree(System.out, tree, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        Annotation annotation = getAnnotation(inputFormat, file);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n          pout.println(sentence);\n          outputTree(pout, tree, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n            outputTree(System.out, tree, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","commit_id":"18dca961074ade328f3b142bc6e5d3aed2ae8154","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTOR, PROBABILITIES, or ROOT\");\n  }","id":51725,"modified_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees.  Trees need to be binarized\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTOR, PROBABILITIES, or ROOT\");\n  }","commit_id":"18b3e882fc2f91666ace202e9cf3ab3e9ff4a5fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    } else if (inputFormat == Input.TREES) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n      props.setProperty(\"tokenize.whitespace\", \"true\");\n    }\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      String text = getText(inputFormat, filename);\n      Annotation annotation = new Annotation(text);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n        System.out.println(sentence);\n        outputTree(System.out, tree, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        String text = getText(inputFormat, file);\n        Annotation annotation = new Annotation(text);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n          pout.println(sentence);\n          outputTree(pout, tree, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n            outputTree(System.out, tree, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","id":51726,"modified_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      props.setProperty(\"annotators\", \"sentiment\");\n      props.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      Annotation annotation = getAnnotation(inputFormat, filename);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n        System.out.println(sentence);\n        outputTree(System.out, tree, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        Annotation annotation = getAnnotation(inputFormat, file);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n          pout.println(sentence);\n          outputTree(pout, tree, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);\n            outputTree(System.out, tree, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","commit_id":"18b3e882fc2f91666ace202e9cf3ab3e9ff4a5fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String getText(Input inputFormat, String filename) {\n    switch (inputFormat) {\n    case TEXT:\n      return IOUtils.slurpFileNoExceptions(filename);\n    case TREES:\n      try {\n        StringBuilder result = new StringBuilder();\n        FileInputStream fin = new FileInputStream(filename);\n        InputStreamReader isr = new InputStreamReader(fin, \"utf-8\");\n        PennTreeReader reader = new PennTreeReader(isr);\n        Tree tree;\n        while ((tree = reader.readTree()) != null) {\n          result.append(Sentence.listToString(tree.yield()));\n          result.append(\"\\n\");\n        }\n        return result.toString();\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","id":51727,"modified_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static Annotation getAnnotation(Input inputFormat, String filename) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      return annotation;\n    }\n    case TREES:\n      try {\n        StringBuilder result = new StringBuilder();\n        FileInputStream fin = new FileInputStream(filename);\n        InputStreamReader isr = new InputStreamReader(fin, \"utf-8\");\n        PennTreeReader reader = new PennTreeReader(isr);\n        \n        List<CoreMap> sentences = Generics.newArrayList();\n\n        Tree tree;\n        while ((tree = reader.readTree()) != null) {\n          CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n          sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n          sentences.add(sentence);\n        }\n        Annotation annotation = new Annotation(\"\");\n        annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n        return annotation;\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","commit_id":"18b3e882fc2f91666ace202e9cf3ab3e9ff4a5fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Test\n    public void testDistanceSortingNestedFields() throws Exception {\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\").field(\"lat_lon\", true)\n                .startObject(\"fielddata\").field(\"format\", randomNumericFieldDataFormat()).endObject().endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()), \n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\").setNestedPath(\"branches\")\n                            .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\").setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":51728,"modified_method":"@Test\n    public void testDistanceSortingNestedFields() throws Exception {\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\").field(\"lat_lon\", true)\n                .startObject(\"fielddata\").field(\"format\", randomNumericFieldDataFormat()).endObject().endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()), \n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\").setNestedPath(\"branches\")\n                            .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\").setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"sum\").setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.queryParserService().getIndexCreatedVersion().before(Version.V_2_0_0);\n        boolean coerce = false;\n        boolean ignoreMalformed = false;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        // TODO: remove this in master, we should be explicit when we want to sort on nested fields and don't do anything automatically\n        if (nestedHelper == null || nestedHelper.getNestedObjectMapper() == null) {\n            ObjectMapper objectMapper = context.mapperService().resolveClosestNestedObjectMapper(fieldName);\n            if (objectMapper != null && objectMapper.nested().isNested()) {\n                if (nestedHelper == null) {\n                    nestedHelper = new NestedInnerQueryParseSupport(context.queryParserService().getParseContext());\n                }\n                nestedHelper.setPath(objectMapper.fullPath());\n            }\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            \n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Filter innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = new QueryWrapperFilter(nestedHelper.getInnerFilter());\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, innerDocumentsFilter);\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSet innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","id":51729,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.queryParserService().getIndexCreatedVersion().before(Version.V_2_0_0);\n        boolean coerce = false;\n        boolean ignoreMalformed = false;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            \n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Filter innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = new QueryWrapperFilter(nestedHelper.getInnerFilter());\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, innerDocumentsFilter);\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSet innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    // https://github.com/elasticsearch/elasticsearch/issues/9305\n    public void testNestedSortingWithNestedFilterAsFilter() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type\", jsonBuilder().startObject().startObject(\"properties\")\n                .startObject(\"officelocation\").field(\"type\", \"string\").endObject()\n                .startObject(\"users\")\n                    .field(\"type\", \"nested\")\n                    .startObject(\"properties\")\n                        .startObject(\"first\").field(\"type\", \"string\").endObject()\n                        .startObject(\"last\").field(\"type\", \"string\").endObject()\n                        .startObject(\"workstations\")\n                            .field(\"type\", \"nested\")\n                            .startObject(\"properties\")\n                                .startObject(\"stationid\").field(\"type\", \"string\").endObject()\n                                .startObject(\"phoneid\").field(\"type\", \"string\").endObject()\n                            .endObject()\n                        .endObject()\n                    .endObject()\n                .endObject()\n                .endObject().endObject()));\n\n        client().prepareIndex(\"test\", \"type\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"officelocation\", \"gendale\")\n                .startArray(\"users\")\n                    .startObject()\n                        .field(\"first\", \"fname1\")\n                        .field(\"last\", \"lname1\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s1\")\n                                .field(\"phoneid\", \"p1\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s2\")\n                                .field(\"phoneid\", \"p2\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                    .startObject()\n                        .field(\"first\", \"fname2\")\n                        .field(\"last\", \"lname2\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s3\")\n                                .field(\"phoneid\", \"p3\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s4\")\n                                .field(\"phoneid\", \"p4\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                    .startObject()\n                        .field(\"first\", \"fname3\")\n                        .field(\"last\", \"lname3\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s5\")\n                                .field(\"phoneid\", \"p5\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s6\")\n                                .field(\"phoneid\", \"p6\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                .endArray()\n                .endObject()).get();\n\n        client().prepareIndex(\"test\", \"type\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"officelocation\", \"gendale\")\n                .startArray(\"users\")\n                    .startObject()\n                    .field(\"first\", \"fname4\")\n                    .field(\"last\", \"lname4\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s1\")\n                            .field(\"phoneid\", \"p1\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s2\")\n                            .field(\"phoneid\", \"p2\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                    .startObject()\n                    .field(\"first\", \"fname5\")\n                    .field(\"last\", \"lname5\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s3\")\n                            .field(\"phoneid\", \"p3\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s4\")\n                            .field(\"phoneid\", \"p4\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                    .startObject()\n                    .field(\"first\", \"fname1\")\n                    .field(\"last\", \"lname1\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s5\")\n                            .field(\"phoneid\", \"p5\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s6\")\n                            .field(\"phoneid\", \"p6\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                .endArray()\n                .endObject()).get();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .addSort(SortBuilders.fieldSort(\"users.first\")\n                        .order(SortOrder.ASC))\n                .addSort(SortBuilders.fieldSort(\"users.first\")\n                        .order(SortOrder.ASC)\n                        .setNestedPath(\"users\")\n                        .setNestedFilter(nestedQuery(\"users.workstations\", termQuery(\"users.workstations.stationid\", \"s5\"))))\n                .get();\n        assertNoFailures(searchResponse);\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getAt(0).sortValues()[0].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(0).sortValues()[1].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(1).id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getAt(1).sortValues()[0].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(1).sortValues()[1].toString(), equalTo(\"fname3\"));\n    }","id":51730,"modified_method":"@Test\n    // https://github.com/elasticsearch/elasticsearch/issues/9305\n    public void testNestedSortingWithNestedFilterAsFilter() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type\", jsonBuilder().startObject().startObject(\"properties\")\n                .startObject(\"officelocation\").field(\"type\", \"string\").endObject()\n                .startObject(\"users\")\n                    .field(\"type\", \"nested\")\n                    .startObject(\"properties\")\n                        .startObject(\"first\").field(\"type\", \"string\").endObject()\n                        .startObject(\"last\").field(\"type\", \"string\").endObject()\n                        .startObject(\"workstations\")\n                            .field(\"type\", \"nested\")\n                            .startObject(\"properties\")\n                                .startObject(\"stationid\").field(\"type\", \"string\").endObject()\n                                .startObject(\"phoneid\").field(\"type\", \"string\").endObject()\n                            .endObject()\n                        .endObject()\n                    .endObject()\n                .endObject()\n                .endObject().endObject()));\n\n        client().prepareIndex(\"test\", \"type\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"officelocation\", \"gendale\")\n                .startArray(\"users\")\n                    .startObject()\n                        .field(\"first\", \"fname1\")\n                        .field(\"last\", \"lname1\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s1\")\n                                .field(\"phoneid\", \"p1\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s2\")\n                                .field(\"phoneid\", \"p2\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                    .startObject()\n                        .field(\"first\", \"fname2\")\n                        .field(\"last\", \"lname2\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s3\")\n                                .field(\"phoneid\", \"p3\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s4\")\n                                .field(\"phoneid\", \"p4\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                    .startObject()\n                        .field(\"first\", \"fname3\")\n                        .field(\"last\", \"lname3\")\n                        .startArray(\"workstations\")\n                            .startObject()\n                                .field(\"stationid\", \"s5\")\n                                .field(\"phoneid\", \"p5\")\n                            .endObject()\n                            .startObject()\n                                .field(\"stationid\", \"s6\")\n                                .field(\"phoneid\", \"p6\")\n                            .endObject()\n                        .endArray()\n                    .endObject()\n                .endArray()\n                .endObject()).get();\n\n        client().prepareIndex(\"test\", \"type\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"officelocation\", \"gendale\")\n                .startArray(\"users\")\n                    .startObject()\n                    .field(\"first\", \"fname4\")\n                    .field(\"last\", \"lname4\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s1\")\n                            .field(\"phoneid\", \"p1\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s2\")\n                            .field(\"phoneid\", \"p2\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                    .startObject()\n                    .field(\"first\", \"fname5\")\n                    .field(\"last\", \"lname5\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s3\")\n                            .field(\"phoneid\", \"p3\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s4\")\n                            .field(\"phoneid\", \"p4\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                    .startObject()\n                    .field(\"first\", \"fname1\")\n                    .field(\"last\", \"lname1\")\n                    .startArray(\"workstations\")\n                        .startObject()\n                            .field(\"stationid\", \"s5\")\n                            .field(\"phoneid\", \"p5\")\n                        .endObject()\n                        .startObject()\n                            .field(\"stationid\", \"s6\")\n                            .field(\"phoneid\", \"p6\")\n                        .endObject()\n                    .endArray()\n                    .endObject()\n                .endArray()\n                .endObject()).get();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .addSort(SortBuilders.fieldSort(\"users.first\")\n                        .setNestedPath(\"users\")\n                        .order(SortOrder.ASC))\n                .addSort(SortBuilders.fieldSort(\"users.first\")\n                        .order(SortOrder.ASC)\n                        .setNestedPath(\"users\")\n                        .setNestedFilter(nestedQuery(\"users.workstations\", termQuery(\"users.workstations.stationid\", \"s5\"))))\n                .get();\n        assertNoFailures(searchResponse);\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getAt(0).sortValues()[0].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(0).sortValues()[1].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(1).id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getAt(1).sortValues()[0].toString(), equalTo(\"fname1\"));\n        assertThat(searchResponse.getHits().getAt(1).sortValues()[1].toString(), equalTo(\"fname3\"));\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleNestedSorting() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(indexSettings())\n                        .put(\"index.refresh_interval\", -1))\n                .addMapping(\"type1\", jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                        .startObject(\"nested1\")\n                        .field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"field1\")\n                        .field(\"type\", \"long\")\n                        .field(\"store\", \"yes\")\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject().endObject().endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 1)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 5)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 2)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 1)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 2)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 3)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 3)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"4\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value + 1\"), \"number\").setNestedPath(\"nested1\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"6.0\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"5.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"3.0\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value + 1\"), \"number\").setNestedPath(\"nested1\")\n                                .sortMode(\"sum\").order(SortOrder.DESC)).execute().actionGet();\n\n        // B/c of sum it is actually +2\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"11.0\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"9.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"5.0\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"number\")\n                                .setNestedFilter(rangeQuery(\"nested1.field1\").from(1).to(3)).setNestedPath(\"nested1\").sortMode(\"avg\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(Double.toString(Double.MAX_VALUE)));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"1.5\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                .order(SortOrder.ASC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"4\"));\n\n        try {\n            client().prepareSearch(\"test\")\n                    .setTypes(\"type1\")\n                    .setQuery(QueryBuilders.matchAllQuery())\n                    .addSort(\n                            SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                    .sortMode(\"sum\").order(SortOrder.ASC)).execute().actionGet();\n            Assert.fail(\"SearchPhaseExecutionException should have been thrown\");\n        } catch (SearchPhaseExecutionException e) {\n            assertThat(e.toString(), containsString(\"type [string] doesn't support mode [SUM]\"));\n        }\n    }","id":51731,"modified_method":"@Test\n    public void testSimpleNestedSorting() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(indexSettings())\n                        .put(\"index.refresh_interval\", -1))\n                .addMapping(\"type1\", jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                        .startObject(\"nested1\")\n                        .field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"field1\")\n                        .field(\"type\", \"long\")\n                        .field(\"store\", \"yes\")\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject().endObject().endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 1)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 5)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 2)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 1)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 2)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 3)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 3)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").order(SortOrder.ASC).setNestedPath(\"nested1\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"4\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").order(SortOrder.DESC).setNestedPath(\"nested1\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value + 1\"), \"number\").setNestedPath(\"nested1\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"6.0\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"5.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"3.0\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value + 1\"), \"number\").setNestedPath(\"nested1\")\n                                .sortMode(\"sum\").order(SortOrder.DESC)).execute().actionGet();\n\n        // B/c of sum it is actually +2\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"11.0\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"9.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"5.0\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"number\")\n                                .setNestedFilter(rangeQuery(\"nested1.field1\").from(1).to(3)).setNestedPath(\"nested1\").sortMode(\"avg\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(Double.toString(Double.MAX_VALUE)));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3.0\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"1.5\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                .order(SortOrder.DESC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        searchResponse = client()\n                .prepareSearch(\"test\")\n                .setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(\n                        SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                .order(SortOrder.ASC)).execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"4\"));\n\n        try {\n            client().prepareSearch(\"test\")\n                    .setTypes(\"type1\")\n                    .setQuery(QueryBuilders.matchAllQuery())\n                    .addSort(\n                            SortBuilders.scriptSort(new Script(\"_fields['nested1.field1'].value\"), \"string\").setNestedPath(\"nested1\")\n                                    .sortMode(\"sum\").order(SortOrder.ASC)).execute().actionGet();\n            Assert.fail(\"SearchPhaseExecutionException should have been thrown\");\n        } catch (SearchPhaseExecutionException e) {\n            assertThat(e.toString(), containsString(\"type [string] doesn't support mode [SUM]\"));\n        }\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSortNestedWithNestedFilter() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type1\", XContentFactory.jsonBuilder().startObject()\n                        .startObject(\"type1\")\n                        .startObject(\"properties\")\n                        .startObject(\"grand_parent_values\").field(\"type\", \"long\").endObject()\n                        .startObject(\"parent\").field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"parent_values\").field(\"type\", \"long\").endObject()\n                        .startObject(\"child\").field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"child_values\").field(\"type\", \"long\").endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()));\n        ensureGreen();\n\n        // sum: 11\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(1)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 1l)\n                .startObject(\"parent\")\n                .field(\"filter\", false)\n                .field(\"parent_values\", 1l)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 1l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 1l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 6l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"filter\", true)\n                .field(\"parent_values\", 2l)\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", -1l)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 5l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n\n        // sum: 7\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(2)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 2l)\n                .startObject(\"parent\")\n                .field(\"filter\", false)\n                .field(\"parent_values\", 2l)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 2l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 2l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 4l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"parent_values\", 3l)\n                .field(\"filter\", true)\n                .startObject(\"child\")\n                .field(\"child_values\", -2l)\n                .field(\"filter\", false)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 3l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n\n        // sum: 2\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(3)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 3l)\n                .startObject(\"parent\")\n                .field(\"parent_values\", 3l)\n                .field(\"filter\", false)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 3l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 3l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 1l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"parent_values\", 4l)\n                .field(\"filter\", true)\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", -3l)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 1l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        // Without nested filter\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"-3\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"-2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"-1\"));\n\n        // With nested filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Nested path should be automatically detected, expect same results as above search request\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.parent_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.filter\", false))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.filter\", false))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        // TODO: If we expose ToChildBlockJoinQuery we can filter sort values based on a higher level nested objects\n//        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n//        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"-3\"));\n//        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n//        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"-2\"));\n//        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n//        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"-1\"));\n\n        // Check if closest nested type is resolved\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_obj.value\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Sort mode: sum\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"sum\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"7\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"11\"));\n\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"sum\")\n                                .order(SortOrder.DESC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"11\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"7\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        // Sort mode: sum with filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .sortMode(\"sum\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Sort mode: avg\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"avg\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"avg\")\n                                .order(SortOrder.DESC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"1\"));\n\n        // Sort mode: avg with filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .sortMode(\"avg\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n    }","id":51732,"modified_method":"@Test\n    public void testSortNestedWithNestedFilter() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type1\", XContentFactory.jsonBuilder().startObject()\n                        .startObject(\"type1\")\n                        .startObject(\"properties\")\n                        .startObject(\"grand_parent_values\").field(\"type\", \"long\").endObject()\n                        .startObject(\"parent\").field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"parent_values\").field(\"type\", \"long\").endObject()\n                        .startObject(\"child\").field(\"type\", \"nested\")\n                        .startObject(\"properties\")\n                        .startObject(\"child_values\").field(\"type\", \"long\").endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()\n                        .endObject()));\n        ensureGreen();\n\n        // sum: 11\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(1)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 1l)\n                .startObject(\"parent\")\n                .field(\"filter\", false)\n                .field(\"parent_values\", 1l)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 1l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 1l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 6l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"filter\", true)\n                .field(\"parent_values\", 2l)\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", -1l)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 5l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n\n        // sum: 7\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(2)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 2l)\n                .startObject(\"parent\")\n                .field(\"filter\", false)\n                .field(\"parent_values\", 2l)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 2l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 2l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 4l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"parent_values\", 3l)\n                .field(\"filter\", true)\n                .startObject(\"child\")\n                .field(\"child_values\", -2l)\n                .field(\"filter\", false)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 3l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n\n        // sum: 2\n        client().prepareIndex(\"test\", \"type1\", Integer.toString(3)).setSource(jsonBuilder().startObject()\n                .field(\"grand_parent_values\", 3l)\n                .startObject(\"parent\")\n                .field(\"parent_values\", 3l)\n                .field(\"filter\", false)\n                .startObject(\"child\")\n                .field(\"filter\", true)\n                .field(\"child_values\", 3l)\n                .startObject(\"child_obj\")\n                .field(\"value\", 3l)\n                .endObject()\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 1l)\n                .endObject()\n                .endObject()\n                .startObject(\"parent\")\n                .field(\"parent_values\", 4l)\n                .field(\"filter\", true)\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", -3l)\n                .endObject()\n                .startObject(\"child\")\n                .field(\"filter\", false)\n                .field(\"child_values\", 1l)\n                .endObject()\n                .endObject()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        // Without nested filter\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"-3\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"-2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"-1\"));\n\n        // With nested filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Nested path should be automatically detected, expect same results as above search request\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.parent_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.filter\", false))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.filter\", false))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        // TODO: If we expose ToChildBlockJoinQuery we can filter sort values based on a higher level nested objects\n//        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n//        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"-3\"));\n//        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n//        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"-2\"));\n//        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n//        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"-1\"));\n\n        // Check if closest nested type is resolved\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_obj.value\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Sort mode: sum\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"sum\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"7\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"11\"));\n\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"sum\")\n                                .order(SortOrder.DESC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"11\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"7\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n\n        // Sort mode: sum with filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .sortMode(\"sum\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        // Sort mode: avg\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"avg\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .sortMode(\"avg\")\n                                .order(SortOrder.DESC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"1\"));\n\n        // Sort mode: avg with filter\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.fieldSort(\"parent.child.child_values\")\n                                .setNestedPath(\"parent.child\")\n                                .setNestedFilter(QueryBuilders.termQuery(\"parent.child.filter\", true))\n                                .sortMode(\"avg\")\n                                .order(SortOrder.ASC)\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().getHits().length, equalTo(3));\n        assertThat(searchResponse.getHits().getHits()[0].getId(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().getHits()[1].getId(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[1].sortValues()[0].toString(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().getHits()[2].getId(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().getHits()[2].sortValues()[0].toString(), equalTo(\"3\"));\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleNestedSorting_withNestedFilterMissing() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(indexSettings())\n                        .put(\"index.referesh_interval\", -1))\n                .addMapping(\"type1\", jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                        .startObject(\"nested1\")\n                        .field(\"type\", \"nested\")\n                            .startObject(\"properties\")\n                                .startObject(\"field1\")\n                                    .field(\"type\", \"long\")\n                                .endObject()\n                                .startObject(\"field2\")\n                                    .field(\"type\", \"boolean\")\n                                .endObject()\n                            .endObject()\n                        .endObject()\n                        .endObject().endObject().endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 1)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 5)\n                .field(\"field2\", true)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .field(\"field2\", true)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 2)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 1)\n                .field(\"field2\", true)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 2)\n                .field(\"field2\", true)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        // Doc with missing nested docs if nested filter is used\n        refresh();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 3)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 3)\n                .field(\"field2\", false)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .field(\"field2\", false)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        SearchRequestBuilder searchRequestBuilder = client().prepareSearch(\"test\").setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").setNestedFilter(termQuery(\"nested1.field2\", true)).missing(10).order(SortOrder.ASC));\n\n        if (randomBoolean()) {\n            searchRequestBuilder.setScroll(\"10m\");\n        }\n\n        SearchResponse searchResponse = searchRequestBuilder.get();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"10\"));\n\n        searchRequestBuilder = client().prepareSearch(\"test\").setTypes(\"type1\").setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").setNestedFilter(termQuery(\"nested1.field2\", true)).missing(10).order(SortOrder.DESC));\n\n        if (randomBoolean()) {\n            searchRequestBuilder.setScroll(\"10m\");\n        }\n\n        searchResponse = searchRequestBuilder.get();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"10\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n        client().prepareClearScroll().addScrollId(\"_all\").get();\n    }","id":51733,"modified_method":"@Test\n    public void testSimpleNestedSorting_withNestedFilterMissing() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(indexSettings())\n                        .put(\"index.referesh_interval\", -1))\n                .addMapping(\"type1\", jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                        .startObject(\"nested1\")\n                        .field(\"type\", \"nested\")\n                            .startObject(\"properties\")\n                                .startObject(\"field1\")\n                                    .field(\"type\", \"long\")\n                                .endObject()\n                                .startObject(\"field2\")\n                                    .field(\"type\", \"boolean\")\n                                .endObject()\n                            .endObject()\n                        .endObject()\n                        .endObject().endObject().endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 1)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 5)\n                .field(\"field2\", true)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .field(\"field2\", true)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 2)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 1)\n                .field(\"field2\", true)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 2)\n                .field(\"field2\", true)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        // Doc with missing nested docs if nested filter is used\n        refresh();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", 3)\n                .startArray(\"nested1\")\n                .startObject()\n                .field(\"field1\", 3)\n                .field(\"field2\", false)\n                .endObject()\n                .startObject()\n                .field(\"field1\", 4)\n                .field(\"field2\", false)\n                .endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        SearchRequestBuilder searchRequestBuilder = client().prepareSearch(\"test\").setTypes(\"type1\")\n                .setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").setNestedPath(\"nested1\").setNestedFilter(termQuery(\"nested1.field2\", true)).missing(10).order(SortOrder.ASC));\n\n        if (randomBoolean()) {\n            searchRequestBuilder.setScroll(\"10m\");\n        }\n\n        SearchResponse searchResponse = searchRequestBuilder.get();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"4\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"10\"));\n\n        searchRequestBuilder = client().prepareSearch(\"test\").setTypes(\"type1\").setQuery(QueryBuilders.matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested1.field1\").setNestedPath(\"nested1\").setNestedFilter(termQuery(\"nested1.field2\", true)).missing(10).order(SortOrder.DESC));\n\n        if (randomBoolean()) {\n            searchRequestBuilder.setScroll(\"10m\");\n        }\n\n        searchResponse = searchRequestBuilder.get();\n\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits()[0].id(), equalTo(\"3\"));\n        assertThat(searchResponse.getHits().hits()[0].sortValues()[0].toString(), equalTo(\"10\"));\n        assertThat(searchResponse.getHits().hits()[1].id(), equalTo(\"1\"));\n        assertThat(searchResponse.getHits().hits()[1].sortValues()[0].toString(), equalTo(\"5\"));\n        assertThat(searchResponse.getHits().hits()[2].id(), equalTo(\"2\"));\n        assertThat(searchResponse.getHits().hits()[2].sortValues()[0].toString(), equalTo(\"2\"));\n        client().prepareClearScroll().addScrollId(\"_all\").get();\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Test case for issue 6150: https://github.com/elasticsearch/elasticsearch/issues/6150\n     */\n    @Test\n    public void testNestedSort() throws IOException, InterruptedException, ExecutionException {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type\",\n                        XContentFactory.jsonBuilder()\n                                .startObject()\n                                    .startObject(\"type\")\n                                        .startObject(\"properties\")\n                                            .startObject(\"nested\")\n                                                .field(\"type\", \"nested\")\n                                                .startObject(\"properties\")\n                                                    .startObject(\"foo\")\n                                                        .field(\"type\", \"string\")\n                                                        .startObject(\"fields\")\n                                                            .startObject(\"sub\")\n                                                                .field(\"type\", \"string\")\n                                                                .field(\"index\", \"not_analyzed\")\n                                                            .endObject()\n                                                        .endObject()\n                                                    .endObject()\n                                                .endObject()\n                                            .endObject()\n                                        .endObject()\n                                    .endObject()\n                                .endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type\", \"1\").setSource(jsonBuilder().startObject()\n                .startObject(\"nested\")\n                    .field(\"foo\", \"bar bar\")\n                .endObject()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        // We sort on nested field\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\"nested.foo\", SortOrder.DESC)\n                .execute().actionGet();\n        assertNoFailures(searchResponse);\n        SearchHit[] hits = searchResponse.getHits().hits();\n        for (int i = 0; i < hits.length; ++i) {\n            assertThat(hits[i].getSortValues().length, is(1));\n            Object o = hits[i].getSortValues()[0];\n            assertThat(o, notNullValue());\n            assertThat(o instanceof StringAndBytesText, is(true));\n            StringAndBytesText text = (StringAndBytesText) o;\n            assertThat(text.string(), is(\"bar\"));\n        }\n\n\n        // We sort on nested sub field\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(\"nested.foo.sub\", SortOrder.DESC)\n                .execute().actionGet();\n        assertNoFailures(searchResponse);\n        hits = searchResponse.getHits().hits();\n        for (int i = 0; i < hits.length; ++i) {\n            assertThat(hits[i].getSortValues().length, is(1));\n            Object o = hits[i].getSortValues()[0];\n            assertThat(o, notNullValue());\n            assertThat(o instanceof StringAndBytesText, is(true));\n            StringAndBytesText text = (StringAndBytesText) o;\n            assertThat(text.string(), is(\"bar bar\"));\n        }\n    }","id":51734,"modified_method":"/**\n     * Test case for issue 6150: https://github.com/elasticsearch/elasticsearch/issues/6150\n     */\n    @Test\n    public void testNestedSort() throws IOException, InterruptedException, ExecutionException {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type\",\n                        XContentFactory.jsonBuilder()\n                                .startObject()\n                                    .startObject(\"type\")\n                                        .startObject(\"properties\")\n                                            .startObject(\"nested\")\n                                                .field(\"type\", \"nested\")\n                                                .startObject(\"properties\")\n                                                    .startObject(\"foo\")\n                                                        .field(\"type\", \"string\")\n                                                        .startObject(\"fields\")\n                                                            .startObject(\"sub\")\n                                                                .field(\"type\", \"string\")\n                                                                .field(\"index\", \"not_analyzed\")\n                                                            .endObject()\n                                                        .endObject()\n                                                    .endObject()\n                                                .endObject()\n                                            .endObject()\n                                        .endObject()\n                                    .endObject()\n                                .endObject()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type\", \"1\").setSource(jsonBuilder().startObject()\n                .startObject(\"nested\")\n                    .field(\"foo\", \"bar bar\")\n                .endObject()\n                .endObject()).execute().actionGet();\n        refresh();\n\n        // We sort on nested field\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested.foo\").setNestedPath(\"nested\").order(SortOrder.DESC))\n                .execute().actionGet();\n        assertNoFailures(searchResponse);\n        SearchHit[] hits = searchResponse.getHits().hits();\n        for (int i = 0; i < hits.length; ++i) {\n            assertThat(hits[i].getSortValues().length, is(1));\n            Object o = hits[i].getSortValues()[0];\n            assertThat(o, notNullValue());\n            assertThat(o instanceof StringAndBytesText, is(true));\n            StringAndBytesText text = (StringAndBytesText) o;\n            assertThat(text.string(), is(\"bar\"));\n        }\n\n\n        // We sort on nested sub field\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(SortBuilders.fieldSort(\"nested.foo.sub\").setNestedPath(\"nested\").order(SortOrder.DESC))\n                .execute().actionGet();\n        assertNoFailures(searchResponse);\n        hits = searchResponse.getHits().hits();\n        for (int i = 0; i < hits.length; ++i) {\n            assertThat(hits[i].getSortValues().length, is(1));\n            Object o = hits[i].getSortValues()[0];\n            assertThat(o, notNullValue());\n            assertThat(o instanceof StringAndBytesText, is(true));\n            StringAndBytesText text = (StringAndBytesText) o;\n            assertThat(text.string(), is(\"bar bar\"));\n        }\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void addSortField(SearchContext context, List<SortField> sortFields, String fieldName, boolean reverse, String unmappedType, @Nullable final String missing, MultiValueMode sortMode, NestedInnerQueryParseSupport nestedHelper) throws IOException {\n        if (SCORE_FIELD_NAME.equals(fieldName)) {\n            if (reverse) {\n                sortFields.add(SORT_SCORE_REVERSE);\n            } else {\n                sortFields.add(SORT_SCORE);\n            }\n        } else if (DOC_FIELD_NAME.equals(fieldName)) {\n            if (reverse) {\n                sortFields.add(SORT_DOC_REVERSE);\n            } else {\n                sortFields.add(SORT_DOC);\n            }\n        } else {\n            MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n            if (fieldType == null) {\n                if (unmappedType != null) {\n                    fieldType = context.mapperService().unmappedFieldType(unmappedType);\n                } else {\n                    throw new SearchParseException(context, \"No mapping found for [\" + fieldName + \"] in order to sort on\", null);\n                }\n            }\n\n            if (!fieldType.isSortable()) {\n                throw new SearchParseException(context, \"Sorting not supported for field[\" + fieldName + \"]\", null);\n            }\n\n            // Enable when we also know how to detect fields that do tokenize, but only emit one token\n            /*if (fieldMapper instanceof StringFieldMapper) {\n                StringFieldMapper stringFieldMapper = (StringFieldMapper) fieldMapper;\n                if (stringFieldMapper.fieldType().tokenized()) {\n                    // Fail early\n                    throw new SearchParseException(context, \"Can't sort on tokenized string field[\" + fieldName + \"]\");\n                }\n            }*/\n\n            // We only support AVG and SUM on number based fields\n            if (fieldType.isNumeric() == false && (sortMode == MultiValueMode.SUM || sortMode == MultiValueMode.AVG)) {\n                sortMode = null;\n            }\n            if (sortMode == null) {\n                sortMode = resolveDefaultSortMode(reverse);\n            }\n\n            // TODO: remove this in master, we should be explicit when we want to sort on nested fields and don't do anything automatically\n            if (!(context instanceof SubSearchContext)) {\n                // Only automatically resolve nested path when sort isn't defined for top_hits\n                if (nestedHelper == null || nestedHelper.getNestedObjectMapper() == null) {\n                    ObjectMapper objectMapper = context.mapperService().resolveClosestNestedObjectMapper(fieldName);\n                    if (objectMapper != null && objectMapper.nested().isNested()) {\n                        if (nestedHelper == null) {\n                            nestedHelper = new NestedInnerQueryParseSupport(context.queryParserService().getParseContext());\n                        }\n                        nestedHelper.setPath(objectMapper.fullPath());\n                    }\n                }\n            }\n            final Nested nested;\n            if (nestedHelper != null && nestedHelper.getPath() != null) {\n                BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n                Filter innerDocumentsFilter;\n                if (nestedHelper.filterFound()) {\n                    // TODO: use queries instead\n                    innerDocumentsFilter = new QueryWrapperFilter(nestedHelper.getInnerFilter());\n                } else {\n                    innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n                }\n                nested = new Nested(rootDocumentsFilter, innerDocumentsFilter);\n            } else {\n                nested = null;\n            }\n\n            IndexFieldData.XFieldComparatorSource fieldComparatorSource = context.fieldData().getForField(fieldType)\n                    .comparatorSource(missing, sortMode, nested);\n            sortFields.add(new SortField(fieldType.names().indexName(), fieldComparatorSource, reverse));\n        }\n    }","id":51735,"modified_method":"private void addSortField(SearchContext context, List<SortField> sortFields, String fieldName, boolean reverse, String unmappedType, @Nullable final String missing, MultiValueMode sortMode, NestedInnerQueryParseSupport nestedHelper) throws IOException {\n        if (SCORE_FIELD_NAME.equals(fieldName)) {\n            if (reverse) {\n                sortFields.add(SORT_SCORE_REVERSE);\n            } else {\n                sortFields.add(SORT_SCORE);\n            }\n        } else if (DOC_FIELD_NAME.equals(fieldName)) {\n            if (reverse) {\n                sortFields.add(SORT_DOC_REVERSE);\n            } else {\n                sortFields.add(SORT_DOC);\n            }\n        } else {\n            MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n            if (fieldType == null) {\n                if (unmappedType != null) {\n                    fieldType = context.mapperService().unmappedFieldType(unmappedType);\n                } else {\n                    throw new SearchParseException(context, \"No mapping found for [\" + fieldName + \"] in order to sort on\", null);\n                }\n            }\n\n            if (!fieldType.isSortable()) {\n                throw new SearchParseException(context, \"Sorting not supported for field[\" + fieldName + \"]\", null);\n            }\n\n            // Enable when we also know how to detect fields that do tokenize, but only emit one token\n            /*if (fieldMapper instanceof StringFieldMapper) {\n                StringFieldMapper stringFieldMapper = (StringFieldMapper) fieldMapper;\n                if (stringFieldMapper.fieldType().tokenized()) {\n                    // Fail early\n                    throw new SearchParseException(context, \"Can't sort on tokenized string field[\" + fieldName + \"]\");\n                }\n            }*/\n\n            // We only support AVG and SUM on number based fields\n            if (fieldType.isNumeric() == false && (sortMode == MultiValueMode.SUM || sortMode == MultiValueMode.AVG)) {\n                sortMode = null;\n            }\n            if (sortMode == null) {\n                sortMode = resolveDefaultSortMode(reverse);\n            }\n\n            final Nested nested;\n            if (nestedHelper != null && nestedHelper.getPath() != null) {\n                BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n                Filter innerDocumentsFilter;\n                if (nestedHelper.filterFound()) {\n                    // TODO: use queries instead\n                    innerDocumentsFilter = new QueryWrapperFilter(nestedHelper.getInnerFilter());\n                } else {\n                    innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n                }\n                nested = new Nested(rootDocumentsFilter, innerDocumentsFilter);\n            } else {\n                nested = null;\n            }\n\n            IndexFieldData.XFieldComparatorSource fieldComparatorSource = context.fieldData().getForField(fieldType)\n                    .comparatorSource(missing, sortMode, nested);\n            sortFields.add(new SortField(fieldType.names().indexName(), fieldComparatorSource, reverse));\n        }\n    }","commit_id":"2eadc6d5958a88187692e3514428413d9ffef508","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"activity\")\n      .setInternal(true)\n      .setResponseExample(getClass().getResource(\"activity-example.json\"))\n      .setHandler(this);\n    action.createParam(PARAM_COMPONENT_UUID)\n      .setDescription(\"Optional id of the component (project) to filter on\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_03);\n    action.createParam(PARAM_COMPONENT_QUERY)\n      .setDescription(format(\"Optional search by component name or key. Must not be set together with %s\", PARAM_COMPONENT_UUID))\n      .setExampleValue(\"Apache\");\n    action.createParam(PARAM_STATUS)\n      .setDescription(\"Optional filter on task status\")\n      .setPossibleValues(CeActivityDto.Status.values());\n    action.createParam(PARAM_ONLY_CURRENTS)\n      .setDescription(\"Optional filter on the current activities (only the most recent task by project)\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n    action.createParam(PARAM_TYPE)\n      .setDescription(\"Optional filter on task type\")\n      .setExampleValue(CeTaskTypes.REPORT);\n    action.createParam(PARAM_MIN_SUBMITTED_AT)\n      .setDescription(\"Optional filter on minimum date of task submission\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.createParam(PARAM_MAX_EXECUTED_AT)\n      .setDescription(\"Optional filter on the maximum date of end of task processing\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.addPagingParams(10);\n  }","id":51736,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"activity\")\n      .setInternal(true)\n      .setDescription(format(\"Search for past task executions. Requires the system administration permission, \" +\n        \"or project administration permission if %s is set.\", PARAM_COMPONENT_UUID))\n      .setResponseExample(getClass().getResource(\"activity-example.json\"))\n      .setHandler(this)\n      .setSince(\"5.2\");\n    action.createParam(PARAM_COMPONENT_UUID)\n      .setDescription(\"Optional id of the component (project) to filter on\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_03);\n    action.createParam(PARAM_COMPONENT_QUERY)\n      .setDescription(format(\"Optional search by component name or key. Must not be set together with %s.\", PARAM_COMPONENT_UUID))\n      .setExampleValue(\"Apache\");\n    action.createParam(PARAM_STATUS)\n      .setDescription(\"Optional filter on task status\")\n      .setPossibleValues(CeActivityDto.Status.values());\n    action.createParam(PARAM_ONLY_CURRENTS)\n      .setDescription(\"Optional filter on the current activities (only the most recent task by project)\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n    action.createParam(PARAM_TYPE)\n      .setDescription(\"Optional filter on task type\")\n      .setExampleValue(CeTaskTypes.REPORT);\n    action.createParam(PARAM_MIN_SUBMITTED_AT)\n      .setDescription(\"Optional filter on minimum date of task submission\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.createParam(PARAM_MAX_EXECUTED_AT)\n      .setDescription(\"Optional filter on the maximum date of end of task processing\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.addPagingParams(10);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    controller.createAction(\"cancel_all\")\n      .setDescription(\"Cancels all pending task. Requires system administration permission.\")\n      .setInternal(true)\n      .setPost(true)\n      .setHandler(this);\n  }","id":51737,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    controller.createAction(\"cancel_all\")\n      .setDescription(\"Cancels all pending tasks. Requires system administration permission. In-progress tasks are not canceled.\")\n      .setInternal(true)\n      .setPost(true)\n      .setSince(\"5.2\")\n      .setHandler(this);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"cancel\")\n      .setDescription(\"Cancels a pending task. Requires system administration permission.\")\n      .setInternal(true)\n      .setPost(true)\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_ID)\n      .setRequired(true)\n      .setDescription(\"Id of the task to cancel.\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","id":51738,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"cancel\")\n      .setDescription(\"Cancels a pending task. Requires system administration permission. In-progress tasks can not be canceled.\")\n      .setInternal(true)\n      .setPost(true)\n      .setSince(\"5.2\")\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_ID)\n      .setRequired(true)\n      .setDescription(\"Id of the task to cancel.\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"component\")\n      .setDescription(\"Get the pending and last executed tasks of a given component (usually a project)\")\n      .setInternal(true)\n      .setResponseExample(getClass().getResource(\"component-example.json\"))\n      .setHandler(this);\n\n    action.createParam(PARAM_COMPONENT_UUID)\n      .setRequired(true)\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","id":51739,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"component\")\n      .setDescription(\"Get the pending tasks, in-progress tasks and the last executed task of a given component \" +\n        \"(usually a project). Requires the administration permission on the component.\")\n      .setInternal(true)\n      .setSince(\"5.2\")\n      .setResponseExample(getClass().getResource(\"component-example.json\"))\n      .setHandler(this);\n\n    action.createParam(PARAM_COMPONENT_UUID)\n      .setRequired(true)\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(API_ENDPOINT)\n      .setDescription(\"Analysis reports processed\");\n    action.define(controller);\n    controller.done();\n  }","id":51740,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(API_ENDPOINT)\n      .setDescription(\"For internal testing - do not use\");\n    action.define(controller);\n    controller.done();\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .setDescription(\"Logs of a task. Returns HTTP code 404 if task does not \" +\n        \"exist or if logs are not available. Requires system administration permission.\")\n      .setInternal(true)\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_UUID)\n      .setRequired(true)\n      .setDescription(\"Id of task\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","id":51741,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .setDescription(\"Logs of a task. Format of response is plain text. HTTP code 404 is returned if the task does not \" +\n        \"exist or if logs are not available. Requires system administration permission.\")\n      .setInternal(true)\n      .setSince(\"5.2\")\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_UUID)\n      .setRequired(true)\n      .setDescription(\"Id of task\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"queue\")\n      .setDescription(\"Gets the tasks of the Compute Engine queue\")\n      .setInternal(true)\n      .setResponseExample(getClass().getResource(\"queue-example.json\"))\n      .setHandler(this);\n\n    action.createParam(PARAM_COMPONENT_UUID);\n  }","id":51742,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"queue\")\n      .setDescription(\"Gets the pending and in-progress tasks. Requires system administration permission.\")\n      .setInternal(true)\n      .setSince(\"5.2\")\n      .setResponseExample(getClass().getResource(\"queue-example.json\"))\n      .setHandler(this);\n\n    action.createParam(PARAM_COMPONENT_UUID);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    String componentUuid = wsRequest.param(PARAM_COMPONENT_UUID);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<CeQueueDto> dtos;\n      if (componentUuid == null) {\n        // no filters\n        userSession.checkGlobalPermission(UserRole.ADMIN);\n        dtos = dbClient.ceQueueDao().selectAllInAscOrder(dbSession);\n      } else {\n        // filter by component\n        if (userSession.hasGlobalPermission(GlobalPermissions.SYSTEM_ADMIN) || userSession.hasComponentUuidPermission(UserRole.ADMIN, componentUuid)) {\n          dtos = dbClient.ceQueueDao().selectByComponentUuid(dbSession, componentUuid);\n        } else {\n          throw new ForbiddenException(\"Requires administration permission\");\n        }\n      }\n\n      WsCe.QueueResponse.Builder wsResponseBuilder = WsCe.QueueResponse.newBuilder();\n      wsResponseBuilder.addAllTasks(formatter.formatQueue(dbSession, dtos));\n      WsUtils.writeProtobuf(wsResponseBuilder.build(), wsRequest, wsResponse);\n\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":51743,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    String componentUuid = wsRequest.param(PARAM_COMPONENT_UUID);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<CeQueueDto> dtos;\n      if (componentUuid == null) {\n        // no filters\n        userSession.checkGlobalPermission(UserRole.ADMIN);\n        dtos = dbClient.ceQueueDao().selectAllInAscOrder(dbSession);\n      } else {\n        // filter by component\n        if (userSession.hasGlobalPermission(GlobalPermissions.SYSTEM_ADMIN) || userSession.hasComponentUuidPermission(UserRole.ADMIN, componentUuid)) {\n          dtos = dbClient.ceQueueDao().selectByComponentUuid(dbSession, componentUuid);\n        } else {\n          throw new ForbiddenException(\"Requires system administration permission\");\n        }\n      }\n\n      WsCe.QueueResponse.Builder wsResponseBuilder = WsCe.QueueResponse.newBuilder();\n      wsResponseBuilder.addAllTasks(formatter.formatQueue(dbSession, dtos));\n      WsUtils.writeProtobuf(wsResponseBuilder.build(), wsRequest, wsResponse);\n\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"submit\")\n      .setDescription(\"Submit an analysis report to the queue of Compute Engine. Report is processed asynchronously.\")\n      .setPost(true)\n      .setInternal(true)\n      .setHandler(this)\n      .setResponseExample(getClass().getResource(\"submit-example.json\"));\n\n    action\n      .createParam(PARAM_PROJECT_KEY)\n      .setRequired(true)\n      .setDescription(\"Key of project\")\n      .setExampleValue(\"my_project\");\n\n    action\n      .createParam(PARAM_PROJECT_BRANCH)\n      .setDescription(\"Optional branch of project\")\n      .setExampleValue(\"branch-1.x\");\n\n    action\n      .createParam(PARAM_PROJECT_NAME)\n      .setRequired(false)\n      .setDescription(\"Optional name of the project, used only if the project does not exist yet.\")\n      .setExampleValue(\"My Project\");\n\n    action\n      .createParam(PARAM_REPORT_DATA)\n      .setRequired(true)\n      .setDescription(\"Report file. Format is not an API, it changes among SonarQube versions.\");\n  }","id":51744,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"submit\")\n      .setDescription(\"Submits a scanner report to the queue. Report is processed asynchronously. Requires analysis permission. \" +\n        \"If the project does not exist, then the provisioning permission is also required.\")\n      .setPost(true)\n      .setInternal(true)\n      .setSince(\"5.2\")\n      .setHandler(this)\n      .setResponseExample(getClass().getResource(\"submit-example.json\"));\n\n    action\n      .createParam(PARAM_PROJECT_KEY)\n      .setRequired(true)\n      .setDescription(\"Key of project\")\n      .setExampleValue(\"my_project\");\n\n    action\n      .createParam(PARAM_PROJECT_BRANCH)\n      .setDescription(\"Optional branch of project\")\n      .setExampleValue(\"branch-1.x\");\n\n    action\n      .createParam(PARAM_PROJECT_NAME)\n      .setRequired(false)\n      .setDescription(\"Optional name of the project, used only if the project does not exist yet.\")\n      .setExampleValue(\"My Project\");\n\n    action\n      .createParam(PARAM_REPORT_DATA)\n      .setRequired(true)\n      .setDescription(\"Report file. Format is not an API, it changes among SonarQube versions.\");\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .setDescription(\"Task information\")\n      .setInternal(true)\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_UUID)\n      .setRequired(true)\n      .setDescription(\"Id of task\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","id":51745,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .setDescription(\"Task information\")\n      .setInternal(true)\n      .setResponseExample(getClass().getResource(\"task-example.json\"))\n      .setSince(\"5.2\")\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TASK_UUID)\n      .setRequired(true)\n      .setDescription(\"Id of task\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_01);\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void task_is_archived() throws Exception {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n\n    ComponentDto project = new ComponentDto().setUuid(\"PROJECT_1\").setName(\"Project One\").setKey(\"P1\");\n    dbTester.getDbClient().componentDao().insert(dbTester.getSession(), project);\n\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setUuid(\"TASK_1\");\n    queueDto.setComponentUuid(project.uuid());\n    CeActivityDto activityDto = new CeActivityDto(queueDto);\n    activityDto.setStatus(CeActivityDto.Status.FAILED);\n    activityDto.setExecutionTimeMs(500L);\n    dbTester.getDbClient().ceActivityDao().insert(dbTester.getSession(), activityDto);\n    dbTester.getSession().commit();\n\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MimeTypes.PROTOBUF)\n      .setParam(\"id\", \"TASK_1\")\n      .execute();\n\n    // verify the protobuf response\n    WsCe.TaskResponse taskResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.TaskResponse.PARSER);\n    assertThat(taskResponse.getTask().getId()).isEqualTo(\"TASK_1\");\n    assertThat(taskResponse.getTask().getStatus()).isEqualTo(WsCe.TaskStatus.FAILED);\n    assertThat(taskResponse.getTask().getComponentId()).isEqualTo(project.uuid());\n    assertThat(taskResponse.getTask().getComponentKey()).isEqualTo(project.key());\n    assertThat(taskResponse.getTask().getComponentName()).isEqualTo(project.name());\n    assertThat(taskResponse.getTask().getExecutionTimeMs()).isEqualTo(500L);\n    assertThat(taskResponse.getTask().getLogs()).isFalse();\n  }","id":51746,"modified_method":"@Test\n  public void task_is_archived() throws Exception {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n\n    ComponentDto project = new ComponentDto().setUuid(\"PROJECT_1\").setName(\"Project One\").setKey(\"P1\");\n    dbTester.getDbClient().componentDao().insert(dbTester.getSession(), project);\n\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setUuid(\"TASK_1\");\n    queueDto.setComponentUuid(project.uuid());\n    CeActivityDto activityDto = new CeActivityDto(queueDto);\n    activityDto.setStatus(CeActivityDto.Status.FAILED);\n    activityDto.setExecutionTimeMs(500L);\n    dbTester.getDbClient().ceActivityDao().insert(dbTester.getSession(), activityDto);\n    dbTester.commit();\n\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MimeTypes.PROTOBUF)\n      .setParam(\"id\", \"TASK_1\")\n      .execute();\n\n    WsCe.TaskResponse taskResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.TaskResponse.PARSER);\n    assertThat(taskResponse.getTask().getId()).isEqualTo(\"TASK_1\");\n    assertThat(taskResponse.getTask().getStatus()).isEqualTo(WsCe.TaskStatus.FAILED);\n    assertThat(taskResponse.getTask().getComponentId()).isEqualTo(project.uuid());\n    assertThat(taskResponse.getTask().getComponentKey()).isEqualTo(project.key());\n    assertThat(taskResponse.getTask().getComponentName()).isEqualTo(project.name());\n    assertThat(taskResponse.getTask().getExecutionTimeMs()).isEqualTo(500L);\n    assertThat(taskResponse.getTask().getLogs()).isFalse();\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void task_is_in_queue() throws Exception {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n\n    ComponentDto project = new ComponentDto().setUuid(\"PROJECT_1\").setName(\"Project One\").setKey(\"P1\");\n    dbTester.getDbClient().componentDao().insert(dbTester.getSession(), project);\n\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setUuid(\"TASK_1\");\n    queueDto.setComponentUuid(project.uuid());\n    queueDto.setStatus(CeQueueDto.Status.PENDING);\n    queueDto.setSubmitterLogin(\"john\");\n    dbTester.getDbClient().ceQueueDao().insert(dbTester.getSession(), queueDto);\n    dbTester.getSession().commit();\n\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MimeTypes.PROTOBUF)\n      .setParam(\"id\", \"TASK_1\")\n      .execute();\n\n    // verify the protobuf response\n    WsCe.TaskResponse taskResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.TaskResponse.PARSER);\n    assertThat(taskResponse.getTask().getId()).isEqualTo(\"TASK_1\");\n    assertThat(taskResponse.getTask().getStatus()).isEqualTo(WsCe.TaskStatus.PENDING);\n    assertThat(taskResponse.getTask().getSubmitterLogin()).isEqualTo(\"john\");\n    assertThat(taskResponse.getTask().getComponentId()).isEqualTo(project.uuid());\n    assertThat(taskResponse.getTask().getComponentKey()).isEqualTo(project.key());\n    assertThat(taskResponse.getTask().getComponentName()).isEqualTo(project.name());\n    assertThat(taskResponse.getTask().hasExecutionTimeMs()).isFalse();\n    assertThat(taskResponse.getTask().getLogs()).isFalse();\n  }","id":51747,"modified_method":"@Test\n  public void task_is_in_queue() throws Exception {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n\n    ComponentDto project = new ComponentDto().setUuid(\"PROJECT_1\").setName(\"Project One\").setKey(\"P1\");\n    dbTester.getDbClient().componentDao().insert(dbTester.getSession(), project);\n\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setUuid(\"TASK_1\");\n    queueDto.setComponentUuid(project.uuid());\n    queueDto.setStatus(CeQueueDto.Status.PENDING);\n    queueDto.setSubmitterLogin(\"john\");\n    dbTester.getDbClient().ceQueueDao().insert(dbTester.getSession(), queueDto);\n    dbTester.commit();\n\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MimeTypes.PROTOBUF)\n      .setParam(\"id\", \"TASK_1\")\n      .execute();\n\n    WsCe.TaskResponse taskResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.TaskResponse.PARSER);\n    assertThat(taskResponse.getTask().getId()).isEqualTo(\"TASK_1\");\n    assertThat(taskResponse.getTask().getStatus()).isEqualTo(WsCe.TaskStatus.PENDING);\n    assertThat(taskResponse.getTask().getSubmitterLogin()).isEqualTo(\"john\");\n    assertThat(taskResponse.getTask().getComponentId()).isEqualTo(project.uuid());\n    assertThat(taskResponse.getTask().getComponentKey()).isEqualTo(project.key());\n    assertThat(taskResponse.getTask().getComponentName()).isEqualTo(project.name());\n    assertThat(taskResponse.getTask().hasExecutionTimeMs()).isFalse();\n    assertThat(taskResponse.getTask().getLogs()).isFalse();\n  }","commit_id":"d67d7addd11df8cc7351273a3e60d098a20a1d55","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, AmbariException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = hh.handleRegistration(message);\n    LOG.debug(\"Sending registration response \" + response);\n    return response;\n  }","id":51748,"modified_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = null;\n    try {\n      response = hh.handleRegistration(message);\n      LOG.debug(\"Sending registration response \" + response);\n    } catch (AmbariException ex) {\n      response = new RegistrationResponse();\n      response.setResponseId(-1);\n      response.setResponseStatus(RegistrationStatus.FAILED);\n      response.setErrors(ex.getMessage());\n      return response;\n    }\n    return response;\n  }","commit_id":"6ccdcc836fb240fb99e0729dd1fdaa0b451dd8fb","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = null;\n    try {\n      response = hh.handleRegistration(message);\n      LOG.debug(\"Sending registration response \" + response);\n    } catch (AmbariException ex) {\n      response = new RegistrationResponse();\n      response.setResponseId(-1);\n      response.setResponseStatus(RegistrationStatus.FAILED);\n      response.setErrors(ex.getMessage());\n      return response;\n    }\n    return response;\n  }","id":51749,"modified_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, AmbariException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = hh.handleRegistration(message);\n    LOG.debug(\"Sending registration response \" + response);\n    return response;\n  }","commit_id":"cd7e9f623e901cf4037d03b9a1728fcd8a199f7a","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, AmbariException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = hh.handleRegistration(message);\n    LOG.debug(\"Sending registration response \" + response);\n    return response;\n  }","id":51750,"modified_method":"/**\n   * Register information about the host (Internal API to be used for\n   * Ambari Agent)\n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to register with the server.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.406.doc Error in register message format\n   * @response.representation.408.doc Request Timed out\n   * @param message Register message\n   * @throws InvalidStateTransitionException\n   * @throws AmbariException\n   * @throws Exception\n   */\n  @Path(\"register/{hostName}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON})\n  public RegistrationResponse register(Register message,\n      @Context HttpServletRequest req)\n      throws WebApplicationException, InvalidStateTransitionException {\n    /* Call into the heartbeat handler */\n\n    RegistrationResponse response = null;\n    try {\n      response = hh.handleRegistration(message);\n      LOG.debug(\"Sending registration response \" + response);\n    } catch (AmbariException ex) {\n      response = new RegistrationResponse();\n      response.setResponseId(-1);\n      response.setResponseStatus(RegistrationStatus.FAILED);\n      response.setExitstatus(1);\n      response.setLog(ex.getMessage());\n      return response;\n    }\n    return response;\n  }","commit_id":"7948bc4b42fc6b786849dd62b202cd886458af2a","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * Adds a segment header to the buffer and writes a segment to the segment\n     * store. This is done automatically (called from prepare) when there is not\n     * enough space for a record. It can also be called explicitly.\n     */\n    public synchronized void flush() {\n        if (length > 0) {\n            int refcount = segment.getRefCount();\n\n            int rootcount = roots.size();\n            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n            int blobrefcount = blobrefs.size();\n            buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\n            buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\n\n            length = align(\n                    refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                    16);\n\n            checkState(length <= buffer.length);\n\n            int pos = refcount * 16;\n            if (pos + length <= buffer.length) {\n                // the whole segment fits to the space *after* the referenced\n                // segment identifiers we've already written, so we can safely\n                // copy those bits ahead even if concurrent code is still\n                // reading from that part of the buffer\n                System.arraycopy(buffer, 0, buffer, buffer.length-length, pos);\n                pos += buffer.length - length;\n            } else {\n                // this might leave some empty space between the header and\n                // the record data, but this case only occurs when the\n                // segment is >252kB in size and the maximum overhead is <<4kB,\n                // which is acceptable\n                length = buffer.length;\n            }\n\n            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                int offset = entry.getKey().getOffset();\n                buffer[pos++] = (byte) entry.getValue().ordinal();\n                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            for (RecordId blobref : blobrefs) {\n                int offset = blobref.getOffset();\n                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            SegmentId id = segment.getSegmentId();\n            log.debug(\"Writing data segment {} ({} bytes)\", id, length);\n            store.writeSegment(id, buffer, buffer.length - length, length);\n\n            // Keep this segment in memory as it's likely to be accessed soon\n            ByteBuffer data;\n            if (buffer.length - length > 4096) {\n                data = ByteBuffer.allocate(length);\n                data.put(buffer, buffer.length - length, length);\n                data.rewind();\n            } else {\n                data = ByteBuffer.wrap(buffer, buffer.length - length, length);\n            }\n            tracker.setSegment(id, new Segment(tracker, id, data));\n\n            buffer = createNewBuffer(version);\n            roots.clear();\n            blobrefs.clear();\n            length = 0;\n            position = buffer.length;\n            segment = new Segment(tracker, buffer);\n            segment.getSegmentId().setSegment(segment);\n        }\n    }","id":51751,"modified_method":"/**\n     * Adds a segment header to the buffer and writes a segment to the segment\n     * store. This is done automatically (called from prepare) when there is not\n     * enough space for a record. It can also be called explicitly.\n     */\n    public void flush() {\n        // Id of the segment to be written in the file store. If the segment id\n        // is not null, a segment will be written outside of the synchronized\n        // block.\n        SegmentId segmentId = null;\n\n        // Buffer containing segment data, and offset and length to locate the\n        // segment data into the buffer. These variable will be initialized in\n        // the synchronized block.\n        byte[] segmentBuffer = null;\n        int segmentOffset = 0;\n        int segmentLength = 0;\n\n        synchronized (this) {\n            if (length > 0) {\n                int refcount = segment.getRefCount();\n\n                int rootcount = roots.size();\n                buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n                buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n                int blobrefcount = blobrefs.size();\n                buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\n                buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\n\n                length = align(\n                        refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                        16);\n\n                checkState(length <= buffer.length);\n\n                int pos = refcount * 16;\n                if (pos + length <= buffer.length) {\n                    // the whole segment fits to the space *after* the referenced\n                    // segment identifiers we've already written, so we can safely\n                    // copy those bits ahead even if concurrent code is still\n                    // reading from that part of the buffer\n                    System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\n                    pos += buffer.length - length;\n                } else {\n                    // this might leave some empty space between the header and\n                    // the record data, but this case only occurs when the\n                    // segment is >252kB in size and the maximum overhead is <<4kB,\n                    // which is acceptable\n                    length = buffer.length;\n                }\n\n                for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                    int offset = entry.getKey().getOffset();\n                    buffer[pos++] = (byte) entry.getValue().ordinal();\n                    buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                    buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n                }\n\n                for (RecordId blobref : blobrefs) {\n                    int offset = blobref.getOffset();\n                    buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                    buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n                }\n\n                segmentId = segment.getSegmentId();\n                segmentBuffer = buffer;\n                segmentOffset = buffer.length - length;\n                segmentLength = length;\n\n                // Keep this segment in memory as it's likely to be accessed soon\n                ByteBuffer data;\n                if (buffer.length - length > 4096) {\n                    data = ByteBuffer.allocate(length);\n                    data.put(buffer, buffer.length - length, length);\n                    data.rewind();\n                } else {\n                    data = ByteBuffer.wrap(buffer, buffer.length - length, length);\n                }\n                tracker.setSegment(segmentId, new Segment(tracker, segmentId, data));\n\n                buffer = createNewBuffer(version);\n                roots.clear();\n                blobrefs.clear();\n                length = 0;\n                position = buffer.length;\n                segment = new Segment(tracker, buffer);\n                segment.getSegmentId().setSegment(segment);\n            }\n        }\n\n        if (segmentId != null) {\n            log.debug(\"Writing data segment {} ({} bytes)\", segmentId, segmentLength);\n            store.writeSegment(segmentId, segmentBuffer, segmentOffset, segmentLength);\n        }\n    }","commit_id":"5a0d9da75eca6c15b6e367782c9106f610837ad8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"SegmentId getRefId(int refid) {\r\n        if (refid == 0) {\r\n            return id;\r\n        } else {\r\n            int refpos = data.position() + refid * 16;\r\n            long msb = data.getLong(refpos);\r\n            long lsb = data.getLong(refpos + 8);\r\n            return tracker.getSegmentId(msb, lsb);\r\n        }\r\n    }","id":51752,"modified_method":"SegmentId getRefId(int index) {\r\n        SegmentId refid = refids[index];\r\n        if (refid == null) {\r\n            synchronized (this) {\r\n                refid = refids[index];\r\n                if (refid == null) {\r\n                    int refpos = data.position() + index * 16;\r\n                    long msb = data.getLong(refpos);\r\n                    long lsb = data.getLong(refpos + 8);\r\n                    refid = tracker.getSegmentId(msb, lsb);\r\n                    refids[index] = refid;\r\n                }\r\n            }\r\n        }\r\n        return refid;\r\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentId getSegmentId() {\r\n        return id;\r\n    }","id":51753,"modified_method":"public SegmentId getSegmentId() {\r\n        return refids[0];\r\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Segment(SegmentTracker tracker, SegmentId id, ByteBuffer data) {\r\n        this.tracker = checkNotNull(tracker);\r\n        this.id = checkNotNull(id);\r\n        this.data = checkNotNull(data);\r\n    }","id":51754,"modified_method":"public Segment(SegmentTracker tracker, SegmentId id, ByteBuffer data) {\r\n        this.tracker = checkNotNull(tracker);\r\n        this.id = checkNotNull(id);\r\n        this.data = checkNotNull(data);\r\n\r\n        if (id.isDataSegmentId()) {\r\n            this.refids = new SegmentId[getRefCount()];\r\n            refids[0] = id;\r\n        } else {\r\n            this.refids = null;\r\n        }\r\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public long getCacheSize() {\r\n        if (data.isDirect()) {\r\n            return 1024 + data.remaining();\r\n        } else {\r\n            return 1024 + 2 * data.remaining();\r\n        }\r\n    }","id":51755,"modified_method":"public long getCacheSize() {\r\n        int size = 1024;\r\n        if (!data.isDirect()) {\r\n            size += size();\r\n        }\r\n        if (id.isDataSegmentId()) {\r\n            size += size();\r\n        }\r\n        return size;\r\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentTracker(SegmentStore store, int cacheSizeMB) {\n        this.store = store;\n        this.writer = new SegmentWriter(store, this);\n        this.cacheSize = cacheSizeMB * MB;\n    }","id":51756,"modified_method":"public SegmentTracker(SegmentStore store, int cacheSizeMB) {\n        for (int i = 0; i < tables.length; i++) {\n            tables[i] = new SegmentIdTable(this);\n        }\n\n        this.store = store;\n        this.writer = new SegmentWriter(store, this);\n        this.cacheSize = cacheSizeMB * MB;\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns all segment identifiers that are currently referenced in memory.\n     *\n     * @return referenced segment identifiers\n     */\n    public synchronized Set<SegmentId> getReferencedSegmentIds() {\n        Set<SegmentId> set = newHashSetWithExpectedSize(uuids.size());\n\n        for (int i = 0; i < uuids.size(); i++) {\n            List<WeakReference<SegmentId>> list = uuids.get(i);\n            if (list != null) {\n                Iterator<WeakReference<SegmentId>> iterator = list.iterator();\n                while (iterator.hasNext()) {\n                    SegmentId id = iterator.next().get();\n                    if (id == null) {\n                        iterator.remove();\n                    } else {\n                        set.add(id);\n                    }\n                }\n                if (list.isEmpty()) {\n                    uuids.set(i, null);\n                }\n            }\n        }\n\n        return set;\n    }","id":51757,"modified_method":"/**\n     * Returns all segment identifiers that are currently referenced in memory.\n     *\n     * @return referenced segment identifiers\n     */\n    public synchronized Set<SegmentId> getReferencedSegmentIds() {\n        Set<SegmentId> ids = newHashSet();\n        for (SegmentIdTable table : tables) {\n            table.collectReferencedIds(ids);\n        }\n        return ids;\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * \n     * @param msb\n     * @param lsb\n     * @return\n     */\n    public synchronized SegmentId getSegmentId(long msb, long lsb) {\n        int index = ((int) lsb) & (uuids.size() - 1);\n\n        List<WeakReference<SegmentId>> list = uuids.get(index);\n        if (list == null) {\n            list = newLinkedList();\n            uuids.set(index, list);\n        }\n\n        Iterator<WeakReference<SegmentId>> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            SegmentId id = iterator.next().get();\n            if (id == null) {\n                iterator.remove();\n            } else if (id.equals(msb, lsb)) {\n                return id;\n            }\n        }\n\n        SegmentId id = new SegmentId(this, msb, lsb);\n        list.add(new WeakReference<SegmentId>(id));\n\n        if (list.size() > 5) {\n            expand();\n        }\n\n        return id;\n    }","id":51758,"modified_method":"/**\n     * \n     * @param msb\n     * @param lsb\n     * @return\n     */\n    public SegmentId getSegmentId(long msb, long lsb) {\n        int index = ((int) msb) & (tables.length - 1);\n        return tables[index].getSegmentId(msb, lsb);\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentWriter(SegmentStore store, SegmentTracker tracker) {\n        this.store = store;\n        this.tracker = tracker;\n        this.segment = new Segment(\n                tracker, tracker.newDataSegmentId(), ByteBuffer.wrap(buffer));\n        segment.getSegmentId().setSegment(segment);\n    }","id":51759,"modified_method":"public SegmentWriter(SegmentStore store, SegmentTracker tracker) {\n        this.store = store;\n        this.tracker = tracker;\n        this.segment = new Segment(tracker, buffer);\n        segment.getSegmentId().setSegment(segment);\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public synchronized void flush() {\n        if (length > 0) {\n            int refcount = segment.getRefCount();\n            length += align(refcount * 16 + roots.size() * 3);\n\n            int rootcount = roots.size();\n            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n            int rootpos = refcount * 16;\n            if (length + rootpos > buffer.length) {\n                length = buffer.length;\n            } else {\n                System.arraycopy(\n                        buffer, 0,\n                        buffer, buffer.length-length, rootpos);\n                rootpos += buffer.length - length;\n            }\n\n            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                int offset = entry.getKey().getOffset();\n                buffer[rootpos++] = (byte) entry.getValue().ordinal();\n                buffer[rootpos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[rootpos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            store.writeSegment(\n                    segment.getSegmentId(),\n                    buffer, buffer.length - length, length);\n            segment.getSegmentId().setSegment(null);\n\n            buffer = createNewBuffer();\n            roots.clear();\n            length = 0;\n            position = buffer.length;\n            segment = new Segment(\n                    tracker, tracker.newDataSegmentId(),\n                    ByteBuffer.wrap(buffer));\n            segment.getSegmentId().setSegment(segment);\n        }\n    }","id":51760,"modified_method":"public synchronized void flush() {\n        if (length > 0) {\n            int refcount = segment.getRefCount();\n            length += align(refcount * 16 + roots.size() * 3);\n\n            int rootcount = roots.size();\n            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n            int rootpos = refcount * 16;\n            if (length + rootpos > buffer.length) {\n                length = buffer.length;\n            } else {\n                System.arraycopy(\n                        buffer, 0,\n                        buffer, buffer.length-length, rootpos);\n                rootpos += buffer.length - length;\n            }\n\n            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                int offset = entry.getKey().getOffset();\n                buffer[rootpos++] = (byte) entry.getValue().ordinal();\n                buffer[rootpos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[rootpos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            store.writeSegment(\n                    segment.getSegmentId(),\n                    buffer, buffer.length - length, length);\n            segment.getSegmentId().setSegment(null);\n\n            buffer = createNewBuffer();\n            roots.clear();\n            length = 0;\n            position = buffer.length;\n            segment = new Segment(tracker, buffer);\n            segment.getSegmentId().setSegment(segment);\n        }\n    }","commit_id":"609e9836dd6244a1b268d639c64d0988595099ae","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void compactionNoBinaryClone() throws Exception {\n        // 2MB data, 5MB blob\n        final int blobSize = 5 * 1024 * 1024;\n        final int dataNodes = 10000;\n\n        // really long time span, no binary cloning\n\n        FileStore fileStore = new FileStore(directory, 1);\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(fileStore);\n        CompactionStrategy custom = new CompactionStrategy(false, false,\n                CLEAN_OLD, TimeUnit.HOURS.toMillis(1), (byte) 0) {\n            @Override\n            public boolean compacted(@Nonnull Callable<Boolean> setHead)\n                    throws Exception {\n                return nodeStore.locked(setHead);\n            }\n        };\n        // Use in memory compaction map as gains asserted later on\n        // do not take additional space of the compaction map into consideration\n        custom.setPersistCompactionMap(false);\n        fileStore.setCompactionStrategy(custom);\n\n        // 1a. Create a bunch of data\n        NodeBuilder extra = nodeStore.getRoot().builder();\n        NodeBuilder content = extra.child(\"content\");\n        for (int i = 0; i < dataNodes; i++) {\n            NodeBuilder c = content.child(\"c\" + i);\n            for (int j = 0; j < 1000; j++) {\n                c.setProperty(\"p\" + i, \"v\" + i);\n            }\n        }\n        nodeStore.merge(extra, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n        // ----\n\n        final long dataSize = fileStore.size();\n        log.debug(\"File store dataSize {}\", byteCountToDisplaySize(dataSize));\n\n        try {\n            // 1. Create a property with 5 MB blob\n            NodeBuilder builder = nodeStore.getRoot().builder();\n            builder.setProperty(\"a1\", createBlob(nodeStore, blobSize));\n            builder.setProperty(\"b\", \"foo\");\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            log.debug(\"File store pre removal {}, expecting {}\",\n                    byteCountToDisplaySize(fileStore.size()),\n                    byteCountToDisplaySize(blobSize + dataSize));\n            assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n            // 2. Now remove the property\n            builder = nodeStore.getRoot().builder();\n            builder.removeProperty(\"a1\");\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            // Size remains same, no cleanup happened yet\n            log.debug(\"File store pre compaction {}, expecting {}\",\n                    byteCountToDisplaySize(fileStore.size()),\n                    byteCountToDisplaySize(blobSize + dataSize));\n            assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n            // 3. Compact\n            assertTrue(fileStore.maybeCompact(false));\n\n            // Size doesn't shrink: ran compaction with a '1 Hour' cleanup\n            // strategy\n            assertSize(\"post compaction\", fileStore.size(),\n                    blobSize + dataSize, blobSize + 2 * dataSize);\n\n            // 4. Add some more property to flush the current TarWriter\n            builder = nodeStore.getRoot().builder();\n            builder.setProperty(\"a2\", createBlob(nodeStore, blobSize));\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            // Size is double\n            assertSize(\"pre cleanup\", fileStore.size(), 2 * blobSize\n                    + dataSize, 2 * blobSize + 2 * dataSize);\n\n            // 5. Cleanup, expecting store size:\n            // no data content =>\n            // fileStore.size() == blobSize\n            // some data content =>\n            // fileStore.size() in [blobSize + dataSize, blobSize + 2 x dataSize]\n            assertTrue(fileStore.maybeCompact(false));\n            fileStore.cleanup();\n            assertSize(\"post cleanup\", fileStore.size(), 0, blobSize + 2 * dataSize);\n\n            // refresh the ts ref, to simulate a long wait time\n            custom.setOlderThan(0);\n            TimeUnit.MILLISECONDS.sleep(5);\n\n            boolean needsCompaction = true;\n            for (int i = 0; i < 3 && needsCompaction; i++) {\n                needsCompaction = fileStore.maybeCompact(false);\n                fileStore.cleanup();\n            }\n\n            // gain is finally 0%\n            assertFalse(fileStore.maybeCompact(false));\n\n            // no data loss happened\n            byte[] blob = ByteStreams.toByteArray(nodeStore.getRoot()\n                    .getProperty(\"a2\").getValue(Type.BINARY).getNewStream());\n            assertEquals(blobSize, blob.length);\n        } finally {\n            fileStore.close();\n        }\n    }","id":51761,"modified_method":"@Test\n    public void compactionNoBinaryClone() throws Exception {\n        // 2MB data, 5MB blob\n        final int blobSize = 5 * 1024 * 1024;\n        final int dataNodes = 10000;\n\n        // really long time span, no binary cloning\n\n        FileStore fileStore = FileStore.newFileStore(directory)\n                .withMaxFileSize(1)\n                .create();\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(fileStore);\n        CompactionStrategy custom = new CompactionStrategy(false, false,\n                CLEAN_OLD, TimeUnit.HOURS.toMillis(1), (byte) 0) {\n            @Override\n            public boolean compacted(@Nonnull Callable<Boolean> setHead)\n                    throws Exception {\n                return nodeStore.locked(setHead);\n            }\n        };\n        // Use in memory compaction map as gains asserted later on\n        // do not take additional space of the compaction map into consideration\n        custom.setPersistCompactionMap(false);\n        fileStore.setCompactionStrategy(custom);\n\n        // 1a. Create a bunch of data\n        NodeBuilder extra = nodeStore.getRoot().builder();\n        NodeBuilder content = extra.child(\"content\");\n        for (int i = 0; i < dataNodes; i++) {\n            NodeBuilder c = content.child(\"c\" + i);\n            for (int j = 0; j < 1000; j++) {\n                c.setProperty(\"p\" + i, \"v\" + i);\n            }\n        }\n        nodeStore.merge(extra, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n        // ----\n\n        final long dataSize = fileStore.size();\n        log.debug(\"File store dataSize {}\", byteCountToDisplaySize(dataSize));\n\n        try {\n            // 1. Create a property with 5 MB blob\n            NodeBuilder builder = nodeStore.getRoot().builder();\n            builder.setProperty(\"a1\", createBlob(nodeStore, blobSize));\n            builder.setProperty(\"b\", \"foo\");\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            log.debug(\"File store pre removal {}, expecting {}\",\n                    byteCountToDisplaySize(fileStore.size()),\n                    byteCountToDisplaySize(blobSize + dataSize));\n            assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n            // 2. Now remove the property\n            builder = nodeStore.getRoot().builder();\n            builder.removeProperty(\"a1\");\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            // Size remains same, no cleanup happened yet\n            log.debug(\"File store pre compaction {}, expecting {}\",\n                    byteCountToDisplaySize(fileStore.size()),\n                    byteCountToDisplaySize(blobSize + dataSize));\n            assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n            // 3. Compact\n            assertTrue(fileStore.maybeCompact(false));\n\n            // Size doesn't shrink: ran compaction with a '1 Hour' cleanup\n            // strategy\n            assertSize(\"post compaction\", fileStore.size(),\n                    blobSize + dataSize, blobSize + 2 * dataSize);\n\n            // 4. Add some more property to flush the current TarWriter\n            builder = nodeStore.getRoot().builder();\n            builder.setProperty(\"a2\", createBlob(nodeStore, blobSize));\n            nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n            // Size is double\n            assertSize(\"pre cleanup\", fileStore.size(), 2 * blobSize\n                    + dataSize, 2 * blobSize + 2 * dataSize);\n\n            // 5. Cleanup, expecting store size:\n            // no data content =>\n            // fileStore.size() == blobSize\n            // some data content =>\n            // fileStore.size() in [blobSize + dataSize, blobSize + 2 x dataSize]\n            assertTrue(fileStore.maybeCompact(false));\n            fileStore.cleanup();\n            assertSize(\"post cleanup\", fileStore.size(), 0, blobSize + 2 * dataSize);\n\n            // refresh the ts ref, to simulate a long wait time\n            custom.setOlderThan(0);\n            TimeUnit.MILLISECONDS.sleep(5);\n\n            boolean needsCompaction = true;\n            for (int i = 0; i < 3 && needsCompaction; i++) {\n                needsCompaction = fileStore.maybeCompact(false);\n                fileStore.cleanup();\n            }\n\n            // gain is finally 0%\n            assertFalse(fileStore.maybeCompact(false));\n\n            // no data loss happened\n            byte[] blob = ByteStreams.toByteArray(nodeStore.getRoot()\n                    .getProperty(\"a2\").getValue(Type.BINARY).getNewStream());\n            assertEquals(blobSize, blob.length);\n        } finally {\n            fileStore.close();\n        }\n    }","commit_id":"8996f36c6ba7f69a3e1e1d8e5f6c3ae8b3516608","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Segment(SegmentTracker tracker, byte[] buffer) {\n        this.tracker = checkNotNull(tracker);\n        this.id = tracker.newDataSegmentId();\n        if (tracker.getStringCache() == null) {\n            strings = newConcurrentMap();\n            stringCache = null;\n        } else {\n            strings = null;\n            stringCache = tracker.getStringCache();\n        }\n        this.data = ByteBuffer.wrap(checkNotNull(buffer));\n        this.refids = new SegmentId[SEGMENT_REFERENCE_LIMIT + 1];\n        this.refids[0] = id;\n        this.version = SegmentVersion.fromByte(buffer[3]);\n    }","id":51762,"modified_method":"Segment(SegmentTracker tracker, byte[] buffer) {\n        this.tracker = checkNotNull(tracker);\n        this.id = tracker.newDataSegmentId();\n        if (tracker.getStringCache() == null) {\n            strings = newConcurrentMap();\n            stringCache = null;\n        } else {\n            strings = null;\n            stringCache = tracker.getStringCache();\n        }\n        this.data = ByteBuffer.wrap(checkNotNull(buffer));\n        this.refids = new SegmentId[SEGMENT_REFERENCE_LIMIT + 1];\n        this.refids[0] = id;\n        this.version = SegmentVersion.fromByte(buffer[3]);\n        this.id.setSegment(this);\n    }","commit_id":"8996f36c6ba7f69a3e1e1d8e5f6c3ae8b3516608","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Adds a segment header to the buffer and writes a segment to the segment\n     * store. This is done automatically (called from prepare) when there is not\n     * enough space for a record. It can also be called explicitly.\n     */\n    public synchronized void flush() {\n        if (length > 0) {\n            int refcount = segment.getRefCount();\n\n            int rootcount = roots.size();\n            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n            int blobrefcount = blobrefs.size();\n            buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\n            buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\n\n            length = align(\n                    refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                    16);\n\n            checkState(length <= buffer.length);\n\n            int pos = refcount * 16;\n            if (pos + length <= buffer.length) {\n                // the whole segment fits to the space *after* the referenced\n                // segment identifiers we've already written, so we can safely\n                // copy those bits ahead even if concurrent code is still\n                // reading from that part of the buffer\n                System.arraycopy(buffer, 0, buffer, buffer.length-length, pos);\n                pos += buffer.length - length;\n            } else {\n                // this might leave some empty space between the header and\n                // the record data, but this case only occurs when the\n                // segment is >252kB in size and the maximum overhead is <<4kB,\n                // which is acceptable\n                length = buffer.length;\n            }\n\n            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                int offset = entry.getKey().getOffset();\n                buffer[pos++] = (byte) entry.getValue().ordinal();\n                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            for (RecordId blobref : blobrefs) {\n                int offset = blobref.getOffset();\n                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n            }\n\n            SegmentId id = segment.getSegmentId();\n            log.debug(\"Writing data segment {} ({} bytes)\", id, length);\n            store.writeSegment(id, buffer, buffer.length - length, length);\n\n            // Keep this segment in memory as it's likely to be accessed soon\n            ByteBuffer data;\n            if (buffer.length - length > 4096) {\n                data = ByteBuffer.allocate(length);\n                data.put(buffer, buffer.length - length, length);\n                data.rewind();\n            } else {\n                data = ByteBuffer.wrap(buffer, buffer.length - length, length);\n            }\n            tracker.setSegment(id, new Segment(tracker, id, data));\n\n            buffer = createNewBuffer(version);\n            roots.clear();\n            blobrefs.clear();\n            length = 0;\n            position = buffer.length;\n            segment = new Segment(tracker, buffer);\n            segment.getSegmentId().setSegment(segment);\n        }\n    }","id":51763,"modified_method":"/**\n     * Adds a segment header to the buffer and writes a segment to the segment\n     * store. This is done automatically (called from prepare) when there is not\n     * enough space for a record. It can also be called explicitly.\n     */\n    public void flush() {\n        // Id of the segment to be written in the file store. If the segment id\n        // is not null, a segment will be written outside of the synchronized block.\n        SegmentId segmentId = null;\n\n        // Buffer containing segment data, and offset and length to locate the\n        // segment data into the buffer. These variable will be initialized in\n        // the synchronized block.\n        byte[] segmentBuffer = null;\n        int segmentOffset = 0;\n        int segmentLength = 0;\n\n        synchronized (this) {\n            if (length > 0) {\n                int refcount = segment.getRefCount();\n\n                int rootcount = roots.size();\n                buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\n                buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\n\n                int blobrefcount = blobrefs.size();\n                buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\n                buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\n\n                length = align(\n                        refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                        16);\n\n                checkState(length <= buffer.length);\n\n                int pos = refcount * 16;\n                if (pos + length <= buffer.length) {\n                    // the whole segment fits to the space *after* the referenced\n                    // segment identifiers we've already written, so we can safely\n                    // copy those bits ahead even if concurrent code is still\n                    // reading from that part of the buffer\n                    System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\n                    pos += buffer.length - length;\n                } else {\n                    // this might leave some empty space between the header and\n                    // the record data, but this case only occurs when the\n                    // segment is >252kB in size and the maximum overhead is <<4kB,\n                    // which is acceptable\n                    length = buffer.length;\n                }\n\n                for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\n                    int offset = entry.getKey().getOffset();\n                    buffer[pos++] = (byte) entry.getValue().ordinal();\n                    buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                    buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n                }\n\n                for (RecordId blobref : blobrefs) {\n                    int offset = blobref.getOffset();\n                    buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\n                    buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\n                }\n\n                segmentId = segment.getSegmentId();\n                segmentBuffer = buffer;\n                segmentOffset = buffer.length - length;\n                segmentLength = length;\n\n                buffer = createNewBuffer(version);\n                roots.clear();\n                blobrefs.clear();\n                length = 0;\n                position = buffer.length;\n                segment = new Segment(tracker, buffer);\n            }\n        }\n\n        if (segmentId != null) {\n            log.debug(\"Writing data segment {} ({} bytes)\", segmentId, segmentLength);\n            store.writeSegment(segmentId, segmentBuffer, segmentOffset, segmentLength);\n\n            // Keep this segment in memory as it's likely to be accessed soon\n            ByteBuffer data;\n            if (segmentOffset > 4096) {\n                data = ByteBuffer.allocate(segmentLength);\n                data.put(segmentBuffer, segmentOffset, segmentLength);\n                data.rewind();\n            } else {\n                data = ByteBuffer.wrap(segmentBuffer, segmentOffset, segmentLength);\n            }\n\n            // It is important to put the segment into the cache only *after* it has been\n            // written to the store since as soon as it is in the cache it becomes eligible\n            // for eviction, which might lead to SNFEs when it is not yet in the store at that point.\n            tracker.setSegment(segmentId, new Segment(tracker, segmentId, data));\n        }\n    }","commit_id":"8996f36c6ba7f69a3e1e1d8e5f6c3ae8b3516608","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentWriter(SegmentStore store, SegmentTracker tracker, SegmentVersion version) {\n        this.store = store;\n        this.tracker = tracker;\n        this.version = version;\n        this.buffer = createNewBuffer(version);\n        this.segment = new Segment(tracker, buffer);\n        segment.getSegmentId().setSegment(segment);\n    }","id":51764,"modified_method":"public SegmentWriter(SegmentStore store, SegmentTracker tracker, SegmentVersion version) {\n        this.store = store;\n        this.tracker = tracker;\n        this.version = version;\n        this.buffer = createNewBuffer(version);\n        this.segment = new Segment(tracker, buffer);\n    }","commit_id":"8996f36c6ba7f69a3e1e1d8e5f6c3ae8b3516608","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static ClientMessage create() {\n        final ClientMessage clientMessage = new ClientMessage();\n\n        if (USE_UNSAFE) {\n            clientMessage.wrap(new UnsafeBuffer(new byte[INITIAL_BUFFER_SIZE]), 0);\n        } else {\n            clientMessage.wrap(new SafeBuffer(new byte[INITIAL_BUFFER_SIZE]), 0);\n\n        }\n        return clientMessage;\n    }","id":51765,"modified_method":"public static ClientMessage create() {\n        return new ClientMessage();\n    }","commit_id":"90d4564e2fc09196db160c80f2c3b60b9a717a2d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean readFrom(ByteBuffer src) {\n        if (index() == 0) {\n            initFrameSize(src);\n        }\n        while (index() >= Bits.INT_SIZE_IN_BYTES && src.hasRemaining() && !isComplete()) {\n            accumulate(src, getFrameLength() - index());\n        }\n        return isComplete();\n    }","id":51766,"modified_method":"public boolean readFrom(ByteBuffer src) {\n        int frameLength = 0;\n        if (this.buffer == null) {\n            //init internal buffer\n            final int remaining = src.remaining();\n            if (remaining < Bits.INT_SIZE_IN_BYTES) {\n                //we don't have even the frame length ready\n                return false;\n            }\n            frameLength = Bits.readIntL(src.array(), 0);\n            if (USE_UNSAFE) {\n                wrap(new UnsafeBuffer(new byte[frameLength]), 0);\n            } else {\n                wrap(new SafeBuffer(new byte[frameLength]), 0);\n            }\n        }\n        frameLength = frameLength > 0 ? frameLength : getFrameLength();\n        accumulate(src, frameLength - index());\n        return isComplete();\n    }","commit_id":"90d4564e2fc09196db160c80f2c3b60b9a717a2d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ClientMessage() {\n    }","id":51767,"modified_method":"protected ClientMessage() {\n    }","commit_id":"90d4564e2fc09196db160c80f2c3b60b9a717a2d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private int accumulate(ByteBuffer byteBuffer, int length) {\n        final int remaining = byteBuffer.remaining();\n        final int readLength = remaining < length ? remaining : length;\n        if (readLength > 0) {\n            final int requiredCapacity = index() + readLength;\n            ensureCapacity(requiredCapacity);\n            buffer.putBytes(index(), byteBuffer.array(), byteBuffer.position(), readLength);\n            byteBuffer.position(byteBuffer.position() + readLength);\n            index(index() + readLength);\n            return readLength;\n        }\n        return 0;\n    }","id":51768,"modified_method":"private int accumulate(ByteBuffer byteBuffer, int length) {\n        final int remaining = byteBuffer.remaining();\n        final int readLength = remaining < length ? remaining : length;\n        if (readLength > 0) {\n            buffer.putBytes(index(), byteBuffer.array(), byteBuffer.position(), readLength);\n            byteBuffer.position(byteBuffer.position() + readLength);\n            index(index() + readLength);\n            return readLength;\n        }\n        return 0;\n    }","commit_id":"90d4564e2fc09196db160c80f2c3b60b9a717a2d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void test_empty_toString() {\n        new ClientMessage().toString();\n    }","id":51769,"modified_method":"@Test\n    public void test_empty_toString() {\n        ClientMessage.create().toString();\n    }","commit_id":"90d4564e2fc09196db160c80f2c3b60b9a717a2d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static ClientMessage create() {\n        final ClientMessage clientMessage = new ClientMessage();\n\n        if (USE_UNSAFE) {\n            clientMessage.wrap(new UnsafeBuffer(new byte[INITIAL_BUFFER_SIZE]), 0);\n        } else {\n            clientMessage.wrap(new SafeBuffer(new byte[INITIAL_BUFFER_SIZE]), 0);\n\n        }\n        return clientMessage;\n    }","id":51770,"modified_method":"public static ClientMessage create() {\n        return new ClientMessage();\n    }","commit_id":"3fc734d91e8c31a5745c8285220031cc141d83b5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ClientMessage() {\n    }","id":51771,"modified_method":"protected ClientMessage() {\n    }","commit_id":"3fc734d91e8c31a5745c8285220031cc141d83b5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private int accumulate(ByteBuffer byteBuffer, int length) {\n        final int remaining = byteBuffer.remaining();\n        final int readLength = remaining < length ? remaining : length;\n        if (readLength > 0) {\n            final int requiredCapacity = index() + readLength;\n            ensureCapacity(requiredCapacity);\n            buffer.putBytes(index(), byteBuffer.array(), byteBuffer.position(), readLength);\n            byteBuffer.position(byteBuffer.position() + readLength);\n            index(index() + readLength);\n            return readLength;\n        }\n        return 0;\n    }","id":51772,"modified_method":"private int accumulate(ByteBuffer byteBuffer, int length) {\n        final int remaining = byteBuffer.remaining();\n        final int readLength = remaining < length ? remaining : length;\n        if (readLength > 0) {\n            buffer.putBytes(index(), byteBuffer.array(), byteBuffer.position(), readLength);\n            byteBuffer.position(byteBuffer.position() + readLength);\n            index(index() + readLength);\n            return readLength;\n        }\n        return 0;\n    }","commit_id":"3fc734d91e8c31a5745c8285220031cc141d83b5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean readFrom(ByteBuffer src) {\n        if (index() == 0) {\n            initFrameSize(src);\n        }\n        while (index() >= Bits.INT_SIZE_IN_BYTES && src.hasRemaining() && !isComplete()) {\n            accumulate(src, getFrameLength() - index());\n        }\n        return isComplete();\n    }","id":51773,"modified_method":"public boolean readFrom(ByteBuffer src) {\n        int frameLength = 0;\n        if (this.buffer == null) {\n            //init internal buffer\n            final int remaining = src.remaining();\n            if (remaining < Bits.INT_SIZE_IN_BYTES) {\n                //we don't have even the frame length ready\n                return false;\n            }\n            frameLength = Bits.readIntL(src.array(), 0);\n            if (USE_UNSAFE) {\n                wrap(new UnsafeBuffer(new byte[frameLength]), 0);\n            } else {\n                wrap(new SafeBuffer(new byte[frameLength]), 0);\n            }\n        }\n        frameLength = frameLength > 0 ? frameLength : getFrameLength();\n        accumulate(src, frameLength - index());\n        return isComplete();\n    }","commit_id":"3fc734d91e8c31a5745c8285220031cc141d83b5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void test_empty_toString() {\n        new ClientMessage().toString();\n    }","id":51774,"modified_method":"@Test\n    public void test_empty_toString() {\n        ClientMessage.create().toString();\n    }","commit_id":"3fc734d91e8c31a5745c8285220031cc141d83b5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     *  @inheritDoc\n     *\n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractRightTuple(final RightTuple rightTuple,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getRightTupleMemory().remove( rightTuple );\n        \n        InternalFactHandle handle = rightTuple.getFactHandle(); \n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               handle );\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() ) {\n                    this.modifyTuple( false,\n                                      tuple,\n                                      handle,\n                                      context,\n                                      workingMemory );\n                } else {\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","id":51775,"modified_method":"/**\n     *  @inheritDoc\n     *\n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractRightTuple(final RightTuple rightTuple,\n                                  final PropagationContext context,\n                                  final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getRightTupleMemory().remove( rightTuple );\n\n        for ( LeftTuple childTuple = rightTuple.getBetaChildren(); childTuple != null; ) {\n            LeftTuple tmp = childTuple.getRightParentNext();\n            if ( this.accumulate.supportsReverse() ) {\n                this.modifyTuple( false,\n                                  childTuple.getParent(),\n                                  rightTuple,\n                                  context,\n                                  workingMemory,\n                                  memory );\n            } else {\n                // does not support reverse, so needs to be fully retracted and reasserted\n                LeftTuple match = childTuple.getParent();\n                \n                // but first, needs to remove the matching child\n                childTuple.unlinkFromLeftParent();\n                childTuple.unlinkFromRightParent();\n                \n                this.retractLeftTuple( match,\n                                       context,\n                                       workingMemory );\n                this.assertLeftTuple( match,\n                                      context,\n                                      workingMemory );\n            }\n            childTuple = tmp;\n        }\n\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            workingMemoryContext = in.readObject();\n            betaMemory = (BetaMemory) in.readObject();\n            resultMap = (ObjectHashMap) in.readObject();\n            resultsContext = (ContextEntry[]) in.readObject();\n            alphaContexts = (ContextEntry[]) in.readObject();\n        }","id":51776,"modified_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            workingMemoryContext = in.readObject();\n            betaMemory = (BetaMemory) in.readObject();\n            resultsContext = (ContextEntry[]) in.readObject();\n            alphaContexts = (ContextEntry[]) in.readObject();\n        }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     *  When a new object is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        final RightTuple rightTuple = new RightTuple( factHandle,\n                                                      this );        \n        memory.betaMemory.getRightTupleMemory().add( rightTuple );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() || context.getType() == PropagationContext.ASSERTION ) {\n                    modifyTuple( true,\n                                 tuple,\n                                 factHandle,\n                                 context,\n                                 workingMemory );\n                } else {\n                    // context is MODIFICATION and does not supports reverse\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","id":51777,"modified_method":"/**\n     * @inheritDoc\n     *\n     *  When a new object is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        final RightTuple rightTuple = new RightTuple( factHandle,\n                                                      this );\n        memory.betaMemory.getRightTupleMemory().add( rightTuple );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() || context.getType() == PropagationContext.ASSERTION ) {\n                    modifyTuple( true,\n                                 tuple,\n                                 rightTuple,\n                                 context,\n                                 workingMemory,\n                                 memory );\n                } else {\n                    // context is MODIFICATION and does not supports reverse\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( workingMemoryContext );\n            out.writeObject( betaMemory );\n            out.writeObject( resultMap );\n            out.writeObject( resultsContext );\n            out.writeObject( alphaContexts );\n        }","id":51778,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( workingMemoryContext );\n            out.writeObject( betaMemory );\n            out.writeObject( resultsContext );\n            out.writeObject( alphaContexts );\n        }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Creates a BetaMemory for the BetaNode's memory.\n     */\n    public Object createMemory(final RuleBaseConfiguration config) {\n        AccumulateMemory memory = new AccumulateMemory();\n        memory.betaMemory = this.constraints.createBetaMemory( config );\n        memory.resultMap = new ObjectHashMap();\n        memory.workingMemoryContext = this.accumulate.createWorkingMemoryContext();\n        memory.resultsContext = this.resultBinder.createContext();\n        memory.alphaContexts = new ContextEntry[this.resultConstraints.length];\n        for ( int i = 0; i < this.resultConstraints.length; i++ ) {\n            memory.alphaContexts[i] = this.resultConstraints[i].createContextEntry();\n        }\n        return memory;\n    }","id":51779,"modified_method":"/**\n     * Creates a BetaMemory for the BetaNode's memory.\n     */\n    public Object createMemory(final RuleBaseConfiguration config) {\n        AccumulateMemory memory = new AccumulateMemory();\n        memory.betaMemory = this.constraints.createBetaMemory( config );\n        memory.workingMemoryContext = this.accumulate.createWorkingMemoryContext();\n        memory.resultsContext = this.resultBinder.createContext();\n        memory.alphaContexts = new ContextEntry[this.resultConstraints.length];\n        for ( int i = 0; i < this.resultConstraints.length; i++ ) {\n            memory.alphaContexts[i] = this.resultConstraints[i].createContextEntry();\n        }\n        return memory;\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            InternalFactHandle handle,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        AccumulateResult accresult = (AccumulateResult) memory.resultMap.get( leftTuple );\n\n        // if tuple was propagated\n        this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple,\n                                                              context,\n                                                              workingMemory );\n\n        LeftTuple tuple = leftTuple;\n        if ( this.unwrapRightObject ) {\n            // if there is a subnetwork, handle must be unwrapped\n            tuple = (LeftTuple) handle.getObject();\n            handle = tuple.getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            // assertion\n            if ( accresult.context == null ) {\n                final Object accContext = this.accumulate.createContext();\n\n                this.accumulate.init( memory.workingMemoryContext,\n                                      accContext,\n                                      leftTuple,\n                                      workingMemory );\n\n                accresult.context = accContext;\n            }\n\n            this.accumulate.accumulate( memory.workingMemoryContext,\n                                        accresult.context,\n                                        tuple,\n                                        handle,\n                                        workingMemory );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            // modification\n            if ( isAssert ) {\n                this.accumulate.accumulate( memory.workingMemoryContext,\n                                            accresult.context,\n                                            tuple,\n                                            handle,\n                                            workingMemory );\n            } else {\n                this.accumulate.reverse( memory.workingMemoryContext,\n                                         accresult.context,\n                                         tuple,\n                                         handle,\n                                         workingMemory );\n            }\n        } else {\n            // retraction\n            this.accumulate.reverse( memory.workingMemoryContext,\n                                     accresult.context,\n                                     tuple,\n                                     handle,\n                                     workingMemory );\n        }\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accresult.context,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle createdHandle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                                     false,\n                                                                                                     workingMemory ); // so far, result is not an event\n        \n        final RightTuple resultTuple = new RightTuple( handle,\n                                                       this );\n        \n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( createdHandle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        createdHandle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory,\n                                                    this.tupleMemoryEnabled );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n            }\n\n            this.resultBinder.resetTuple( memory.resultsContext );\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n        }\n    }","id":51780,"modified_method":"public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            final RightTuple rightTuple,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory,\n                            final AccumulateMemory memory) {\n\n        final AccumulateContext accctx = (AccumulateContext) memory.betaMemory.getCreatedHandles().get( leftTuple );\n\n        // if tuple was propagated\n        if ( accctx.propagated ) {\n            LeftTuple firstMatch = getFirstMatch( leftTuple,\n                                                  accctx );\n\n            // we may have no matches yet\n            if ( firstMatch != null ) {\n                // temporarily break the linked list to avoid wrong retracts\n                firstMatch.getLeftParentPrevious().setLeftParentNext( null );\n                firstMatch.setLeftParentPrevious( null );\n            }\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 context,\n                                                 workingMemory );\n            // now set the beta children to the first match\n            leftTuple.setBetaChildren( firstMatch );\n            accctx.propagated = false;\n        }\n\n        if ( isAssert ) {\n            // linking left and right by creating a new left tuple\n            new LeftTuple( leftTuple,\n                           rightTuple,\n                           this,\n                           this.tupleMemoryEnabled );\n        } else {\n            removeMatchingChild( leftTuple,\n                                 rightTuple );\n        }\n\n        // if there is a subnetwork, we need to unwrapp the object from inside the tuple\n        InternalFactHandle handle = rightTuple.getFactHandle();\n        LeftTuple tuple = leftTuple;\n        if ( this.unwrapRightObject ) {\n            tuple = ((LeftTuple) handle.getObject());\n            handle = tuple.getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            // assertion\n            this.accumulate.accumulate( memory.workingMemoryContext,\n                                        accctx.context,\n                                        tuple,\n                                        handle,\n                                        workingMemory );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            // modification\n            if ( isAssert ) {\n                this.accumulate.accumulate( memory.workingMemoryContext,\n                                            accctx.context,\n                                            tuple,\n                                            handle,\n                                            workingMemory );\n            } else {\n                this.accumulate.reverse( memory.workingMemoryContext,\n                                         accctx.context,\n                                         tuple,\n                                         handle,\n                                         workingMemory );\n            }\n        } else {\n            // retraction\n            this.accumulate.reverse( memory.workingMemoryContext,\n                                     accctx.context,\n                                     tuple,\n                                     handle,\n                                     workingMemory );\n        }\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accctx.context,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // update result object \n        accctx.result.getFactHandle().setObject( result );\n\n        evaluateResultConstraints( leftTuple,\n                                   context,\n                                   workingMemory,\n                                   memory,\n                                   accctx );\n\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Execute the initialization code using the tuple + matching objects\n     *  3. Execute the accumulation code for each combination of tuple+object\n     *  4. Execute the return code\n     *  5. Create a new CalculatedObjectHandle for the resulting object and add it to the tuple\n     *  6. Propagate the tuple\n     *\n     *  The initialization, accumulation and return codes, in JBRules, are assembled\n     *  into a generated method code and called once for the whole match, as you can see\n     *  bellow:\n     *\n     *   Object result = this.accumulator.accumulate( ... );\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        AccumulateResult accresult = new AccumulateResult();\n\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n            memory.resultMap.put( leftTuple,\n                                      accresult,\n                                      false );\n        }\n\n        final Object accContext = this.accumulate.createContext();\n\n        accresult.context = accContext;\n        this.accumulate.init( memory.workingMemoryContext,\n                              accContext,\n                              leftTuple,\n                              workingMemory );\n\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.betaMemory.getRightTupleMemory().getFirst( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getNext() ) {\n            InternalFactHandle handle = rightTuple.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                if ( this.unwrapRightObject ) {\n                    // if there is a subnetwork, handle must be unwrapped\n                    LeftTuple tuple = (LeftTuple) handle.getObject();\n                    handle = tuple.getLastHandle();\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                tuple,\n                                                handle,\n                                                workingMemory );\n                } else {\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                leftTuple,\n                                                handle,\n                                                workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accContext,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                              false,\n                                                                                              workingMemory ); // so far, result is not an event\n        \n        final RightTuple resultTuple = new RightTuple( handle,\n                                                       this );        \n\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( handle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        handle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory,\n                                                    this.tupleMemoryEnabled );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n            }\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n        }\n\n    }","id":51781,"modified_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Execute the initialization code using the tuple + matching objects\n     *  3. Execute the accumulation code for each combination of tuple+object\n     *  4. Execute the return code\n     *  5. Create a new CalculatedObjectHandle for the resulting object and add it to the tuple\n     *  6. Propagate the tuple\n     *\n     *  The initialization, accumulation and return codes, in JBRules, are assembled\n     *  into a generated method code and called once for the whole match, as you can see\n     *  bellow:\n     *\n     *   Object result = this.accumulator.accumulate( ... );\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        AccumulateContext accresult = new AccumulateContext();\n\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n            memory.betaMemory.getCreatedHandles().put( leftTuple,\n                                                       accresult,\n                                                       false );\n        }\n\n        accresult.context = this.accumulate.createContext();\n\n        this.accumulate.init( memory.workingMemoryContext,\n                              accresult.context,\n                              leftTuple,\n                              workingMemory );\n\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.betaMemory.getRightTupleMemory().getFirst( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getNext() ) {\n            InternalFactHandle handle = rightTuple.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                LeftTuple tuple = leftTuple;\n                if ( this.unwrapRightObject ) {\n                    // if there is a subnetwork, handle must be unwrapped\n                    tuple = (LeftTuple) handle.getObject();\n                    handle = tuple.getLastHandle();\n                }\n                this.accumulate.accumulate( memory.workingMemoryContext,\n                                            accresult.context,\n                                            tuple,\n                                            handle,\n                                            workingMemory );\n\n                // in sequential mode, we don't need to keep record of matched tuples\n                if ( this.tupleMemoryEnabled ) {\n                    // linking left and right by creating a new left tuple\n                    new LeftTuple( leftTuple,\n                                   rightTuple,\n                                   this,\n                                   this.tupleMemoryEnabled );\n                }\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accresult.context,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                              false,\n                                                                                              workingMemory ); // so far, result is not an event\n\n        accresult.result = new RightTuple( handle,\n                                           this );\n\n        evaluateResultConstraints( leftTuple,\n                                   context,\n                                   workingMemory,\n                                   memory,\n                                   accresult );\n\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     * As the accumulate node will always propagate the tuple,\n     * it must always also retreat it.\n     *\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getLeftTupleMemory().remove( leftTuple );\n        \n        memory.resultMap.remove( leftTuple );\n\n        this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple,\n                                                              context,\n                                                              workingMemory );\n    }","id":51782,"modified_method":"/**\n     * @inheritDoc\n     *\n     * As the accumulate node will always generate a resulting tuple,\n     * we must always destroy it\n     *\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getLeftTupleMemory().remove( leftTuple );\n        final AccumulateContext accctx = (AccumulateContext) memory.betaMemory.getCreatedHandles().remove( leftTuple );\n\n        LeftTuple child = getFirstMatch( leftTuple,\n                                         accctx );\n\n        // Now, unlink the matches \n        while ( child != null ) {\n            LeftTuple tmp = child.getLeftParentNext();\n            child.unlinkFromLeftParent();\n            child.unlinkFromRightParent();\n            child = tmp;\n        }\n\n        if ( accctx.propagated ) {\n            // if tuple was previously propagated, retract it\n            this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple,\n                                                                  context,\n                                                                  workingMemory );\n        }\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator tupleIter = memory.betaMemory.getLeftTupleMemory().iterator();\n        for ( LeftTuple leftTuple = (LeftTuple) tupleIter.next(); leftTuple != null; leftTuple = (LeftTuple) tupleIter.next() ) {\n            LeftTuple childLeftTuple = leftTuple.getBetaChildren();\n            if ( childLeftTuple != null ) {\n                RightTuple rightTuple = childLeftTuple.getRightParent();\n                sink.assertLeftTuple( new LeftTuple( leftTuple,\n                                                     rightTuple,\n                                                     sink,\n                                                     this.tupleMemoryEnabled ),\n                                      context,\n                                      workingMemory );\n            }\n        }\n    }","id":51783,"modified_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator tupleIter = memory.betaMemory.getLeftTupleMemory().iterator();\n        for ( LeftTuple leftTuple = (LeftTuple) tupleIter.next(); leftTuple != null; leftTuple = (LeftTuple) tupleIter.next() ) {\n            AccumulateContext accctx = (AccumulateContext) memory.betaMemory.getCreatedHandles().get( leftTuple );\n            if( accctx.propagated ) {\n                sink.assertLeftTuple( new LeftTuple( leftTuple,\n                                                     accctx.result,\n                                                     sink,\n                                                     this.tupleMemoryEnabled ),\n                                      context,\n                                      workingMemory );\n            }\n        }\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\r\n                                                           final PropagationContext context,\r\n                                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            workingMemory.getFactHandleFactory().destroyFactHandle( child.getRightParent().getFactHandle() );\r\n            child.unlinkFromRightParent();\r\n            child = temp;\r\n        }\r\n        leftTuple.setBetaChildren( null );\r\n    }","id":51784,"modified_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\r\n                                                           final PropagationContext context,\r\n                                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            workingMemory.getFactHandleFactory().destroyFactHandle( child.getRightParent().getFactHandle() );\r\n            child.unlinkFromRightParent();\r\n            child.unlinkFromLeftParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractRightTuple(final RightTuple rightTuple,\r\n                                           final PropagationContext context,\r\n                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = rightTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getRightParentNext();\r\n            //child.unlinkFromParents();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromLeftParent();\r\n            //child = child.getRightParentNext();\r\n            child = temp;\r\n        }\r\n        rightTuple.setBetaChildren( null );\r\n    }","id":51785,"modified_method":"public void propagateRetractRightTuple(final RightTuple rightTuple,\r\n                                           final PropagationContext context,\r\n                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = rightTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getRightParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromLeftParent();\r\n            child.unlinkFromRightParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractLeftTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            //child.unlinkFromParents();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromRightParent();\r\n            //child = child.getLeftParentNext();\r\n            child = temp;\r\n        }\r\n        leftTuple.setBetaChildren( null );\r\n    }","id":51786,"modified_method":"public void propagateRetractLeftTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromRightParent();\r\n            child.unlinkFromLeftParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractRightTuple(final RightTuple rightTuple,\r\n                                           final PropagationContext context,\r\n                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = rightTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getRightParentNext();\r\n            //child.unlinkFromParents();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromLeftParent();\r\n            //child = child.getRightParentNext();\r\n            child = temp;\r\n        }\r\n        rightTuple.setBetaChildren( null );\r\n    }","id":51787,"modified_method":"public void propagateRetractRightTuple(final RightTuple rightTuple,\r\n                                           final PropagationContext context,\r\n                                           final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = rightTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getRightParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromLeftParent();\r\n            child.unlinkFromRightParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            workingMemory.getFactHandleFactory().destroyFactHandle( child.getRightParent().getFactHandle() );\r\n            child.unlinkFromRightParent();\r\n            child = temp;\r\n        }\r\n        leftTuple.setBetaChildren( null );\r\n    }","id":51788,"modified_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            workingMemory.getFactHandleFactory().destroyFactHandle( child.getRightParent().getFactHandle() );\r\n            child.unlinkFromRightParent();\r\n            child.unlinkFromLeftParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propagateRetractLeftTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            //child.unlinkFromParents();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromRightParent();\r\n            //child = child.getLeftParentNext();\r\n            child = temp;\r\n        }\r\n        leftTuple.setBetaChildren( null );\r\n    }","id":51789,"modified_method":"public void propagateRetractLeftTuple(final LeftTuple leftTuple,\r\n                                          final PropagationContext context,\r\n                                          final InternalWorkingMemory workingMemory) {\r\n        LeftTuple child = leftTuple.getBetaChildren();\r\n        while ( child != null ) {\r\n            LeftTuple temp = child.getLeftParentNext();\r\n            child.getSink().retractLeftTuple( child,\r\n                                              context,\r\n                                              workingMemory );\r\n            child.unlinkFromRightParent();\r\n            child.unlinkFromLeftParent();\r\n            child = temp;\r\n        }\r\n    }","commit_id":"7ab267d8727de9c95e4c32f23411a3c771db09f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testCallFromClient() throws Exception {\n        SpringBusFactory factory = new SpringBusFactory();\n        Bus bus = factory.createBus(\"org/apache/cxf/systest/xmlbeans/cxf.xml\");\n        BusFactory.setDefaultBus(bus);\n        URL wsdl = this.getClass().getResource(\"/wsdl_systest/xmlbeans/hello_world.wsdl\");\n        assertNotNull(\"We should found the WSDL her. \" , wsdl);      \n        \n        SOAPService ss = new SOAPService(wsdl, SERVICE_NAME);\n        Greeter port = ss.getSoapPort();\n        String resp; \n        \n        resp = port.sayHi();\n        assertEquals(\"We should get the right response\", resp, \"Bonjour\");        \n        \n        resp = port.greetMe(\"Willem\");\n        assertEquals(\"We should get the right response\", resp, \"Hello Willem\");\n        \n        try {\n            resp = port.greetMe(\"Invoking greetMe with invalid length string, expecting exception...\");\n            fail(\"We expect exception here\");\n        } catch (WebServiceException ex) {           \n            assertTrue(\"Get a wrong exception\", \n                       ex.getMessage().\n                       indexOf(\"string length (67) is greater than maxLength facet (30)\") >= 0);\n        }\n        \n        port.greetMeOneWay(System.getProperty(\"user.name\"));\n        \n        try {\n            port.pingMe();\n            fail(\"We expect exception here\");\n        } catch (PingMeFault ex) {            \n            FaultDetailDocument detailDocument = ex.getFaultInfo();\n            FaultDetail detail = detailDocument.getFaultDetail();\n            assertEquals(\"Wrong faultDetail major\", detail.getMajor(), 2);\n            assertEquals(\"Wrong faultDetail minor:\", detail.getMinor(), 1);             \n        }          \n    }","id":51790,"modified_method":"@Test\n    public void testCallFromClient() throws Exception {\n        SpringBusFactory factory = new SpringBusFactory();\n        Bus bus = factory.createBus(\"org/apache/cxf/systest/xmlbeans/cxf.xml\");\n        BusFactory.setDefaultBus(bus);\n        URL wsdl = this.getClass().getResource(\"/wsdl_systest/xmlbeans/hello_world.wsdl\");\n        assertNotNull(\"We should found the WSDL her. \" , wsdl);      \n        \n        SOAPService ss = new SOAPService(wsdl, SERVICE_NAME);\n        Greeter port = ss.getSoapPort();\n        String resp; \n        ClientProxy.getClient(port).getInInterceptors().add(new LoggingInInterceptor());\n        ClientProxy.getClient(port).getOutInterceptors().add(new LoggingOutInterceptor());\n        resp = port.sayHi();\n        assertEquals(\"We should get the right response\", resp, \"Bonjour\");        \n        \n        resp = port.greetMe(\"Willem\");\n        assertEquals(\"We should get the right response\", resp, \"Hello Willem\");\n        \n        try {\n            resp = port.greetMe(\"Invoking greetMe with invalid length string, expecting exception...\");\n            fail(\"We expect exception here\");\n        } catch (WebServiceException ex) {           \n            assertTrue(\"Get a wrong exception\", \n                       ex.getMessage().\n                       indexOf(\"string length (67) is greater than maxLength facet (30)\") >= 0);\n        }\n        \n        port.greetMeOneWay(System.getProperty(\"user.name\"));\n        \n        try {\n            port.pingMe();\n            fail(\"We expect exception here\");\n        } catch (PingMeFault ex) {            \n            FaultDetailDocument detailDocument = ex.getFaultInfo();\n            FaultDetail detail = detailDocument.getFaultDetail();\n            assertEquals(\"Wrong faultDetail major\", detail.getMajor(), 2);\n            assertEquals(\"Wrong faultDetail minor:\", detail.getMinor(), 1);             \n        }          \n    }","commit_id":"75c0b449a475a0387c7d453c24f6bad0583c9653","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\"server did not launch correctly\", launchServer(Server.class, true));\n    }","id":51791,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\"server did not launch correctly\", launchServer(Server.class, true));\n        assertTrue(\"server did not launch correctly\", launchServer(ServerNoWsdl.class, true));\n    }","commit_id":"75c0b449a475a0387c7d453c24f6bad0583c9653","url":"https://github.com/apache/cxf"},{"original_method":"private void mapClass(MessagePartInfo part, Class clazz) {\n        \n        if (!XmlObject.class.isAssignableFrom(clazz)) {\n            \n            Class<? extends XmlAnySimpleType> type = CLASS_MAP.get(clazz);\n            if (type == null) {\n                LOG.log(Level.SEVERE, clazz.getName() + \" was not found in class map\");\n                return;\n            }\n            SchemaTypeSystem sts = BuiltinSchemaTypeSystem.get();\n            SchemaType st2 = sts.typeForClassname(type.getName());\n\n            part.setProperty(SchemaType.class.getName(), st2);\n            part.setProperty(XmlAnySimpleType.class.getName(), type);\n            part.setTypeQName(st2.getName());\n            XmlSchemaType xmlSchema = schemas.getTypeByQName(st2.getName());\n            part.setXmlSchema(xmlSchema);\n            return;\n        }\n        \n        try {\n            Field field = clazz.getField(\"type\");\n            SchemaType st = (SchemaType)field.get(null);\n            part.setProperty(SchemaType.class.getName(), st);\n            \n            SchemaTypeSystem sts = st.getTypeSystem();\n            schemas.getXmlSchemaCollection().setSchemaResolver(new XMLSchemaResolver(sts));\n\n            XmlSchema schema = getSchema(sts, st.getSourceName());\n\n            if (st.isDocumentType()) {\n                XmlSchemaElement sct = schema.getElementByName(st.getDocumentElementName());\n                part.setXmlSchema(sct);\n                part.setElement(true);\n                part.setElementQName(st.getDocumentElementName());\n                part.setConcreteName(st.getDocumentElementName());\n            } else if (st.getComponentType() == SchemaType.ELEMENT) {\n                XmlSchemaElement sct = schema.getElementByName(st.getName());\n                part.setXmlSchema(sct);\n                part.setElement(true);\n            } else {\n                XmlSchemaType sct = schema.getTypeByName(st.getName());\n                part.setTypeQName(st.getName());\n                part.setXmlSchema(sct);\n                part.setElement(false);\n            }\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }        \n    }","id":51792,"modified_method":"private void mapClass(MessagePartInfo part, Class clazz) {\n        \n        if (!XmlObject.class.isAssignableFrom(clazz)) {\n            \n            Class<? extends XmlAnySimpleType> type = CLASS_MAP.get(clazz);\n            if (type == null) {\n                LOG.log(Level.SEVERE, clazz.getName() + \" was not found in class map\");\n                return;\n            }\n            SchemaTypeSystem sts = BuiltinSchemaTypeSystem.get();\n            SchemaType st2 = sts.typeForClassname(type.getName());\n\n            part.setProperty(SchemaType.class.getName(), st2);\n            part.setProperty(XmlAnySimpleType.class.getName(), type);\n            part.setTypeQName(st2.getName());\n            XmlSchemaType xmlSchema = schemas.getTypeByQName(st2.getName());\n            part.setXmlSchema(xmlSchema);\n            return;\n        }\n        \n        try {\n            Field field = clazz.getField(\"type\");\n            SchemaType st = (SchemaType)field.get(null);\n            part.setProperty(SchemaType.class.getName(), st);\n            \n            SchemaTypeSystem sts = st.getTypeSystem();\n            schemas.getXmlSchemaCollection().setSchemaResolver(new XMLSchemaResolver(sts));\n            String sourceName = st.getSourceName();\n            if (sourceName.endsWith(\"wsdl\")) {\n                return;\n            }\n            XmlSchema schema = getSchema(sts, sourceName);\n\n            if (st.isDocumentType()) {\n                XmlSchemaElement sct = schema.getElementByName(st.getDocumentElementName());\n                part.setXmlSchema(sct);\n                part.setElement(true);\n                part.setElementQName(st.getDocumentElementName());\n                part.setConcreteName(st.getDocumentElementName());\n            } else if (st.getComponentType() == SchemaType.ELEMENT) {\n                XmlSchemaElement sct = schema.getElementByName(st.getName());\n                part.setXmlSchema(sct);\n                part.setElement(true);\n            } else {\n                XmlSchemaType sct = schema.getTypeByName(st.getName());\n                part.setTypeQName(st.getName());\n                part.setXmlSchema(sct);\n                part.setElement(false);\n            }\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }        \n    }","commit_id":"75c0b449a475a0387c7d453c24f6bad0583c9653","url":"https://github.com/apache/cxf"},{"original_method":"private CheckstyleResults executeCheckstyle( Configuration config, ModuleFactory moduleFactory )\n        throws MavenReportException, CheckstyleException\n    {\n        File[] files;\n        try\n        {\n            files = getFilesToProcess( includes, excludes );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Error getting files to process\", e );\n        }\n\n        FilterSet filterSet = getSuppressions();\n\n        Checker checker = new Checker();\n\n        // setup classloader, needed to avoid \"Unable to get class information\n        // for ...\" errors\n        List classPathStrings;\n        List outputDirectories = new ArrayList();\n        try\n        {\n            classPathStrings = this.project.getCompileClasspathElements();\n            outputDirectories.add( this.project.getBuild().getOutputDirectory() );\n\n            if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n                && ( testSourceDirectory.isDirectory() ) )\n            {\n                classPathStrings = this.project.getTestClasspathElements();\n                outputDirectories.add( this.project.getBuild().getTestOutputDirectory() );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( e.getMessage(), e );\n        }\n\n        List urls = new ArrayList( classPathStrings.size() );\n\n        Iterator iter = classPathStrings.iterator();\n        while ( iter.hasNext() )\n        {\n            try\n            {\n                urls.add( new File( ( (String) iter.next() ) ).toURL() );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        Iterator iterator = outputDirectories.iterator();\n        while ( iterator.hasNext() )\n        {\n            try\n            {\n                String outputDirectoryString = (String) iterator.next();\n                if ( outputDirectoryString != null )\n                {\n                    File outputDirectoryFile = new File( outputDirectoryString );\n                    if ( outputDirectoryFile.exists() )\n                    {\n                        URL outputDirectoryUrl = outputDirectoryFile.toURL();\n                        getLog().debug( \"Adding the outputDirectory \" + outputDirectoryUrl.toString()\n                            + \" to the Checkstyle class path\" );\n                        urls.add( outputDirectoryUrl );\n                    }\n                }\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        URLClassLoader projectClassLoader = new URLClassLoader( (URL[]) urls.toArray( new URL[urls.size()] ), null );\n        checker.setClassloader( projectClassLoader );\n\n        if ( moduleFactory != null )\n        {\n            checker.setModuleFactory( moduleFactory );\n        }\n\n        if ( filterSet != null )\n        {\n            checker.addFilter( filterSet );\n        }\n\n        checker.configure( config );\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n\n        if ( consoleOutput )\n        {\n            checker.addListener( getConsoleListener() );\n        }\n\n        CheckstyleReportListener sinkListener = new CheckstyleReportListener( sourceDirectory );\n        if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n            && ( testSourceDirectory.isDirectory() ) )\n        {\n            sinkListener.addSourceDirectory( testSourceDirectory );\n        }\n\n        checker.addListener( sinkListener );\n\n        int nbErrors = checker.process( files );\n\n        checker.destroy();\n\n        if ( stringOutputStream != null )\n        {\n            getLog().info( stringOutputStream.toString() );\n        }\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            // TODO: should be a failure, not an error. Report is not meant to\n            // throw an exception here (so site would\n            // work regardless of config), but should record this information\n            throw new MavenReportException( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n        else if ( nbErrors > 0 )\n        {\n            getLog().info( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n\n        return sinkListener.getResults();\n    }","id":51793,"modified_method":"private CheckstyleResults executeCheckstyle( Configuration config )\n        throws MavenReportException, CheckstyleException\n    {\n        File[] files;\n        try\n        {\n            files = getFilesToProcess( includes, excludes );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Error getting files to process\", e );\n        }\n\n        FilterSet filterSet = getSuppressions();\n\n        Checker checker = new Checker();\n\n        // setup classloader, needed to avoid \"Unable to get class information\n        // for ...\" errors\n        List classPathStrings;\n        List outputDirectories = new ArrayList();\n        try\n        {\n            classPathStrings = this.project.getCompileClasspathElements();\n            outputDirectories.add( this.project.getBuild().getOutputDirectory() );\n\n            if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n                && ( testSourceDirectory.isDirectory() ) )\n            {\n                classPathStrings = this.project.getTestClasspathElements();\n                outputDirectories.add( this.project.getBuild().getTestOutputDirectory() );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( e.getMessage(), e );\n        }\n\n        List urls = new ArrayList( classPathStrings.size() );\n\n        Iterator iter = classPathStrings.iterator();\n        while ( iter.hasNext() )\n        {\n            try\n            {\n                urls.add( new File( ( (String) iter.next() ) ).toURL() );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        Iterator iterator = outputDirectories.iterator();\n        while ( iterator.hasNext() )\n        {\n            try\n            {\n                String outputDirectoryString = (String) iterator.next();\n                if ( outputDirectoryString != null )\n                {\n                    File outputDirectoryFile = new File( outputDirectoryString );\n                    if ( outputDirectoryFile.exists() )\n                    {\n                        URL outputDirectoryUrl = outputDirectoryFile.toURL();\n                        getLog().debug( \"Adding the outputDirectory \" + outputDirectoryUrl.toString()\n                            + \" to the Checkstyle class path\" );\n                        urls.add( outputDirectoryUrl );\n                    }\n                }\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        URLClassLoader projectClassLoader = new URLClassLoader( (URL[]) urls.toArray( new URL[urls.size()] ), null );\n        checker.setClassloader( projectClassLoader );\n\n        checker.setModuleClassLoader( Thread.currentThread().getContextClassLoader() );\n\n        if ( filterSet != null )\n        {\n            checker.addFilter( filterSet );\n        }\n\n        checker.configure( config );\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n\n        if ( consoleOutput )\n        {\n            checker.addListener( getConsoleListener() );\n        }\n\n        CheckstyleReportListener sinkListener = new CheckstyleReportListener( sourceDirectory );\n        if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n            && ( testSourceDirectory.isDirectory() ) )\n        {\n            sinkListener.addSourceDirectory( testSourceDirectory );\n        }\n\n        checker.addListener( sinkListener );\n\n        ArrayList filesList = new ArrayList();\n        for (int i = 0; i < files.length; i++) {\n            filesList.add(files[i]);\n        }\n        int nbErrors = checker.process( filesList );\n\n        checker.destroy();\n\n        if ( stringOutputStream != null )\n        {\n            getLog().info( stringOutputStream.toString() );\n        }\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            // TODO: should be a failure, not an error. Report is not meant to\n            // throw an exception here (so site would\n            // work regardless of config), but should record this information\n            throw new MavenReportException( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n        else if ( nbErrors > 0 )\n        {\n            getLog().info( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n\n        return sinkListener.getResults();\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void generateRSS( CheckstyleResults results )\n        throws MavenReportException\n    {\n        VelocityTemplate vtemplate = new VelocityTemplate( velocityComponent, PLUGIN_RESOURCES );\n        vtemplate.setLog( getLog() );\n\n        Context context = new VelocityContext();\n        context.put( \"results\", results );\n        context.put( \"project\", project );\n        context.put( \"copyright\", getCopyright() );\n        context.put( \"levelInfo\", SeverityLevel.INFO );\n        context.put( \"levelWarning\", SeverityLevel.WARNING );\n        context.put( \"levelError\", SeverityLevel.ERROR );\n        context.put( \"stringutils\", new StringUtils() );\n\n        try\n        {\n            vtemplate.generate( outputDirectory.getPath() + \"/checkstyle.rss\", \"checkstyle-rss.vm\", context );\n        }\n        catch ( ResourceNotFoundException e )\n        {\n            throw new MavenReportException( \"Unable to find checkstyle-rss.vm resource.\", e );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n        catch ( VelocityException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n    }","id":51794,"modified_method":"private void generateRSS( CheckstyleResults results )\n        throws MavenReportException\n    {\n        if ( velocityComponent == null )\n        {\n            try\n            {\n                velocityComponent = (VelocityComponent) serviceLocator.lookup( VelocityComponent.ROLE );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new MavenReportException( \"Failed to setup Velocity\", e );\n            }\n        }\n\n        VelocityTemplate vtemplate = new VelocityTemplate( velocityComponent, PLUGIN_RESOURCES );\n        vtemplate.setLog( getLog() );\n\n        Context context = new VelocityContext();\n        context.put( \"results\", results );\n        context.put( \"project\", project );\n        context.put( \"copyright\", getCopyright() );\n        context.put( \"levelInfo\", SeverityLevel.INFO );\n        context.put( \"levelWarning\", SeverityLevel.WARNING );\n        context.put( \"levelError\", SeverityLevel.ERROR );\n        context.put( \"stringutils\", new StringUtils() );\n\n        try\n        {\n            vtemplate.generate( outputDirectory.getPath() + \"/checkstyle.rss\", \"checkstyle-rss.vm\", context );\n        }\n        catch ( ResourceNotFoundException e )\n        {\n            throw new MavenReportException( \"Unable to find checkstyle-rss.vm resource.\", e );\n        }\n        catch ( MojoExecutionException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n        catch ( VelocityException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to generate checkstyle.rss.\", e );\n        }\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void generateMainReport( CheckstyleResults results, Configuration config, ModuleFactory moduleFactory,\n                                     ResourceBundle bundle )\n    {\n        CheckstyleReportGenerator generator = new CheckstyleReportGenerator( getSink(), bundle, project.getBasedir(), siteTool );\n\n        generator.setLog( getLog() );\n        generator.setEnableRulesSummary( enableRulesSummary );\n        generator.setEnableSeveritySummary( enableSeveritySummary );\n        generator.setEnableFilesSummary( enableFilesSummary );\n        generator.setEnableRSS( enableRSS );\n        generator.setCheckstyleConfig( config );\n        generator.setCheckstyleModuleFactory( moduleFactory );\n        if ( linkXRef )\n        {\n            String relativePath = PathTool.getRelativePath( getOutputDirectory(), xrefLocation.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLocation.getName();\n            if ( xrefLocation.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle\n                // binding\n                generator.setXrefLocation( relativePath );\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                for ( Iterator reports = getProject().getReportPlugins().iterator(); reports.hasNext(); )\n                {\n                    ReportPlugin report = (ReportPlugin) reports.next();\n\n                    String artifactId = report.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        generator.setXrefLocation( relativePath );\n                    }\n                }\n            }\n\n            if ( generator.getXrefLocation() == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        generator.generateReport( results );\n    }","id":51795,"modified_method":"private void generateMainReport( CheckstyleResults results, Configuration config, ResourceBundle bundle )\n    {\n        CheckstyleReportGenerator generator = new CheckstyleReportGenerator( getSink(), bundle, project.getBasedir(), siteTool );\n\n        generator.setLog( getLog() );\n        generator.setEnableRulesSummary( enableRulesSummary );\n        generator.setEnableSeveritySummary( enableSeveritySummary );\n        generator.setEnableFilesSummary( enableFilesSummary );\n        generator.setEnableRSS( enableRSS );\n        generator.setCheckstyleConfig( config );\n        if ( linkXRef )\n        {\n            String relativePath = PathTool.getRelativePath( getOutputDirectory(), xrefLocation.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLocation.getName();\n            if ( xrefLocation.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle\n                // binding\n                generator.setXrefLocation( relativePath );\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                for ( Iterator reports = getProject().getReportPlugins().iterator(); reports.hasNext(); )\n                {\n                    ReportPlugin report = (ReportPlugin) reports.next();\n\n                    String artifactId = report.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        generator.setXrefLocation( relativePath );\n                    }\n                }\n            }\n\n            if ( generator.getXrefLocation() == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        generator.generateReport( results );\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"private DefaultLogger getConsoleListener()\n        throws MavenReportException\n    {\n        DefaultLogger consoleListener;\n\n        if ( useFile == null )\n        {\n            stringOutputStream = new StringOutputStream();\n            consoleListener = new DefaultLogger( stringOutputStream, false );\n        }\n        else\n        {\n            OutputStream out = getOutputStream( useFile );\n\n            consoleListener = new DefaultLogger( out, true );\n        }\n\n        return consoleListener;\n    }","id":51796,"modified_method":"private DefaultLogger getConsoleListener()\n        throws MavenReportException\n    {\n        DefaultLogger consoleListener;\n\n        if ( useFile == null )\n        {\n            stringOutputStream = new ByteArrayOutputStream();\n            consoleListener = new DefaultLogger( stringOutputStream, false );\n        }\n        else\n        {\n            OutputStream out = getOutputStream( useFile );\n            consoleListener = new DefaultLogger( out, true );\n        }\n\n        return consoleListener;\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip )\n        {\n            mergeDeprecatedInfo();\n\n            locator.addSearchPath( FileResourceLoader.ID, project.getFile().getParentFile().getAbsolutePath() );\n            locator.addSearchPath( \"url\", \"\" );\n\n            locator.setOutputDirectory( new File( project.getBuild().getDirectory() ) );\n\n            if ( !canGenerateReport() )\n            {\n                getLog().info( \"Source directory does not exist - skipping report.\" );\n                return;\n            }\n\n            // for when we start using maven-shared-io and\n            // maven-shared-monitor...\n            // locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n\n            // locator = new Locator( getLog(), new File(\n            // project.getBuild().getDirectory() ) );\n\n            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // checkstyle will always use the context classloader in order\n                // to load resources (dtds),\n                // so we have to fix it\n                ClassLoader checkstyleClassLoader = PackageNamesLoader.class.getClassLoader();\n                Thread.currentThread().setContextClassLoader( checkstyleClassLoader );\n\n\n                String configFile = getConfigFile();\n                Properties overridingProperties = getOverridingProperties();\n                ModuleFactory moduleFactory;\n                Configuration config;\n                CheckstyleResults results;\n\n                moduleFactory = getModuleFactory();\n\n                config = ConfigurationLoader.loadConfiguration( configFile,\n                                                                new PropertiesExpander( overridingProperties ) );\n                String effectiveEncoding =\n                    StringUtils.isNotEmpty( encoding ) ? encoding : System.getProperty( \"file.encoding\", \"UTF-8\" );\n                if ( StringUtils.isEmpty( encoding ) )\n                {\n                    getLog().warn(\n                                   \"File encoding has not been set, using platform encoding \" + effectiveEncoding\n                                       + \", i.e. build is platform dependent!\" );\n                }\n                Configuration[] modules = config.getChildren();\n                for ( int i = 0; i < modules.length; i++ )\n                {\n                    Configuration module = modules[i];\n                    if ( \"TreeWalker\".equals( module.getName() )\n                        || \"com.puppycrawl.tools.checkstyle.TreeWalker\".equals( module.getName() ) )\n                    {\n                        if ( module instanceof DefaultConfiguration )\n                        {\n                            ( (DefaultConfiguration) module ).addAttribute( \"charset\", effectiveEncoding );\n                        }\n                        else\n                        {\n                            getLog().warn( \"Failed to configure file encoding on module \" + module );\n                        }\n                    }\n                }\n\n                results = executeCheckstyle( config, moduleFactory );\n\n                ResourceBundle bundle = getBundle( locale );\n                generateReportStatics();\n                generateMainReport( results, config, moduleFactory, bundle );\n                if ( enableRSS )\n                {\n                    generateRSS( results );\n                }\n\n            }\n            catch ( CheckstyleException e )\n            {\n                throw new MavenReportException( \"Failed during checkstyle configuration\", e );\n            }\n            finally\n            {\n                //be sure to restore original context classloader\n                Thread.currentThread().setContextClassLoader( currentClassLoader );\n            }\n        }\n    }","id":51797,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip )\n        {\n            mergeDeprecatedInfo();\n\n            locator.addSearchPath( FileResourceLoader.ID, project.getFile().getParentFile().getAbsolutePath() );\n            locator.addSearchPath( \"url\", \"\" );\n\n            locator.setOutputDirectory( new File( project.getBuild().getDirectory() ) );\n\n            if ( !canGenerateReport() )\n            {\n                getLog().info( \"Source directory does not exist - skipping report.\" );\n                return;\n            }\n\n            // for when we start using maven-shared-io and\n            // maven-shared-monitor...\n            // locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n\n            // locator = new Locator( getLog(), new File(\n            // project.getBuild().getDirectory() ) );\n\n            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // checkstyle will always use the context classloader in order\n                // to load resources (dtds),\n                // so we have to fix it\n                ClassLoader checkstyleClassLoader = PackageNamesLoader.class.getClassLoader();\n                Thread.currentThread().setContextClassLoader( checkstyleClassLoader );\n\n\n                String configFile = getConfigFile();\n                Properties overridingProperties = getOverridingProperties();\n                Configuration config;\n                CheckstyleResults results;\n\n                config = ConfigurationLoader.loadConfiguration( configFile,\n                                                                new PropertiesExpander( overridingProperties ) );\n                String effectiveEncoding =\n                    StringUtils.isNotEmpty( encoding ) ? encoding : System.getProperty( \"file.encoding\", \"UTF-8\" );\n                if ( StringUtils.isEmpty( encoding ) )\n                {\n                    getLog().warn(\n                                   \"File encoding has not been set, using platform encoding \" + effectiveEncoding\n                                       + \", i.e. build is platform dependent!\" );\n                }\n                Configuration[] modules = config.getChildren();\n                for ( int i = 0; i < modules.length; i++ )\n                {\n                    Configuration module = modules[i];\n                    if ( \"Checker\".equals( module.getName() )\n                        || \"com.puppycrawl.tools.checkstyle.Checker\".equals( module.getName() ) )\n                    {\n                        if ( module instanceof DefaultConfiguration )\n                        {\n                            ( (DefaultConfiguration) module ).addAttribute( \"charset\", effectiveEncoding );\n                        }\n                        else\n                        {\n                            getLog().warn( \"Failed to configure file encoding on module \" + module );\n                        }\n                    }\n                    if (\"TreeWalker\".equals(module.getName())\n                        || \"com.puppycrawl.tools.checkstyle.TreeWalker\".equals(module.getName()))\n                    {\n                        if (module instanceof DefaultConfiguration)\n                        {\n                            ((DefaultConfiguration) module).addAttribute(\"cacheFile\", cacheFile);\n                        }\n                        else\n                        {\n                            getLog().warn(\"Failed to configure cache file on module \" + module);\n                        }\n                    }\n                }\n\n                results = executeCheckstyle( config );\n\n                ResourceBundle bundle = getBundle( locale );\n                generateReportStatics();\n                generateMainReport( results, config, bundle );\n                if ( enableRSS )\n                {\n                    generateRSS( results );\n                }\n\n            }\n            catch ( CheckstyleException e )\n            {\n                throw new MavenReportException( \"Failed during checkstyle configuration\", e );\n            }\n            finally\n            {\n                //be sure to restore original context classloader\n                Thread.currentThread().setContextClassLoader( currentClassLoader );\n            }\n        }\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Count the number of violations for the given rule.\n     *\n     * @param files An iterator over the set of files that has violations\n     * @param ruleName The name of the rule\n     * @param message A message that, if it's not null, will be matched to the message from the violation\n     * @param severity A severity that, if it's not null, will be matched to the severity from the violation\n     * @return The number of rule violations\n     */\n    private String countRuleViolation( Iterator files, String ruleName, String message, String severity )\n    {\n        long count = 0;\n        String sourceName;\n\n        try\n        {\n            sourceName = checkstyleModuleFactory.createModule( ruleName ).getClass().getName();\n        }\n        catch ( CheckstyleException e )\n        {\n            getLog().error( \"Unable to obtain Source Name for Rule '\" + ruleName + \"'.\", e );\n            return \"(report failure)\";\n        }\n\n        while ( files.hasNext() )\n        {\n            List errors = (List) files.next();\n\n            for ( Iterator error = errors.iterator(); error.hasNext(); )\n            {\n                AuditEvent event = (AuditEvent) error.next();\n\n                if ( event.getSourceName().equals( sourceName ) )\n                {\n                    // check message too, for those that have a specific one.\n                    // like GenericIllegalRegexp and Regexp\n                    if ( message != null )\n                    {\n                        // event.getMessage() uses java.text.MessageFormat in its implementation.\n                        // Read MessageFormat Javadoc about single quote:\n                        // http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html\n                        String msgWithoutSingleQuote = StringUtils.replace( message, \"'\", \"\" );\n                        if ( message.equals( event.getMessage() )\n                            || msgWithoutSingleQuote.equals( event.getMessage() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    // Check the severity. This helps to distinguish between\n                    // different configurations for the same rule, where each\n                    // configuration has a different severity, like JavadocMetod.\n                    // See also http://jira.codehaus.org/browse/MCHECKSTYLE-41\n                    else if ( severity != null )\n                    {\n                        if ( severity.equals( event.getSeverityLevel().getName() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    else\n                    {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return String.valueOf( count );\n    }","id":51798,"modified_method":"/**\n     * Count the number of violations for the given rule.\n     *\n     * @param files An iterator over the set of files that has violations\n     * @param ruleName The name of the rule\n     * @param message A message that, if it's not null, will be matched to the message from the violation\n     * @param severity A severity that, if it's not null, will be matched to the severity from the violation\n     * @return The number of rule violations\n     */\n    private String countRuleViolation( Iterator files, String ruleName, String message, String severity )\n    {\n        long count = 0;\n\n        while ( files.hasNext() )\n        {\n            List errors = (List) files.next();\n\n            for ( Iterator error = errors.iterator(); error.hasNext(); )\n            {\n                AuditEvent event = (AuditEvent) error.next();\n\n                String eventSrcName = event.getSourceName();\n                if ( eventSrcName != null\n                        && ( eventSrcName.endsWith( ruleName )\n                        || eventSrcName.endsWith( ruleName + \"Check\" ) ) )\n                {\n                    // check message too, for those that have a specific one.\n                    // like GenericIllegalRegexp and Regexp\n                    if ( message != null )\n                    {\n                        // event.getMessage() uses java.text.MessageFormat in its implementation.\n                        // Read MessageFormat Javadoc about single quote:\n                        // http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html\n                        String msgWithoutSingleQuote = StringUtils.replace( message, \"'\", \"\" );\n                        if ( message.equals( event.getMessage() )\n                            || msgWithoutSingleQuote.equals( event.getMessage() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    // Check the severity. This helps to distinguish between\n                    // different configurations for the same rule, where each\n                    // configuration has a different severity, like JavadocMetod.\n                    // See also http://jira.codehaus.org/browse/MCHECKSTYLE-41\n                    else if ( severity != null )\n                    {\n                        if ( severity.equals( event.getSeverityLevel().getName() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    else\n                    {\n                        count++;\n                    }\n                }\n            }\n        }\n        return String.valueOf( count );\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testListeners()\n    {\n        fireAuditStarted( null );\n\n        AuditEvent event = new AuditEvent( this, \"/source/path/file1\", null );\n        fireFileStarted( event );\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file1\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file2\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file3\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file4\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireFileFinished( event );\n\n        fireAuditFinished( null );\n\n        CheckstyleReportListener listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.INFO );\n        CheckstyleResults results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.WARNING );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.ERROR );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.IGNORE );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n    }","id":51799,"modified_method":"public void testListeners()\n    {\n        fireAuditStarted( null );\n\n        AuditEvent event = new AuditEvent( this, \"/source/path/file1\", null );\n        fireFileStarted( event );\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file1\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file2\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file3\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file4\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireFileFinished( event );\n\n        fireAuditFinished( null );\n\n        CheckstyleReportListener listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.INFO );\n        CheckstyleResults results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.WARNING );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.ERROR );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.IGNORE );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testResults()\n    {\n        Map files = new HashMap();\n\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass() );\n        AuditEvent event = new AuditEvent( this, \"file1\", message );\n        files.put( \"file1\", Collections.singletonList( event ) );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass() );\n        List events = new ArrayList();\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        files.put( \"file2\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass() );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        files.put( \"file3\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass() );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        files.put( \"file4\", events );\n\n        results.setFiles( files );\n\n        assertEquals( \"test total files\", 4, results.getFiles().size() );\n        assertEquals( \"test file count\", 4, results.getFileCount() );\n\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 4, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 4, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test INFO severity count\", 1, results.getSeverityCount( SeverityLevel.INFO ) );\n        assertEquals( \"test WARNING severity count\", 2, results.getSeverityCount( SeverityLevel.WARNING ) );\n        assertEquals( \"test ERROR severity count\", 3, results.getSeverityCount( SeverityLevel.ERROR ) );\n        assertEquals( \"test IGNORE severity count\", 4, results.getSeverityCount( SeverityLevel.IGNORE ) );\n\n        results.setFileViolations( \"file\", Collections.EMPTY_LIST );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file\" ).size() );\n    }","id":51800,"modified_method":"public void testResults()\n    {\n        Map files = new HashMap();\n\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass(), null );\n        AuditEvent event = new AuditEvent( this, \"file1\", message );\n        files.put( \"file1\", Collections.singletonList( event ) );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass(), null );\n        List events = new ArrayList();\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        files.put( \"file2\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass(), null );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        files.put( \"file3\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass(), null );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        files.put( \"file4\", events );\n\n        results.setFiles( files );\n\n        assertEquals( \"test total files\", 4, results.getFiles().size() );\n        assertEquals( \"test file count\", 4, results.getFileCount() );\n\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 4, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 4, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test INFO severity count\", 1, results.getSeverityCount( SeverityLevel.INFO ) );\n        assertEquals( \"test WARNING severity count\", 2, results.getSeverityCount( SeverityLevel.WARNING ) );\n        assertEquals( \"test ERROR severity count\", 3, results.getSeverityCount( SeverityLevel.ERROR ) );\n        assertEquals( \"test IGNORE severity count\", 4, results.getSeverityCount( SeverityLevel.IGNORE ) );\n\n        results.setFileViolations( \"file\", Collections.EMPTY_LIST );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file\" ).size() );\n    }","commit_id":"8fa74e35f023c13142df5daeb781e55723ac2c84","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void generateMainReport( CheckstyleResults results, Configuration config, ModuleFactory moduleFactory,\n                                     ResourceBundle bundle )\n    {\n        CheckstyleReportGenerator generator = new CheckstyleReportGenerator( getSink(), bundle, project.getBasedir(), siteTool );\n\n        generator.setLog( getLog() );\n        generator.setEnableRulesSummary( enableRulesSummary );\n        generator.setEnableSeveritySummary( enableSeveritySummary );\n        generator.setEnableFilesSummary( enableFilesSummary );\n        generator.setEnableRSS( enableRSS );\n        generator.setCheckstyleConfig( config );\n        generator.setCheckstyleModuleFactory( moduleFactory );\n        if ( linkXRef )\n        {\n            String relativePath = PathTool.getRelativePath( getOutputDirectory(), xrefLocation.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLocation.getName();\n            if ( xrefLocation.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle\n                // binding\n                generator.setXrefLocation( relativePath );\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                for ( Iterator reports = getProject().getReportPlugins().iterator(); reports.hasNext(); )\n                {\n                    ReportPlugin report = (ReportPlugin) reports.next();\n\n                    String artifactId = report.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        generator.setXrefLocation( relativePath );\n                    }\n                }\n            }\n\n            if ( generator.getXrefLocation() == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        generator.generateReport( results );\n    }","id":51801,"modified_method":"private void generateMainReport( CheckstyleResults results, Configuration config, ResourceBundle bundle )\n    {\n        CheckstyleReportGenerator generator = new CheckstyleReportGenerator( getSink(), bundle, project.getBasedir(), siteTool );\n\n        generator.setLog( getLog() );\n        generator.setEnableRulesSummary( enableRulesSummary );\n        generator.setEnableSeveritySummary( enableSeveritySummary );\n        generator.setEnableFilesSummary( enableFilesSummary );\n        generator.setEnableRSS( enableRSS );\n        generator.setCheckstyleConfig( config );\n        if ( linkXRef )\n        {\n            String relativePath = PathTool.getRelativePath( getOutputDirectory(), xrefLocation.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLocation.getName();\n            if ( xrefLocation.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle\n                // binding\n                generator.setXrefLocation( relativePath );\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                for ( Iterator reports = getProject().getReportPlugins().iterator(); reports.hasNext(); )\n                {\n                    ReportPlugin report = (ReportPlugin) reports.next();\n\n                    String artifactId = report.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        generator.setXrefLocation( relativePath );\n                    }\n                }\n            }\n\n            if ( generator.getXrefLocation() == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        generator.generateReport( results );\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"private CheckstyleResults executeCheckstyle( Configuration config, ModuleFactory moduleFactory )\n        throws MavenReportException, CheckstyleException\n    {\n        File[] files;\n        try\n        {\n            files = getFilesToProcess( includes, excludes );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Error getting files to process\", e );\n        }\n\n        FilterSet filterSet = getSuppressions();\n\n        Checker checker = new Checker();\n\n        // setup classloader, needed to avoid \"Unable to get class information\n        // for ...\" errors\n        List classPathStrings;\n        List outputDirectories = new ArrayList();\n        try\n        {\n            classPathStrings = this.project.getCompileClasspathElements();\n            outputDirectories.add( this.project.getBuild().getOutputDirectory() );\n\n            if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n                && ( testSourceDirectory.isDirectory() ) )\n            {\n                classPathStrings = this.project.getTestClasspathElements();\n                outputDirectories.add( this.project.getBuild().getTestOutputDirectory() );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( e.getMessage(), e );\n        }\n\n        List urls = new ArrayList( classPathStrings.size() );\n\n        Iterator iter = classPathStrings.iterator();\n        while ( iter.hasNext() )\n        {\n            try\n            {\n                urls.add( new File( ( (String) iter.next() ) ).toURL() );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        Iterator iterator = outputDirectories.iterator();\n        while ( iterator.hasNext() )\n        {\n            try\n            {\n                String outputDirectoryString = (String) iterator.next();\n                if ( outputDirectoryString != null )\n                {\n                    File outputDirectoryFile = new File( outputDirectoryString );\n                    if ( outputDirectoryFile.exists() )\n                    {\n                        URL outputDirectoryUrl = outputDirectoryFile.toURL();\n                        getLog().debug( \"Adding the outputDirectory \" + outputDirectoryUrl.toString()\n                            + \" to the Checkstyle class path\" );\n                        urls.add( outputDirectoryUrl );\n                    }\n                }\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        URLClassLoader projectClassLoader = new URLClassLoader( (URL[]) urls.toArray( new URL[urls.size()] ), null );\n        checker.setClassloader( projectClassLoader );\n\n        if ( moduleFactory != null )\n        {\n            checker.setModuleFactory( moduleFactory );\n        }\n\n        if ( filterSet != null )\n        {\n            checker.addFilter( filterSet );\n        }\n\n        checker.configure( config );\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n\n        if ( consoleOutput )\n        {\n            checker.addListener( getConsoleListener() );\n        }\n\n        CheckstyleReportListener sinkListener = new CheckstyleReportListener( sourceDirectory );\n        if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n            && ( testSourceDirectory.isDirectory() ) )\n        {\n            sinkListener.addSourceDirectory( testSourceDirectory );\n        }\n\n        checker.addListener( sinkListener );\n\n        int nbErrors = checker.process( files );\n\n        checker.destroy();\n\n        if ( stringOutputStream != null )\n        {\n            getLog().info( stringOutputStream.toString() );\n        }\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            // TODO: should be a failure, not an error. Report is not meant to\n            // throw an exception here (so site would\n            // work regardless of config), but should record this information\n            throw new MavenReportException( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n        else if ( nbErrors > 0 )\n        {\n            getLog().info( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n\n        return sinkListener.getResults();\n    }","id":51802,"modified_method":"private CheckstyleResults executeCheckstyle( Configuration config )\n        throws MavenReportException, CheckstyleException\n    {\n        File[] files;\n        try\n        {\n            files = getFilesToProcess( includes, excludes );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Error getting files to process\", e );\n        }\n\n        FilterSet filterSet = getSuppressions();\n\n        Checker checker = new Checker();\n\n        // setup classloader, needed to avoid \"Unable to get class information\n        // for ...\" errors\n        List classPathStrings;\n        List outputDirectories = new ArrayList();\n        try\n        {\n            classPathStrings = this.project.getCompileClasspathElements();\n            outputDirectories.add( this.project.getBuild().getOutputDirectory() );\n\n            if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n                && ( testSourceDirectory.isDirectory() ) )\n            {\n                classPathStrings = this.project.getTestClasspathElements();\n                outputDirectories.add( this.project.getBuild().getTestOutputDirectory() );\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( e.getMessage(), e );\n        }\n\n        List urls = new ArrayList( classPathStrings.size() );\n\n        Iterator iter = classPathStrings.iterator();\n        while ( iter.hasNext() )\n        {\n            try\n            {\n                urls.add( new File( ( (String) iter.next() ) ).toURL() );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        Iterator iterator = outputDirectories.iterator();\n        while ( iterator.hasNext() )\n        {\n            try\n            {\n                String outputDirectoryString = (String) iterator.next();\n                if ( outputDirectoryString != null )\n                {\n                    File outputDirectoryFile = new File( outputDirectoryString );\n                    if ( outputDirectoryFile.exists() )\n                    {\n                        URL outputDirectoryUrl = outputDirectoryFile.toURL();\n                        getLog().debug( \"Adding the outputDirectory \" + outputDirectoryUrl.toString()\n                            + \" to the Checkstyle class path\" );\n                        urls.add( outputDirectoryUrl );\n                    }\n                }\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n        }\n\n        URLClassLoader projectClassLoader = new URLClassLoader( (URL[]) urls.toArray( new URL[urls.size()] ), null );\n        checker.setClassloader( projectClassLoader );\n\n        checker.setModuleClassLoader( Thread.currentThread().getContextClassLoader() );\n\n        if ( filterSet != null )\n        {\n            checker.addFilter( filterSet );\n        }\n\n        checker.configure( config );\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n\n        if ( consoleOutput )\n        {\n            checker.addListener( getConsoleListener() );\n        }\n\n        CheckstyleReportListener sinkListener = new CheckstyleReportListener( sourceDirectory );\n        if ( includeTestSourceDirectory && ( testSourceDirectory != null ) && ( testSourceDirectory.exists() )\n            && ( testSourceDirectory.isDirectory() ) )\n        {\n            sinkListener.addSourceDirectory( testSourceDirectory );\n        }\n\n        checker.addListener( sinkListener );\n\n        ArrayList filesList = new ArrayList();\n        for (int i = 0; i < files.length; i++) {\n            filesList.add(files[i]);\n        }\n        int nbErrors = checker.process( filesList );\n\n        checker.destroy();\n\n        if ( stringOutputStream != null )\n        {\n            getLog().info( stringOutputStream.toString() );\n        }\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            // TODO: should be a failure, not an error. Report is not meant to\n            // throw an exception here (so site would\n            // work regardless of config), but should record this information\n            throw new MavenReportException( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n        else if ( nbErrors > 0 )\n        {\n            getLog().info( \"There are \" + nbErrors + \" checkstyle errors.\" );\n        }\n\n        return sinkListener.getResults();\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip )\n        {\n            mergeDeprecatedInfo();\n\n            locator.addSearchPath( FileResourceLoader.ID, project.getFile().getParentFile().getAbsolutePath() );\n            locator.addSearchPath( \"url\", \"\" );\n\n            locator.setOutputDirectory( new File( project.getBuild().getDirectory() ) );\n\n            if ( !canGenerateReport() )\n            {\n                getLog().info( \"Source directory does not exist - skipping report.\" );\n                return;\n            }\n\n            // for when we start using maven-shared-io and\n            // maven-shared-monitor...\n            // locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n\n            // locator = new Locator( getLog(), new File(\n            // project.getBuild().getDirectory() ) );\n\n            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // checkstyle will always use the context classloader in order\n                // to load resources (dtds),\n                // so we have to fix it\n                ClassLoader checkstyleClassLoader = PackageNamesLoader.class.getClassLoader();\n                Thread.currentThread().setContextClassLoader( checkstyleClassLoader );\n\n\n                String configFile = getConfigFile();\n                Properties overridingProperties = getOverridingProperties();\n                ModuleFactory moduleFactory;\n                Configuration config;\n                CheckstyleResults results;\n\n                moduleFactory = getModuleFactory();\n\n                config = ConfigurationLoader.loadConfiguration( configFile,\n                                                                new PropertiesExpander( overridingProperties ) );\n                String effectiveEncoding =\n                    StringUtils.isNotEmpty( encoding ) ? encoding : System.getProperty( \"file.encoding\", \"UTF-8\" );\n                if ( StringUtils.isEmpty( encoding ) )\n                {\n                    getLog().warn(\n                                   \"File encoding has not been set, using platform encoding \" + effectiveEncoding\n                                       + \", i.e. build is platform dependent!\" );\n                }\n                Configuration[] modules = config.getChildren();\n                for ( int i = 0; i < modules.length; i++ )\n                {\n                    Configuration module = modules[i];\n                    if ( \"TreeWalker\".equals( module.getName() )\n                        || \"com.puppycrawl.tools.checkstyle.TreeWalker\".equals( module.getName() ) )\n                    {\n                        if ( module instanceof DefaultConfiguration )\n                        {\n                            ( (DefaultConfiguration) module ).addAttribute( \"charset\", effectiveEncoding );\n                        }\n                        else\n                        {\n                            getLog().warn( \"Failed to configure file encoding on module \" + module );\n                        }\n                    }\n                }\n\n                results = executeCheckstyle( config, moduleFactory );\n\n                ResourceBundle bundle = getBundle( locale );\n                generateReportStatics();\n                generateMainReport( results, config, moduleFactory, bundle );\n                if ( enableRSS )\n                {\n                    CheckstyleRssGeneratorRequest request =\n                        new CheckstyleRssGeneratorRequest( this.project, this.getCopyright(), outputDirectory, getLog() );\n                    checkstyleRssGenerator.generateRSS( results, request );\n                }\n\n            }\n            catch ( CheckstyleException e )\n            {\n                throw new MavenReportException( \"Failed during checkstyle configuration\", e );\n            }\n            finally\n            {\n                //be sure to restore original context classloader\n                Thread.currentThread().setContextClassLoader( currentClassLoader );\n            }\n        }\n    }","id":51803,"modified_method":"/** {@inheritDoc} */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip )\n        {\n            mergeDeprecatedInfo();\n\n            locator.addSearchPath( FileResourceLoader.ID, project.getFile().getParentFile().getAbsolutePath() );\n            locator.addSearchPath( \"url\", \"\" );\n\n            locator.setOutputDirectory( new File( project.getBuild().getDirectory() ) );\n\n            if ( !canGenerateReport() )\n            {\n                getLog().info( \"Source directory does not exist - skipping report.\" );\n                return;\n            }\n\n            // for when we start using maven-shared-io and\n            // maven-shared-monitor...\n            // locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) );\n\n            // locator = new Locator( getLog(), new File(\n            // project.getBuild().getDirectory() ) );\n\n            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // checkstyle will always use the context classloader in order\n                // to load resources (dtds),\n                // so we have to fix it\n                ClassLoader checkstyleClassLoader = PackageNamesLoader.class.getClassLoader();\n                Thread.currentThread().setContextClassLoader( checkstyleClassLoader );\n\n\n                String configFile = getConfigFile();\n                Properties overridingProperties = getOverridingProperties();\n                Configuration config;\n                CheckstyleResults results;\n\n                config = ConfigurationLoader.loadConfiguration( configFile,\n                                                                new PropertiesExpander( overridingProperties ) );\n                String effectiveEncoding =\n                    StringUtils.isNotEmpty( encoding ) ? encoding : System.getProperty( \"file.encoding\", \"UTF-8\" );\n                if ( StringUtils.isEmpty( encoding ) )\n                {\n                    getLog().warn(\n                                   \"File encoding has not been set, using platform encoding \" + effectiveEncoding\n                                       + \", i.e. build is platform dependent!\" );\n                }\n                Configuration[] modules = config.getChildren();\n                for ( int i = 0; i < modules.length; i++ )\n                {\n                    Configuration module = modules[i];\n                    if ( \"Checker\".equals( module.getName() )\n                        || \"com.puppycrawl.tools.checkstyle.Checker\".equals( module.getName() ) )\n                    {\n                        if ( module instanceof DefaultConfiguration )\n                        {\n                            ( (DefaultConfiguration) module ).addAttribute( \"charset\", effectiveEncoding );\n                        }\n                        else\n                        {\n                            getLog().warn( \"Failed to configure file encoding on module \" + module );\n                        }\n                    }\n                    if (\"TreeWalker\".equals(module.getName())\n                        || \"com.puppycrawl.tools.checkstyle.TreeWalker\".equals(module.getName()))\n                    {\n                        if (module instanceof DefaultConfiguration)\n                        {\n                            ((DefaultConfiguration) module).addAttribute(\"cacheFile\", cacheFile);\n                        }\n                        else\n                        {\n                            getLog().warn(\"Failed to configure cache file on module \" + module);\n                        }\n                    }\n                }\n\n                results = executeCheckstyle( config );\n\n                ResourceBundle bundle = getBundle( locale );\n                generateReportStatics();\n                generateMainReport( results, config, bundle );\n                if ( enableRSS )\n                {\n                    CheckstyleRssGeneratorRequest request =\n                        new CheckstyleRssGeneratorRequest( this.project, this.getCopyright(), outputDirectory, getLog() );\n                    checkstyleRssGenerator.generateRSS( results, request );\n                }\n\n            }\n            catch ( CheckstyleException e )\n            {\n                throw new MavenReportException( \"Failed during checkstyle configuration\", e );\n            }\n            finally\n            {\n                //be sure to restore original context classloader\n                Thread.currentThread().setContextClassLoader( currentClassLoader );\n            }\n        }\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Count the number of violations for the given rule.\n     *\n     * @param files An iterator over the set of files that has violations\n     * @param ruleName The name of the rule\n     * @param message A message that, if it's not null, will be matched to the message from the violation\n     * @param severity A severity that, if it's not null, will be matched to the severity from the violation\n     * @return The number of rule violations\n     */\n    private String countRuleViolation( Iterator files, String ruleName, String message, String severity )\n    {\n        long count = 0;\n        String sourceName;\n\n        try\n        {\n            sourceName = checkstyleModuleFactory.createModule( ruleName ).getClass().getName();\n        }\n        catch ( CheckstyleException e )\n        {\n            getLog().error( \"Unable to obtain Source Name for Rule '\" + ruleName + \"'.\", e );\n            return \"(report failure)\";\n        }\n\n        while ( files.hasNext() )\n        {\n            List errors = (List) files.next();\n\n            for ( Iterator error = errors.iterator(); error.hasNext(); )\n            {\n                AuditEvent event = (AuditEvent) error.next();\n\n                if ( event.getSourceName().equals( sourceName ) )\n                {\n                    // check message too, for those that have a specific one.\n                    // like GenericIllegalRegexp and Regexp\n                    if ( message != null )\n                    {\n                        // event.getMessage() uses java.text.MessageFormat in its implementation.\n                        // Read MessageFormat Javadoc about single quote:\n                        // http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html\n                        String msgWithoutSingleQuote = StringUtils.replace( message, \"'\", \"\" );\n                        if ( message.equals( event.getMessage() )\n                            || msgWithoutSingleQuote.equals( event.getMessage() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    // Check the severity. This helps to distinguish between\n                    // different configurations for the same rule, where each\n                    // configuration has a different severity, like JavadocMetod.\n                    // See also http://jira.codehaus.org/browse/MCHECKSTYLE-41\n                    else if ( severity != null )\n                    {\n                        if ( severity.equals( event.getSeverityLevel().getName() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    else\n                    {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return String.valueOf( count );\n    }","id":51804,"modified_method":"/**\n     * Count the number of violations for the given rule.\n     *\n     * @param files An iterator over the set of files that has violations\n     * @param ruleName The name of the rule\n     * @param message A message that, if it's not null, will be matched to the message from the violation\n     * @param severity A severity that, if it's not null, will be matched to the severity from the violation\n     * @return The number of rule violations\n     */\n    private String countRuleViolation( Iterator files, String ruleName, String message, String severity )\n    {\n        long count = 0;\n\n        while ( files.hasNext() )\n        {\n            List errors = (List) files.next();\n\n            for ( Iterator error = errors.iterator(); error.hasNext(); )\n            {\n                AuditEvent event = (AuditEvent) error.next();\n\n                String eventSrcName = event.getSourceName();\n                if ( eventSrcName != null\n                        && ( eventSrcName.endsWith( ruleName )\n                        || eventSrcName.endsWith( ruleName + \"Check\" ) ) )\n                {\n                    // check message too, for those that have a specific one.\n                    // like GenericIllegalRegexp and Regexp\n                    if ( message != null )\n                    {\n                        // event.getMessage() uses java.text.MessageFormat in its implementation.\n                        // Read MessageFormat Javadoc about single quote:\n                        // http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html\n                        String msgWithoutSingleQuote = StringUtils.replace( message, \"'\", \"\" );\n                        if ( message.equals( event.getMessage() )\n                            || msgWithoutSingleQuote.equals( event.getMessage() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    // Check the severity. This helps to distinguish between\n                    // different configurations for the same rule, where each\n                    // configuration has a different severity, like JavadocMetod.\n                    // See also http://jira.codehaus.org/browse/MCHECKSTYLE-41\n                    else if ( severity != null )\n                    {\n                        if ( severity.equals( event.getSeverityLevel().getName() ) )\n                        {\n                            count++;\n                        }\n                    }\n                    else\n                    {\n                        count++;\n                    }\n                }\n            }\n        }\n        return String.valueOf( count );\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testListeners()\n    {\n        fireAuditStarted( null );\n\n        AuditEvent event = new AuditEvent( this, \"/source/path/file1\", null );\n        fireFileStarted( event );\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file1\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file2\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file3\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file4\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass() );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireFileFinished( event );\n\n        fireAuditFinished( null );\n\n        CheckstyleReportListener listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.INFO );\n        CheckstyleResults results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.WARNING );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.ERROR );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.IGNORE );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n    }","id":51805,"modified_method":"public void testListeners()\n    {\n        fireAuditStarted( null );\n\n        AuditEvent event = new AuditEvent( this, \"/source/path/file1\", null );\n        fireFileStarted( event );\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file1\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file2\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file2\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file3\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file3\", message ) );\n        fireFileFinished( event );\n\n        event = new AuditEvent( this, \"/source/path/file4\", null );\n        fireFileStarted( event );\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass(), null );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireAddError( new AuditEvent( this, \"/source/path/file4\", message ) );\n        fireFileFinished( event );\n\n        fireAuditFinished( null );\n\n        CheckstyleReportListener listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.INFO );\n        CheckstyleResults results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.WARNING );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.ERROR );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        listener = (CheckstyleReportListener) listenerMap.get( SeverityLevel.IGNORE );\n        results = listener.getResults();\n        assertEquals( \"Test total files\", 4, results.getFiles().size() );\n        assertEquals( \"Test file count\", 4, results.getFileCount() );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testResults()\n    {\n        Map files = new HashMap();\n\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass() );\n        AuditEvent event = new AuditEvent( this, \"file1\", message );\n        files.put( \"file1\", Collections.singletonList( event ) );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass() );\n        List events = new ArrayList();\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        files.put( \"file2\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass() );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        files.put( \"file3\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass() );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        files.put( \"file4\", events );\n\n        results.setFiles( files );\n\n        assertEquals( \"test total files\", 4, results.getFiles().size() );\n        assertEquals( \"test file count\", 4, results.getFileCount() );\n\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 4, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 4, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test INFO severity count\", 1, results.getSeverityCount( SeverityLevel.INFO ) );\n        assertEquals( \"test WARNING severity count\", 2, results.getSeverityCount( SeverityLevel.WARNING ) );\n        assertEquals( \"test ERROR severity count\", 3, results.getSeverityCount( SeverityLevel.ERROR ) );\n        assertEquals( \"test IGNORE severity count\", 4, results.getSeverityCount( SeverityLevel.IGNORE ) );\n\n        results.setFileViolations( \"file\", Collections.EMPTY_LIST );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file\" ).size() );\n    }","id":51806,"modified_method":"public void testResults()\n    {\n        Map files = new HashMap();\n\n        LocalizedMessage message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.INFO, null, getClass(), null );\n        AuditEvent event = new AuditEvent( this, \"file1\", message );\n        files.put( \"file1\", Collections.singletonList( event ) );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.WARNING, null, getClass(), null );\n        List events = new ArrayList();\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        events.add( new AuditEvent( this, \"file2\", message ) );\n        files.put( \"file2\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.ERROR, null, getClass(), null );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        events.add( new AuditEvent( this, \"file3\", message ) );\n        files.put( \"file3\", events );\n\n        message = new LocalizedMessage( 0, 0, \"\", \"\", null, SeverityLevel.IGNORE, null, getClass(), null );\n        events = new ArrayList();\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        events.add( new AuditEvent( this, \"file4\", message ) );\n        files.put( \"file4\", events );\n\n        results.setFiles( files );\n\n        assertEquals( \"test total files\", 4, results.getFiles().size() );\n        assertEquals( \"test file count\", 4, results.getFileCount() );\n\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file0\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 1, results.getFileViolations( \"file1\" ).size() );\n        assertEquals( \"test file severities\", 1, results.getSeverityCount( \"file1\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file1\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 2, results.getFileViolations( \"file2\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 2, results.getSeverityCount( \"file2\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file2\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 3, results.getFileViolations( \"file3\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 3, results.getSeverityCount( \"file3\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file3\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test file violations\", 4, results.getFileViolations( \"file4\" ).size() );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.INFO ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.WARNING ) );\n        assertEquals( \"test file severities\", 0, results.getSeverityCount( \"file4\", SeverityLevel.ERROR ) );\n        assertEquals( \"test file severities\", 4, results.getSeverityCount( \"file4\", SeverityLevel.IGNORE ) );\n\n        assertEquals( \"test INFO severity count\", 1, results.getSeverityCount( SeverityLevel.INFO ) );\n        assertEquals( \"test WARNING severity count\", 2, results.getSeverityCount( SeverityLevel.WARNING ) );\n        assertEquals( \"test ERROR severity count\", 3, results.getSeverityCount( SeverityLevel.ERROR ) );\n        assertEquals( \"test IGNORE severity count\", 4, results.getSeverityCount( SeverityLevel.IGNORE ) );\n\n        results.setFileViolations( \"file\", Collections.EMPTY_LIST );\n        assertEquals( \"test file violations\", 0, results.getFileViolations( \"file\" ).size() );\n    }","commit_id":"5cde9c49f8148d003392bd67b7bae6ef0d0970f6","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void notify(Exchange exchange) throws ApnsException {\n        String message = exchange.getIn().getBody(String.class);\n\n        Collection<String> tokens;\n        if (isTokensConfiguredUsingUri()) {\n            if (hasTokensHeader(exchange)) {\n                throw new IllegalArgumentException(\"Tokens already configured on endpoint \" + ApnsConstants.HEADER_TOKENS);\n            }\n            tokens = new ArrayList<String>(tokenList);\n        } else {\n            String tokensHeader = getHeaderTokens(exchange);\n            tokens = extractTokensFromString(tokensHeader);\n        }\n\n        MessageType messageType = getHeaderMessageType(exchange, MessageType.STRING);\n\n        String payload;\n        if (messageType == MessageType.STRING) {\n            payload = APNS.newPayload().alertBody(message).build();\n        } else {\n            payload = message;\n        }\n        Date expiry = exchange.getIn().getHeader(ApnsConstants.HEADER_EXPIRY, Date.class);\n        if (expiry != null) {\n            getEndpoint().getApnsService().push(tokens, payload, expiry);\n        } else {\n            getEndpoint().getApnsService().push(tokens, payload);\n        }\n    }","id":51807,"modified_method":"private void notify(Exchange exchange) throws ApnsException {\n        MessageType messageType = getHeaderMessageType(exchange, MessageType.STRING);\n\n        if (messageType == MessageType.APNS_NOTIFICATION) {\n            ApnsNotification apnsNotification = exchange.getIn().getBody(ApnsNotification.class);\n            getEndpoint().getApnsService().push(apnsNotification);\n        } else {\n            constructNotificationAndNotify(exchange, messageType);\n        }\n    }","commit_id":"7ca0c8756fa237ba1b9c9caf662dffd0df66c4ae","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"direct:test\").setHeader(ApnsConstants.HEADER_TOKENS, constant(FAKE_TOKEN)).to(\"apns:notify\");\n            }\n        };\n    }","id":51808,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"direct:test\").setHeader(ApnsConstants.HEADER_TOKENS, constant(FAKE_TOKEN)).to(\"apns:notify\");\n                from(\"direct:testWithApnsNotification\")\n                        .setHeader(ApnsConstants.HEADER_MESSAGE_TYPE, constant(MessageType.APNS_NOTIFICATION.name()))\n                        .to(\"apns:notify\");\n            }\n        };\n    }","commit_id":"7ca0c8756fa237ba1b9c9caf662dffd0df66c4ae","url":"https://github.com/apache/camel"},{"original_method":"/**\n\t * Remove a file from the cache.\n\t * @param item The ArchiveStoreItem to remove.\n\t */\n\tsynchronized void removeCachedItem(ArchiveStoreItem item) {\n\t\tstoredData.removeKey(item.key);\n\t}","id":51809,"modified_method":"/**\n\t * Remove a file from the cache.\n\t * @param item The ArchiveStoreItem to remove.\n\t */\n\tsynchronized void removeCachedItem(ArchiveStoreItem item) {\n\t\tsynchronized (storedData) {\n\t\t\tstoredData.removeKey(item.key);\t\n\t\t}\n\t}","commit_id":"5def4f5b403707d0bfb0ef7d4dc880d812b3672e","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Get a cached, previously extracted, file from an archive.\n\t * @param key The key used to fetch the archive.\n\t * @param filename The name of the file within the archive.\n\t * @return A Bucket containing the data requested, or null.\n\t * @throws ArchiveFailureException \n\t */\n\tpublic synchronized Bucket getCached(FreenetURI key, String filename) throws ArchiveFailureException {\n\t\tif(logMINOR) Logger.minor(this, \"Fetch cached: \"+key+ ' ' +filename);\n\t\tArchiveKey k = new ArchiveKey(key, filename);\n\t\tArchiveStoreItem asi = (ArchiveStoreItem) storedData.get(k);\n\t\tif(asi == null) return null;\n\t\t// Promote to top of LRU\n\t\tstoredData.push(k, asi);\n\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\treturn asi.getDataOrThrow();\n\t}","id":51810,"modified_method":"/**\n\t * Get a cached, previously extracted, file from an archive.\n\t * @param key The key used to fetch the archive.\n\t * @param filename The name of the file within the archive.\n\t * @return A Bucket containing the data requested, or null.\n\t * @throws ArchiveFailureException \n\t */\n\tpublic synchronized Bucket getCached(FreenetURI key, String filename) throws ArchiveFailureException {\n\t\tif(logMINOR) Logger.minor(this, \"Fetch cached: \"+key+ ' ' +filename);\n\t\tArchiveKey k = new ArchiveKey(key, filename);\n\t\tArchiveStoreItem asi = null;\n\t\tsynchronized (storedData) {\n\t\t\tasi = (ArchiveStoreItem) storedData.get(k);\t\n\t\t\n\t\t\tif(asi == null) return null;\n\t\t\t// Promote to top of LRU\n\t\t\tstoredData.push(k, asi);\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\treturn asi.getDataOrThrow();\n\t}","commit_id":"5def4f5b403707d0bfb0ef7d4dc880d812b3672e","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add a store element.\n\t */\n\tprivate void addStoreElement(ArchiveStoreContext ctx, FreenetURI key, String name, TempStoreElement temp) {\n\t\tRealArchiveStoreItem element = new RealArchiveStoreItem(this, ctx, key, name, temp);\n\t\tif(logMINOR) Logger.minor(this, \"Adding store element: \"+element+\" ( \"+key+ ' ' +name+\" size \"+element.spaceUsed()+\" )\");\n\t\tstoredData.push(element.key, element);\n\t\ttrimStoredData();\n\t}","id":51811,"modified_method":"/**\n\t * Add a store element.\n\t */\n\tprivate void addStoreElement(ArchiveStoreContext ctx, FreenetURI key, String name, TempStoreElement temp) {\n\t\tRealArchiveStoreItem element = new RealArchiveStoreItem(this, ctx, key, name, temp);\n\t\tif(logMINOR) Logger.minor(this, \"Adding store element: \"+element+\" ( \"+key+ ' ' +name+\" size \"+element.spaceUsed()+\" )\");\n\t\tsynchronized (storedData) {\n\t\t\tstoredData.push(element.key, element);\n\t\t\ttrimStoredData();\n\t\t}\n\t}","commit_id":"5def4f5b403707d0bfb0ef7d4dc880d812b3672e","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add an error element to the cache. This happens when a single file in the archive\n\t * is invalid (usually because it is too large).\n\t * @param ctx The ArchiveStoreContext which must be notified about this element's creation.\n\t * @param key The key from which the archive was fetched.\n\t * @param name The name of the file within the archive.\n\t * @param error The error message to be included on the eventual exception thrown,\n\t * if anyone tries to extract the data for this element.\n\t */\n\tprivate void addErrorElement(ArchiveStoreContext ctx, FreenetURI key, String name, String error) {\n\t\tErrorArchiveStoreItem element = new ErrorArchiveStoreItem(ctx, key, name, error);\n\t\tif(logMINOR) Logger.minor(this, \"Adding error element: \"+element+\" for \"+key+ ' ' +name);\n\t\tstoredData.push(element.key, element);\n\t}","id":51812,"modified_method":"/**\n\t * Add an error element to the cache. This happens when a single file in the archive\n\t * is invalid (usually because it is too large).\n\t * @param ctx The ArchiveStoreContext which must be notified about this element's creation.\n\t * @param key The key from which the archive was fetched.\n\t * @param name The name of the file within the archive.\n\t * @param error The error message to be included on the eventual exception thrown,\n\t * if anyone tries to extract the data for this element.\n\t */\n\tprivate void addErrorElement(ArchiveStoreContext ctx, FreenetURI key, String name, String error) {\n\t\tErrorArchiveStoreItem element = new ErrorArchiveStoreItem(ctx, key, name, error);\n\t\tif(logMINOR) Logger.minor(this, \"Adding error element: \"+element+\" for \"+key+ ' ' +name);\n\t\tsynchronized (storedData) {\n\t\t\tstoredData.push(element.key, element);\t\n\t\t}\n\t}","commit_id":"5def4f5b403707d0bfb0ef7d4dc880d812b3672e","url":"https://github.com/freenet/fred"},{"original_method":"public PatternDescr lhs_and() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:231:17: (left= lhs_unary ( ('and'|'&&')right= lhs_unary )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:231:17: left= lhs_unary ( ('and'|'&&')right= lhs_unary )*\n            {\n\n             AndDescr and = null; \n\n            following.push(FOLLOW_lhs_unary_in_lhs_and987);\n            left=lhs_unary();\n            following.pop();\n\n\n             d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:233:17: ( ('and'|'&&')right= lhs_unary )*\n            loop31:\n            do {\n                int alt31=2;\n                int LA31_0 = input.LA(1);\n                if ( (LA31_0>=38 && LA31_0<=39) ) {\n                    alt31=1;\n                }\n\n\n                switch (alt31) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:233:25: ('and'|'&&')right= lhs_unary\n            \t    {\n\n            \t    if ( (input.LA(1)>=38 && input.LA(1)<=39) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_and996);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_unary_in_lhs_and1007);\n            \t    right=lhs_unary();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( and == null ) {\n            \t    \t\t\t\t\tand = new AndDescr();\n            \t    \t\t\t\t\tand.addDescr( left );\n            \t    \t\t\t\t\td = and;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tand.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop31;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51813,"modified_method":"public PatternDescr lhs_and() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:258:17: (left= lhs_unary ( ('and'|'&&')right= lhs_unary )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:258:17: left= lhs_unary ( ('and'|'&&')right= lhs_unary )*\n            {\n\n             AndDescr and = null; \n\n            following.push(FOLLOW_lhs_unary_in_lhs_and1072);\n            left=lhs_unary();\n            following.pop();\n\n\n             d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:260:17: ( ('and'|'&&')right= lhs_unary )*\n            loop31:\n            do {\n                int alt31=2;\n                int LA31_0 = input.LA(1);\n                if ( (LA31_0>=39 && LA31_0<=40) ) {\n                    alt31=1;\n                }\n\n\n                switch (alt31) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:260:25: ('and'|'&&')right= lhs_unary\n            \t    {\n\n            \t    if ( (input.LA(1)>=39 && input.LA(1)<=40) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_and1081);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_unary_in_lhs_and1092);\n            \t    right=lhs_unary();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( and == null ) {\n            \t    \t\t\t\t\tand = new AndDescr();\n            \t    \t\t\t\t\tand.addDescr( left );\n            \t    \t\t\t\t\td = and;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tand.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop31;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void salience() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:17: ( 'salience' INT ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:17: 'salience' INT ( ';' )? opt_eol\n            {\n\n            match(input,26,FOLLOW_26_in_salience418);\n\n            match(input,INT,FOLLOW_INT_in_salience420);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:32: ( ';' )?\n            int alt22=2;\n            int LA22_0 = input.LA(1);\n            if ( LA22_0==15 ) {\n                alt22=1;\n            }\n            else if ( LA22_0==EOL||LA22_0==20||LA22_0==22||(LA22_0>=25 && LA22_0<=27) ) {\n                alt22=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"94:32: ( \\';\\' )?\", 22, 0, input);\n\n                throw nvae;\n            }\n            switch (alt22) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:32: ';'\n                    {\n\n                    match(input,15,FOLLOW_15_in_salience422);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_salience425);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51814,"modified_method":"public void salience() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:106:17: ( 'salience' INT ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:106:17: 'salience' INT ( ';' )? opt_eol\n            {\n\n            match(input,27,FOLLOW_27_in_salience428);\n\n            match(input,INT,FOLLOW_INT_in_salience430);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:106:32: ( ';' )?\n            int alt22=2;\n            int LA22_0 = input.LA(1);\n            if ( LA22_0==16 ) {\n                alt22=1;\n            }\n            else if ( LA22_0==EOL||LA22_0==21||LA22_0==23||(LA22_0>=26 && LA22_0<=28) ) {\n                alt22=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"106:32: ( \\';\\' )?\", 22, 0, input);\n\n                throw nvae;\n            }\n            switch (alt22) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:106:32: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_salience432);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_salience435);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void no_loop() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:99:17: ( 'no-loop' ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:99:17: 'no-loop' ( ';' )? opt_eol\n            {\n\n            match(input,27,FOLLOW_27_in_no_loop439);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:99:27: ( ';' )?\n            int alt23=2;\n            int LA23_0 = input.LA(1);\n            if ( LA23_0==15 ) {\n                alt23=1;\n            }\n            else if ( LA23_0==EOL||LA23_0==20||LA23_0==22||(LA23_0>=25 && LA23_0<=27) ) {\n                alt23=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"99:27: ( \\';\\' )?\", 23, 0, input);\n\n                throw nvae;\n            }\n            switch (alt23) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:99:27: ';'\n                    {\n\n                    match(input,15,FOLLOW_15_in_no_loop441);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_no_loop444);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51815,"modified_method":"public void no_loop() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:111:17: ( 'no-loop' ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:111:17: 'no-loop' ( ';' )? opt_eol\n            {\n\n            match(input,28,FOLLOW_28_in_no_loop449);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:111:27: ( ';' )?\n            int alt23=2;\n            int LA23_0 = input.LA(1);\n            if ( LA23_0==16 ) {\n                alt23=1;\n            }\n            else if ( LA23_0==EOL||LA23_0==21||LA23_0==23||(LA23_0>=26 && LA23_0<=28) ) {\n                alt23=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"111:27: ( \\';\\' )?\", 23, 0, input);\n\n                throw nvae;\n            }\n            switch (alt23) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:111:27: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_no_loop451);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_no_loop454);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public NotDescr lhs_not() throws RecognitionException {   \n\n        NotDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:270:17: ( 'not' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:270:17: 'not' column= lhs_column\n            {\n\n            match(input,41,FOLLOW_41_in_lhs_not1138);\n\n            following.push(FOLLOW_lhs_column_in_lhs_not1142);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new NotDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51816,"modified_method":"public NotDescr lhs_not() throws RecognitionException {   \n\n        NotDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:297:17: ( 'not' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:297:17: 'not' column= lhs_column\n            {\n\n            match(input,42,FOLLOW_42_in_lhs_not1223);\n\n            following.push(FOLLOW_lhs_column_in_lhs_not1227);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new NotDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_exist() throws RecognitionException {   \n\n        PatternDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:263:17: ( 'exists' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:263:17: 'exists' column= lhs_column\n            {\n\n            match(input,40,FOLLOW_40_in_lhs_exist1109);\n\n            following.push(FOLLOW_lhs_column_in_lhs_exist1113);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new ExistsDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51817,"modified_method":"public PatternDescr lhs_exist() throws RecognitionException {   \n\n        PatternDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:290:17: ( 'exists' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:290:17: 'exists' column= lhs_column\n            {\n\n            match(input,41,FOLLOW_41_in_lhs_exist1194);\n\n            following.push(FOLLOW_lhs_column_in_lhs_exist1198);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new ExistsDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String retval_constraint() throws RecognitionException {   \n\n        String text;\n\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:176:17: (c= chunk )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:176:17: c= chunk\n            {\n\n            following.push(FOLLOW_chunk_in_retval_constraint827);\n            c=chunk();\n            following.pop();\n\n\n             text = c; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51818,"modified_method":"public String retval_constraint() throws RecognitionException {   \n\n        String text;\n\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:203:17: (c= chunk )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:203:17: c= chunk\n            {\n\n            following.push(FOLLOW_chunk_in_retval_constraint912);\n            c=chunk();\n            following.pop();\n\n\n             text = c; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr l = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:107:17: (l= lhs_or )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:107:17: l= lhs_or\n            {\n\n            following.push(FOLLOW_lhs_or_in_lhs470);\n            l=lhs_or();\n            following.pop();\n\n\n             d = l; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51819,"modified_method":"public PatternDescr lhs() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr l = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:17: (l= lhs_or )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:17: l= lhs_or\n            {\n\n            following.push(FOLLOW_lhs_or_in_lhs480);\n            l=lhs_or();\n            following.pop();\n\n\n             d = l; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ColumnDescr lhs_column() throws RecognitionException {   \n\n        ColumnDescr d;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:17: ( fact_binding | fact )\n            int alt24=2;\n            alt24 = dfa24.predict(input);\n            switch (alt24) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:17: fact_binding\n                    {\n\n                    following.push(FOLLOW_fact_binding_in_lhs_column495);\n                    fact_binding();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:116:17: fact\n                    {\n\n                    following.push(FOLLOW_fact_in_lhs_column500);\n                    fact();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51820,"modified_method":"public ColumnDescr lhs_column() throws RecognitionException {   \n\n        ColumnDescr d;\n\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:127:17: (f= fact_binding | f= fact )\n            int alt24=2;\n            alt24 = dfa24.predict(input);\n            switch (alt24) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:127:17: f= fact_binding\n                    {\n\n                    following.push(FOLLOW_fact_binding_in_lhs_column507);\n                    f=fact_binding();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:128:17: f= fact\n                    {\n\n                    following.push(FOLLOW_fact_in_lhs_column516);\n                    f=fact();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void use_expander() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:58:17: ( 'use' 'expander' ID ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:58:17: 'use' 'expander' ID ( ';' )? opt_eol\n            {\n\n            match(input,17,FOLLOW_17_in_use_expander215);\n\n            match(input,18,FOLLOW_18_in_use_expander217);\n\n            match(input,ID,FOLLOW_ID_in_use_expander219);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:58:37: ( ';' )?\n            int alt9=2;\n            int LA9_0 = input.LA(1);\n            if ( LA9_0==15 ) {\n                alt9=1;\n            }\n            else if ( LA9_0==-1||LA9_0==EOL||LA9_0==19 ) {\n                alt9=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"58:37: ( \\';\\' )?\", 9, 0, input);\n\n                throw nvae;\n            }\n            switch (alt9) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:58:37: ';'\n                    {\n\n                    match(input,15,FOLLOW_15_in_use_expander221);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_use_expander224);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51821,"modified_method":"public void use_expander() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:70:17: ( 'use' 'expander' ID ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:70:17: 'use' 'expander' ID ( ';' )? opt_eol\n            {\n\n            match(input,18,FOLLOW_18_in_use_expander225);\n\n            match(input,19,FOLLOW_19_in_use_expander227);\n\n            match(input,ID,FOLLOW_ID_in_use_expander229);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:70:37: ( ';' )?\n            int alt9=2;\n            int LA9_0 = input.LA(1);\n            if ( LA9_0==16 ) {\n                alt9=1;\n            }\n            else if ( LA9_0==-1||LA9_0==EOL||LA9_0==20 ) {\n                alt9=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"70:37: ( \\';\\' )?\", 9, 0, input);\n\n                throw nvae;\n            }\n            switch (alt9) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:70:37: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_use_expander231);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_use_expander234);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String import_statement() throws RecognitionException {   \n\n        String importStatement;\n\n        String name = null;\n\n\n\n        \t\timportStatement = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:54:17: ( 'import' opt_eol name= java_package_or_class ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:54:17: 'import' opt_eol name= java_package_or_class ( ';' )? opt_eol\n            {\n\n            match(input,16,FOLLOW_16_in_import_statement190);\n\n            following.push(FOLLOW_opt_eol_in_import_statement192);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_java_package_or_class_in_import_statement196);\n            name=java_package_or_class();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:54:61: ( ';' )?\n            int alt8=2;\n            int LA8_0 = input.LA(1);\n            if ( LA8_0==15 ) {\n                alt8=1;\n            }\n            else if ( LA8_0==-1||LA8_0==EOL||(LA8_0>=16 && LA8_0<=17)||LA8_0==19 ) {\n                alt8=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"54:61: ( \\';\\' )?\", 8, 0, input);\n\n                throw nvae;\n            }\n            switch (alt8) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:54:61: ';'\n                    {\n\n                    match(input,15,FOLLOW_15_in_import_statement198);\n\n                    }\n                    break;\n\n            }\n\n\n             importStatement = name; \n\n            following.push(FOLLOW_opt_eol_in_import_statement203);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return importStatement;\n\n    }","id":51822,"modified_method":"public String import_statement() throws RecognitionException {   \n\n        String importStatement;\n\n        String name = null;\n\n\n\n        \t\timportStatement = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:66:17: ( 'import' opt_eol name= java_package_or_class ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:66:17: 'import' opt_eol name= java_package_or_class ( ';' )? opt_eol\n            {\n\n            match(input,17,FOLLOW_17_in_import_statement200);\n\n            following.push(FOLLOW_opt_eol_in_import_statement202);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_java_package_or_class_in_import_statement206);\n            name=java_package_or_class();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:66:61: ( ';' )?\n            int alt8=2;\n            int LA8_0 = input.LA(1);\n            if ( LA8_0==16 ) {\n                alt8=1;\n            }\n            else if ( LA8_0==-1||LA8_0==EOL||(LA8_0>=17 && LA8_0<=18)||LA8_0==20 ) {\n                alt8=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"66:61: ( \\';\\' )?\", 8, 0, input);\n\n                throw nvae;\n            }\n            switch (alt8) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:66:61: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_import_statement208);\n\n                    }\n                    break;\n\n            }\n\n\n             importStatement = name; \n\n            following.push(FOLLOW_opt_eol_in_import_statement213);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return importStatement;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String chunk() throws RecognitionException {   \n\n        String text;\n        Token any=null;\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:17: ( ( (any= . ) | ( '(' c= chunk ')' ) )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            loop29:\n            do {\n                int alt29=3;\n                alt29 = dfa29.predict(input);\n                switch (alt29) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:25: (any= . )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:25: (any= . )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:27: any= .\n            \t    {\n\n            \t    any=(Token)input.LT(1);\n            \t    matchAny(input);\n\n\n            \t    \t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\ttext = any.getText();\n            \t    \t\t\t\t\t} else {\n            \t    \t\t\t\t\t\ttext = text + \" \" + any.getText(); \n            \t    \t\t\t\t\t} \n            \t    \t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n            \tcase 2 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:25: ( '(' c= chunk ')' )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:25: ( '(' c= chunk ')' )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:27: '(' c= chunk ')'\n            \t    {\n\n            \t    match(input,28,FOLLOW_28_in_chunk868);\n\n            \t    following.push(FOLLOW_chunk_in_chunk872);\n            \t    c=chunk();\n            \t    following.pop();\n\n\n            \t    match(input,29,FOLLOW_29_in_chunk874);\n\n\n            \t    \t\t\t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\t\t\ttext = \"( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t} else {\n            \t    \t\t\t\t\t\t\t\ttext = text + \" ( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t}\n            \t    \t\t\t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop29;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51823,"modified_method":"public String chunk() throws RecognitionException {   \n\n        String text;\n        Token any=null;\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: ( ( (any= . ) | ( '(' c= chunk ')' ) )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            loop29:\n            do {\n                int alt29=3;\n                alt29 = dfa29.predict(input);\n                switch (alt29) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:25: (any= . )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:25: (any= . )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:27: any= .\n            \t    {\n\n            \t    any=(Token)input.LT(1);\n            \t    matchAny(input);\n\n\n            \t    \t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\ttext = any.getText();\n            \t    \t\t\t\t\t} else {\n            \t    \t\t\t\t\t\ttext = text + \" \" + any.getText(); \n            \t    \t\t\t\t\t} \n            \t    \t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n            \tcase 2 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:217:25: ( '(' c= chunk ')' )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:217:25: ( '(' c= chunk ')' )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:217:27: '(' c= chunk ')'\n            \t    {\n\n            \t    match(input,29,FOLLOW_29_in_chunk953);\n\n            \t    following.push(FOLLOW_chunk_in_chunk957);\n            \t    c=chunk();\n            \t    following.pop();\n\n\n            \t    match(input,30,FOLLOW_30_in_chunk959);\n\n\n            \t    \t\t\t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\t\t\ttext = \"( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t} else {\n            \t    \t\t\t\t\t\t\t\ttext = text + \" ( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t}\n            \t    \t\t\t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop29;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_or() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: (left= lhs_and ( ('or'|'||')right= lhs_and )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: left= lhs_and ( ('or'|'||')right= lhs_and )*\n            {\n\n             OrDescr or = null; \n\n            following.push(FOLLOW_lhs_and_in_lhs_or926);\n            left=lhs_and();\n            following.pop();\n\n\n            d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:212:17: ( ('or'|'||')right= lhs_and )*\n            loop30:\n            do {\n                int alt30=2;\n                int LA30_0 = input.LA(1);\n                if ( (LA30_0>=36 && LA30_0<=37) ) {\n                    alt30=1;\n                }\n\n\n                switch (alt30) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:212:25: ('or'|'||')right= lhs_and\n            \t    {\n\n            \t    if ( (input.LA(1)>=36 && input.LA(1)<=37) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_or936);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_and_in_lhs_or947);\n            \t    right=lhs_and();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( or == null ) {\n            \t    \t\t\t\t\tor = new OrDescr();\n            \t    \t\t\t\t\tor.addDescr( left );\n            \t    \t\t\t\t\td = or;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tor.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop30;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51824,"modified_method":"public PatternDescr lhs_or() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:237:17: (left= lhs_and ( ('or'|'||')right= lhs_and )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:237:17: left= lhs_and ( ('or'|'||')right= lhs_and )*\n            {\n\n             OrDescr or = null; \n\n            following.push(FOLLOW_lhs_and_in_lhs_or1011);\n            left=lhs_and();\n            following.pop();\n\n\n            d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:239:17: ( ('or'|'||')right= lhs_and )*\n            loop30:\n            do {\n                int alt30=2;\n                int LA30_0 = input.LA(1);\n                if ( (LA30_0>=37 && LA30_0<=38) ) {\n                    alt30=1;\n                }\n\n\n                switch (alt30) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:239:25: ('or'|'||')right= lhs_and\n            \t    {\n\n            \t    if ( (input.LA(1)>=37 && input.LA(1)<=38) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_or1021);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_and_in_lhs_or1032);\n            \t    right=lhs_and();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( or == null ) {\n            \t    \t\t\t\t\tor = new OrDescr();\n            \t    \t\t\t\t\tor.addDescr( left );\n            \t    \t\t\t\t\td = or;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tor.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop30;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String package_statement() throws RecognitionException {   \n\n        String packageName;\n        Token id=null;\n\n\n        \t\tpackageName = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:17: ( 'package' opt_eol id= ID ( '.' id= ID )* ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:17: 'package' opt_eol id= ID ( '.' id= ID )* ( ';' )? opt_eol\n            {\n\n            match(input,13,FOLLOW_13_in_package_statement141);\n\n            following.push(FOLLOW_opt_eol_in_package_statement143);\n            opt_eol();\n            following.pop();\n\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_package_statement147);\n\n             packageName = id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:73: ( '.' id= ID )*\n            loop6:\n            do {\n                int alt6=2;\n                int LA6_0 = input.LA(1);\n                if ( LA6_0==14 ) {\n                    alt6=1;\n                }\n\n\n                switch (alt6) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:75: '.' id= ID\n            \t    {\n\n            \t    match(input,14,FOLLOW_14_in_package_statement153);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_package_statement157);\n\n            \t     packageName += \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop6;\n                }\n            } while (true);\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:127: ( ';' )?\n            int alt7=2;\n            int LA7_0 = input.LA(1);\n            if ( LA7_0==15 ) {\n                alt7=1;\n            }\n            else if ( LA7_0==-1||LA7_0==EOL||(LA7_0>=16 && LA7_0<=17)||LA7_0==19 ) {\n                alt7=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"47:127: ( \\';\\' )?\", 7, 0, input);\n\n                throw nvae;\n            }\n            switch (alt7) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:47:127: ';'\n                    {\n\n                    match(input,15,FOLLOW_15_in_package_statement164);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_package_statement167);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return packageName;\n\n    }","id":51825,"modified_method":"public String package_statement() throws RecognitionException {   \n\n        String packageName;\n        Token id=null;\n\n\n        \t\tpackageName = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:17: ( 'package' opt_eol id= ID ( '.' id= ID )* ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:17: 'package' opt_eol id= ID ( '.' id= ID )* ( ';' )? opt_eol\n            {\n\n            match(input,14,FOLLOW_14_in_package_statement151);\n\n            following.push(FOLLOW_opt_eol_in_package_statement153);\n            opt_eol();\n            following.pop();\n\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_package_statement157);\n\n             packageName = id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:73: ( '.' id= ID )*\n            loop6:\n            do {\n                int alt6=2;\n                int LA6_0 = input.LA(1);\n                if ( LA6_0==15 ) {\n                    alt6=1;\n                }\n\n\n                switch (alt6) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:75: '.' id= ID\n            \t    {\n\n            \t    match(input,15,FOLLOW_15_in_package_statement163);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_package_statement167);\n\n            \t     packageName += \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop6;\n                }\n            } while (true);\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:127: ( ';' )?\n            int alt7=2;\n            int LA7_0 = input.LA(1);\n            if ( LA7_0==16 ) {\n                alt7=1;\n            }\n            else if ( LA7_0==-1||LA7_0==EOL||(LA7_0>=17 && LA7_0<=18)||LA7_0==20 ) {\n                alt7=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"59:127: ( \\';\\' )?\", 7, 0, input);\n\n                throw nvae;\n            }\n            switch (alt7) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:59:127: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_package_statement174);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_package_statement177);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return packageName;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr fact() throws RecognitionException {   \n\n        PatternDescr d;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:131:17: ( ID opt_eol '(' opt_eol ( constraints )? opt_eol ')' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:131:17: ID opt_eol '(' opt_eol ( constraints )? opt_eol ')' opt_eol\n            {\n\n            match(input,ID,FOLLOW_ID_in_fact566);\n\n            following.push(FOLLOW_opt_eol_in_fact568);\n            opt_eol();\n            following.pop();\n\n\n            match(input,28,FOLLOW_28_in_fact570);\n\n            following.push(FOLLOW_opt_eol_in_fact572);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:131:40: ( constraints )?\n            int alt25=2;\n            alt25 = dfa25.predict(input);\n            switch (alt25) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:131:40: constraints\n                    {\n\n                    following.push(FOLLOW_constraints_in_fact574);\n                    constraints();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_fact577);\n            opt_eol();\n            following.pop();\n\n\n            match(input,29,FOLLOW_29_in_fact579);\n\n            following.push(FOLLOW_opt_eol_in_fact581);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51826,"modified_method":"public ColumnDescr fact() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        List c = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:147:17: (id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:147:17: id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact594);\n\n             d = new ColumnDescr( id.getText() ); \n\n            following.push(FOLLOW_opt_eol_in_fact598);\n            opt_eol();\n            following.pop();\n\n\n            match(input,29,FOLLOW_29_in_fact604);\n\n            following.push(FOLLOW_opt_eol_in_fact606);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:148:29: (c= constraints )?\n            int alt25=2;\n            alt25 = dfa25.predict(input);\n            switch (alt25) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:148:33: c= constraints\n                    {\n\n                    following.push(FOLLOW_constraints_in_fact612);\n                    c=constraints();\n                    following.pop();\n\n\n\n                    \t\t \t\t\tfor ( Iterator cIter = c.iterator() ; cIter.hasNext() ; ) {\n                     \t\t\t\t\t\td.addDescr( (PatternDescr) cIter.next() );\n                     \t\t\t\t\t}\n                     \t\t\t\t\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_fact631);\n            opt_eol();\n            following.pop();\n\n\n            match(input,30,FOLLOW_30_in_fact633);\n\n            following.push(FOLLOW_opt_eol_in_fact635);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_eval() throws RecognitionException {   \n\n        PatternDescr d;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:277:17: ( 'eval' )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:277:17: 'eval'\n            {\n\n            match(input,42,FOLLOW_42_in_lhs_eval1165);\n\n             d = new EvalDescr( \"\" ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51827,"modified_method":"public PatternDescr lhs_eval() throws RecognitionException {   \n\n        PatternDescr d;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:304:17: ( 'eval' )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:304:17: 'eval'\n            {\n\n            match(input,43,FOLLOW_43_in_lhs_eval1250);\n\n             d = new EvalDescr( \"\" ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String getPackageName() { return packageName; }","id":51828,"modified_method":"public PackageDescr getPackageDescr() {\n    \t\treturn packageDescr;\n    \t}","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr fact_binding() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:124:17: ( ID opt_eol ':' opt_eol f= fact opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:124:17: ID opt_eol ':' opt_eol f= fact opt_eol\n            {\n\n            match(input,ID,FOLLOW_ID_in_fact_binding527);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding529);\n            opt_eol();\n            following.pop();\n\n\n            match(input,21,FOLLOW_21_in_fact_binding531);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding533);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_fact_in_fact_binding537);\n            f=fact();\n            following.pop();\n\n\n             d=f; \n\n            following.push(FOLLOW_opt_eol_in_fact_binding541);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51829,"modified_method":"public ColumnDescr fact_binding() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:136:17: (id= ID opt_eol ':' opt_eol f= fact opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:136:17: id= ID opt_eol ':' opt_eol f= fact opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact_binding548);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding550);\n            opt_eol();\n            following.pop();\n\n\n            match(input,22,FOLLOW_22_in_fact_binding552);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding554);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_fact_in_fact_binding558);\n            f=fact();\n            following.pop();\n\n\n             d=f; \n\n            following.push(FOLLOW_opt_eol_in_fact_binding562);\n            opt_eol();\n            following.pop();\n\n\n\n             \t\t\td=f;\n             \t\t\td.setIdentifier( id.getText() );\n             \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String java_package_or_class() throws RecognitionException {   \n\n        String name;\n        Token id=null;\n\n\n        \t\tname = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:285:17: (id= ID ( '.' id= ID )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:285:17: id= ID ( '.' id= ID )*\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_java_package_or_class1194);\n\n             name=id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:285:46: ( '.' id= ID )*\n            loop33:\n            do {\n                int alt33=2;\n                int LA33_0 = input.LA(1);\n                if ( LA33_0==14 ) {\n                    alt33=1;\n                }\n\n\n                switch (alt33) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:285:48: '.' id= ID\n            \t    {\n\n            \t    match(input,14,FOLLOW_14_in_java_package_or_class1200);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_java_package_or_class1204);\n\n            \t     name = name + \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop33;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return name;\n\n    }","id":51830,"modified_method":"public String java_package_or_class() throws RecognitionException {   \n\n        String name;\n        Token id=null;\n\n\n        \t\tname = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:17: (id= ID ( '.' id= ID )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:17: id= ID ( '.' id= ID )*\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_java_package_or_class1279);\n\n             name=id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:46: ( '.' id= ID )*\n            loop33:\n            do {\n                int alt33=2;\n                int LA33_0 = input.LA(1);\n                if ( LA33_0==15 ) {\n                    alt33=1;\n                }\n\n\n                switch (alt33) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:48: '.' id= ID\n            \t    {\n\n            \t    match(input,15,FOLLOW_15_in_java_package_or_class1285);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_java_package_or_class1289);\n\n            \t     name = name + \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop33;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return name;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_unary() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr u = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:251:17: ( (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:251:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:251:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            int alt32=5;\n            switch ( input.LA(1) ) {\n            case 40:\n                alt32=1;\n                break;\n            case 41:\n                alt32=2;\n                break;\n            case 42:\n                alt32=3;\n                break;\n            case ID:\n                alt32=4;\n                break;\n            case 28:\n                alt32=5;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"251:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | \\'(\\' u= lhs \\')\\' )\", 32, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt32) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:251:25: u= lhs_exist\n                    {\n\n                    following.push(FOLLOW_lhs_exist_in_lhs_unary1045);\n                    u=lhs_exist();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:252:25: u= lhs_not\n                    {\n\n                    following.push(FOLLOW_lhs_not_in_lhs_unary1053);\n                    u=lhs_not();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:253:25: u= lhs_eval\n                    {\n\n                    following.push(FOLLOW_lhs_eval_in_lhs_unary1061);\n                    u=lhs_eval();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:254:25: u= lhs_column\n                    {\n\n                    following.push(FOLLOW_lhs_column_in_lhs_unary1069);\n                    u=lhs_column();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:255:25: '(' u= lhs ')'\n                    {\n\n                    match(input,28,FOLLOW_28_in_lhs_unary1075);\n\n                    following.push(FOLLOW_lhs_in_lhs_unary1079);\n                    u=lhs();\n                    following.pop();\n\n\n                    match(input,29,FOLLOW_29_in_lhs_unary1081);\n\n                    }\n                    break;\n\n            }\n\n\n             d = u; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51831,"modified_method":"public PatternDescr lhs_unary() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr u = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:278:17: ( (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:278:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:278:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            int alt32=5;\n            switch ( input.LA(1) ) {\n            case 41:\n                alt32=1;\n                break;\n            case 42:\n                alt32=2;\n                break;\n            case 43:\n                alt32=3;\n                break;\n            case ID:\n                alt32=4;\n                break;\n            case 29:\n                alt32=5;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"278:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | \\'(\\' u= lhs \\')\\' )\", 32, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt32) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:278:25: u= lhs_exist\n                    {\n\n                    following.push(FOLLOW_lhs_exist_in_lhs_unary1130);\n                    u=lhs_exist();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:279:25: u= lhs_not\n                    {\n\n                    following.push(FOLLOW_lhs_not_in_lhs_unary1138);\n                    u=lhs_not();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:280:25: u= lhs_eval\n                    {\n\n                    following.push(FOLLOW_lhs_eval_in_lhs_unary1146);\n                    u=lhs_eval();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:281:25: u= lhs_column\n                    {\n\n                    following.push(FOLLOW_lhs_column_in_lhs_unary1154);\n                    u=lhs_column();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:282:25: '(' u= lhs ')'\n                    {\n\n                    match(input,29,FOLLOW_29_in_lhs_unary1160);\n\n                    following.push(FOLLOW_lhs_in_lhs_unary1164);\n                    u=lhs();\n                    following.pop();\n\n\n                    match(input,30,FOLLOW_30_in_lhs_unary1166);\n\n                    }\n                    break;\n\n            }\n\n\n             d = u; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String literal_constraint() throws RecognitionException {   \n\n        String text;\n        Token t=null;\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:17: ( (t= STRING | t= INT | t= FLOAT ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:17: (t= STRING | t= INT | t= FLOAT )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:17: (t= STRING | t= INT | t= FLOAT )\n            int alt28=3;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt28=1;\n                break;\n            case INT:\n                alt28=2;\n                break;\n            case FLOAT:\n                alt28=3;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"165:17: (t= STRING | t= INT | t= FLOAT )\", 28, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt28) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:25: t= STRING\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_literal_constraint770);\n\n                     text = t.getText(); text=text.substring( 1, text.length() - 1 ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:166:25: t= INT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,INT,FOLLOW_INT_in_literal_constraint780);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:167:25: t= FLOAT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,FLOAT,FOLLOW_FLOAT_in_literal_constraint793);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n\n            }\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51832,"modified_method":"public String literal_constraint() throws RecognitionException {   \n\n        String text;\n        Token t=null;\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:192:17: ( (t= STRING | t= INT | t= FLOAT ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:192:17: (t= STRING | t= INT | t= FLOAT )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:192:17: (t= STRING | t= INT | t= FLOAT )\n            int alt28=3;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt28=1;\n                break;\n            case INT:\n                alt28=2;\n                break;\n            case FLOAT:\n                alt28=3;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"192:17: (t= STRING | t= INT | t= FLOAT )\", 28, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt28) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:192:25: t= STRING\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_literal_constraint855);\n\n                     text = t.getText(); text=text.substring( 1, text.length() - 1 ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:193:25: t= INT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,INT,FOLLOW_INT_in_literal_constraint865);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:194:25: t= FLOAT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,FLOAT,FOLLOW_FLOAT_in_literal_constraint878);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n\n            }\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr constraint() throws RecognitionException {   \n\n        PatternDescr d;\n        Token f=null;\n        Token op=null;\n        String lc = null;\n\n        String rvc = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:149:17: ( opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:149:17: opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraint661);\n            opt_eol();\n            following.pop();\n\n\n            f=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_constraint667);\n\n            following.push(FOLLOW_opt_eol_in_constraint669);\n            opt_eol();\n            following.pop();\n\n\n            op=(Token)input.LT(1);\n            if ( (input.LA(1)>=30 && input.LA(1)<=35) ) {\n                input.consume();\n                errorRecovery=false;\n            }\n            else {\n                MismatchedSetException mse =\n                    new MismatchedSetException(null,input);\n                recoverFromMismatchedSet(input,mse,FOLLOW_set_in_constraint675);    throw mse;\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint717);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:156:41: (lc= literal_constraint | rvc= retval_constraint )\n            int alt27=2;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt27=1;\n                break;\n            case INT:\n                alt27=1;\n                break;\n            case FLOAT:\n                alt27=1;\n                break;\n            case EOL:\n            case ID:\n            case WS:\n            case SH_STYLE_SINGLE_LINE_COMMENT:\n            case C_STYLE_SINGLE_LINE_COMMENT:\n            case MULTI_LINE_COMMENT:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n            case 36:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n            case 41:\n            case 42:\n                alt27=2;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"156:41: (lc= literal_constraint | rvc= retval_constraint )\", 27, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt27) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:156:49: lc= literal_constraint\n                    {\n\n                    following.push(FOLLOW_literal_constraint_in_constraint723);\n                    lc=literal_constraint();\n                    following.pop();\n\n\n                     d = new LiteralDescr( f.getText(), null, lc ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:157:49: rvc= retval_constraint\n                    {\n\n                    following.push(FOLLOW_retval_constraint_in_constraint736);\n                    rvc=retval_constraint();\n                    following.pop();\n\n\n                     d = new ReturnValueDescr( f.getText(), null, rvc ); \n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint744);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51833,"modified_method":"public PatternDescr constraint() throws RecognitionException {   \n\n        PatternDescr d;\n        Token f=null;\n        Token op=null;\n        String lc = null;\n\n        String rvc = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:173:17: ( opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:173:17: opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraint715);\n            opt_eol();\n            following.pop();\n\n\n            f=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_constraint721);\n\n            following.push(FOLLOW_opt_eol_in_constraint723);\n            opt_eol();\n            following.pop();\n\n\n            op=(Token)input.LT(1);\n            if ( (input.LA(1)>=31 && input.LA(1)<=36) ) {\n                input.consume();\n                errorRecovery=false;\n            }\n            else {\n                MismatchedSetException mse =\n                    new MismatchedSetException(null,input);\n                recoverFromMismatchedSet(input,mse,FOLLOW_set_in_constraint730);    throw mse;\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint784);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:182:41: (lc= literal_constraint | rvc= retval_constraint )\n            int alt27=2;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt27=1;\n                break;\n            case INT:\n                alt27=1;\n                break;\n            case FLOAT:\n                alt27=1;\n                break;\n            case EOL:\n            case ID:\n            case MISC:\n            case WS:\n            case SH_STYLE_SINGLE_LINE_COMMENT:\n            case C_STYLE_SINGLE_LINE_COMMENT:\n            case MULTI_LINE_COMMENT:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n            case 36:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n            case 41:\n            case 42:\n            case 43:\n                alt27=2;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"182:41: (lc= literal_constraint | rvc= retval_constraint )\", 27, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt27) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:182:49: lc= literal_constraint\n                    {\n\n                    following.push(FOLLOW_literal_constraint_in_constraint802);\n                    lc=literal_constraint();\n                    following.pop();\n\n\n                     d = new LiteralDescr( f.getText(), op.getText(), lc ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:183:49: rvc= retval_constraint\n                    {\n\n                    following.push(FOLLOW_retval_constraint_in_constraint815);\n                    rvc=retval_constraint();\n                    following.pop();\n\n\n                     d = new ReturnValueDescr( f.getText(), op.getText(), rvc ); \n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint829);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void rule_options() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: ( 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol\n            {\n\n            match(input,24,FOLLOW_24_in_rule_options361);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:27: ( ':' )?\n            int alt17=2;\n            int LA17_0 = input.LA(1);\n            if ( LA17_0==21 ) {\n                alt17=1;\n            }\n            else if ( LA17_0==EOL||(LA17_0>=26 && LA17_0<=27) ) {\n                alt17=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"88:27: ( \\':\\' )?\", 17, 0, input);\n\n                throw nvae;\n            }\n            switch (alt17) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:27: ':'\n                    {\n\n                    match(input,21,FOLLOW_21_in_rule_options363);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options366);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:25: ( salience | no_loop )\n            int alt18=2;\n            int LA18_0 = input.LA(1);\n            if ( LA18_0==26 ) {\n                alt18=1;\n            }\n            else if ( LA18_0==27 ) {\n                alt18=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"89:25: ( salience | no_loop )\", 18, 0, input);\n\n                throw nvae;\n            }\n            switch (alt18) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:27: salience\n                    {\n\n                    following.push(FOLLOW_salience_in_rule_options373);\n                    salience();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:38: no_loop\n                    {\n\n                    following.push(FOLLOW_no_loop_in_rule_options377);\n                    no_loop();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options381);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:56: ( ( ',' )? opt_eol ( salience | no_loop ) )*\n            loop21:\n            do {\n                int alt21=2;\n                alt21 = dfa21.predict(input);\n                switch (alt21) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:58: ( ',' )? opt_eol ( salience | no_loop )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:58: ( ',' )?\n            \t    int alt19=2;\n            \t    int LA19_0 = input.LA(1);\n            \t    if ( LA19_0==25 ) {\n            \t        alt19=1;\n            \t    }\n            \t    else if ( LA19_0==EOL||(LA19_0>=26 && LA19_0<=27) ) {\n            \t        alt19=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"89:58: ( \\',\\' )?\", 19, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt19) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:58: ','\n            \t            {\n\n            \t            match(input,25,FOLLOW_25_in_rule_options385);\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    following.push(FOLLOW_opt_eol_in_rule_options388);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:71: ( salience | no_loop )\n            \t    int alt20=2;\n            \t    int LA20_0 = input.LA(1);\n            \t    if ( LA20_0==26 ) {\n            \t        alt20=1;\n            \t    }\n            \t    else if ( LA20_0==27 ) {\n            \t        alt20=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"89:71: ( salience | no_loop )\", 20, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt20) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:73: salience\n            \t            {\n\n            \t            following.push(FOLLOW_salience_in_rule_options392);\n            \t            salience();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n            \t        case 2 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:84: no_loop\n            \t            {\n\n            \t            following.push(FOLLOW_no_loop_in_rule_options396);\n            \t            no_loop();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop21;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options403);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51834,"modified_method":"public void rule_options() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:17: ( 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:17: 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol\n            {\n\n            match(input,25,FOLLOW_25_in_rule_options371);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:27: ( ':' )?\n            int alt17=2;\n            int LA17_0 = input.LA(1);\n            if ( LA17_0==22 ) {\n                alt17=1;\n            }\n            else if ( LA17_0==EOL||(LA17_0>=27 && LA17_0<=28) ) {\n                alt17=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"100:27: ( \\':\\' )?\", 17, 0, input);\n\n                throw nvae;\n            }\n            switch (alt17) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:27: ':'\n                    {\n\n                    match(input,22,FOLLOW_22_in_rule_options373);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options376);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:25: ( salience | no_loop )\n            int alt18=2;\n            int LA18_0 = input.LA(1);\n            if ( LA18_0==27 ) {\n                alt18=1;\n            }\n            else if ( LA18_0==28 ) {\n                alt18=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"101:25: ( salience | no_loop )\", 18, 0, input);\n\n                throw nvae;\n            }\n            switch (alt18) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:27: salience\n                    {\n\n                    following.push(FOLLOW_salience_in_rule_options383);\n                    salience();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:38: no_loop\n                    {\n\n                    following.push(FOLLOW_no_loop_in_rule_options387);\n                    no_loop();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options391);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:56: ( ( ',' )? opt_eol ( salience | no_loop ) )*\n            loop21:\n            do {\n                int alt21=2;\n                alt21 = dfa21.predict(input);\n                switch (alt21) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:58: ( ',' )? opt_eol ( salience | no_loop )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:58: ( ',' )?\n            \t    int alt19=2;\n            \t    int LA19_0 = input.LA(1);\n            \t    if ( LA19_0==26 ) {\n            \t        alt19=1;\n            \t    }\n            \t    else if ( LA19_0==EOL||(LA19_0>=27 && LA19_0<=28) ) {\n            \t        alt19=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"101:58: ( \\',\\' )?\", 19, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt19) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:58: ','\n            \t            {\n\n            \t            match(input,26,FOLLOW_26_in_rule_options395);\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    following.push(FOLLOW_opt_eol_in_rule_options398);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:71: ( salience | no_loop )\n            \t    int alt20=2;\n            \t    int LA20_0 = input.LA(1);\n            \t    if ( LA20_0==27 ) {\n            \t        alt20=1;\n            \t    }\n            \t    else if ( LA20_0==28 ) {\n            \t        alt20=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"101:71: ( salience | no_loop )\", 20, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt20) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:73: salience\n            \t            {\n\n            \t            following.push(FOLLOW_salience_in_rule_options402);\n            \t            salience();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n            \t        case 2 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:84: no_loop\n            \t            {\n\n            \t            following.push(FOLLOW_no_loop_in_rule_options406);\n            \t            no_loop();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop21;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options413);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void compilation_unit() throws RecognitionException {   \n\n\n\n        RuleDescr r = null;\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:29:17: ( prolog (r= rule )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:29:17: prolog (r= rule )*\n            {\n\n            following.push(FOLLOW_prolog_in_compilation_unit53);\n            prolog();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:30:17: (r= rule )*\n            loop2:\n            do {\n                int alt2=2;\n                int LA2_0 = input.LA(1);\n                if ( LA2_0==EOL||LA2_0==19 ) {\n                    alt2=1;\n                }\n\n\n                switch (alt2) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:30:18: r= rule\n            \t    {\n\n            \t    following.push(FOLLOW_rule_in_compilation_unit61);\n            \t    r=rule();\n            \t    following.pop();\n\n\n            \t    this.rules.add( r ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop2;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51835,"modified_method":"public void compilation_unit() throws RecognitionException {   \n\n\n\n        RuleDescr r = null;\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:37:17: ( prolog (r= rule )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:37:17: prolog (r= rule )*\n            {\n\n            following.push(FOLLOW_prolog_in_compilation_unit53);\n            prolog();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:38:17: (r= rule )*\n            loop2:\n            do {\n                int alt2=2;\n                int LA2_0 = input.LA(1);\n                if ( LA2_0==EOL||LA2_0==20 ) {\n                    alt2=1;\n                }\n\n\n                switch (alt2) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:38:18: r= rule\n            \t    {\n\n            \t    following.push(FOLLOW_rule_in_compilation_unit61);\n            \t    r=rule();\n            \t    following.pop();\n\n\n            \t    this.packageDescr.addRule( r ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop2;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String word() throws RecognitionException {   \n\n        String word;\n        Token id=null;\n        Token str=null;\n\n\n        \t\tword = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:293:17: (id= ID | 'import' | 'use' | 'rule' | 'salience' | 'no-loop' | 'when' | 'then' | 'end' | str= STRING )\n            int alt34=10;\n            switch ( input.LA(1) ) {\n            case ID:\n                alt34=1;\n                break;\n            case 16:\n                alt34=2;\n                break;\n            case 17:\n                alt34=3;\n                break;\n            case 19:\n                alt34=4;\n                break;\n            case 26:\n                alt34=5;\n                break;\n            case 27:\n                alt34=6;\n                break;\n            case 20:\n                alt34=7;\n                break;\n            case 22:\n                alt34=8;\n                break;\n            case 23:\n                alt34=9;\n                break;\n            case STRING:\n                alt34=10;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"289:1: word returns [String word] : (id= ID | \\'import\\' | \\'use\\' | \\'rule\\' | \\'salience\\' | \\'no-loop\\' | \\'when\\' | \\'then\\' | \\'end\\' | str= STRING );\", 34, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt34) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:293:17: id= ID\n                    {\n\n                    id=(Token)input.LT(1);\n                    match(input,ID,FOLLOW_ID_in_word1234);\n\n                     word=id.getText(); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:294:17: 'import'\n                    {\n\n                    match(input,16,FOLLOW_16_in_word1246);\n\n                     word=\"import\"; \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:295:17: 'use'\n                    {\n\n                    match(input,17,FOLLOW_17_in_word1255);\n\n                     word=\"use\"; \n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:296:17: 'rule'\n                    {\n\n                    match(input,19,FOLLOW_19_in_word1267);\n\n                     word=\"rule\"; \n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:297:17: 'salience'\n                    {\n\n                    match(input,26,FOLLOW_26_in_word1278);\n\n                     word=\"salience\"; \n\n                    }\n                    break;\n                case 6 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:298:17: 'no-loop'\n                    {\n\n                    match(input,27,FOLLOW_27_in_word1286);\n\n                     word=\"no-loop\"; \n\n                    }\n                    break;\n                case 7 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:299:17: 'when'\n                    {\n\n                    match(input,20,FOLLOW_20_in_word1294);\n\n                     word=\"when\"; \n\n                    }\n                    break;\n                case 8 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:300:17: 'then'\n                    {\n\n                    match(input,22,FOLLOW_22_in_word1305);\n\n                     word=\"then\"; \n\n                    }\n                    break;\n                case 9 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:301:17: 'end'\n                    {\n\n                    match(input,23,FOLLOW_23_in_word1316);\n\n                     word=\"end\"; \n\n                    }\n                    break;\n                case 10 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:302:17: str= STRING\n                    {\n\n                    str=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_word1330);\n\n                     word=str.getText(); word=word.substring( 1, word.length()-1 ); \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return word;\n\n    }","id":51836,"modified_method":"public String word() throws RecognitionException {   \n\n        String word;\n        Token id=null;\n        Token str=null;\n\n\n        \t\tword = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:17: (id= ID | 'import' | 'use' | 'rule' | 'salience' | 'no-loop' | 'when' | 'then' | 'end' | str= STRING )\n            int alt34=10;\n            switch ( input.LA(1) ) {\n            case ID:\n                alt34=1;\n                break;\n            case 17:\n                alt34=2;\n                break;\n            case 18:\n                alt34=3;\n                break;\n            case 20:\n                alt34=4;\n                break;\n            case 27:\n                alt34=5;\n                break;\n            case 28:\n                alt34=6;\n                break;\n            case 21:\n                alt34=7;\n                break;\n            case 23:\n                alt34=8;\n                break;\n            case 24:\n                alt34=9;\n                break;\n            case STRING:\n                alt34=10;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"316:1: word returns [String word] : (id= ID | \\'import\\' | \\'use\\' | \\'rule\\' | \\'salience\\' | \\'no-loop\\' | \\'when\\' | \\'then\\' | \\'end\\' | str= STRING );\", 34, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt34) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:17: id= ID\n                    {\n\n                    id=(Token)input.LT(1);\n                    match(input,ID,FOLLOW_ID_in_word1319);\n\n                     word=id.getText(); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:321:17: 'import'\n                    {\n\n                    match(input,17,FOLLOW_17_in_word1331);\n\n                     word=\"import\"; \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:322:17: 'use'\n                    {\n\n                    match(input,18,FOLLOW_18_in_word1340);\n\n                     word=\"use\"; \n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:323:17: 'rule'\n                    {\n\n                    match(input,20,FOLLOW_20_in_word1352);\n\n                     word=\"rule\"; \n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:324:17: 'salience'\n                    {\n\n                    match(input,27,FOLLOW_27_in_word1363);\n\n                     word=\"salience\"; \n\n                    }\n                    break;\n                case 6 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:325:17: 'no-loop'\n                    {\n\n                    match(input,28,FOLLOW_28_in_word1371);\n\n                     word=\"no-loop\"; \n\n                    }\n                    break;\n                case 7 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:326:17: 'when'\n                    {\n\n                    match(input,21,FOLLOW_21_in_word1379);\n\n                     word=\"when\"; \n\n                    }\n                    break;\n                case 8 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:327:17: 'then'\n                    {\n\n                    match(input,23,FOLLOW_23_in_word1390);\n\n                     word=\"then\"; \n\n                    }\n                    break;\n                case 9 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:328:17: 'end'\n                    {\n\n                    match(input,24,FOLLOW_24_in_word1401);\n\n                     word=\"end\"; \n\n                    }\n                    break;\n                case 10 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:329:17: str= STRING\n                    {\n\n                    str=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_word1415);\n\n                     word=str.getText(); word=word.substring( 1, word.length()-1 ); \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return word;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleDescr rule() throws RecognitionException {   \n\n        RuleDescr rule;\n        Token any=null;\n        String ruleName = null;\n\n        PatternDescr l = null;\n\n\n\n        \t\trule = null;\n        \t\tString consequence = \"\";\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:68:17: ( opt_eol 'rule' ruleName= word opt_eol ( rule_options )? ( 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:68:17: opt_eol 'rule' ruleName= word opt_eol ( rule_options )? ( 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_rule248);\n            opt_eol();\n            following.pop();\n\n\n            match(input,19,FOLLOW_19_in_rule252);\n\n            following.push(FOLLOW_word_in_rule256);\n            ruleName=word();\n            following.pop();\n\n\n            following.push(FOLLOW_opt_eol_in_rule258);\n            opt_eol();\n            following.pop();\n\n\n             rule = new RuleDescr( ruleName, null ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:71:17: ( rule_options )?\n            int alt10=2;\n            int LA10_0 = input.LA(1);\n            if ( LA10_0==24 ) {\n                alt10=1;\n            }\n            else if ( LA10_0==EOL||LA10_0==20||LA10_0==22 ) {\n                alt10=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"71:17: ( rule_options )?\", 10, 0, input);\n\n                throw nvae;\n            }\n            switch (alt10) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:71:17: rule_options\n                    {\n\n                    following.push(FOLLOW_rule_options_in_rule267);\n                    rule_options();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:72:17: ( 'when' ( ':' )? opt_eol (l= lhs )* )?\n            int alt13=2;\n            int LA13_0 = input.LA(1);\n            if ( LA13_0==20 ) {\n                alt13=1;\n            }\n            else if ( LA13_0==EOL||LA13_0==22 ) {\n                alt13=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"72:17: ( \\'when\\' ( \\':\\' )? opt_eol (l= lhs )* )?\", 13, 0, input);\n\n                throw nvae;\n            }\n            switch (alt13) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:72:25: 'when' ( ':' )? opt_eol (l= lhs )*\n                    {\n\n                    match(input,20,FOLLOW_20_in_rule274);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:72:32: ( ':' )?\n                    int alt11=2;\n                    int LA11_0 = input.LA(1);\n                    if ( LA11_0==21 ) {\n                        alt11=1;\n                    }\n                    else if ( (LA11_0>=EOL && LA11_0<=ID)||LA11_0==22||LA11_0==28||(LA11_0>=40 && LA11_0<=42) ) {\n                        alt11=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"72:32: ( \\':\\' )?\", 11, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt11) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:72:32: ':'\n                            {\n\n                            match(input,21,FOLLOW_21_in_rule276);\n\n                            }\n                            break;\n\n                    }\n\n\n                    following.push(FOLLOW_opt_eol_in_rule279);\n                    opt_eol();\n                    following.pop();\n\n\n                     AndDescr lhs = new AndDescr(); rule.setLhs( lhs ); \n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:74:33: (l= lhs )*\n                    loop12:\n                    do {\n                        int alt12=2;\n                        int LA12_0 = input.LA(1);\n                        if ( LA12_0==ID||LA12_0==28||(LA12_0>=40 && LA12_0<=42) ) {\n                            alt12=1;\n                        }\n\n\n                        switch (alt12) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:74:34: l= lhs\n                    \t    {\n\n                    \t    following.push(FOLLOW_lhs_in_rule293);\n                    \t    l=lhs();\n                    \t    following.pop();\n\n\n                    \t     lhs.addDescr( l ); \n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop12;\n                        }\n                    } while (true);\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:76:17: ( 'then' ( ':' )? (any= . )* )?\n            int alt16=2;\n            int LA16_0 = input.LA(1);\n            if ( LA16_0==22 ) {\n                alt16=1;\n            }\n            else if ( LA16_0==EOL ) {\n                alt16=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"76:17: ( \\'then\\' ( \\':\\' )? (any= . )* )?\", 16, 0, input);\n\n                throw nvae;\n            }\n            switch (alt16) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:76:25: 'then' ( ':' )? (any= . )*\n                    {\n\n                    match(input,22,FOLLOW_22_in_rule309);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:76:32: ( ':' )?\n                    int alt14=2;\n                    int LA14_0 = input.LA(1);\n                    if ( LA14_0==21 ) {\n                        alt14=1;\n                    }\n                    else if ( (LA14_0>=EOL && LA14_0<=20)||(LA14_0>=22 && LA14_0<=42) ) {\n                        alt14=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"76:32: ( \\':\\' )?\", 14, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt14) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:76:32: ':'\n                            {\n\n                            match(input,21,FOLLOW_21_in_rule311);\n\n                            }\n                            break;\n\n                    }\n\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:77:25: (any= . )*\n                    loop15:\n                    do {\n                        int alt15=2;\n                        alt15 = dfa15.predict(input);\n                        switch (alt15) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:77:26: any= .\n                    \t    {\n\n                    \t    any=(Token)input.LT(1);\n                    \t    matchAny(input);\n\n\n                    \t    \t\t\t\t\tconsequence = consequence + \" \" + any.getText();\n                    \t    \t\t\t\t\n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop15;\n                        }\n                    } while (true);\n\n\n                     rule.setConsequence( consequence ); \n\n                    }\n                    break;\n\n            }\n\n\n            match(input,EOL,FOLLOW_EOL_in_rule346);\n\n            match(input,23,FOLLOW_23_in_rule348);\n\n            following.push(FOLLOW_opt_eol_in_rule350);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return rule;\n\n    }","id":51837,"modified_method":"public RuleDescr rule() throws RecognitionException {   \n\n        RuleDescr rule;\n        Token any=null;\n        String ruleName = null;\n\n        PatternDescr l = null;\n\n\n\n        \t\trule = null;\n        \t\tString consequence = \"\";\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:80:17: ( opt_eol 'rule' ruleName= word opt_eol ( rule_options )? ( 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:80:17: opt_eol 'rule' ruleName= word opt_eol ( rule_options )? ( 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_rule258);\n            opt_eol();\n            following.pop();\n\n\n            match(input,20,FOLLOW_20_in_rule262);\n\n            following.push(FOLLOW_word_in_rule266);\n            ruleName=word();\n            following.pop();\n\n\n            following.push(FOLLOW_opt_eol_in_rule268);\n            opt_eol();\n            following.pop();\n\n\n             rule = new RuleDescr( ruleName, null ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:83:17: ( rule_options )?\n            int alt10=2;\n            int LA10_0 = input.LA(1);\n            if ( LA10_0==25 ) {\n                alt10=1;\n            }\n            else if ( LA10_0==EOL||LA10_0==21||LA10_0==23 ) {\n                alt10=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"83:17: ( rule_options )?\", 10, 0, input);\n\n                throw nvae;\n            }\n            switch (alt10) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:83:17: rule_options\n                    {\n\n                    following.push(FOLLOW_rule_options_in_rule277);\n                    rule_options();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:84:17: ( 'when' ( ':' )? opt_eol (l= lhs )* )?\n            int alt13=2;\n            int LA13_0 = input.LA(1);\n            if ( LA13_0==21 ) {\n                alt13=1;\n            }\n            else if ( LA13_0==EOL||LA13_0==23 ) {\n                alt13=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"84:17: ( \\'when\\' ( \\':\\' )? opt_eol (l= lhs )* )?\", 13, 0, input);\n\n                throw nvae;\n            }\n            switch (alt13) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:84:25: 'when' ( ':' )? opt_eol (l= lhs )*\n                    {\n\n                    match(input,21,FOLLOW_21_in_rule284);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:84:32: ( ':' )?\n                    int alt11=2;\n                    int LA11_0 = input.LA(1);\n                    if ( LA11_0==22 ) {\n                        alt11=1;\n                    }\n                    else if ( (LA11_0>=EOL && LA11_0<=ID)||LA11_0==23||LA11_0==29||(LA11_0>=41 && LA11_0<=43) ) {\n                        alt11=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"84:32: ( \\':\\' )?\", 11, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt11) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:84:32: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule286);\n\n                            }\n                            break;\n\n                    }\n\n\n                    following.push(FOLLOW_opt_eol_in_rule289);\n                    opt_eol();\n                    following.pop();\n\n\n                     AndDescr lhs = new AndDescr(); rule.setLhs( lhs ); \n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:86:33: (l= lhs )*\n                    loop12:\n                    do {\n                        int alt12=2;\n                        int LA12_0 = input.LA(1);\n                        if ( LA12_0==ID||LA12_0==29||(LA12_0>=41 && LA12_0<=43) ) {\n                            alt12=1;\n                        }\n\n\n                        switch (alt12) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:86:34: l= lhs\n                    \t    {\n\n                    \t    following.push(FOLLOW_lhs_in_rule303);\n                    \t    l=lhs();\n                    \t    following.pop();\n\n\n                    \t     lhs.addDescr( l ); \n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop12;\n                        }\n                    } while (true);\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: ( 'then' ( ':' )? (any= . )* )?\n            int alt16=2;\n            int LA16_0 = input.LA(1);\n            if ( LA16_0==23 ) {\n                alt16=1;\n            }\n            else if ( LA16_0==EOL ) {\n                alt16=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"88:17: ( \\'then\\' ( \\':\\' )? (any= . )* )?\", 16, 0, input);\n\n                throw nvae;\n            }\n            switch (alt16) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:25: 'then' ( ':' )? (any= . )*\n                    {\n\n                    match(input,23,FOLLOW_23_in_rule319);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:32: ( ':' )?\n                    int alt14=2;\n                    int LA14_0 = input.LA(1);\n                    if ( LA14_0==22 ) {\n                        alt14=1;\n                    }\n                    else if ( (LA14_0>=EOL && LA14_0<=21)||(LA14_0>=23 && LA14_0<=43) ) {\n                        alt14=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"88:32: ( \\':\\' )?\", 14, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt14) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:32: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule321);\n\n                            }\n                            break;\n\n                    }\n\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:25: (any= . )*\n                    loop15:\n                    do {\n                        int alt15=2;\n                        alt15 = dfa15.predict(input);\n                        switch (alt15) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:26: any= .\n                    \t    {\n\n                    \t    any=(Token)input.LT(1);\n                    \t    matchAny(input);\n\n\n                    \t    \t\t\t\t\tconsequence = consequence + \" \" + any.getText();\n                    \t    \t\t\t\t\n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop15;\n                        }\n                    } while (true);\n\n\n                     rule.setConsequence( consequence ); \n\n                    }\n                    break;\n\n            }\n\n\n            match(input,EOL,FOLLOW_EOL_in_rule356);\n\n            match(input,24,FOLLOW_24_in_rule358);\n\n            following.push(FOLLOW_opt_eol_in_rule360);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return rule;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void prolog() throws RecognitionException {   \n\n\n\n        String name = null;\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:34:17: ( opt_eol (name= package_statement )? opt_eol (name= import_statement )* opt_eol ( use_expander )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:34:17: opt_eol (name= package_statement )? opt_eol (name= import_statement )* opt_eol ( use_expander )? opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_prolog77);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:35:17: (name= package_statement )?\n            int alt3=2;\n            int LA3_0 = input.LA(1);\n            if ( LA3_0==13 ) {\n                alt3=1;\n            }\n            else if ( LA3_0==-1||LA3_0==EOL||(LA3_0>=16 && LA3_0<=17)||LA3_0==19 ) {\n                alt3=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"35:17: (name= package_statement )?\", 3, 0, input);\n\n                throw nvae;\n            }\n            switch (alt3) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:35:19: name= package_statement\n                    {\n\n                    following.push(FOLLOW_package_statement_in_prolog85);\n                    name=package_statement();\n                    following.pop();\n\n\n                     this.packageName = name; \n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_prolog94);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:37:17: (name= import_statement )*\n            loop4:\n            do {\n                int alt4=2;\n                int LA4_0 = input.LA(1);\n                if ( LA4_0==16 ) {\n                    alt4=1;\n                }\n\n\n                switch (alt4) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:37:19: name= import_statement\n            \t    {\n\n            \t    following.push(FOLLOW_import_statement_in_prolog102);\n            \t    name=import_statement();\n            \t    following.pop();\n\n\n            \t     this.imports.add( name ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop4;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_prolog111);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:39:17: ( use_expander )?\n            int alt5=2;\n            int LA5_0 = input.LA(1);\n            if ( LA5_0==17 ) {\n                alt5=1;\n            }\n            else if ( LA5_0==-1||LA5_0==EOL||LA5_0==19 ) {\n                alt5=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"39:17: ( use_expander )?\", 5, 0, input);\n\n                throw nvae;\n            }\n            switch (alt5) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:39:17: use_expander\n                    {\n\n                    following.push(FOLLOW_use_expander_in_prolog115);\n                    use_expander();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_prolog120);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51838,"modified_method":"public void prolog() throws RecognitionException {   \n\n\n\n        String name = null;\n\n\n\n        \t\tString packageName = \"\";\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:45:17: ( opt_eol (name= package_statement )? opt_eol (name= import_statement )* opt_eol ( use_expander )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:45:17: opt_eol (name= package_statement )? opt_eol (name= import_statement )* opt_eol ( use_expander )? opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_prolog83);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:46:17: (name= package_statement )?\n            int alt3=2;\n            int LA3_0 = input.LA(1);\n            if ( LA3_0==14 ) {\n                alt3=1;\n            }\n            else if ( LA3_0==-1||LA3_0==EOL||(LA3_0>=17 && LA3_0<=18)||LA3_0==20 ) {\n                alt3=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"46:17: (name= package_statement )?\", 3, 0, input);\n\n                throw nvae;\n            }\n            switch (alt3) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:46:19: name= package_statement\n                    {\n\n                    following.push(FOLLOW_package_statement_in_prolog91);\n                    name=package_statement();\n                    following.pop();\n\n\n                     packageName = name; \n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_prolog100);\n            opt_eol();\n            following.pop();\n\n\n             this.packageDescr = new PackageDescr( name ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:49:17: (name= import_statement )*\n            loop4:\n            do {\n                int alt4=2;\n                int LA4_0 = input.LA(1);\n                if ( LA4_0==17 ) {\n                    alt4=1;\n                }\n\n\n                switch (alt4) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:49:19: name= import_statement\n            \t    {\n\n            \t    following.push(FOLLOW_import_statement_in_prolog112);\n            \t    name=import_statement();\n            \t    following.pop();\n\n\n            \t     this.packageDescr.addImport( name ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop4;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_prolog121);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:51:17: ( use_expander )?\n            int alt5=2;\n            int LA5_0 = input.LA(1);\n            if ( LA5_0==18 ) {\n                alt5=1;\n            }\n            else if ( LA5_0==-1||LA5_0==EOL||LA5_0==20 ) {\n                alt5=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"51:17: ( use_expander )?\", 5, 0, input);\n\n                throw nvae;\n            }\n            switch (alt5) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:51:17: use_expander\n                    {\n\n                    following.push(FOLLOW_use_expander_in_prolog125);\n                    use_expander();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_prolog130);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public List constraints() throws RecognitionException {   \n\n        List constraints;\n\n        PatternDescr c = null;\n\n\n\n        \t\tconstraints = new ArrayList();\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:139:17: ( opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:139:17: opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraints607);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_constraint_in_constraints613);\n            c=constraint();\n            following.pop();\n\n\n             constraints.add( c ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:141:17: ( opt_eol ',' opt_eol c= constraint )*\n            loop26:\n            do {\n                int alt26=2;\n                alt26 = dfa26.predict(input);\n                switch (alt26) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:141:19: opt_eol ',' opt_eol c= constraint\n            \t    {\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints622);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    match(input,25,FOLLOW_25_in_constraints624);\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints626);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    following.push(FOLLOW_constraint_in_constraints630);\n            \t    c=constraint();\n            \t    following.pop();\n\n\n            \t     constraints.add( c ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop26;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_constraints639);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return constraints;\n\n    }","id":51839,"modified_method":"public List constraints() throws RecognitionException {   \n\n        List constraints;\n\n        PatternDescr c = null;\n\n\n\n        \t\tconstraints = new ArrayList();\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:163:17: ( opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:163:17: opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraints661);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_constraint_in_constraints667);\n            c=constraint();\n            following.pop();\n\n\n             constraints.add( c ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:17: ( opt_eol ',' opt_eol c= constraint )*\n            loop26:\n            do {\n                int alt26=2;\n                alt26 = dfa26.predict(input);\n                switch (alt26) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:165:19: opt_eol ',' opt_eol c= constraint\n            \t    {\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints676);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    match(input,26,FOLLOW_26_in_constraints678);\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints680);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    following.push(FOLLOW_constraint_in_constraints684);\n            \t    c=constraint();\n            \t    following.pop();\n\n\n            \t     constraints.add( c ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop26;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_constraints693);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return constraints;\n\n    }","commit_id":"fff854ec2f66b984223283cbc62ee227de4e99a3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n\tpublic void send(JSONObject jsonObject) {\n\t\tString payload = null;\n\n\t\ttry {\n\t\t\tlong userId = jsonObject.getLong(\"userId\");\n\n\t\t\tList<String> tokens =\n\t\t\t\tPushNotificationsDeviceLocalServiceUtil.getTokens(\n\t\t\t\t\tuserId, \"apple\", QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tif (tokens.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpayload = buildPayload(jsonObject);\n\n\t\t\t_apnsService.push(tokens, payload);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Could not send notification \" + payload, e);\n\t\t}\n\t}","id":51840,"modified_method":"@Override\n\tpublic void send(List<String> tokens, JSONObject jsonObject)\n\t\tthrows Exception {\n\n\t\tString payload = buildPayload(jsonObject);\n\n\t\t_apnsService.push(tokens, payload);\n\t}","commit_id":"9c302f6d8aab877f6820ead992ede15b380b5827","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String buildPayload(JSONObject jsonObject) {\n\t\tPayloadBuilder payload = PayloadBuilder.newPayload();\n\n\t\tString body = jsonObject.getString(\"entryTitle\");\n\n\t\tif (body != null) {\n\t\t\tpayload.alertBody(body);\n\t\t}\n\n\t\treturn payload.build();\n\t}","id":51841,"modified_method":"protected String buildPayload(JSONObject jsonObject) {\n\t\tPayloadBuilder builder = PayloadBuilder.newPayload();\n\n\t\tString entryTitle = jsonObject.getString(\"entryTitle\");\n\n\t\tif (entryTitle != null) {\n\t\t\tbuilder.alertBody(entryTitle);\n\t\t}\n\n\t\treturn builder.build();\n\t}","commit_id":"9c302f6d8aab877f6820ead992ede15b380b5827","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void receive(Message message) {\n\t\tJSONObject jsonObject = (JSONObject)message.getPayload();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received message \" + jsonObject);\n\t\t}\n\n\t\tfor (PushNotificationsSender pushNotificationsSender :\n\t\t\t\t_pushNotificationsSenders) {\n\n\t\t\tpushNotificationsSender.send(jsonObject);\n\t\t}\n\t}","id":51842,"modified_method":"@Override\n\tpublic void receive(Message message) {\n\t\tJSONObject jsonObject = (JSONObject)message.getPayload();\n\t\tlong userId = jsonObject.getLong(\"userId\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Received message \" + jsonObject + \" for userId \" + userId);\n\t\t}\n\n\t\ttry {\n\t\t\tfor (Entry<String, PushNotificationsSender> entry :\n\t\t\t\t\t_pushNotificationsSenders.entrySet()) {\n\n\t\t\t\tString platform = entry.getKey();\n\n\t\t\t\tList<String> tokens =\n\t\t\t\t\tPushNotificationsDeviceLocalServiceUtil.getTokens(\n\t\t\t\t\t\tuserId, platform, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\t\tif (tokens.isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPushNotificationsSender pushNotificationsSender =\n\t\t\t\t\tentry.getValue();\n\n\t\t\t\tpushNotificationsSender.send(tokens, jsonObject);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Could not send notification\", e);\n\t\t}\n\t}","commit_id":"9c302f6d8aab877f6820ead992ede15b380b5827","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<PushNotificationsSender> getPushNotificationsSenders() {\n\t\treturn _pushNotificationsSenders;\n\t}","id":51843,"modified_method":"public Map<String, PushNotificationsSender> getPushNotificationsSenders() {\n\t\treturn _pushNotificationsSenders;\n\t}","commit_id":"9c302f6d8aab877f6820ead992ede15b380b5827","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setPushNotificationsSenders(\n\t\tList<PushNotificationsSender> pushNotificationSenders) {\n\n\t\t_pushNotificationsSenders = pushNotificationSenders;\n\t}","id":51844,"modified_method":"public void setPushNotificationsSenders(\n\t\tMap<String, PushNotificationsSender> pushNotificationSenders) {\n\n\t\t_pushNotificationsSenders = pushNotificationSenders;\n\t}","commit_id":"9c302f6d8aab877f6820ead992ede15b380b5827","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List constraints() throws RecognitionException {   \n\n        List constraints;\n\n        PatternDescr c = null;\n\n\n\n        \t\tconstraints = new ArrayList();\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:171:17: ( opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:171:17: opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraints665);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_constraint_in_constraints671);\n            c=constraint();\n            following.pop();\n\n\n             constraints.add( c ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:173:17: ( opt_eol ',' opt_eol c= constraint )*\n            loop26:\n            do {\n                int alt26=2;\n                alt26 = dfa26.predict(input);\n                switch (alt26) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:173:19: opt_eol ',' opt_eol c= constraint\n            \t    {\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints680);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    match(input,26,FOLLOW_26_in_constraints682);\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints684);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    following.push(FOLLOW_constraint_in_constraints688);\n            \t    c=constraint();\n            \t    following.pop();\n\n\n            \t     constraints.add( c ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop26;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_constraints697);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return constraints;\n\n    }","id":51845,"modified_method":"public List constraints() throws RecognitionException {   \n\n        List constraints;\n\n        PatternDescr c = null;\n\n\n\n        \t\tconstraints = new ArrayList();\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: ( opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:210:17: opt_eol c= constraint ( opt_eol ',' opt_eol c= constraint )* opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraints757);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_constraint_in_constraints763);\n            c=constraint();\n            following.pop();\n\n\n             constraints.add( c ); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:212:17: ( opt_eol ',' opt_eol c= constraint )*\n            loop24:\n            do {\n                int alt24=2;\n                alt24 = dfa24.predict(input);\n                switch (alt24) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:212:19: opt_eol ',' opt_eol c= constraint\n            \t    {\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints772);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    match(input,30,FOLLOW_30_in_constraints774);\n\n            \t    following.push(FOLLOW_opt_eol_in_constraints776);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    following.push(FOLLOW_constraint_in_constraints780);\n            \t    c=constraint();\n            \t    following.pop();\n\n\n            \t     constraints.add( c ); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop24;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_constraints789);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return constraints;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr constraint() throws RecognitionException {   \n\n        PatternDescr d;\n        Token f=null;\n        Token op=null;\n        String lc = null;\n\n        String rvc = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:181:17: ( opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:181:17: opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraint719);\n            opt_eol();\n            following.pop();\n\n\n            f=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_constraint725);\n\n            following.push(FOLLOW_opt_eol_in_constraint727);\n            opt_eol();\n            following.pop();\n\n\n            op=(Token)input.LT(1);\n            if ( (input.LA(1)>=31 && input.LA(1)<=36) ) {\n                input.consume();\n                errorRecovery=false;\n            }\n            else {\n                MismatchedSetException mse =\n                    new MismatchedSetException(null,input);\n                recoverFromMismatchedSet(input,mse,FOLLOW_set_in_constraint734);    throw mse;\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint788);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:41: (lc= literal_constraint | rvc= retval_constraint )\n            int alt27=2;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt27=1;\n                break;\n            case INT:\n                alt27=1;\n                break;\n            case FLOAT:\n                alt27=1;\n                break;\n            case EOL:\n            case ID:\n            case MISC:\n            case WS:\n            case SH_STYLE_SINGLE_LINE_COMMENT:\n            case C_STYLE_SINGLE_LINE_COMMENT:\n            case MULTI_LINE_COMMENT:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n            case 36:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n            case 41:\n            case 42:\n            case 43:\n                alt27=2;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"190:41: (lc= literal_constraint | rvc= retval_constraint )\", 27, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt27) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:49: lc= literal_constraint\n                    {\n\n                    following.push(FOLLOW_literal_constraint_in_constraint806);\n                    lc=literal_constraint();\n                    following.pop();\n\n\n                     d = new LiteralDescr( f.getText(), op.getText(), lc ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:191:49: rvc= retval_constraint\n                    {\n\n                    following.push(FOLLOW_retval_constraint_in_constraint819);\n                    rvc=retval_constraint();\n                    following.pop();\n\n\n                     d = new ReturnValueDescr( f.getText(), op.getText(), rvc ); \n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint833);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51846,"modified_method":"public PatternDescr constraint() throws RecognitionException {   \n\n        PatternDescr d;\n        Token f=null;\n        Token op=null;\n        String lc = null;\n\n        String rvc = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:220:17: ( opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:220:17: opt_eol f= ID opt_eol op= ('=='|'>'|'>='|'<'|'<='|'!=') opt_eol (lc= literal_constraint | rvc= retval_constraint ) opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_constraint811);\n            opt_eol();\n            following.pop();\n\n\n            f=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_constraint817);\n\n            following.push(FOLLOW_opt_eol_in_constraint819);\n            opt_eol();\n            following.pop();\n\n\n            op=(Token)input.LT(1);\n            if ( (input.LA(1)>=31 && input.LA(1)<=36) ) {\n                input.consume();\n                errorRecovery=false;\n            }\n            else {\n                MismatchedSetException mse =\n                    new MismatchedSetException(null,input);\n                recoverFromMismatchedSet(input,mse,FOLLOW_set_in_constraint826);    throw mse;\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint880);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:229:41: (lc= literal_constraint | rvc= retval_constraint )\n            int alt25=2;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt25=1;\n                break;\n            case INT:\n                alt25=1;\n                break;\n            case FLOAT:\n                alt25=1;\n                break;\n            case EOL:\n            case ID:\n            case MISC:\n            case WS:\n            case SH_STYLE_SINGLE_LINE_COMMENT:\n            case C_STYLE_SINGLE_LINE_COMMENT:\n            case MULTI_LINE_COMMENT:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n            case 36:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n            case 41:\n            case 42:\n            case 43:\n                alt25=2;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"229:41: (lc= literal_constraint | rvc= retval_constraint )\", 25, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt25) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:229:49: lc= literal_constraint\n                    {\n\n                    following.push(FOLLOW_literal_constraint_in_constraint898);\n                    lc=literal_constraint();\n                    following.pop();\n\n\n                     \n                    \t\t\t\t\t\t\td = new LiteralDescr( f.getText(), op.getText(), lc ); \n                    \t\t\t\t\t\t\td.setLocation( f.getLine(), f.getCharPositionInLine() );\n                    \t\t\t\t\t\t\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:234:49: rvc= retval_constraint\n                    {\n\n                    following.push(FOLLOW_retval_constraint_in_constraint918);\n                    rvc=retval_constraint();\n                    following.pop();\n\n\n                     \n                    \t\t\t\t\t\t\td = new ReturnValueDescr( f.getText(), op.getText(), rvc ); \n                    \t\t\t\t\t\t\td.setLocation( f.getLine(), f.getCharPositionInLine() );\n                    \t\t\t\t\t\t\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_constraint939);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String chunk() throws RecognitionException {   \n\n        String text;\n        Token any=null;\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:17: ( ( (any= . ) | ( '(' c= chunk ')' ) )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            loop29:\n            do {\n                int alt29=3;\n                alt29 = dfa29.predict(input);\n                switch (alt29) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:25: (any= . )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:25: (any= . )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:218:27: any= .\n            \t    {\n\n            \t    any=(Token)input.LT(1);\n            \t    matchAny(input);\n\n\n            \t    \t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\ttext = any.getText();\n            \t    \t\t\t\t\t} else {\n            \t    \t\t\t\t\t\ttext = text + \" \" + any.getText(); \n            \t    \t\t\t\t\t} \n            \t    \t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n            \tcase 2 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:225:25: ( '(' c= chunk ')' )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:225:25: ( '(' c= chunk ')' )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:225:27: '(' c= chunk ')'\n            \t    {\n\n            \t    match(input,29,FOLLOW_29_in_chunk957);\n\n            \t    following.push(FOLLOW_chunk_in_chunk961);\n            \t    c=chunk();\n            \t    following.pop();\n\n\n            \t    match(input,30,FOLLOW_30_in_chunk963);\n\n\n            \t    \t\t\t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\t\t\ttext = \"( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t} else {\n            \t    \t\t\t\t\t\t\t\ttext = text + \" ( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t}\n            \t    \t\t\t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop29;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51847,"modified_method":"public String chunk() throws RecognitionException {   \n\n        String text;\n        Token any=null;\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:17: ( ( (any= . ) | ( '(' c= chunk ')' ) )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:17: ( (any= . ) | ( '(' c= chunk ')' ) )*\n            loop27:\n            do {\n                int alt27=3;\n                alt27 = dfa27.predict(input);\n                switch (alt27) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:25: (any= . )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:25: (any= . )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:265:27: any= .\n            \t    {\n\n            \t    any=(Token)input.LT(1);\n            \t    matchAny(input);\n\n\n            \t    \t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\ttext = any.getText();\n            \t    \t\t\t\t\t} else {\n            \t    \t\t\t\t\t\ttext = text + \" \" + any.getText(); \n            \t    \t\t\t\t\t} \n            \t    \t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n            \tcase 2 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:272:25: ( '(' c= chunk ')' )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:272:25: ( '(' c= chunk ')' )\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:272:27: '(' c= chunk ')'\n            \t    {\n\n            \t    match(input,28,FOLLOW_28_in_chunk1063);\n\n            \t    following.push(FOLLOW_chunk_in_chunk1067);\n            \t    c=chunk();\n            \t    following.pop();\n\n\n            \t    match(input,29,FOLLOW_29_in_chunk1069);\n\n\n            \t    \t\t\t\t\t\t\tif ( text == null ) {\n            \t    \t\t\t\t\t\t\t\ttext = \"( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t} else {\n            \t    \t\t\t\t\t\t\t\ttext = text + \" ( \" + c + \" )\";\n            \t    \t\t\t\t\t\t\t}\n            \t    \t\t\t\t\t\t\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop27;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleDescr rule() throws RecognitionException {   \n\n        RuleDescr rule;\n        Token loc=null;\n        Token any=null;\n        String ruleName = null;\n\n        PatternDescr l = null;\n\n\n\n        \t\trule = null;\n        \t\tString consequence = \"\";\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:82:17: ( opt_eol loc= 'rule' ruleName= word opt_eol ( rule_options )? (loc= 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:82:17: opt_eol loc= 'rule' ruleName= word opt_eol ( rule_options )? (loc= 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_rule258);\n            opt_eol();\n            following.pop();\n\n\n            loc=(Token)input.LT(1);\n            match(input,20,FOLLOW_20_in_rule264);\n\n            following.push(FOLLOW_word_in_rule268);\n            ruleName=word();\n            following.pop();\n\n\n            following.push(FOLLOW_opt_eol_in_rule270);\n            opt_eol();\n            following.pop();\n\n\n             \n            \t\t\trule = new RuleDescr( ruleName, null ); \n            \t\t\trule.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: ( rule_options )?\n            int alt10=2;\n            int LA10_0 = input.LA(1);\n            if ( LA10_0==25 ) {\n                alt10=1;\n            }\n            else if ( LA10_0==EOL||LA10_0==21||LA10_0==23 ) {\n                alt10=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"88:17: ( rule_options )?\", 10, 0, input);\n\n                throw nvae;\n            }\n            switch (alt10) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: rule_options\n                    {\n\n                    following.push(FOLLOW_rule_options_in_rule279);\n                    rule_options();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:17: (loc= 'when' ( ':' )? opt_eol (l= lhs )* )?\n            int alt13=2;\n            int LA13_0 = input.LA(1);\n            if ( LA13_0==21 ) {\n                alt13=1;\n            }\n            else if ( LA13_0==EOL||LA13_0==23 ) {\n                alt13=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"89:17: (loc= \\'when\\' ( \\':\\' )? opt_eol (l= lhs )* )?\", 13, 0, input);\n\n                throw nvae;\n            }\n            switch (alt13) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:25: loc= 'when' ( ':' )? opt_eol (l= lhs )*\n                    {\n\n                    loc=(Token)input.LT(1);\n                    match(input,21,FOLLOW_21_in_rule288);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:36: ( ':' )?\n                    int alt11=2;\n                    int LA11_0 = input.LA(1);\n                    if ( LA11_0==22 ) {\n                        alt11=1;\n                    }\n                    else if ( (LA11_0>=EOL && LA11_0<=ID)||LA11_0==23||LA11_0==29||(LA11_0>=41 && LA11_0<=43) ) {\n                        alt11=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"89:36: ( \\':\\' )?\", 11, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt11) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:89:36: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule290);\n\n                            }\n                            break;\n\n                    }\n\n\n                    following.push(FOLLOW_opt_eol_in_rule293);\n                    opt_eol();\n                    following.pop();\n\n\n                     \n                    \t\t\t\tAndDescr lhs = new AndDescr(); rule.setLhs( lhs ); \n                    \t\t\t\tlhs.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n                    \t\t\t\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:33: (l= lhs )*\n                    loop12:\n                    do {\n                        int alt12=2;\n                        int LA12_0 = input.LA(1);\n                        if ( LA12_0==ID||LA12_0==29||(LA12_0>=41 && LA12_0<=43) ) {\n                            alt12=1;\n                        }\n\n\n                        switch (alt12) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:94:34: l= lhs\n                    \t    {\n\n                    \t    following.push(FOLLOW_lhs_in_rule307);\n                    \t    l=lhs();\n                    \t    following.pop();\n\n\n                    \t     lhs.addDescr( l ); \n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop12;\n                        }\n                    } while (true);\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:96:17: ( 'then' ( ':' )? (any= . )* )?\n            int alt16=2;\n            int LA16_0 = input.LA(1);\n            if ( LA16_0==23 ) {\n                alt16=1;\n            }\n            else if ( LA16_0==EOL ) {\n                alt16=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"96:17: ( \\'then\\' ( \\':\\' )? (any= . )* )?\", 16, 0, input);\n\n                throw nvae;\n            }\n            switch (alt16) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:96:25: 'then' ( ':' )? (any= . )*\n                    {\n\n                    match(input,23,FOLLOW_23_in_rule323);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:96:32: ( ':' )?\n                    int alt14=2;\n                    int LA14_0 = input.LA(1);\n                    if ( LA14_0==22 ) {\n                        alt14=1;\n                    }\n                    else if ( (LA14_0>=EOL && LA14_0<=21)||(LA14_0>=23 && LA14_0<=43) ) {\n                        alt14=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"96:32: ( \\':\\' )?\", 14, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt14) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:96:32: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule325);\n\n                            }\n                            break;\n\n                    }\n\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:97:25: (any= . )*\n                    loop15:\n                    do {\n                        int alt15=2;\n                        alt15 = dfa15.predict(input);\n                        switch (alt15) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:97:26: any= .\n                    \t    {\n\n                    \t    any=(Token)input.LT(1);\n                    \t    matchAny(input);\n\n\n                    \t    \t\t\t\t\tconsequence = consequence + \" \" + any.getText();\n                    \t    \t\t\t\t\n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop15;\n                        }\n                    } while (true);\n\n\n                     rule.setConsequence( consequence ); \n\n                    }\n                    break;\n\n            }\n\n\n            match(input,EOL,FOLLOW_EOL_in_rule360);\n\n            match(input,24,FOLLOW_24_in_rule362);\n\n            following.push(FOLLOW_opt_eol_in_rule364);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return rule;\n\n    }","id":51848,"modified_method":"public RuleDescr rule() throws RecognitionException {   \n\n        RuleDescr rule;\n        Token loc=null;\n        Token any=null;\n        String ruleName = null;\n\n        List a = null;\n\n        PatternDescr l = null;\n\n\n\n        \t\trule = null;\n        \t\tString consequence = \"\";\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:82:17: ( opt_eol loc= 'rule' ruleName= word opt_eol (a= rule_options )? (loc= 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:82:17: opt_eol loc= 'rule' ruleName= word opt_eol (a= rule_options )? (loc= 'when' ( ':' )? opt_eol (l= lhs )* )? ( 'then' ( ':' )? (any= . )* )? EOL 'end' opt_eol\n            {\n\n            following.push(FOLLOW_opt_eol_in_rule258);\n            opt_eol();\n            following.pop();\n\n\n            loc=(Token)input.LT(1);\n            match(input,20,FOLLOW_20_in_rule264);\n\n            following.push(FOLLOW_word_in_rule268);\n            ruleName=word();\n            following.pop();\n\n\n            following.push(FOLLOW_opt_eol_in_rule270);\n            opt_eol();\n            following.pop();\n\n\n             \n            \t\t\trule = new RuleDescr( ruleName, null ); \n            \t\t\trule.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:17: (a= rule_options )?\n            int alt10=2;\n            int LA10_0 = input.LA(1);\n            if ( LA10_0==25 ) {\n                alt10=1;\n            }\n            else if ( LA10_0==EOL||LA10_0==21||LA10_0==23 ) {\n                alt10=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"88:17: (a= rule_options )?\", 10, 0, input);\n\n                throw nvae;\n            }\n            switch (alt10) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:88:25: a= rule_options\n                    {\n\n                    following.push(FOLLOW_rule_options_in_rule283);\n                    a=rule_options();\n                    following.pop();\n\n\n\n                    \t\t\t\trule.setAttributes( a );\n                    \t\t\t\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:93:17: (loc= 'when' ( ':' )? opt_eol (l= lhs )* )?\n            int alt13=2;\n            int LA13_0 = input.LA(1);\n            if ( LA13_0==21 ) {\n                alt13=1;\n            }\n            else if ( LA13_0==EOL||LA13_0==23 ) {\n                alt13=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"93:17: (loc= \\'when\\' ( \\':\\' )? opt_eol (l= lhs )* )?\", 13, 0, input);\n\n                throw nvae;\n            }\n            switch (alt13) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:93:25: loc= 'when' ( ':' )? opt_eol (l= lhs )*\n                    {\n\n                    loc=(Token)input.LT(1);\n                    match(input,21,FOLLOW_21_in_rule301);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:93:36: ( ':' )?\n                    int alt11=2;\n                    int LA11_0 = input.LA(1);\n                    if ( LA11_0==22 ) {\n                        alt11=1;\n                    }\n                    else if ( (LA11_0>=EOL && LA11_0<=ID)||LA11_0==23||LA11_0==28||(LA11_0>=41 && LA11_0<=43) ) {\n                        alt11=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"93:36: ( \\':\\' )?\", 11, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt11) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:93:36: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule303);\n\n                            }\n                            break;\n\n                    }\n\n\n                    following.push(FOLLOW_opt_eol_in_rule306);\n                    opt_eol();\n                    following.pop();\n\n\n                     \n                    \t\t\t\tAndDescr lhs = new AndDescr(); rule.setLhs( lhs ); \n                    \t\t\t\tlhs.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n                    \t\t\t\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:98:33: (l= lhs )*\n                    loop12:\n                    do {\n                        int alt12=2;\n                        int LA12_0 = input.LA(1);\n                        if ( LA12_0==ID||LA12_0==28||(LA12_0>=41 && LA12_0<=43) ) {\n                            alt12=1;\n                        }\n\n\n                        switch (alt12) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:98:34: l= lhs\n                    \t    {\n\n                    \t    following.push(FOLLOW_lhs_in_rule320);\n                    \t    l=lhs();\n                    \t    following.pop();\n\n\n                    \t     lhs.addDescr( l ); \n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop12;\n                        }\n                    } while (true);\n\n\n                    }\n                    break;\n\n            }\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:17: ( 'then' ( ':' )? (any= . )* )?\n            int alt16=2;\n            int LA16_0 = input.LA(1);\n            if ( LA16_0==23 ) {\n                alt16=1;\n            }\n            else if ( LA16_0==EOL ) {\n                alt16=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"100:17: ( \\'then\\' ( \\':\\' )? (any= . )* )?\", 16, 0, input);\n\n                throw nvae;\n            }\n            switch (alt16) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:25: 'then' ( ':' )? (any= . )*\n                    {\n\n                    match(input,23,FOLLOW_23_in_rule336);\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:32: ( ':' )?\n                    int alt14=2;\n                    int LA14_0 = input.LA(1);\n                    if ( LA14_0==22 ) {\n                        alt14=1;\n                    }\n                    else if ( (LA14_0>=EOL && LA14_0<=21)||(LA14_0>=23 && LA14_0<=43) ) {\n                        alt14=2;\n                    }\n                    else {\n\n                        NoViableAltException nvae =\n                            new NoViableAltException(\"100:32: ( \\':\\' )?\", 14, 0, input);\n\n                        throw nvae;\n                    }\n                    switch (alt14) {\n                        case 1 :\n                            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:100:32: ':'\n                            {\n\n                            match(input,22,FOLLOW_22_in_rule338);\n\n                            }\n                            break;\n\n                    }\n\n\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:25: (any= . )*\n                    loop15:\n                    do {\n                        int alt15=2;\n                        alt15 = dfa15.predict(input);\n                        switch (alt15) {\n                    \tcase 1 :\n                    \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:101:26: any= .\n                    \t    {\n\n                    \t    any=(Token)input.LT(1);\n                    \t    matchAny(input);\n\n\n                    \t    \t\t\t\t\tconsequence = consequence + \" \" + any.getText();\n                    \t    \t\t\t\t\n\n                    \t    }\n                    \t    break;\n\n                    \tdefault :\n                    \t    break loop15;\n                        }\n                    } while (true);\n\n\n                     rule.setConsequence( consequence ); \n\n                    }\n                    break;\n\n            }\n\n\n            match(input,EOL,FOLLOW_EOL_in_rule373);\n\n            match(input,24,FOLLOW_24_in_rule375);\n\n            following.push(FOLLOW_opt_eol_in_rule377);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return rule;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_or() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:245:17: (left= lhs_and ( ('or'|'||')right= lhs_and )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:245:17: left= lhs_and ( ('or'|'||')right= lhs_and )*\n            {\n\n             OrDescr or = null; \n\n            following.push(FOLLOW_lhs_and_in_lhs_or1015);\n            left=lhs_and();\n            following.pop();\n\n\n            d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:17: ( ('or'|'||')right= lhs_and )*\n            loop30:\n            do {\n                int alt30=2;\n                int LA30_0 = input.LA(1);\n                if ( (LA30_0>=37 && LA30_0<=38) ) {\n                    alt30=1;\n                }\n\n\n                switch (alt30) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:25: ('or'|'||')right= lhs_and\n            \t    {\n\n            \t    if ( (input.LA(1)>=37 && input.LA(1)<=38) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_or1025);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_and_in_lhs_or1036);\n            \t    right=lhs_and();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( or == null ) {\n            \t    \t\t\t\t\tor = new OrDescr();\n            \t    \t\t\t\t\tor.addDescr( left );\n            \t    \t\t\t\t\td = or;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tor.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop30;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51849,"modified_method":"public PatternDescr lhs_or() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:292:17: (left= lhs_and ( ('or'|'||')right= lhs_and )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:292:17: left= lhs_and ( ('or'|'||')right= lhs_and )*\n            {\n\n             OrDescr or = null; \n\n            following.push(FOLLOW_lhs_and_in_lhs_or1121);\n            left=lhs_and();\n            following.pop();\n\n\n            d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:294:17: ( ('or'|'||')right= lhs_and )*\n            loop28:\n            do {\n                int alt28=2;\n                int LA28_0 = input.LA(1);\n                if ( (LA28_0>=37 && LA28_0<=38) ) {\n                    alt28=1;\n                }\n\n\n                switch (alt28) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:294:25: ('or'|'||')right= lhs_and\n            \t    {\n\n            \t    if ( (input.LA(1)>=37 && input.LA(1)<=38) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_or1131);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_and_in_lhs_or1142);\n            \t    right=lhs_and();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( or == null ) {\n            \t    \t\t\t\t\tor = new OrDescr();\n            \t    \t\t\t\t\tor.addDescr( left );\n            \t    \t\t\t\t\td = or;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tor.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop28;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void salience() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:114:17: ( 'salience' INT ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:114:17: 'salience' INT ( ';' )? opt_eol\n            {\n\n            match(input,27,FOLLOW_27_in_salience432);\n\n            match(input,INT,FOLLOW_INT_in_salience434);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:114:32: ( ';' )?\n            int alt22=2;\n            int LA22_0 = input.LA(1);\n            if ( LA22_0==16 ) {\n                alt22=1;\n            }\n            else if ( LA22_0==EOL||LA22_0==21||LA22_0==23||(LA22_0>=26 && LA22_0<=28) ) {\n                alt22=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"114:32: ( \\';\\' )?\", 22, 0, input);\n\n                throw nvae;\n            }\n            switch (alt22) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:114:32: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_salience436);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_salience439);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51850,"modified_method":"public AttributeDescr salience() throws RecognitionException {   \n\n        AttributeDescr d;\n        Token loc=null;\n        Token i=null;\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:138:17: (loc= 'salience' opt_eol i= INT ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:138:17: loc= 'salience' opt_eol i= INT ( ';' )? opt_eol\n            {\n\n            loc=(Token)input.LT(1);\n            match(input,26,FOLLOW_26_in_salience496);\n\n            following.push(FOLLOW_opt_eol_in_salience498);\n            opt_eol();\n            following.pop();\n\n\n            i=(Token)input.LT(1);\n            match(input,INT,FOLLOW_INT_in_salience502);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:138:46: ( ';' )?\n            int alt20=2;\n            int LA20_0 = input.LA(1);\n            if ( LA20_0==16 ) {\n                alt20=1;\n            }\n            else if ( LA20_0==EOL||LA20_0==21||LA20_0==23||(LA20_0>=26 && LA20_0<=27) ) {\n                alt20=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"138:46: ( \\';\\' )?\", 20, 0, input);\n\n                throw nvae;\n            }\n            switch (alt20) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:138:46: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_salience504);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_salience507);\n            opt_eol();\n            following.pop();\n\n\n\n            \t\t\td = new AttributeDescr( \"salience\", i.getText() );\n            \t\t\td.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ColumnDescr fact_binding() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:144:17: (id= ID opt_eol ':' opt_eol f= fact opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:144:17: id= ID opt_eol ':' opt_eol f= fact opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact_binding552);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding554);\n            opt_eol();\n            following.pop();\n\n\n            match(input,22,FOLLOW_22_in_fact_binding556);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding558);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_fact_in_fact_binding562);\n            f=fact();\n            following.pop();\n\n\n             d=f; \n\n            following.push(FOLLOW_opt_eol_in_fact_binding566);\n            opt_eol();\n            following.pop();\n\n\n\n             \t\t\td=f;\n             \t\t\td.setIdentifier( id.getText() );\n             \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51851,"modified_method":"public ColumnDescr fact_binding() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:179:17: (id= ID opt_eol ':' opt_eol f= fact opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:179:17: id= ID opt_eol ':' opt_eol f= fact opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact_binding640);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding642);\n            opt_eol();\n            following.pop();\n\n\n            match(input,22,FOLLOW_22_in_fact_binding644);\n\n            following.push(FOLLOW_opt_eol_in_fact_binding646);\n            opt_eol();\n            following.pop();\n\n\n            following.push(FOLLOW_fact_in_fact_binding650);\n            f=fact();\n            following.pop();\n\n\n             d=f; \n\n            following.push(FOLLOW_opt_eol_in_fact_binding654);\n            opt_eol();\n            following.pop();\n\n\n\n             \t\t\td=f;\n             \t\t\td.setIdentifier( id.getText() );\n             \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void rule_options() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:108:17: ( 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:108:17: 'options' ( ':' )? opt_eol ( salience | no_loop ) opt_eol ( ( ',' )? opt_eol ( salience | no_loop ) )* opt_eol\n            {\n\n            match(input,25,FOLLOW_25_in_rule_options375);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:108:27: ( ':' )?\n            int alt17=2;\n            int LA17_0 = input.LA(1);\n            if ( LA17_0==22 ) {\n                alt17=1;\n            }\n            else if ( LA17_0==EOL||(LA17_0>=27 && LA17_0<=28) ) {\n                alt17=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"108:27: ( \\':\\' )?\", 17, 0, input);\n\n                throw nvae;\n            }\n            switch (alt17) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:108:27: ':'\n                    {\n\n                    match(input,22,FOLLOW_22_in_rule_options377);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options380);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:25: ( salience | no_loop )\n            int alt18=2;\n            int LA18_0 = input.LA(1);\n            if ( LA18_0==27 ) {\n                alt18=1;\n            }\n            else if ( LA18_0==28 ) {\n                alt18=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"109:25: ( salience | no_loop )\", 18, 0, input);\n\n                throw nvae;\n            }\n            switch (alt18) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:27: salience\n                    {\n\n                    following.push(FOLLOW_salience_in_rule_options387);\n                    salience();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:38: no_loop\n                    {\n\n                    following.push(FOLLOW_no_loop_in_rule_options391);\n                    no_loop();\n                    following.pop();\n\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options395);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:56: ( ( ',' )? opt_eol ( salience | no_loop ) )*\n            loop21:\n            do {\n                int alt21=2;\n                alt21 = dfa21.predict(input);\n                switch (alt21) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:58: ( ',' )? opt_eol ( salience | no_loop )\n            \t    {\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:58: ( ',' )?\n            \t    int alt19=2;\n            \t    int LA19_0 = input.LA(1);\n            \t    if ( LA19_0==26 ) {\n            \t        alt19=1;\n            \t    }\n            \t    else if ( LA19_0==EOL||(LA19_0>=27 && LA19_0<=28) ) {\n            \t        alt19=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"109:58: ( \\',\\' )?\", 19, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt19) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:58: ','\n            \t            {\n\n            \t            match(input,26,FOLLOW_26_in_rule_options399);\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    following.push(FOLLOW_opt_eol_in_rule_options402);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:71: ( salience | no_loop )\n            \t    int alt20=2;\n            \t    int LA20_0 = input.LA(1);\n            \t    if ( LA20_0==27 ) {\n            \t        alt20=1;\n            \t    }\n            \t    else if ( LA20_0==28 ) {\n            \t        alt20=2;\n            \t    }\n            \t    else {\n\n            \t        NoViableAltException nvae =\n            \t            new NoViableAltException(\"109:71: ( salience | no_loop )\", 20, 0, input);\n\n            \t        throw nvae;\n            \t    }\n            \t    switch (alt20) {\n            \t        case 1 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:73: salience\n            \t            {\n\n            \t            following.push(FOLLOW_salience_in_rule_options406);\n            \t            salience();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n            \t        case 2 :\n            \t            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:109:84: no_loop\n            \t            {\n\n            \t            following.push(FOLLOW_no_loop_in_rule_options410);\n            \t            no_loop();\n            \t            following.pop();\n\n\n            \t            }\n            \t            break;\n\n            \t    }\n\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop21;\n                }\n            } while (true);\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options417);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51852,"modified_method":"public List rule_options() throws RecognitionException {   \n\n        List options;\n\n        AttributeDescr a = null;\n\n\n\n        \t\toptions = new ArrayList();\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:17: ( 'options' ( ':' )? opt_eol (a= rule_option opt_eol )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:17: 'options' ( ':' )? opt_eol (a= rule_option opt_eol )*\n            {\n\n            match(input,25,FOLLOW_25_in_rule_options398);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:27: ( ':' )?\n            int alt17=2;\n            int LA17_0 = input.LA(1);\n            if ( LA17_0==22 ) {\n                alt17=1;\n            }\n            else if ( LA17_0==EOL||LA17_0==21||LA17_0==23||(LA17_0>=26 && LA17_0<=27) ) {\n                alt17=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"115:27: ( \\':\\' )?\", 17, 0, input);\n\n                throw nvae;\n            }\n            switch (alt17) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:115:27: ':'\n                    {\n\n                    match(input,22,FOLLOW_22_in_rule_options400);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_rule_options403);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:116:25: (a= rule_option opt_eol )*\n            loop18:\n            do {\n                int alt18=2;\n                int LA18_0 = input.LA(1);\n                if ( (LA18_0>=26 && LA18_0<=27) ) {\n                    alt18=1;\n                }\n\n\n                switch (alt18) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:116:33: a= rule_option opt_eol\n            \t    {\n\n            \t    following.push(FOLLOW_rule_option_in_rule_options412);\n            \t    a=rule_option();\n            \t    following.pop();\n\n\n            \t    following.push(FOLLOW_opt_eol_in_rule_options414);\n            \t    opt_eol();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\t\toptions.add( a );\n            \t    \t\t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop18;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return options;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ColumnDescr lhs_column() throws RecognitionException {   \n\n        ColumnDescr d;\n\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:135:17: (f= fact_binding | f= fact )\n            int alt24=2;\n            alt24 = dfa24.predict(input);\n            switch (alt24) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:135:17: f= fact_binding\n                    {\n\n                    following.push(FOLLOW_fact_binding_in_lhs_column511);\n                    f=fact_binding();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:136:17: f= fact\n                    {\n\n                    following.push(FOLLOW_fact_in_lhs_column520);\n                    f=fact();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51853,"modified_method":"public ColumnDescr lhs_column() throws RecognitionException {   \n\n        ColumnDescr d;\n\n        ColumnDescr f = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:170:17: (f= fact_binding | f= fact )\n            int alt22=2;\n            alt22 = dfa22.predict(input);\n            switch (alt22) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:170:17: f= fact_binding\n                    {\n\n                    following.push(FOLLOW_fact_binding_in_lhs_column599);\n                    f=fact_binding();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:171:17: f= fact\n                    {\n\n                    following.push(FOLLOW_fact_in_lhs_column608);\n                    f=fact();\n                    following.pop();\n\n\n                     d = f; \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_exist() throws RecognitionException {   \n\n        PatternDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:298:17: ( 'exists' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:298:17: 'exists' column= lhs_column\n            {\n\n            match(input,41,FOLLOW_41_in_lhs_exist1198);\n\n            following.push(FOLLOW_lhs_column_in_lhs_exist1202);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new ExistsDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51854,"modified_method":"public PatternDescr lhs_exist() throws RecognitionException {   \n\n        PatternDescr d;\n        Token loc=null;\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:345:17: (loc= 'exists' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:345:17: loc= 'exists' column= lhs_column\n            {\n\n            loc=(Token)input.LT(1);\n            match(input,41,FOLLOW_41_in_lhs_exist1306);\n\n            following.push(FOLLOW_lhs_column_in_lhs_exist1310);\n            column=lhs_column();\n            following.pop();\n\n\n             \n            \t\t\td = new ExistsDescr( column ); \n            \t\t\td.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String java_package_or_class() throws RecognitionException {   \n\n        String name;\n        Token id=null;\n\n\n        \t\tname = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:17: (id= ID ( '.' id= ID )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:17: id= ID ( '.' id= ID )*\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_java_package_or_class1283);\n\n             name=id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:46: ( '.' id= ID )*\n            loop33:\n            do {\n                int alt33=2;\n                int LA33_0 = input.LA(1);\n                if ( LA33_0==15 ) {\n                    alt33=1;\n                }\n\n\n                switch (alt33) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:320:48: '.' id= ID\n            \t    {\n\n            \t    match(input,15,FOLLOW_15_in_java_package_or_class1289);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_java_package_or_class1293);\n\n            \t     name = name + \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop33;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return name;\n\n    }","id":51855,"modified_method":"public String java_package_or_class() throws RecognitionException {   \n\n        String name;\n        Token id=null;\n\n\n        \t\tname = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:375:17: (id= ID ( '.' id= ID )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:375:17: id= ID ( '.' id= ID )*\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_java_package_or_class1399);\n\n             name=id.getText(); \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:375:46: ( '.' id= ID )*\n            loop31:\n            do {\n                int alt31=2;\n                int LA31_0 = input.LA(1);\n                if ( LA31_0==15 ) {\n                    alt31=1;\n                }\n\n\n                switch (alt31) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:375:48: '.' id= ID\n            \t    {\n\n            \t    match(input,15,FOLLOW_15_in_java_package_or_class1405);\n\n            \t    id=(Token)input.LT(1);\n            \t    match(input,ID,FOLLOW_ID_in_java_package_or_class1409);\n\n            \t     name = name + \".\" + id.getText(); \n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop31;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return name;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public NotDescr lhs_not() throws RecognitionException {   \n\n        NotDescr d;\n\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:305:17: ( 'not' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:305:17: 'not' column= lhs_column\n            {\n\n            match(input,42,FOLLOW_42_in_lhs_not1227);\n\n            following.push(FOLLOW_lhs_column_in_lhs_not1231);\n            column=lhs_column();\n            following.pop();\n\n\n             d = new NotDescr( column ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51856,"modified_method":"public NotDescr lhs_not() throws RecognitionException {   \n\n        NotDescr d;\n        Token loc=null;\n        ColumnDescr column = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:356:17: (loc= 'not' column= lhs_column )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:356:17: loc= 'not' column= lhs_column\n            {\n\n            loc=(Token)input.LT(1);\n            match(input,42,FOLLOW_42_in_lhs_not1340);\n\n            following.push(FOLLOW_lhs_column_in_lhs_not1344);\n            column=lhs_column();\n            following.pop();\n\n\n\n            \t\t\td = new NotDescr( column ); \n            \t\t\td.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void no_loop() throws RecognitionException {   \n\n\n\n\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:17: ( 'no-loop' ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:17: 'no-loop' ( ';' )? opt_eol\n            {\n\n            match(input,28,FOLLOW_28_in_no_loop453);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:27: ( ';' )?\n            int alt23=2;\n            int LA23_0 = input.LA(1);\n            if ( LA23_0==16 ) {\n                alt23=1;\n            }\n            else if ( LA23_0==EOL||LA23_0==21||LA23_0==23||(LA23_0>=26 && LA23_0<=28) ) {\n                alt23=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"119:27: ( \\';\\' )?\", 23, 0, input);\n\n                throw nvae;\n            }\n            switch (alt23) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:119:27: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_no_loop455);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_no_loop458);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n    }","id":51857,"modified_method":"public AttributeDescr no_loop() throws RecognitionException {   \n\n        AttributeDescr d;\n        Token loc=null;\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:150:17: (loc= 'no-loop' ( ';' )? opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:150:17: loc= 'no-loop' ( ';' )? opt_eol\n            {\n\n            loc=(Token)input.LT(1);\n            match(input,27,FOLLOW_27_in_no_loop537);\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:150:31: ( ';' )?\n            int alt21=2;\n            int LA21_0 = input.LA(1);\n            if ( LA21_0==16 ) {\n                alt21=1;\n            }\n            else if ( LA21_0==EOL||LA21_0==21||LA21_0==23||(LA21_0>=26 && LA21_0<=27) ) {\n                alt21=2;\n            }\n            else {\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"150:31: ( \\';\\' )?\", 21, 0, input);\n\n                throw nvae;\n            }\n            switch (alt21) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:150:31: ';'\n                    {\n\n                    match(input,16,FOLLOW_16_in_no_loop539);\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_no_loop542);\n            opt_eol();\n            following.pop();\n\n\n\n            \t\t\td = new AttributeDescr( \"no-loop\", null );\n            \t\t\td.setLocation( loc.getLine(), loc.getCharPositionInLine() );\n            \t\t\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr l = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:127:17: (l= lhs_or )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:127:17: l= lhs_or\n            {\n\n            following.push(FOLLOW_lhs_or_in_lhs484);\n            l=lhs_or();\n            following.pop();\n\n\n             d = l; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51858,"modified_method":"public PatternDescr lhs() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr l = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:162:17: (l= lhs_or )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:162:17: l= lhs_or\n            {\n\n            following.push(FOLLOW_lhs_or_in_lhs572);\n            l=lhs_or();\n            following.pop();\n\n\n             d = l; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String word() throws RecognitionException {   \n\n        String word;\n        Token id=null;\n        Token str=null;\n\n\n        \t\tword = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:328:17: (id= ID | 'import' | 'use' | 'rule' | 'salience' | 'no-loop' | 'when' | 'then' | 'end' | str= STRING )\n            int alt34=10;\n            switch ( input.LA(1) ) {\n            case ID:\n                alt34=1;\n                break;\n            case 17:\n                alt34=2;\n                break;\n            case 18:\n                alt34=3;\n                break;\n            case 20:\n                alt34=4;\n                break;\n            case 27:\n                alt34=5;\n                break;\n            case 28:\n                alt34=6;\n                break;\n            case 21:\n                alt34=7;\n                break;\n            case 23:\n                alt34=8;\n                break;\n            case 24:\n                alt34=9;\n                break;\n            case STRING:\n                alt34=10;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"324:1: word returns [String word] : (id= ID | \\'import\\' | \\'use\\' | \\'rule\\' | \\'salience\\' | \\'no-loop\\' | \\'when\\' | \\'then\\' | \\'end\\' | str= STRING );\", 34, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt34) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:328:17: id= ID\n                    {\n\n                    id=(Token)input.LT(1);\n                    match(input,ID,FOLLOW_ID_in_word1323);\n\n                     word=id.getText(); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:329:17: 'import'\n                    {\n\n                    match(input,17,FOLLOW_17_in_word1335);\n\n                     word=\"import\"; \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:330:17: 'use'\n                    {\n\n                    match(input,18,FOLLOW_18_in_word1344);\n\n                     word=\"use\"; \n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:331:17: 'rule'\n                    {\n\n                    match(input,20,FOLLOW_20_in_word1356);\n\n                     word=\"rule\"; \n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:332:17: 'salience'\n                    {\n\n                    match(input,27,FOLLOW_27_in_word1367);\n\n                     word=\"salience\"; \n\n                    }\n                    break;\n                case 6 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:333:17: 'no-loop'\n                    {\n\n                    match(input,28,FOLLOW_28_in_word1375);\n\n                     word=\"no-loop\"; \n\n                    }\n                    break;\n                case 7 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:334:17: 'when'\n                    {\n\n                    match(input,21,FOLLOW_21_in_word1383);\n\n                     word=\"when\"; \n\n                    }\n                    break;\n                case 8 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:335:17: 'then'\n                    {\n\n                    match(input,23,FOLLOW_23_in_word1394);\n\n                     word=\"then\"; \n\n                    }\n                    break;\n                case 9 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:336:17: 'end'\n                    {\n\n                    match(input,24,FOLLOW_24_in_word1405);\n\n                     word=\"end\"; \n\n                    }\n                    break;\n                case 10 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:337:17: str= STRING\n                    {\n\n                    str=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_word1419);\n\n                     word=str.getText(); word=word.substring( 1, word.length()-1 ); \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return word;\n\n    }","id":51859,"modified_method":"public String word() throws RecognitionException {   \n\n        String word;\n        Token id=null;\n        Token str=null;\n\n\n        \t\tword = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:383:17: (id= ID | 'import' | 'use' | 'rule' | 'salience' | 'no-loop' | 'when' | 'then' | 'end' | str= STRING )\n            int alt32=10;\n            switch ( input.LA(1) ) {\n            case ID:\n                alt32=1;\n                break;\n            case 17:\n                alt32=2;\n                break;\n            case 18:\n                alt32=3;\n                break;\n            case 20:\n                alt32=4;\n                break;\n            case 26:\n                alt32=5;\n                break;\n            case 27:\n                alt32=6;\n                break;\n            case 21:\n                alt32=7;\n                break;\n            case 23:\n                alt32=8;\n                break;\n            case 24:\n                alt32=9;\n                break;\n            case STRING:\n                alt32=10;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"379:1: word returns [String word] : (id= ID | \\'import\\' | \\'use\\' | \\'rule\\' | \\'salience\\' | \\'no-loop\\' | \\'when\\' | \\'then\\' | \\'end\\' | str= STRING );\", 32, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt32) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:383:17: id= ID\n                    {\n\n                    id=(Token)input.LT(1);\n                    match(input,ID,FOLLOW_ID_in_word1439);\n\n                     word=id.getText(); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:384:17: 'import'\n                    {\n\n                    match(input,17,FOLLOW_17_in_word1451);\n\n                     word=\"import\"; \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:385:17: 'use'\n                    {\n\n                    match(input,18,FOLLOW_18_in_word1460);\n\n                     word=\"use\"; \n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:386:17: 'rule'\n                    {\n\n                    match(input,20,FOLLOW_20_in_word1472);\n\n                     word=\"rule\"; \n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:387:17: 'salience'\n                    {\n\n                    match(input,26,FOLLOW_26_in_word1483);\n\n                     word=\"salience\"; \n\n                    }\n                    break;\n                case 6 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:388:17: 'no-loop'\n                    {\n\n                    match(input,27,FOLLOW_27_in_word1491);\n\n                     word=\"no-loop\"; \n\n                    }\n                    break;\n                case 7 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:389:17: 'when'\n                    {\n\n                    match(input,21,FOLLOW_21_in_word1499);\n\n                     word=\"when\"; \n\n                    }\n                    break;\n                case 8 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:390:17: 'then'\n                    {\n\n                    match(input,23,FOLLOW_23_in_word1510);\n\n                     word=\"then\"; \n\n                    }\n                    break;\n                case 9 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:391:17: 'end'\n                    {\n\n                    match(input,24,FOLLOW_24_in_word1521);\n\n                     word=\"end\"; \n\n                    }\n                    break;\n                case 10 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:392:17: str= STRING\n                    {\n\n                    str=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_word1535);\n\n                     word=str.getText(); word=word.substring( 1, word.length()-1 ); \n\n                    }\n                    break;\n\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return word;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_and() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:266:17: (left= lhs_unary ( ('and'|'&&')right= lhs_unary )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:266:17: left= lhs_unary ( ('and'|'&&')right= lhs_unary )*\n            {\n\n             AndDescr and = null; \n\n            following.push(FOLLOW_lhs_unary_in_lhs_and1076);\n            left=lhs_unary();\n            following.pop();\n\n\n             d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:268:17: ( ('and'|'&&')right= lhs_unary )*\n            loop31:\n            do {\n                int alt31=2;\n                int LA31_0 = input.LA(1);\n                if ( (LA31_0>=39 && LA31_0<=40) ) {\n                    alt31=1;\n                }\n\n\n                switch (alt31) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:268:25: ('and'|'&&')right= lhs_unary\n            \t    {\n\n            \t    if ( (input.LA(1)>=39 && input.LA(1)<=40) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_and1085);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_unary_in_lhs_and1096);\n            \t    right=lhs_unary();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( and == null ) {\n            \t    \t\t\t\t\tand = new AndDescr();\n            \t    \t\t\t\t\tand.addDescr( left );\n            \t    \t\t\t\t\td = and;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tand.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop31;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51860,"modified_method":"public PatternDescr lhs_and() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr left = null;\n\n        PatternDescr right = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:313:17: (left= lhs_unary ( ('and'|'&&')right= lhs_unary )* )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:313:17: left= lhs_unary ( ('and'|'&&')right= lhs_unary )*\n            {\n\n             AndDescr and = null; \n\n            following.push(FOLLOW_lhs_unary_in_lhs_and1182);\n            left=lhs_unary();\n            following.pop();\n\n\n             d = left; \n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:315:17: ( ('and'|'&&')right= lhs_unary )*\n            loop29:\n            do {\n                int alt29=2;\n                int LA29_0 = input.LA(1);\n                if ( (LA29_0>=39 && LA29_0<=40) ) {\n                    alt29=1;\n                }\n\n\n                switch (alt29) {\n            \tcase 1 :\n            \t    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:315:25: ('and'|'&&')right= lhs_unary\n            \t    {\n\n            \t    if ( (input.LA(1)>=39 && input.LA(1)<=40) ) {\n            \t        input.consume();\n            \t        errorRecovery=false;\n            \t    }\n            \t    else {\n            \t        MismatchedSetException mse =\n            \t            new MismatchedSetException(null,input);\n            \t        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_lhs_and1191);    throw mse;\n            \t    }\n\n\n            \t    following.push(FOLLOW_lhs_unary_in_lhs_and1202);\n            \t    right=lhs_unary();\n            \t    following.pop();\n\n\n\n            \t    \t\t\t\tif ( and == null ) {\n            \t    \t\t\t\t\tand = new AndDescr();\n            \t    \t\t\t\t\tand.addDescr( left );\n            \t    \t\t\t\t\td = and;\n            \t    \t\t\t\t}\n            \t    \t\t\t\t\n            \t    \t\t\t\tand.addDescr( right );\n            \t    \t\t\t\n\n            \t    }\n            \t    break;\n\n            \tdefault :\n            \t    break loop29;\n                }\n            } while (true);\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String literal_constraint() throws RecognitionException {   \n\n        String text;\n        Token t=null;\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:200:17: ( (t= STRING | t= INT | t= FLOAT ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:200:17: (t= STRING | t= INT | t= FLOAT )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:200:17: (t= STRING | t= INT | t= FLOAT )\n            int alt28=3;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt28=1;\n                break;\n            case INT:\n                alt28=2;\n                break;\n            case FLOAT:\n                alt28=3;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"200:17: (t= STRING | t= INT | t= FLOAT )\", 28, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt28) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:200:25: t= STRING\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_literal_constraint859);\n\n                     text = t.getText(); text=text.substring( 1, text.length() - 1 ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:201:25: t= INT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,INT,FOLLOW_INT_in_literal_constraint869);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:202:25: t= FLOAT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,FLOAT,FOLLOW_FLOAT_in_literal_constraint882);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n\n            }\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51861,"modified_method":"public String literal_constraint() throws RecognitionException {   \n\n        String text;\n        Token t=null;\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:17: ( (t= STRING | t= INT | t= FLOAT ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:17: (t= STRING | t= INT | t= FLOAT )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:17: (t= STRING | t= INT | t= FLOAT )\n            int alt26=3;\n            switch ( input.LA(1) ) {\n            case STRING:\n                alt26=1;\n                break;\n            case INT:\n                alt26=2;\n                break;\n            case FLOAT:\n                alt26=3;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"247:17: (t= STRING | t= INT | t= FLOAT )\", 26, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt26) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:247:25: t= STRING\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,STRING,FOLLOW_STRING_in_literal_constraint965);\n\n                     text = t.getText(); text=text.substring( 1, text.length() - 1 ); \n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:248:25: t= INT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,INT,FOLLOW_INT_in_literal_constraint975);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:249:25: t= FLOAT\n                    {\n\n                    t=(Token)input.LT(1);\n                    match(input,FLOAT,FOLLOW_FLOAT_in_literal_constraint988);\n\n                     text = t.getText(); \n\n                    }\n                    break;\n\n            }\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_eval() throws RecognitionException {   \n\n        PatternDescr d;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:17: ( 'eval' )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:312:17: 'eval'\n            {\n\n            match(input,43,FOLLOW_43_in_lhs_eval1254);\n\n             d = new EvalDescr( \"\" ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51862,"modified_method":"public PatternDescr lhs_eval() throws RecognitionException {   \n\n        PatternDescr d;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:367:17: ( 'eval' )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:367:17: 'eval'\n            {\n\n            match(input,43,FOLLOW_43_in_lhs_eval1370);\n\n             d = new EvalDescr( \"\" ); \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ColumnDescr fact() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        List c = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:155:17: (id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:155:17: id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact598);\n\n             d = new ColumnDescr( id.getText() ); \n\n            following.push(FOLLOW_opt_eol_in_fact602);\n            opt_eol();\n            following.pop();\n\n\n            match(input,29,FOLLOW_29_in_fact608);\n\n            following.push(FOLLOW_opt_eol_in_fact610);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:156:29: (c= constraints )?\n            int alt25=2;\n            alt25 = dfa25.predict(input);\n            switch (alt25) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:156:33: c= constraints\n                    {\n\n                    following.push(FOLLOW_constraints_in_fact616);\n                    c=constraints();\n                    following.pop();\n\n\n\n                    \t\t \t\t\tfor ( Iterator cIter = c.iterator() ; cIter.hasNext() ; ) {\n                     \t\t\t\t\t\td.addDescr( (PatternDescr) cIter.next() );\n                     \t\t\t\t\t}\n                     \t\t\t\t\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_fact635);\n            opt_eol();\n            following.pop();\n\n\n            match(input,30,FOLLOW_30_in_fact637);\n\n            following.push(FOLLOW_opt_eol_in_fact639);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51863,"modified_method":"public ColumnDescr fact() throws RecognitionException {   \n\n        ColumnDescr d;\n        Token id=null;\n        List c = null;\n\n\n\n        \t\td=null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:17: (id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:190:17: id= ID opt_eol '(' opt_eol (c= constraints )? opt_eol ')' opt_eol\n            {\n\n            id=(Token)input.LT(1);\n            match(input,ID,FOLLOW_ID_in_fact686);\n\n             \n             \t\t\td = new ColumnDescr( id.getText() ); \n             \t\t\td.setLocation( id.getLine(), id.getCharPositionInLine() );\n             \t\t\n\n            following.push(FOLLOW_opt_eol_in_fact694);\n            opt_eol();\n            following.pop();\n\n\n            match(input,28,FOLLOW_28_in_fact700);\n\n            following.push(FOLLOW_opt_eol_in_fact702);\n            opt_eol();\n            following.pop();\n\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:195:29: (c= constraints )?\n            int alt23=2;\n            alt23 = dfa23.predict(input);\n            switch (alt23) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:195:33: c= constraints\n                    {\n\n                    following.push(FOLLOW_constraints_in_fact708);\n                    c=constraints();\n                    following.pop();\n\n\n\n                    \t\t \t\t\tfor ( Iterator cIter = c.iterator() ; cIter.hasNext() ; ) {\n                     \t\t\t\t\t\td.addDescr( (PatternDescr) cIter.next() );\n                     \t\t\t\t\t}\n                     \t\t\t\t\n\n                    }\n                    break;\n\n            }\n\n\n            following.push(FOLLOW_opt_eol_in_fact727);\n            opt_eol();\n            following.pop();\n\n\n            match(input,29,FOLLOW_29_in_fact729);\n\n            following.push(FOLLOW_opt_eol_in_fact731);\n            opt_eol();\n            following.pop();\n\n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String retval_constraint() throws RecognitionException {   \n\n        String text;\n\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:211:17: (c= chunk )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:211:17: c= chunk\n            {\n\n            following.push(FOLLOW_chunk_in_retval_constraint916);\n            c=chunk();\n            following.pop();\n\n\n             text = c; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","id":51864,"modified_method":"public String retval_constraint() throws RecognitionException {   \n\n        String text;\n\n        String c = null;\n\n\n\n        \t\ttext = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:258:17: (c= chunk )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:258:17: c= chunk\n            {\n\n            following.push(FOLLOW_chunk_in_retval_constraint1022);\n            c=chunk();\n            following.pop();\n\n\n             text = c; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return text;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PatternDescr lhs_unary() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr u = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:286:17: ( (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:286:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:286:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            int alt32=5;\n            switch ( input.LA(1) ) {\n            case 41:\n                alt32=1;\n                break;\n            case 42:\n                alt32=2;\n                break;\n            case 43:\n                alt32=3;\n                break;\n            case ID:\n                alt32=4;\n                break;\n            case 29:\n                alt32=5;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"286:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | \\'(\\' u= lhs \\')\\' )\", 32, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt32) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:286:25: u= lhs_exist\n                    {\n\n                    following.push(FOLLOW_lhs_exist_in_lhs_unary1134);\n                    u=lhs_exist();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:287:25: u= lhs_not\n                    {\n\n                    following.push(FOLLOW_lhs_not_in_lhs_unary1142);\n                    u=lhs_not();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:288:25: u= lhs_eval\n                    {\n\n                    following.push(FOLLOW_lhs_eval_in_lhs_unary1150);\n                    u=lhs_eval();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:289:25: u= lhs_column\n                    {\n\n                    following.push(FOLLOW_lhs_column_in_lhs_unary1158);\n                    u=lhs_column();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:290:25: '(' u= lhs ')'\n                    {\n\n                    match(input,29,FOLLOW_29_in_lhs_unary1164);\n\n                    following.push(FOLLOW_lhs_in_lhs_unary1168);\n                    u=lhs();\n                    following.pop();\n\n\n                    match(input,30,FOLLOW_30_in_lhs_unary1170);\n\n                    }\n                    break;\n\n            }\n\n\n             d = u; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","id":51865,"modified_method":"public PatternDescr lhs_unary() throws RecognitionException {   \n\n        PatternDescr d;\n\n        PatternDescr u = null;\n\n\n\n        \t\td = null;\n        \t\n        try {\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:333:17: ( (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' ) )\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:333:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            {\n\n            // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:333:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | '(' u= lhs ')' )\n            int alt30=5;\n            switch ( input.LA(1) ) {\n            case 41:\n                alt30=1;\n                break;\n            case 42:\n                alt30=2;\n                break;\n            case 43:\n                alt30=3;\n                break;\n            case ID:\n                alt30=4;\n                break;\n            case 28:\n                alt30=5;\n                break;\n            default:\n\n                NoViableAltException nvae =\n                    new NoViableAltException(\"333:17: (u= lhs_exist | u= lhs_not | u= lhs_eval | u= lhs_column | \\'(\\' u= lhs \\')\\' )\", 30, 0, input);\n\n                throw nvae;\n            }\n\n            switch (alt30) {\n                case 1 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:333:25: u= lhs_exist\n                    {\n\n                    following.push(FOLLOW_lhs_exist_in_lhs_unary1240);\n                    u=lhs_exist();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 2 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:334:25: u= lhs_not\n                    {\n\n                    following.push(FOLLOW_lhs_not_in_lhs_unary1248);\n                    u=lhs_not();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 3 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:335:25: u= lhs_eval\n                    {\n\n                    following.push(FOLLOW_lhs_eval_in_lhs_unary1256);\n                    u=lhs_eval();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 4 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:336:25: u= lhs_column\n                    {\n\n                    following.push(FOLLOW_lhs_column_in_lhs_unary1264);\n                    u=lhs_column();\n                    following.pop();\n\n\n                    }\n                    break;\n                case 5 :\n                    // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/drl.g:337:25: '(' u= lhs ')'\n                    {\n\n                    match(input,28,FOLLOW_28_in_lhs_unary1270);\n\n                    following.push(FOLLOW_lhs_in_lhs_unary1274);\n                    u=lhs();\n                    following.pop();\n\n\n                    match(input,29,FOLLOW_29_in_lhs_unary1276);\n\n                    }\n                    break;\n\n            }\n\n\n             d = u; \n\n            }\n\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n\n\n        }\n\n        return d;\n\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mT30() throws RecognitionException {\n        int type = T30;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:22:7: ( ')' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:22:7: ')'\n        {\n\n        match(')');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","id":51866,"modified_method":"public void mT30() throws RecognitionException {\n        int type = T30;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:22:7: ( ',' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:22:7: ','\n        {\n\n        match(',');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mT27() throws RecognitionException {\n        int type = T27;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:19:7: ( 'salience' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:19:7: 'salience'\n        {\n\n        match(\"salience\");\n\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","id":51867,"modified_method":"public void mT27() throws RecognitionException {\n        int type = T27;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:19:7: ( 'no-loop' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:19:7: 'no-loop'\n        {\n\n        match(\"no-loop\");\n\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mT28() throws RecognitionException {\n        int type = T28;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:20:7: ( 'no-loop' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:20:7: 'no-loop'\n        {\n\n        match(\"no-loop\");\n\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","id":51868,"modified_method":"public void mT28() throws RecognitionException {\n        int type = T28;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:20:7: ( '(' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:20:7: '('\n        {\n\n        match('(');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mT26() throws RecognitionException {\n        int type = T26;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:18:7: ( ',' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:18:7: ','\n        {\n\n        match(',');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","id":51869,"modified_method":"public void mT26() throws RecognitionException {\n        int type = T26;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:18:7: ( 'salience' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:18:7: 'salience'\n        {\n\n        match(\"salience\");\n\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mT29() throws RecognitionException {\n        int type = T29;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:21:7: ( '(' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:21:7: '('\n        {\n\n        match('(');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","id":51870,"modified_method":"public void mT29() throws RecognitionException {\n        int type = T29;\n        int start = getCharIndex();\n        int line = getLine();\n        int charPosition = getCharPositionInLine();\n        int channel = Token.DEFAULT_CHANNEL;\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:21:7: ( ')' )\n        // /Users/bob/Documents/workspace/jbossrules/drools-compiler/src/main/java/org/drools/lang/RuleParser.lexer.g:21:7: ')'\n        {\n\n        match(')');\n\n        }\n\n        if ( token==null ) {emit(type,line,charPosition,channel,start,getCharIndex()-1);}\n    }","commit_id":"6833d501892b01f75d1e85d86abc31534d6b813e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object unmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\ttry {\n\t\t\tJSONObject jso = (JSONObject) o;\n\t\t\tString java_class = jso.getString(\"javaClass\");\n\t\t\tif (java_class == null) {\n\t\t\t\tthrow new UnmarshallException(\"no type hint\");\n\t\t\t}\n\t\t\tNSMutableArray al = null;\n\t\t\tif (java_class.equals(\"com.webobjects.foundation.NSArray\") || java_class.equals(\"com.webobjects.foundation.NSMutableArray\")) {\n\t\t\t\tal = new NSMutableArray();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new UnmarshallException(\"not a NSArray\");\n\t\t\t}\n\t\t\tJSONArray jsonlist = jso.getJSONArray(\"nsarray\");\n\t\t\tif (jsonlist == null) {\n\t\t\t\tthrow new UnmarshallException(\"nsarray missing\");\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\ttry {\n\t\t\t\tfor (; i < jsonlist.length(); i++) {\n\t\t\t\t\tObject object = jsonlist.get(i);\n\t\t\t\t\tobject = ser.unmarshall(state, null, object);\n\t\t\t\t\tal.addObject(object);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnmarshallException e) {\n\t\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage());\n\t\t\t}\n\t\t\treturn al;\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Failed to unmarshall NSArray.\", e);\n\t\t}\n\n\t}","id":51871,"modified_method":"public Object unmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\tJSONObject jso = (JSONObject) o;\n\t\tString java_class;\n\t\ttry {\n\t\t\tjava_class = jso.getString(\"javaClass\");\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Could not read javaClass\", e);\n\t\t}\n\t\tif (java_class == null) {\n\t\t\tthrow new UnmarshallException(\"no type hint\");\n\t\t}\n\t\tNSMutableArray al;\n\t\tboolean immutableClone = false;\n\t\tif (java_class.equals(\"com.webobjects.foundation.NSArray\")) {\n\t\t\tal = new NSMutableArray(); // we have to be able to add to it\n\t\t\timmutableClone = true;\n\t\t}\n\t\telse if (java_class.equals(\"com.webobjects.foundation.NSMutableArray\")) {\n\t\t\tal = new NSMutableArray();\n\t\t}\n\t\telse {\n\t\t\tthrow new UnmarshallException(\"not an NSArray\");\n\t\t}\n\n\t\tJSONArray jsonNSArray;\n\t\ttry {\n\t\t\tjsonNSArray = jso.getJSONArray(\"nsarray\");\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Could not read nsarray: \" + e.getMessage(), e);\n\t\t}\n\t\tif (jsonNSArray == null) {\n\t\t\tthrow new UnmarshallException(\"nsarray missing\");\n\t\t}\n\t\tstate.setSerialized(o, al);\n\t\tint i = 0;\n\t\ttry {\n\t\t\tfor (; i < jsonNSArray.length(); i++) {\n\t\t\t\tObject obj = ser.unmarshall(state, null, jsonNSArray.get(i));\n\t\t\t\tif (obj != null) {\n\t\t\t\t\tal.addObject(obj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tal.addObject(NSKeyValueCoding.NullValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (UnmarshallException e) {\n\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage(), e);\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage(), e);\n\t\t}\n\t\tif (immutableClone) {\n\t\t\treturn al.immutableClone();\n\t\t}\n\t\telse {\n\t\t\treturn al;\n\t\t}\n\t}","commit_id":"b310f82356c276cc2b4877d5cb816f57e90e697e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean canSerialize(Class clazz, Class jsonClazz) {\n\t\treturn (super.canSerialize(clazz, jsonClazz) || ((jsonClazz == null || jsonClazz == JSONArray.class) && NSArray.class.isAssignableFrom(clazz)));\n\t}","id":51872,"modified_method":"public boolean canSerialize(Class clazz, Class jsonClazz) {\n\t\treturn (super.canSerialize(clazz, jsonClazz) || ((jsonClazz == null || jsonClazz == JSONObject.class) && NSArray.class.isAssignableFrom(clazz)));\n\t}","commit_id":"b310f82356c276cc2b4877d5cb816f57e90e697e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object marshall(SerializerState state, Object p, Object o) throws MarshallException {\n\t\ttry {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tNSArray array = (NSArray) o;\n\t\t\tJSONObject obj = new JSONObject();\n\t\t\tJSONArray arr = new JSONArray();\n\t\t\tobj.put(\"javaClass\", o.getClass().getName());\n\t\t\tobj.put(\"nsarray\", arr);\n\t\t\tstate.push(o, array, \"nsarray\");\n\t\t\tint index = 0;\n\t\t\ttry {\n\t\t\t\tfor (Enumeration e = array.objectEnumerator(); e.hasMoreElements(); index++) {\n\t\t\t\t\tObject json = ser.marshall(state, array, e.nextElement(), new Integer(index));\n\t\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE == json)\n\t\t\t\t\t\tarr.put(JSONObject.NULL);\n\t\t\t\t\telse\n\t\t\t\t\t\tarr.put(json);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (MarshallException e) {\n\t\t\t\tthrow new MarshallException(\"element \" + index + \" \" + e.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstate.pop();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall NSArray.\", e);\n\t\t}\n\t}","id":51873,"modified_method":"public Object marshall(SerializerState state, Object p, Object o) throws MarshallException {\n\t\tNSArray nsarray = (NSArray) o;\n\t\tJSONObject obj = new JSONObject();\n\t\tJSONArray arr = new JSONArray();\n\n\t\t// TODO: this same block is done everywhere.\n\t\t// Have a single function to do it.\n\t\tif (ser.getMarshallClassHints()) {\n\t\t\ttry {\n\t\t\t\tobj.put(\"javaClass\", o.getClass().getName());\n\t\t\t}\n\t\t\tcatch (JSONException e) {\n\t\t\t\tthrow new MarshallException(\"javaClass not found!\");\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tobj.put(\"nsarray\", arr);\n\t\t\tstate.push(o, arr, \"nsarray\");\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Error setting nsarray: \" + e);\n\t\t}\n\t\tint index = 0;\n\t\ttry {\n\t\t\tEnumeration e = nsarray.objectEnumerator();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tObject json = ser.marshall(state, arr, e.nextElement(), new Integer(index));\n\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE != json) {\n\t\t\t\t\tarr.put(json);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// put a slot where the object would go, so it can be fixed up properly in the fix up phase\n\t\t\t\t\tarr.put(JSONObject.NULL);\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tcatch (MarshallException e) {\n\t\t\tthrow (MarshallException) new MarshallException(\"element \" + index).initCause(e);\n\t\t}\n\t\tfinally {\n\t\t\tstate.pop();\n\t\t}\n\t\treturn obj;\n\t}","commit_id":"b310f82356c276cc2b4877d5cb816f57e90e697e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * @see com.metaparadigm.jsonrpc.Serializer#doTryToUnmarshall(java.lang.Class, java.lang.Object)\n\t */\n\tpublic ObjectMatch tryUnmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\ttry {\n\t\t\tJSONObject jso = (JSONObject) o;\n\t\t\tString java_class = jso.getString(\"javaClass\");\n\t\t\tif (java_class == null) {\n\t\t\t\tthrow new UnmarshallException(\"no type hint\");\n\t\t\t}\n\t\t\tif (!(java_class.equals(\"com.webobjects.foundation.NSArray\") || java_class.equals(\"com.webobjects.foundation.NSMutableArray\"))) {\n\t\t\t\tthrow new UnmarshallException(\"not a NSArray\");\n\t\t\t}\n\n\t\t\tJSONArray jsonlist = jso.getJSONArray(\"nsarray\");\n\t\t\tif (jsonlist == null) {\n\t\t\t\tthrow new UnmarshallException(\"nsarray missing\");\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tObjectMatch m = new ObjectMatch(-1);\n\t\t\ttry {\n\t\t\t\tfor (; i < jsonlist.length(); i++) {\n\t\t\t\t\tm = ser.tryUnmarshall(state, null, jsonlist.get(i)).max(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnmarshallException e) {\n\t\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage());\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Failed to unmarshall NSArray.\", e);\n\t\t}\n\t}","id":51874,"modified_method":"public ObjectMatch tryUnmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\tJSONObject jso = (JSONObject) o;\n\t\tString java_class;\n\t\ttry {\n\t\t\tjava_class = jso.getString(\"javaClass\");\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Could not read javaClass\", e);\n\t\t}\n\t\tif (java_class == null) {\n\t\t\tthrow new UnmarshallException(\"no type hint\");\n\t\t}\n\t\tif (!(java_class.equals(\"com.webobjects.foundation.NSArray\") || java_class.equals(\"com.webobjects.foundation.NSMutableArray\"))) {\n\t\t\tthrow new UnmarshallException(\"not an NSArray\");\n\t\t}\n\t\tJSONArray jsonNSArray;\n\t\ttry {\n\t\t\tjsonNSArray = jso.getJSONArray(\"nsarray\");\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Could not read nsarray: \" + e.getMessage(), e);\n\t\t}\n\t\tif (jsonNSArray == null) {\n\t\t\tthrow new UnmarshallException(\"nsarray missing\");\n\t\t}\n\t\tint i = 0;\n\t\tObjectMatch m = new ObjectMatch(-1);\n\t\tstate.setSerialized(o, m);\n\t\ttry {\n\t\t\tfor (; i < jsonNSArray.length(); i++) {\n\t\t\t\tm.setMismatch(ser.tryUnmarshall(state, null, jsonNSArray.get(i)).max(m).getMismatch());\n\t\t\t}\n\t\t}\n\t\tcatch (UnmarshallException e) {\n\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage(), e);\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"element \" + i + \" \" + e.getMessage(), e);\n\t\t}\n\t\treturn m;\n\t}","commit_id":"b310f82356c276cc2b4877d5cb816f57e90e697e","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void initClass(Class<?> clazz) {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Loading \" + clazz.getName() + \" and \" +\n\t\t\t\t\tclazz.getDeclaredClasses().length + \" inner classes\");\n\t\t}\n\t}","id":51875,"modified_method":"protected void initClass(Class<?> clazz) {\n\n\t\t// Do not remove this declaration, we need all the inner classes to be\n\t\t// loaded by the current classloader\n\n\t\tClass<?>[] declaredClasses = clazz.getDeclaredClasses();\n\n\t\tint declaredClassesLength = declaredClasses.length;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Loading \" + clazz.getName() + \" and \" + declaredClassesLength +\n\t\t\t\t\t\" inner classes\");\n\t\t}\n\t}","commit_id":"d1955c208271e2d48f24c923f43a5f87e7db21af","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLoadTypesAndresolveAllParameterNames() throws Exception {\n\t\tfor (String name : getClassNamesToLoad()) {\n\t\t\tJvmDeclaredType type = loadAndResolve(name, true, true, true, true, true);\n\t\t\tTreeIterator<Object> iterator = EcoreUtil.getAllContents(type.eResource().getResourceSet(), true);\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject next = iterator.next();\n\t\t\t\tif (next instanceof JvmFormalParameter) {\n\t\t\t\t\t((JvmFormalParameter) next).getName();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":51876,"modified_method":"@Test\n\tpublic void testLoadTypesAndResolveAllParameterNames() throws Exception {\n\t\tfor (String name : getClassNamesToLoad()) {\n\t\t\tJvmDeclaredType type = loadAndResolve(name, true, true, true, true, true);\n\t\t\tTreeIterator<Object> iterator = EcoreUtil.getAllContents(type.eResource().getResourceSet(), true);\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject next = iterator.next();\n\t\t\t\tif (next instanceof JvmFormalParameter) {\n\t\t\t\t\t((JvmFormalParameter) next).getName();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmTypeReference createTypeArgument(Type actualTypeArgument, Type rawType, int i) {\n\t\tif (actualTypeArgument instanceof WildcardType) {\n\t\t\tWildcardType wildcardType = (WildcardType) actualTypeArgument;\n\t\t\tJvmWildcardTypeReference result = TypesFactory.eINSTANCE.createJvmWildcardTypeReference();\n\t\t\tif (wildcardType.getUpperBounds().length != 0) {\n\t\t\t\tJvmUpperBound upperBound = TypesFactory.eINSTANCE.createJvmUpperBound();\n\t\t\t\tfor (Type boundType : wildcardType.getUpperBounds()) {\n\t\t\t\t\tJvmTypeReference upperBoundType = createTypeReference(boundType);\n\t\t\t\t\tupperBound.setTypeReference(upperBoundType);\n\t\t\t\t}\n\t\t\t\tresult.getConstraints().add(upperBound);\n\t\t\t}\n\t\t\tif (wildcardType.getLowerBounds().length != 0) {\n\t\t\t\tJvmLowerBound lowerBound = TypesFactory.eINSTANCE.createJvmLowerBound();\n\t\t\t\tfor (Type boundType : wildcardType.getLowerBounds()) {\n\t\t\t\t\tJvmTypeReference lowerBoundType = createTypeReference(boundType);\n\t\t\t\t\tlowerBound.setTypeReference(lowerBoundType);\n\t\t\t\t}\n\t\t\t\tresult.getConstraints().add(lowerBound);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\tJvmTypeReference result = createTypeReference(actualTypeArgument);\n\t\t\treturn result;\n\t\t}\n\t}","id":51877,"modified_method":"protected JvmTypeReference createTypeArgument(Type actualTypeArgument) {\n\t\tif (actualTypeArgument instanceof WildcardType) {\n\t\t\tWildcardType wildcardType = (WildcardType) actualTypeArgument;\n\t\t\tJvmWildcardTypeReference result = TypesFactory.eINSTANCE.createJvmWildcardTypeReference();\n\t\t\tInternalEList<JvmTypeConstraint> constraints = (InternalEList<JvmTypeConstraint>)result.getConstraints();\n\t\t\tType[] upperBounds = wildcardType.getUpperBounds();\n\t\t\tif (upperBounds.length != 0) {\n\t\t\t\tfor (Type boundType : upperBounds) {\n\t\t\t\t\tJvmUpperBound upperBound = TypesFactory.eINSTANCE.createJvmUpperBound();\n\t\t\t\t\tJvmTypeReference upperBoundType = createTypeReference(boundType);\n\t\t\t\t\t((JvmTypeConstraintImplCustom) upperBound).internalSetTypeReference(upperBoundType);\n\t\t\t\t\tconstraints.addUnique(upperBound);\n\t\t\t\t}\n\t\t\t}\n\t\t\tType[] lowerBounds = wildcardType.getLowerBounds();\n\t\t\tif (lowerBounds.length != 0) {\n\t\t\t\tfor (Type boundType : lowerBounds) {\n\t\t\t\t\tJvmLowerBound lowerBound = TypesFactory.eINSTANCE.createJvmLowerBound();\n\t\t\t\t\tJvmTypeReference lowerBoundType = createTypeReference(boundType);\n\t\t\t\t\t((JvmTypeConstraintImplCustom) lowerBound).internalSetTypeReference(lowerBoundType);\n\t\t\t\t\tconstraints.addUnique(lowerBound);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\tJvmTypeReference result = createTypeReference(actualTypeArgument);\n\t\t\treturn result;\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createNestedTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\tfor (Class<?> declaredClass : clazz.getDeclaredClasses()) {\n\t\t\tif (!declaredClass.isAnonymousClass() && !declaredClass.isSynthetic()) {\n\t\t\t\tresult.getMembers().add(createType(declaredClass));\n\t\t\t}\n\t\t}\n\t}","id":51878,"modified_method":"protected void createNestedTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\tClass<?>[] declaredClasses = clazz.getDeclaredClasses();\n\t\tif (declaredClasses.length != 0) {\n\t\t\tInternalEList<JvmMember> members = (InternalEList<JvmMember>)result.getMembers();\n\t\t\tfor (Class<?> declaredClass : declaredClasses) {\n\t\t\t\tif (!declaredClass.isAnonymousClass() && !declaredClass.isSynthetic()) {\n\t\t\t\t\tmembers.addUnique(createType(declaredClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createAnnotationValues(final AnnotatedElement annotated, final JvmAnnotationTarget result) {\n\t\tfor (Annotation annotation : annotated.getDeclaredAnnotations()) {\n\t\t\tresult.getAnnotations().add(createAnnotationReference(annotation));\n\t\t}\n\t}","id":51879,"modified_method":"protected void createAnnotationValues(final AnnotatedElement annotated, final JvmAnnotationTarget result) {\n\t\tAnnotation[] declaredAnnotations = annotated.getDeclaredAnnotations();\n\t\tif (declaredAnnotations.length != 0) {\n\t\t\tInternalEList<JvmAnnotationReference> annotations = (InternalEList<JvmAnnotationReference>)result.getAnnotations();\n\t\t\tfor (Annotation annotation : declaredAnnotations) {\n\t\t\t\tannotations.addUnique(createAnnotationReference(annotation));\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setVisibility(Class<?> clazz, org.eclipse.xtext.common.types.JvmMember result) {\n\t\tif (Modifier.isPrivate(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PRIVATE);\n\t\telse if (Modifier.isProtected(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PROTECTED);\n\t\telse if (Modifier.isPublic(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t}","id":51880,"modified_method":"protected void setVisibility(Class<?> clazz, JvmMember result) {\n\t\tif (Modifier.isPrivate(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PRIVATE);\n\t\telse if (Modifier.isProtected(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PROTECTED);\n\t\telse if (Modifier.isPublic(clazz.getModifiers()))\n\t\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmAnnotationReference createAnnotationReference(Annotation annotation) {\n\t\tJvmAnnotationReference annotationReference = TypesFactory.eINSTANCE.createJvmAnnotationReference();\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tannotationReference.setAnnotation(createAnnotationProxy(type));\n\t\tfor (Method method : type.getDeclaredMethods()) {\n\t\t\ttry {\n\t\t\t\tObject value = method.invoke(annotation, EMPTY_ARRAY);\n\t\t\t\tif (method.getReturnType().isArray()) {\n\t\t\t\t\tJvmAnnotationValue annotationValue = createArrayAnnotationValue(value, method.getReturnType());\n\t\t\t\t\tannotationReference.getValues().add(annotationValue);\n\t\t\t\t\tannotationValue.setOperation(createMethodProxy(method));\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationValue annotationValue = createAnnotationValue(value, method.getReturnType());\n\t\t\t\t\tannotationReference.getValues().add(annotationValue);\n\t\t\t\t\tannotationValue.setOperation(createMethodProxy(method));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn annotationReference;\n\t}","id":51881,"modified_method":"protected JvmAnnotationReference createAnnotationReference(Annotation annotation) {\n\t\tJvmAnnotationReference annotationReference = TypesFactory.eINSTANCE.createJvmAnnotationReference();\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tannotationReference.setAnnotation(createAnnotationProxy(type));\n\t\tMethod[] declaredMethods = type.getDeclaredMethods();\n\t\tif (declaredMethods.length > 0) {\n\t\t\tInternalEList<JvmAnnotationValue> values = (InternalEList<JvmAnnotationValue>)annotationReference.getValues();\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = method.invoke(annotation, EMPTY_ARRAY);\n\t\t\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\t\t\tif (returnType.isArray()) {\n\t\t\t\t\t\tJvmAnnotationValue annotationValue = createArrayAnnotationValue(value, returnType);\n\t\t\t\t\t\tvalues.addUnique(annotationValue);\n\t\t\t\t\t\tannotationValue.setOperation(createMethodProxy(method));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJvmAnnotationValue annotationValue = createAnnotationValue(value, returnType);\n\t\t\t\t\t\tvalues.addUnique(annotationValue);\n\t\t\t\t\t\tannotationValue.setOperation(createMethodProxy(method));\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn annotationReference;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void enhanceGenericDeclaration(JvmExecutable result, GenericDeclaration declaration) {\n\t\tfor (TypeVariable<?> variable : declaration.getTypeParameters()) {\n\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t}\n\t}","id":51882,"modified_method":"protected void enhanceGenericDeclaration(JvmExecutable result, GenericDeclaration declaration) {\n\t\tTypeVariable<?>[] typeParameters = declaration.getTypeParameters();\n\t\tif (typeParameters.length != 0) {\n\t\t\tInternalEList<JvmTypeParameter> jvmTypeParameters = (InternalEList<JvmTypeParameter>)result.getTypeParameters();\n\t\t\tfor (TypeVariable<?> variable : typeParameters) {\n\t\t\t\tjvmTypeParameters.addUnique(createTypeParameter(variable, result));\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmTypeReference createArrayTypeReference(Type componentType) {\n\t\tJvmTypeReference componentTypeReference = createTypeReference(componentType);\n\t\tif (componentTypeReference != null) {\n\t\t\tJvmGenericArrayTypeReference result = TypesFactory.eINSTANCE.createJvmGenericArrayTypeReference();\n\t\t\tresult.setComponentType(componentTypeReference);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":51883,"modified_method":"protected JvmTypeReference createArrayTypeReference(Type componentType) {\n\t\tJvmTypeReference componentTypeReference = createTypeReference(componentType);\n\t\tJvmGenericArrayTypeReference result = TypesFactory.eINSTANCE.createJvmGenericArrayTypeReference();\n\t\tresult.setComponentType(componentTypeReference);\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmAnnotationType createAnnotationProxy(Class<? extends Annotation> type) {\n\t\tInternalEObject proxy = (InternalEObject) TypesFactory.eINSTANCE.createJvmAnnotationType();\n\t\tURI uri = uriHelper.getFullURI(type);\n\t\tproxy.eSetProxyURI(uri);\n\t\treturn (JvmAnnotationType) proxy;\n\t}","id":51884,"modified_method":"protected JvmAnnotationType createAnnotationProxy(Class<? extends Annotation> type) {\n\t\tJvmAnnotationType proxy = annotationProxies.get(type);\n\t\tif (proxy == null)  {\n\t\t\tproxy = TypesFactory.eINSTANCE.createJvmAnnotationType();\n\t\t\tURI uri = uriHelper.getFullURI(type);\n\t\t\t((InternalEObject)proxy).eSetProxyURI(uri);\n\t\t\tannotationProxies.put(type, proxy);\n\t\t}\n\t\treturn proxy;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * \n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tresult.setStrictFloatingPoint(Modifier.isStrict(clazz.getModifiers()));\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tfor (TypeVariable<?> variable : clazz.getTypeParameters()) {\n\t\t\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t\t\t}\n\t\t\t} catch (GenericSignatureFormatError error) {\n\t\t\t\tlogSignatureFormatError(clazz);\n\t\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\t\tlogSignatureFormatError(clazz);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","id":51885,"modified_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * \n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tresult.setStrictFloatingPoint(Modifier.isStrict(clazz.getModifiers()));\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tTypeVariable<?>[] typeParameters = clazz.getTypeParameters();\n\t\t\t\tif (typeParameters.length != 0) {\n\t\t\t\t\tInternalEList<JvmTypeParameter> jvmTypeParameters = (InternalEList<JvmTypeParameter>)result.getTypeParameters();\n\t\t\t\t\tfor (TypeVariable<?> variable : typeParameters) {\n\t\t\t\t\t\tjvmTypeParameters.addUnique(createTypeParameter(variable, result));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (GenericSignatureFormatError error) {\n\t\t\t\tlogSignatureFormatError(clazz);\n\t\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\t\tlogSignatureFormatError(clazz);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmAnnotationValue createAnnotationValue(Class<?> type) {\n\t\tif (String.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmStringAnnotationValue();\n\t\t} else if (Class.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmTypeAnnotationValue();\n\t\t} else if (type.isAnnotation()) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmAnnotationAnnotationValue();\n\t\t} else if (type.isEnum()) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmEnumAnnotationValue();\n\t\t} else if (int.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmIntAnnotationValue();\n\t\t} else if (boolean.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue();\n\t\t} else if (long.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmLongAnnotationValue();\n\t\t} else if (byte.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmByteAnnotationValue();\n\t\t} else if (short.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmShortAnnotationValue();\n\t\t} else if (float.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmFloatAnnotationValue();\n\t\t} else if (double.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue();\n\t\t} else if (char.class.equals(type)) {\n\t\t\treturn TypesFactory.eINSTANCE.createJvmCharAnnotationValue();\n\t\t} else\n\t\t\tthrow new IllegalArgumentException(\"Unexpected type: \" + type.getCanonicalName());\n\t}","id":51886,"modified_method":"protected EStructuralFeature.Setting createAnnotationValue(Class<?> type) {\n\t\tif (String.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmStringAnnotationValue().getValues();\n\t\t} else if (Class.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmTypeAnnotationValue().getValues();\n\t\t} else if (boolean.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue().getValues();\n\t\t} else if (int.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmIntAnnotationValue().getValues();\n\t\t} else if (type.isAnnotation()) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmAnnotationAnnotationValue().getValues();\n\t\t} else if (type.isEnum()) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmEnumAnnotationValue().getValues();\n\t\t} else if (long.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmLongAnnotationValue().getValues();\n\t\t} else if (short.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmShortAnnotationValue().getValues();\n\t\t} else if (float.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmFloatAnnotationValue().getValues();\n\t\t} else if (double.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue().getValues();\n\t\t} else if (char.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmCharAnnotationValue().getValues();\n\t\t} else if (byte.class == type) {\n\t\t\treturn (EStructuralFeature.Setting)TypesFactory.eINSTANCE.createJvmByteAnnotationValue().getValues();\n\t\t} else\n\t\t\tthrow new IllegalArgumentException(\"Unexpected type: \" + type.getCanonicalName());\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected <T> org.eclipse.xtext.common.types.JvmConstructor createConstructor(Constructor<T> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<T> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, constructor.getDeclaringClass().getSimpleName(), genericParameterTypes,\n\t\t\t\tconstructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = constructor.getGenericExceptionTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","id":51887,"modified_method":"protected JvmConstructor createConstructor(Constructor<?> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<?> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(declaringClass);\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(declaringClass);\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, declaringClass.getSimpleName(), genericParameterTypes,\n\t\t\t\tconstructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = constructor.getGenericExceptionTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(declaringClass);\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(declaringClass);\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t}\n\t\tif (exceptionTypes.length != 0) {\n\t\t\tInternalEList<JvmTypeReference> exceptions = (InternalEList<JvmTypeReference>)result.getExceptions();\n\t\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\t\texceptions.addUnique(createTypeReference(exceptionType));\n\t\t\t}\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createConstructors(Class<?> clazz, JvmDeclaredType result) {\n\t\tfor (Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n\t\t\tif (!constructor.isSynthetic())\n\t\t\t\tresult.getMembers().add(createConstructor(constructor));\n\t\t}\n\t}","id":51888,"modified_method":"protected void createConstructors(Class<?> clazz, JvmDeclaredType result) {\n\t\tConstructor<?>[] declaredConstructors = clazz.getDeclaredConstructors();\n\t\tif (declaredConstructors.length != 0) {\n\t\t\tInternalEList<JvmMember> members = (InternalEList<JvmMember>)result.getMembers();\n\t\t\tfor (Constructor<?> constructor : declaredConstructors) {\n\t\t\t\tif (!constructor.isSynthetic()) {\n\t\t\t\t\tmembers.addUnique(createConstructor(constructor));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createFields(Class<?> clazz, JvmDeclaredType result) {\n\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\tif (!field.isSynthetic())\n\t\t\t\tresult.getMembers().add(createField(field));\n\t\t}\n\t}","id":51889,"modified_method":"protected void createFields(Class<?> clazz, JvmDeclaredType result) {\n\t\tField[] declaredFields = clazz.getDeclaredFields();\n\t\tif (declaredFields.length != 0) {\n\t\t\tInternalEList<JvmMember> members = (InternalEList<JvmMember>)result.getMembers();\n\t\t\tfor (Field field : declaredFields) {\n\t\t\t\tif (!field.isSynthetic()) {\n\t\t\t\t\tmembers.addUnique(createField(field));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmOperation createMethodProxy(Method method) {\n\t\tInternalEObject proxy = (InternalEObject) TypesFactory.eINSTANCE.createJvmOperation();\n\t\tURI uri = uriHelper.getFullURI(method);\n\t\tproxy.eSetProxyURI(uri);\n\t\treturn (JvmOperation) proxy;\n\t}","id":51890,"modified_method":"protected JvmOperation createMethodProxy(Method method) {\n\t\tJvmOperation proxy = operationProxies.get(method);\n\t\tif (proxy == null) {\n\t\t\tproxy = TypesFactory.eINSTANCE.createJvmOperation();\n\t\t\tURI uri = uriHelper.getFullURI(method);\n\t\t\t((InternalEObject)proxy).eSetProxyURI(uri);\n\t\t\toperationProxies.put(method, proxy);\n\t\t}\n\t\treturn  proxy;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmTypeReference createTypeReference(Type type) {\n\t\tif (type instanceof GenericArrayType) {\n\t\t\tGenericArrayType arrayType = (GenericArrayType) type;\n\t\t\tType componentType = arrayType.getGenericComponentType();\n\t\t\treturn createArrayTypeReference(componentType);\n\t\t} else if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\t\tJvmParameterizedTypeReference result = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();\n\t\t\tresult.setType(createProxy(parameterizedType.getRawType()));\n\t\t\tfor (int i = 0; i < parameterizedType.getActualTypeArguments().length; i++) {\n\t\t\t\tJvmTypeReference argument = createTypeArgument(parameterizedType.getActualTypeArguments()[i],\n\t\t\t\t\t\tparameterizedType.getRawType(), i);\n\t\t\t\tresult.getArguments().add(argument);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (type instanceof Class<?> && ((Class<?>) type).isArray()) {\n\t\t\tClass<?> arrayType = (Class<?>) type;\n\t\t\tType componentType = arrayType.getComponentType();\n\t\t\treturn createArrayTypeReference(componentType);\n\t\t} else {\n\t\t\tJvmParameterizedTypeReference result = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();\n\t\t\tresult.setType(createProxy(type));\n\t\t\treturn result;\n\t\t}\n\t}","id":51891,"modified_method":"protected JvmTypeReference createTypeReference(Type type) {\n\t\tif (type instanceof GenericArrayType) {\n\t\t\tGenericArrayType arrayType = (GenericArrayType) type;\n\t\t\tType componentType = arrayType.getGenericComponentType();\n\t\t\treturn createArrayTypeReference(componentType);\n\t\t} else if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\t\tJvmParameterizedTypeReference result = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();\n\t\t\tresult.setType(createProxy(parameterizedType.getRawType()));\n\t\t\tType[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\t\t\tif (actualTypeArguments.length != 0) {\n\t\t\t\tInternalEList<JvmTypeReference> arguments = (InternalEList<JvmTypeReference>)result.getArguments();\n\t\t\t\tfor (Type actualTypeArgument : actualTypeArguments) {\n\t\t\t\t\tJvmTypeReference argument = createTypeArgument(actualTypeArgument);\n\t\t\t\t\targuments.addUnique(argument);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (type instanceof Class<?> && ((Class<?>) type).isArray()) {\n\t\t\tClass<?> arrayType = (Class<?>) type;\n\t\t\tType componentType = arrayType.getComponentType();\n\t\t\treturn createArrayTypeReference(componentType);\n\t\t} else {\n\t\t\tJvmParameterizedTypeReference result = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();\n\t\t\tresult.setType(createProxy(type));\n\t\t\treturn result;\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmAnnotationValue createAnnotationValue(Object value, Class<?> type) {\n\t\tJvmAnnotationValue result = createAnnotationValue(type);\n\t\tif (type.isPrimitive() || String.class.equals(type)) {\n\t\t\tresult.eSet(result.eClass().getEStructuralFeature(\"values\"), Collections.singleton(value));\n\t\t} else if (type.equals(Class.class)) {\n\t\t\tClass<?> referencedClass = (Class<?>) value;\n\t\t\tJvmTypeReference reference = createTypeReference(referencedClass);\n\t\t\tresult.eSet(result.eClass().getEStructuralFeature(\"values\"), Collections.singleton(reference));\n\t\t} else if (type.isAnnotation()) {\n\t\t\tAnnotation nestedAnnotation = (Annotation) value;\n\t\t\t((JvmAnnotationAnnotationValue) result).getValues().add(createAnnotationReference(nestedAnnotation));\n\t\t} else if (type.isEnum()) {\n\t\t\tEnum<?> e = (Enum<?>) value;\n\t\t\tJvmEnumerationLiteral proxy = createEnumLiteralProxy(e);\n\t\t\tresult.eSet(result.eClass().getEStructuralFeature(\"values\"), Collections.singleton(proxy));\n\t\t}\n\t\treturn result;\n\t}","id":51892,"modified_method":"protected JvmAnnotationValue createAnnotationValue(Object value, Class<?> type) {\n\t\tEStructuralFeature.Setting result = createAnnotationValue(type);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tInternalEList<Object> values = (InternalEList<Object>)result;\n\t\tif (type.isPrimitive() || String.class == type) {\n\t\t\tvalues.addUnique(value);\n\t\t} else if (type == Class.class) {\n\t\t\tClass<?> referencedClass = (Class<?>) value;\n\t\t\tJvmTypeReference reference = createTypeReference(referencedClass);\n\t\t\tvalues.addUnique(reference);\n\t\t} else if (type.isAnnotation()) {\n\t\t\tAnnotation nestedAnnotation = (Annotation) value;\n\t\t\tvalues.addUnique(createAnnotationReference(nestedAnnotation));\n\t\t} else if (type.isEnum()) {\n\t\t\tEnum<?> e = (Enum<?>) value;\n\t\t\tJvmEnumerationLiteral proxy = createEnumLiteralProxy(e);\n\t\t\tvalues.addUnique(proxy);\n\t\t}\n\t\treturn (JvmAnnotationValue)result.getEObject();\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + field.getName());\n\t\tresult.setSimpleName(field.getName());\n\t\tresult.setFinal(Modifier.isFinal(field.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(field.getModifiers()));\n\t\tresult.setTransient(Modifier.isTransient(field.getModifiers()));\n\t\tresult.setVolatile(Modifier.isVolatile(field.getModifiers()));\n\t\tsetVisibility(result, field.getModifiers());\n\t\tType fieldType = null;\n\t\ttry {\n\t\t\tfieldType = field.getGenericType();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(field.getDeclaringClass());\n\t\t\tfieldType = field.getType();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(field.getDeclaringClass());\n\t\t\tfieldType = field.getType();\n\t\t}\n\t\tresult.setType(createTypeReference(fieldType));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","id":51893,"modified_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tString fieldName = field.getName();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + fieldName);\n\t\tresult.setSimpleName(fieldName);\n\t\tint modifiers = field.getModifiers();\n\t\tresult.setFinal(Modifier.isFinal(modifiers));\n\t\tresult.setStatic(Modifier.isStatic(modifiers));\n\t\tresult.setTransient(Modifier.isTransient(modifiers));\n\t\tresult.setVolatile(Modifier.isVolatile(modifiers));\n\t\tsetVisibility(result, modifiers);\n\t\tType fieldType = null;\n\t\ttry {\n\t\t\tfieldType = field.getGenericType();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(field.getDeclaringClass());\n\t\t\tfieldType = field.getType();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(field.getDeclaringClass());\n\t\t\tfieldType = field.getType();\n\t\t}\n\t\tresult.setType(createTypeReference(fieldType));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmFormalParameter createFormalParameter(Type parameterType, String paramName,\n\t\t\torg.eclipse.xtext.common.types.JvmMember container, GenericDeclaration member, Annotation[] annotations) {\n\t\tJvmFormalParameter result = TypesFactory.eINSTANCE.createJvmFormalParameter();\n\t\tresult.setName(paramName);\n\t\tif (isLocal(parameterType, member)) {\n\t\t\tresult.setParameterType(createLocalTypeReference(parameterType, (JvmTypeParameterDeclarator) container,\n\t\t\t\t\tmember));\n\t\t} else {\n\t\t\tresult.setParameterType(createTypeReference(parameterType));\n\t\t}\n\t\tfor (Annotation annotation : annotations) {\n\t\t\tresult.getAnnotations().add(createAnnotationReference(annotation));\n\t\t}\n\t\treturn result;\n\t}","id":51894,"modified_method":"protected JvmFormalParameter createFormalParameter(Type parameterType, String paramName,\n\t\t\tJvmMember container, GenericDeclaration member, Annotation[] annotations) {\n\t\tJvmFormalParameter result = TypesFactory.eINSTANCE.createJvmFormalParameter();\n\t\tresult.setName(paramName);\n\t\tif (isLocal(parameterType, member)) {\n\t\t\tresult.setParameterType(createLocalTypeReference(parameterType, (JvmTypeParameterDeclarator) container,\n\t\t\t\t\tmember));\n\t\t} else {\n\t\t\tresult.setParameterType(createTypeReference(parameterType));\n\t\t}\n\t\tif (annotations.length != 0) {\n\t\t\tInternalEList<JvmAnnotationReference> annotationsReferences = (InternalEList<JvmAnnotationReference>)result.getAnnotations();\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tannotationsReferences.addUnique(createAnnotationReference(annotation));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmTypeReference createLocalArrayTypeReference(Type componentType, JvmTypeParameterDeclarator container,\n\t\t\tGenericDeclaration member) {\n\t\tJvmTypeReference componentTypeReference = createLocalTypeReference(componentType, container, member);\n\t\tif (componentTypeReference != null) {\n\t\t\tJvmGenericArrayTypeReference result = TypesFactory.eINSTANCE.createJvmGenericArrayTypeReference();\n\t\t\tresult.setComponentType(componentTypeReference);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":51895,"modified_method":"protected JvmTypeReference createLocalArrayTypeReference(Type componentType, JvmTypeParameterDeclarator container,\n\t\t\tGenericDeclaration member) {\n\t\tJvmTypeReference componentTypeReference = createLocalTypeReference(componentType, container, member);\n\t\tJvmGenericArrayTypeReference result = TypesFactory.eINSTANCE.createJvmGenericArrayTypeReference();\n\t\tresult.setComponentType(componentTypeReference);\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmTypeParameter createTypeParameter(TypeVariable<?> variable,\n\t\t\torg.eclipse.xtext.common.types.JvmMember container) {\n\t\tJvmTypeParameter result = TypesFactory.eINSTANCE.createJvmTypeParameter();\n\t\tresult.setName(variable.getName());\n\t\tif (variable.getBounds().length != 0) {\n\t\t\tfor (Type bound : variable.getBounds()) {\n\t\t\t\tJvmUpperBound upperBound = TypesFactory.eINSTANCE.createJvmUpperBound();\n\t\t\t\tupperBound.setTypeReference(createTypeReference(bound));\n\t\t\t\tresult.getConstraints().add(upperBound);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":51896,"modified_method":"protected JvmTypeParameter createTypeParameter(TypeVariable<?> variable, JvmMember container) {\n\t\tJvmTypeParameter result = TypesFactory.eINSTANCE.createJvmTypeParameter();\n\t\tresult.setName(variable.getName());\n\t\tType[] bounds = variable.getBounds();\n\t\tif (bounds.length != 0) {\n\t\t\tInternalEList<JvmTypeConstraint> constraints = (InternalEList<JvmTypeConstraint>)result.getConstraints();\n\t\t\tfor (Type bound : variable.getBounds()) {\n\t\t\t\tJvmUpperBound upperBound = TypesFactory.eINSTANCE.createJvmUpperBound();\n\t\t\t\t((JvmTypeConstraintImplCustom) upperBound).internalSetTypeReference(createTypeReference(bound));\n\t\t\t\tconstraints.addUnique(upperBound);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected <T extends Member & GenericDeclaration> void enhanceExecutable(JvmExecutable result, T member,\n\t\t\tString simpleName, Type[] parameterTypes, Annotation[][] annotations, int offset) {\n\t\tStringBuilder fqName = new StringBuilder(48);\n\t\tfqName.append(member.getDeclaringClass().getName());\n\t\tfqName.append('.');\n\t\tfqName.append(simpleName);\n\t\tfqName.append('(');\n\t\tfor (int typeIdx = offset, annotationIdx = annotations.length - parameterTypes.length + offset; typeIdx < parameterTypes.length; typeIdx++, annotationIdx++) {\n\t\t\tif (typeIdx != offset)\n\t\t\t\tfqName.append(',');\n\t\t\tType parameterType = parameterTypes[typeIdx];\n\t\t\turiHelper.computeTypeName(parameterType, fqName);\n\t\t\tresult.getParameters().add(\n\t\t\t\t\tcreateFormalParameter(parameterType, \"arg\" + (typeIdx - offset), result, member,\n\t\t\t\t\t\t\tannotations[annotationIdx]));\n\t\t}\n\t\tfqName.append(')');\n\t\tresult.internalSetIdentifier(fqName.toString());\n\t\tresult.setSimpleName(simpleName);\n\t\tsetVisibility(result, member.getModifiers());\n\t}","id":51897,"modified_method":"protected <T extends Member & GenericDeclaration> void enhanceExecutable(JvmExecutable result, T member,\n\t\t\tString simpleName, Type[] parameterTypes, Annotation[][] annotations, int offset) {\n\t\tStringBuilder fqName = new StringBuilder(48);\n\t\tfqName.append(member.getDeclaringClass().getName());\n\t\tfqName.append('.');\n\t\tfqName.append(simpleName);\n\t\tfqName.append('(');\n\t\tInternalEList<JvmFormalParameter> parameters = (InternalEList<JvmFormalParameter>)result.getParameters();\n\t\tfor (int typeIdx = offset, annotationIdx = annotations.length - parameterTypes.length + offset; typeIdx < parameterTypes.length; typeIdx++, annotationIdx++) {\n\t\t\tif (typeIdx != offset)\n\t\t\t\tfqName.append(',');\n\t\t\tType parameterType = parameterTypes[typeIdx];\n\t\t\turiHelper.computeTypeName(parameterType, fqName);\n\t\t\tparameters.addUnique(\n\t\t\t\t\tcreateFormalParameter(parameterType, \"arg\" + (typeIdx - offset), result, member,\n\t\t\t\t\t\t\tannotations[annotationIdx]));\n\t\t}\n\t\tfqName.append(')');\n\t\tresult.internalSetIdentifier(fqName.toString());\n\t\tresult.setSimpleName(simpleName);\n\t\tsetVisibility(result, member.getModifiers());\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmAnnotationValue createArrayAnnotationValue(Object value, Class<?> type) {\n\t\tif (!type.isArray())\n\t\t\tthrow new IllegalArgumentException(\"type is not an array type: \" + type.getCanonicalName());\n\t\tClass<?> componentType = type.getComponentType();\n\t\tJvmAnnotationValue result = createAnnotationValue(componentType);\n\t\tint length = Array.getLength(value);\n\t\tif (length > 0) {\n\t\t\tList<Object> valuesAsList = Lists.newArrayListWithExpectedSize(length);\n\t\t\tif (componentType.isPrimitive() || String.class.equals(componentType)) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tvaluesAsList.add(Array.get(value, i));\n\t\t\t\t}\n\t\t\t} else if (componentType.equals(Class.class)) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tClass<?> referencedClass = (Class<?>) Array.get(value, i);\n\t\t\t\t\tvaluesAsList.add(createTypeReference(referencedClass));\n\t\t\t\t}\n\t\t\t} else if (componentType.isAnnotation()) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tAnnotation nestedAnnotation = (Annotation) Array.get(value, i);\n\t\t\t\t\t((JvmAnnotationAnnotationValue) result).getValues()\n\t\t\t\t\t\t\t.add(createAnnotationReference(nestedAnnotation));\n\t\t\t\t}\n\t\t\t} else if (componentType.isEnum()) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tEnum<?> e = (Enum<?>) Array.get(value, i);\n\t\t\t\t\tJvmEnumerationLiteral proxy = createEnumLiteralProxy(e);\n\t\t\t\t\tvaluesAsList.add(proxy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!componentType.isAnnotation())\n\t\t\t\tresult.eSet(result.eClass().getEStructuralFeature(\"values\"), valuesAsList);\n\t\t}\n\t\treturn result;\n\t}","id":51898,"modified_method":"protected JvmAnnotationValue createArrayAnnotationValue(Object value, Class<?> type) {\n\t\tif (!type.isArray())\n\t\t\tthrow new IllegalArgumentException(\"type is not an array type: \" + type.getCanonicalName());\n\t\tClass<?> componentType = type.getComponentType();\n\t\tEStructuralFeature.Setting result = createAnnotationValue(componentType);\n\t\tint length = Array.getLength(value);\n\t\tif (length > 0) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tInternalEList<Object> values = (InternalEList<Object>)result;\n\t\t\tif (componentType.isPrimitive() || String.class == componentType) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tvalues.addUnique(Array.get(value, i));\n\t\t\t\t}\n\t\t\t} else if (componentType == Class.class) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tClass<?> referencedClass = (Class<?>) Array.get(value, i);\n\t\t\t\t\tvalues.addUnique(createTypeReference(referencedClass));\n\t\t\t\t}\n\t\t\t} else if (componentType.isAnnotation()) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tAnnotation nestedAnnotation = (Annotation) Array.get(value, i);\n\t\t\t\t\tvalues.addUnique(createAnnotationReference(nestedAnnotation));\n\t\t\t\t}\n\t\t\t} else if (componentType.isEnum()) {\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tEnum<?> e = (Enum<?>) Array.get(value, i);\n\t\t\t\t\tvalues.addUnique(createEnumLiteralProxy(e));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (JvmAnnotationValue)result.getEObject();\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tresult.setAbstract(Modifier.isAbstract(method.getModifiers()));\n\t\tresult.setFinal(Modifier.isFinal(method.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(method.getModifiers()));\n\t\tresult.setSynchronized(Modifier.isSynchronized(method.getModifiers()));\n\t\tresult.setStrictFloatingPoint(Modifier.isStrict(method.getModifiers()));\n\t\tresult.setNative(Modifier.isNative(method.getModifiers()));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\treturnType = method.getReturnType();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = method.getGenericExceptionTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","id":51899,"modified_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tint modifiers = method.getModifiers();\n\t\tresult.setAbstract(Modifier.isAbstract(modifiers));\n\t\tresult.setFinal(Modifier.isFinal(modifiers));\n\t\tresult.setStatic(Modifier.isStatic(modifiers));\n\t\tresult.setSynchronized(Modifier.isSynchronized(modifiers));\n\t\tresult.setStrictFloatingPoint(Modifier.isStrict(modifiers));\n\t\tresult.setNative(Modifier.isNative(modifiers));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\treturnType = method.getReturnType();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = method.getGenericExceptionTypes();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t}\n\t\tif (exceptionTypes.length != 0) {\n\t\t\tInternalEList<JvmTypeReference> exceptions = (InternalEList<JvmTypeReference>)result.getExceptions();\n\t\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\t\texceptions.addUnique(createTypeReference(exceptionType));\n\t\t\t}\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmType createProxy(Type type) {\n\t\tInternalEObject proxy = (InternalEObject) TypesFactory.eINSTANCE.createJvmVoid();\n\t\tURI uri = uriHelper.getFullURI(type);\n\t\tproxy.eSetProxyURI(uri);\n\t\treturn (org.eclipse.xtext.common.types.JvmType) proxy;\n\t}","id":51900,"modified_method":"protected JvmType createProxy(Type type) {\n\t\tJvmType proxy = typeProxies.get(type);\n\t\tif (proxy == null) {\n\t\t\tproxy = TypesFactory.eINSTANCE.createJvmVoid();\n\t\t\tURI uri = uriHelper.getFullURI(type);\n\t\t\t((InternalEObject)proxy).eSetProxyURI(uri);\n\t\t\ttypeProxies.put(type, proxy);\n\t\t}\n\t\treturn proxy;\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getGenericSuperclass()));\n\t\t\t}\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t}\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\n\t\tfor (Type type : interfaces) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(type));\n\t\t}\n\t\tif (result.getSuperTypes().isEmpty() && !Object.class.equals(clazz)) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(Object.class));\n\t\t}\n\t}","id":51901,"modified_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\tInternalEList<JvmTypeReference> superTypes = (InternalEList<JvmTypeReference>)result.getSuperTypes();\n\t\tType superclass = null;\n\t\ttry {\n\t\t\tsuperclass = clazz.getGenericSuperclass();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tsuperclass = clazz.getSuperclass();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tsuperclass = clazz.getSuperclass();\n\t\t}\n\t\tif (superclass != null) {\n\t\t\tsuperTypes.addUnique(createTypeReference(superclass));\n\t\t}\n\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch (GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t} catch (MalformedParameterizedTypeException error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\t\tfor (Type type : interfaces) {\n\t\t\tsuperTypes.addUnique(createTypeReference(type));\n\t\t}\n\n\t\tif (superTypes.isEmpty() && Object.class != clazz) {\n\t\t\tsuperTypes.addUnique(createTypeReference(Object.class));\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createMethods(Class<?> clazz, JvmDeclaredType result) {\n\t\tfor (Method method : clazz.getDeclaredMethods()) {\n\t\t\tif (!method.isSynthetic()) {\n\t\t\t\tJvmOperation operation = createOperation(method);\n\t\t\t\tif (clazz.isAnnotation()) {\n\t\t\t\t\tsetDefaultValue(operation, method);\n\t\t\t\t}\n\t\t\t\tresult.getMembers().add(operation);\n\t\t\t}\n\t\t}\n\t}","id":51902,"modified_method":"protected void createMethods(Class<?> clazz, JvmDeclaredType result) {\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tif (declaredMethods.length != 0) {\n\t\t\tInternalEList<JvmMember> members = (InternalEList<JvmMember>)result.getMembers();\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\tif (!method.isSynthetic()) {\n\t\t\t\t\tJvmOperation operation = createOperation(method);\n\t\t\t\t\tif (clazz.isAnnotation()) {\n\t\t\t\t\t\tsetDefaultValue(operation, method);\n\t\t\t\t\t}\n\t\t\t\t\tmembers.addUnique(operation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"private void setDefaultValue(JvmOperation operation, Method method) {\n\t\tObject defaultValue = method.getDefaultValue();\n\t\tif (defaultValue != null) {\n\t\t\tif (method.getReturnType().isArray()) {\n\t\t\t\tJvmAnnotationValue annotationValue = createArrayAnnotationValue(defaultValue, method.getReturnType());\n\t\t\t\toperation.setDefaultValue(annotationValue);\n\t\t\t\tannotationValue.setOperation(operation);\n\t\t\t} else {\n\t\t\t\tJvmAnnotationValue annotationValue = createAnnotationValue(defaultValue, method.getReturnType());\n\t\t\t\toperation.setDefaultValue(annotationValue);\n\t\t\t\tannotationValue.setOperation(operation);\n\t\t\t}\n\t\t}\n\t}","id":51903,"modified_method":"private void setDefaultValue(JvmOperation operation, Method method) {\n\t\tObject defaultValue = method.getDefaultValue();\n\t\tif (defaultValue != null) {\n\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\tif (returnType.isArray()) {\n\t\t\t\tJvmAnnotationValue annotationValue = createArrayAnnotationValue(defaultValue, returnType);\n\t\t\t\toperation.setDefaultValue(annotationValue);\n\t\t\t\tannotationValue.setOperation(operation);\n\t\t\t} else {\n\t\t\t\tJvmAnnotationValue annotationValue = createAnnotationValue(defaultValue, returnType);\n\t\t\t\toperation.setDefaultValue(annotationValue);\n\t\t\t\tannotationValue.setOperation(operation);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setTypeModifiers(Class<?> clazz, JvmDeclaredType result) {\n\t\tresult.setAbstract(Modifier.isAbstract(clazz.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(clazz.getModifiers()));\n\t\tif (!(result instanceof JvmEnumerationType))\n\t\t\tresult.setFinal(Modifier.isFinal(clazz.getModifiers()));\n\t}","id":51904,"modified_method":"protected void setTypeModifiers(Class<?> clazz, JvmDeclaredType result) {\n\t\tint modifiers = clazz.getModifiers();\n\t\tresult.setAbstract(Modifier.isAbstract(modifiers));\n\t\tresult.setStatic(Modifier.isStatic(modifiers));\n\t\tif (!(result instanceof JvmEnumerationType))\n\t\t\tresult.setFinal(Modifier.isFinal(modifiers));\n\t}","commit_id":"a7b595aef65c84593712197164be7bffde47f7a7","url":"https://github.com/eclipse/xtext"},{"original_method":"public Collection<SourceClass> getMemberClasses() throws IOException {\n\t\t\tList<SourceClass> members = new ArrayList<SourceClass>();\n\t\t\tif (this.source instanceof Class<?>) {\n\t\t\t\tClass<?> sourceClass = (Class<?>) this.source;\n\t\t\t\tfor (Class<?> declaredClass : sourceClass.getDeclaredClasses()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmembers.add(asSourceClass(declaredClass));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMetadataReader sourceReader = (MetadataReader) source;\n\t\t\t\tfor (String memberClassName : sourceReader.getClassMetadata().getMemberClassNames()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmembers.add(asSourceClass(memberClassName));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn members;\n\t\t}","id":51905,"modified_method":"public Collection<SourceClass> getMemberClasses() throws IOException {\n\t\t\tObject sourceToProcess = this.source;\n\n\t\t\tif (sourceToProcess instanceof Class<?>) {\n\t\t\t\tClass<?> sourceClass = (Class<?>) sourceToProcess;\n\t\t\t\ttry {\n\t\t\t\t\tClass<?>[] declaredClasses = sourceClass.getDeclaredClasses();\n\t\t\t\t\tList<SourceClass> members = new ArrayList<SourceClass>(declaredClasses.length);\n\t\t\t\t\tfor (Class<?> declaredClass : declaredClasses) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmembers.add(asSourceClass(declaredClass));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn members;\n\t\t\t\t}\n\t\t\t\tcatch (NoClassDefFoundError err) {\n\t\t\t\t\t// getDeclaredClasses() failed because of non-resolvable dependencies\n\t\t\t\t\t// -> fall back to ASM below\n\t\t\t\t\tsourceToProcess = metadataReaderFactory.getMetadataReader(sourceClass.getName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ASM-based resolution - safe for non-resolvable classes as well\n\t\t\tMetadataReader sourceReader = (MetadataReader) sourceToProcess;\n\t\t\tString[] memberClassNames = sourceReader.getClassMetadata().getMemberClassNames();\n\t\t\tList<SourceClass> members = new ArrayList<SourceClass>(memberClassNames.length);\n\t\t\tfor (String memberClassName : memberClassNames) {\n\t\t\t\ttry {\n\t\t\t\t\tmembers.add(asSourceClass(memberClassName));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn members;\n\t\t}","commit_id":"6aa9c40552c8b446ffcbd71bf2edc17b5ca38c77","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n    public void panicTest() throws Exception\n    {\n        String path = \"target/var/testdb\";\n        AbstractNeo4jTestCase.deleteFileOrDirectory( new File( path ) );\n        EmbeddedGraphDatabase graphDb = new EmbeddedGraphDatabase( path );\n        XaDataSourceManager xaDs =\n            graphDb.getConfig().getTxModule().getXaDataSourceManager();\n        \n        IllBehavingXaDataSource noob = new IllBehavingXaDataSource();\n        xaDs.registerDataSource( \"noob\", noob, UTF8.encode( \"554342\" ) );\n        \n        Panic panic = new Panic();\n        graphDb.registerKernelEventHandler( panic );\n     \n        org.neo4j.graphdb.Transaction gdbTx = graphDb.beginTx();\n        TransactionManager txMgr = graphDb.getConfig().getTxModule().getTxManager();\n        Transaction tx = txMgr.getTransaction();\n        \n        graphDb.createNode();\n        tx.enlistResource( noob.getXaConnection().getXaResource() );\n        try\n        {\n            gdbTx.success();\n            gdbTx.finish();\n            fail( \"Should fail\" );\n        }\n        catch ( Throwable t )\n        {\n            // ok\n            for ( int i = 0; i < 10 && panic.panic == false; i++ )\n            {\n                Thread.sleep( 1000 );\n            }\n        }\n        finally\n        {\n            graphDb.unregisterKernelEventHandler( panic );\n        }\n        assertTrue( panic.panic );\n        \n        graphDb.shutdown();\n    }","id":51906,"modified_method":"@Test\n    public void panicTest() throws Exception\n    {\n        String path = \"target/var/testdb\";\n        AbstractNeo4jTestCase.deleteFileOrDirectory( new File( path ) );\n        EmbeddedGraphDatabase graphDb = new EmbeddedGraphDatabase( path );\n        XaDataSourceManager xaDs =\n            graphDb.getConfig().getTxModule().getXaDataSourceManager();\n        \n        IllBehavingXaDataSource noob = new IllBehavingXaDataSource();\n        xaDs.registerDataSource( \"noob\", noob, UTF8.encode( \"554342\" ) );\n        \n        Panic panic = new Panic();\n        graphDb.registerKernelEventHandler( panic );\n     \n        org.neo4j.graphdb.Transaction gdbTx = graphDb.beginTx();\n        TransactionManager txMgr = graphDb.getConfig().getTxModule().getTxManager();\n        Transaction tx = txMgr.getTransaction();\n        \n        graphDb.createNode();\n        tx.enlistResource( noob.getXaConnection().getXaResource() );\n        try\n        {\n            gdbTx.success();\n            gdbTx.finish();\n            fail( \"Should fail\" );\n        }\n        catch ( Throwable t )\n        {\n            // ok\n            for ( int i = 0; i < 10 && !panic.panic; i++ )\n            {\n                Thread.sleep( 1000 );\n            }\n        }\n        finally\n        {\n            graphDb.unregisterKernelEventHandler( panic );\n        }\n        assertTrue( panic.panic );\n        assertMessageLogContains(path,\"at org.neo4j.kernel.impl.event.TestKernelPanic.panicTest\");\n        graphDb.shutdown();\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void rollbackCommit( Thread thread, TransactionImpl tx )\n        throws HeuristicMixedException, RollbackException, SystemException\n    {\n        try\n        {\n            tx.doRollback();\n        }\n        catch ( XAException e )\n        {\n            log.log( Level.SEVERE, \"Unable to rollback marked transaction. \"\n                + \"Some resources may be commited others not. \"\n                + \"Neo4j kernel should be SHUTDOWN for \"\n                                   + \"resource maintance and transaction recovery ---->\", e );\n            setTmNotOk();\n            throw Exceptions.withCause(\n                    new HeuristicMixedException( \"Unable to rollback \" + \" ---> error code for rollback: \"\n                                                 + e.errorCode ), e );\n        }\n\n        tx.doAfterCompletion();\n        txThreadMap.remove( thread );\n        try\n        {\n            if ( tx.isGlobalStartRecordWritten() )\n            {\n                getTxLog().txDone( tx.getGlobalId() );\n            }\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log\" ), e );\n        }\n        tx.setStatus( Status.STATUS_NO_TRANSACTION );\n        throw new RollbackException(\n            \"Failed to commit, transaction rolledback\" );\n    }","id":51907,"modified_method":"private void rollbackCommit( Thread thread, TransactionImpl tx )\n        throws HeuristicMixedException, RollbackException, SystemException\n    {\n        try\n        {\n            tx.doRollback();\n        }\n        catch ( XAException e )\n        {\n            log.log( Level.SEVERE, \"Unable to rollback marked transaction. \"\n                + \"Some resources may be commited others not. \"\n                + \"Neo4j kernel should be SHUTDOWN for \"\n                                   + \"resource maintance and transaction recovery ---->\", e );\n            setTmNotOk();\n            throw logAndReturn(\"TM error tx rollback commit\",Exceptions.withCause(\n                    new HeuristicMixedException( \"Unable to rollback \" + \" ---> error code for rollback: \"\n                                                 + e.errorCode ), e ));\n        }\n\n        tx.doAfterCompletion();\n        txThreadMap.remove( thread );\n        try\n        {\n            if ( tx.isGlobalStartRecordWritten() )\n            {\n                getTxLog().txDone( tx.getGlobalId() );\n            }\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw logAndReturn(\"TM error tx rollback commit\",Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log\" ), e ));\n        }\n        tx.setStatus( Status.STATUS_NO_TRANSACTION );\n        throw new RollbackException(\n            \"Failed to commit, transaction rolledback\" );\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Transaction suspend() throws SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        // check for ACTIVE/MARKED_ROLLBACK?\n        TransactionImpl tx = txThreadMap.remove( Thread.currentThread() );\n        if ( tx != null )\n        {\n            // generate pro-active event suspend\n            tx.markAsSuspended();\n        }\n        return tx;\n    }","id":51908,"modified_method":"public Transaction suspend() throws SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx suspend\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        // check for ACTIVE/MARKED_ROLLBACK?\n        TransactionImpl tx = txThreadMap.remove( Thread.currentThread() );\n        if ( tx != null )\n        {\n            // generate pro-active event suspend\n            tx.markAsSuspended();\n        }\n        return tx;\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void buildRecoveryInfo( List<NonCompletedTransaction> commitList,\n        List<Xid> rollbackList, Map<Resource,XAResource> resourceMap,\n        Iterator<List<TxLog.Record>> danglingRecordList )\n    {\n        while ( danglingRecordList.hasNext() )\n        {\n            Iterator<TxLog.Record> dListItr =\n                danglingRecordList.next().iterator();\n            TxLog.Record startRecord = dListItr.next();\n            if ( startRecord.getType() != TxLog.TX_START )\n            {\n                throw new TransactionFailureException(\n                    \"First record not a start record, type=\"\n                        + startRecord.getType() );\n            }\n            // get branches & commit status\n            HashSet<Resource> branchSet = new HashSet<Resource>();\n            int markedCommit = -1;\n            while ( dListItr.hasNext() )\n            {\n                TxLog.Record record = dListItr.next();\n                if ( record.getType() == TxLog.BRANCH_ADD )\n                {\n                    if ( markedCommit != -1 )\n                    {\n                        throw new TransactionFailureException(\n                            \"Already marked commit \" + startRecord );\n                    }\n                    branchSet.add( new Resource( record.getBranchId() ) );\n                }\n                else if ( record.getType() == TxLog.MARK_COMMIT )\n                {\n                    if ( markedCommit != -1 )\n                    {\n                        throw new TransactionFailureException(\n                            \"Already marked commit \" + startRecord );\n                    }\n                    markedCommit = record.getSequenceNumber();\n                }\n                else\n                {\n                    throw new TransactionFailureException(\n                        \"Illegal record type[\" + record.getType() + \"]\" );\n                }\n            }\n            Iterator<Resource> resourceItr = branchSet.iterator();\n            List<Xid> xids = new LinkedList<Xid>();\n            while ( resourceItr.hasNext() )\n            {\n                Resource resource = resourceItr.next();\n                if ( !resourceMap.containsKey( resource ) )\n                {\n                    resourceMap.put( resource, getXaResource(\n                        resource.getResourceId() ) );\n                }\n                xids.add( new XidImpl( startRecord.getGlobalId(),\n                    resource.getResourceId() ) );\n            }\n            if ( markedCommit != -1 ) // this xid needs to be committed\n            {\n                commitList.add(\n                    new NonCompletedTransaction( markedCommit, xids ) );\n            }\n            else\n            {\n                rollbackList.addAll( xids );\n            }\n        }\n    }","id":51909,"modified_method":"private void buildRecoveryInfo( List<NonCompletedTransaction> commitList,\n        List<Xid> rollbackList, Map<Resource,XAResource> resourceMap,\n        Iterator<List<TxLog.Record>> danglingRecordList )\n    {\n        while ( danglingRecordList.hasNext() )\n        {\n            Iterator<TxLog.Record> dListItr =\n                danglingRecordList.next().iterator();\n            TxLog.Record startRecord = dListItr.next();\n            if ( startRecord.getType() != TxLog.TX_START )\n            {\n                throw logAndReturn(\"TM error building recovery info\",\n                        new TransactionFailureException(\n                    \"First record not a start record, type=\"\n                        + startRecord.getType() ));\n            }\n            // get branches & commit status\n            HashSet<Resource> branchSet = new HashSet<Resource>();\n            int markedCommit = -1;\n            while ( dListItr.hasNext() )\n            {\n                TxLog.Record record = dListItr.next();\n                if ( record.getType() == TxLog.BRANCH_ADD )\n                {\n                    if ( markedCommit != -1 )\n                    {\n\n                        throw logAndReturn(\"TM error building recovery info\", new TransactionFailureException(\n                            \"Already marked commit \" + startRecord ));\n                    }\n                    branchSet.add( new Resource( record.getBranchId() ) );\n                }\n                else if ( record.getType() == TxLog.MARK_COMMIT )\n                {\n                    if ( markedCommit != -1 )\n                    {\n                        throw logAndReturn(\"TM error building recovery info\",new TransactionFailureException(\n                            \"Already marked commit \" + startRecord ));\n                    }\n                    markedCommit = record.getSequenceNumber();\n                }\n                else\n                {\n                    throw logAndReturn(\"TM error building recovery info\",new TransactionFailureException(\n                        \"Illegal record type[\" + record.getType() + \"]\" ));\n                }\n            }\n            Iterator<Resource> resourceItr = branchSet.iterator();\n            List<Xid> xids = new LinkedList<Xid>();\n            while ( resourceItr.hasNext() )\n            {\n                Resource resource = resourceItr.next();\n                if ( !resourceMap.containsKey( resource ) )\n                {\n                    resourceMap.put( resource, getXaResource(\n                        resource.getResourceId() ) );\n                }\n                xids.add( new XidImpl( startRecord.getGlobalId(),\n                    resource.getResourceId() ) );\n            }\n            if ( markedCommit != -1 ) // this xid needs to be committed\n            {\n                commitList.add(\n                    new NonCompletedTransaction( markedCommit, xids ) );\n            }\n            else\n            {\n                rollbackList.addAll( xids );\n            }\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"void writeStartRecord( byte globalId[] ) throws SystemException\n    {\n        try\n        {\n            getTxLog().txStart( globalId );\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log,\" ), e );\n        }\n    }","id":51910,"modified_method":"void writeStartRecord( byte globalId[] ) throws SystemException\n    {\n        try\n        {\n            getTxLog().txStart( globalId );\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw logAndReturn(\"TM error write start record\",Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log,\" ), e ));\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private XaDataSource xaResourceToDataSource( XAResource participant )\n    {\n        byte[] participantBranchId = xaDsManager.getBranchId( participant );\n        for ( XaDataSource dataSource : xaDsManager.getAllRegisteredDataSources() )\n        {\n            if ( Arrays.equals( participantBranchId, dataSource.getBranchId() ) )\n            {\n                return dataSource;\n            }\n        }\n        throw new TransactionFailureException( \"Data source for recovery participant \" + participant +\n                \", \" + Arrays.toString( participantBranchId ) + \" couldn't be found\" );\n    }","id":51911,"modified_method":"private XaDataSource xaResourceToDataSource( XAResource participant )\n    {\n        byte[] participantBranchId = xaDsManager.getBranchId( participant );\n        for ( XaDataSource dataSource : xaDsManager.getAllRegisteredDataSources() )\n        {\n            if ( Arrays.equals( participantBranchId, dataSource.getBranchId() ) )\n            {\n                return dataSource;\n            }\n        }\n        throw logAndReturn(\"TM recovery data source not found\",\n                new TransactionFailureException(\"Data source for recovery participant \" + participant +\n                        \", \" + Arrays.toString(participantBranchId) + \" couldn't be found\"));\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized TxLog getTxLog() throws IOException\n    {\n        if ( txLog.getRecordCount() > maxTxLogRecordCount )\n        {\n            if ( txLog.getName().endsWith( txLog1FileName ) )\n            {\n                txLog.switchToLogFile( txLogDir + separator + txLog2FileName );\n                changeActiveLog( txLog2FileName );\n            }\n            else if ( txLog.getName().endsWith( txLog2FileName ) )\n            {\n                txLog.switchToLogFile( txLogDir + separator + txLog1FileName );\n                changeActiveLog( txLog1FileName );\n            }\n            else\n            {\n                setTmNotOk();\n                log.severe( \"Unknown active tx log file[\" + txLog.getName()\n                    + \"], unable to switch.\" );\n                throw new IOException( \"Unknown txLogFile[\" + txLog.getName()\n                    + \"] not equals to either [\" + txLog1FileName + \"] or [\"\n                    + txLog2FileName + \"]\" );\n            }\n        }\n        return txLog;\n    }","id":51912,"modified_method":"synchronized TxLog getTxLog() throws IOException\n    {\n        if ( txLog.getRecordCount() > maxTxLogRecordCount )\n        {\n            if ( txLog.getName().endsWith( txLog1FileName ) )\n            {\n                txLog.switchToLogFile( txLogDir + separator + txLog2FileName );\n                changeActiveLog( txLog2FileName );\n            }\n            else if ( txLog.getName().endsWith( txLog2FileName ) )\n            {\n                txLog.switchToLogFile( txLogDir + separator + txLog1FileName );\n                changeActiveLog( txLog1FileName );\n            }\n            else {\n                setTmNotOk();\n                log.severe(\"Unknown active tx log file[\" + txLog.getName()\n                        + \"], unable to switch.\");\n                final IOException ex = new IOException(\"Unknown txLogFile[\" + txLog.getName()\n                        + \"] not equals to either [\" + txLog1FileName + \"] or [\"\n                        + txLog2FileName + \"]\");\n                throw logAndReturn(\"TM error accessing log file\", ex);\n            }\n        }\n        return txLog;\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setRollbackOnly() throws IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw new IllegalStateException( \"Not in transaction\" );\n        }\n        tx.setRollbackOnly();\n    }","id":51913,"modified_method":"public void setRollbackOnly() throws IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx set rollback only\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw new IllegalStateException( \"Not in transaction\" );\n        }\n        tx.setRollbackOnly();\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void begin() throws NotSupportedException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx != null )\n        {\n            throw new NotSupportedException(\n                \"Nested transactions not supported\" );\n        }\n        tx = new TransactionImpl( this );\n        txThreadMap.put( thread, tx );\n        int concurrentTxCount = txThreadMap.size();\n        if ( concurrentTxCount > peakConcurrentTransactions )\n        {\n            peakConcurrentTransactions = concurrentTxCount;\n        }\n        startedTxCount.incrementAndGet();\n        // start record written on resource enlistment\n    }","id":51914,"modified_method":"public void begin() throws NotSupportedException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx begin\", new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx != null )\n        {\n            throw logAndReturn(\"TM error tx begin\",new NotSupportedException(\n                \"Nested transactions not supported\" ));\n        }\n        tx = new TransactionImpl( this );\n        txThreadMap.put( thread, tx );\n        int concurrentTxCount = txThreadMap.size();\n        if ( concurrentTxCount > peakConcurrentTransactions )\n        {\n            peakConcurrentTransactions = concurrentTxCount;\n        }\n        startedTxCount.incrementAndGet();\n        // start record written on resource enlistment\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void recover( Iterator<List<TxLog.Record>> danglingRecordList )\n    {\n        msgLog.logMessage( \"TM non resolved transactions found in \" + txLog.getName(), true );\n        try\n        {\n            // contains NonCompletedTransaction that needs to be committed\n            List<NonCompletedTransaction> commitList =\n                new ArrayList<NonCompletedTransaction>();\n\n            // contains Xids that should be rolledback\n            List<Xid> rollbackList = new LinkedList<Xid>();\n\n            // key = Resource(branchId) value = XAResource\n            Map<Resource,XAResource> resourceMap =\n                new HashMap<Resource,XAResource>();\n            buildRecoveryInfo( commitList, rollbackList, resourceMap,\n                danglingRecordList );\n            // invoke recover on all xa resources found\n            Iterator<Resource> resourceItr = resourceMap.keySet().iterator();\n            List<Xid> recoveredXidsList = new LinkedList<Xid>();\n            while ( resourceItr.hasNext() )\n            {\n                XAResource xaRes = resourceMap.get( resourceItr.next() );\n                Xid xids[] = xaRes.recover( XAResource.TMNOFLAGS );\n                for ( int i = 0; i < xids.length; i++ )\n                {\n                    if ( XidImpl.isThisTm( xids[i].getGlobalTransactionId() ) )\n                    {\n                        // linear search\n                        if ( rollbackList.contains( xids[i] ) )\n                        {\n                            log.fine( \"Found pre commit \" + xids[i]\n                                + \" rolling back ... \" );\n                            msgLog.logMessage( \"TM: Found pre commit \" + xids[i] + \" rolling back ... \", true );\n                            rollbackList.remove( xids[i] );\n                            xaRes.rollback( xids[i] );\n                        }\n                        else\n                        {\n                            recoveredXidsList.add( xids[i] );\n                        }\n                    }\n                    else\n                    {\n                        log.warning( \"Unknown xid: \" + xids[i] );\n                    }\n                }\n            }\n            // sort the commit list after sequence number\n            Collections.sort( commitList,\n                new Comparator<NonCompletedTransaction>()\n                {\n                    public int compare( NonCompletedTransaction r1,\n                        NonCompletedTransaction r2 )\n                    {\n                        return r1.getSequenceNumber() - r2.getSequenceNumber();\n                    }\n                } );\n            // go through and commit\n            Iterator<NonCompletedTransaction> commitItr = commitList.iterator();\n            while ( commitItr.hasNext() )\n            {\n                NonCompletedTransaction nct = commitItr.next();\n                int seq = nct.getSequenceNumber();\n                Xid xids[] = nct.getXids();\n                log.fine( \"Marked as commit tx-seq[\" + seq +\n                    \"] branch length: \" + xids.length );\n                for ( Xid xid : xids )\n                {\n                    if ( !recoveredXidsList.contains( xid ) )\n                    {\n                        log.fine( \"Tx-seq[\" + seq + \"][\" + xid +\n                            \"] not found in recovered xid list, \"\n                            + \"assuming already committed\" );\n                        continue;\n                    }\n                    recoveredXidsList.remove( xid );\n                    Resource resource = new Resource( xid.getBranchQualifier() );\n                    if ( !resourceMap.containsKey( resource ) )\n                    {\n                        throw new TransactionFailureException(\n                            \"Couldn't find XAResource for \" + xid );\n                    }\n                    log.fine( \"Commiting tx seq[\" + seq + \"][\" + xid + \"] ... \" );\n                    msgLog.logMessage( \"TM: Committing tx \" + xid, true );\n                    resourceMap.get( resource ).commit( xid, false );\n                }\n            }\n            // rollback the rest\n            Iterator<Xid> rollbackItr = recoveredXidsList.iterator();\n            while ( rollbackItr.hasNext() )\n            {\n                Xid xid = rollbackItr.next();\n                Resource resource = new Resource( xid.getBranchQualifier() );\n                if ( !resourceMap.containsKey( resource ) )\n                {\n                    throw new TransactionFailureException(\n                        \"Couldn't find XAResource for \" + xid );\n                }\n                log.fine( \"Rollback \" + xid + \" ... \" );\n                msgLog.logMessage( \"TM: no match found for \" + xid + \" removing\", true );\n                resourceMap.get( resource ).rollback( xid );\n            }\n            if ( rollbackList.size() > 0 )\n            {\n                log.fine( \"TxLog contained unresolved \"\n                    + \"xids that needed rollback. They couldn't be matched to \"\n                    + \"any of the XAResources recover list. \" + \"Assuming \"\n                    + rollbackList.size()\n                    + \" transactions already rolled back.\" );\n                msgLog.logMessage( \"TM: no match found for in total \" + rollbackList.size() +\n                        \" transaction that should have been rolled back\", true );\n            }\n            \n            // Rotate the logs of the participated data sources, making sure that\n            // done-records are written so that even if the tm log gets truncated,\n            // which it will be after this recovery, that transaction information\n            // doesn't get lost.\n            for ( XAResource participant : MapUtil.reverse( resourceMap ).keySet() )\n            {\n                xaResourceToDataSource( participant ).rotateLogicalLog();\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new TransactionFailureException( \"Recovery failed.\", e );\n        }\n        catch ( XAException e )\n        {\n            throw new TransactionFailureException( \"Recovery failed.\", e );\n        }\n    }","id":51915,"modified_method":"private void recover( Iterator<List<TxLog.Record>> danglingRecordList )\n    {\n        msgLog.logMessage( \"TM non resolved transactions found in \" + txLog.getName(), true );\n        try\n        {\n            // contains NonCompletedTransaction that needs to be committed\n            List<NonCompletedTransaction> commitList =\n                new ArrayList<NonCompletedTransaction>();\n\n            // contains Xids that should be rolledback\n            List<Xid> rollbackList = new LinkedList<Xid>();\n\n            // key = Resource(branchId) value = XAResource\n            Map<Resource,XAResource> resourceMap =\n                new HashMap<Resource,XAResource>();\n            buildRecoveryInfo( commitList, rollbackList, resourceMap,\n                danglingRecordList );\n            // invoke recover on all xa resources found\n            Iterator<Resource> resourceItr = resourceMap.keySet().iterator();\n            List<Xid> recoveredXidsList = new LinkedList<Xid>();\n            while ( resourceItr.hasNext() )\n            {\n                XAResource xaRes = resourceMap.get( resourceItr.next() );\n                Xid xids[] = xaRes.recover( XAResource.TMNOFLAGS );\n                for ( int i = 0; i < xids.length; i++ )\n                {\n                    if ( XidImpl.isThisTm( xids[i].getGlobalTransactionId() ) )\n                    {\n                        // linear search\n                        if ( rollbackList.contains( xids[i] ) )\n                        {\n                            log.fine( \"Found pre commit \" + xids[i]\n                                + \" rolling back ... \" );\n                            msgLog.logMessage( \"TM: Found pre commit \" + xids[i] + \" rolling back ... \", true );\n                            rollbackList.remove( xids[i] );\n                            xaRes.rollback( xids[i] );\n                        }\n                        else\n                        {\n                            recoveredXidsList.add( xids[i] );\n                        }\n                    }\n                    else\n                    {\n                        log.warning( \"Unknown xid: \" + xids[i] );\n                    }\n                }\n            }\n            // sort the commit list after sequence number\n            Collections.sort( commitList,\n                new Comparator<NonCompletedTransaction>()\n                {\n                    public int compare( NonCompletedTransaction r1,\n                        NonCompletedTransaction r2 )\n                    {\n                        return r1.getSequenceNumber() - r2.getSequenceNumber();\n                    }\n                } );\n            // go through and commit\n            Iterator<NonCompletedTransaction> commitItr = commitList.iterator();\n            while ( commitItr.hasNext() )\n            {\n                NonCompletedTransaction nct = commitItr.next();\n                int seq = nct.getSequenceNumber();\n                Xid xids[] = nct.getXids();\n                log.fine( \"Marked as commit tx-seq[\" + seq +\n                    \"] branch length: \" + xids.length );\n                for ( Xid xid : xids )\n                {\n                    if ( !recoveredXidsList.contains( xid ) )\n                    {\n                        log.fine( \"Tx-seq[\" + seq + \"][\" + xid +\n                            \"] not found in recovered xid list, \"\n                            + \"assuming already committed\" );\n                        continue;\n                    }\n                    recoveredXidsList.remove( xid );\n                    Resource resource = new Resource( xid.getBranchQualifier() );\n                    if ( !resourceMap.containsKey( resource ) ) {\n                        final TransactionFailureException ex = new TransactionFailureException(\n                                \"Couldn't find XAResource for \" + xid);\n                        throw logAndReturn(\"TM: recovery error\", ex);\n                    }\n                    log.fine( \"Commiting tx seq[\" + seq + \"][\" + xid + \"] ... \" );\n                    msgLog.logMessage( \"TM: Committing tx \" + xid, true );\n                    resourceMap.get( resource ).commit( xid, false );\n                }\n            }\n            // rollback the rest\n            Iterator<Xid> rollbackItr = recoveredXidsList.iterator();\n            while ( rollbackItr.hasNext() )\n            {\n                Xid xid = rollbackItr.next();\n                Resource resource = new Resource( xid.getBranchQualifier() );\n                if ( !resourceMap.containsKey( resource ) ) {\n                    final TransactionFailureException ex = new TransactionFailureException(\n                            \"Couldn't find XAResource for \" + xid);\n                    throw logAndReturn(\"TM: recovery error\", ex);\n                }\n                log.fine( \"Rollback \" + xid + \" ... \" );\n                msgLog.logMessage( \"TM: no match found for \" + xid + \" removing\", true );\n                resourceMap.get( resource ).rollback( xid );\n            }\n            if ( rollbackList.size() > 0 )\n            {\n                log.fine( \"TxLog contained unresolved \"\n                    + \"xids that needed rollback. They couldn't be matched to \"\n                    + \"any of the XAResources recover list. \" + \"Assuming \"\n                    + rollbackList.size()\n                    + \" transactions already rolled back.\" );\n                msgLog.logMessage( \"TM: no match found for in total \" + rollbackList.size() +\n                        \" transaction that should have been rolled back\", true );\n            }\n            \n            // Rotate the logs of the participated data sources, making sure that\n            // done-records are written so that even if the tm log gets truncated,\n            // which it will be after this recovery, that transaction information\n            // doesn't get lost.\n            for ( XAResource participant : MapUtil.reverse( resourceMap ).keySet() )\n            {\n                xaResourceToDataSource( participant ).rotateLogicalLog();\n            }\n        }\n        catch ( IOException e )\n        {\n            throw logAndReturn(\"TM: recovery failed\",new TransactionFailureException(\"Recovery failed.\", e));\n        }\n        catch ( XAException e )\n        {\n            throw logAndReturn(\"TM: recovery failed\", new TransactionFailureException( \"Recovery failed.\", e ));\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setTransactionTimeout( int seconds ) throws SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        // ...\n    }","id":51916,"modified_method":"public void setTransactionTimeout( int seconds ) throws SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx set timeout\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        // ...\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void rollback() throws IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw new IllegalStateException( \"Not in transaction\" );\n        }\n\n        boolean hasAnyLocks = false;\n        try\n        {\n            hasAnyLocks = finishHook.hasAnyLocks( tx );\n            if ( tx.getStatus() == Status.STATUS_ACTIVE ||\n                tx.getStatus() == Status.STATUS_MARKED_ROLLBACK ||\n                tx.getStatus() == Status.STATUS_PREPARING )\n            {\n                tx.setStatus( Status.STATUS_MARKED_ROLLBACK );\n                tx.doBeforeCompletion();\n                // delist resources?\n                try\n                {\n                    rolledBackTxCount.incrementAndGet();\n                    tx.doRollback();\n                }\n                catch ( XAException e )\n                {\n                    log.log( Level.SEVERE, \"Unable to rollback marked or active transaction. \"\n                        + \"Some resources may be commited others not. \"\n                        + \"Neo4j kernel should be SHUTDOWN for \"\n                                           + \"resource maintance and transaction recovery ---->\", e );\n                    setTmNotOk();\n                    throw Exceptions.withCause(\n                            new SystemException( \"Unable to rollback \" + \" ---> error code for rollback: \"\n                                                 + e.errorCode ), e );\n                }\n                tx.doAfterCompletion();\n                txThreadMap.remove( thread );\n                try\n                {\n                    if ( tx.isGlobalStartRecordWritten() )\n                    {\n                        getTxLog().txDone( tx.getGlobalId() );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    log.log( Level.SEVERE, \"Error writing transaction log\", e );\n                    setTmNotOk();\n                    throw Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                                     + \" error writing transaction log\" ), e );\n                }\n                tx.setStatus( Status.STATUS_NO_TRANSACTION );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) );\n            }\n        }\n        finally\n        {\n            if ( hasAnyLocks )\n            {\n                finishHook.finishTransaction( tx.getEventIdentifier() );\n            }\n        }\n    }","id":51917,"modified_method":"public void rollback() throws IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx rollback\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw new IllegalStateException( \"Not in transaction\" );\n        }\n\n        boolean hasAnyLocks = false;\n        try\n        {\n            hasAnyLocks = finishHook.hasAnyLocks( tx );\n            if ( tx.getStatus() == Status.STATUS_ACTIVE ||\n                tx.getStatus() == Status.STATUS_MARKED_ROLLBACK ||\n                tx.getStatus() == Status.STATUS_PREPARING )\n            {\n                tx.setStatus( Status.STATUS_MARKED_ROLLBACK );\n                tx.doBeforeCompletion();\n                // delist resources?\n                try\n                {\n                    rolledBackTxCount.incrementAndGet();\n                    tx.doRollback();\n                }\n                catch ( XAException e )\n                {\n                    log.log( Level.SEVERE, \"Unable to rollback marked or active transaction. \"\n                        + \"Some resources may be commited others not. \"\n                        + \"Neo4j kernel should be SHUTDOWN for \"\n                                           + \"resource maintance and transaction recovery ---->\", e );\n                    setTmNotOk();\n                    throw logAndReturn(\"TM error tx rollback\", Exceptions.withCause(\n                            new SystemException( \"Unable to rollback \" + \" ---> error code for rollback: \"\n                                                 + e.errorCode ), e ));\n                }\n                tx.doAfterCompletion();\n                txThreadMap.remove( thread );\n                try\n                {\n                    if ( tx.isGlobalStartRecordWritten() )\n                    {\n                        getTxLog().txDone( tx.getGlobalId() );\n                    }\n                }\n                catch ( IOException e )\n                {\n                    log.log( Level.SEVERE, \"Error writing transaction log\", e );\n                    setTmNotOk();\n                    throw logAndReturn(\"TM error tx rollback\", Exceptions.withCause(\n                            new SystemException( \"TM encountered a problem, \"\n                                                 + \" error writing transaction log\" ), e ));\n                }\n                tx.setStatus( Status.STATUS_NO_TRANSACTION );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) );\n            }\n        }\n        finally\n        {\n            if ( hasAnyLocks )\n            {\n                finishHook.finishTransaction( tx.getEventIdentifier() );\n            }\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void commit( Thread thread, TransactionImpl tx )\n        throws SystemException, HeuristicMixedException,\n        HeuristicRollbackException\n    {\n        // mark as commit in log done TxImpl.doCommit()\n        Throwable commitFailureCause = null;\n        int xaErrorCode = -1;\n        if ( tx.getResourceCount() == 0 )\n        {\n            tx.setStatus( Status.STATUS_COMMITTED );\n        }\n        else\n        {\n            try\n            {\n                tx.doCommit();\n            }\n            catch ( XAException e )\n            {\n                xaErrorCode = e.errorCode;\n                log.log( Level.SEVERE, \"Commit failed, status=\"\n                    + getTxStatusAsString( tx.getStatus() ) + \", errorCode=\"\n + xaErrorCode, e );\n                if ( tx.getStatus() == Status.STATUS_COMMITTED )\n                {\n                    // this should never be\n                    setTmNotOk();\n                    throw new TransactionFailureException(\n                        \"commit threw exception but status is committed?\", e );\n                }\n            }\n            catch ( Throwable t )\n            {\n                log.log( Level.SEVERE, \"Commit failed\", t );\n                commitFailureCause = t;\n            }\n        }\n        if ( tx.getStatus() != Status.STATUS_COMMITTED )\n        {\n            try\n            {\n                tx.doRollback();\n            }\n            catch ( XAException e )\n            {\n                log.log( Level.SEVERE, \"Unable to rollback transaction. \"\n                    + \"Some resources may be commited others not. \"\n                    + \"Neo4j kernel should be SHUTDOWN for \"\n                                       + \"resource maintance and transaction recovery ---->\", e );\n                setTmNotOk();\n                String commitError;\n                if ( commitFailureCause != null )\n                {\n                    commitError = \"error in commit: \" + commitFailureCause;\n                }\n                else\n                {\n                    commitError = \"error code in commit: \" + xaErrorCode;\n                }\n                throw Exceptions.withCause( new HeuristicMixedException( \"Unable to rollback ---> \" + commitError\n                                                                         + \" ---> error code for rollback: \"\n                                                                         + e.errorCode ), e );\n            }\n            tx.doAfterCompletion();\n            txThreadMap.remove( thread );\n            try\n            {\n                if ( tx.isGlobalStartRecordWritten() )\n                {\n                    getTxLog().txDone( tx.getGlobalId() );\n                }\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.SEVERE, \"Error writing transaction log\", e );\n                setTmNotOk();\n                throw Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                                 + \" error writing transaction log\" ), e );\n            }\n            tx.setStatus( Status.STATUS_NO_TRANSACTION );\n            if ( commitFailureCause == null )\n            {\n                throw new HeuristicRollbackException(\n                    \"Failed to commit, transaction rolledback ---> \"\n                        + \"error code was: \" + xaErrorCode );\n            }\n            else\n            {\n                throw Exceptions.withCause( new HeuristicRollbackException(\n                    \"Failed to commit, transaction rolledback ---> \" +\n commitFailureCause ), commitFailureCause );\n            }\n        }\n        tx.doAfterCompletion();\n        txThreadMap.remove( thread );\n        try\n        {\n            if ( tx.isGlobalStartRecordWritten() )\n            {\n                getTxLog().txDone( tx.getGlobalId() );\n            }\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log\" ), e );\n        }\n        tx.setStatus( Status.STATUS_NO_TRANSACTION );\n    }","id":51918,"modified_method":"private void commit( Thread thread, TransactionImpl tx )\n        throws SystemException, HeuristicMixedException,\n        HeuristicRollbackException\n    {\n        // mark as commit in log done TxImpl.doCommit()\n        Throwable commitFailureCause = null;\n        int xaErrorCode = -1;\n        if ( tx.getResourceCount() == 0 )\n        {\n            tx.setStatus( Status.STATUS_COMMITTED );\n        }\n        else\n        {\n            try\n            {\n                tx.doCommit();\n            }\n            catch ( XAException e )\n            {\n                xaErrorCode = e.errorCode;\n                log.log( Level.SEVERE, \"Commit failed, status=\"\n                    + getTxStatusAsString( tx.getStatus() ) + \", errorCode=\"\n + xaErrorCode, e );\n                if ( tx.getStatus() == Status.STATUS_COMMITTED )\n                {\n                    // this should never be\n                    setTmNotOk();\n                    throw logAndReturn(\"TM error tx commit\",new TransactionFailureException(\n                        \"commit threw exception but status is committed?\", e ));\n                }\n            }\n            catch ( Throwable t )\n            {\n                log.log( Level.SEVERE, \"Commit failed\", t );\n                commitFailureCause = t;\n            }\n        }\n        if ( tx.getStatus() != Status.STATUS_COMMITTED )\n        {\n            try\n            {\n                tx.doRollback();\n            }\n            catch ( XAException e )\n            {\n                log.log( Level.SEVERE, \"Unable to rollback transaction. \"\n                    + \"Some resources may be commited others not. \"\n                    + \"Neo4j kernel should be SHUTDOWN for \"\n                                       + \"resource maintance and transaction recovery ---->\", e );\n                setTmNotOk();\n                String commitError;\n                if ( commitFailureCause != null )\n                {\n                    commitError = \"error in commit: \" + commitFailureCause;\n                }\n                else\n                {\n                    commitError = \"error code in commit: \" + xaErrorCode;\n                }\n                throw logAndReturn(\"TM error tx commit\",Exceptions.withCause( new HeuristicMixedException( \"Unable to rollback ---> \" + commitError\n                                                                         + \" ---> error code for rollback: \"\n                                                                         + e.errorCode ), e ));\n            }\n            tx.doAfterCompletion();\n            txThreadMap.remove( thread );\n            try\n            {\n                if ( tx.isGlobalStartRecordWritten() )\n                {\n                    getTxLog().txDone( tx.getGlobalId() );\n                }\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.SEVERE, \"Error writing transaction log\", e );\n                setTmNotOk();\n                throw logAndReturn(\"TM error tx commit\",Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                                 + \" error writing transaction log\" ), e ));\n            }\n            tx.setStatus( Status.STATUS_NO_TRANSACTION );\n            if ( commitFailureCause == null )\n            {\n                throw logAndReturn(\"TM error tx commit\",new HeuristicRollbackException(\n                    \"Failed to commit, transaction rolledback ---> \"\n                        + \"error code was: \" + xaErrorCode ));\n            }\n            else\n            {\n                throw logAndReturn(\"TM error tx commit\",Exceptions.withCause( new HeuristicRollbackException(\n                    \"Failed to commit, transaction rolledback ---> \" +\n                    commitFailureCause ), commitFailureCause ));\n            }\n        }\n        tx.doAfterCompletion();\n        txThreadMap.remove( thread );\n        try\n        {\n            if ( tx.isGlobalStartRecordWritten() )\n            {\n                getTxLog().txDone( tx.getGlobalId() );\n            }\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Error writing transaction log\", e );\n            setTmNotOk();\n            throw logAndReturn(\"TM error tx commit\",\n                    Exceptions.withCause( new SystemException( \"TM encountered a problem, \"\n                                                             + \" error writing transaction log\" ), e ));\n        }\n        tx.setStatus( Status.STATUS_NO_TRANSACTION );\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void commit() throws RollbackException, HeuristicMixedException,\n        HeuristicRollbackException, IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw new IllegalStateException( \"Not in transaction\" );\n        }\n\n        boolean hasAnyLocks = false;\n        try\n        {\n            hasAnyLocks = finishHook.hasAnyLocks( tx );\n            if ( tx.getStatus() != Status.STATUS_ACTIVE\n                && tx.getStatus() != Status.STATUS_MARKED_ROLLBACK )\n            {\n                throw new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) );\n            }\n            tx.doBeforeCompletion();\n            // delist resources?\n            if ( tx.getStatus() == Status.STATUS_ACTIVE )\n            {\n                comittedTxCount.incrementAndGet();\n                commit( thread, tx );\n            }\n            else if ( tx.getStatus() == Status.STATUS_MARKED_ROLLBACK )\n            {\n                rolledBackTxCount.incrementAndGet();\n                rollbackCommit( thread, tx );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) );\n            }\n        }\n        finally\n        {\n            if ( hasAnyLocks )\n            {\n                finishHook.finishTransaction( tx.getEventIdentifier() );\n            }\n        }\n    }","id":51919,"modified_method":"public void commit() throws RollbackException, HeuristicMixedException,\n        HeuristicRollbackException, IllegalStateException, SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx commit\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        Thread thread = Thread.currentThread();\n        TransactionImpl tx = txThreadMap.get( thread );\n        if ( tx == null )\n        {\n            throw logAndReturn(\"TM error tx commit\", new IllegalStateException( \"Not in transaction\" ));\n        }\n\n        boolean hasAnyLocks = false;\n        try\n        {\n            hasAnyLocks = finishHook.hasAnyLocks( tx );\n            if ( tx.getStatus() != Status.STATUS_ACTIVE\n                && tx.getStatus() != Status.STATUS_MARKED_ROLLBACK )\n            {\n                throw logAndReturn(\"TM error tx commit\",new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) ));\n            }\n            tx.doBeforeCompletion();\n            // delist resources?\n            if ( tx.getStatus() == Status.STATUS_ACTIVE )\n            {\n                comittedTxCount.incrementAndGet();\n                commit( thread, tx );\n            }\n            else if ( tx.getStatus() == Status.STATUS_MARKED_ROLLBACK )\n            {\n                rolledBackTxCount.incrementAndGet();\n                rollbackCommit( thread, tx );\n            }\n            else\n            {\n                throw logAndReturn(\"TM error tx commit\",new IllegalStateException( \"Tx status is: \"\n                    + getTxStatusAsString( tx.getStatus() ) ));\n            }\n        }\n        finally\n        {\n            if ( hasAnyLocks )\n            {\n                finishHook.finishTransaction( tx.getEventIdentifier() );\n            }\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void init( XaDataSourceManager xaDsManagerToUse )\n    {\n        this.xaDsManager = xaDsManagerToUse;\n        txThreadMap = new ArrayMap<Thread,TransactionImpl>( 5, true, true );\n        logSwitcherFileName = txLogDir + separator + \"active_tx_log\";\n        txLog1FileName = \"tm_tx_log.1\";\n        txLog2FileName = \"tm_tx_log.2\";\n        try\n        {\n            if ( new File( logSwitcherFileName ).exists() )\n            {\n                FileChannel fc = new RandomAccessFile( logSwitcherFileName,\n                    \"rw\" ).getChannel();\n                byte fileName[] = new byte[256];\n                ByteBuffer buf = ByteBuffer.wrap( fileName );\n                fc.read( buf );\n                fc.close();\n                String currentTxLog = txLogDir + separator\n                    + UTF8.decode( fileName ).trim();\n                if ( !new File( currentTxLog ).exists() )\n                {\n                    throw new TransactionFailureException(\n                        \"Unable to start TM, \" + \"active tx log file[\" +\n                        currentTxLog + \"] not found.\" );\n                }\n                txLog = new TxLog( currentTxLog );\n                msgLog.logMessage( \"TM opening log: \" + currentTxLog, true );\n            }\n            else\n            {\n                if ( new File( txLogDir + separator + txLog1FileName ).exists()\n                    || new File( txLogDir + separator + txLog2FileName )\n                        .exists() )\n                {\n                    throw new TransactionFailureException(\n                        \"Unable to start TM, \"\n                        + \"no active tx log file found but found either \"\n                        + txLog1FileName + \" or \" + txLog2FileName\n                        + \" file, please set one of them as active or \"\n                        + \"remove them.\" );\n                }\n                ByteBuffer buf = ByteBuffer.wrap( txLog1FileName\n                    .getBytes( \"UTF-8\" ) );\n                FileChannel fc = new RandomAccessFile( logSwitcherFileName,\n                    \"rw\" ).getChannel();\n                fc.write( buf );\n                txLog = new TxLog( txLogDir + separator + txLog1FileName );\n                msgLog.logMessage( \"TM new log: \" + txLog1FileName, true );\n                fc.force( true );\n                fc.close();\n            }\n            Iterator<List<TxLog.Record>> danglingRecordList =\n                txLog.getDanglingRecords();\n            if ( danglingRecordList.hasNext() )\n            {\n                log.info( \"Unresolved transactions found, \" +\n                    \"recovery started ...\" );\n                recover( danglingRecordList );\n                log.info( \"Recovery completed, all transactions have been \" +\n                    \"resolved to a consistent state.\" );\n                msgLog.logMessage( \"Recovery completed, all transactions have been \" +\n                    \"resolved to a consistent state.\" );\n            }\n            getTxLog().truncate();\n            tmOk = true;\n        }\n        catch ( IOException e )\n        {\n            log.log( Level.SEVERE, \"Unable to start TM\", e );\n            throw new TransactionFailureException( \"Unable to start TM\", e );\n        }\n    }","id":51920,"modified_method":"@Override\n    public void init( XaDataSourceManager xaDsManagerToUse )\n    {\n        this.xaDsManager = xaDsManagerToUse;\n        txThreadMap = new ArrayMap<Thread,TransactionImpl>( 5, true, true );\n        logSwitcherFileName = txLogDir + separator + \"active_tx_log\";\n        txLog1FileName = \"tm_tx_log.1\";\n        txLog2FileName = \"tm_tx_log.2\";\n        try\n        {\n            if ( new File( logSwitcherFileName ).exists() )\n            {\n                FileChannel fc = new RandomAccessFile( logSwitcherFileName,\n                    \"rw\" ).getChannel();\n                byte fileName[] = new byte[256];\n                ByteBuffer buf = ByteBuffer.wrap( fileName );\n                fc.read( buf );\n                fc.close();\n                String currentTxLog = txLogDir + separator\n                    + UTF8.decode( fileName ).trim();\n                if ( !new File( currentTxLog ).exists() )\n                {\n                    throw logAndReturn(\"TM startup failure\",\n                            new TransactionFailureException(\n                                    \"Unable to start TM, \" + \"active tx log file[\" +\n                                            currentTxLog + \"] not found.\"));\n                }\n                txLog = new TxLog( currentTxLog );\n                msgLog.logMessage( \"TM opening log: \" + currentTxLog, true );\n            }\n            else\n            {\n                if ( new File( txLogDir + separator + txLog1FileName ).exists()\n                    || new File( txLogDir + separator + txLog2FileName )\n                        .exists() )\n                {\n                    throw logAndReturn(\"TM startup failure\",\n                            new TransactionFailureException(\n                                    \"Unable to start TM, \"\n                                            + \"no active tx log file found but found either \"\n                                            + txLog1FileName + \" or \" + txLog2FileName\n                                            + \" file, please set one of them as active or \"\n                                            + \"remove them.\"));\n                }\n                ByteBuffer buf = ByteBuffer.wrap( txLog1FileName\n                    .getBytes( \"UTF-8\" ) );\n                FileChannel fc = new RandomAccessFile( logSwitcherFileName,\n                    \"rw\" ).getChannel();\n                fc.write( buf );\n                txLog = new TxLog( txLogDir + separator + txLog1FileName );\n                msgLog.logMessage( \"TM new log: \" + txLog1FileName, true );\n                fc.force( true );\n                fc.close();\n            }\n            Iterator<List<TxLog.Record>> danglingRecordList =\n                txLog.getDanglingRecords();\n            if ( danglingRecordList.hasNext() )\n            {\n                log.info( \"Unresolved transactions found, \" +\n                    \"recovery started ...\" );\n                recover( danglingRecordList );\n                log.info( \"Recovery completed, all transactions have been \" +\n                    \"resolved to a consistent state.\" );\n                msgLog.logMessage( \"Recovery completed, all transactions have been \" +\n                    \"resolved to a consistent state.\" );\n            }\n            getTxLog().truncate();\n            tmOk = true;\n        }\n        catch ( IOException e )\n        {\n            log.log(Level.SEVERE, \"Unable to start TM\", e);\n            throw logAndReturn(\"TM startup failure\",\n                    new TransactionFailureException(\"Unable to start TM\", e));\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void resume( Transaction tx ) throws IllegalStateException,\n        SystemException\n    {\n        if ( !tmOk )\n        {\n            throw new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" );\n        }\n        Thread thread = Thread.currentThread();\n        if ( txThreadMap.get( thread ) != null )\n        {\n            throw new IllegalStateException( \"Transaction already associated\" );\n        }\n        if ( tx != null )\n        {\n            TransactionImpl txImpl = (TransactionImpl) tx;\n            if ( txImpl.getStatus() != Status.STATUS_NO_TRANSACTION )\n            {\n                txImpl.markAsActive();\n                txThreadMap.put( thread, txImpl );\n            }\n            // generate pro-active event resume\n        }\n    }","id":51921,"modified_method":"public void resume( Transaction tx ) throws IllegalStateException,\n        SystemException\n    {\n        if ( !tmOk )\n        {\n            throw logAndReturn(\"TM error tx resume\",new SystemException( \"TM has encountered some problem, \"\n                + \"please perform neccesary action (tx recovery/restart)\" ));\n        }\n        Thread thread = Thread.currentThread();\n        if ( txThreadMap.get( thread ) != null )\n        {\n            throw new IllegalStateException( \"Transaction already associated\" );\n        }\n        if ( tx != null )\n        {\n            TransactionImpl txImpl = (TransactionImpl) tx;\n            if ( txImpl.getStatus() != Status.STATUS_NO_TRANSACTION )\n            {\n                txImpl.markAsActive();\n                txThreadMap.put( thread, txImpl );\n            }\n            // generate pro-active event resume\n        }\n    }","commit_id":"0820ce6cfb5a8615ed805b189f33a10018cfd622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void initializePlugins() {\n    try {\n      // Get all model services.\n      Object svcObj=null;\n      ServiceReference refs[] = m_context.getServiceReferences(Plugin.class.getName(), null);\n      if (refs != null) {\n        // Add model services to list, ignore duplicates.\n        for (int i = 0; i < refs.length; i++) {\n          svcObj = m_context.getService(refs[i]);\n          if (!m_pluginList.contains(svcObj)) {\n            m_pluginList.add(svcObj);\n            firePropertyChangedEvent(Plugin.PLUGIN_ADDED, null, (Plugin)svcObj);\n          }\n        }\n      }\n      // Get all common plugins\n      refs = m_context.getServiceReferences(CommonPlugin.class.getName(), null);\n      if (refs != null) {\n        for (int i = 0; i < refs.length; i++) {\n          svcObj = m_context.getService(refs[i]);\n          if (!m_commonpluginList.contains(svcObj)) {\n            m_commonpluginList.add(svcObj);\n            firePropertyChangedEvent(CommonPlugin.COMMON_PLUGIN_ADDED, null, (CommonPlugin)svcObj);\n          }\n        }\n      }\n    } catch (Exception ex) {\n      System.err.println(\"ShellGuiActivator: Error initializing model list.\");\n      System.err.println(\"ShellGuiActivator: \" + ex);\n      ex.printStackTrace();\n    }\n  }","id":51922,"modified_method":"private synchronized void initializePlugins() { // Never used ?\n    System.out.println(\"??? private synchronized void initializePlugins() ???\");\n    try {\n      // Get all model services.\n      Object svcObj=null;\n      ServiceReference refs[] = m_context.getServiceReferences(Plugin.class.getName(), null);\n      if (refs != null) {\n        // Add model services to list, ignore duplicates.\n        for (int i = 0; i < refs.length; i++) {\n          svcObj = m_context.getService(refs[i]);\n          if (!m_pluginList.contains(svcObj)) {\n            m_pluginList.add(svcObj);\n            firePropertyChangedEvent(Plugin.PLUGIN_ADDED, null, (Plugin)svcObj);\n\t    //this.nodesTree.valueChanged(null);\n          }\n        }\n      }\n      // Get all common plugins\n      refs = m_context.getServiceReferences(CommonPlugin.class.getName(), null);\n      if (refs != null) {\n        for (int i = 0; i < refs.length; i++) {\n          svcObj = m_context.getService(refs[i]);\n          if (!m_commonpluginList.contains(svcObj)) {\n            m_commonpluginList.add(svcObj);\n            firePropertyChangedEvent(CommonPlugin.COMMON_PLUGIN_ADDED, null, (CommonPlugin)svcObj);\n\t    //this.nodesTree.valueChanged(null);\n          }\n        }\n      }\n    } catch (Exception ex) {\n      System.err.println(\"ShellGuiActivator: Error initializing model list.\");\n      System.err.println(\"ShellGuiActivator: \" + ex);\n      ex.printStackTrace();\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,\n  \t\t\t\t\t\t boolean hasFocus, int row, int column) {\n    setOpaque(true);\n    if (column==0){\n      Integer state;\n      try{\n        state=new Integer(Integer.parseInt((String) table.getValueAt(row,5)));\n      }catch (NumberFormatException nfe) {\n        state=new Integer(-1);\n      }\n      setBackground((Color) eventName.get(state));\n    }\n    setText((String) value);\n\n    return this;\n  }","id":51923,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    setOpaque(true);\n    if (column==0){\n      Integer state;\n      try{\n        state=new Integer(Integer.parseInt((String) table.getValueAt(row,5)));\n      }catch (NumberFormatException nfe) {\n        state=new Integer(-1);\n      }\n      if (((String) value).equals(\"??/??/??\")) {\n\tsetBackground(Color.white);\n      } else{\n\tsetBackground((Color) eventName.get(state));\n      }\n    }\n    setText((String) value);\n\n    return this;\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public JtreeCellRenderer(BundleContext bdlCtx){\n    for (int i=0 ; i<states.length ; i++){\n      this.ii[i]=new ImageIcon(Toolkit.getDefaultToolkit().getImage(bdlCtx.getBundle().getResource(\"icons/\"+states[i]+\".gif\")));\n    }\n  }","id":51924,"modified_method":"public JtreeCellRenderer(BundleContext bdlCtx){\n    for (int i=0 ; i<states.length ; i++){\n      this.ii[i]=new ImageIcon(Toolkit.getDefaultToolkit().getImage(bdlCtx.getBundle().getResource(\"icons/\"+states[i]+\".gif\")));\n    }\n    this.iiOldLog=new ImageIcon(Toolkit.getDefaultToolkit().getImage(bdlCtx.getBundle().getResource(\"icons/OLDLOG.gif\")));\n\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    this.isLeaf=leaf;\n\n    super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);\n    setOpaque(true);\n    setBackground(Color.white);\n    setFont(new Font(\"Monospaced\",Font.BOLD,12));\n\n    StringTokenizer st=null;\n    DefaultMutableTreeNode dmtn=(DefaultMutableTreeNode)value;\n    int lvl=dmtn.getLevel(); \n    if(lvl==3 & dmtn.getChildCount()>0){\n      st=new StringTokenizer(dmtn.getFirstChild().toString(),\" | \");\n    }\n    if (lvl==4){\n      st=new StringTokenizer(dmtn.toString(),\" | \");\n    }\n\n    if(st!=null){\n      st.nextToken();\n      st.nextToken();\n      String state=st.nextToken();\n      for (int i=0 ; i<states.length ; i++){\n        if (state.equals(states[i])){\n          if (lvl==4){\n            setIcon(ii[i]);\n\t    setFont(new Font(\"Monospaced\",Font.PLAIN,10));\n          }else{ \n            StringTokenizer st2 = new StringTokenizer(((DefaultMutableTreeNode)dmtn.getFirstChild()).toString(),\" | \");\n            setToolTipText(\"<html><B>IP = <\/B>\"+/*IP=<ip> Profil=<port>/<profil>*/dmtn.getParent().getParent()+\"<B> Profil =<\/B>\"+dmtn.getParent()+\"<br><B>Bundle : <\/B>\"+/*Bundle : Id=<bundleId> : <bundleSymbolicName>*/dmtn+\"<br><B>Date : <\/B>\"+/*<date> - <time>*/st2.nextToken()+\" - \"+st2.nextToken()+\"<br><B>State : <\/B>\"+/*<bundleState>*/st2.nextToken()+\"<B><br>Event \"+/*Event <eventNumber> : <logLevel> : <message>*/dmtn.getChildCount()+\" : \"+st2.nextToken()+\" : \"+st2.nextToken()+\"<\/B><\/html>\");\n            setBackground(colors[i]);\n          }\n\tbreak;\n        }\n      }\n    }\t\n\t\n    return this;\n  }","id":51925,"modified_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    this.isLeaf=leaf;\n\n    super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);\n    setOpaque(true);\n    setBackground(Color.white);\n    setFont(new Font(\"Monospaced\",Font.BOLD,12));\n    setToolTipText(null);\n\n    StringTokenizer st=null;\n    DefaultMutableTreeNode dmtn=(DefaultMutableTreeNode)value;\n    int lvl=dmtn.getLevel(); \n    if(lvl==3 & dmtn.getChildCount()>0){\n      st=new StringTokenizer(dmtn.getFirstChild().toString(),\" | \");\n    }\n    if (lvl==4){\n      st=new StringTokenizer(dmtn.toString(),\" | \");\n    }\n\n    if(st!=null){\n      String date=st.nextToken();\n      st.nextToken();\n      String state=st.nextToken();\n      for (int i=0 ; i<states.length ; i++){\n        if (state.equals(states[i])){\n          if (lvl==4){\n\t    if(!date.equals(\"??/??/??\")){\n\t      setIcon(ii[i]);\n\t    }else{\n\t      setIcon(iiOldLog);\n\t    }\n\t    setFont(new Font(\"Monospaced\",Font.PLAIN,10));\n          }else{ \n            StringTokenizer st2 = new StringTokenizer(((DefaultMutableTreeNode)dmtn.getFirstChild()).toString(),\" | \");\n            setToolTipText(\"<html><B>IP = <\/B>\"+/*IP=<ip> Profil=<port>/<profil>*/dmtn.getParent().getParent()+\"<B> Profil =<\/B>\"+dmtn.getParent()+\"<br><B>Bundle : <\/B>\"+/*Bundle : Id=<bundleId> : <bundleSymbolicName>*/dmtn+\"<br><B>Date : <\/B>\"+/*<date> - <time>*/st2.nextToken()+\" - \"+st2.nextToken()+\"<br><B>State : \"+/*<bundleState>*/st2.nextToken()+\"<br>Event \"+/*Event <eventNumber> : <logLevel> : <message>*/dmtn.getChildCount()+\" : \"+st2.nextToken()+\" : \"+st2.nextToken()+\"<\/B><\/html>\");\n            setBackground(colors[i]);\n          }\n\tbreak;\n        }\n      }\n    }\t\n\t\n    return this;\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void logged(LogEntry log){\n    String reg=new String(\":\");\n    StringBuffer message=new StringBuffer();\n    //System.out.print(\"mosgi.jmx.remotelogger : new log : \");\n\n    synchronized (logMutex){\n      try{\n        message.append(\"\"+log.getBundle().getBundleId());\n      }catch(NullPointerException e){\n        message.append(\"Unknown source\");\n      }\n     \n      String lSymbolicName=log.getBundle().getSymbolicName();\n      if(lSymbolicName != null){\n        message.append(reg+lSymbolicName);\n      }else {\n        message.append(reg+\"\\\"null\\\"\");\n      }\n\n      message.append(reg+log.getBundle().getState());\n\n      int lLevel=log.getLevel();\n      if(debugLogFlag && lLevel==LogService.LOG_DEBUG){\n        message.append(reg+\"DEBUG  \");\n      }else if (errorLogFlag && lLevel==LogService.LOG_ERROR){\n        message.append(reg+\"ERROR  \");\n      }else if(infoLogFlag && lLevel==LogService.LOG_INFO){\n        message.append(reg+\"INFO   \");\n      }else if(warningLogFlag && lLevel==LogService.LOG_WARNING){\n        message.append(reg+\"WARNING\");\n      }else {\n        message.append(reg+\"NOLEVEL\");\n      }\n\n      message.append(reg+log.getMessage());\n    }\n    //System.out.println(message.toString());\n    if (this.agent!=null){ // On envoie tous les logs a un MBeanServer\n      //System.out.println(\"this.agent != null => remoteLogger.Logger.sendNotifiaction(....\"+message.toString());\n      this.sendNotification(new  AttributeChangeNotification(this.remoteLoggerON, 0, \n\t\t\t\t\t\t             System.currentTimeMillis(),\n\t\t\t\t\t\t             message.toString(), null, \"Log\", null, null));\n    }\n  }","id":51926,"modified_method":"public void logged(LogEntry log){\n    logged(log, false);\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent event) {\n    if (event.getPropertyName().equals(Plugin.PLUGIN_ADDED)) {\n      Plugin cp = (Plugin) event.getNewValue();\n      this.add(cp.getName(), cp.getGUI());\nSystem.out.println(\"add gui \"+cp.getName()+\" :: \"+cp.getGUI());      \n      this.m_activator.addPropertyChangeListener(cp);\n      this.pluginList.put(cp.pluginLocation(), cp);\n      \n    }else if(event.getPropertyName().equals(Plugin.PLUGIN_REMOVED)) {\n      Plugin cp = (Plugin) event.getNewValue();\n      this.remove(cp.getGUI());\n      this.m_activator.removePropertyChangeListener(cp);\n//\t\t\tthis.pluginList.remove(cp.pluginLocation());\n      \n    }else if(event.getPropertyName().equals(Plugin.EMPTY_NODE)) {\nSystem.out.println(\"******* Debug No node selected\");\n      this.clean();\n    }else if (event.getPropertyName().equals(Plugin.NEW_NODE_SELECTED)) {\n//System.out.println(\"Event NEW_NODE_SELECTED\");\n    /* Update the tabs (Plugin) in the JTabbedPane (NodePanel) */\n      MBeanServerConnection mbsc = (MBeanServerConnection)event.getNewValue();\n      try {\n\tthis.clean();\n\n        Set ons = mbsc.queryNames( null, null );\n        for( Iterator i=ons.iterator(); i.hasNext(); ) {\n          ObjectName name = ( ObjectName )i.next();\nSystem.out.println(\"Queried name: \"+name.toString());\n          if ( \"TabUI\".equals(name.getDomain()) ) {\nSystem.out.println(\"New tab: \"+name.toString());\n\t    /* Get the plugin implementation via a bundle */\n\t    String tabBundle = (String) mbsc.getAttribute(name, \"BundleName\");\nSystem.out.println(\"Bundle name for current Plugin: \"+tabBundle);\n\t    if (tabBundle!=null){\n              Plugin p = (Plugin) this.pluginList.get(tabBundle);\n              if (p == null){\n  \t          Bundle b = m_context.installBundle(tabBundle);\n\t\t  b.start();\nSystem.out.println(\"Bundle started\");\n//Thread.sleep(5000);\n               }else{\nSystem.out.println(\"register service plugin: \" + p);\n                 p.registerServicePlugin();\n               }\n\n//             ServiceReference[] sr = b.getRegisteredServices();\n//             System.out.println(sr);\n//             Plugin p;\n//             for (int j=0 ; j < sr.length ; j++) {\n//               p=(Plugin)m_context.getService(sr[j]);\n//               this.add(p.getName(), p.getGUI());\n//               this.m_activator.addPropertyChangeListener(p);\n//             }\n\n//               System.out.println(\"Delegation for this\");\n//               printcl = this.getClass().getClassLoader();\n//               while (printcl != null) {\n//                 System.out.println(printcl);\n//                 printcl = printcl.getParent();\n//               }\n//               System.out.println(\"{bootstrap loader}\");\n//               System.out.println(\"\");\n\n\t\t\t\t\t/* Get the tab object */\n//             Object tabObj = mbsc.getAttribute(name, \"Tab\");\n// \n//               System.out.println(\"Delegation for tabObj: \" + tabObj);\n//               printcl = tabObj.getClass().getClassLoader();\n//               while (printcl != null) {\n//                 System.out.println(printcl);\n//                 printcl = printcl.getParent();\n//               }\n//               System.out.println(\"{bootstrap loader}\");\n//               System.out.println(\"\");\n  \n//          System.out.println(\"tabObj.getName(): \" + ((fr.inria.ares.managedelements.testprobe.tab.TestProbeTabUI) tabObj).getName());\n              \n          /* Cast the tab */  \n//            Plugin tab = (Plugin)tabObj;\n          /* register the tab on the JTabbedPane */\n//            this.add(tab.getName(), tab.getGUI());\n            }else{\n\t      System.out.println(\"No \"+tabBundle+\" property defined. I cannot install \"+tabBundle+\" tab\");\n            }\n          }\n        }\n        m_activator.firePropertyChangedEvent(Plugin.NEW_NODE_READY, null, mbsc);\n        m_activator.firePropertyChangedEvent(Plugin.PLUGIN_ACTIVATED, null, this.getComponentAt(0).getName());\n\n\n      } catch (MBeanException e) {\n          System.err.println(e);\n//        } catch (MalformedObjectNameException e) {\n//          System.err.println(e);\n      } catch (AttributeNotFoundException e) {\n        System.err.println(e);\n      } catch (InstanceNotFoundException e) {\n        System.err.println(e);\n      } catch (ReflectionException e) {\n        System.err.println(e);\n      } catch (IOException e) {\n        System.err.println(e);\n      } catch (BundleException e) {\n        System.err.println(e);\n      }\n      \n//       catch (java.lang.InterruptedException e) {\n// \t      System.err.println(e);\n//       }\n    }\n  }","id":51927,"modified_method":"public void propertyChange(PropertyChangeEvent event) {\n    if (event.getPropertyName().equals(Plugin.PLUGIN_ADDED)) {\n      Plugin cp=(Plugin) event.getNewValue();\n      this.add(cp.getName(), cp.getGUI());\n      System.out.println(\"Add gui \\\"\"+cp.getName()+\"\\\" into NodePanel\"/*+\" :: \"+cp.getGUI()*/);      \n      this.a.addPropertyChangeListener(cp);\n      this.pluginList.put(cp.pluginLocation(), cp); \n    }else if(event.getPropertyName().equals(Plugin.PLUGIN_REMOVED)) {\n      Plugin cp = (Plugin) event.getNewValue();\n      this.remove(cp.getGUI());\n      this.a.removePropertyChangeListener(cp);\n      //\tthis.pluginList.remove(cp.pluginLocation());\n    }else if(event.getPropertyName().equals(Plugin.EMPTY_NODE)) {\n      System.out.println(\"******* Debug No node selected\");\n      this.clean();\n    }else if (event.getPropertyName().equals(Plugin.NEW_NODE_SELECTED)) {\n      //System.out.println(\"Event NEW_NODE_SELECTED\");\n      /* Update the tabs (Plugin) in the JTabbedPane (NodePanel) */\n      MBeanServerConnection mbsc = (MBeanServerConnection)event.getNewValue();\n      try {\n\tthis.clean();\n        Set ons = mbsc.queryNames( null, null );\n        String msg=\"\";\n        for( Iterator i=ons.iterator(); i.hasNext(); ) {\n\t  ObjectName name = ( ObjectName )i.next();\n          msg=\"Queried name: \"+name.toString();\n          if ( \"TabUI\".equals(name.getDomain()) ) {\n            msg+=\" New tab: \"+name.toString();\n\t    /* Get the plugin implementation via a bundle */\n\t    String tabBundle = (String) mbsc.getAttribute(name, \"BundleName\");\n            msg+=\" Bundle name for current Plugin: \"+tabBundle;\n\t    if (tabBundle!=null){\n              Plugin p = (Plugin) this.pluginList.get(tabBundle);\n              if (p == null){\n  \t          Bundle b = m_context.installBundle(tabBundle);\n\t\t  b.start();\n                  System.out.println(msg+\" Bundle started\");\n                  //Thread.sleep(5000);\n              }else{\n                System.out.println(msg+\" Register service plugin: \" + p);\n                p.registerServicePlugin();\n              }\n\n//            ServiceReference[] sr = b.getRegisteredServices();\n//            System.out.println(sr);\n//            Plugin p;\n//            for (int j=0 ; j < sr.length ; j++) {\n//              p=(Plugin)m_context.getService(sr[j]);\n//              this.add(p.getName(), p.getGUI());\n//              this.a.addPropertyChangeListener(p);\n//            }\n\n//            System.out.println(\"Delegation for this\");\n//            printcl = this.getClass().getClassLoader();\n//            while (printcl != null) {\n//              System.out.println(printcl);\n//              printcl = printcl.getParent();\n//            }\n//            System.out.println(\"{bootstrap loader}\");\n//            System.out.println(\"\");\n\n              /* Get the tab object */\n//            Object tabObj = mbsc.getAttribute(name, \"Tab\");\n// \n//            System.out.println(\"Delegation for tabObj: \" + tabObj);\n//            printcl = tabObj.getClass().getClassLoader();\n//            while (printcl != null) {\n//              System.out.println(printcl);\n//              printcl = printcl.getParent();\n//            }\n//            System.out.println(\"{bootstrap loader}\");\n//            System.out.println(\"\");\n  \n//            System.out.println(\"tabObj.getName(): \" + ((fr.inria.ares.managedelements.testprobe.tab.TestProbeTabUI) tabObj).getName());\n              \n              /* Cast the tab */  \n//            Plugin tab = (Plugin)tabObj;\n              /* register the tab on the JTabbedPane */\n//            this.add(tab.getName(), tab.getGUI());\n            }else{\n\t      System.out.println(msg+\" No \"+tabBundle+\" property defined. I cannot install \"+tabBundle+\" tab\");\n            }\n          }\n        }\n        a.firePropertyChangedEvent(Plugin.NEW_NODE_READY, null, mbsc);\n        a.firePropertyChangedEvent(Plugin.PLUGIN_ACTIVATED, null, this.getComponentAt(0).getName());\n\n      } catch (MBeanException e) {\n        System.err.println(\"MBeanException : \"+e);\n//    } catch (MalformedObjectNameException e) {\n//      System.err.println(e);\n      } catch (AttributeNotFoundException e) {\n        System.err.println(\"AttributeNotFoundException : \"+e);\n      } catch (InstanceNotFoundException e) {\n        System.err.println(\"InstanceNotFoundException : \"+e);\n      } catch (ReflectionException e) {\n        System.err.println(\"ReflectionException : \"+e);\n      } catch (IOException e) {\n        System.err.println(\"IOException : \"+e);\n      } catch (BundleException e) {\n        System.err.println(\"BundleException : \"+e);\n      } catch (Exception e) {\n        System.err.println(\"Exception : \"+e);\n      }\n//    } catch (java.lang.InterruptedException e) {\n//      System.err.println(e);\n//    }\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public NodePanel(Activator activator, BundleContext context){\n    m_context = context;\n    m_activator = activator;\n    m_activator.addPropertyChangeListener(this);\n    this.pluginList = new Hashtable();\n    //repo = m_context.getProperty(\"mosgi.jmxconsole.repository\");\n    this.addChangeListener(this);\n  }","id":51928,"modified_method":"public NodePanel(Activator activator, BundleContext context){\n    this.m_context=context;\n    this.a=activator;\n    a.addPropertyChangeListener(this);\n    this.pluginList=new Hashtable();\n    //repo = m_context.getProperty(\"mosgi.jmxconsole.repository\");\n    this.addChangeListener(this);\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void stateChanged(ChangeEvent e){\n//   System.out.println(\"coucou => \"+((JTabbedPane)e.getSource()).getSelectedIndex()+\":\"+((JTabbedPane)e.getSource()).getSelectedComponent().getName());\n   if (this.getSelectedComponent()!=null){\n     m_activator.firePropertyChangedEvent(Plugin.PLUGIN_ACTIVATED, null, this.getSelectedComponent().getName());\n   }\n  }","id":51929,"modified_method":"public void stateChanged(ChangeEvent e){\n    //   System.out.println(\"coucou => \"+((JTabbedPane)e.getSource()).getSelectedIndex()+\":\"+((JTabbedPane)e.getSource()).getSelectedComponent().getName());\n    if (this.getSelectedComponent()!=null){\n      a.firePropertyChangedEvent(Plugin.PLUGIN_ACTIVATED, null, this.getSelectedComponent().getName());\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"protected void createDefaultNodes(boolean createTreeNode) {\n    String profile;\n    String rmiPort;\n    String ip;\n    \n    int i=1;\n    profile=bc.getProperty(\"mosgi.jmxconsole.profile.\" + i);\n\n    while (profile!=null){\n      rmiPort=bc.getProperty(\"mosgi.jmxconsole.rmiport.\"+profile);\n      if (rmiPort==null){rmiPort=\"1099\";}\n      String virtual=bc.getProperty(\"mosgi.jmxconsole.core.\"+profile);\n      ip=bc.getProperty(\"mosgi.jmxconsole.ip.\" + i);\n      String connString=ip+\":\"+rmiPort+\"/\"+profile;\n      if (createTreeNode){\n        DefaultMutableTreeNode dmtn=new DefaultMutableTreeNode(connString);\n        DefaultMutableTreeNode parent=top;\n        if (virtual==null){\n          nodes.put(connString, dmtn);\n        }else{\n          String parentString=ip+\":\"+virtual;\n          parent=(DefaultMutableTreeNode)nodes.get(parentString);\n        }\n        parent.add(dmtn);\n      }\n      this.connectToNode(connString);\n      i++;\n      profile=bc.getProperty(\"mosgi.jmxconsole.profile.\" + i);\n    }\n      \n    if (i==1){\n      try{\n        System.out.println(\"No property mosgi.jmxconsole.profile., managing local profile\");\n\t\tString prof=bc.getProperty(BundleCache.CACHE_PROFILE_PROP);\n    \tif (prof==null){\n\t      prof=System.getProperty(BundleCache.CACHE_PROFILE_PROP);\n\t\t}\n        String connString=java.net.InetAddress.getLocalHost().getHostAddress()+\":1099/\"+prof;\n        if (createTreeNode){\n          top.add(new DefaultMutableTreeNode(connString));\n        }\n//        this.connectToNode(connString);\n      }catch(Exception e){\n        e.printStackTrace();\n      }\n    }\n  }","id":51930,"modified_method":"protected void createDefaultNodes() {\n    String profile;\n    String rmiPort;\n    String ip;\n    int i=1;\n    profile=bc.getProperty(\"mosgi.jmxconsole.profile.\" + i);\n\n    while (profile!=null){\n      rmiPort=bc.getProperty(\"mosgi.jmxconsole.rmiport.\"+profile);\n      if (rmiPort==null) {rmiPort=\"1099\";}\n      String virtual=bc.getProperty(\"mosgi.jmxconsole.core.\"+profile);\n      ip=bc.getProperty(\"mosgi.jmxconsole.ip.\"+i);\n      String connString=ip+\":\"+rmiPort+\"/\"+profile;\n      createTreeNode(connString, ip, virtual);\n      i++;\n      profile=bc.getProperty(\"mosgi.jmxconsole.profile.\" + i);\n    }\n\n    // Kesako ???\n    if (i==1){\n      try{\n        System.out.println(\"No property mosgi.jmxconsole.profile., managing local profile\");\n\tString prof=bc.getProperty(BundleCache.CACHE_PROFILE_PROP);\n    \tif (prof==null){\n\t  prof=System.getProperty(BundleCache.CACHE_PROFILE_PROP);\n\t}\n        String connString=java.net.InetAddress.getLocalHost().getHostAddress()+\":1099/\"+prof;\n        top.add(new DefaultMutableTreeNode(connString));\n      }catch(Exception e){\n        e.printStackTrace();\n      }\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n//    System.out.println(\"Connection ==> \"+notification.getMessage()+\":\"+((JMXConnectionNotification)notification).getConnectionId()+\":\"+handback);\n    if ( !JMXConnectionNotification.OPENED.equals(notification.getType()) ){\n      this.disconnectFromNode((String)handback);\n      tree.treeDidChange();\n    }\n  }","id":51931,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    //    System.out.println(\"Connection ==> \"+notification.getMessage()+\":\"+((JMXConnectionNotification)notification).getConnectionId()+\":\"+handback);\n    if ( !JMXConnectionNotification.OPENED.equals(notification.getType()) ){\n      this.disconnectFromNode((String)handback);\n      tree.treeDidChange();\n      isAllNodesConnected=false;\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void runDiscovery(){\n\tthis.createDefaultNodes(true);\n    poolThread=new Thread(this.pt);\n    poolThread.start();\n  }","id":51932,"modified_method":"public void runDiscovery(){\n    this.createDefaultNodes();\n    poolThread=new Thread(this.pt);\n    poolThread.start();\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public NodesTree(Activator a,BundleContext bc) {\n\t\tsuper(new GridLayout(1, 0));\n    this.a=a;\n    this.bc=bc;\n    this.pt=new PoolingThread();\n    \n\t\tSystem.setProperty(\"java.security.policy\", \"client.policy\");\n\t\ttop = new DefaultMutableTreeNode(NodesTree.TOP_NAME);\n    dtm=new DefaultTreeModel(top);\n\t\ttree = new JTree(dtm);\n    tree.setCellRenderer(ncr=new NodeCellRenderer(bc,this));\n\t\ttree.addTreeSelectionListener(this);\n\t\ttree.getSelectionModel().setSelectionMode(\n\t\t\t\tTreeSelectionModel.SINGLE_TREE_SELECTION);\n\n\t\tJScrollPane treeView = new JScrollPane(tree);\n\t\tadd(treeView);\n\t}","id":51933,"modified_method":"public NodesTree(Activator a,BundleContext bc) {\n    super(new BorderLayout());\n    //super(new GridLayout(1, 0));\n    this.a=a;\n    this.bc=bc;\n    this.pt=new PoolingThread();\n    \n    System.setProperty(\"java.security.policy\", \"client.policy\");\n    top=new DefaultMutableTreeNode(NodesTree.TOP_NAME);\n    dtm=new DefaultTreeModel(top);\n    tree=new JTree(dtm);\n    tree.setCellRenderer(ncr=new NodeCellRenderer(bc,this));\n    tree.addTreeSelectionListener(this);\n    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    JScrollPane treeView=new JScrollPane(tree);\n    add(createButtonPanel(), BorderLayout.NORTH);\n    add(treeView, BorderLayout.CENTER);\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"private void disconnectFromNode(String connString){\n    JMXConnector jmxc=(JMXConnector)this.jmxConnectors.remove(connString);\n    MBeanServerConnection mbscl=(MBeanServerConnection)this.connectedNodes.remove(connString);\n    try{\n      jmxc.removeConnectionNotificationListener(this);\n      //mbscl.removeNotificationListener(new ObjectName(\"OSGI:name=OSGi\n      // Server\"), this); // Does not work since the connexion is lost !!\n      jmxc.close();\n      a.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n    }catch (Exception e){\n      e.printStackTrace();\n    }\n    jmxc=null;\n    mbscl=null;\n  }","id":51934,"modified_method":"private void disconnectFromNode(String connString){\n    JMXConnector jmxc=(JMXConnector)this.jmxConnectors.remove(connString);\n    MBeanServerConnection mbscl=(MBeanServerConnection)this.connectedNodes.remove(connString);\n    System.out.println(\"mbscl=\"+mbscl);\n    if (jmxc!=null) {\n      try{\n        jmxc.removeConnectionNotificationListener(this);\n        //mbscl.removeNotificationListener(new ObjectName(\"OSGI:name=OSGi\n        // Server\"), this); // Does not work since the connexion is lost !!\n        jmxc.close();\n\n        // firePCE Plugin.EMPTY_NODE only if it's the selected one\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent(); \n        if (node!=null) {\n\t  if (connString.equals((String)node.getUserObject())){\n            a.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n\t  }\n        }\n      }catch (Exception e){\n        e.printStackTrace();\n      }\n      jmxc=null;\n    }\n    mbscl=null;\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"private void connectToNode(String connString){\n    Object ls=this.connectedNodes.get(connString);\n    if (ls==null){\n      JMXConnector jmxc = null;\n      try {\n\n        JMXServiceURL surl = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://\" + connString);\n/*\nThread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\nSystem.out.println(\"=====> \"+java.util.logging.Logger.getLogger(\"javax.management.remote.misc\"));\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").setLevel(java.util.logging.Level.FINEST);\n\njava.util.logging.ConsoleHandler ch=new java.util.logging.ConsoleHandler();\nch.setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").addHandler(ch);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").addHandler(ch);\n*/\n\t\t\t\t\n        jmxc = JMXConnectorFactory.connect(surl);\n        MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n        if (mbsc.isRegistered(new ObjectName(\"OSGI:name=Remote Logger\"))){\n          jmxc.addConnectionNotificationListener(this, null, connString);\n          mbsc.addNotificationListener(new ObjectName(\"TabUI:name=OsgiProbes\"), this, null, null); //Needed,\n\n          this.connectedNodes.put(connString, mbsc);\n          this.jmxConnectors.put(connString, jmxc);\n          a.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, connString, mbsc);\n System.out.println(\"Node \"+connString+\" connected\");\n        }else {\nSystem.out.println(\"The Remote Logger of \"+connString+\" is not started\");\n        }\n      }catch(java.io.IOException ex){\nSystem.out.println(\"Impossible to connect to \"+connString);\n      }catch(MalformedObjectNameException e){\n        e.printStackTrace();\n      }catch(Exception e){\n        e.printStackTrace();\n      }\n    }else{\n      a.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, connString, ls);\n    }\n  }","id":51935,"modified_method":"private boolean connectToNode(String connString){\n    Object ls=this.connectedNodes.get(connString);\n    if (ls==null){\n      JMXConnector jmxc=null;\n      try {\n        JMXServiceURL surl=new JMXServiceURL(NodesTree.JMX_SERVICE_URL+connString);\n/*\nThread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\nSystem.out.println(\"=====> \"+java.util.logging.Logger.getLogger(\"javax.management.remote.misc\"));\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").setLevel(java.util.logging.Level.FINEST);\n\njava.util.logging.ConsoleHandler ch=new java.util.logging.ConsoleHandler();\nch.setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").addHandler(ch);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").addHandler(ch);\n*/\t\t\t\t\n        jmxc = JMXConnectorFactory.connect(surl);\n        MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n        if (mbsc.isRegistered(new ObjectName(\"OSGI:name=Remote Logger\"))){\n          jmxc.addConnectionNotificationListener(this, null, connString);\n          mbsc.addNotificationListener(new ObjectName(\"TabUI:name=OsgiProbes\"), this, null, null); //Needed ???\n          this.connectedNodes.put(connString, mbsc);\n          this.jmxConnectors.put(connString, jmxc);\n          a.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, connString, mbsc);\n\t  // If new connected is the selected one then create a false valueChanged in order to load the NodePanel :\n\t  DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent(); \n\t  if (node!=null) {\n  \t    if (connString.equals((String)node.getUserObject())){\n\t      this.valueChanged(null);\n            }\n\t  }\n\t  System.out.println(\"Node \"+connString+\" connected\");\n\t  return true;\n        }else {\n          System.out.println(\"The Remote Logger of \"+connString+\" is not started\");\n\t  return false;\n        }\n      }catch(java.io.IOException ex){\n        //System.out.println(\"Impossible to connect to \"+connString);\n      }catch(MalformedObjectNameException e){\n        e.printStackTrace();\n      }catch(Exception e){\n        //e.printStackTrace();\n\tSystem.out.println(\"gui.NodesTree.connectToNode(\"+connString+\") : \"+e);\n\tSystem.out.println(\"  => Delete this node ? to implement... ?\");\n\n      }\n    }else{\n      // a.firePCE(NEW_NODE_CONNECTION, connString, ls) inutile maintenant je sais plus pourqouoi ca l'etait d'ailleur ???\n      return true;\n    }\n  return false;\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void run(){\n      while (cont){\n        createDefaultNodes(false);\n        tree.treeDidChange();\n        try{\n          Thread.sleep(POOLING_TIME);\n        }catch(InterruptedException e){\n          e.printStackTrace();\n        }\n      }\n    }","id":51936,"modified_method":"public void run(){\n      while (cont){\n        if (!isAllNodesConnected) {\n\t  tryToConnectAllNodes();\n          tree.treeDidChange();\n        } \n\ttry{\n          Thread.sleep(POOLING_TIME);\n        }catch(InterruptedException e){\n          e.printStackTrace();\n        }\n      }\n    }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void valueChanged(TreeSelectionEvent e) {\n//    System.out.println(\"coucou, value changed\");\n\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n\t  String selectedNode=(String)node.getUserObject();\n    if (!selectedNode.equals(NodesTree.TOP_NAME)){\n      Object mbsc=connectedNodes.get(selectedNode);\n      if (mbsc!=null){\n        a.firePropertyChangedEvent(Plugin.NEW_NODE_SELECTED, selectedNode, mbsc);\n      }else{\n        a.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n      }\n    }\n\t}","id":51937,"modified_method":"public void valueChanged(TreeSelectionEvent e) {\n    //System.out.println(\"Value changed : e=\"+e);\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n    if (node!=null) {\n      String selectedNode=(String)node.getUserObject();\n      if (!selectedNode.equals(NodesTree.TOP_NAME)){\n        Object mbsc=connectedNodes.get(selectedNode);\n        if (mbsc!=null){\n\t  //tryToConnectAllNodes();\n\t  //createDefaultNodes(false);\n          a.firePropertyChangedEvent(Plugin.NEW_NODE_SELECTED, selectedNode, mbsc);\n        }else{\n          a.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n        }\n      }\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st = new StringTokenizer(notification.getMessage(),\":\");\n    Date d=new Date(notification.getTimeStamp());\n    //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n    DateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM); // utilise le format de date local\n    DateFormat df2 = DateFormat.getDateInstance(DateFormat.SHORT);\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String shortName=name.substring(name.lastIndexOf(\".\")+1,name.length());\n    String state=st.nextToken();\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    Object [] event = new Object []{df2.format(d),df.format(d),handback,id,shortName,state,lvl,msg};\n\t\t\t\t    \n    this.insertRow(0,event); \n    this.fireTableRowsInserted(0, 0);\n  }","id":51938,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st = new StringTokenizer(notification.getMessage(),\"*\");\n    \n    long ts=notification.getTimeStamp();\n    String date=\"??/??/??\";\n    String time=\"??/??/??\";\n    if (ts!=0){ // means it's not an old log\n      Date d=new Date(ts);\n      //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n      date=DateFormat.getDateInstance(DateFormat.SHORT).format(d);\n      time=DateFormat.getTimeInstance(DateFormat.MEDIUM).format(d);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String shortName=name.substring(name.lastIndexOf(\".\")+1,name.length());\n    String state=st.nextToken();\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    Object [] event = new Object []{date,time,handback,id,shortName,state,lvl,msg};\n\t\t\t\t    \n    this.insertRow(0,event); \n    this.fireTableRowsInserted(0, 0);\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent e){\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\n\t  System.out.println(\"Ajout d'un listener \" +mbs);\n          ((MBeanServerConnection)e.getNewValue()).addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","id":51939,"modified_method":"public void propertyChange(PropertyChangeEvent e){\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\n\t  //System.out.println(\"Ajout d'un listener \" +mbs);\n          ((MBeanServerConnection)e.getNewValue()).addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st=new StringTokenizer(handback.toString(),\":\");\n    String ip=st.nextToken();\n    String ref=st.nextToken();\n    \n    st = new StringTokenizer(notification.getMessage(),\":\");\n    Date timeDate=new Date(notification.getTimeStamp());\n    //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n    DateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM); // use local date format \n    DateFormat df2 = DateFormat.getDateInstance(DateFormat.SHORT);\n    String time=df.format(timeDate);\n    String date=df2.format(timeDate);\n\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String idname=new String(id+\" : \"+name);\n    String state=\"\"+eventName.get(new Integer((int) Integer.parseInt(st.nextToken())));\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n\n    // Get and maybe create parents nodes : ip, ref, idname\n    DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode);\n    DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip);\n    DefaultMutableTreeNode dmtn_idname=createIfNeed(idname, dmtn_ref);\n\n    // insert the leaf with message under id/ref/idname\n    DefaultMutableTreeNode dmtn=new DefaultMutableTreeNode(date+\" | \"+time+\" | \"+state+\" | \"+lvl+\" | \"+msg,false); \n    this.insertNodeInto(dmtn, dmtn_idname, 0);\n\n    this.reload(dmtn_idname);\n    }","id":51940,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st=new StringTokenizer(handback.toString(),\":\");\n    boolean isOldLog=false;\n    String ip=st.nextToken();\n    String ref=st.nextToken();\n    \n    st = new StringTokenizer(notification.getMessage(),\"*\");\n    long ts=notification.getTimeStamp();\n    String time=\"??:??:??\";\n    String date=\"??/??/??\";\n    if (ts==0) {\n      isOldLog=true;\n    }\n    if (!isOldLog){\n      Date timeDate=new Date(ts);\n      //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n      DateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM); // use local date format\n      DateFormat df2 = DateFormat.getDateInstance(DateFormat.SHORT);\n      time=df.format(timeDate);\n      date=df2.format(timeDate);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String idname=new String(id+\" : \"+name);\n    String state=\"\"+eventName.get(new Integer((int) Integer.parseInt(st.nextToken())));\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    // Get and maybe create parents nodes : ip, ref, idname\n    DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode, isOldLog);\n    DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip, isOldLog);\n    DefaultMutableTreeNode dmtn_idname=createIfNeed(idname, dmtn_ref, isOldLog);\n    // insert the leaf with message under id/ref/idname\n    DefaultMutableTreeNode dmtn=new DefaultMutableTreeNode(date+\" | \"+time+\" | \"+state+\" | \"+lvl+\" | \"+msg,false);\n    if (isOldLog){\n      this.insertNodeInto(dmtn, dmtn_idname, dmtn_idname.getChildCount());\n    } else{\n      this.insertNodeInto(dmtn, dmtn_idname, 0);\n    }\n    this.reload(dmtn_idname);\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"private DefaultMutableTreeNode createIfNeed(String nodeToCreateAndGet, DefaultMutableTreeNode parent){\n    int childNumber=this.getChildCount(parent);\n    DefaultMutableTreeNode theNode=null;\n    for (int i=0 ; i<childNumber ; i++){ // is node even exist ?\n      String string_pool=((DefaultMutableTreeNode)(this.getChild(parent, i))).toString();\n      if (string_pool.equals(nodeToCreateAndGet)){\n        theNode=(DefaultMutableTreeNode) (this.getChild(parent, i));\n          break;\n      }\n    }\n    if (theNode==null){ // create the node\n      theNode=new DefaultMutableTreeNode(nodeToCreateAndGet);\t\n      // Unable to set tree expand whithout a first node\n      if (rootNode.getChildCount()==0){\n        this.insertNodeInto(theNode, parent, 0);\n        logTree.expandPath(new TreePath(rootNode.getPath()));\n      }else{\n        this.insertNodeInto(theNode, parent, 0);\n      }\n    }\n  return theNode;\n  }","id":51941,"modified_method":"private DefaultMutableTreeNode createIfNeed(String nodeToCreateAndGet, DefaultMutableTreeNode parent, boolean isOldLog){\n    int childNumber=this.getChildCount(parent);\n    DefaultMutableTreeNode theNode=null;\n    for (int i=0 ; i<childNumber ; i++){ // is node even exist ?\n      String string_pool=((DefaultMutableTreeNode)(this.getChild(parent, i))).toString();\n      if (string_pool.equals(nodeToCreateAndGet)){\n        theNode=(DefaultMutableTreeNode) (this.getChild(parent, i));\n        break;\n      }\n    }\n    if (theNode==null){ // create the node\n      theNode=new DefaultMutableTreeNode(nodeToCreateAndGet);\n      // Unable to set tree expand whithout a first node:\n      if (rootNode.getChildCount()==0){\n        this.insertNodeInto(theNode, parent, 0);\n        logTree.expandPath(new TreePath(rootNode.getPath()));\n      } else{\n        if(isOldLog){\n          this.insertNodeInto(theNode, parent, parent.getChildCount());\n        } else {\n          this.insertNodeInto(theNode, parent, 0);\n        }\n      }\n    }\n    return theNode;\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public RemoteLogger_jtree (BundleContext bdlCtx){\n    super(null);\n    setRoot(rootNode);\n    System.out.println(\"JTree Remote logger\"); \n\n    this.jp=new JPanel();\n    this.jp.setLayout(new BorderLayout());\n   \n    this.logTree=new MyTree(this);\n    JtreeCellRenderer treeCellRenderer=new JtreeCellRenderer(bdlCtx);\n    this.logTree.setCellRenderer(treeCellRenderer);\n    this.logTree.setLargeModel(true);\n    this.logTree.setToggleClickCount(1); \n    this.logTree.setRootVisible(false);\n    // this create an invisible tree even if I use *expand* so...\n    // I use expand after the first insert into the tree\n  \n    jp.add(new JScrollPane(logTree), BorderLayout.CENTER);    \n    \n    eventName.put(new Integer(Bundle.ACTIVE),     \"ACTIVE     \");\n    eventName.put(new Integer(Bundle.INSTALLED),  \"INSTALLED  \");\n    eventName.put(new Integer(Bundle.RESOLVED),   \"RESOLVED   \");\n    eventName.put(new Integer(Bundle.STARTING),   \"STARTING   \");\n    eventName.put(new Integer(Bundle.STOPPING),   \"STOPPING   \");\n    eventName.put(new Integer(Bundle.UNINSTALLED),\"UNINSTALLED\");\n  }","id":51942,"modified_method":"public RemoteLogger_jtree (BundleContext bdlCtx){\n    super(null);\n    setRoot(rootNode);\n    System.out.println(\"JTree Remote logger\"); \n\n    this.jp=new JPanel();\n    this.jp.setLayout(new BorderLayout());\n   \n    this.logTree=new MyTree(this);\n    JtreeCellRenderer treeCellRenderer=new JtreeCellRenderer(bdlCtx);\n    this.logTree.setCellRenderer(treeCellRenderer);\n    this.logTree.setLargeModel(true);\n    this.logTree.setToggleClickCount(2); \n    this.logTree.setRootVisible(false);\n    // this create an invisible tree even if I use *expand* so...\n    // I use expand after the first insert into the tree\n\n    MouseListener ml = new MouseAdapter() {\n      public void mousePressed(MouseEvent e) {\n        int selRow = logTree.getRowForLocation(e.getX(), e.getY());\n        selPath = logTree.getPathForLocation(e.getX(), e.getY());\n        if(selRow != -1 & e.getButton()>1) {\n\t  String nodeString=\"\\\"\"+((DefaultMutableTreeNode) selPath.getLastPathComponent()).getUserObject()+\"\\\"\";\n\t  JMenuItem itemm=new JMenuItem(\"Delete logs \"+nodeString+\"\");\n\t  itemm.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e){\n\t      removeNodeFromParent((DefaultMutableTreeNode) selPath.getLastPathComponent());\n\t    }\n\t  });\n\t  JPopupMenu jpopup=new JPopupMenu();\n\t  jpopup.add(itemm);\n          jpopup.show(jp, e.getX(), e.getY());\n        }\n      }\n    };\n    this.logTree.addMouseListener(ml);\n\n    jp.add(new JScrollPane(logTree), BorderLayout.CENTER);    \n    \n    eventName.put(new Integer(Bundle.ACTIVE),     \"ACTIVE     \");\n    eventName.put(new Integer(Bundle.INSTALLED),  \"INSTALLED  \");\n    eventName.put(new Integer(Bundle.RESOLVED),   \"RESOLVED   \");\n    eventName.put(new Integer(Bundle.STARTING),   \"STARTING   \");\n    eventName.put(new Integer(Bundle.STOPPING),   \"STOPPING   \");\n    eventName.put(new Integer(Bundle.UNINSTALLED),\"UNINSTALLED\");\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent e){\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\nSystem.out.println(\"Ajout d'un listener \" +mbs);\n          ((MBeanServerConnection)e.getNewValue()).addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","id":51943,"modified_method":"public void propertyChange(PropertyChangeEvent e){\n    //System.out.println(\"PCE : \"+e.getPropertyName());\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\n          //System.out.println(\"RemoteLogger_jtree add a notification listener on this Remote Logger : \"+mbs);\n\t  ((MBeanServerConnection)e.getNewValue()).addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n          if(JOptionPane.showConfirmDialog(null,\"Do you want \\\"\"+this.getName()+\"\\\" ask old log to this gateway :\\n\"+((String) e.getOldValue())+\" ?\")==JOptionPane.YES_OPTION) {\n            try {\n\t      //System.out.println(\"   => mosgi.console.component.RemoteLoger_jtree gonna ask the oldLog\");\n\t      mbs.invoke(new ObjectName(\"OSGI:name=Remote Logger\"), \"sendOldLog\", new Object[]{}, new String[]{});\n\t    } catch (Exception ee) {\n\t      System.out.println(\"   => mosgi.console.component.RemoteLoger_jtree : getOldLog : \"+ee);\n\t    }\n\t  }\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","commit_id":"e2b74407f793a64becb4a2164bc60dc97c65f6ec","url":"https://github.com/apache/felix"},{"original_method":"public void rebuildDates(){\n        serverLog.logInfo(\"BOOKMARKS\", \"rebuilding dates.db from bookmarks.db...\");\n        final Iterator<Bookmark> it=bookmarkIterator(true);\n        Bookmark bookmark;\n        String date;\n        bookmarksDate bmDate;\n        while(it.hasNext()){\n            bookmark=it.next();\n            date = (new SimpleDateFormat(\"yyyy-MM-dd\")).format(new Date(bookmark.getTimeStamp()));\n            bmDate=getDate(date);\n            if(bmDate==null){\n                bmDate=new bookmarksDate(date);\n            }\n            bmDate.add(bookmark.getUrlHash());\n            bmDate.setDatesTable();\n        }\n        serverLog.logInfo(\"BOOKMARKS\", \"Rebuilt \"+datesTable.size()+\" dates using your \"+bookmarksTable.size()+\" bookmarks.\");\n    }","id":51944,"modified_method":"public void rebuildDates(){\n        serverLog.logInfo(\"BOOKMARKS\", \"rebuilding dates.db from bookmarks.db...\");\n        final Iterator<Bookmark> it=bookmarkIterator(true);\n        Bookmark bookmark;        \n        String date;\n        bookmarksDate bmDate;\n        while(it.hasNext()){\n            bookmark=it.next();\n            date = String.valueOf(bookmark.getTimeStamp());\n            bmDate=getDate(date);\n            if(bmDate==null){\n                bmDate=new bookmarksDate(date);\n            }\n            bmDate.add(bookmark.getUrlHash());\n            bmDate.setDatesTable();\n        }\n        serverLog.logInfo(\"BOOKMARKS\", \"Rebuilt \"+datesTable.size()+\" dates using your \"+bookmarksTable.size()+\" bookmarks.\");\n    }","commit_id":"bc048db7b61f07bc259a6d530c322dffb27c3564","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public void doWrite(Query query) throws Exception {\n        for (Result result : query.getResults()) {\n            Map<String, Object> resultValues = result.getValues();\n            if (resultValues != null) {\n                for (Map.Entry<String, Object> values : resultValues.entrySet()) {\n                    if (JmxUtils.isNumeric(values.getValue())) {\n                        StringBuilder writer = new StringBuilder();\n                        writer.append(\"{ \\\"host\\\": \");\n                        quote(query.getServer().getAlias(), writer);\n                        writer.append(\", \\\"seq\\\" : \" + SEQUENCE_COUNTER.incrementAndGet());\n                        writer.append(\", \\\"timestamp\\\" : \");\n                        quote(formatDate(result.getEpoch()), writer);\n                        writer.append(\", \\\"object\\\" : \");\n                        quote(query.getObj(), writer);\n                        writer.append(\", \\\"attribute\\\" : \");\n                        quote(result.getAttributeName(), writer);\n                        writer.append(\", \\\"class\\\" : \");\n                        quote(result.getClassName(), writer);\n                        writer.append(\", \\\"alias\\\" : \");\n                        quote(result.getClassNameAlias(), writer);\n                        writer.append(\", \\\"type\\\" : \");\n                        quote(result.getTypeName(), writer);\n                        writer.append(\", \\\"key\\\" : \");\n                        quote(values.getKey(), writer);\n                        writer.append(\", \\\"value\\\" : \" + values.getValue().toString());\n                        writer.append(\" }\");\n\n                        String index = this.index + \"-\" + new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date(result.getEpoch()));\n\n                        IndexRequest request = new IndexRequest()\n                                .index(index)\n                                .type(type)\n                                .source(writer.toString())\n                                .create(true);\n                        sender.put(request);\n                    }\n                }\n            }\n        }\n    }","id":51945,"modified_method":"@Override\n    public void doWrite(Query query) throws Exception {\n        for (Result result : query.getResults()) {\n            Map<String, Object> resultValues = result.getValues();\n            if (resultValues != null) {\n                for (Map.Entry<String, Object> values : resultValues.entrySet()) {\n                    if (JmxUtils.isNumeric(values.getValue())) {\n                        StringBuilder writer = new StringBuilder();\n                        writer.append(\"{ \\\"host\\\": \");\n                        quote(query.getServer().getAlias(), writer);\n                        writer.append(\", \\\"timestamp\\\" : \");\n                        quote(formatDate(result.getEpoch()), writer);\n                        writer.append(\", \\\"object\\\" : \");\n                        quote(query.getObj(), writer);\n                        writer.append(\", \\\"attribute\\\" : \");\n                        quote(result.getAttributeName(), writer);\n                        writer.append(\", \\\"class\\\" : \");\n                        quote(result.getClassName(), writer);\n                        writer.append(\", \\\"alias\\\" : \");\n                        quote(result.getClassNameAlias(), writer);\n                        writer.append(\", \\\"type\\\" : \");\n                        quote(result.getTypeName(), writer);\n                        writer.append(\", \\\"key\\\" : \");\n                        quote(values.getKey(), writer);\n                        writer.append(\", \\\"value\\\" : \").append(values.getValue().toString());\n                        writer.append(\" }\");\n\n                        IndexRequest request = new IndexRequest()\n                                .index(getIndex(result.getEpoch()))\n                                .type(type)\n                                .source(writer.toString())\n                                .create(true);\n                        sender.put(request);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e35211424f3f811813faa12afe19dc2625e4cac9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void handleEvent(final Event event) {\n        try {\n            StringBuilder writer = new StringBuilder();\n            writer.append(\"{ \\\"host\\\": \");\n            quote(name, writer);\n            writer.append(\", \\\"seq\\\" : \" + SEQUENCE_COUNTER.incrementAndGet());\n            writer.append(\", \\\"topic\\\": \");\n            quote(event.getTopic(), writer);\n            writer.append(\", \\\"properties\\\": { \");\n            boolean first = true;\n\n            long timestamp = 0;\n\n            for (String name : event.getPropertyNames()) {\n                if (first) {\n                    first = false;\n                } else {\n                    writer.append(\", \");\n                }\n                quote(name, writer);\n                writer.append(\": \");\n                Object value = event.getProperty(name);\n                if (value == null) {\n                    writer.append(\"null\");\n                } else if (EventConstants.TIMESTAMP.equals(name) && value instanceof Long) {\n                    timestamp = (Long) value;\n                    quote(formatDate(timestamp), writer);\n                } else if (value.getClass().isArray()) {\n                    writer.append(\" [ \");\n                    boolean vfirst = true;\n                    for (Object v : ((Object[]) value)) {\n                        if (!vfirst) {\n                            writer.append(\", \");\n                        } else {\n                            vfirst = false;\n                        }\n                        quote(v.toString(), writer);\n                    }\n                    writer.append(\" ] \");\n                } else {\n                    quote(value.toString(), writer);\n                }\n            }\n            writer.append(\" } }\");\n\n            if (timestamp == 0) {\n                timestamp = System.currentTimeMillis();\n            }\n            String index = this.index + \"-\"+ new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date(timestamp));\n\n            IndexRequest request = new IndexRequest()\n                    .index(index)\n                    .type(type)\n                    .source(writer.toString())\n                    .create(true);\n            sender.put(request);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":51946,"modified_method":"public void handleEvent(final Event event) {\n        try {\n            StringBuilder writer = new StringBuilder();\n            writer.append(\"{ \\\"host\\\": \");\n            quote(name, writer);\n            writer.append(\", \\\"topic\\\": \");\n            quote(event.getTopic(), writer);\n            writer.append(\", \\\"properties\\\": { \");\n            boolean first = true;\n\n            long timestamp = 0;\n\n            for (String name : event.getPropertyNames()) {\n                if (first) {\n                    first = false;\n                } else {\n                    writer.append(\", \");\n                }\n                quote(name, writer);\n                writer.append(\": \");\n                Object value = event.getProperty(name);\n                if (value == null) {\n                    writer.append(\"null\");\n                } else if (EventConstants.TIMESTAMP.equals(name) && value instanceof Long) {\n                    timestamp = (Long) value;\n                    quote(formatDate(timestamp), writer);\n                } else if (value.getClass().isArray()) {\n                    writer.append(\" [ \");\n                    boolean vfirst = true;\n                    for (Object v : ((Object[]) value)) {\n                        if (!vfirst) {\n                            writer.append(\", \");\n                        } else {\n                            vfirst = false;\n                        }\n                        quote(v.toString(), writer);\n                    }\n                    writer.append(\" ] \");\n                } else {\n                    quote(value.toString(), writer);\n                }\n            }\n            writer.append(\" } }\");\n\n            if (timestamp == 0) {\n                timestamp = System.currentTimeMillis();\n            }\n\n            IndexRequest request = new IndexRequest()\n                    .index(getIndex(timestamp))\n                    .type(type)\n                    .source(writer.toString())\n                    .create(true);\n            sender.put(request);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"e35211424f3f811813faa12afe19dc2625e4cac9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void doAppend(final PaxLoggingEvent paxLoggingEvent) {\n        try {\n\n            // Only store TRACE events which have a trace-id.\n            if ( \"TRACE\".equals(paxLoggingEvent.getLevel().toString().toUpperCase()) &&\n                  !paxLoggingEvent.getProperties().containsKey(\"trace-id\") ) {\n                return;\n            }\n            StringBuilder writer = new StringBuilder();\n            writer.append(\"{ \\\"host\\\" : \");\n            quote(name, writer);\n            writer.append(\",\\n  \\\"seq\\\" : \" + SEQUENCE_COUNTER.incrementAndGet());\n            writer.append(\",\\n  \\\"timestamp\\\" : \");\n            quote(formatDate(paxLoggingEvent.getTimeStamp()), writer);\n            writer.append(\",\\n  \\\"level\\\" : \");\n            quote(paxLoggingEvent.getLevel().toString(), writer);\n            writer.append(\",\\n  \\\"logger\\\" : \");\n            quote(paxLoggingEvent.getLoggerName(), writer);\n            writer.append(\",\\n  \\\"thread\\\" : \");\n            quote(paxLoggingEvent.getThreadName(), writer);\n            writer.append(\",\\n  \\\"message\\\" : \");\n            quote(paxLoggingEvent.getMessage(), writer);\n\n            String[] throwable = paxLoggingEvent.getThrowableStrRep();\n            if( throwable!=null ) {\n                writer.append(\",\\n  \\\"exception\\\" : [\");\n                for (int i = 0; i < throwable.length; i++) {\n                    if(i!=0)\n                        writer.append(\", \");\n                    quote(throwable[i], writer);\n                }\n                writer.append(\"]\");\n            }\n\n            writer.append(\",\\n  \\\"properties\\\" : { \");\n            boolean first = true;\n            for (Object key : paxLoggingEvent.getProperties().keySet()) {\n                if (first) {\n                    first = false;\n                } else {\n                    writer.append(\", \");\n                }\n                quote(key.toString(), writer);\n                writer.append(\": \");\n                quote(paxLoggingEvent.getProperties().get(key).toString(), writer);\n            }\n            writer.append(\" }\");\n            writer.append(\"\\n}\");\n\n            String index = this.index + \"-\"+ new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date(paxLoggingEvent.getTimeStamp()));\n\n            IndexRequest request = new IndexRequest()\n                    .index(index)\n                    .type(type)\n                    .source(writer.toString())\n                    .create(true);\n            sender.put(request);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":51947,"modified_method":"public void doAppend(final PaxLoggingEvent paxLoggingEvent) {\n        try {\n\n            // Only store TRACE events which have a trace-id.\n            if ( \"TRACE\".equals(paxLoggingEvent.getLevel().toString().toUpperCase()) &&\n                  !paxLoggingEvent.getProperties().containsKey(\"trace-id\") ) {\n                return;\n            }\n            StringBuilder writer = new StringBuilder();\n            writer.append(\"{ \\\"host\\\" : \");\n            quote(name, writer);\n            writer.append(\",\\n  \\\"timestamp\\\" : \");\n            quote(formatDate(paxLoggingEvent.getTimeStamp()), writer);\n            writer.append(\",\\n  \\\"level\\\" : \");\n            quote(paxLoggingEvent.getLevel().toString(), writer);\n            writer.append(\",\\n  \\\"logger\\\" : \");\n            quote(paxLoggingEvent.getLoggerName(), writer);\n            writer.append(\",\\n  \\\"thread\\\" : \");\n            quote(paxLoggingEvent.getThreadName(), writer);\n            writer.append(\",\\n  \\\"message\\\" : \");\n            quote(paxLoggingEvent.getMessage(), writer);\n\n            String[] throwable = paxLoggingEvent.getThrowableStrRep();\n            if( throwable!=null ) {\n                writer.append(\",\\n  \\\"exception\\\" : [\");\n                for (int i = 0; i < throwable.length; i++) {\n                    if(i!=0)\n                        writer.append(\", \");\n                    quote(throwable[i], writer);\n                }\n                writer.append(\"]\");\n            }\n\n            writer.append(\",\\n  \\\"properties\\\" : { \");\n            boolean first = true;\n            for (Object key : paxLoggingEvent.getProperties().keySet()) {\n                if (first) {\n                    first = false;\n                } else {\n                    writer.append(\", \");\n                }\n                quote(key.toString(), writer);\n                writer.append(\": \");\n                quote(paxLoggingEvent.getProperties().get(key).toString(), writer);\n            }\n            writer.append(\" }\");\n            writer.append(\"\\n}\");\n\n            IndexRequest request = new IndexRequest()\n                    .index(getIndex(paxLoggingEvent.getTimeStamp()))\n                    .type(type)\n                    .source(writer.toString())\n                    .create(true);\n            sender.put(request);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"e35211424f3f811813faa12afe19dc2625e4cac9","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Object put(String name, Object k, Object v, long ttl) {\n        Data key = toData(k);\n        int partitionId = nodeService.getPartitionId(key);\n        PutOperation putOperation = new PutOperation(name, toData(k), v, ttl);\n        try {\n            Data response = (Data) nodeService.invokeOptimistically(MAP_SERVICE_NAME, putOperation, partitionId).get();\n            return toObject(response);\n        } catch (Throwable throwable) {\n            throw new RuntimeException(throwable);\n        }\n    }","id":51948,"modified_method":"public Object put(String name, Object k, Object v, long ttl) {\n        Data key = toData(k);\n        int partitionId = nodeService.getPartitionId(key);\n        PutOperation putOperation = new PutOperation(name, toData(k), v, ttl);\n        try {\n            Invocation invocation = nodeService.createSinglePartitionInvocation(MAP_SERVICE_NAME, putOperation, partitionId).build();\n            Future f = invocation.invoke();\n            Data response = (Data) f.get();\n            return toObject(response);\n        } catch (Throwable throwable) {\n            throw new RuntimeException(throwable);\n        }\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object getOperation(String name, Object k) {\n        Data key = toData(k);\n        int partitionId = nodeService.getPartitionId(key);\n        GetOperation getOperation = new GetOperation(name, toData(k));\n        try {\n            Data response = (Data) nodeService.invokeOptimistically(MAP_SERVICE_NAME, getOperation, partitionId).get();\n            return toObject(response);\n        } catch (Throwable throwable) {\n            throw new RuntimeException(throwable);\n        }\n    }","id":51949,"modified_method":"public Object getOperation(String name, Object k) {\n        Data key = toData(k);\n        int partitionId = nodeService.getPartitionId(key);\n        GetOperation getOperation = new GetOperation(name, toData(k));\n        try {\n            Invocation invocation = nodeService.createSinglePartitionInvocation(MAP_SERVICE_NAME, getOperation, partitionId).build();\n            Future f = invocation.invoke();\n            Data response = (Data) f.get();\n            return toObject(response);\n        } catch (Throwable throwable) {\n            throw new RuntimeException(throwable);\n        }\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Future invoke(String serviceName, Operation op, int partitionId, int tryCount, long tryPauseMillis) {\n        return invoke(serviceName, op, partitionId, 0, tryCount, tryPauseMillis);\n    }","id":51950,"modified_method":"public SinglePartitionInvocationBuilder createSinglePartitionInvocation(String serviceName, Operation op, int partitionId) {\n        return new SinglePartitionInvocationBuilder(NodeService.this, serviceName, op, getPartitionInfo(partitionId));\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void invokeOnSinglePartition(final SinglePartitionInvocation inv) {\n        final Address target = inv.getTarget();\n        final Operation op = inv.getOperation();\n        final int partitionId = inv.getPartitionInfo().getPartitionId();\n        final String serviceName = inv.getServiceName();\n        final boolean nonBlocking = (op instanceof NonBlockingOperation);\n        setOperationContext(op, serviceName, node.getThisAddress(), -1, partitionId)\n                .setLocal(true);\n        if (target == null) {\n            throw new NullPointerException(inv.getOperation() + \": Target is null\");\n        }\n        if (getClusterImpl().getMember(target) == null) {\n            throw new RuntimeException(\"Target not a member: \" + target);\n        }\n        if (getThisAddress().equals(target)) {\n            final ExecutorService executor = getExecutor(partitionId, nonBlocking);\n            executor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        if (partitionId != -1 && !nonBlocking) {\n                            PartitionInfo partitionInfo = getPartitionInfo(partitionId);\n                            Address owner = partitionInfo.getOwner();\n                            if (!getThisAddress().equals(owner)) {\n                                throw new WrongTargetException(getThisAddress(), owner);\n                            }\n                        }\n                        inv.run();\n                    } catch (Throwable e) {\n                        inv.setResult(e);\n                    }\n                }\n            });\n        } else {\n            if (getThisAddress().equals(target)) {\n                throw new RuntimeException(\"RemoteTarget cannot be local!\");\n            }\n            final Packet packet = new Packet();\n            packet.operation = REMOTE_CALL;\n            packet.blockId = partitionId;\n            packet.name = serviceName;\n            packet.longValue = nonBlocking ? 1 : 0;\n            Data valueData = toData(op);\n            packet.setValue(valueData);\n            TheCall call = new TheCall(target, op, inv);\n            boolean sent = node.concurrentMapManager.registerAndSend(target, packet, call);\n            if (!sent) {\n                inv.setResult(new IOException());\n            }\n        }\n    }","id":51951,"modified_method":"void invokeOnSinglePartition(final SinglePartitionInvocation inv) {\n        final Address target = inv.getTarget();\n        final Operation op = inv.getOperation();\n        final int partitionId = inv.getPartitionInfo().getPartitionId();\n        final String serviceName = inv.getServiceName();\n        final boolean nonBlocking = (op instanceof NonBlockingOperation);\n        setOperationContext(op, serviceName, node.getThisAddress(), -1, partitionId)\n                .setLocal(true);\n        if (target == null) {\n            throw new NullPointerException(inv.getOperation() + \": Target is null\");\n        }\n        if (getClusterImpl().getMember(target) == null) {\n            throw new RuntimeException(\"Target not a member: \" + target);\n        }\n        if (getThisAddress().equals(target)) {\n            final ExecutorService executor = getExecutor(partitionId, nonBlocking);\n            executor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        if (partitionId != -1 && !nonBlocking) {\n                            PartitionInfo partitionInfo = getPartitionInfo(partitionId);\n                            Address owner = partitionInfo.getOwner();\n                            if (!getThisAddress().equals(owner)) {\n                                throw new WrongTargetException(getThisAddress(), owner);\n                            }\n                        }\n                        inv.run();\n                    } catch (Throwable e) {\n                        inv.setResult(e);\n                    }\n                }\n            });\n        } else {\n            final Packet packet = new Packet();\n            packet.operation = REMOTE_CALL;\n            packet.blockId = partitionId;\n            packet.name = serviceName;\n            packet.longValue = nonBlocking ? 1 : 0;\n            Data valueData = toData(op);\n            packet.setValue(valueData);\n            TheCall call = new TheCall(target, op, inv);\n            boolean sent = node.concurrentMapManager.registerAndSend(target, packet, call);\n            if (!sent) {\n                inv.setResult(new IOException());\n            }\n        }\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private boolean takeBackup() {\n        boolean callerBackup = false;\n        OperationContext context = getOperationContext();\n        NodeService nodeService = context.getNodeService();\n        MapService mapService = (MapService) context.getService();\n        MapPartition mapPartition = mapService.getMapPartition(context.getPartitionId(), name);\n        int mapBackupCount = 1;\n        int backupCount = Math.min(nodeService.getClusterImpl().getSize() - 1, mapBackupCount);\n        if (backupCount > 0) {\n            List<Future> backupOps = new ArrayList<Future>(backupCount);\n            PartitionInfo partitionInfo = mapPartition.partitionInfo;\n            for (int i = 0; i < backupCount; i++) {\n                int replicaIndex = i + 1;\n                Address replicaTarget = partitionInfo.getReplicaAddress(replicaIndex);\n                if (replicaTarget != null) {\n                    if (replicaTarget.equals(nodeService.getThisAddress())) {\n//                            Normally shouldn't happen!!\n//                            PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n//                            pbo.call();\n                    } else {\n                        if (replicaTarget.equals(getOperationContext().getCaller())) {\n                            callerBackup = true;\n//                                PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n//                                backupOps.add(service.backup(pbo, replicaTarget));\n                        } else {\n                            PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n                            try {\n                                backupOps.add(nodeService.invokeOptimistically(MapService.MAP_SERVICE_NAME, pbo, partitionInfo.getPartitionId(), replicaIndex));\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    }\n                }\n            }\n            for (Future backupOp : backupOps) {\n                try {\n                    backupOp.get(10, TimeUnit.SECONDS);\n                } catch (Exception e) {\n                }\n            }\n        }\n        return callerBackup;\n    }","id":51952,"modified_method":"private boolean takeBackup() {\n        boolean callerBackup = false;\n        OperationContext context = getOperationContext();\n        NodeService nodeService = context.getNodeService();\n        MapService mapService = (MapService) context.getService();\n        MapPartition mapPartition = mapService.getMapPartition(context.getPartitionId(), name);\n        int mapBackupCount = 1;\n        int backupCount = Math.min(nodeService.getClusterImpl().getSize() - 1, mapBackupCount);\n        if (backupCount > 0) {\n            List<Future> backupOps = new ArrayList<Future>(backupCount);\n            PartitionInfo partitionInfo = mapPartition.partitionInfo;\n            for (int i = 0; i < backupCount; i++) {\n                int replicaIndex = i + 1;\n                Address replicaTarget = partitionInfo.getReplicaAddress(replicaIndex);\n                if (replicaTarget != null) {\n                    if (replicaTarget.equals(nodeService.getThisAddress())) {\n//                            Normally shouldn't happen!!\n//                            PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n//                            pbo.call();\n                    } else {\n                        if (replicaTarget.equals(getOperationContext().getCaller())) {\n                            callerBackup = true;\n//                                PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n//                                backupOps.add(service.backup(pbo, replicaTarget));\n                        } else {\n                            PutBackupOperation pbo = new PutBackupOperation(name, dataKey, dataValue, ttl);\n                            try {\n                                backupOps.add(nodeService.createSinglePartitionInvocation(MapService.MAP_SERVICE_NAME, pbo, partitionInfo.getPartitionId()).setReplicaIndex(replicaIndex).build().invoke());\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    }\n                }\n            }\n            for (Future backupOp : backupOps) {\n                try {\n                    backupOp.get(10, TimeUnit.SECONDS);\n                } catch (Exception e) {\n                }\n            }\n        }\n        return callerBackup;\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void onDisconnect(Address dead) {\n        if (dead.equals(target)) {\n            callback.notify(op, new IOException());\n        }\n    }","id":51953,"modified_method":"public void onDisconnect(Address dead) {\n        if (dead.equals(target)) {\n            callback.notify(new IOException());\n        }\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public TheCall(Address target, Operation op) {\n        this.target = target;\n        this.op = op;\n        final BlockingQueue responseQ = ResponseQueueFactory.newResponseQueue();\n        this.callback = new Callback() {\n            public void notify(Operation op, final Object result) {\n                responseQ.offer(result);\n            }\n        };\n    }","id":51954,"modified_method":"public TheCall(Address target, Operation op) {\n        this.target = target;\n        this.op = op;\n        final BlockingQueue responseQ = ResponseQueueFactory.newResponseQueue();\n        this.callback = new Callback() {\n            public void notify(final Object result) {\n                responseQ.offer(result);\n            }\n        };\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void offerResponse(Response response) {\n        callback.notify(op, response);\n    }","id":51955,"modified_method":"public void offerResponse(Response response) {\n        callback.notify(response);\n    }","commit_id":"03a17e2fc29b0557c9be573bd15bc6681a69ff70","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test public void testSimpleOperations() throws Exception {\n        generateEvents();\n\n        assertEquals(\"Received: \" + events, 5, events.size());\n        final Set<String> addPaths = new HashSet<String>();\n        final Set<String> modifyPaths = new HashSet<String>();\n        final Set<String> removePaths = new HashSet<String>();\n\n        for(final Event event : events) {\n            if ( event.getTopic().equals(SlingConstants.TOPIC_RESOURCE_ADDED) ) {\n                addPaths.add((String)event.getProperty(SlingConstants.PROPERTY_PATH));\n            } else if ( event.getTopic().equals(SlingConstants.TOPIC_RESOURCE_CHANGED) ) {\n                modifyPaths.add((String)event.getProperty(SlingConstants.PROPERTY_PATH));\n            } else if ( event.getTopic().equals(SlingConstants.TOPIC_RESOURCE_REMOVED) ) {\n                removePaths.add((String)event.getProperty(SlingConstants.PROPERTY_PATH));\n            } else {\n                fail(\"Unexpected event: \" + event);\n            }\n            assertNotNull(event.getProperty(SlingConstants.PROPERTY_USERID));\n        }\n        assertEquals(3, addPaths.size());\n        assertTrue(\"Added set should contain \" + createdPath, addPaths.contains(createdPath));\n        assertTrue(\"Added set should contain \" + pathToDelete, addPaths.contains(pathToDelete));\n        assertTrue(\"Added set should contain \" + pathToModify, addPaths.contains(pathToModify));\n\n        assertEquals(1, modifyPaths.size());\n        assertTrue(\"Modified set should contain \" + pathToModify, modifyPaths.contains(pathToModify));\n\n        assertEquals(1, removePaths.size());\n        assertTrue(\"Removed set should contain \" + pathToDelete, removePaths.contains(pathToDelete));\n    }","id":51956,"modified_method":"@Test public void testSimpleOperations() throws Exception {\n        generateEvents();\n\n        assertEquals(\"Received: \" + events, 5, events.size());\n        final Set<String> addPaths = new HashSet<String>();\n        final Set<String> modifyPaths = new HashSet<String>();\n        final Set<String> removePaths = new HashSet<String>();\n\n        for (final ResourceChange event : events) {\n            if (event.getType() == ChangeType.ADDED) {\n                addPaths.add(event.getPath());\n            } else if (event.getType() == ChangeType.CHANGED) {\n                modifyPaths.add(event.getPath());\n                assertEquals(Collections.singleton(\"foo\"), event.getAddedPropertyNames());\n            } else if (event.getType() == ChangeType.REMOVED) {\n                removePaths.add(event.getPath());\n            } else {\n                fail(\"Unexpected event: \" + event);\n            }\n            assertNotNull(event.getUserId());\n        }\n        assertEquals(3, addPaths.size());\n        assertTrue(\"Added set should contain \" + createdPath, addPaths.contains(createdPath));\n        assertTrue(\"Added set should contain \" + pathToDelete, addPaths.contains(pathToDelete));\n        assertTrue(\"Added set should contain \" + pathToModify, addPaths.contains(pathToModify));\n\n        assertEquals(1, modifyPaths.size());\n        assertTrue(\"Modified set should contain \" + pathToModify, modifyPaths.contains(pathToModify));\n\n        assertEquals(1, removePaths.size());\n        assertTrue(\"Removed set should contain \" + pathToDelete, removePaths.contains(pathToDelete));\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"private void generateEvents() throws Exception {\n        final Session session = getRepository().loginAdministrative(null);\n\n        try {\n            // create the nodes\n            createNode(session, createdPath);\n            createNode(session, pathToModify);\n            createNode(session, pathToDelete);\n\n            Thread.sleep(1000);\n\n            // modify\n            final Node modified = session.getNode(pathToModify);\n            modified.setProperty(\"foo\", \"bar\");\n\n            session.save();\n\n            // delete\n            final Node deleted = session.getNode(pathToDelete);\n            deleted.remove();\n            session.save();\n\n            Thread.sleep(3500);\n\n        } finally {\n            session.logout();\n        }\n    }","id":51957,"modified_method":"private void generateEvents() throws Exception {\n        @SuppressWarnings(\"deprecation\")\n        final Session session = getRepository().loginAdministrative(null);\n\n        try {\n            // create the nodes\n            createNode(session, createdPath);\n            createNode(session, pathToModify);\n            createNode(session, pathToDelete);\n\n            Thread.sleep(1000);\n\n            // modify\n            final Node modified = session.getNode(pathToModify);\n            modified.setProperty(\"foo\", \"bar\");\n\n            session.save();\n\n            // delete\n            final Node deleted = session.getNode(pathToDelete);\n            deleted.remove();\n            session.save();\n\n            Thread.sleep(3500);\n\n        } finally {\n            session.logout();\n        }\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n     */\n    @Override\n    public void onEvent(final EventIterator events) {\n        // if the event admin is currently not available, we just skip this\n        final EventAdmin localEA = this.support.getEventAdmin();\n        if ( localEA == null ) {\n            return;\n        }\n        final Map<String, Map<String, Object>> addedEvents = new HashMap<String, Map<String, Object>>();\n        final Map<String, ChangedAttributes> changedEvents = new HashMap<String, ChangedAttributes>();\n        final Map<String, Map<String, Object>> removedEvents = new HashMap<String, Map<String, Object>>();\n        while ( events.hasNext() ) {\n            final Event event = events.nextEvent();\n            try {\n                final String eventPath;\n                if ( this.mountPrefix != null ) {\n                    eventPath = this.mountPrefix + event.getPath();\n                } else {\n                    eventPath = event.getPath();\n                }\n                if ( event.getType() == Event.PROPERTY_ADDED\n                     || event.getType() == Event.PROPERTY_REMOVED\n                     || event.getType() == Event.PROPERTY_CHANGED ) {\n                    final int lastSlash = eventPath.lastIndexOf('/');\n                    final String nodePath = eventPath.substring(0, lastSlash);\n                    final String propName = eventPath.substring(lastSlash + 1);\n                    this.updateChangedEvent(changedEvents, nodePath, event, propName);\n\n                } else if ( event.getType() == Event.NODE_ADDED ) {\n                    addedEvents.put(eventPath, createEventProperties(event));\n\n                } else if ( event.getType() == Event.NODE_REMOVED) {\n                    // remove is the strongest operation, therefore remove all removed\n                    // paths from added\n                    addedEvents.remove(eventPath);\n                    removedEvents.put(eventPath, createEventProperties(event));\n                }\n            } catch (final RepositoryException e) {\n                logger.error(\"Error during modification: {}\", e.getMessage());\n            }\n        }\n\n        for (final Entry<String, Map<String, Object>> e : removedEvents.entrySet()) {\n            // Launch an OSGi event\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_REMOVED,\n                null);\n        }\n\n        for (final Entry<String, Map<String, Object>> e : addedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue(), SlingConstants.TOPIC_RESOURCE_ADDED,\n                changedEvents.remove(e.getKey()));\n        }\n\n        // Send the changed events.\n        for (final Entry<String, ChangedAttributes> e : changedEvents.entrySet()) {\n            // Launch an OSGi event.\n            sendOsgiEvent(e.getKey(), e.getValue().toEventProperties(), SlingConstants.TOPIC_RESOURCE_CHANGED, null);\n        }\n    }","id":51958,"modified_method":"/**\n     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n     */\n    @Override\n    public void onEvent(final EventIterator events) {\n        final Map<String, Builder> addedEvents = new HashMap<String, Builder>();\n        final Map<String, Builder> changedEvents = new HashMap<String, Builder>();\n        final Map<String, Builder> removedEvents = new HashMap<String, Builder>();\n\n        while ( events.hasNext() ) {\n            final Event event = events.nextEvent();\n            if (isExternal(event) && !includeExternal) {\n                continue;\n            }\n\n            try {\n                final String eventPath = event.getPath();\n                final int type = event.getType();\n                if ( type == PROPERTY_ADDED\n                     || type == PROPERTY_REMOVED\n                     || type == PROPERTY_CHANGED ) {\n                    final int lastSlash = eventPath.lastIndexOf('/');\n                    final String nodePath = eventPath.substring(0, lastSlash);\n                    final String propName = eventPath.substring(lastSlash + 1);\n                    Builder builder = changedEvents.get(nodePath);\n                    if (builder == null) {\n                        changedEvents.put(nodePath, builder = createResourceChange(event, nodePath, ChangeType.CHANGED));\n                    }\n                    this.updateResourceChanged(builder, event.getType(), propName);\n                } else if ( type == NODE_ADDED ) {\n                    addedEvents.put(eventPath, createResourceChange(event, ChangeType.ADDED));\n                } else if ( type == NODE_REMOVED) {\n                    // remove is the strongest operation, therefore remove all removed\n                    // paths from added\n                    addedEvents.remove(eventPath);\n                    removedEvents.put(eventPath, createResourceChange(event, ChangeType.REMOVED));\n                }\n            } catch (final RepositoryException e) {\n                logger.error(\"Error during modification: {}\", e);\n            }\n        }\n\n        final List<ResourceChange> changes = new ArrayList<ResourceChange>();\n        for (Entry<String, Builder> e : addedEvents.entrySet()) {\n            String path = e.getKey();\n            if (changedEvents.containsKey(path)) {\n                Builder builder = changedEvents.remove(path);\n                builder.setChangeType(ChangeType.ADDED);\n                changes.add(builder.build());\n            } else {\n                changes.add(e.getValue().build());\n            }\n        }\n        buildResourceChanges(changes, removedEvents);\n        buildResourceChanges(changes, changedEvents);\n        filterChanges(changes);\n        ctx.getObservationReporter().reportChanges(changes, false);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"public JcrResourceListener(\n                    final String mountPrefix,\n                    final ObservationListenerSupport support,\n                    final PathMapper pathMapper)\n    throws RepositoryException {\n        this.pathMapper = pathMapper;\n        boolean foundClass = false;\n        try {\n            this.getClass().getClassLoader().loadClass(JackrabbitEvent.class.getName());\n            foundClass = true;\n        } catch (final Throwable t) {\n            // we ignore this\n        }\n        this.hasJackrabbitEventClass = foundClass;\n        this.mountPrefix = (mountPrefix == null || mountPrefix.length() == 0 || mountPrefix.equals(\"/\") ? null : mountPrefix);\n\n        this.support = support;\n        this.support.getSession().getWorkspace().getObservationManager().addEventListener(this,\n                        Event.NODE_ADDED|Event.NODE_REMOVED|Event.PROPERTY_ADDED|Event.PROPERTY_CHANGED|Event.PROPERTY_REMOVED,\n                        \"/\", true, null, null, false);\n\n        this.osgiEventQueue = new LinkedBlockingQueue<Map<String,Object>>();\n        final Thread oeqt = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                processOsgiEventQueue();\n            }\n        }, \"Apache Sling JCR Resource Event Queue Processor\");\n        oeqt.start();\n    }","id":51959,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public JcrResourceListener(\n                    final ProviderContext ctx,\n                    final String mountPrefix,\n                    final PathMapper pathMapper,\n                    final SlingRepository repository)\n    throws RepositoryException {\n        this.includeExternal = isIncludeExternal(ctx);\n        this.pathMapper = pathMapper;\n        this.mountPrefix = mountPrefix;\n        this.ctx = ctx;\n        boolean foundClass = false;\n        try {\n            this.getClass().getClassLoader().loadClass(JackrabbitEvent.class.getName());\n            foundClass = true;\n        } catch (final Throwable t) {\n            // we ignore this\n        }\n        this.hasJackrabbitEventClass = foundClass;\n        this.session = repository.loginAdministrative(repository.getDefaultWorkspace());\n        final String absPath = getAbsPath(pathMapper, ctx);\n        final int types = getTypes(ctx);\n        this.session.getWorkspace().getObservationManager().addEventListener(this, types, absPath, true, null, null, false);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Dispose this listener.\n     */\n    @Override\n    public void close() throws IOException {\n        // unregister from observations\n        try {\n            this.support.getSession().getWorkspace().getObservationManager().removeEventListener(this);\n        } catch (RepositoryException e) {\n            logger.warn(\"Unable to remove session listener: \" + this, e);\n        }\n\n        // drop any remaining OSGi Events not processed yet\n        this.osgiEventQueue.clear();\n        this.osgiEventQueue.offer(TERMINATE_PROCESSING);\n\n        this.support.dispose();\n    }","id":51960,"modified_method":"/**\n     * Dispose this listener.\n     */\n    @Override\n    public void close() throws IOException {\n        // unregister from observations\n        try {\n            this.session.getWorkspace().getObservationManager().removeEventListener(this);\n        } catch (RepositoryException e) {\n            logger.warn(\"Unable to remove session listener: \" + this, e);\n        }\n        this.session.logout();\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setUp() throws RepositoryException, InvalidSyntaxException {\n        ObservationManager observationManager = mock(ObservationManager.class);\n\n        Workspace workspace = mock(Workspace.class);\n        when(workspace.getObservationManager()).thenReturn(observationManager);\n\n        Session session = mock(Session.class);\n        when(session.getWorkspace()).thenReturn(workspace);\n\n        SlingRepository repository = mock(SlingRepository.class);\n        when(repository.loginAdministrative(null)).thenReturn(session);\n\n        EventAdmin eventAdmin = mock(EventAdmin.class);\n        ServiceReference serviceRef = mock(ServiceReference.class);\n        ServiceReference[] serviceRefs = new ServiceReference[]{serviceRef};\n        BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.getServiceReferences(anyString(), anyString())).thenReturn(serviceRefs);\n        when(bundleContext.getService(serviceRef)).thenReturn(eventAdmin);\n\n        jcrResourceListener = new JcrResourceListener(\"/\", new ObservationListenerSupport(bundleContext, repository, null), new PathMapperImpl());\n\n        Event event = mock(MockEvent.class);\n        events = mock(EventIterator.class);\n        when(events.hasNext()).thenReturn(true);\n        when(event.getPath()).thenCallRealMethod();\n        when(event.getType()).thenReturn(Event.NODE_ADDED);\n        when(events.nextEvent()).thenReturn(event);\n    }","id":51961,"modified_method":"@SuppressWarnings(\"deprecation\")\n    @Before\n    public void setUp() throws RepositoryException, InvalidSyntaxException {\n        ObservationManager observationManager = mock(ObservationManager.class);\n\n        Workspace workspace = mock(Workspace.class);\n        when(workspace.getObservationManager()).thenReturn(observationManager);\n\n        Session session = mock(Session.class);\n        when(session.getWorkspace()).thenReturn(workspace);\n\n        SlingRepository repository = mock(SlingRepository.class);\n        when(repository.loginAdministrative(null)).thenReturn(session);\n\n        jcrResourceListener = new JcrResourceListener(new SimpleProviderContext(), \"/\", new PathMapperImpl(), RepositoryUtil.getRepository());\n\n        Event event = mock(MockEvent.class);\n        events = mock(EventIterator.class);\n        when(events.hasNext()).thenReturn(true);\n        when(event.getPath()).thenCallRealMethod();\n        when(event.getType()).thenReturn(Event.NODE_ADDED);\n        when(events.nextEvent()).thenReturn(event);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        RepositoryUtil.startRepository();\n        this.adminSession = RepositoryUtil.getRepository().loginAdministrative(null);\n        RepositoryUtil.registerSlingNodeTypes(adminSession);\n        final ResourceResolver resolver = Mockito.mock(ResourceResolver.class);\n        Mockito.when(resolver.adaptTo(Mockito.any(Class.class))).thenReturn(this.adminSession);\n        Mockito.when(resolver.getResource(Mockito.anyString())).thenReturn(new JcrTestNodeResource(resolver, this.adminSession.getNode(\"/\"), null));\n\n        final ResourceResolverFactory factory = Mockito.mock(ResourceResolverFactory.class);\n        Mockito.when(factory.getAdministrativeResourceResolver(Mockito.anyMap())).thenReturn(resolver);\n\n        final EventAdmin mockEA = new EventAdmin() {\n\n            public void postEvent(final Event event) {\n                addEvent(event);\n            }\n\n            public void sendEvent(final Event event) {\n                addEvent(event);\n            }\n        };\n\n        final ServiceTracker tracker = mock(ServiceTracker.class);\n        when(tracker.getService()).thenReturn(mockEA);\n\n        final BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.createFilter(any(String.class))).thenReturn(null);\n        when(bundleContext.getServiceReference(any(String.class))).thenReturn(null);\n        when(bundleContext.getService(null)).thenReturn(mockEA);\n\n        this.listener = new SynchronousJcrResourceListener(RepositoryUtil.getRepository(),\n                        bundleContext, resolver, tracker);\n    }","id":51962,"modified_method":"@SuppressWarnings(\"deprecation\")\n    @Before\n    public void setUp() throws Exception {\n        RepositoryUtil.startRepository();\n        this.adminSession = RepositoryUtil.getRepository().loginAdministrative(null);\n        RepositoryUtil.registerSlingNodeTypes(adminSession);\n        this.listener = new JcrResourceListener(new ProviderContext() {\n            @Override\n            public ObservationReporter getObservationReporter() {\n                return JcrResourceListenerTest.this.getObservationReporter();\n            }\n\n            @Override\n            public PathSet getExcludedPaths() {\n                return PathSet.fromPaths();\n            }\n        }, \"/\", new PathMapperImpl(), RepositoryUtil.getRepository());\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        if ( adminSession != null ) {\n            adminSession.logout();\n            adminSession = null;\n        }\n        RepositoryUtil.stopRepository();\n        if ( listener != null ) {\n            listener.dispose();\n            listener = null;\n        }\n    }","id":51963,"modified_method":"@After\n    public void tearDown() throws Exception {\n        if ( adminSession != null ) {\n            adminSession.logout();\n            adminSession = null;\n        }\n        RepositoryUtil.stopRepository();\n        if ( listener != null ) {\n            listener.close();\n            listener = null;\n        }\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void start(final ProviderContext ctx) {\n        super.start(ctx);\n        registerLegacyListener();\n    }","id":51964,"modified_method":"@Override\n    public void start(final ProviderContext ctx) {\n        super.start(ctx);\n        registerListener(ctx);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"private void unregisterLegacyListener() {\n        if ( this.listener != null ) {\n            try {\n                this.listener.close();\n            } catch (final IOException e) {\n                // ignore this as the method above does not throw it\n            }\n            this.listener = null;\n        }\n    }","id":51965,"modified_method":"private void unregisterListener() {\n        if ( this.listener != null ) {\n            try {\n                this.listener.close();\n            } catch (final IOException e) {\n                // ignore this as the method above does not throw it\n            }\n            this.listener = null;\n        }\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void stop() {\n        unregisterLegacyListener();\n        super.stop();\n    }","id":51966,"modified_method":"@Override\n    public void stop() {\n        unregisterListener();\n        super.stop();\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Deactivate\n    protected void deactivate() {\n        unregisterLegacyListener();\n    }","id":51967,"modified_method":"@Deactivate\n    protected void deactivate() {\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void changed(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Map<String, Object> changes = toEventProperties(added, deleted, changed);\n        addCommitInfo(changes, commitInfo);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"changed(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        sendOsgiEvent(path, TOPIC_RESOURCE_CHANGED, changes, properties);\n    }","id":51968,"modified_method":"@Override\n    protected void changed(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Builder builder = toEventProperties(JcrResourceListener.stripNtFilePath(path, session), added, deleted, changed, commitInfo);\n        if (ctx.getExcludedPaths().matches(builder.getPath()) != null) {\n            return;\n        }\n        builder.setChangeType(ChangeType.CHANGED);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"changed(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        ctx.getObservationReporter().reportChanges(Arrays.asList(builder.build()), false);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"public OakResourceListener(\n            final String mountPrefix,\n            final ObservationListenerSupport support,\n            final BundleContext bundleContext,\n            final Executor executor,\n            final PathMapper pathMapper,\n            final int  observationQueueLength)\n    throws RepositoryException {\n        super(\"/\", \"jcr:primaryType\", \"sling:resourceType\", \"sling:resourceSuperType\");\n        this.support = support;\n        this.pathMapper = pathMapper;\n        this.mountPrefix = (mountPrefix == null || mountPrefix.length() == 0 || mountPrefix.equals(\"/\") ? null : mountPrefix);\n\n        final Hashtable<String, Object> props = new Hashtable<String, Object>();\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        props.put(Constants.SERVICE_DESCRIPTION, \"Apache Sling JCR Observation Listener for Oak\");\n\n        final BackgroundObserver observer = new BackgroundObserver(this, executor, observationQueueLength) {\n            @Override\n            protected void added(int queueSize) {\n                if (queueSize == observationQueueLength) {\n                    logger.warn(\"Revision queue for observer {} is full (max = {}). Further revisions will be compacted.\",\n                            getClass().getName(), observationQueueLength);\n                }\n            }\n        };\n        serviceRegistration = bundleContext.registerService(Observer.class.getName(), observer, props);\n\n        final Dictionary<String, Object> mbeanProps = new Hashtable<String, Object>(props);\n        String objectName = String.format(\"org.apache.sling:type=%s,name=SlingResourceListener\",\n                BackgroundObserverMBean.TYPE);\n        mbeanProps.put(\"jmx.objectname\", objectName);\n\n        mbeanRegistration = bundleContext.registerService(BackgroundObserverMBean.class.getName(), observer.getMBean(), mbeanProps);\n    }","id":51969,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public OakResourceListener(\n            final String mountPrefix,\n            final ProviderContext ctx,\n            final BundleContext bundleContext,\n            final Executor executor,\n            final PathMapper pathMapper,\n            final int observationQueueLength,\n            final SlingRepository repository)\n    throws RepositoryException {\n        super(JcrResourceListener.getAbsPath(pathMapper, ctx), \"jcr:primaryType\", \"sling:resourceType\", \"sling:resourceSuperType\");\n        this.ctx = ctx;\n        this.pathMapper = pathMapper;\n        this.mountPrefix = mountPrefix;\n        this.session = repository.loginAdministrative(repository.getDefaultWorkspace());\n\n        final Hashtable<String, Object> props = new Hashtable<String, Object>();\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        props.put(Constants.SERVICE_DESCRIPTION, \"Apache Sling JCR Observation Listener for Oak\");\n\n        final BackgroundObserver observer = new BackgroundObserver(this, executor, observationQueueLength) {\n            @Override\n            protected void added(int queueSize) {\n                if (queueSize == observationQueueLength) {\n                    logger.warn(\"Revision queue for observer {} is full (max = {}). Further revisions will be compacted.\",\n                            getClass().getName(), observationQueueLength);\n                }\n            }\n        };\n        serviceRegistration = bundleContext.registerService(Observer.class.getName(), observer, props);\n\n        final Dictionary<String, Object> mbeanProps = new Hashtable<String, Object>(props);\n        String objectName = String.format(\"org.apache.sling:type=%s,name=SlingResourceListener\",\n                BackgroundObserverMBean.TYPE);\n        mbeanProps.put(\"jmx.objectname\", objectName);\n\n        mbeanRegistration = bundleContext.registerService(BackgroundObserverMBean.class.getName(), observer.getMBean(), mbeanProps);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Dispose this listener.\n     */\n    @Override\n    public void close() throws IOException {\n        mbeanRegistration.unregister();\n        serviceRegistration.unregister();\n        this.support.dispose();\n    }","id":51970,"modified_method":"/**\n     * Dispose this listener.\n     */\n    @Override\n    public void close() throws IOException {\n        mbeanRegistration.unregister();\n        serviceRegistration.unregister();\n        session.logout();\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"private static Map<String, Object> toEventProperties(final Set<String> added, final Set<String> deleted, final Set<String> changed) {\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        if ( added != null && added.size() > 0 ) {\n            properties.put(PROPERTY_ADDED_ATTRIBUTES, added.toArray(new String[added.size()]));\n        }\n        if ( changed != null && changed.size() > 0 ) {\n            properties.put(PROPERTY_CHANGED_ATTRIBUTES, changed.toArray(new String[changed.size()]));\n        }\n        if ( deleted != null && deleted.size() > 0 ) {\n            properties.put(PROPERTY_REMOVED_ATTRIBUTES, deleted.toArray(new String[deleted.size()]));\n        }\n        return properties;\n    }","id":51971,"modified_method":"private Builder toEventProperties(final String path, final Set<String> added, final Set<String> deleted, final Set<String> changed, final CommitInfo commitInfo) {\n        Builder builder = new Builder();\n        String pathWithPrefix = JcrResourceListener.addMountPrefix(mountPrefix, path);\n        builder.setPath(pathMapper.mapJCRPathToResourcePath(pathWithPrefix));\n        if ( added != null && added.size() > 0 ) {\n            for (String propName : added) {\n                builder.addAddedAttributeName(propName);\n            }\n        }\n        if ( changed != null && changed.size() > 0 ) {\n            for (String propName : changed) {\n                builder.addChangedAttributeName(propName);\n            }\n        }\n        if ( deleted != null && deleted.size() > 0 ) {\n            for (String propName : deleted) {\n                builder.addRemovedAttributeName(propName);\n            }\n        }\n        builder.setUserId(commitInfo.getUserId());\n        builder.setExternal(false);\n        return builder;\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void deleted(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Map<String, Object> changes = toEventProperties(added, deleted, changed);\n        addCommitInfo(changes, commitInfo);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"deleted(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        sendOsgiEvent(path, TOPIC_RESOURCE_REMOVED, changes, properties);\n    }","id":51972,"modified_method":"@Override\n    protected void deleted(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Builder builder = toEventProperties(path, added, deleted, changed, commitInfo);\n        if (ctx.getExcludedPaths().matches(builder.getPath()) != null) {\n            return;\n        }\n        builder.setChangeType(ChangeType.REMOVED);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"deleted(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        ctx.getObservationReporter().reportChanges(Arrays.asList(builder.build()), false);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void added(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Map<String, Object> changes = toEventProperties(added, deleted, changed);\n        addCommitInfo(changes, commitInfo);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"added(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        sendOsgiEvent(path, TOPIC_RESOURCE_ADDED, changes, properties);\n    }","id":51973,"modified_method":"@Override\n    protected void added(final String path,\n            final Set<String> added,\n            final Set<String> deleted,\n            final Set<String> changed,\n            final Map<String, String> properties,\n            final CommitInfo commitInfo) {\n        final Builder builder = toEventProperties(JcrResourceListener.stripNtFilePath(path, session), added, deleted, changed, commitInfo);\n        if (ctx.getExcludedPaths().matches(builder.getPath()) != null) {\n            return;\n        }\n        builder.setChangeType(ChangeType.ADDED);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"added(path={}, added={}, deleted={}, changed={})\", new Object[] {path, added, deleted, changed});\n        }\n        ctx.getObservationReporter().reportChanges(Arrays.asList(builder.build()), false);\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        executor = Executors.newSingleThreadExecutor();\n        final Oak oak = new Oak(new SegmentNodeStore());\n        this.whiteboard = oak.getWhiteboard();\n        final Repository repository = new Jcr(oak).createRepository();\n        this.slingRepository = new RepositoryWrapper(repository);\n\n        session = this.slingRepository.loginAdministrative(null);\n\n        ResourceResolver resolver = mock(ResourceResolver.class);\n        when(resolver.adaptTo(any(Class.class))).thenReturn(session);\n        when(resolver.getResource(anyString())).thenReturn(new JcrTestNodeResource(resolver, session.getNode(\"/\"), null));\n\n        ResourceResolverFactory factory = mock(ResourceResolverFactory.class);\n        when(factory.getAdministrativeResourceResolver(anyMap())).thenReturn(resolver);\n\n        EventAdmin mockEA = new EventAdmin() {\n            public void postEvent(Event event) {\n                addEvent(event);\n            }\n\n            public void sendEvent(Event event) {\n                addEvent(event);\n            }\n        };\n\n        ServiceTracker tracker = mock(ServiceTracker.class);\n        when(tracker.getService()).thenReturn(mockEA);\n\n        BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.createFilter(any(String.class))).thenReturn(null);\n        when(bundleContext.getServiceReference(any(String.class))).thenReturn(null);\n        when(bundleContext.getService(null)).thenReturn(mockEA);\n        when(bundleContext.registerService(eq(Observer.class.getName()), any(Object.class), any(Dictionary.class)))\n                .thenAnswer(new Answer<ServiceRegistration>() {\n                    public ServiceRegistration answer(InvocationOnMock invocation) throws Throwable {\n                        Object[] arguments = invocation.getArguments();\n                        registerObserver(whiteboard, (Observer) arguments[1]);\n                        return mock(ServiceRegistration.class);\n                    }\n                });\n\n        when(bundleContext.registerService(eq(BackgroundObserverMBean.class.getName()), any(Object.class), any\n                (Dictionary.class)))\n                .thenAnswer(new Answer<ServiceRegistration>() {\n                    public ServiceRegistration answer(InvocationOnMock invocation) throws Throwable {\n                        Object[] arguments = invocation.getArguments();\n                        assertNotNull(((Dictionary)arguments[2]).get(\"jmx.objectname\"));\n                        return mock(ServiceRegistration.class);\n                    }\n                });\n\n        listener = new SynchronousOakResourceListener(\n                this.slingRepository, bundleContext, resolver, tracker, executor);\n    }","id":51974,"modified_method":"@Before\n    public void setUp() throws Exception {\n        executor = Executors.newSingleThreadExecutor();\n        final Oak oak = new Oak(new SegmentNodeStore());\n        this.whiteboard = oak.getWhiteboard();\n        final Repository repository = new Jcr(oak).createRepository();\n        this.slingRepository = new RepositoryWrapper(repository);\n\n        BundleContext bundleContext = mock(BundleContext.class);\n        when(bundleContext.registerService(any(String.class), any(Object.class), any(Dictionary.class)))\n                .thenAnswer(new Answer<ServiceRegistration>() {\n                    public ServiceRegistration answer(InvocationOnMock invocation) throws Throwable {\n                        Object[] arguments = invocation.getArguments();\n                        if (arguments[1] instanceof Observer) {\n                            registerObserver(whiteboard, (Observer) arguments[1]);\n                        }\n                        return mock(ServiceRegistration.class);\n                    }\n                });\n        listener = new OakResourceListener(\"/\", new ProviderContext() {\n            @Override\n            public ObservationReporter getObservationReporter() {\n                return OakResourceListenerTest.this.getObservationReporter();\n            }\n\n            @Override\n            public PathSet getExcludedPaths() {\n                return PathSet.fromPaths();\n            }\n        }, bundleContext, executor, new PathMapperImpl(), 1000, slingRepository); \n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        listener.dispose();\n        session.logout();\n        executor.shutdown();\n    }","id":51975,"modified_method":"@After\n    public void tearDown() throws Exception {\n        listener.close();\n        executor.shutdown();\n    }","commit_id":"9c424dfca6a802a6b66b4b7981a313c5856a0e1f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n      public void actionPerformed(AnActionEvent e) {\n        HgUpdateCommand hgUpdateCommand = new HgUpdateCommand(myProject, mySelectedRepository.getRoot());\n        hgUpdateCommand.setBranch(myBranch);\n        HgCommandResult result = hgUpdateCommand.execute();\n        if (HgErrorUtil.hasErrorsInCommandExecution(result)) {\n          new HgCommandResultNotifier(myProject).notifyError(result, \"\", \"Update failed\");\n        }\n        myProject.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(myProject, null);\n      }","id":51976,"modified_method":"@Override\n      public void actionPerformed(AnActionEvent e) {\n        final VirtualFile repository = mySelectedRepository.getRoot();\n        HgUpdateCommand hgUpdateCommand = new HgUpdateCommand(myProject, repository);\n        hgUpdateCommand.setBranch(myBranch);\n        HgCommandResult result = hgUpdateCommand.execute();\n        if (HgErrorUtil.hasErrorsInCommandExecution(result)) {\n          new HgCommandResultNotifier(myProject).notifyError(result, \"\", \"Update failed\");\n          new HgConflictResolver(myProject).resolve(repository);\n        }\n        myProject.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(myProject, null);\n      }","commit_id":"dd4b38854fe55f43a516a8ab9a3d59f3fe16c614","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateTo(HgUpdateToDialog dialog, final Project project) {\n    final HgUpdateCommand command = new HgUpdateCommand(project, dialog.getRepository());\n    command.setClean(dialog.isRemoveLocalChanges());\n    if (dialog.isRevisionSelected()) {\n      command.setRevision(dialog.getRevision());\n    }\n    if (dialog.isBranchSelected()) {\n      command.setBranch(dialog.getBranch().getName());\n    }\n    if (dialog.isTagSelected()) {\n      command.setRevision(dialog.getTag().getName());\n    }\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        HgCommandResult result = command.execute();\n        if (HgErrorUtil.hasErrorsInCommandExecution(result)) {\n          new HgCommandResultNotifier(project).notifyError(result, \"\", \"Update failed\");\n        }\n        project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project, null);\n      }\n    });\n  }","id":51977,"modified_method":"public void updateTo(HgUpdateToDialog dialog, final Project project) {\n    final VirtualFile repository = dialog.getRepository();\n    final HgUpdateCommand command = new HgUpdateCommand(project, repository);\n    command.setClean(dialog.isRemoveLocalChanges());\n    if (dialog.isRevisionSelected()) {\n      command.setRevision(dialog.getRevision());\n    }\n    if (dialog.isBranchSelected()) {\n      command.setBranch(dialog.getBranch().getName());\n    }\n    if (dialog.isTagSelected()) {\n      command.setRevision(dialog.getTag().getName());\n    }\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        HgCommandResult result = command.execute();\n        new HgConflictResolver(project).resolve(repository);\n        if (HgErrorUtil.hasErrorsInCommandExecution(result)) {\n          new HgCommandResultNotifier(project).notifyError(result, \"\", \"Update failed\");\n        }\n        project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project, null);\n      }\n    });\n  }","commit_id":"dd4b38854fe55f43a516a8ab9a3d59f3fe16c614","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private File createFileRemote(@Nullable String branchName) throws IOException, GitAPIException {\n    Git git = new Git(testWatcher.getRepository(ICS_DIR));\n\n    if (branchName != null) {\n      // jgit cannot checkout&create branch if no HEAD (no commits in our empty repository), so we create initial empty commit\n      git.commit().setMessage(\"\").call();\n\n      git.checkout().setCreateBranch(true).setName(branchName).call();\n    }\n\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    File workTree = git.getRepository().getWorkTree();\n    FileUtil.copy(new File(getTestDataPath(), \"encoding.xml\"), new File(workTree, addedFile));\n    git.add().addFilepattern(addedFile).call();\n    git.commit().setMessage(\"\").call();\n    return workTree;\n  }","id":51978,"modified_method":"@NotNull\n  private File createFileRemote(@Nullable String branchName) throws IOException, GitAPIException {\n    Repository repository = testWatcher.getRepository(ICS_DIR);\n    Git git = new Git(repository);\n\n    if (branchName != null) {\n      // jgit cannot checkout&create branch if no HEAD (no commits in our empty repository), so we create initial empty commit\n      git.commit().setMessage(\"\").call();\n\n      git.checkout().setCreateBranch(true).setName(branchName).call();\n    }\n\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    File workTree = repository.getWorkTree();\n    FileUtil.copy(new File(getTestDataPath(), \"encoding.xml\"), new File(workTree, addedFile));\n    GitPackage.edit(repository, new AddFile(addedFile));\n    git.commit().setMessage(\"\").call();\n    return workTree;\n  }","commit_id":"8fe42b55ccd01b0c3450e060ed6c07a50659e576","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClassDefinitionBuilder field(int modifiers, String attrName, JCExpression type, JCExpression initialValue, boolean isLocal) {\n        Name attrNameNm = gen.names().fromString(attrName);\n        if (!isLocal) {\n            // A shared or captured attribute gets turned into a class member\n            defs(gen.make().VarDef(gen.make().Modifiers(modifiers, List.<JCTree.JCAnnotation>nil()), attrNameNm, type, null));\n            if (initialValue != null) {\n                // The attribute's initializer gets moved to the constructor\n                // because it might be using locals of the initializer\n                init(gen.make().Exec(gen.make().Assign(gen.makeSelect(\"this\", attrName), initialValue)));\n            }\n        } else {\n            // Otherwise it's local to the constructor\n            init(gen.make().VarDef(gen.make().Modifiers(modifiers, List.<JCTree.JCAnnotation>nil()), attrNameNm, type, initialValue));\n        }\n        return this;\n    }","id":51979,"modified_method":"public ClassDefinitionBuilder field(int modifiers, String attrName, JCExpression type, JCExpression initialValue, boolean isLocal) {\n        return field(modifiers, attrName, type, initialValue, isLocal, List.<JCTree.JCAnnotation>nil());\n    }","commit_id":"c201b10ee5cceaed06fa75c5dc25dea4b9505cd7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** Creates an anonymous class that extends Iterable and implements the specified comprehension.\n     */\n    public JCExpression transformComprehension(Comprehension comp) {\n        at(comp);\n        Tree.ComprehensionClause clause = comp.getForComprehensionClause();\n        ProducedType targetIterType = typeFact().getIterableType(clause.getTypeModel());\n        int idx = 0;\n        ExpressionComprehensionClause excc = null;\n        String prevItemVar = null;\n        String ctxtName = null;\n        //Iterator fields\n        ListBuffer<JCTree> fields = new ListBuffer<JCTree>();\n        HashSet<String> fieldNames = new HashSet<String>();\n        while (clause != null) {\n            final String iterVar = \"iter$\"+idx;\n            String itemVar = null;\n            //spread 1162\n            if (clause instanceof ForComprehensionClause) {\n\n                ForComprehensionClause fcl = (ForComprehensionClause)clause;\n                SpecifierExpression specexpr = fcl.getForIterator().getSpecifierExpression();\n                ProducedType iterType = specexpr.getExpression().getTypeModel();\n                JCExpression iterTypeExpr = makeJavaType(typeFact().getIteratorType(\n                        typeFact().getIteratedType(iterType)), CLASS_NEW|EXTENDS);\n                if (clause == comp.getForComprehensionClause()) {\n                    //The first iterator can be initialized as a field\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr,\n                        make().Apply(null, make().Select(transformExpression(specexpr.getExpression()),\n                            names().fromString(\"getIterator\")), List.<JCExpression>nil())));\n                    fieldNames.add(iterVar);\n                } else {\n                    //The subsequent iterators need to be inside a method,\n                    //in case they depend on the current element of the previous iterator\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr, null));\n                    fieldNames.add(iterVar);\n                    JCBlock body = make().Block(0l, List.<JCStatement>of(\n                            make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                                    make().Exec(make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil())),\n                                    null),\n                            make().Exec(make().Assign(makeUnquotedIdent(iterVar), make().Apply(null,\n                                    make().Select(transformExpression(specexpr.getExpression()),\n                                    names().fromString(\"getIterator\")), List.<JCExpression>nil()))),\n                            make().Return(makeUnquotedIdent(iterVar))\n                    ));\n                    fields.add(make().MethodDef(make().Modifiers(2),\n                            names().fromString(iterVar), iterTypeExpr, List.<JCTree.JCTypeParameter>nil(),\n                            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), body, null));\n                }\n                //Add the item var\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    Value item = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel();\n                    itemVar = item.getName();\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar), makeJavaType(item.getType(),NO_PRIMITIVES), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar+\"$exhausted\"),\n                        makeJavaType(typeFact().getBooleanDeclaration().getType()), null));\n                    fieldNames.add(itemVar);\n                } else if (fcl.getForIterator() instanceof KeyValueIterator) {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    itemVar = null;//compname+\"$item$\"+idx;\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getKeyVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getKeyVariable().getDeclarationModel().getType()), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getValueVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getValueVariable().getDeclarationModel().getType()), null));\n                    fieldNames.add(kviter.getKeyVariable().getDeclarationModel().getName());\n                    fieldNames.add(kviter.getValueVariable().getDeclarationModel().getName());\n                } else {\n                    return makeErroneous(fcl, \"No support yet for iterators of type \" + fcl.getForIterator().getClass().getName());\n                }\n\n                //Now the context for this iterator\n                ListBuffer<JCStatement> contextBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    //Subsequent iterators may depend on the item from the previous loop so we make sure we have one\n                    contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                            make().Exec(make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil())), null));\n                }\n\n                //Assign the next item to an Object variable\n                String tmpItem = tempName(\"item\");\n                contextBody.add(make().VarDef(make().Modifiers(0), names().fromString(tmpItem),\n                        makeJavaType(typeFact().getObjectDeclaration().getType()),\n                        make().Apply(null, make().Select(makeUnquotedIdent(iterVar), names().fromString(\"next\")), List.<JCExpression>nil())));\n                //Then we check if it's exhausted\n                contextBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar+\"$exhausted\"),\n                        make().Binary(JCTree.EQ, makeUnquotedIdent(tmpItem), makeFinished()))));\n                //Variables get assigned in the else block\n                ListBuffer<JCStatement> elseBody = new ListBuffer<JCStatement>();\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    ProducedType itemType = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel().getType();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar),\n                            make().TypeCast(makeJavaType(itemType,NO_PRIMITIVES), makeUnquotedIdent(tmpItem)))));\n                } else {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    Value key = kviter.getKeyVariable().getDeclarationModel();\n                    Value item = kviter.getValueVariable().getDeclarationModel();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(key.getName()),\n                            make().TypeCast(makeJavaType(key.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getKey\")), List.<JCExpression>nil()))))));\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(item.getName()),\n                            make().TypeCast(makeJavaType(item.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getItem\")), List.<JCExpression>nil()))))));\n                }\n                ListBuffer<JCStatement> innerBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    //Subsequent contexts run once for every iteration of the previous loop\n                    //This will reset our previous context by getting a new iterator if the previous loop isn't done\n                    innerBody.add(make().If(make().Binary(JCTree.EQ,\n                            make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil()), makeBoolean(true)),\n                            make().Block(0, List.<JCStatement>of(\n                                make().Exec(make().Assign(makeUnquotedIdent(iterVar),\n                                        make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil()))),\n                                make().Return(make().Apply(null,\n                                        make().Select(makeUnquotedIdent(\"this\"),\n                                        names().fromString(itemVar)), List.<JCExpression>nil()))\n                    )), null));\n                }\n                innerBody.add(make().Return(makeBoolean(false)));\n                //Assign the next item to the corresponding variables if not exhausted yet\n                contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(itemVar+\"$exhausted\"), makeBoolean(true)),\n                    make().Block(0, innerBody.toList()),\n                    make().Block(0, elseBody.toList())));\n                contextBody.add(make().Return(makeBoolean(true)));\n                //Create the context method that returns the next item for this iterator\n                ctxtName = itemVar;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(itemVar),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, contextBody.toList()), null));\n                clause = fcl.getComprehensionClause();\n\n            } else if (clause instanceof IfComprehensionClause) {\n\n                Condition cond = ((IfComprehensionClause)clause).getCondition();\n                //The context of an if is an iteration through the parent, checking each element against the condition\n                Variable var = null;\n                boolean reassign = false;\n                if (cond instanceof IsCondition || cond instanceof ExistsOrNonemptyCondition) {\n                    var = cond instanceof IsCondition ? ((IsCondition)cond).getVariable()\n                            : ((ExistsOrNonemptyCondition)cond).getVariable();\n                    //Initialize the condition's attribute to finished so that this is returned\n                    //in case the condition is not met and the iterator is exhausted\n                    var.getDeclarationModel().setUnboxed(false);\n                    if (!fieldNames.contains(var.getDeclarationModel().getName())) {\n                        fields.add(make().VarDef(make().Modifiers(2), names().fromString(var.getDeclarationModel().getName()),\n                                makeJavaType(var.getDeclarationModel().getType(),NO_PRIMITIVES), null));\n                        reassign = true;\n                    }\n                }\n                //Filter contexts need to check if the previous context applies and then check the condition\n                JCExpression condExpr = make().Binary(JCTree.EQ, make().Apply(null,\n                    make().Select(makeUnquotedIdent(\"this\"), names().fromString(ctxtName)), List.<JCExpression>nil()),\n                    makeBoolean(true));\n                //_AND_ the previous iterator condition with the comprehension's\n                final JCExpression otherCondition;\n                if (cond instanceof IsCondition) {\n                    JCExpression _expr = transformExpression(var.getSpecifierExpression().getExpression());\n                    String _varName = tempName(\"compr\");\n                    JCExpression test = makeTypeTest(null, _varName, ((IsCondition) cond).getType().getTypeModel());\n                    if (reassign) {\n                        otherCondition = makeLetExpr(_varName, List.<JCStatement>nil(), make().Type(syms().objectType), _expr, test);\n                    } else {\n                        otherCondition = make().Unary(JCTree.NOT, makeLetExpr(_varName, List.<JCStatement>nil(), make().Type(syms().objectType), _expr, test));\n                    }\n                } else if (cond instanceof ExistsCondition) {\n                    JCExpression expression = transformExpression(var.getSpecifierExpression().getExpression());\n                    otherCondition =  make().Binary(reassign ? JCTree.NE : JCTree.EQ, expression, makeNull());\n                } else if (cond instanceof NonemptyCondition) {\n                    JCExpression expression = transformExpression(var.getSpecifierExpression().getExpression());\n                    String varName = tempName();\n                    JCExpression test = makeNonEmptyTest(null, varName);\n                    if (reassign) {\n                        otherCondition = makeLetExpr(varName, List.<JCStatement>nil(), make().Type(syms().objectType), expression, test);\n                    } else {\n                        otherCondition = make().Unary(JCTree.NOT, makeLetExpr(varName, List.<JCStatement>nil(), make().Type(syms().objectType), expression, test));\n                    }\n                } else if (cond instanceof BooleanCondition) {\n                    otherCondition = make().Unary(JCTree.NOT, transformExpression(((BooleanCondition) cond).getExpression(),\n                            BoxingStrategy.UNBOXED, typeFact().getBooleanDeclaration().getType()));\n                } else {\n                    return makeErroneous(cond, \"This type of condition is not supported yet for comprehensions\");\n                }\n                condExpr = make().Binary(JCTree.AND, condExpr, otherCondition);\n                //Create the context method that filters from the last iterator\n                ctxtName = \"next\"+idx;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(ctxtName),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                        make().WhileLoop(condExpr, make().Block(0, reassign ? List.<JCStatement>of(\n                            //If there's a var, assign the last item to it\n                            make().If(make().Unary(JCTree.NOT, makeUnquotedIdent(prevItemVar+\"$exhausted\")),\n                                make().Exec(make().Assign(makeUnquotedIdent(var.getDeclarationModel().getName()),\n                                    make().TypeCast(makeJavaType(var.getDeclarationModel().getType(), NO_PRIMITIVES), transformExpression(var.getSpecifierExpression().getExpression())\n                                ))), null)\n                        ) : List.<JCStatement>nil())),\n                        make().Return(make().Unary(JCTree.NOT, makeUnquotedIdent(prevItemVar+\"$exhausted\")))\n                )), null));\n                clause = ((IfComprehensionClause)clause).getComprehensionClause();\n                itemVar = prevItemVar;\n\n            } else if (clause instanceof ExpressionComprehensionClause) {\n\n                //Just keep a reference to the expression\n                excc = (ExpressionComprehensionClause)clause;\n                at(excc);\n                clause = null;\n\n            } else {\n                return makeErroneous(clause, \"No support for comprehension clause of type \" + clause.getClass().getName());\n            }\n            idx++;\n            if (itemVar != null) prevItemVar = itemVar;\n        }\n\n        //Define the next() method for the Iterator\n        fields.add(make().MethodDef(make().Modifiers(1), names().fromString(\"next\"),\n            makeJavaType(typeFact().getObjectDeclaration().getType()), List.<JCTree.JCTypeParameter>nil(),\n            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                make().Return(\n                    make().Conditional(\n                        make().Binary(JCTree.EQ, make().Apply(null, make().Select(makeUnquotedIdent(\"this\"),\n                            names().fromString(ctxtName)), List.<JCExpression>nil()), makeBoolean(true)),\n                        transformExpression(excc.getExpression(), BoxingStrategy.BOXED, typeFact().getIteratedType(targetIterType)),\n                        makeFinished()))\n        )), null));\n        //Define the inner iterator class\n        ProducedType iteratorType = typeFact().getIteratorType(typeFact().getIteratedType(targetIterType));\n        JCExpression iterator = make().NewClass(null, null,makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), fields.toList()));\n        //Define the anonymous iterable class\n        JCExpression iterable = make().NewClass(null, null,\n                make().TypeApply(makeIdent(syms().ceylonAbstractIterableType),\n                    List.<JCExpression>of(makeJavaType(typeFact().getIteratedType(targetIterType), NO_PRIMITIVES))),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), List.<JCTree>of(\n                    make().MethodDef(make().Modifiers(1), names().fromString(\"getIterator\"),\n                        makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, List.<JCStatement>of(make().Return(iterator))), null)\n        )));\n        return iterable;\n    }","id":51980,"modified_method":"/** Creates an anonymous class that extends Iterable and implements the specified comprehension.\n     */\n    public JCExpression transformComprehension(Comprehension comp) {\n        at(comp);\n        Tree.ComprehensionClause clause = comp.getForComprehensionClause();\n        ProducedType targetIterType = typeFact().getIterableType(clause.getTypeModel());\n        int idx = 0;\n        ExpressionComprehensionClause excc = null;\n        String prevItemVar = null;\n        String ctxtName = null;\n        //Iterator fields\n        ListBuffer<JCTree> fields = new ListBuffer<JCTree>();\n        HashSet<String> fieldNames = new HashSet<String>();\n        while (clause != null) {\n            final String iterVar = \"iter$\"+idx;\n            String itemVar = null;\n            //spread 1162\n            if (clause instanceof ForComprehensionClause) {\n\n                ForComprehensionClause fcl = (ForComprehensionClause)clause;\n                SpecifierExpression specexpr = fcl.getForIterator().getSpecifierExpression();\n                ProducedType iterType = specexpr.getExpression().getTypeModel();\n                JCExpression iterTypeExpr = makeJavaType(typeFact().getIteratorType(\n                        typeFact().getIteratedType(iterType)), CLASS_NEW|EXTENDS);\n                if (clause == comp.getForComprehensionClause()) {\n                    //The first iterator can be initialized as a field\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr,\n                        make().Apply(null, make().Select(transformExpression(specexpr.getExpression()),\n                            names().fromString(\"getIterator\")), List.<JCExpression>nil())));\n                    fieldNames.add(iterVar);\n                } else {\n                    //The subsequent iterators need to be inside a method,\n                    //in case they depend on the current element of the previous iterator\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr, null));\n                    fieldNames.add(iterVar);\n                    JCBlock body = make().Block(0l, List.<JCStatement>of(\n                            make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                                    make().Exec(make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil())),\n                                    null),\n                            make().Exec(make().Assign(makeUnquotedIdent(iterVar), make().Apply(null,\n                                    make().Select(transformExpression(specexpr.getExpression()),\n                                    names().fromString(\"getIterator\")), List.<JCExpression>nil()))),\n                            make().Return(makeUnquotedIdent(iterVar))\n                    ));\n                    fields.add(make().MethodDef(make().Modifiers(2),\n                            names().fromString(iterVar), iterTypeExpr, List.<JCTree.JCTypeParameter>nil(),\n                            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), body, null));\n                }\n                //Add the item var\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    Value item = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel();\n                    itemVar = item.getName();\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar), makeJavaType(item.getType(),NO_PRIMITIVES), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar+\"$exhausted\"),\n                        makeJavaType(typeFact().getBooleanDeclaration().getType()), null));\n                    fieldNames.add(itemVar);\n                } else if (fcl.getForIterator() instanceof KeyValueIterator) {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    itemVar = null;//compname+\"$item$\"+idx;\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getKeyVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getKeyVariable().getDeclarationModel().getType()), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getValueVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getValueVariable().getDeclarationModel().getType()), null));\n                    fieldNames.add(kviter.getKeyVariable().getDeclarationModel().getName());\n                    fieldNames.add(kviter.getValueVariable().getDeclarationModel().getName());\n                } else {\n                    return makeErroneous(fcl, \"No support yet for iterators of type \" + fcl.getForIterator().getClass().getName());\n                }\n\n                //Now the context for this iterator\n                ListBuffer<JCStatement> contextBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    //Subsequent iterators may depend on the item from the previous loop so we make sure we have one\n                    contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                            make().Exec(make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil())), null));\n                }\n\n                //Assign the next item to an Object variable\n                String tmpItem = tempName(\"item\");\n                contextBody.add(make().VarDef(make().Modifiers(0), names().fromString(tmpItem),\n                        makeJavaType(typeFact().getObjectDeclaration().getType()),\n                        make().Apply(null, make().Select(makeUnquotedIdent(iterVar), names().fromString(\"next\")), List.<JCExpression>nil())));\n                //Then we check if it's exhausted\n                contextBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar+\"$exhausted\"),\n                        make().Binary(JCTree.EQ, makeUnquotedIdent(tmpItem), makeFinished()))));\n                //Variables get assigned in the else block\n                ListBuffer<JCStatement> elseBody = new ListBuffer<JCStatement>();\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    ProducedType itemType = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel().getType();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar),\n                            make().TypeCast(makeJavaType(itemType,NO_PRIMITIVES), makeUnquotedIdent(tmpItem)))));\n                } else {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    Value key = kviter.getKeyVariable().getDeclarationModel();\n                    Value item = kviter.getValueVariable().getDeclarationModel();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(key.getName()),\n                            make().TypeCast(makeJavaType(key.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getKey\")), List.<JCExpression>nil()))))));\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(item.getName()),\n                            make().TypeCast(makeJavaType(item.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getItem\")), List.<JCExpression>nil()))))));\n                }\n                ListBuffer<JCStatement> innerBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    //Subsequent contexts run once for every iteration of the previous loop\n                    //This will reset our previous context by getting a new iterator if the previous loop isn't done\n                    innerBody.add(make().If(make().Binary(JCTree.EQ,\n                            make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil()), makeBoolean(true)),\n                            make().Block(0, List.<JCStatement>of(\n                                make().Exec(make().Assign(makeUnquotedIdent(iterVar),\n                                        make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil()))),\n                                make().Return(make().Apply(null,\n                                        make().Select(makeUnquotedIdent(\"this\"),\n                                        names().fromString(itemVar)), List.<JCExpression>nil()))\n                    )), null));\n                }\n                innerBody.add(make().Return(makeBoolean(false)));\n                //Assign the next item to the corresponding variables if not exhausted yet\n                contextBody.add(make().If( makeUnquotedIdent(itemVar+\"$exhausted\"),\n                    make().Block(0, innerBody.toList()),\n                    make().Block(0, elseBody.toList())));\n                contextBody.add(make().Return(makeBoolean(true)));\n                //Create the context method that returns the next item for this iterator\n                ctxtName = itemVar;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(itemVar),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, contextBody.toList()), null));\n                clause = fcl.getComprehensionClause();\n\n            } else if (clause instanceof IfComprehensionClause) {\n\n                Condition cond = ((IfComprehensionClause)clause).getCondition();\n                //The context of an if is an iteration through the parent, checking each element against the condition\n                Variable var = null;\n                boolean reassign = false;\n                if (cond instanceof IsCondition || cond instanceof ExistsOrNonemptyCondition) {\n                    var = cond instanceof IsCondition ? ((IsCondition)cond).getVariable()\n                            : ((ExistsOrNonemptyCondition)cond).getVariable();\n                    //Initialize the condition's attribute to finished so that this is returned\n                    //in case the condition is not met and the iterator is exhausted\n                    var.getDeclarationModel().setUnboxed(false);\n                    if (!fieldNames.contains(var.getDeclarationModel().getName())) {\n                        fields.add(make().VarDef(make().Modifiers(2), names().fromString(var.getDeclarationModel().getName()),\n                                makeJavaType(var.getDeclarationModel().getType(),NO_PRIMITIVES), null));\n                        reassign = true;\n                    }\n                }\n                //Filter contexts need to check if the previous context applies and then check the condition\n                JCExpression condExpr = make().Apply(null,\n                    make().Select(makeUnquotedIdent(\"this\"), names().fromString(ctxtName)), List.<JCExpression>nil());\n                //_AND_ the previous iterator condition with the comprehension's\n                final JCExpression otherCondition;\n                if (cond instanceof IsCondition) {\n                    JCExpression _expr = transformExpression(var.getSpecifierExpression().getExpression());\n                    String _varName = tempName(\"compr\");\n                    JCExpression test = makeTypeTest(null, _varName, ((IsCondition) cond).getType().getTypeModel());\n                    test = makeLetExpr(_varName, List.<JCStatement>nil(), make().Type(syms().objectType), _expr, test);\n                    if (reassign) {\n                        _expr = make().Assign(makeUnquotedIdent(var.getDeclarationModel().getName()),\n                                make().Conditional(test, make().TypeCast(makeJavaType(var.getDeclarationModel().getType(), NO_PRIMITIVES), _expr), makeNull()));\n                        otherCondition = make().Binary(JCTree.EQ, _expr, makeNull());\n                    } else {\n                        otherCondition = make().Unary(JCTree.NOT, test);\n                    }\n\n                } else if (cond instanceof ExistsCondition) {\n                    JCExpression expression = transformExpression(var.getSpecifierExpression().getExpression());\n                    if (reassign) {\n                        //Assign the expression, check it's not null\n                        expression = make().Assign(makeUnquotedIdent(var.getDeclarationModel().getName()), expression);\n                    }\n                    otherCondition =  make().Binary(JCTree.EQ, expression, makeNull());\n\n                } else if (cond instanceof NonemptyCondition) {\n                    JCExpression expression = transformExpression(var.getSpecifierExpression().getExpression());\n                    String varName = tempName(\"compr\");\n                    JCExpression test = makeNonEmptyTest(null, varName);\n                    test = makeLetExpr(varName, List.<JCStatement>nil(), make().Type(syms().objectType), expression, test);\n                    if (reassign) {\n                        //Assign the expression if it's nonempty\n                        expression = make().Assign(makeUnquotedIdent(var.getDeclarationModel().getName()),\n                                make().Conditional(test, make().TypeCast(makeJavaType(var.getDeclarationModel().getType(), NO_PRIMITIVES), expression), makeNull()));\n                        otherCondition = make().Binary(JCTree.EQ, expression, makeNull());\n                    } else {\n                        otherCondition = make().Unary(JCTree.NOT, test);\n                    }\n\n                } else if (cond instanceof BooleanCondition) {\n                    otherCondition = make().Unary(JCTree.NOT, transformExpression(((BooleanCondition) cond).getExpression(),\n                        BoxingStrategy.UNBOXED, typeFact().getBooleanDeclaration().getType()));\n                } else {\n                    return makeErroneous(cond, \"This type of condition is not supported yet for comprehensions\");\n                }\n                condExpr = make().Binary(JCTree.AND, condExpr, otherCondition);\n                //Create the context method that filters from the last iterator\n                ctxtName = \"next\"+idx;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(ctxtName),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                        make().WhileLoop(condExpr, make().Block(0, List.<JCStatement>nil())),\n                        make().Return(make().Unary(JCTree.NOT, makeUnquotedIdent(prevItemVar+\"$exhausted\")))\n                )), null));\n                clause = ((IfComprehensionClause)clause).getComprehensionClause();\n                itemVar = prevItemVar;\n\n            } else if (clause instanceof ExpressionComprehensionClause) {\n\n                //Just keep a reference to the expression\n                excc = (ExpressionComprehensionClause)clause;\n                at(excc);\n                clause = null;\n\n            } else {\n                return makeErroneous(clause, \"No support for comprehension clause of type \" + clause.getClass().getName());\n            }\n            idx++;\n            if (itemVar != null) prevItemVar = itemVar;\n        }\n\n        //Define the next() method for the Iterator\n        fields.add(make().MethodDef(make().Modifiers(1), names().fromString(\"next\"),\n            makeJavaType(typeFact().getObjectDeclaration().getType()), List.<JCTree.JCTypeParameter>nil(),\n            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                make().Return(\n                    make().Conditional(\n                        make().Apply(null, make().Select(makeUnquotedIdent(\"this\"),\n                            names().fromString(ctxtName)), List.<JCExpression>nil()),\n                        transformExpression(excc.getExpression(), BoxingStrategy.BOXED, typeFact().getIteratedType(targetIterType)),\n                        makeFinished()))\n        )), null));\n        //Define the inner iterator class\n        ProducedType iteratorType = typeFact().getIteratorType(typeFact().getIteratedType(targetIterType));\n        JCExpression iterator = make().NewClass(null, null,makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), fields.toList()));\n        //Define the anonymous iterable class\n        JCExpression iterable = make().NewClass(null, null,\n                make().TypeApply(makeIdent(syms().ceylonAbstractIterableType),\n                    List.<JCExpression>of(makeJavaType(typeFact().getIteratedType(targetIterType), NO_PRIMITIVES))),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), List.<JCTree>of(\n                    make().MethodDef(make().Modifiers(1), names().fromString(\"getIterator\"),\n                        makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, List.<JCStatement>of(make().Return(iterator))), null)\n        )));\n        return iterable;\n    }","commit_id":"108ebf97e067ccec1abc2023816a921e5b80b473","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transformWrappedMethod(Tree.MethodDefinition decl) {\n        // Generate a wrapper class for the method\n        String name = decl.getIdentifier().getText();\n        JCTree.JCIdent nameId = make().Ident(names().fromString(Util.quoteIfJavaKeyword(name)));\n        ClassDefinitionBuilder builder = ClassDefinitionBuilder.methodWrapper(this, name, Decl.isShared(decl));\n        builder.body(classGen().transform(decl));\n        if (Decl.withinMethod(decl)) {\n            // Inner method\n            List<JCTree> result = builder.build();\n            JCVariableDecl call = at(decl).VarDef(\n                    make().Modifiers(FINAL),\n                    names().fromString(name),\n                    nameId,\n                    at(decl).NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null));\n            return result.append(call);\n        } else {\n            // Toplevel method\n            if (decl.getParameterLists().size() > 0 && decl.getParameterLists().get(0).getParameters().size() == 0) {\n                // Add a main() method\n                MethodDefinitionBuilder methbuilder = MethodDefinitionBuilder.main(this);\n                // Add call to process.setupArguments\n                JCIdent argsId = make().Ident(names().fromString(\"args\"));\n                JCMethodInvocation processExpr = at(decl).Apply(null, makeIdent(\"ceylon\", \"language\", \"process\", \"getProcess\"), List.<JCTree.JCExpression>nil());\n                methbuilder.body(make().Exec(at(decl).Apply(null, makeSelect(processExpr, \"setupArguments\"), List.<JCTree.JCExpression>of(argsId))));\n                // Add call to toplevel method\n                methbuilder.body(make().Exec(at(decl).Apply(null, nameId, List.<JCTree.JCExpression>nil())));\n                builder.body(methbuilder.build());\n            }\n            return builder.build();                \n        }\n    }","id":51981,"modified_method":"public List<JCTree> transformWrappedMethod(Tree.MethodDefinition def) {\n        // Generate a wrapper class for the method\n        String name = def.getIdentifier().getText();\n        JCTree.JCIdent nameId = make().Ident(names().fromString(Util.quoteIfJavaKeyword(name)));\n        ClassDefinitionBuilder builder = ClassDefinitionBuilder.methodWrapper(this, name, Decl.isShared(def));\n        builder.body(classGen().transform(def));\n        if (Decl.withinMethod(def)) {\n            // Inner method\n            List<JCTree> result = builder.build();\n            JCVariableDecl call = at(def).VarDef(\n                    make().Modifiers(FINAL),\n                    names().fromString(name),\n                    nameId,\n                    at(def).NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null));\n            return result.append(call);\n        } else {\n            // Toplevel method\n            if (!def.getParameterLists().isEmpty() && def.getParameterLists().get(0).getParameters().isEmpty()) {\n                // Add a main() method\n                builder.body(makeMainMethod(make().Apply(null, nameId, List.<JCTree.JCExpression>nil())));\n            }\n            return builder.build();                \n        }\n    }","commit_id":"39cdcce5ee64a48973754d66e202c9d3947483f8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder.klass(this, className);\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        return classBuilder\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","id":51982,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder.klass(this, className);\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (def instanceof Tree.AnyClass && Decl.isToplevel(def) && Decl.isShared(def)) {\n            com.redhat.ceylon.compiler.typechecker.model.Class c = (com.redhat.ceylon.compiler.typechecker.model.Class) def.getDeclarationModel();\n            if (c.getParameterList().getParameters().isEmpty()) {\n                // Add a main() method\n                JCTree.JCIdent nameId = make().Ident(names().fromString(Util.quoteIfJavaKeyword(className)));\n                JCNewClass expr = make().NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null);\n                classBuilder.body(makeMainMethod(expr));\n            }\n        }\n        \n        return classBuilder\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","commit_id":"39cdcce5ee64a48973754d66e202c9d3947483f8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.callBuilder = CallBuilder.instance(gen);\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        \n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            this.primaryTypeArguments = transformTypeArguments(gen, ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels());\n        } else {\n            this.primaryTypeArguments = transformTypeArguments(gen, null);\n        }\n        if (primary instanceof Tree.QualifiedMemberOrTypeExpression){\n            this.qmePrimary = ((Tree.QualifiedMemberOrTypeExpression) primary).getPrimary();\n            this.onValueType = Decl.isValueTypeDecl(qmePrimary);\n        } else {\n            this.qmePrimary = null;\n            this.onValueType = false;\n        }\n    }","id":51983,"modified_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.callBuilder = CallBuilder.instance(gen);\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        \n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            transformTypeArguments(gen, ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels());\n        } else {\n            transformTypeArguments(gen, null);\n        }\n        if (primary instanceof Tree.QualifiedMemberOrTypeExpression){\n            this.qmePrimary = ((Tree.QualifiedMemberOrTypeExpression) primary).getPrimary();\n            this.onValueType = Decl.isValueTypeDecl(qmePrimary);\n        } else {\n            this.qmePrimary = null;\n            this.onValueType = false;\n        }\n    }","commit_id":"c1b01f26e5e1c37b63ef6b6fa849118d3eee3a89","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformInvocation(\n            TransformedInvocationPrimary transformedPrimary) {\n        callBuilder.typeArguments(primaryTypeArguments);\n        if (onValueType) {\n            JCExpression primTypeExpr = gen.makeJavaType(qmePrimary.getTypeModel(), JT_NO_PRIMITIVES);\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(primTypeExpr, transformedPrimary.selector));\n        } else {\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(transformedPrimary.expr, transformedPrimary.selector));\n        }\n        return callBuilder.build();\n    }","id":51984,"modified_method":"private JCExpression transformInvocation(\n            TransformedInvocationPrimary transformedPrimary) {\n        if (onValueType) {\n            JCExpression primTypeExpr = gen.makeJavaType(qmePrimary.getTypeModel(), JT_NO_PRIMITIVES);\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(primTypeExpr, transformedPrimary.selector));\n        } else {\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(transformedPrimary.expr, transformedPrimary.selector));\n        }\n        return callBuilder.build();\n    }","commit_id":"c1b01f26e5e1c37b63ef6b6fa849118d3eee3a89","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        \n        this.callBuilder.typeArguments(primaryTypeArguments)\n            .invoke(gen.naming.makeQuotedQualIdent(callable, Naming.getCallableMethodName()));\n        \n        transformArgumentList(null);\n        JCExpression result = this.callBuilder.build();\n        if(handleBoxing)\n            result = gen.expressionGen().applyErasureAndBoxing(result, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return result;\n    }","id":51985,"modified_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        \n        this.callBuilder\n            .invoke(gen.naming.makeQuotedQualIdent(callable, Naming.getCallableMethodName()));\n        \n        transformArgumentList(null);\n        JCExpression result = this.callBuilder.build();\n        if(handleBoxing)\n            result = gen.expressionGen().applyErasureAndBoxing(result, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return result;\n    }","commit_id":"c1b01f26e5e1c37b63ef6b6fa849118d3eee3a89","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"static final List<JCExpression> transformTypeArguments(\n            AbstractTransformer gen,\n            java.util.List<ProducedType> typeArguments) {\n        List<JCExpression> result = List.<JCExpression> nil();\n        if(typeArguments != null){\n            for (ProducedType arg : typeArguments) {\n                // cancel type parameters and go raw if we can't specify them\n                if(gen.willEraseToObject(arg) || gen.willEraseToSequential(arg))\n                    return List.nil();\n                result = result.append(gen.makeJavaType(arg, JT_TYPE_ARGUMENT));\n            }\n        }\n        return result;\n    }","id":51986,"modified_method":"private void transformTypeArguments(\n            AbstractTransformer gen,\n            java.util.List<ProducedType> typeArguments) {\n        if(typeArguments != null){\n            for (ProducedType arg : typeArguments) {\n                // cancel type parameters and go raw if we can't specify them\n                if(gen.willEraseToObject(arg) || gen.willEraseToSequential(arg)) {\n                    this.callBuilder.typeArguments(List.<JCExpression>nil());\n                }\n                this.callBuilder.typeArgument(gen.makeJavaType(arg, JT_TYPE_ARGUMENT));\n            }\n        }\n    }","commit_id":"c1b01f26e5e1c37b63ef6b6fa849118d3eee3a89","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n   * Clean the blocks that have been evicted from evicting list in each StorageDir\n   */\n  protected void cleanEvictingBlockIds() {\n    List<Pair<StorageDir, Long>> outdatedBlocks = new ArrayList<Pair<StorageDir, Long>>();\n    for (Entry<StorageDir, Long> block : mEvictingBlockIds.entries()) {\n      StorageDir dir = block.getKey();\n      long blockId = block.getValue();\n      // If the block has been evicted, mark it outdated\n      if (!dir.containsBlock(blockId)) {\n        outdatedBlocks.add(new Pair<StorageDir, Long>(dir, blockId));\n      }\n    }\n    for (Pair<StorageDir, Long> block : outdatedBlocks) {\n      mEvictingBlockIds.remove(block.getFirst(), block.getSecond());\n    }\n  }","id":51987,"modified_method":"/**\n   * Clean the blocks that have been evicted from evicting list in each StorageDir\n   */\n  protected void cleanEvictingBlockIds() {\n    Iterator<Entry<StorageDir, Long>> iterator = mEvictingBlockIds.entries().iterator();\n    while (iterator.hasNext()) {\n      Entry<StorageDir, Long> block = iterator.next();\n      StorageDir dir = block.getKey();\n      long blockId = block.getValue();\n      if (!dir.containsBlock(blockId)) {\n        iterator.remove();\n      }\n    }\n  }","commit_id":"1b3aee0b15cdd6351573f914e6c1ac65e7de0ab1","url":"https://github.com/amplab/tachyon"},{"original_method":"public synchronized java.util.Properties asProperties() {\n        final java.util.Properties props = new java.util.Properties();\n\n        for (Map.Entry<String,?> e : entries())  {\n            put(e.getKey(), e.getValue().toString());\n        }\n\n        return props;\n    }","id":51988,"modified_method":"public synchronized java.util.Properties asProperties() {\n        final java.util.Properties props = new java.util.Properties();\n\n        for (Map.Entry e : entries())\n            props.put(e.getKey().toString(), e.getValue().toString());\n\n        return props;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean containsEntry(String key, String value) {\n        return mData.containsEntry(key, value);\n    }","id":51989,"modified_method":"public boolean containsEntry(String key, String value) {\n        return mData.containsEntry(Key.instance(key), value);\n        //return mData.containsEntry(key, value);\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public String getString(String key) {\n        return getFirstValue(key);\n//         Object v = get(key);\n//         return v == null ? null : v.toString();\n    }","id":51990,"modified_method":"/** @return first value found for key as a string: current impl identical to getFirstString */\n    // if there are multiple values for the given key, this someday could return a string\n    // that concatenates all the values with a delimiter\n    public String getString(String key) {\n        return getFirstString(key);\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"/** remove ALL values having the given key */\n    public synchronized Object remove(Object key) {\n\n        //final Object prior = super.remove(key);\n        final Object prior = mData.removeAll(key);\n        //final Object prior = mData.remove(key);\n\n        if (prior != null) {\n\n            //mTotalSize--;\n            //Util.printStackTrace(\"remove used; key=\" + Util.tags(key) + \"; prior=\" + Util.tags(prior));\n            \n            if (mHoldingChanges)\n                mChanges++;\n            else if (mTableModel != null)\n                mTableModel.reload();\n        }\n\n        return prior;\n    }","id":51991,"modified_method":"/** remove ALL values having the given key */\n    public synchronized Object remove(Object key) {\n\n        final Object prior = mData.removeAll(key);\n\n        if (prior != null)\n            markChange();\n\n        return prior;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public MetaMap clone() throws CloneNotSupportedException {\n        final MetaMap clone = (MetaMap) super.clone();\n        clone.listeners = null;\n        clone.mChanges = 0;\n        clone.mTableModel = null;\n        return clone;\n    }","id":51992,"modified_method":"@Override\n    public MetaMap clone() {\n        final MetaMap clone = new MetaMap();\n        clone.mData.putAll(mData);\n        return clone;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public synchronized void addListener(Listener l) {\n        if (listeners == null)\n            listeners = new java.util.ArrayList();\n        listeners.add(l);\n    }","id":51993,"modified_method":"public synchronized void addListener(TableBag.Listener l) {\n        if (listeners == null)\n            listeners = new java.util.ArrayList();\n        listeners.add(l);\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean containsKey(String key) {\n        return mData.containsKey(key);\n    }","id":51994,"modified_method":"public boolean containsKey(String key) {\n        // can we optimize if the key-cache finds to key at all to look up?\n        // I think only if we also case-fold the key-cache.\n        return mData.containsKey(Key.instance(key));\n        //return mData.containsKey(key);\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public javax.swing.table.TableModel getTableModel() {\n        // mTableModel is volatile, so as of Java 1.5, the double-checked locking\n        // idiom used here should work.\n        if (mTableModel == null) {\n            synchronized (mTableModel_LOCK) {\n                if (mTableModel == null)\n                    mTableModel = new SortedMapModel();\n            }\n        }\n        return mTableModel;\n    }","id":51995,"modified_method":"public javax.swing.table.TableModel getTableModel() {\n        // mTableModel is volatile, so as of Java 1.5, the double-checked locking\n        // idiom used here should work.\n        if (mTableModel == null) {\n            synchronized (mData) { // sync on anything other than \"this\" just in case\n                if (mTableModel == null)\n                    mTableModel = new MapModel();\n            }\n        }\n        return mTableModel;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"/** @return the property value for the given key, dereferened if an instanceof java.lang.ref.Reference is found */\n    public Object getValue(String key) {\n\n        Object o = get(key);\n            \n        if (o instanceof Reference) {\n            o = ((Reference)o).get();\n            if (o == null) {\n                if (DEBUG.Enabled) Log.debug(\"value was GC'd for key: \" + key);\n                mData.remove(key, o); // don't need to see it again\n            }\n        }\n        \n        return o;\n    }","id":51996,"modified_method":"/** @return the property value for the given key, dereferened if an instanceof java.lang.ref.Reference is found */\n    public Object getValue(String key) {\n\n        Object o = getFirst(key);\n            \n        if (o instanceof Reference) {\n            o = ((Reference)o).get();\n            if (o == null) {\n                if (DEBUG.Enabled) Log.debug(\"value was GC'd for key: \" + key);\n                //mData.remove(Key.instance(key), o); // don't need to see it again\n            }\n        }\n        \n        return o;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"/** add the given key/value, only if the value is considered \"non-empty\"\n     * Empty values currently include null, zero length Strings, and empty Collections */\n    public void addNonEmpty(String key, Object value) {\n        if (!isEmpty(value))\n            put(key, value);\n    }","id":51997,"modified_method":"/** set the given key/value, only if the value is considered \"non-empty\" */\n    public void setNonEmpty(String key, Object value) {\n        if (!isEmpty(value))\n            set(key, value);\n        //else if (DEBUG.DATA) Log.debug(\"EMPTY: \" + Util.tags(value));\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"private static boolean isEmpty(Object v) {\n        if (v == null)\n            return false;\n        else if (v.getClass() == String.class && v.toString().length() == 0)\n            return false;\n        else if (v instanceof Collection && ((Collection)v).size() == 0)\n            return false;\n        else\n            return true;\n    }","id":51998,"modified_method":"/** @return true if the given value is considered \"empty\", e.g., a null,\n     * 0 length string, or zero size collection */\n    private static boolean isEmpty(Object v) {\n        if (v == null)\n            return true;\n        else if (v.getClass() == String.class && v.toString().length() == 0)\n            return true;\n        else if (v instanceof Collection && ((Collection)v).size() == 0)\n            return true;\n        else\n            return false;\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"},{"original_method":"public synchronized void removeListener(Listener l) {\n            \n        // Note: we can DEADLOCK here in AWT obtaining the method entry lock if this\n        // PropertyMap instance is already locked by an ImageLoader thread.\n            \n        if (listeners != null)\n            listeners.remove(l);\n    }","id":51999,"modified_method":"public synchronized void removeListener(TableBag.Listener l) {\n            \n        // Note: we can DEADLOCK here in AWT obtaining the method entry lock if this\n        // MetaMap instance is already locked by an ImageLoader thread.\n            \n        if (listeners != null)\n            listeners.remove(l);\n    }","commit_id":"8e3c2010d2a0e1e0f4312c17b8f45c9b0d88c8f8","url":"https://github.com/VUE/VUE"}]