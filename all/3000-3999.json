[{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WysiwygServiceAsync#getImageAttachments(String, String, String, AsyncCallback)\n     */\n    public void getImageAttachments(String wikiName, String spaceName, String pageName,\n        AsyncCallback<Map<String, String>> async)\n    {\n        service.getImageAttachments(wikiName, spaceName, pageName, async);\n    }","id":3000,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WysiwygServiceAsync#getImageAttachments(String, String, String, AsyncCallback)\n     */\n    public void getImageAttachments(String wikiName, String spaceName, String pageName,\n        AsyncCallback<List<ImageConfig>> async)\n    {\n        service.getImageAttachments(wikiName, spaceName, pageName, async);\n    }","commit_id":"caefd24ff7b830e33cf143f3d6d83d2e0677f07f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void _addReturnElement(\r\n\t\t\tElement methodElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tType returns = javaMethod.getReturns();\r\n\r\n\t\tif (returns == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tString returnsValue = returns.getValue();\r\n\r\n\t\tif (returnsValue.equals(\"void\")) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tElement returnElement = methodElement.addElement(\"return\");\r\n\r\n\t\tElement commentElement = returnElement.addElement(\"comment\");\r\n\r\n\t\tDocletTag[] returnDocletTags = javaMethod.getTagsByName(\"return\");\r\n\r\n\t\tString comment = StringPool.BLANK;\r\n\r\n\t\tif (returnDocletTags.length > 0) {\r\n\t\t\tDocletTag returnDocletTag = returnDocletTags[0];\r\n\r\n\t\t\tcomment = GetterUtil.getString(returnDocletTag.getValue());\r\n\t\t}\r\n\r\n\t\tcomment = _trimMultilineText(comment);\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","id":3001,"modified_method":"private void _addReturnElement(\r\n\t\t\tElement methodElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tType returns = javaMethod.getReturns();\r\n\r\n\t\tif (returns == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tString returnsValue = returns.getValue();\r\n\r\n\t\tif (returnsValue.equals(\"void\")) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDocletTag[] returnDocletTags = javaMethod.getTagsByName(\"return\");\r\n\r\n\t\tString comment = StringPool.BLANK;\r\n\r\n\t\tif (returnDocletTags.length > 0) {\r\n\t\t\tDocletTag returnDocletTag = returnDocletTags[0];\r\n\r\n\t\t\tcomment = GetterUtil.getString(returnDocletTag.getValue());\r\n\t\t}\r\n\r\n\t\tcomment = _trimMultilineText(comment);\r\n\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement returnElement = methodElement.addElement(\"return\");\r\n\r\n\t\t\tElement commentElement = returnElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(comment);\r\n\t\t}\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addFieldElement(Element rootElement, JavaField javaField)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement fieldElement = rootElement.addElement(\"field\");\r\n\r\n\t\tDocUtil.add(fieldElement, \"name\", javaField.getName());\r\n\r\n\t\tElement commentElement = fieldElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(javaField));\r\n\r\n\t\t_addDocletElements(fieldElement, javaField, \"version\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"see\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"since\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"deprecated\");\r\n\t}","id":3002,"modified_method":"private void _addFieldElement(Element rootElement, JavaField javaField)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement fieldElement = rootElement.addElement(\"field\");\r\n\r\n\t\tDocUtil.add(fieldElement, \"name\", javaField.getName());\r\n\r\n\t\tString comment = _getCDATA(javaField);\r\n\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement commentElement = fieldElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(comment);\r\n\t\t}\r\n\r\n\t\t_addDocletElements(fieldElement, javaField, \"version\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"see\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"since\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"deprecated\");\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addClassCommentElement(\r\n\t\tElement rootElement, JavaClass javaClass) {\r\n\r\n\t\tElement commentElement = rootElement.addElement(\"comment\");\r\n\r\n\t\tString comment = _getCDATA(javaClass);\r\n\r\n\t\tif (comment.startsWith(\"Copyright (c) 2000-2010 Liferay, Inc.\")) {\r\n\t\t\tcomment = StringPool.BLANK;\r\n\t\t}\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","id":3003,"modified_method":"private void _addClassCommentElement(\r\n\t\tElement rootElement, JavaClass javaClass) {\r\n\r\n\t\tString comment = _getCDATA(javaClass);\r\n\r\n\t\tif (comment.startsWith(\"Copyright (c) 2000-2010 Liferay, Inc.\")) {\r\n\t\t\tcomment = StringPool.BLANK;\r\n\t\t}\r\n\r\n\t\tif (Validator.isNull(comment)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tElement commentElement = rootElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addParamElement(\r\n\t\tElement methodElement, JavaParameter javaParameter,\r\n\t\tDocletTag[] paramDocletTags) {\r\n\r\n\t\tString name = javaParameter.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\r\n\t\t\tString curValue = paramDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement paramElement = methodElement.addElement(\"param\");\r\n\r\n\t\tDocUtil.add(paramElement, \"name\", name);\r\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tElement commentElement = paramElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(value);\r\n\t}","id":3004,"modified_method":"private void _addParamElement(\r\n\t\tElement methodElement, JavaParameter javaParameter,\r\n\t\tDocletTag[] paramDocletTags) {\r\n\r\n\t\tString name = javaParameter.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\r\n\t\t\tString curValue = paramDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement paramElement = methodElement.addElement(\"param\");\r\n\r\n\t\tDocUtil.add(paramElement, \"name\", name);\r\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tif (Validator.isNotNull(value)) {\r\n\t\t\tElement commentElement = paramElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(value);\r\n\t\t}\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addMethodElement(Element rootElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement methodElement = rootElement.addElement(\"method\");\r\n\r\n\t\tDocUtil.add(methodElement, \"name\", javaMethod.getName());\r\n\r\n\t\tElement commentElement = methodElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(javaMethod));\r\n\r\n\t\t_addDocletElements(methodElement, javaMethod, \"version\");\r\n\t\t_addParamElements(methodElement, javaMethod);\r\n\t\t_addReturnElement(methodElement, javaMethod);\r\n\t\t_addThrowsElements(methodElement, javaMethod);\r\n\t\t_addDocletElements(methodElement, javaMethod, \"see\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"since\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"deprecated\");\r\n\t}","id":3005,"modified_method":"private void _addMethodElement(Element rootElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement methodElement = rootElement.addElement(\"method\");\r\n\r\n\t\tDocUtil.add(methodElement, \"name\", javaMethod.getName());\r\n\r\n\t\tString comment = _getCDATA(javaMethod);\r\n\t\t\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement commentElement = methodElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(_getCDATA(javaMethod));\r\n\t\t}\r\n\r\n\t\t_addDocletElements(methodElement, javaMethod, \"version\");\r\n\t\t_addParamElements(methodElement, javaMethod);\r\n\t\t_addReturnElement(methodElement, javaMethod);\r\n\t\t_addThrowsElements(methodElement, javaMethod);\r\n\t\t_addDocletElements(methodElement, javaMethod, \"see\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"since\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"deprecated\");\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addThrowsElement(\r\n\t\tElement methodElement, Type exceptionType,\r\n\t\tDocletTag[] throwsDocletTags) {\r\n\r\n\t\tJavaClass javaClass = exceptionType.getJavaClass();\r\n\r\n\t\tString name = javaClass.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag throwsDocletTag : throwsDocletTags) {\r\n\t\t\tString curValue = throwsDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement throwsElement = methodElement.addElement(\"throws\");\r\n\r\n\t\tDocUtil.add(throwsElement, \"name\", name);\r\n\t\tDocUtil.add(throwsElement, \"type\", exceptionType.getValue());\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tElement commentElement = throwsElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(value));\r\n\t}","id":3006,"modified_method":"private void _addThrowsElement(\r\n\t\tElement methodElement, Type exceptionType,\r\n\t\tDocletTag[] throwsDocletTags) {\r\n\r\n\t\tJavaClass javaClass = exceptionType.getJavaClass();\r\n\r\n\t\tString name = javaClass.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag throwsDocletTag : throwsDocletTags) {\r\n\t\t\tString curValue = throwsDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement throwsElement = methodElement.addElement(\"throws\");\r\n\r\n\t\tDocUtil.add(throwsElement, \"name\", name);\r\n\t\tDocUtil.add(throwsElement, \"type\", exceptionType.getValue());\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tif (Validator.isNotNull(value)) {\r\n\t\t\tElement commentElement = throwsElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(_getCDATA(value));\r\n\t\t}\r\n\t}","commit_id":"441b9b73f67b62ff36e797e571508d2da73ba8e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addReturnElement(\r\n\t\t\tElement methodElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tType returns = javaMethod.getReturns();\r\n\r\n\t\tif (returns == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tString returnsValue = returns.getValue();\r\n\r\n\t\tif (returnsValue.equals(\"void\")) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tElement returnElement = methodElement.addElement(\"return\");\r\n\r\n\t\tElement commentElement = returnElement.addElement(\"comment\");\r\n\r\n\t\tDocletTag[] returnDocletTags = javaMethod.getTagsByName(\"return\");\r\n\r\n\t\tString comment = StringPool.BLANK;\r\n\r\n\t\tif (returnDocletTags.length > 0) {\r\n\t\t\tDocletTag returnDocletTag = returnDocletTags[0];\r\n\r\n\t\t\tcomment = GetterUtil.getString(returnDocletTag.getValue());\r\n\t\t}\r\n\r\n\t\tcomment = _trimMultilineText(comment);\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","id":3007,"modified_method":"private void _addReturnElement(\r\n\t\t\tElement methodElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tType returns = javaMethod.getReturns();\r\n\r\n\t\tif (returns == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tString returnsValue = returns.getValue();\r\n\r\n\t\tif (returnsValue.equals(\"void\")) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDocletTag[] returnDocletTags = javaMethod.getTagsByName(\"return\");\r\n\r\n\t\tString comment = StringPool.BLANK;\r\n\r\n\t\tif (returnDocletTags.length > 0) {\r\n\t\t\tDocletTag returnDocletTag = returnDocletTags[0];\r\n\r\n\t\t\tcomment = GetterUtil.getString(returnDocletTag.getValue());\r\n\t\t}\r\n\r\n\t\tcomment = _trimMultilineText(comment);\r\n\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement returnElement = methodElement.addElement(\"return\");\r\n\r\n\t\t\tElement commentElement = returnElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(comment);\r\n\t\t}\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addThrowsElement(\r\n\t\tElement methodElement, Type exceptionType,\r\n\t\tDocletTag[] throwsDocletTags) {\r\n\r\n\t\tJavaClass javaClass = exceptionType.getJavaClass();\r\n\r\n\t\tString name = javaClass.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag throwsDocletTag : throwsDocletTags) {\r\n\t\t\tString curValue = throwsDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement throwsElement = methodElement.addElement(\"throws\");\r\n\r\n\t\tDocUtil.add(throwsElement, \"name\", name);\r\n\t\tDocUtil.add(throwsElement, \"type\", exceptionType.getValue());\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tElement commentElement = throwsElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(value));\r\n\r\n\t}","id":3008,"modified_method":"private void _addThrowsElement(\r\n\t\tElement methodElement, Type exceptionType,\r\n\t\tDocletTag[] throwsDocletTags) {\r\n\r\n\t\tJavaClass javaClass = exceptionType.getJavaClass();\r\n\r\n\t\tString name = javaClass.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag throwsDocletTag : throwsDocletTags) {\r\n\t\t\tString curValue = throwsDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement throwsElement = methodElement.addElement(\"throws\");\r\n\r\n\t\tDocUtil.add(throwsElement, \"name\", name);\r\n\t\tDocUtil.add(throwsElement, \"type\", exceptionType.getValue());\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tif (Validator.isNotNull(value)) {\r\n\t\t\tElement commentElement = throwsElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(_getCDATA(value));\r\n\t\t}\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addClassCommentElement(\r\n\t\tElement rootElement, JavaClass javaClass) {\r\n\r\n\t\tElement commentElement = rootElement.addElement(\"comment\");\r\n\r\n\t\tString comment = _getCDATA(javaClass);\r\n\r\n\t\tif (comment.startsWith(\"Copyright (c) 2000-2010 Liferay, Inc.\")) {\r\n\t\t\tcomment = StringPool.BLANK;\r\n\t\t}\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","id":3009,"modified_method":"private void _addClassCommentElement(\r\n\t\tElement rootElement, JavaClass javaClass) {\r\n\r\n\t\tString comment = _getCDATA(javaClass);\r\n\r\n\t\tif (Validator.isNull(comment)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tElement commentElement = rootElement.addElement(\"comment\");\r\n\r\n\t\tif (comment.startsWith(\"Copyright (c) 2000-2010 Liferay, Inc.\")) {\r\n\t\t\tcomment = StringPool.BLANK;\r\n\t\t}\r\n\r\n\t\tcommentElement.addCDATA(comment);\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Tuple _getJavadocsXmlTuple(String fileName) throws Exception {\r\n\t\tFile file = new File(fileName);\r\n\r\n\t\tString absolutePath = file.getAbsolutePath();\r\n\r\n\t\tabsolutePath = StringUtil.replace(absolutePath, \"\\\\\", \"/\");\r\n\r\n\t\tint pos = absolutePath.indexOf(\"/portal-impl/src/\");\r\n\r\n\t\tString srcDirName = null;\r\n\r\n\t\tif (pos != -1) {\r\n\t\t\tsrcDirName = absolutePath.substring(0, pos + 17);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpos = absolutePath.indexOf(\"/WEB-INF/src/\");\r\n\r\n\t\t\tif (pos != -1) {\r\n\t\t\t\tsrcDirName = absolutePath.substring(0, pos + 13);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (srcDirName == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tTuple tuple = _javadocxXmlTuples.get(srcDirName);\r\n\r\n\t\tif (tuple != null) {\r\n\t\t\treturn tuple;\r\n\t\t}\r\n\r\n\t\tFile javadocsXmlFile = new File(\r\n\t\t\tsrcDirName, \"META-INF/\" + _outputFileName);\r\n\r\n\t\tif (!javadocsXmlFile.exists()) {\r\n\t\t\t_fileUtil.write(\r\n\t\t\t\tjavadocsXmlFile,\r\n\t\t\t\t\"<?xml version=\\\"1.0\\\"?>\\n\\n<javadocs>\\n<\/javadocs>\");\r\n\t\t}\r\n\r\n\t\tString javadocsXmlContent = _fileUtil.read(javadocsXmlFile);\r\n\r\n\t\tDocument javadocsXmlDocument = _saxReaderUtil.read(javadocsXmlContent);\r\n\r\n\t\ttuple = new Tuple(\r\n\t\t\tsrcDirName, javadocsXmlFile, javadocsXmlContent,\r\n\t\t\tjavadocsXmlDocument);\r\n\r\n\t\t_javadocxXmlTuples.put(srcDirName, tuple);\r\n\r\n\t\treturn tuple;\r\n\t}","id":3010,"modified_method":"private Tuple _getJavadocsXmlTuple(String fileName) throws Exception {\r\n\t\tFile file = new File(fileName);\r\n\r\n\t\tString absolutePath = file.getAbsolutePath();\r\n\r\n\t\tabsolutePath = StringUtil.replace(absolutePath, \"\\\\\", \"/\");\r\n\r\n\t\tint pos = absolutePath.indexOf(\"/portal-impl/src/\");\r\n\r\n\t\tString srcDirName = null;\r\n\r\n\t\tif (pos != -1) {\r\n\t\t\tsrcDirName = absolutePath.substring(0, pos + 17);\r\n\t\t}\r\n\r\n\t\tif (srcDirName == null) {\r\n\t\t\tpos = absolutePath.indexOf(\"/portal-kernel/src/\");\r\n\r\n\t\t\tif (pos == -1) {\r\n\t\t\t\tpos = absolutePath.indexOf(\"/portal-service/src/\");\r\n\t\t\t}\r\n\r\n\t\t\tif (pos == -1) {\r\n\t\t\t\tpos = absolutePath.indexOf(\"/util-bridges/src/\");\r\n\t\t\t}\r\n\r\n\t\t\tif (pos == -1) {\r\n\t\t\t\tpos = absolutePath.indexOf(\"/util-java/src/\");\r\n\t\t\t}\r\n\r\n\t\t\tif (pos == -1) {\r\n\t\t\t\tpos = absolutePath.indexOf(\"/util-taglib/src/\");\r\n\t\t\t}\r\n\r\n\t\t\tif (pos != -1) {\r\n\t\t\t\tsrcDirName =\r\n\t\t\t\t\tabsolutePath.substring(0, pos) + \"/portal-impl/src/\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (srcDirName == null) {\r\n\t\t\tpos = absolutePath.indexOf(\"/WEB-INF/src/\");\r\n\r\n\t\t\tif (pos != -1) {\r\n\t\t\t\tsrcDirName = absolutePath.substring(0, pos + 13);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (srcDirName == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tTuple tuple = _javadocxXmlTuples.get(srcDirName);\r\n\r\n\t\tif (tuple != null) {\r\n\t\t\treturn tuple;\r\n\t\t}\r\n\r\n\t\tFile javadocsXmlFile = new File(\r\n\t\t\tsrcDirName, \"META-INF/\" + _outputFileName);\r\n\r\n\t\tif (!javadocsXmlFile.exists()) {\r\n\t\t\t_fileUtil.write(\r\n\t\t\t\tjavadocsXmlFile,\r\n\t\t\t\t\"<?xml version=\\\"1.0\\\"?>\\n\\n<javadocs>\\n<\/javadocs>\");\r\n\t\t}\r\n\r\n\t\tString javadocsXmlContent = _fileUtil.read(javadocsXmlFile);\r\n\r\n\t\tDocument javadocsXmlDocument = _saxReaderUtil.read(javadocsXmlContent);\r\n\r\n\t\ttuple = new Tuple(\r\n\t\t\tsrcDirName, javadocsXmlFile, javadocsXmlContent,\r\n\t\t\tjavadocsXmlDocument);\r\n\r\n\t\t_javadocxXmlTuples.put(srcDirName, tuple);\r\n\r\n\t\treturn tuple;\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addMethodElement(Element rootElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement methodElement = rootElement.addElement(\"method\");\r\n\r\n\t\tDocUtil.add(methodElement, \"name\", javaMethod.getName());\r\n\r\n\t\tElement commentElement = methodElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(javaMethod));\r\n\r\n\t\t_addDocletElements(methodElement, javaMethod, \"version\");\r\n\t\t_addParamElements(methodElement, javaMethod);\r\n\t\t_addReturnElement(methodElement, javaMethod);\r\n\t\t_addThrowsElements(methodElement, javaMethod);\r\n\t\t_addDocletElements(methodElement, javaMethod, \"see\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"since\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"deprecated\");\r\n\t}","id":3011,"modified_method":"private void _addMethodElement(Element rootElement, JavaMethod javaMethod)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement methodElement = rootElement.addElement(\"method\");\r\n\r\n\t\tDocUtil.add(methodElement, \"name\", javaMethod.getName());\r\n\r\n\t\tString comment = _getCDATA(javaMethod);\r\n\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement commentElement = methodElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(comment);\r\n\t\t}\r\n\r\n\t\t_addDocletElements(methodElement, javaMethod, \"version\");\r\n\t\t_addParamElements(methodElement, javaMethod);\r\n\t\t_addReturnElement(methodElement, javaMethod);\r\n\t\t_addThrowsElements(methodElement, javaMethod);\r\n\t\t_addDocletElements(methodElement, javaMethod, \"see\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"since\");\r\n\t\t_addDocletElements(methodElement, javaMethod, \"deprecated\");\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _updateJavadocsXmlFile(\r\n\t\t\tString fileName, JavaClass javaClass, Document javaClassDocument)\r\n\t\tthrows Exception {\r\n\r\n\t\tString javaClassFullyQualifiedName = javaClass.getFullyQualifiedName();\r\n\r\n\t\tif (!javaClassFullyQualifiedName.contains(\".service.\") ||\r\n\t\t\t!javaClassFullyQualifiedName.endsWith(\"ServiceImpl\")) {\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tTuple javadocsXmlTuple = _getJavadocsXmlTuple(fileName);\r\n\r\n\t\tif (javadocsXmlTuple == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDocument javadocsXmlDocument = (Document)javadocsXmlTuple.getObject(3);\r\n\r\n\t\tElement javadocsXmlRootElement = javadocsXmlDocument.getRootElement();\r\n\r\n\t\tList<Element> javadocElements = javadocsXmlRootElement.elements(\r\n\t\t\t\"javadoc\");\r\n\r\n\t\tfor (Element javadocElement : javadocElements) {\r\n\t\t\tString type = javadocElement.elementText(\"type\");\r\n\r\n\t\t\tif (type.equals(javaClassFullyQualifiedName)) {\r\n\t\t\t\tElement javaClassRootElement =\r\n\t\t\t\t\tjavaClassDocument.getRootElement();\r\n\r\n\t\t\t\tif (Validator.equals(\r\n\t\t\t\t\t\tjavadocElement.formattedString(),\r\n\t\t\t\t\t\tjavaClassRootElement.formattedString())) {\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tjavadocElement.detach();\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tjavadocsXmlRootElement.add(javaClassDocument.getRootElement());\r\n\t}","id":3012,"modified_method":"private void _updateJavadocsXmlFile(\r\n\t\t\tString fileName, JavaClass javaClass, Document javaClassDocument)\r\n\t\tthrows Exception {\r\n\r\n\t\tString javaClassFullyQualifiedName = javaClass.getFullyQualifiedName();\r\n\r\n\t\t/*if (!javaClassFullyQualifiedName.contains(\".service.\") ||\r\n\t\t\t!javaClassFullyQualifiedName.endsWith(\"ServiceImpl\")) {\r\n\r\n\t\t\treturn;\r\n\t\t}*/\r\n\r\n\t\tTuple javadocsXmlTuple = _getJavadocsXmlTuple(fileName);\r\n\r\n\t\tif (javadocsXmlTuple == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDocument javadocsXmlDocument = (Document)javadocsXmlTuple.getObject(3);\r\n\r\n\t\tElement javadocsXmlRootElement = javadocsXmlDocument.getRootElement();\r\n\r\n\t\tList<Element> javadocElements = javadocsXmlRootElement.elements(\r\n\t\t\t\"javadoc\");\r\n\r\n\t\tfor (Element javadocElement : javadocElements) {\r\n\t\t\tString type = javadocElement.elementText(\"type\");\r\n\r\n\t\t\tif (type.equals(javaClassFullyQualifiedName)) {\r\n\t\t\t\tElement javaClassRootElement =\r\n\t\t\t\t\tjavaClassDocument.getRootElement();\r\n\r\n\t\t\t\tif (Validator.equals(\r\n\t\t\t\t\t\tjavadocElement.formattedString(),\r\n\t\t\t\t\t\tjavaClassRootElement.formattedString())) {\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tjavadocElement.detach();\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tjavadocsXmlRootElement.add(javaClassDocument.getRootElement());\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addFieldElement(Element rootElement, JavaField javaField)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement fieldElement = rootElement.addElement(\"field\");\r\n\r\n\t\tDocUtil.add(fieldElement, \"name\", javaField.getName());\r\n\r\n\t\tElement commentElement = fieldElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(_getCDATA(javaField));\r\n\r\n\t\t_addDocletElements(fieldElement, javaField, \"version\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"see\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"since\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"deprecated\");\r\n\t}","id":3013,"modified_method":"private void _addFieldElement(Element rootElement, JavaField javaField)\r\n\t\tthrows Exception {\r\n\r\n\t\tElement fieldElement = rootElement.addElement(\"field\");\r\n\r\n\t\tDocUtil.add(fieldElement, \"name\", javaField.getName());\r\n\r\n\t\tString comment = _getCDATA(javaField);\r\n\r\n\t\tif (Validator.isNotNull(comment)) {\r\n\t\t\tElement commentElement = fieldElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(comment);\r\n\t\t}\r\n\r\n\t\t_addDocletElements(fieldElement, javaField, \"version\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"see\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"since\");\r\n\t\t_addDocletElements(fieldElement, javaField, \"deprecated\");\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addParamElement(\r\n\t\tElement methodElement, JavaParameter javaParameter,\r\n\t\tDocletTag[] paramDocletTags) {\r\n\r\n\t\tString name = javaParameter.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\r\n\t\t\tString curValue = paramDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement paramElement = methodElement.addElement(\"param\");\r\n\r\n\t\tDocUtil.add(paramElement, \"name\", name);\r\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tElement commentElement = paramElement.addElement(\"comment\");\r\n\r\n\t\tcommentElement.addCDATA(value);\r\n\t}","id":3014,"modified_method":"private void _addParamElement(\r\n\t\tElement methodElement, JavaParameter javaParameter,\r\n\t\tDocletTag[] paramDocletTags) {\r\n\r\n\t\tString name = javaParameter.getName();\r\n\r\n\t\tString value = null;\r\n\r\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\r\n\t\t\tString curValue = paramDocletTag.getValue();\r\n\r\n\t\t\tif (!curValue.startsWith(name)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = curValue;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement paramElement = methodElement.addElement(\"param\");\r\n\r\n\t\tDocUtil.add(paramElement, \"name\", name);\r\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\r\n\r\n\t\tif (value != null) {\r\n\t\t\tvalue = value.substring(name.length());\r\n\t\t}\r\n\r\n\t\tvalue = _trimMultilineText(value);\r\n\r\n\t\tif (Validator.isNotNull(value)) {\r\n\t\t\tElement commentElement = paramElement.addElement(\"comment\");\r\n\r\n\t\t\tcommentElement.addCDATA(value);\r\n\t\t}\r\n\t}","commit_id":"300c07b2cca71bb16f2575774dfe2edafa829f00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic HttpSession getSession(boolean create) {\n\t\tHttpSession session = new PortletServletSession(\n\t\t\t_request.getSession(create), _portletRequestImpl);\n\n\t\tif (ServerDetector.isJetty()) {\n\t\t\ttry {\n\t\t\t\tsession = wrapJettySession(session);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn session;\n\t}","id":3015,"modified_method":"@Override\n\tpublic HttpSession getSession(boolean create) {\n\t\tHttpSession session = _request.getSession(create);\n\n\t\tif (session == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tsession = new PortletServletSession(session, _portletRequestImpl);\n\n\t\tif (ServerDetector.isJetty()) {\n\t\t\ttry {\n\t\t\t\tsession = wrapJettySession(session);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn session;\n\t}","commit_id":"7bd9ab1c2ad783e0351bb35ec10b4eff27f2cbd4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Gets the Session for this request.\n\t * <br>\n\t * This method should be used instead of the originalRequest.getSession() method.\n\t * @param value indicates, if a session should be created when a session for the particular client does not already exist. \n\t * @return the CmsSession, or <code>null<\/code> if no session already exists and value was set to <code>false<\/code>\n\t * \n\t */\n\tpublic I_CmsSession getSession(boolean value) {\n\t\t\treturn (I_CmsSession) new CmsSession(((HttpServletRequest)m_req.getOriginalRequest()).getSession(value));\n\t}","id":3016,"modified_method":"/**\n\t * Gets the Session for this request.\n\t * <br>\n\t * This method should be used instead of the originalRequest.getSession() method.\n\t * @param value indicates, if a session should be created when a session for the particular client does not already exist. \n\t * @return the CmsSession, or <code>null<\/code> if no session already exists and value was set to <code>false<\/code>\n\t * \n\t */\n\tpublic I_CmsSession getSession(boolean value) {\n\t\tHttpSession session = ((HttpServletRequest)m_req.getOriginalRequest()).getSession(value);\n\t\tif(session != null) {\n\t\t\treturn (I_CmsSession) new CmsSession(session);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"787ab54db06efef81c02a524b3d9885306b677d4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void invalid() {\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.checkCanceled();\n    }\n\n    throw new PsiInvalidElementAccessException(this);\n  }","id":3017,"modified_method":"private void invalid() {\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.checkCanceled();\n    }\n\n    final StringBuilder builder = new StringBuilder();\n    TreeElement element = this;\n    while (element != null) {\n      if (element != this) builder.append(\" / \");\n      builder.append(element.getClass().getName()).append(':').append(element.getElementType());\n      element = element.getTreeParent();\n    }\n\n    throw new PsiInvalidElementAccessException(this, builder.toString());\n  }","commit_id":"ef087c602ccbaa4189c77977073ae0c461a6a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n    EditSourceUtil.getDescriptor(this).navigate(requestFocus);\n  }","id":3018,"modified_method":"public void navigate(boolean requestFocus) {\n    final Navigatable descriptor = EditSourceUtil.getDescriptor(this);\n    if (descriptor != null) {\n      descriptor.navigate(requestFocus);\n    }\n  }","commit_id":"ef087c602ccbaa4189c77977073ae0c461a6a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiFile getContainingFile() {\n    PsiFile file = SharedImplUtil.getContainingFile(this);\n    if (file == null || !file.isValid()) {\n      invalid();\n    }\n    return file;\n  }","id":3019,"modified_method":"public PsiFile getContainingFile() {\n    final PsiFile file = SharedImplUtil.getContainingFile(this);\n    if (file == null || !file.isValid()) invalid();\n    //noinspection ConstantConditions\n    return file;\n  }","commit_id":"ef087c602ccbaa4189c77977073ae0c461a6a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void navigate(boolean requestFocus) {\n    PsiNavigationSupport.getInstance().getDescriptor(this).navigate(requestFocus);\n  }","id":3020,"modified_method":"@Override\n  public void navigate(boolean requestFocus) {\n    Navigatable descriptor = PsiNavigationSupport.getInstance().getDescriptor(this);\n    if (descriptor != null) descriptor.navigate(requestFocus);\n  }","commit_id":"403e70c19dae78958f0879032a071f1da84b5919","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void deleteChildRange(PsiElement first, PsiElement last) throws IncorrectOperationException {\n    CheckUtil.checkWritable(this);\n    ASTNode firstElement = SourceTreeToPsiMap.psiElementToTree(first);\n    ASTNode lastElement = SourceTreeToPsiMap.psiElementToTree(last);\n    LOG.assertTrue(firstElement.getTreeParent() == this);\n    LOG.assertTrue(lastElement.getTreeParent() == this);\n    CodeEditUtil.removeChildren(this, firstElement, lastElement);\n  }","id":3021,"modified_method":"@Override\n  public void deleteChildRange(PsiElement first, PsiElement last) throws IncorrectOperationException {\n    CheckUtil.checkWritable(this);\n    ASTNode firstElement = first.getNode();\n    ASTNode lastElement = last.getNode();\n    LOG.assertTrue(firstElement.getTreeParent() == this);\n    LOG.assertTrue(lastElement.getTreeParent() == this);\n    CodeEditUtil.removeChildren(this, firstElement, lastElement);\n  }","commit_id":"403e70c19dae78958f0879032a071f1da84b5919","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull final Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    try {\n      int offset = editor.getCaretModel().getOffset();\n      PsiElement[] elements = findAllTargetElements(project, editor, offset);\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n\n      if (elements.length != 1) {\n        chooseAmbiguousTarget(editor, offset, elements);\n        return;\n      }\n\n      final PsiElement element = elements[0];\n\n      PsiElement navElement = element.getNavigationElement();\n      navElement = TargetElementUtilBase.getInstance().getGotoDeclarationTarget(element, navElement);\n\n      if (navElement != null) {\n        gotoTargetElement(navElement);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      DumbService.getInstance(project).showDumbModeNotification(\"Navigation is not available here during index update\");\n    }\n  }","id":3022,"modified_method":"@Override\n  public void invoke(@NotNull final Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    try {\n      int offset = editor.getCaretModel().getOffset();\n      PsiElement[] elements = findAllTargetElements(project, editor, offset);\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n\n      if (elements.length != 1) {\n        chooseAmbiguousTarget(editor, offset, elements);\n        return;\n      }\n\n      PsiElement element = elements[0];\n      PsiElement navElement = element.getNavigationElement();\n      navElement = TargetElementUtilBase.getInstance().getGotoDeclarationTarget(element, navElement);\n      if (navElement != null) {\n        gotoTargetElement(navElement);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      DumbService.getInstance(project).showDumbModeNotification(\"Navigation is not available here during index update\");\n    }\n  }","commit_id":"403e70c19dae78958f0879032a071f1da84b5919","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected CodeInsightActionHandler getHandler() {\n    String s = \"/java/lang/Object.class\";\n    return this;\n  }","id":3023,"modified_method":"@NotNull\n  @Override\n  protected CodeInsightActionHandler getHandler() {\n    return this;\n  }","commit_id":"403e70c19dae78958f0879032a071f1da84b5919","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(final AnActionEvent event) {\n    final InputEvent inputEvent = event.getInputEvent();\n    if (inputEvent instanceof MouseEvent) {\n      final MouseEvent mouseEvent = (MouseEvent)inputEvent;\n      final Point point = mouseEvent.getPoint();\n      final Component componentAt = SwingUtilities.getDeepestComponentAt(inputEvent.getComponent(), point.x, point.y);\n      if (componentAt instanceof EditorGutterComponentEx) {\n        event.getPresentation().setEnabled(false);\n        return;\n      }\n    }\n\n    for (GotoDeclarationHandler handler : Extensions.getExtensions(GotoDeclarationHandler.EP_NAME)) {\n      try {\n        final String text = handler.getActionText(event.getDataContext());\n\n        if (text != null) {\n          Presentation presentation = event.getPresentation();\n          presentation.setText(text);\n          break;\n        }\n      }\n      catch (AbstractMethodError e) {\n        LOG.error(handler.toString(), e);\n      }\n    }\n\n    super.update(event);\n  }","id":3024,"modified_method":"@Override\n  public void update(final AnActionEvent event) {\n    InputEvent inputEvent = event.getInputEvent();\n    if (inputEvent instanceof MouseEvent) {\n      Component component = inputEvent.getComponent();\n      if (component != null) {\n        Point point = ((MouseEvent)inputEvent).getPoint();\n        Component componentAt = SwingUtilities.getDeepestComponentAt(component, point.x, point.y);\n        if (componentAt instanceof EditorGutterComponentEx) {\n          event.getPresentation().setEnabled(false);\n          return;\n        }\n      }\n    }\n\n    for (GotoDeclarationHandler handler : Extensions.getExtensions(GotoDeclarationHandler.EP_NAME)) {\n      try {\n        String text = handler.getActionText(event.getDataContext());\n        if (text != null) {\n          Presentation presentation = event.getPresentation();\n          presentation.setText(text);\n          break;\n        }\n      }\n      catch (AbstractMethodError e) {\n        LOG.error(handler.toString(), e);\n      }\n    }\n\n    super.update(event);\n  }","commit_id":"403e70c19dae78958f0879032a071f1da84b5919","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n    EditSourceUtil.getDescriptor(this).navigate(requestFocus);\n  }","id":3025,"modified_method":"public void navigate(boolean requestFocus) {\n    final Navigatable navigatable = EditSourceUtil.getDescriptor(this);\n    if (navigatable != null) {\n      navigatable.navigate(requestFocus);\n    }\n  }","commit_id":"5ecafe407c6d7b755807621becefa68190431707","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n    PsiNavigationSupport.getInstance().getDescriptor(this).navigate(requestFocus);\n  }","id":3026,"modified_method":"public void navigate(boolean requestFocus) {\n    final Navigatable descriptor = PsiNavigationSupport.getInstance().getDescriptor(this);\n    if (descriptor != null) {\n      descriptor.navigate(requestFocus);\n    }\n  }","commit_id":"ba6f6f82fd389c9ace630936b2d5c143fbd30b35","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n    EditSourceUtil.getDescriptor(this).navigate(requestFocus);\n  }","id":3027,"modified_method":"public void navigate(boolean requestFocus) {\n    final Navigatable descriptor = EditSourceUtil.getDescriptor(this);\n    if (descriptor != null) descriptor.navigate(requestFocus);\n  }","commit_id":"7e892a6a6d43ced3fd17caf03345ec4ab60444f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEntityInspectable() {\n        Integer isEntityInspectable=(Integer)d2wContext().valueForKey(\"isEntityInspectable\");\n        return isEntityReadOnly() && (isEntityInspectable!=null && isEntityInspectable.intValue()!=0);\n    }","id":3028,"modified_method":"public boolean isEntityInspectable() {\n        return ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityInspectable\"), isEntityReadOnly());\n        // return isEntityReadOnly() && (isEntityInspectable!=null && isEntityInspectable.intValue()!=0);\n    }","commit_id":"147465d449db52b63f1dfeea14057ec0d12d69d6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent deleteObjectAction() {\n        // FIXME: Shouldn't ave a hard dependency on names here.\n        String confirmDeleteConfigurationName=(String)d2wContext().valueForKey(\"confirmDeleteConfigurationName\");\n        if(confirmDeleteConfigurationName!=null){\n            ConfirmPageInterface nextPage = (ConfirmPageInterface)D2W.factory().pageForConfigurationNamed(confirmDeleteConfigurationName,session());\n            nextPage.setConfirmDelegate(new ERDDeletionDelegate(object(),dataSource(),context().page()));\n            nextPage.setCancelDelegate(new ERDDeletionDelegate(null,null,context().page()));\n            if(nextPage instanceof ERD2WInspectPage) {\n                ((ERD2WInspectPage)nextPage).setObject(object());\n            } else {\n                nextPage.setMessage(\"Are you sure you want to delete the following \"+d2wContext().valueForKey(\"displayNameForEntity\")+\":<br> \"+object().userPresentableDescription()+ \" ?\");\n            }\n            return (WOComponent) nextPage;\n        } else {\n            ConfirmPageInterface nextPage = (ConfirmPageInterface)pageWithName(\"ERD2WConfirmPageTemplate\");\n            nextPage.setConfirmDelegate(new ERDDeletionDelegate(object(),dataSource(),context().page()));\n            nextPage.setCancelDelegate(new ERDDeletionDelegate(null,null,context().page()));\n\n            nextPage.setMessage(\"Are you sure you want to delete the following \"+d2wContext().valueForKey(\"displayNameForEntity\")+\":<br> \"+object().userPresentableDescription()+ \" ?\");\n            return (WOComponent) nextPage;\n        }\n    }","id":3029,"modified_method":"public WOComponent deleteObjectAction() {\n        String confirmDeleteConfigurationName=(String)d2wContext().valueForKey(\"confirmDeleteConfigurationName\");\n        ConfirmPageInterface nextPage;\n        if(confirmDeleteConfigurationName==null) {\n            log.warn(\"Using default delete template: ERD2WConfirmPageTemplate, set the 'confirmDeleteConfigurationName' key to something more sensible\");\n            nextPage = (ConfirmPageInterface)pageWithName(\"ERD2WConfirmPageTemplate\");\n        } else {\n            nextPage = (ConfirmPageInterface)D2W.factory().pageForConfigurationNamed(confirmDeleteConfigurationName,session());\n        }\n        nextPage.setConfirmDelegate(new ERDDeletionDelegate(object(),dataSource(),context().page()));\n        nextPage.setCancelDelegate(new ERDDeletionDelegate(null,null,context().page()));\n        if(nextPage instanceof InspectPageInterface) {\n            ((InspectPageInterface)nextPage).setObject(object());\n        } else {\n            nextPage.setMessage(\"Are you sure you want to delete the following \"+d2wContext().valueForKey(\"displayNameForEntity\")+\":<br> \"+object().userPresentableDescription()+ \" ?\");\n        }\n        return (WOComponent) nextPage;\n    }","commit_id":"147465d449db52b63f1dfeea14057ec0d12d69d6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isEntityReadOnly() {\n        Integer isEntityEditable=(Integer)d2wContext().valueForKey(\"isEntityEditable\");\n        return  isEntityEditable!=null ? isEntityEditable.intValue()==0 : super.isEntityReadOnly();\n    }","id":3030,"modified_method":"public boolean isEntityReadOnly() {\n        return !ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), !super.isEntityReadOnly());\n    }","commit_id":"e8ea5a1d75a76009fa4c077fc2530cb805def810","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isEntityReadOnly() {\n        Integer isEntityEditable=(Integer)d2wContext().valueForKey(\"isEntityEditable\");\n        return  isEntityEditable!=null ? isEntityEditable.intValue()==0 : super.isEntityReadOnly();\n    }","id":3031,"modified_method":"public boolean isEntityReadOnly() {\n        return !ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), !super.isEntityReadOnly());\n    }","commit_id":"e8ea5a1d75a76009fa4c077fc2530cb805def810","url":"https://github.com/wocommunity/wonder"},{"original_method":"private Document loadDocument(\r\n            final LoaderDispatcher loader,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final DigestURI url,\r\n            final boolean reindexing,\r\n            ResultClass source) {\r\n        /* ===========================================================================\r\n         * LOAD RESOURCE DATA\r\n         * =========================================================================== */\r\n        // if the snippet is not in the cache, we can try to get it from the htcache\r\n        final Response response;\r\n        try {\r\n            // first try to get the snippet from metadata\r\n            String loc;\r\n            final boolean noCacheUsage = url.isFile() || url.isSMB() || cacheStrategy == null;\r\n            if (containsAllHashes(loc = comp.dc_title(), queryhashes)) {\r\n                // try to create the snippet from information given in the url itself\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return null;\r\n            } else if (containsAllHashes(loc = comp.dc_creator(), queryhashes)) {\r\n                // try to create the snippet from information given in the creator metadata\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return null;\r\n            } else if (containsAllHashes(loc = comp.dc_subject(), queryhashes)) {\r\n                // try to create the snippet from information given in the subject metadata\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return null;\r\n            } else if (containsAllHashes(loc = comp.url().toNormalform(true, true).replace('-', ' '), queryhashes)) {\r\n                // try to create the snippet from information given in the url\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return null;\r\n            } else {\r\n                // try to load the resource from the cache\r\n                response = loader == null ? null : loader.load(loader.request(url, true, reindexing), noCacheUsage ? CacheStrategy.NOCACHE : cacheStrategy, true);\r\n                if (response == null) {\r\n                    // in case that we did not get any result we can still return a success when we are not allowed to go online\r\n                    if (cacheStrategy == null || cacheStrategy.mustBeOffline()) {\r\n                        init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"omitted network load (not allowed), no cache entry\");\r\n                        return null;\r\n                    }\r\n\r\n                    // if it is still not available, report an error\r\n                    init(url.hash(), null, ResultClass.ERROR_RESOURCE_LOADING, \"error loading resource from net, no cache entry\");\r\n                    return null;\r\n                } else {\r\n                    // place entry on indexing queue\r\n                    Switchboard.getSwitchboard().toIndexer(response);\r\n                    source = ResultClass.SOURCE_WEB;\r\n                }\r\n            }\r\n        } catch (final Exception e) {\r\n            //Log.logException(e);\r\n            init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"error loading resource: \" + e.getMessage());\r\n            return null;\r\n        }\r\n\r\n        /* ===========================================================================\r\n         * PARSE RESOURCE\r\n         * =========================================================================== */\r\n        Document document = null;\r\n        try {\r\n            document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n        } catch (final Parser.Failure e) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, e.getMessage()); // cannot be parsed\r\n            return null;\r\n        }\r\n        if (document == null) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, \"parser error/failed\"); // cannot be parsed\r\n        }\r\n        return document;\r\n    }","id":3032,"modified_method":"private Document loadDocument(\r\n            final LoaderDispatcher loader,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final DigestURI url,\r\n            final boolean reindexing,\r\n            ResultClass source) {\r\n        /* ===========================================================================\r\n         * LOAD RESOURCE DATA\r\n         * =========================================================================== */\r\n        // if the snippet is not in the cache, we can try to get it from the htcache\r\n        Response response = null;\r\n        try {\r\n            // first try to get the snippet from metadata\r\n            String loc;\r\n            final Request request = loader.request(url, true, reindexing);\r\n            final boolean inCache = de.anomic.http.client.Cache.has(comp.url());\r\n            final boolean noCacheUsage = url.isFile() || url.isSMB() || cacheStrategy == null;\r\n            if (containsAllHashes(loc = comp.dc_title(), queryhashes) ||\r\n                containsAllHashes(loc = comp.dc_creator(), queryhashes) ||\r\n                containsAllHashes(loc = comp.dc_subject(), queryhashes) ||\r\n                containsAllHashes(loc = comp.url().toNormalform(true, true).replace('-', ' '), queryhashes)) {\r\n                // try to create the snippet from information given in the url\r\n                if (inCache) response = loader == null ? null : loader.load(request, CacheStrategy.CACHEONLY, true);\r\n                Document document = null;\r\n                if (response != null) {\r\n                    try {\r\n                        document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n                    } catch (final Parser.Failure e) {\r\n                    }\r\n                }\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return document;\r\n            } else {\r\n                // try to load the resource from the cache\r\n                response = loader == null ? null : loader.load(request, noCacheUsage ? CacheStrategy.NOCACHE : cacheStrategy, true);\r\n                if (response == null) {\r\n                    // in case that we did not get any result we can still return a success when we are not allowed to go online\r\n                    if (cacheStrategy == null || cacheStrategy.mustBeOffline()) {\r\n                        init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"omitted network load (not allowed), no cache entry\");\r\n                        return null;\r\n                    }\r\n\r\n                    // if it is still not available, report an error\r\n                    init(url.hash(), null, ResultClass.ERROR_RESOURCE_LOADING, \"error loading resource from net, no cache entry\");\r\n                    return null;\r\n                } else {\r\n                    // place entry on indexing queue\r\n                    Switchboard.getSwitchboard().toIndexer(response);\r\n                    source = ResultClass.SOURCE_WEB;\r\n                }\r\n            }\r\n        } catch (final Exception e) {\r\n            //Log.logException(e);\r\n            init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"error loading resource: \" + e.getMessage());\r\n            return null;\r\n        }\r\n\r\n        /* ===========================================================================\r\n         * PARSE RESOURCE\r\n         * =========================================================================== */\r\n        Document document = null;\r\n        try {\r\n            document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n        } catch (final Parser.Failure e) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, e.getMessage()); // cannot be parsed\r\n            return null;\r\n        }\r\n        if (document == null) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, \"parser error/failed\"); // cannot be parsed\r\n        }\r\n        return document;\r\n    }","commit_id":"4ad9fc2bff4a4b868b6d0fd6b0c6c41f38282336","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public TextSnippet(\r\n            final LoaderDispatcher loader,\r\n            final String solrText,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final boolean pre,\r\n            final int snippetMaxLength,\r\n            final int maxDocLen,\r\n            final boolean reindexing) {\r\n        // heise = \"0OQUNU3JSs05\"\r\n        final DigestURI url = comp.url();\r\n        if (queryhashes.isEmpty()) {\r\n            //System.out.println(\"found no queryhashes for URL retrieve \" + url);\r\n            init(url.hash(), null, ResultClass.ERROR_NO_HASH_GIVEN, \"no query hashes given\");\r\n            return;\r\n        }\r\n\r\n        // try to get snippet from snippetCache\r\n        final ResultClass source = ResultClass.SOURCE_CACHE;\r\n        final String wordhashes = RemoteSearch.set2string(queryhashes);\r\n        final String urls = ASCII.String(url.hash());\r\n        String snippetLine = snippetsCache.get(wordhashes, urls);\r\n        if (snippetLine != null) {\r\n            // found the snippet\r\n            init(url.hash(), snippetLine, source, null);\r\n            return;\r\n        }\r\n\r\n        // try to get the snippet from a document at the cache (or in the web)\r\n        // this requires that the document is parsed after loading\r\n        String textline = null;\r\n        HandleSet remainingHashes = queryhashes;\r\n        { //encapsulate potential expensive sentences\r\n            Collection<StringBuilder> sentences = null;\r\n\r\n            // try the solr text first\r\n            if (solrText != null) {\r\n                // compute sentences from solr query\r\n                sentences = Document.getSentences(pre, new ByteArrayInputStream(UTF8.getBytes(solrText)));\r\n            }\r\n\r\n            // if then no sentences are found, we fail-over to get the content from the re-loaded document\r\n            if (sentences == null) {\r\n                final Document document = loadDocument(loader, comp, queryhashes, cacheStrategy, url, reindexing, source);\r\n                if (document == null) {\r\n                    return;\r\n                }\r\n\r\n                // compute sentences from parsed document\r\n                sentences = document.getSentences(pre);\r\n                document.close();\r\n\r\n                if (sentences == null) {\r\n                    init(url.hash(), null, ResultClass.ERROR_PARSER_NO_LINES, \"parser returned no sentences\");\r\n                    return;\r\n                }\r\n            }\r\n\r\n            try {\r\n                final SnippetExtractor tsr = new SnippetExtractor(sentences, queryhashes, snippetMaxLength);\r\n                textline = tsr.getSnippet();\r\n                remainingHashes =  tsr.getRemainingWords();\r\n            } catch (final UnsupportedOperationException e) {\r\n                init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n                return;\r\n            }\r\n        } //encapsulate potential expensive sentences END\r\n\r\n        // compute snippet from media - attention document closed above!\r\n        //String audioline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n        //String videoline = computeMediaSnippet(document.getVideolinks(), queryhashes);\r\n        //String appline = computeMediaSnippet(document.getApplinks(), queryhashes);\r\n        //String hrefline = computeMediaSnippet(document.getAnchors(), queryhashes);\r\n        //String imageline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n\r\n        snippetLine = \"\";\r\n        //if (audioline != null) line += (line.length() == 0) ? audioline : \"<br />\" + audioline;\r\n        //if (videoline != null) line += (line.length() == 0) ? videoline : \"<br />\" + videoline;\r\n        //if (appline   != null) line += (line.length() == 0) ? appline   : \"<br />\" + appline;\r\n        //if (hrefline  != null) line += (line.length() == 0) ? hrefline  : \"<br />\" + hrefline;\r\n        if (textline  != null) snippetLine += (snippetLine.length() == 0) ? textline  : \"<br />\" + textline;\r\n\r\n        if (snippetLine == null || !remainingHashes.isEmpty()) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n        if (snippetLine.length() > snippetMaxLength) snippetLine = snippetLine.substring(0, snippetMaxLength);\r\n\r\n        // finally store this snippet in our own cache\r\n        snippetsCache.put(wordhashes, urls, snippetLine);\r\n\r\n//        document.close();\r\n        init(url.hash(), snippetLine, source, null);\r\n    }","id":3033,"modified_method":"public TextSnippet(\r\n            final LoaderDispatcher loader,\r\n            final String solrText,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final boolean pre,\r\n            final int snippetMaxLength,\r\n            final int maxDocLen,\r\n            final boolean reindexing) {\r\n        // heise = \"0OQUNU3JSs05\"\r\n        final DigestURI url = comp.url();\r\n        if (queryhashes.isEmpty()) {\r\n            //System.out.println(\"found no queryhashes for URL retrieve \" + url);\r\n            init(url.hash(), null, ResultClass.ERROR_NO_HASH_GIVEN, \"no query hashes given\");\r\n            return;\r\n        }\r\n\r\n        // try to get snippet from snippetCache\r\n        final ResultClass source = ResultClass.SOURCE_CACHE;\r\n        final String wordhashes = RemoteSearch.set2string(queryhashes);\r\n        final String urls = ASCII.String(url.hash());\r\n        String snippetLine = snippetsCache.get(wordhashes, urls);\r\n        if (snippetLine != null) {\r\n            // found the snippet\r\n            init(url.hash(), snippetLine, source, null);\r\n            return;\r\n        }\r\n\r\n        // try to get the snippet from a document at the cache (or in the web)\r\n        // this requires that the document is parsed after loading\r\n        String textline = null;\r\n        HandleSet remainingHashes = queryhashes;\r\n        { //encapsulate potential expensive sentences\r\n            Collection<StringBuilder> sentences = null;\r\n\r\n            // try the solr text first\r\n            if (solrText != null) {\r\n                // compute sentences from solr query\r\n                sentences = Document.getSentences(pre, new ByteArrayInputStream(UTF8.getBytes(solrText)));\r\n            }\r\n\r\n            // if then no sentences are found, we fail-over to get the content from the re-loaded document\r\n            if (sentences == null) {\r\n                final Document document = loadDocument(loader, comp, queryhashes, cacheStrategy, url, reindexing, source);\r\n                if (document == null) {\r\n                    return;\r\n                }\r\n\r\n                // compute sentences from parsed document\r\n                sentences = document.getSentences(pre);\r\n                document.close();\r\n\r\n                if (sentences == null) {\r\n                    init(url.hash(), null, ResultClass.ERROR_PARSER_NO_LINES, \"parser returned no sentences\");\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (this.resultStatus == ResultClass.SOURCE_METADATA) {\r\n                // if we already know that there is a match then use the first lines from the text as snippet\r\n                final StringBuilder s = new StringBuilder(snippetMaxLength);\r\n                for (final StringBuilder t: sentences) {\r\n                    s.append(t).append(' ');\r\n                    if (s.length() >= snippetMaxLength / 4 * 3) break;\r\n                }\r\n                if (s.length() > snippetMaxLength) { s.setLength(snippetMaxLength); s.trimToSize(); }\r\n                init(url.hash(), s.length() > 0 ? s.toString() : this.line, ResultClass.SOURCE_METADATA, null);\r\n                return;\r\n            }\r\n\r\n            try {\r\n                final SnippetExtractor tsr = new SnippetExtractor(sentences, queryhashes, snippetMaxLength);\r\n                textline = tsr.getSnippet();\r\n                remainingHashes =  tsr.getRemainingWords();\r\n            } catch (final UnsupportedOperationException e) {\r\n                init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n                return;\r\n            }\r\n        } //encapsulate potential expensive sentences END\r\n\r\n        // compute snippet from media - attention document closed above!\r\n        //String audioline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n        //String videoline = computeMediaSnippet(document.getVideolinks(), queryhashes);\r\n        //String appline = computeMediaSnippet(document.getApplinks(), queryhashes);\r\n        //String hrefline = computeMediaSnippet(document.getAnchors(), queryhashes);\r\n        //String imageline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n\r\n        snippetLine = \"\";\r\n        //if (audioline != null) line += (line.length() == 0) ? audioline : \"<br />\" + audioline;\r\n        //if (videoline != null) line += (line.length() == 0) ? videoline : \"<br />\" + videoline;\r\n        //if (appline   != null) line += (line.length() == 0) ? appline   : \"<br />\" + appline;\r\n        //if (hrefline  != null) line += (line.length() == 0) ? hrefline  : \"<br />\" + hrefline;\r\n        if (textline  != null) snippetLine += (snippetLine.length() == 0) ? textline  : \"<br />\" + textline;\r\n\r\n        if (snippetLine == null || !remainingHashes.isEmpty()) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n        if (snippetLine.length() > snippetMaxLength) snippetLine = snippetLine.substring(0, snippetMaxLength);\r\n\r\n        // finally store this snippet in our own cache\r\n        snippetsCache.put(wordhashes, urls, snippetLine);\r\n\r\n//        document.close();\r\n        init(url.hash(), snippetLine, source, null);\r\n    }","commit_id":"4ad9fc2bff4a4b868b6d0fd6b0c6c41f38282336","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.BodyTagSupport#doAfterBody()\n     */\n    public int doAfterBody() throws JspException {\n        \n        doEndTag();\n        m_file = getNextFilname(); \n        if (m_file != null) {\n            m_wasEditable = contentItemTagFileAction(pageContext, m_file, m_editable, createEditOptions(true, true, false), null, pageContext.getRequest());            \n            return EVAL_BODY_AGAIN;\n        }\n        return SKIP_BODY;\n    }","id":3034,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.BodyTagSupport#doAfterBody()\n     */\n    public int doAfterBody() throws JspException {\n\n        if (m_directEditPermissions != null) {\n            // last element was direct editable, close it\n            CmsJspTagEditable.includeDirectEditElement(\n                pageContext,\n                I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_END, \n                m_file, \n                null, \n                null, \n                m_directEditPermissions,\n                null);            \n            m_directEditPermissions = null;\n        }\n        \n        // check if there are more files to iterate\n        if (m_filterContentList.size() > 0) {\n            \n            // there are more files available...\n            try {\n                doLoadNextFile();\n            } catch (CmsException e) {\n                m_controller.setThrowable(e, m_file);\n                throw new JspException(e);\n            }\n            \n            // check \"direct edit\" support\n            if (m_editable) {\n                m_directEditPermissions = CmsJspTagEditable.includeDirectEditElement(\n                    pageContext, \n                    I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START, \n                    m_file, \n                    null, \n                    CmsJspTagEditable.createEditOptions(true, true, false),  \n                    null,\n                    m_directEditCreateLink);\n            }             \n            \n            // another loop is required\n            return EVAL_BODY_AGAIN;\n        }\n        \n        // no more files are available, so skip the body and finish the loop\n        return SKIP_BODY;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#release()\n     */ \n    public void release() {\n        \n        super.release();        \n        m_file = null;\n        m_filter = null;\n        m_createLink = null;\n        m_filterContentList = null;\n        m_param = null;\n        m_editable = false;\n        m_wasEditable = false;\n    }","id":3035,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#release()\n     */\n    public void release() {\n\n        super.release();\n        m_file = null;\n        m_filter = null;\n        m_filterContentList = null;\n        m_param = null;\n        m_cms = null;\n        m_controller = null;\n        m_editable = false;    \n        m_directEditPermissions = null;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n        \n        if (getFilter() != null) {\n            \n            // check if this is already initialized\n            m_file = getNextFilname();\n            \n            if (m_file == null) {            \n                CmsFlexController controller = (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n                I_CmsXmlContentFilter filter;\n    \n                // HACK: Need to improve this\n                filter = OpenCms.getXmlContentTypeManager().getContentFilter(getFilter());        \n                try {\n                    m_filterContentList = filter.getFilterResults(controller.getCmsObject(), getFilter(), getParam());\n                    m_createLink = CmsEncoder.encode(getFilter() + \"|\" + getParam());\n                } catch (CmsException e) {\n                    if (OpenCms.getLog(this).isErrorEnabled()) {\n                        OpenCms.getLog(this).error(\"Error in Jsp 'contentitem' filter tag processing\", e);\n                    }                \n                    throw new javax.servlet.jsp.JspException(e);\n                }\n            }\n\n            m_file = getNextFilname(); \n            m_wasEditable = contentItemTagFileAction(pageContext, getFile(), m_editable, createEditOptions(true, true, true), m_createLink, pageContext.getRequest());            \n            return EVAL_BODY_INCLUDE;\n        } \n        \n        if (getFile() != null) {\n            m_wasEditable = contentItemTagFileAction(pageContext, getFile(), m_editable, createEditOptions(true, false, false), null, pageContext.getRequest());\n       \n            return EVAL_BODY_INCLUDE;\n        }\n        \n        return SKIP_BODY;\n    }","id":3036,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        if (getFilter() == null) {\n            throw new IllegalArgumentException(\"'contentload' tag requires 'filter' attribute\");\n        }\n\n        // initialize OpenCms access objects\n        m_controller = (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        m_cms = m_controller.getCmsObject();\n\n        // store the current locale    \n        m_locale = m_cms.getRequestContext().getLocale();\n\n        // get the selected filter class\n        String filterName = getFilter();\n        String param = resolveMagicName(getParam());\n        I_CmsXmlContentFilter filter = OpenCms.getXmlContentTypeManager().getContentFilter(filterName);\n\n        try {\n            // execute the filter\n            m_filterContentList = filter.getFilterResults(m_cms, filterName, param);\n            if (filter.getCreateLink(m_cms, filterName, param) != null) {\n                // use \"create link\" only if filter supports it\n                m_directEditCreateLink = CmsEncoder.encode(getFilter() + \"|\" + getParam());\n            }\n            doLoadNextFile();\n        } catch (CmsException e) {\n            m_controller.setThrowable(e, m_cms.getRequestContext().getUri());\n            throw new JspException(e);\n        }\n        \n        // check options for first element\n        String directEditOptions;\n        if (m_directEditCreateLink != null) {\n            // if create link is not null, show \"edit\", \"delete\" and \"new\" button for first element\n            directEditOptions = CmsJspTagEditable.createEditOptions(true, true, true);\n        } else {\n            // if create link is null, show onle \"edit\" button for first element\n            directEditOptions = CmsJspTagEditable.createEditOptions(true, false, false);\n        }\n        \n        // check \"direct edit\" support\n        if (m_editable) {\n            m_directEditPermissions = CmsJspTagEditable.includeDirectEditElement(\n                pageContext, \n                I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START, \n                m_file, \n                null, \n                directEditOptions,\n                null,\n                m_directEditCreateLink);\n        }        \n\n        return EVAL_BODY_INCLUDE;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.jsp.I_CmsJspTagContentContainer#getResourceName()\n     */\n    public String getResourceName() {\n\n        return m_resourceName;\n    }","id":3037,"modified_method":"/**\n     * @see org.opencms.jsp.I_CmsJspTagContentContainer#getResourceName()\n     */\n    public String getResourceName() {\n\n        return m_file;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#release()\n     */\n    public void release() {\n\n        super.release();\n        m_element = null;\n        m_content = null;\n        m_resourceName = null;\n        m_index = 0;\n    }","id":3038,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#release()\n     */\n    public void release() {\n\n        super.release();\n        m_element = null;\n        m_content = null;\n        m_locale = null;\n        m_parentTag = null;\n        m_index = 0;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.jsp.I_CmsJspTagContentContainer#getResourceName()\n     */\n    public String getResourceName() {\n\n        return m_resourceName;\n    }","id":3039,"modified_method":"/**\n     * @see org.opencms.jsp.I_CmsJspTagContentContainer#getResourceName()\n     */\n    public String getResourceName() {\n\n        return m_parentTag.getResourceName();\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentloop> without required parent tag <contentload> found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        m_content = contentContainer.getXmlDocument();\n        m_resourceName = contentContainer.getResourceName();\n        m_locale = contentContainer.getXmlDocumentLocale();\n        m_index = 0;\n\n        if (m_content.hasValue(m_element, m_locale)) {\n            // selected element is available at last once in content\n            return EVAL_BODY_INCLUDE;\n        } else {\n            // no value available for the selected element name, so we skip the whole body\n            return SKIP_BODY;\n        }\n    }","id":3040,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, CmsJspTagContentLoad.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag 'contentloop' without required parent tag 'contentload' found!\");\n        }\n        m_parentTag = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        m_content = m_parentTag.getXmlDocument();\n        m_locale = m_parentTag.getXmlDocumentLocale();\n        m_index = 0;\n\n        if (m_content.hasValue(m_element, m_locale)) {\n            // selected element is available at last once in content\n            return EVAL_BODY_INCLUDE;\n        } else {\n            // no value available for the selected element name, so we skip the whole body\n            return SKIP_BODY;\n        }\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag <contentload> found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        String resourceName = contentContainer.getResourceName();\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n        String element = getElement();\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        }\n        int index = getIndex();\n        if (getIndex() < 0) {\n            index = contentContainer.getXmlDocumentIndex();\n        }\n\n        // now get the content element value to display\n        String content = contentShowTagAction(xmlContent, element, locale, index, resourceName, pageContext\n            .getRequest());\n\n        // make sure that no null String is returned\n        if (content == null) {\n            content = CmsMessages.formatUnknownKey(element + '[' + index + ']');\n        }\n\n        try {\n            pageContext.getOut().print(content);\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error in Jsp <contentshow> tag processing\", e);\n            }\n            throw new javax.servlet.jsp.JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","id":3041,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag <contentload> found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n\n        String element = getElement();\n\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        }\n\n        String content;\n        if (element.startsWith(I_CmsJspTagContentContainer.C_MAGIC_PREFIX)) {\n\n            // this is a \"magic\" element name, resolve it\n            content = contentContainer.resolveMagicName(element);\n        } else {\n\n            // resolve \"normal\" content reference\n            int index = getIndex();\n            if (getIndex() < 0) {\n                index = contentContainer.getXmlDocumentIndex();\n            }\n\n            // now get the content element value to display\n            content = contentShowTagAction(xmlContent, element, locale, index, pageContext.getRequest());\n\n            // make sure that no null String is returned\n            if (content == null) {\n                content = CmsMessages.formatUnknownKey(element + '[' + index + ']');\n            }\n        }\n\n        try {\n            pageContext.getOut().print(content);\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error in Jsp <contentshow> tag processing\", e);\n            }\n            throw new JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Internal action method to show an element from a XML content document.<p>\n     * \n     * @param content the XML content to show the element from\n     * @param element the node name of the element to show\n     * @param locale the locale of the element to show\n     * @param index the node index of the element to show\n     * @param resourceName the name of the resource the content was loaded from\n     * @param req the current request \n     * \n     * @return the value of the selected content element\n     */\n    public static String contentShowTagAction(\n        A_CmsXmlDocument content,\n        String element,\n        Locale locale,\n        int index,\n        String resourceName,\n        ServletRequest req) {\n\n        if (\"opencms:uri\".equals(element)) {\n            // special tag value used for the current uri\n            return resourceName;\n        }\n\n        if (content == null) {\n            // no content was loaded\n            return null;\n        }\n\n        if (content.hasValue(element, locale, index)) {\n\n            // selected element is available in content\n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            CmsObject cms = controller.getCmsObject();\n\n            try {\n                // read the element from the content\n                return content.getStringValue(cms, element, locale, index);\n            } catch (CmsXmlException e) {\n                OpenCms.getLog(CmsJspTagContentShow.class).error(\n                    \"Error processing content element '\" + element + '[' + index + \"]'\",\n                    e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }","id":3042,"modified_method":"/**\n     * Internal action method to show an element from a XML content document.<p>\n     * @param content the XML content to show the element from\n     * @param element the node name of the element to show\n     * @param locale the locale of the element to show\n     * @param index the node index of the element to show\n     * @param req the current request \n     * \n     * @return the value of the selected content element\n     */\n    public static String contentShowTagAction(\n        A_CmsXmlDocument content,\n        String element,\n        Locale locale,\n        int index,\n        ServletRequest req) {\n\n        if (content == null) {\n            // no content was loaded\n            return null;\n        }\n\n        if (content.hasValue(element, locale, index)) {\n\n            // selected element is available in content\n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            CmsObject cms = controller.getCmsObject();\n\n            try {\n                // read the element from the content\n                return content.getStringValue(cms, element, locale, index);\n            } catch (CmsXmlException e) {\n                OpenCms.getLog(CmsJspTagContentShow.class).error(\n                    \"Error processing content element '\" + element + '[' + index + \"]'\",\n                    e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Include action method.<p>\n     * \n     * The logic in this mehod is more complex than it should be.\n     * This is because of the XMLTemplate integration, which requires some settings \n     * to the parameters understandable only to XMLTemplate gurus.\n     * By putting this logic here it is not required to care about these issues\n     * on JSP pages, and you end up with considerable less JSP code.\n     * Also JSP developers need not to know the intrinsics of XMLTemplates this way.<p>\n     * \n     * @param context the current JSP page context\n     * @param target the target for the include, might be <code>null<\/code>\n     * @param element the element to select form the target might be <code>null<\/code>\n     * @param editable the flag to indicate if the target is editable\n     * @param paramMap a map of parameters for the include, will be merged with the request \n     *      parameters, might be <code>null<\/code>\n     * @param req the current request\n     * @param res the current response\n     * @throws JspException in case something goes wrong\n     */\n    public static void includeTagAction(PageContext context, String target, String element, boolean editable, Map paramMap, ServletRequest req, ServletResponse res) \n    throws JspException {\n        \n        // the Flex controller provides access to the interal OpenCms structures\n        CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        \n        if (target == null) {\n            // set target to default\n            target = controller.getCmsObject().getRequestContext().getUri();\n        }\n                \n        // each include will have it's unique map of parameters\n        Map parameterMap = new HashMap();      \n        if (paramMap != null) {\n            // add all parameters from the parent elements\n            parameterMap.putAll(paramMap);\n        }                    \n        \n        if (element != null) {            \n            // add template element selector for JSP templates\n            addParameter(parameterMap, I_CmsConstants.C_PARAMETER_ELEMENT, element, true);\n        }        \n        \n        // resolve possible relative URI\n        target = CmsLinkManager.getAbsoluteUri(target, controller.getCurrentRequest().getElementUri());\n        \n        try {\n            // now resolve additional include extensions that might be required for special loader implementations\n            target = OpenCms.getResourceManager().resolveIncludeExtensions(target, element, editable, paramMap, req, res);\n        } catch (CmsException e) {\n            controller.setThrowable(e, target);\n            throw new JspException(e);\n        }\n        \n        // check the \"direct edit\" mode\n        String directEditPermissions = null;\n        String directEditIncludeFile = null;    \n        \n        if (editable) {\n            // get the include file where the direct edit HTML is stored in\n            directEditIncludeFile = (String)context.getRequest().getAttribute(I_CmsEditorActionHandler.C_DIRECT_EDIT_INCLUDE_FILE_URI);\n            if (directEditIncludeFile != null) {\n                // check the direct edit permissions of the current user                    \n                directEditPermissions = OpenCms.getWorkplaceManager().getEditorActionHandler().getEditMode(controller.getCmsObject(), target, element, req);\n            }\n            if (directEditPermissions == null) {\n                // \"editable\" is true only if both direct edit include file and direct edit permissions are available\n                editable = false;\n            }            \n        }\n        \n        // save old parameters from request\n        Map oldParameterMap = req.getParameterMap();        \n        \n        try {                     \n            // include direct edit \"start\" element (if enabled)\n            if (editable) {                \n                includeDirectEditElement(context, directEditIncludeFile, I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START + \"_\" + directEditPermissions, target, element, req, res);\n            }\n            \n            // add parameters (again) to set the correct element\n            controller.getCurrentRequest().addParameterMap(parameterMap); \n            \n            // write out a C_FLEX_CACHE_DELIMITER char on the page, this is used as a parsing delimeter later\n            context.getOut().print(CmsFlexResponse.C_FLEX_CACHE_DELIMITER);\n            \n            // add the target to the include list (the list will be initialized if it is currently empty)\n            controller.getCurrentResponse().addToIncludeList(target, parameterMap);\n            \n            // now use the Flex dispatcher to include the target (this will also work for targets in the OpenCms VFS)\n            // TODO: check if the \"req\" dispatcher should be used insted the controller\n            controller.getCurrentRequest().getRequestDispatcher(target).include(req, res); \n            \n            // include direct edit \"end\" element (if enabled)\n            if (editable) {\n                includeDirectEditElement(context, directEditIncludeFile, I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_END + \"_\" + directEditPermissions, target, element, req, res);\n            }\n            \n        } catch (ServletException e) {\n            Throwable t;\n            if (e.getRootCause() != null) {\n                t = e.getRootCause();\n            } else {\n                t = e;\n            }\n            t = controller.setThrowable(t, target);\n            throw new JspException(t);    \n        } catch (IOException e) {\n            Throwable t = controller.setThrowable(e, target);\n\n            throw new JspException(t);\n        } finally {\n            if (oldParameterMap != null) {\n                controller.getCurrentRequest().setParameterMap(oldParameterMap);\n            }\n        }           \n    }","id":3043,"modified_method":"/**\n     * Include action method.<p>\n     * \n     * The logic in this mehod is more complex than it should be.\n     * This is because of the XMLTemplate integration, which requires some settings \n     * to the parameters understandable only to XMLTemplate gurus.\n     * By putting this logic here it is not required to care about these issues\n     * on JSP pages, and you end up with considerable less JSP code.\n     * Also JSP developers need not to know the intrinsics of XMLTemplates this way.<p>\n     * \n     * @param context the current JSP page context\n     * @param target the target for the include, might be <code>null<\/code>\n     * @param element the element to select form the target might be <code>null<\/code>\n     * @param editable the flag to indicate if the target is editable\n     * @param paramMap a map of parameters for the include, will be merged with the request \n     *      parameters, might be <code>null<\/code>\n     * @param req the current request\n     * @param res the current response\n     * @throws JspException in case something goes wrong\n     */\n    public static void includeTagAction(\n        PageContext context,\n        String target,\n        String element,\n        boolean editable,\n        Map paramMap,\n        ServletRequest req,\n        ServletResponse res) throws JspException {\n\n        // the Flex controller provides access to the interal OpenCms structures\n        CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n\n        if (target == null) {\n            // set target to default\n            target = controller.getCmsObject().getRequestContext().getUri();\n        }\n\n        // each include will have it's unique map of parameters\n        Map parameterMap = new HashMap();\n        if (paramMap != null) {\n            // add all parameters from the parent elements\n            parameterMap.putAll(paramMap);\n        }\n\n        if (element != null) {\n            // add template element selector for JSP templates\n            addParameter(parameterMap, I_CmsConstants.C_PARAMETER_ELEMENT, element, true);\n        }\n\n        // resolve possible relative URI\n        target = CmsLinkManager.getAbsoluteUri(target, controller.getCurrentRequest().getElementUri());\n\n        try {\n            // now resolve additional include extensions that might be required for special loader implementations\n            target = OpenCms.getResourceManager().resolveIncludeExtensions(\n                target,\n                element,\n                editable,\n                paramMap,\n                req,\n                res);\n        } catch (CmsException e) {\n            controller.setThrowable(e, target);\n            throw new JspException(e);\n        }\n\n        // save old parameters from request\n        Map oldParameterMap = req.getParameterMap();\n\n        try {\n            // include direct edit \"start\" element (if enabled)\n            String directEditPermissions = null;\n            if (editable) {\n                directEditPermissions = CmsJspTagEditable.includeDirectEditElement(\n                    context,\n                    I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START,\n                    target,\n                    element,\n                    null,\n                    null,\n                    null);\n            }\n\n            // add parameters (again) to set the correct element\n            controller.getCurrentRequest().addParameterMap(parameterMap);\n\n            // write out a C_FLEX_CACHE_DELIMITER char on the page, this is used as a parsing delimeter later\n            context.getOut().print(CmsFlexResponse.C_FLEX_CACHE_DELIMITER);\n\n            // add the target to the include list (the list will be initialized if it is currently empty)\n            controller.getCurrentResponse().addToIncludeList(target, parameterMap);\n\n            // now use the Flex dispatcher to include the target (this will also work for targets in the OpenCms VFS)\n            controller.getCurrentRequest().getRequestDispatcher(target).include(req, res);\n\n            // include direct edit \"end\" element (if required)\n            if (directEditPermissions != null) {\n                CmsJspTagEditable.includeDirectEditElement(\n                    context,\n                    I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_END,\n                    target,\n                    element,\n                    null,\n                    directEditPermissions,\n                    null);\n            }\n\n        } catch (ServletException e) {\n\n            Throwable t;\n            if (e.getRootCause() != null) {\n                t = e.getRootCause();\n            } else {\n                t = e;\n            }\n            t = controller.setThrowable(t, target);\n            throw new JspException(t);\n        } catch (IOException e) {\n\n            Throwable t = controller.setThrowable(e, target);\n            throw new JspException(t);\n        } finally {\n\n            // restore old parameter map (if required)\n            if (oldParameterMap != null) {\n                controller.getCurrentRequest().setParameterMap(oldParameterMap);\n            }\n        }\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentFilter#getCreateLink(org.opencms.file.CmsObject, java.lang.String, java.lang.String)\n     */\n    public String getCreateLink(CmsObject cms, String filterName, String param) throws CmsException {\n\n        // if action is not set use default\n        if (filterName == null) {\n            filterName = m_filterNames[0];\n        }\n\n        switch (m_filters.indexOf(filterName)) {\n            case 0:\n                return getAllInFolderCreate(cms, param);\n            default:\n                throw new CmsException(\"Invalid XML content filter selected: \" + filterName);\n        }\n    }","id":3044,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentFilter#getCreateLink(org.opencms.file.CmsObject, java.lang.String, java.lang.String)\n     */\n    public String getCreateLink(CmsObject cms, String filterName, String param) throws CmsException {\n\n        // if action is not set use default\n        if (filterName == null) {\n            filterName = m_filterNames[0];\n        }\n\n        switch (m_filters.indexOf(filterName)) {\n            case 0:\n                // \"singleFile\" (does not support create link)\n                return null;\n            case 1:\n                return getAllInFolderCreate(cms, param);\n            default:\n                throw new CmsException(\"Invalid XML content filter selected: \" + filterName);\n        }\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentFilter#getFilterResults(org.opencms.file.CmsObject, java.lang.String, java.lang.String)\n     */\n    public List getFilterResults(CmsObject cms, String filterName, String param) throws CmsException {\n\n        // if action is not set use default\n        if (filterName == null) {\n            filterName = m_filterNames[0];\n        }\n\n        switch (m_filters.indexOf(filterName)) {\n            case 0:\n                return getAllInFolder(cms, param);\n            default:\n                throw new CmsException(\"Invalid XML content filter selected: \" + filterName);                    \n        }\n    }","id":3045,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentFilter#getFilterResults(org.opencms.file.CmsObject, java.lang.String, java.lang.String)\n     */\n    public List getFilterResults(CmsObject cms, String filterName, String param) throws CmsException {\n\n        // if action is not set use default\n        if (filterName == null) {\n            filterName = m_filterNames[0];\n        }\n\n        switch (m_filters.indexOf(filterName)) {\n            case 0:\n                return getSingleFile(cms, param);\n            case 1:\n                return getAllInFolder(cms, param);\n            default:\n                throw new CmsException(\"Invalid XML content filter selected: \" + filterName);\n        }\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the link to create a new XML content item in the folder pointed to by the parameter.<p>\n     * \n     * @param cms the current CmsObject\n     * @param param the folder name to use\n     * @return the link to create a new XML content item in the folder\n     * @throws CmsException if something goes wrong\n     */\n    protected String getAllInFolderCreate(CmsObject cms, String param) throws CmsException {\n\n        if (param == null) {\n            throw new CmsException(\"Filter requires a parameter e.g. in the form '/sites/default/myfolder/file_${number}.html|11'\");            \n        }\n        \n        int pos1 = param.indexOf('|');\n        if (pos1 == -1) {\n            throw new CmsException(\"Malformed filter parameter '\" + param + \"'\");\n        }\n\n        String path = param.substring(0, pos1);\n        String foldername = CmsResource.getFolderPath(path);\n\n        List result;\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"/\");\n\n            List resources = cms.getFilesInFolder(foldername, CmsResourceFilter.ALL);\n            result = new ArrayList(resources.size());\n\n            for (int i = 0; i < resources.size(); i++) {\n                // must check ALL resources in folder because named don't care for type\n                CmsResource resource = (CmsResource)resources.get(i);\n                result.add(cms.getSitePath(resource));\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        String checkName;\n        String number;\n\n        int j = 0;\n        do {\n            number = C_FORMAT_NUMBER.sprintf(++j);\n            checkName = CmsStringUtil.substitute(path, \"${number}\", number);\n        } while (result.contains(checkName));\n\n        return checkName.substring(cms.getRequestContext().getSiteRoot().length());\n    }","id":3046,"modified_method":"/**\n     * Returns the link to create a new XML content item in the folder pointed to by the parameter.<p>\n     * \n     * @param cms the current CmsObject\n     * @param param the folder name to use\n     * @return the link to create a new XML content item in the folder\n     * @throws CmsException if something goes wrong\n     */\n    protected String getAllInFolderCreate(CmsObject cms, String param) throws CmsException {\n\n        if (param == null) {\n            throw new IllegalArgumentException(\n                \"Filter requires a parameter e.g. in the form '/sites/default/myfolder/file_${number}.html|11'\");\n        }\n\n        int pos1 = param.indexOf('|');\n        if (pos1 == -1) {\n            throw new IllegalArgumentException(\"Malformed filter parameter '\" + param + \"'\");\n        }\n\n        String path = param.substring(0, pos1);\n        String foldername = CmsResource.getFolderPath(path);\n\n        List result;\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"/\");\n\n            List resources = cms.getFilesInFolder(foldername, CmsResourceFilter.ALL);\n            result = new ArrayList(resources.size());\n\n            for (int i = 0; i < resources.size(); i++) {\n                // must check ALL resources in folder because named don't care for type\n                CmsResource resource = (CmsResource)resources.get(i);\n                result.add(cms.getSitePath(resource));\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        String checkName;\n        String number;\n\n        int j = 0;\n        do {\n            number = C_FORMAT_NUMBER.sprintf(++j);\n            checkName = CmsStringUtil.substitute(path, \"${number}\", number);\n        } while (result.contains(checkName));\n\n        return checkName.substring(cms.getRequestContext().getSiteRoot().length());\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns all XML content objects in the folder pointed to by the parameter.<p>\n     * \n     * @param cms the current CmsObject\n     * @param param the folder name to use\n     * @return all XML content objects in the folder\n     * @throws CmsException if something goes wrong\n     */\n    protected List getAllInFolder(CmsObject cms, String param) throws CmsException {\n\n        if (param == null) {\n            throw new CmsException(\"Filter requires a parameter in the form '/sites/default/myfolder/|11'\");            \n        }\n        \n        int pos1 = param.indexOf('|');\n        if (pos1 == -1) {\n            throw new CmsException(\"Malformed filter parameter '\" + param + \"'\");\n        }\n\n        String foldername = CmsResource.getFolderPath(param.substring(0, pos1));\n        int type = Integer.valueOf(param.substring(pos1 + 1)).intValue();\n\n        List result;\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        int prefix = siteRoot.length();\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"/\");\n            List resources = cms.getFilesInFolder(foldername);\n            result = new ArrayList(resources.size());\n\n            Iterator i = resources.iterator();\n            while (i.hasNext()) {\n                CmsResource resource = (CmsResource)i.next();\n                if (resource.getTypeId() != type) {\n                    continue;\n                }\n                result.add(cms.getSitePath(resource).substring(prefix));\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        Collections.sort(result);\n        Collections.reverse(result);\n\n        return result;\n    }","id":3047,"modified_method":"/**\n     * Returns all XML content objects in the folder pointed to by the parameter.<p>\n     * \n     * @param cms the current CmsObject\n     * @param param the folder name to use\n     * @return all XML content objects in the folder\n     * @throws CmsException if something goes wrong\n     */\n    protected List getAllInFolder(CmsObject cms, String param) throws CmsException {\n\n        if (param == null) {\n            throw new IllegalArgumentException(\"Filter requires a parameter in the form '/sites/default/myfolder/|11'\");\n        }\n\n        int pos1 = param.indexOf('|');\n        if (pos1 == -1) {\n            throw new IllegalArgumentException(\"Malformed filter parameter '\" + param + \"'\");\n        }\n\n        String foldername = CmsResource.getFolderPath(param.substring(0, pos1));\n        int type = Integer.valueOf(param.substring(pos1 + 1)).intValue();\n\n        List result;\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        int prefix = siteRoot.length();\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"/\");\n            List resources = cms.getFilesInFolder(foldername);\n            result = new ArrayList(resources.size());\n\n            Iterator i = resources.iterator();\n            while (i.hasNext()) {\n                CmsResource resource = (CmsResource)i.next();\n                if (resource.getTypeId() != type) {\n                    continue;\n                }\n                result.add(cms.getSitePath(resource).substring(prefix));\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        Collections.sort(result);\n        Collections.reverse(result);\n\n        return result;\n    }","commit_id":"247b9f9f8ac6897a562e2ae06f80157d6d8a3ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a1a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3048,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a6a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6164634611271252587(final ReferenceMacroContext _context) {\n    SNode type = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\")));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a1a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a2a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a3a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632137\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a4a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632254\");\n    }\n    return null;\n  }","id":3049,"modified_method":"public static Object referenceMacro_GetReferent_6164634611271252587(final ReferenceMacroContext _context) {\n    SNode seqType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"))), new QueriesGenerated.Pattern_x583g4_a1a0a0a41(), true);\n    if (seqType == null) {\n      return null;\n    }\n    SNode elementType = SLinkOperations.getTarget(seqType, MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a3a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a4a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a5a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632137\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a6a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632254\");\n    }\n    return null;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a2a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3050,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a6a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_1.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_1, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a1a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3051,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a5a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6164634611271252527(final ReferenceMacroContext _context) {\n    SNode type = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\")));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a1a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263258755\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a2a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263262593\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a3a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263265578\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a4a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263268620\");\n    }\n    return null;\n  }","id":3052,"modified_method":"public static Object referenceMacro_GetReferent_6164634611271252527(final ReferenceMacroContext _context) {\n    SNode seqType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"))), new QueriesGenerated.Pattern_x583g4_a1a0a0a31(), true);\n    if (seqType == null) {\n      return null;\n    }\n    SNode elementType = SLinkOperations.getTarget(seqType, MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a3a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263258755\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a4a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263262593\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a5a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263265578\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a6a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263268620\");\n    }\n    return null;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a3a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3053,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a3a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a3a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3054,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a3a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a4a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_2.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_2, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3055,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a4a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a4a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_2.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_2, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3056,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a4a41() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_b0a2a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":3057,"modified_method":"private static SNode _quotation_createNode_x583g4_b0a5a31() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    return quotedNode_1;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_jy8svg_a0b0b() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, \"jetbrains.mps.lang.typesystem.structure.JoinType\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_6);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_7);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_3);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_8);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_4);\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_9.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_9, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_9);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_5);\n    return quotedNode_1;\n  }","id":3058,"modified_method":"private static SNode _quotation_createNode_jy8svg_a0c0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, \"jetbrains.mps.lang.typesystem.structure.JoinType\"), null, null, false);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_7, MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), (SNode) parameter_1);\n    quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_7);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_3);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x798c0d67da9d2175L, \"jetbrains.mps.lang.smodel.structure.SReferenceType\"), null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_8);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_4);\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_9);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_5);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), null, null, false);\n    quotedNode_10.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, \"classifier\"), quotedNode_10, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/java:org.jetbrains.mps.openapi.module(MPS.OpenAPI/)\"), facade.createNodeId(\"~SModule\")));\n    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_10);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x1129e737f02L, 0x1129e73a76aL, \"argument\"), quotedNode_6);\n    return quotedNode_2;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode showExpression, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      SNode _nodeToCheck_1029348928467 = showExpression;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246417176611\", 0, null);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246417176148\", true), (SNode) _quotation_createNode_jy8svg_a0a0b(), _info_12389875345);\n    }\n    if (!(typeCheckingContext.isSingleTypeComputation())) {\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(showExpression, MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246423284446\", 0, null);\n        typeCheckingContext.createLessThanInequality((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246423276130\", true), (SNode) _quotation_createNode_jy8svg_a0b0b(), true, true, _info_12389875345);\n      }\n    }\n  }","id":3059,"modified_method":"public void applyRule(final SNode showExpression, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      SNode _nodeToCheck_1029348928467 = showExpression;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246417176611\", 0, null);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246417176148\", true), (SNode) _quotation_createNode_jy8svg_a0a0b(), _info_12389875345);\n    }\n    final SNode Concept_typevar_1654718075370792335 = typeCheckingContext.createNewRuntimeTypesVariable();\n    if (!(typeCheckingContext.isSingleTypeComputation())) {\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(showExpression, MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246423284446\", 0, null);\n        typeCheckingContext.createLessThanInequality((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:71e81c80-d7fe-47f3-91de-9281cfae8376(jetbrains.mps.console.ideCommands.typesystem)\", \"7600370246423276130\", true), (SNode) _quotation_createNode_jy8svg_a0c0b(typeCheckingContext.getRepresentative(Concept_typevar_1654718075370792335)), true, true, _info_12389875345);\n      }\n    }\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doSiteLink(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString button_text = data.getParameters().getString(\"button_text\");\n\t\t\n\t\tObject retval = ltiService.insertToolSiteLink(id, button_text);\n\t\tif ( retval instanceof String ) {\n\t\t\tString prefix = ((String) retval).substring(0,2);\n\t\t\taddAlert(state, ((String) retval).substring(2));\n\t\t\tif (\"0-\".equals(prefix))\n\t\t\t{\n\t\t\t\tswitchPanel(state, \"Content\");\n\t\t\t}\n\t\t\telse if (\"1-\".equals(prefix))\n\t\t\t{\n\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\t\tswitchPanel(state, \"Refresh\");\n\t}","id":3060,"modified_method":"public void doSiteLink(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString button_text = data.getParameters().getString(\"button_text\");\n\t\t\n\t\tObject retval = ltiService.insertToolSiteLink(id, button_text);\n\t\tif ( retval instanceof String ) {\n\t\t\tString prefix = ((String) retval).substring(0,2);\n\t\t\taddAlert(state, ((String) retval).substring(2));\n\t\t\tif (\"0-\".equals(prefix))\n\t\t\t{\n\t\t\t\tswitchPanel(state, \"Content\");\n\t\t\t}\n\t\t\telse if (\"1-\".equals(prefix))\n\t\t\t{\n\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\n\t\tif ( ToolUtils.isInlineRequest(data.getRequest()) ) {\n\t\t\tswitchPanel(state, \"ToolSite\"); \n\t\t} else {\n\t\t\tswitchPanel(state, \"Refresh\");\n\t\t}\n\t}","commit_id":"b870f8f2185990530912baee6455bf1ad24c5c2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doContentPut(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tstate.removeAttribute(STATE_POST);\n\t\t\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\t\tObject retval = ltiService.insertToolContent(id, toolId, reqProps);\n\t\t\n\t\tLong contentKey = null;\n\t\tMap<String,Object> content = null;\n\t\tif ( retval instanceof String ) \n\t\t{\n\t\t\taddAlert(state, (String) retval);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\treturn;\n\t\t}\n\t\telse if ( retval instanceof Boolean )\n\t\t{\n\t\t\t//If it's true retrieve the previous content?\n\t\t\tif ((Boolean) retval == true) {\n\t\t\t\tcontent = ltiService.getContent(Long.parseLong(id));\n\t\t\t\tif ( content == null ) {\n\t\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TODO: returns false, should it do anyhing else? \n\t\t\t\tM_log.error(\"insertToolContent returned false for\" + id);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// the return value is the content key Long value\n\t\t\tid = ((Long) retval).toString();\n\t\t\tcontentKey = new Long(id);\n\t\t\tcontent = ltiService.getContent(contentKey);\n\t\t\tif ( content == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tString returnUrl = reqProps.getProperty(\"returnUrl\");\n\t\tif ( returnUrl != null )\n\t\t{\n\t\t\tif ( id != null ) {\n\t\t\t\tif ( returnUrl.startsWith(\"about:blank\") ) { // Redirect to the item\n\t\t\t\t\tif ( content != null ) {\n\t\t\t\t\t\tString launch = (String) ltiService.getContentLaunch(content);\n\t\t\t\t\t\tif ( launch != null ) returnUrl = launch;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Forward\");\n\t\t\t\t} else {\n\t\t\t\t\tif ( returnUrl.indexOf(\"?\") > 0 ) {\n\t\t\t\t\t\treturnUrl += \"&ltiItemId=/blti/\" + retval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnUrl += \"?ltiItemId=/blti/\" + retval;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Redirect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.setAttribute(STATE_REDIRECT_URL,returnUrl);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString success = null;\n\t\tif ( id == null ) \n\t\t{\n\t\t\tsuccess = rb.getString(\"success.created\");\n\t\t} else {\n\t\t\tsuccess = rb.getString(\"success.updated\");\n\t\t}\n\t\tstate.setAttribute(STATE_SUCCESS,success);\n\t\t\n\t\tString title = data.getParameters().getString(LTIService.LTI_PAGETITLE);\n\n\t\t// Take the title from the content (or tool) definition\n\t\tif (title == null || title.trim().length() < 1 ) {\n\t\t\tif ( content != null ) {\n\t\t\t\ttitle = (String) content.get(ltiService.LTI_PAGETITLE);\n\t\t\t}\n\t\t}\n\n\t\tif (reqProps.getProperty(\"add_site_link\") != null)\n\t\t{\n\t\t\t// this is to add site link:\n\t\t\tretval = ltiService.insertToolSiteLink(id, title);\n\t\t\tif ( retval instanceof String ) {\n\t\t\t\tString prefix = ((String) retval).substring(0,2);\n\t\t\t\taddAlert(state, ((String) retval).substring(2));\n\t\t\t\tif (\"0-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t}\n\t\t\t\telse if (\"1-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ( retval instanceof Boolean ) {\n\t\t\t\tif (((Boolean) retval).booleanValue())\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\t\t}\n\n\n\t\tswitchPanel(state, \"ToolSite\");\n\t}","id":3061,"modified_method":"public void doContentPut(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tstate.removeAttribute(STATE_POST);\n\t\t\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\n\t\t// Does an insert when id is null and update when is is not null\n\t\tObject retval = ltiService.insertToolContent(id, toolId, reqProps);\n\t\t\n\t\tLong contentKey = null;\n\t\tMap<String,Object> content = null;\n\t\tif ( retval instanceof String ) \n\t\t{\n\t\t\taddAlert(state, (String) retval);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\treturn;\n\t\t}\n\t\telse if ( retval instanceof Boolean )\n\t\t{\n\t\t\t//If it's true retrieve the previous content?\n\t\t\tif ((Boolean) retval == true) {\n\t\t\t\tcontent = ltiService.getContent(Long.parseLong(id));\n\t\t\t\tif ( content == null ) {\n\t\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TODO: returns false, should it do anyhing else? \n\t\t\t\tM_log.error(\"insertToolContent returned false for\" + id);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// the return value is the content key Long value\n\t\t\tid = ((Long) retval).toString();\n\t\t\tcontentKey = new Long(id);\n\t\t\tcontent = ltiService.getContent(contentKey);\n\t\t\tif ( content == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tString returnUrl = reqProps.getProperty(\"returnUrl\");\n\t\tif ( returnUrl != null )\n\t\t{\n\t\t\tif ( id != null ) {\n\t\t\t\tif ( returnUrl.startsWith(\"about:blank\") ) { // Redirect to the item\n\t\t\t\t\tif ( content != null ) {\n\t\t\t\t\t\tString launch = (String) ltiService.getContentLaunch(content);\n\t\t\t\t\t\tif ( launch != null ) returnUrl = launch;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Forward\");\n\t\t\t\t} else {\n\t\t\t\t\tif ( returnUrl.indexOf(\"?\") > 0 ) {\n\t\t\t\t\t\treturnUrl += \"&ltiItemId=/blti/\" + retval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnUrl += \"?ltiItemId=/blti/\" + retval;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Redirect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.setAttribute(STATE_REDIRECT_URL,returnUrl);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString success = null;\n\t\tif ( id == null ) \n\t\t{\n\t\t\tsuccess = rb.getString(\"success.created\");\n\t\t} else {\n\t\t\tsuccess = rb.getString(\"success.updated\");\n\t\t}\n\t\tstate.setAttribute(STATE_SUCCESS,success);\n\t\t\n\t\tString title = data.getParameters().getString(LTIService.LTI_PAGETITLE);\n\n\t\t// Take the title from the content (or tool) definition\n\t\tif (title == null || title.trim().length() < 1 ) {\n\t\t\tif ( content != null ) {\n\t\t\t\ttitle = (String) content.get(ltiService.LTI_PAGETITLE);\n\t\t\t}\n\t\t}\n\n\t\tif (reqProps.getProperty(\"add_site_link\") != null)\n\t\t{\n\t\t\t// this is to add site link:\n\t\t\tretval = ltiService.insertToolSiteLink(id, title);\n\t\t\tif ( retval instanceof String ) {\n\t\t\t\tString prefix = ((String) retval).substring(0,1);\n\t\t\t\taddAlert(state, ((String) retval).substring(1));\n\t\t\t\tif (\"0\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tif ( ToolUtils.isInlineRequest(data.getRequest()) ) {\n\t\t\t\t\t\tswitchPanel(state, \"ToolSite\"); \n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (\"1\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ( retval instanceof Boolean ) {\n\t\t\t\tif (((Boolean) retval).booleanValue())\n\t\t\t\t{\n\t\t\t\t\tif ( ToolUtils.isInlineRequest(data.getRequest()) ) {\n\t\t\t\t\t\tswitchPanel(state, \"ToolSite\"); \n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\t\t}\n\n\t\tswitchPanel(state, \"ToolSite\");\n\t}","commit_id":"b870f8f2185990530912baee6455bf1ad24c5c2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String prepareValidate(Map<String,Object> deploy, List<Map<String,Object>> theTools, \n\t\tProperties info, SessionState state)\n\t{\n        Long reg_state = foorm.getLongNull(deploy.get(LTIService.LTI_REG_STATE));\n\t\tString profileText = (String) deploy.get(LTIService.LTI_REG_PROFILE);\n\t\tif ( profileText == null || profileText.length() < 1 ) {\n\t\t\taddAlert(state,rb.getString(\"error.activate.not.ready\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\n        JSONObject providerProfile = (JSONObject) JSONValue.parse(profileText);\n\n\t\tList<Properties> profileTools = new ArrayList<Properties> ();\n        try {\n            String retval = LTI2Util.parseToolProfile(profileTools, info, providerProfile);\n            if ( retval != null ) {\n\t\t\t\taddAlert(state,rb.getString(\"deploy.parse.error\")+\" \"+retval);\n\t\t\t\treturn \"lti_error\";\n            }\n\t\t}\n        catch (Exception e ) {\n\t\t\taddAlert(state,rb.getString(\"deploy.parse.exception\")+\" \"+e.getLocalizedMessage());\n\t\t\te.printStackTrace();\n\t\t\treturn \"lti_error\";\n        }\n\n\t\tString instance_guid = (String) info.get(\"instance_guid\");\n\n        if ( profileTools.size() < 1 ) {\n\t\t\taddAlert(state,rb.getString(\"deploy.activate.notools\"));\n\t\t\treturn \"lti_error\";\n        }\n\n\t\t// Check them all first\n\t\tfor ( Properties profileTool : profileTools ) {\n\t\t\tString launch = (String) profileTool.get(LTIService.LTI_LAUNCH);\n\t\t\tif ( ! FormattedText.validateURL(launch) ) {\n\t\t\t\taddAlert(state,rb.getString(\"deploy.activate.badlaunch\")+\" \"+launch);\n\t\t\t\treturn \"lti_error\";\n\t\t\t}\n\t\t}\n\n\t\t// Make a copy of the deploy object and clean it up\n\t\tMap<String, Object> localDeploy = new HashMap<String, Object> ();\n\t\tlocalDeploy.putAll(deploy);\n\t\tlocalDeploy.remove(LTIService.LTI_ID);\n\t\tlocalDeploy.remove(LTIService.LTI_CREATED_AT);\n\t\tlocalDeploy.remove(LTIService.LTI_UPDATED_AT);\n\t\tlocalDeploy.remove(LTIService.LTI_REG_PROFILE);\n\n\t\t// Loop through all of the tools\n\t\tfor ( Properties profileTool : profileTools ) {\n\t\t\tString resource_type_code = (String) profileTool.get(\"resource_type_code\");\n\t\t\tString resource_handler = instance_guid;\n\t\t\tif ( ! resource_handler.endsWith(\"/\") && ! resource_handler.startsWith(\"/\") ) resource_handler = resource_handler + \"/\" ;\n\t\t\tresource_handler = resource_handler + resource_type_code;\n\t\t\tMap<String,Object> tool = ltiService.getToolForResourceHandlerDao(resource_handler);\n\n\t\t\t// Construct a new tool object\n\t\t\tMap<String, Object> newTool = new HashMap<String, Object> ();\n\t\t\tif ( tool != null ) {\n\t\t\t\tnewTool.putAll(tool);\n\t\t\t\tnewTool.putAll(localDeploy); // New settings from the deployment\n\t\t\t} else { \n\t\t\t\tnewTool.putAll(localDeploy); \n\t\t\t}\n\n\t\t\tnewTool.put(LTIService.LTI_RESOURCE_HANDLER, resource_handler);\n\t\t\tnewTool.put(LTIService.LTI_DEPLOYMENT_ID, deploy.get(LTIService.LTI_ID));\n\n\t\t\t// Copy explicitly in case the parser changes slightly\n\t\t\tif ( profileTool.get(LTIService.LTI_LAUNCH) != null ) newTool.put(LTIService.LTI_LAUNCH, profileTool.get(LTIService.LTI_LAUNCH));\n\t\t\tif ( profileTool.get(LTIService.LTI_TITLE) != null ) newTool.put(LTIService.LTI_TITLE, profileTool.get(LTIService.LTI_TITLE));\n\t\t\tif ( profileTool.get(LTIService.LTI_TITLE) != null ) newTool.put(LTIService.LTI_PAGETITLE, profileTool.get(LTIService.LTI_TITLE)); // Duplicate by default\n\t\t\tif ( profileTool.get(\"button\") != null ) newTool.put(LTIService.LTI_PAGETITLE, profileTool.get(\"button\")); // Note different fields\n\t\t\tif ( profileTool.get(LTIService.LTI_DESCRIPTION) != null ) newTool.put(LTIService.LTI_DESCRIPTION, profileTool.get(LTIService.LTI_DESCRIPTION));\n\t\t\tif ( profileTool.get(LTIService.LTI_PARAMETER) != null ) newTool.put(LTIService.LTI_PARAMETER, profileTool.get(LTIService.LTI_PARAMETER));\n\t\t\tif ( profileTool.get(LTIService.LTI_ENABLED_CAPABILITY) != null ) newTool.put(LTIService.LTI_ENABLED_CAPABILITY, profileTool.get(LTIService.LTI_ENABLED_CAPABILITY));\n\nSystem.out.println(\"newTool=\"+newTool);\n\t\t\ttheTools.add(newTool); \n\t\t}\n\t\treturn null; // Success\n\t}","id":3062,"modified_method":"public String prepareValidate(Map<String,Object> deploy, List<Map<String,Object>> theTools, \n\t\tProperties info, SessionState state)\n\t{\n        Long reg_state = foorm.getLongNull(deploy.get(LTIService.LTI_REG_STATE));\n\t\tString profileText = (String) deploy.get(LTIService.LTI_REG_PROFILE);\n\t\tif ( profileText == null || profileText.length() < 1 ) {\n\t\t\taddAlert(state,rb.getString(\"error.activate.not.ready\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\n        JSONObject providerProfile = (JSONObject) JSONValue.parse(profileText);\n\n\t\tList<Properties> profileTools = new ArrayList<Properties> ();\n        try {\n            String retval = LTI2Util.parseToolProfile(profileTools, info, providerProfile);\n            if ( retval != null ) {\n\t\t\t\taddAlert(state,rb.getString(\"deploy.parse.error\")+\" \"+retval);\n\t\t\t\treturn \"lti_error\";\n            }\n\t\t}\n        catch (Exception e ) {\n\t\t\taddAlert(state,rb.getString(\"deploy.parse.exception\")+\" \"+e.getLocalizedMessage());\n\t\t\te.printStackTrace();\n\t\t\treturn \"lti_error\";\n        }\n\n\t\tString instance_guid = (String) info.get(\"instance_guid\");\n\n        if ( profileTools.size() < 1 ) {\n\t\t\taddAlert(state,rb.getString(\"deploy.activate.notools\"));\n\t\t\treturn \"lti_error\";\n        }\n\n\t\t// Check them all first\n\t\tfor ( Properties profileTool : profileTools ) {\n\t\t\tString launch = (String) profileTool.get(LTIService.LTI_LAUNCH);\n\t\t\tif ( ! FormattedText.validateURL(launch) ) {\n\t\t\t\taddAlert(state,rb.getString(\"deploy.activate.badlaunch\")+\" \"+launch);\n\t\t\t\treturn \"lti_error\";\n\t\t\t}\n\t\t}\n\n\t\t// Make a copy of the deploy object and clean it up\n\t\tMap<String, Object> localDeploy = new HashMap<String, Object> ();\n\t\tlocalDeploy.putAll(deploy);\n\t\tlocalDeploy.remove(LTIService.LTI_ID);\n\t\tlocalDeploy.remove(LTIService.LTI_CREATED_AT);\n\t\tlocalDeploy.remove(LTIService.LTI_UPDATED_AT);\n\t\tlocalDeploy.remove(LTIService.LTI_REG_PROFILE);\n\n\t\t// Loop through all of the tools\n\t\tfor ( Properties profileTool : profileTools ) {\n\t\t\tString resource_type_code = (String) profileTool.get(\"resource_type_code\");\n\t\t\tString resource_handler = instance_guid;\n\t\t\tif ( ! resource_handler.endsWith(\"/\") && ! resource_handler.startsWith(\"/\") ) resource_handler = resource_handler + \"/\" ;\n\t\t\tresource_handler = resource_handler + resource_type_code;\n\t\t\tMap<String,Object> tool = ltiService.getToolForResourceHandlerDao(resource_handler);\n\n\t\t\t// Construct a new tool object\n\t\t\tMap<String, Object> newTool = new HashMap<String, Object> ();\n\t\t\tif ( tool != null ) {\n\t\t\t\tnewTool.putAll(tool);\n\t\t\t\tnewTool.putAll(localDeploy); // New settings from the deployment\n\t\t\t} else { \n\t\t\t\tnewTool.putAll(localDeploy); \n\t\t\t}\n\n\t\t\tnewTool.put(LTIService.LTI_RESOURCE_HANDLER, resource_handler);\n\t\t\tnewTool.put(LTIService.LTI_DEPLOYMENT_ID, deploy.get(LTIService.LTI_ID));\n\n\t\t\t// Copy explicitly in case the parser changes slightly\n\t\t\tif ( profileTool.get(LTIService.LTI_LAUNCH) != null ) newTool.put(LTIService.LTI_LAUNCH, profileTool.get(LTIService.LTI_LAUNCH));\n\t\t\tif ( profileTool.get(LTIService.LTI_TITLE) != null ) newTool.put(LTIService.LTI_TITLE, profileTool.get(LTIService.LTI_TITLE));\n\t\t\tif ( profileTool.get(LTIService.LTI_TITLE) != null ) newTool.put(LTIService.LTI_PAGETITLE, profileTool.get(LTIService.LTI_TITLE)); // Duplicate by default\n\t\t\tif ( profileTool.get(\"button\") != null ) newTool.put(LTIService.LTI_PAGETITLE, profileTool.get(\"button\")); // Note different fields\n\t\t\tif ( profileTool.get(LTIService.LTI_DESCRIPTION) != null ) newTool.put(LTIService.LTI_DESCRIPTION, profileTool.get(LTIService.LTI_DESCRIPTION));\n\t\t\tif ( profileTool.get(LTIService.LTI_PARAMETER) != null ) newTool.put(LTIService.LTI_PARAMETER, profileTool.get(LTIService.LTI_PARAMETER));\n\t\t\tif ( profileTool.get(LTIService.LTI_ENABLED_CAPABILITY) != null ) newTool.put(LTIService.LTI_ENABLED_CAPABILITY, profileTool.get(LTIService.LTI_ENABLED_CAPABILITY));\n\n\t\t\tM_log.info(\"newTool=\"+newTool);\n\t\t\ttheTools.add(newTool); \n\t\t}\n\t\treturn null; // Success\n\t}","commit_id":"b870f8f2185990530912baee6455bf1ad24c5c2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doContentDelete(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.delete\"));\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\treturn;\n\t\t}\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tObject retval = null;\n\t\tif ( id == null ) {\n\t\t\taddAlert(state,rb.getString(\"error.id.not.found\"));\n\t\t\tswitchPanel(state, \"DeploySystem\");\n\t\t\treturn;\n\t\t}\n\t\tLong key = new Long(id);\n\t\t// also remove the link\n\t\tif ( ltiService.deleteContent(key) )\n\t\t{\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.deleted\"));\n\t\t} else {\n\t\t\taddAlert(state,rb.getString(\"error.delete.fail\"));\n\t\t}\n\t\tswitchPanel(state, \"Refresh\");\n\t}","id":3063,"modified_method":"public void doContentDelete(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.delete\"));\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\treturn;\n\t\t}\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tObject retval = null;\n\t\tif ( id == null ) {\n\t\t\taddAlert(state,rb.getString(\"error.id.not.found\"));\n\t\t\tswitchPanel(state, \"ToolSite\");\n\t\t\treturn;\n\t\t}\n\t\tLong key = new Long(id);\n\t\t// also remove the link\n\t\tif ( ltiService.deleteContent(key) )\n\t\t{\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.deleted\"));\n\t\t} else {\n\t\t\taddAlert(state,rb.getString(\"error.delete.fail\"));\n\t\t}\t\n\n\t\tif ( ToolUtils.isInlineRequest(data.getRequest()) ) {\n\t\t\tswitchPanel(state, \"ToolSite\"); \n\t\t} else {\n\t\t\tswitchPanel(state, \"Refresh\");\n\t\t}\n\t}","commit_id":"b870f8f2185990530912baee6455bf1ad24c5c2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doLinkRemove(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\t\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tLong key = id == null ? null:new Long(id);\n\t\t\n\t\tString rv = ltiService.deleteContentLink(key);\n\t\tif (rv != null)\n\t\t{\n\t\t\t// there is error removing the external tool site link\n\t\t\taddAlert(state, rv);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// external tool site link removed successfully\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.remove\"));\n\t\t\tswitchPanel(state, \"Refresh\");\n\t\t}\n\t}","id":3064,"modified_method":"public void doLinkRemove(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\t\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tLong key = id == null ? null:new Long(id);\n\t\t\n\t\tString rv = ltiService.deleteContentLink(key);\n\t\tif (rv != null)\n\t\t{\n\t\t\t// there is error removing the external tool site link\n\t\t\taddAlert(state, rv);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// external tool site link removed successfully\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.remove\"));\n\t\t\tif ( ToolUtils.isInlineRequest(data.getRequest()) ) {\n\t\t\t\tswitchPanel(state, \"ToolSite\");\n\t\t\t} else {\n\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"b870f8f2185990530912baee6455bf1ad24c5c2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void solveInequations() {\n    Set<SNode> nodes = subtypingGraphVertices();\n\n    //1.transitive closure\n    for (SNode node1 : nodes) {\n      for (SNode node2 : nodes) {\n        for (SNode node3 : nodes) {\n          if (node1 == node2 || node2 == node3 || node1 == node3) continue;\n          Set<SNode> supertypes1 = mySubtypesToSupertypesMap.get(node1);\n          if (supertypes1 == null) continue;\n          Set<SNode> supertypes2 = mySubtypesToSupertypesMap.get(node2);\n          if (supertypes2 == null) continue;\n          if (supertypes1.contains(node2) && supertypes2.contains(node3)) {\n            supertypes1.add(node3);\n            mySupertypesToSubtypesMap.get(node3).add(node1);\n          }\n        }\n      }\n    }\n\n    //2.T>S\n    for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) continue;\n      Set<SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n      if (supertypes == null) continue;\n      for (SNode supertype : new HashSet<SNode>(supertypes)) {\n        if (supertype instanceof RuntimeTypeVariable) continue;\n        addInequation(node, supertype);\n        supertypes.remove(supertype);\n        mySupertypesToSubtypesMap.get(supertype).remove(node);\n      }\n    }\n\n    //3. a->b, b->a => a = b\n    for (SNode node : subtypingGraphVertices()) {\n      Set<SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n      if (supertypes == null) continue;\n      for (SNode supertype : new HashSet<SNode>(supertypes)) {\n        Set<SNode> supertypesSupertypes = mySubtypesToSupertypesMap.get(supertype);\n        if (supertypesSupertypes == null) continue;\n        for (SNode supertypesSubtype : supertypesSupertypes) {\n          if (supertypesSubtype == node) {\n            addEquation(node, supertype);\n          }\n        }\n      }\n    }\n\n    //4. {}->c->{S} => c = lcs({S})\n    outer: for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) {\n        Set<SNode> subtypes = mySupertypesToSubtypesMap.get(node);\n        if (subtypes == null) continue;\n        Set<SNode> concreteSubtypes = new HashSet<SNode>();\n        for (SNode subtype : new HashSet<SNode>(subtypes)) {\n          if (subtype instanceof RuntimeTypeVariable) {\n            continue; // outer;\n          }\n          concreteSubtypes.add(subtype);\n          subtypes.remove(subtype);\n          mySubtypesToSupertypesMap.get(subtype).remove(node);\n        }\n        Set<SNode> lcs = SubtypingManager.lowestCommonSupertypes(concreteSubtypes);\n        if (lcs.isEmpty()) {\n          ErrorReporter.getInstance().setErrorString(node, \"can't find common supertype\");//todo show subtypes\n          TypeChecker.reportTypeError(node);\n        } else {\n          addEquation(node, lcs.iterator().next()); // todo not just first type but intersection\n        }\n      }\n    }\n\n    //5. T->c->{} => c = T\n    for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) {\n        Set<SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n        if (supertypes == null) continue;\n        if (supertypes.size() == 1) {\n          SNode supertype = supertypes.iterator().next();\n          Set<SNode> subtypes = mySupertypesToSubtypesMap.get(node);\n          if (subtypes == null || subtypes.isEmpty()) {\n            supertypes.remove(supertype);\n            mySupertypesToSubtypesMap.get(supertype).remove(node);\n            addEquation(supertype, node);\n          }\n        }\n      }\n    }\n  }","id":3065,"modified_method":"public void solveInequations() {\n    Set<SNode> nodes = subtypingGraphVertices();\n\n    //1.transitive closure\n    for (SNode node2 : nodes) {\n      for (SNode node1 : nodes) {\n        for (SNode node3 : nodes) {\n          if (node1 == node2 || node2 == node3 || node1 == node3) continue;\n          Map<SNode,SNode> supertypes1 = mySubtypesToSupertypesMap.get(node1);\n          if (supertypes1 == null) continue;\n          Map<SNode,SNode> supertypes2 = mySubtypesToSupertypesMap.get(node2);\n          if (supertypes2 == null) continue;\n          if (supertypes1.keySet().contains(node2) && supertypes2.keySet().contains(node3)) {\n            mySubtypesToSupertypesMap.get(node1).put(node3, supertypes1.get(node2));\n            mySupertypesToSubtypesMap.get(node3).put(node1, supertypes1.get(node2));\n          }\n        }\n      }\n    }\n\n    //2.T>S\n    for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) continue;\n      Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n      if (supertypes == null) continue;\n      for (SNode supertype : new HashSet<SNode>(supertypes.keySet())) {\n        if (supertype instanceof RuntimeTypeVariable) continue;\n        addInequation(node, supertype, supertypes.get(supertype));\n        supertypes.remove(supertype);\n        mySupertypesToSubtypesMap.get(supertype).remove(node);\n      }\n    }\n\n    //3. a->b, b->a => a = b\n    for (SNode node : subtypingGraphVertices()) {\n      Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n      if (supertypes == null) continue;\n      for (SNode supertype : new HashSet<SNode>(supertypes.keySet())) {\n        Map<SNode,SNode> supertypesSupertypes = mySubtypesToSupertypesMap.get(supertype);\n        if (supertypesSupertypes == null) continue;\n        for (SNode supertypesSubtype : supertypesSupertypes.keySet()) {\n          if (supertypesSubtype == node) {\n            addEquation(node, supertype, supertypesSupertypes.get(supertypesSubtype));\n          }\n        }\n      }\n    }\n\n    //4. {}->c->{S} => c = lcs({S})\n    outer: for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) {\n        Map<SNode,SNode> subtypes = mySupertypesToSubtypesMap.get(node);\n        if (subtypes == null) continue;\n        Set<SNode> concreteSubtypes = new HashSet<SNode>();\n        Set<SNode> nodesToCheck = new HashSet<SNode>();\n        for (SNode subtype : new HashSet<SNode>(subtypes.keySet())) {\n          if (subtype instanceof RuntimeTypeVariable) {\n            continue; // outer;\n          }\n          concreteSubtypes.add(subtype);\n          nodesToCheck.add(subtypes.get(subtype));\n          subtypes.remove(subtype);\n          mySubtypesToSupertypesMap.get(subtype).remove(node);\n        }\n        SNode nodeToCheck = nodesToCheck.isEmpty() ? null : nodesToCheck.iterator().next(); //todo nodeToCheck is chosen randomly\n        Set<SNode> lcs = SubtypingManager.lowestCommonSupertypes(concreteSubtypes);\n        if (lcs.isEmpty()) {\n          TypeChecker.reportTypeError(nodeToCheck,\"can't find common supertype\"); //todo show subtypes\n        } else {\n          addEquation(node, lcs.iterator().next(), nodeToCheck); // todo not just first type but intersection\n        }\n      }\n    }\n\n    //5. T->c->{} => c = T\n    for (SNode node : subtypingGraphVertices()) {\n      if (node instanceof RuntimeTypeVariable) {\n        Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(node);\n        if (supertypes == null) continue;\n        if (supertypes.size() == 1) {\n          SNode supertype = supertypes.keySet().iterator().next();\n          Map<SNode,SNode> subtypes = mySupertypesToSubtypesMap.get(node);\n          if (subtypes == null || subtypes.isEmpty()) {\n            supertypes.remove(supertype);\n            mySupertypesToSubtypesMap.get(supertype).remove(node);\n            addEquation(supertype, node, supertypes.get(supertype));\n          }\n        }\n      }\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addInequation(SNode subType, SNode supertype) {\n    SNode subtypeRepresentator = getRepresentator(subType);\n    SNode supertypeRepresentator = getRepresentator(supertype);\n\n    // no equation needed\n    if (subtypeRepresentator == supertypeRepresentator) return;\n\n    // if one of them is a var\n    RuntimeTypeVariable varSubtype = TypeVariablesManager.getTypeVar(subtypeRepresentator);\n    RuntimeTypeVariable varSupertype = TypeVariablesManager.getTypeVar(supertypeRepresentator);\n    if (varSubtype != null || varSupertype != null) {\n      addSubtyping(subtypeRepresentator, supertypeRepresentator);\n      return;\n    }\n\n    // if strict subtyping\n    if (SubtypingManager.getInstance().isSubtype(subtypeRepresentator, supertypeRepresentator)) {\n      return;\n    }\n\n    ErrorReporter.getInstance().setErrorString(subtypeRepresentator, \"type \"+ subtypeRepresentator+\" should be a subtype of \"+supertypeRepresentator);\n    TypeChecker.reportTypeError(subtypeRepresentator);\n  }","id":3066,"modified_method":"public void addInequation(SNode subType, SNode supertype, SNode nodeToCheck) {\n    SNode subtypeRepresentator = getRepresentator(subType);\n    SNode supertypeRepresentator = getRepresentator(supertype);\n\n    // no equation needed\n    if (subtypeRepresentator == supertypeRepresentator) return;\n\n    // if one of them is a var\n    RuntimeTypeVariable varSubtype = TypeVariablesManager.getTypeVar(subtypeRepresentator);\n    RuntimeTypeVariable varSupertype = TypeVariablesManager.getTypeVar(supertypeRepresentator);\n    if (varSubtype != null || varSupertype != null) {\n      addSubtyping(subtypeRepresentator, supertypeRepresentator, nodeToCheck);\n      return;\n    }\n\n    // if strict subtyping\n    if (SubtypingManager.getInstance().isSubtype(subtypeRepresentator, supertypeRepresentator)) {\n      return;\n    }\n\n    String errorText = \"type \"+ subtypeRepresentator+\" should be a subtype of \"+supertypeRepresentator;\n    TypeChecker.reportTypeError(nodeToCheck, errorText);\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addSubtyping(SNode subtype, SNode supertype) {\n    Set<SNode> supertypes = mySubtypesToSupertypesMap.get(subtype);\n    if (supertypes == null) {\n      supertypes = new HashSet<SNode>();\n      mySubtypesToSupertypesMap.put(subtype, supertypes);\n    }\n    supertypes.add(supertype);\n\n    Set<SNode> subtypes = mySupertypesToSubtypesMap.get(supertype);\n    if (subtypes == null) {\n      subtypes = new HashSet<SNode>();\n      mySupertypesToSubtypesMap.put(supertype, subtypes);\n    }\n    subtypes.add(subtype);\n  }","id":3067,"modified_method":"private void addSubtyping(SNode subtype, SNode supertype, SNode nodeToCheck) {\n    Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(subtype);\n    if (supertypes == null) {\n      supertypes = new HashMap<SNode, SNode>();\n      mySubtypesToSupertypesMap.put(subtype, supertypes);\n    }\n    supertypes.put(supertype, nodeToCheck);\n\n    Map<SNode,SNode> subtypes = mySupertypesToSubtypesMap.get(supertype);\n    if (subtypes == null) {\n      subtypes = new HashMap<SNode, SNode>();\n      mySupertypesToSubtypesMap.put(supertype, subtypes);\n    }\n    subtypes.put(subtype, nodeToCheck);\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void keepInequation(SNode var, SNode type) {\n    if (mySubtypesToSupertypesMap.containsKey(var)) {\n      Set<SNode> supertypes = mySubtypesToSupertypesMap.get(var);\n      mySubtypesToSupertypesMap.remove(var);\n      for (SNode supertype : supertypes) {\n        mySupertypesToSubtypesMap.get(supertype).remove(var);\n      }\n      for (SNode supertype : supertypes) {\n        addInequation(type, supertype);\n      }\n    }\n    if (mySupertypesToSubtypesMap.containsKey(var)) {\n      Set<SNode> subtypes = mySupertypesToSubtypesMap.get(var);\n      mySupertypesToSubtypesMap.remove(var);\n      for (SNode subtype : subtypes) {\n        mySubtypesToSupertypesMap.get(subtype).remove(var);\n      }\n      for (SNode subtype : subtypes) {\n        addInequation(subtype, type);\n      }\n    }\n  }","id":3068,"modified_method":"private void keepInequation(SNode var, SNode type) {\n    if (mySubtypesToSupertypesMap.containsKey(var)) {\n      Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(var);\n      mySubtypesToSupertypesMap.remove(var);\n      for (SNode supertype : supertypes.keySet()) {\n        mySupertypesToSubtypesMap.get(supertype).remove(var);\n      }\n      for (SNode supertype : supertypes.keySet()) {\n        addInequation(type, supertype, supertypes.get(supertype));\n      }\n    }\n    if (mySupertypesToSubtypesMap.containsKey(var)) {\n      Map<SNode,SNode> subtypes = mySupertypesToSubtypesMap.get(var);\n      mySupertypesToSubtypesMap.remove(var);\n      for (SNode subtype : subtypes.keySet()) {\n        mySubtypesToSupertypesMap.get(subtype).remove(var);\n      }\n      for (SNode subtype : subtypes.keySet()) {\n        addInequation(subtype, type, subtypes.get(subtype));\n      }\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void processEquation(SNode var, SNode type) {\n    setParent(var, type);\n    keepInequation(var, type);\n    TypeVariablesManager.getInstance().addAllVarSetsOfSourceAndRemoveSourceFromThem(type, var);\n    if (TypeVariablesManager.getTypeVar(var) instanceof RuntimeErrorType) {\n      TypeChecker.reportTypeError(var);\n    }\n  }","id":3069,"modified_method":"private void processEquation(SNode var, SNode type, SNode nodeToCheck) {\n    setParent(var, type);\n    keepInequation(var, type);\n    TypeVariablesManager.getInstance().addAllVarSetsOfSourceAndRemoveSourceFromThem(type, var);\n    RuntimeTypeVariable typeVar = TypeVariablesManager.getTypeVar(var);\n    if (typeVar instanceof RuntimeErrorType) {\n      TypeChecker.reportTypeError(nodeToCheck,((RuntimeErrorType)typeVar).getErrorText());\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void processErrorEquation(SNode type, SNode error, String errorText) {\n    setParent(error, type); //type\n    ErrorReporter.getInstance().setErrorString(error, errorText);\n    TypeVariablesManager.getInstance().addAllVarSetsOfSourceAndRemoveSourceFromThem(type, error);\n    TypeChecker.reportTypeError(error);\n  }","id":3070,"modified_method":"private void processErrorEquation(SNode type, SNode error, String errorText, SNode nodeToCheck) {\n    setParent(error, type); //type\n    TypeVariablesManager.getInstance().addAllVarSetsOfSourceAndRemoveSourceFromThem(type, error);\n    TypeChecker.reportTypeError(nodeToCheck, errorText);\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeSubtyping(SNode subtype, SNode supertype) {\n    Set<SNode> supertypes = mySubtypesToSupertypesMap.get(subtype);\n    if (supertypes != null) {\n      supertypes.remove(supertype);\n    }\n\n    Set<SNode> subtypes = mySupertypesToSubtypesMap.get(supertype);\n    if (subtypes != null) {\n      subtypes.remove(subtype);\n    }\n  }","id":3071,"modified_method":"private void removeSubtyping(SNode subtype, SNode supertype) {\n    Map<SNode,SNode> supertypes = mySubtypesToSupertypesMap.get(subtype);\n    if (supertypes != null) {\n      supertypes.remove(supertype);\n    }\n\n    Map<SNode,SNode> subtypes = mySupertypesToSubtypesMap.get(supertype);\n    if (subtypes != null) {\n      subtypes.remove(subtype);\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEquation(SNode lhs, SNode rhs) {\n    SNode rhsRepresentator = getRepresentator(lhs);\n    SNode lhsRepresentator = getRepresentator(rhs);\n\n    // no equation needed\n    if (rhsRepresentator == lhsRepresentator) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = TypeVariablesManager.getTypeVar(rhsRepresentator);\n    RuntimeTypeVariable varLhs = TypeVariablesManager.getTypeVar(lhsRepresentator);\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator);\n        return;\n      }\n    }\n\n    // solve equation\n    if (!compareNodes(rhsRepresentator, lhsRepresentator)) {\n      String error = \"incompatible types: \" + rhsRepresentator + \" and \" + lhsRepresentator; //todo more friendly error representation\n      processErrorEquation(lhsRepresentator, rhsRepresentator, error);\n      return;\n    }\n    Set<Pair<SNode, SNode>> childEQs = createChildEquations(rhsRepresentator, lhsRepresentator);\n    for (Pair<SNode, SNode> eq : childEQs) {\n      addEquation(eq.o2, eq.o1);\n    }\n  }","id":3072,"modified_method":"public void addEquation(SNode lhs, SNode rhs, SNode nodeToCheck) {\n    SNode rhsRepresentator = getRepresentator(lhs);\n    SNode lhsRepresentator = getRepresentator(rhs);\n\n    // no equation needed\n    if (rhsRepresentator == lhsRepresentator) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = TypeVariablesManager.getTypeVar(rhsRepresentator);\n    RuntimeTypeVariable varLhs = TypeVariablesManager.getTypeVar(lhsRepresentator);\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator, nodeToCheck);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator, nodeToCheck);\n        return;\n      }\n    }\n\n    // solve equation\n    if (!compareNodes(rhsRepresentator, lhsRepresentator)) {\n      String error = \"incompatible types: \" + rhsRepresentator + \" and \" + lhsRepresentator; //todo more friendly error representation\n      processErrorEquation(lhsRepresentator, rhsRepresentator, error, nodeToCheck);\n      return;\n    }\n    Set<Pair<SNode, SNode>> childEQs = createChildEquations(rhsRepresentator, lhsRepresentator);\n    for (Pair<SNode, SNode> eq : childEQs) {\n      addEquation(eq.o2, eq.o1, nodeToCheck);\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void checkTypes(SNode root, SModel typesModel) {\n    //clear\n    clearForTypesModel(typesModel);\n\n    //register contexts\n    for (ContextDeclaration contextDeclaration : typesModel.getRoots(ContextDeclaration.class)) {\n      if (contextDeclaration.getMain()) {\n        ContextsManager.getInstance().registerMainContext(contextDeclaration.getName());\n      } else {\n        ContextsManager.getInstance().registerNewContext(contextDeclaration.getName());\n      }\n    }\n\n    //register global varsets\n    for (VariableSetDeclaration varset : typesModel.getRoots(VariableSetDeclaration.class)) {\n      TypeVariablesManager.getInstance().registerNewVarset(varset);\n    }\n\n    // load rules\n    ourRules = new ArrayList<Rule>();\n    for (Rule rule : typesModel.getRoots(Rule.class)) {\n      ourRules.add(rule);\n    }\n\n    // load subtyping rules\n    SubtypingManager.getInstance().initiate(typesModel);\n\n    // load adaptation rules\n    AdaptationManager.getInstance().initiate(typesModel);\n\n    // check types\n    doCheckTypes(root);\n\n    // solve residual inequations\n    EquationManager.getInstance().solveInequations();\n\n    // main context\n    Set<Pair<SNode, SNode>> mainContext = ContextsManager.getInstance().getMainContext();\n\n    // setting types to nodes\n    for (Pair<SNode, SNode> contextEntry : mainContext) {\n      SNode term = contextEntry.o1;\n      SNode type = expandType(contextEntry.o2, Interpretator.getRuntimeTypesModel(typesModel));\n      if (type instanceof RuntimeErrorType) {\n        reportTypeError(type, term);\n      }\n      term.putUserObject(TYPE_OF_TERM, type);\n    }\n\n    // setting errors\n    for (SNode node : ourNodesWithErrors.keySet()) {\n      SNode errorType = ourNodesWithErrors.get(node);\n      node.putUserObject(TYPE_OF_TERM, errorType);\n    }\n  }","id":3073,"modified_method":"public static void checkTypes(SNode root, SModel typesModel) {\n    //clear\n    clearForTypesModel(typesModel);\n\n    //register contexts\n    for (ContextDeclaration contextDeclaration : typesModel.getRoots(ContextDeclaration.class)) {\n      if (contextDeclaration.getMain()) {\n        ContextsManager.getInstance().registerMainContext(contextDeclaration.getName());\n      } else {\n        ContextsManager.getInstance().registerNewContext(contextDeclaration.getName());\n      }\n    }\n\n    //register global varsets\n    for (VariableSetDeclaration varset : typesModel.getRoots(VariableSetDeclaration.class)) {\n      TypeVariablesManager.getInstance().registerNewVarset(varset);\n    }\n\n    // load rules\n    ourRules = new ArrayList<Rule>();\n    for (Rule rule : typesModel.getRoots(Rule.class)) {\n      ourRules.add(rule);\n    }\n\n    // load subtyping rules\n    SubtypingManager.getInstance().initiate(typesModel);\n\n    // load adaptation rules\n    AdaptationManager.getInstance().initiate(typesModel);\n\n    // check types\n    doCheckTypes(root);\n\n    // solve residual inequations\n    EquationManager.getInstance().solveInequations();\n\n    // main context\n    Set<Pair<SNode, SNode>> mainContext = ContextsManager.getInstance().getMainContext();\n\n    // setting types to nodes\n    for (Pair<SNode, SNode> contextEntry : mainContext) {\n      SNode term = contextEntry.o1;\n      SNode type = expandType(contextEntry.o2, Interpretator.getRuntimeTypesModel(typesModel));\n      if (type instanceof RuntimeErrorType) {\n        reportTypeError(term, ((RuntimeErrorType)type).getErrorText());\n      }\n      term.putUserObject(TYPE_OF_TERM, type);\n    }\n\n    // setting errors\n    for (SNode node : ourNodesWithErrors.keySet()) {\n      String errorString = ourNodesWithErrors.get(node);\n      node.putUserObject(TYPE_OF_TERM, errorString);\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void reportTypeError(SNode errorType, SNode nodeWithError) {\n    if (nodeWithError != null) {\n      ourNodesWithErrors.put(nodeWithError, errorType);\n    } else {\n      LOG.warning(\"can't report error: error has no related node\");\n    }\n  }","id":3074,"modified_method":"public static void reportTypeError(SNode nodeWithError, String errorString) {\n    if (nodeWithError != null) {\n      ourNodesWithErrors.put(nodeWithError, errorString);\n    } else {\n      LOG.warning(\"can't report error: error has no related node\");\n    }\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void clearForTypesModel(SModel typesModel) {\n    ContextsManager.getInstance().clear();\n    EquationManager.getInstance().clear();\n    TypeVariablesManager.getInstance().clearVariables();\n    Interpretator.clearForTypesModel(typesModel);\n    SubtypingManager.getInstance().clear();\n    AdaptationManager.getInstance().clear();\n    ErrorReporter.getInstance().clear();\n    ourRules.clear();\n    ourCheckedNodes.clear();\n    ourNodesWithErrors.clear();\n  }","id":3075,"modified_method":"public static void clearForTypesModel(SModel typesModel) {\n    ContextsManager.getInstance().clear();\n    EquationManager.getInstance().clear();\n    TypeVariablesManager.getInstance().clearVariables();\n    Interpretator.clearForTypesModel(typesModel);\n    SubtypingManager.getInstance().clear();\n    AdaptationManager.getInstance().clear();\n    ourRules.clear();\n    ourCheckedNodes.clear();\n    ourNodesWithErrors.clear();\n  }","commit_id":"93652b1ae5c99ec558edaeffd8672e4f25bd8f38","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void addJournalStructures(\n\t\t\tlong groupId, long userId, Locale locale)\n\t\tthrows Exception {\n\n\t\t// Article\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tnameMap.put(locale, \"Article\");\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This structure accommodates article title, both main, and \" +\n\t\t\t\t\"preview images, and the main article body.\");\n\n\t\tString xsd = getFileAsString(\"/structures/article.xml\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tDDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"ARTICLE\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t// Carousel\n\n\t\tnameMap.put(locale, \"Carousel\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a simple carousel structure designed to handle other \" +\n\t\t\t\t\"necessary carousel configurations.\");\n\n\t\txsd = getFileAsString(\"/structures/multiple_item_carousel.xml\");\n\n\t\tDDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM-CAROUSEL\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t// Multiple Item\n\n\t\tnameMap.put(locale, \"Multiple Item\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a simple structure with a single repeatable element \" +\n\t\t\t\t\"that includes an HTML field, and text-box for a title and \" +\n\t\t\t\t\t\"URL designation.\");\n\n\t\txsd = getFileAsString(\"/structures/multiple_item.xml\");\n\n\t\tDDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\t}","id":3076,"modified_method":"protected void addJournalStructures(\n\t\t\tlong groupId, long userId, Locale locale)\n\t\tthrows Exception {\n\n\t\t// Article\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tnameMap.put(locale, \"Article\");\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This structure accommodates article title, both main, and \" +\n\t\t\t\t\"preview images, and the main article body.\");\n\n\t\tString xsd = getFileAsString(\"/structures/article.xml\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"ARTICLE\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t_ddmStructureIds.put(\n\t\t\tgroupId + \"#\" + \"ARTICLE\", ddmStructure.getStructureId());\n\n\t\t// Carousel\n\n\t\tnameMap.put(locale, \"Carousel\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a simple carousel structure designed to handle other \" +\n\t\t\t\t\"necessary carousel configurations.\");\n\n\t\txsd = getFileAsString(\"/structures/multiple_item_carousel.xml\");\n\n\t\tddmStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM-CAROUSEL\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t_ddmStructureIds.put(\n\t\t\tgroupId + \"#\" + \"MULTIPLE-ITEM-CAROUSEL\",\n\t\t\tddmStructure.getStructureId());\n\n\t\t// Multiple Item\n\n\t\tnameMap.put(locale, \"Multiple Item\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a simple structure with a single repeatable element \" +\n\t\t\t\t\"that includes an HTML field, and text-box for a title and \" +\n\t\t\t\t\t\"URL designation.\");\n\n\t\txsd = getFileAsString(\"/structures/multiple_item.xml\");\n\n\t\tddmStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, 0, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM\", nameMap, descriptionMap,\n\t\t\tJournalConverterUtil.getDDMXSD(xsd), \"xml\",\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t_ddmStructureIds.put(\n\t\t\tgroupId + \"#\" + \"MULTIPLE-ITEM\", ddmStructure.getStructureId());\n\t}","commit_id":"06b8f8fb6e2e7ddcc4652451deec2edc626ce35f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addJournalTemplates(long groupId, long userId, Locale locale)\n\t\tthrows Exception {\n\n\t\t// Regular Article Description\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"ARTICLE\");\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tnameMap.put(locale, \"Regular Article Description\");\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This template only displays brief descriptions of web content\");\n\n\t\tString script = getFileAsString(\"/templates/article_description.vm\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tddmStructure.getStructureId(), \"ARTICLE-DESCRIPTION\", nameMap,\n\t\t\tdescriptionMap, DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Regular Article\n\n\t\tnameMap.put(locale, \"Regular Article\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is the regular article template, it handles basic article \" +\n\t\t\t\t\"content like, titles, main image, body, and author \" +\n\t\t\t\t\t\"information.\");\n\n\t\tscript = getFileAsString(\"/templates/regular_article.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tddmStructure.getStructureId(), \"REGULAR-ARTICLE\", nameMap,\n\t\t\tdescriptionMap, DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Carousel\n\n\t\tddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM-CAROUSEL\");\n\n\t\tnameMap.put(locale, \"Carousel\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is the carousel template that utilizes Alloy UI to display \" +\n\t\t\t\t\"repeatable content as a slideshow.\");\n\n\t\tscript = getFileAsString(\"/templates/multiple_item_carousel.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tddmStructure.getStructureId(), \"MULTIPLE-ITEM-CAROUSEL\", nameMap,\n\t\t\tdescriptionMap, DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Featured Items\n\n\t\tddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(JournalArticle.class),\n\t\t\t\"MULTIPLE-ITEM\");\n\n\t\tnameMap.put(locale, \"Featured Items\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a template that utilizes the Multiple Item Structure, \" +\n\t\t\t\t\"and displays the data as Featured Items.\");\n\n\t\tscript = getFileAsString(\"/templates/multiple_item_feature.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tddmStructure.getStructureId(), \"MULTIPLE-ITEM-FEATURE\", nameMap,\n\t\t\tdescriptionMap, DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\t}","id":3077,"modified_method":"protected void addJournalTemplates(long groupId, long userId, Locale locale)\n\t\tthrows Exception {\n\n\t\t// Regular Article Description\n\n\t\tlong classPK = _ddmStructureIds.get(groupId + \"#\" + \"ARTICLE\");\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tnameMap.put(locale, \"Regular Article Description\");\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This template only displays brief descriptions of web content\");\n\n\t\tString script = getFileAsString(\"/templates/article_description.vm\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tclassPK, \"ARTICLE-DESCRIPTION\", nameMap, descriptionMap,\n\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Regular Article\n\n\t\tnameMap.put(locale, \"Regular Article\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is the regular article template, it handles basic article \" +\n\t\t\t\t\"content like, titles, main image, body, and author \" +\n\t\t\t\t\t\"information.\");\n\n\t\tscript = getFileAsString(\"/templates/regular_article.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tclassPK, \"REGULAR-ARTICLE\", nameMap, descriptionMap,\n\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Carousel\n\n\t\tclassPK = _ddmStructureIds.get(\n\t\t\tgroupId + \"#\" + \"MULTIPLE-ITEM-CAROUSEL\");\n\n\t\tnameMap.put(locale, \"Carousel\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is the carousel template that utilizes Alloy UI to display \" +\n\t\t\t\t\"repeatable content as a slideshow.\");\n\n\t\tscript = getFileAsString(\"/templates/multiple_item_carousel.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tclassPK, \"MULTIPLE-ITEM-CAROUSEL\", nameMap, descriptionMap,\n\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\n\t\t// Featured Items\n\n\t\tclassPK = _ddmStructureIds.get(groupId + \"#\" + \"MULTIPLE-ITEM\");\n\n\t\tnameMap.put(locale, \"Featured Items\");\n\n\t\tdescriptionMap.put(\n\t\t\tlocale,\n\t\t\t\"This is a template that utilizes the Multiple Item Structure, \" +\n\t\t\t\t\"and displays the data as Featured Items.\");\n\n\t\tscript = getFileAsString(\"/templates/multiple_item_feature.vm\");\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tclassPK, \"MULTIPLE-ITEM-FEATURE\", nameMap, descriptionMap,\n\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\tTemplateConstants.LANG_TYPE_VM, script, true, false,\n\t\t\tStringPool.BLANK, null, serviceContext);\n\t}","commit_id":"06b8f8fb6e2e7ddcc4652451deec2edc626ce35f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.AbstractAction\");\n      }\n    });\n  }","id":3078,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.AbstractAction\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.BeanExtensionPoint\");\n      }\n    });\n  }","id":3079,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.BeanExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.ExtensionPoint\");\n      }\n    });\n  }","id":3080,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.ExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.IntefaceExtensionPoint\");\n      }\n    });\n  }","id":3081,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.IntefaceExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.Plugin\");\n      }\n    });\n  }","id":3082,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.Plugin\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void registerServletContainerInitializerAnnotationHandlers (WebAppContext context, AnnotationParser parser)\n    throws Exception\n    {     \n        //TODO verify my interpretation of the spec. That is, that metadata-complete has nothing\n        //to do with finding the ServletContainerInitializers, classes designated to be of interest to them,\n        //or even calling them on startup. \n        \n        //Get all ServletContainerInitializers, and check them for HandlesTypes annotations.\n        //For each class in the HandlesTypes value, if it IS an annotation, register a handler\n        //that will record the classes that have that annotation.\n        //If it is NOT an annotation, then we will interrogate the type hierarchy discovered during\n        //parsing later on to find the applicable classes.\n        ArrayList<ContainerInitializer> initializers = new ArrayList<ContainerInitializer>();\n        context.setAttribute(ContainerInitializerConfiguration.CONTAINER_INITIALIZERS, initializers);\n        \n        //We use the ServiceLoader mechanism to find the ServletContainerInitializer classes to inspect\n        ServiceLoader<ServletContainerInitializer> loadedInitializers = ServiceLoader.load(ServletContainerInitializer.class, context.getClassLoader());\n       \n        if (loadedInitializers != null)\n        {\n            for (ServletContainerInitializer service : loadedInitializers)\n            {\n                if (!isFromExcludedJar(context, service))\n                { \n                    HandlesTypes annotation = service.getClass().getAnnotation(HandlesTypes.class);\n                    ContainerInitializer initializer = new ContainerInitializer();\n                    initializer.setTarget(service);\n                    initializers.add(initializer);\n                    if (annotation != null)\n                    {\n                        Class[] classes = annotation.value();\n                        if (classes != null)\n                        {\n                            initializer.setInterestedTypes(classes);\n                            for (Class c: classes)\n                            {\n                                if (c.isAnnotation())\n                                {\n                                    if (LOG.isDebugEnabled()) LOG.debug(\"Registering annotation handler for \"+c.getName());\n                                    parser.registerAnnotationHandler(c.getName(), new ContainerInitializerAnnotationHandler(initializer, c));\n                                }\n                            }\n                        }\n                        else\n                            if (LOG.isDebugEnabled()) LOG.debug(\"No classes in HandlesTypes on initializer \"+service.getClass());\n                    }\n                    else\n                        if (LOG.isDebugEnabled()) LOG.debug(\"No annotation on initializer \"+service.getClass());\n                }\n            }\n        }\n    }","id":3083,"modified_method":"public AnnotationParser registerServletContainerInitializerAnnotationHandlers (WebAppContext context, AnnotationParser parser, List<ServletContainerInitializer> scis)\n    throws Exception\n    {     \n        \n        //TODO verify my interpretation of the spec. That is, that metadata-complete has nothing\n        //to do with finding the ServletContainerInitializers, classes designated to be of interest to them,\n        //or even calling them on startup. \n        \n        //Get all ServletContainerInitializers, and check them for HandlesTypes annotations.\n        //For each class in the HandlesTypes value, if it IS an annotation, register a handler\n        //that will record the classes that have that annotation.\n        //If it is NOT an annotation, then we will interrogate the type hierarchy discovered during\n        //parsing later on to find the applicable classes.\n        \n        if (scis == null || scis.isEmpty())\n            return parser; // nothing to do\n\n        ServletContainerInitializerListener listener = new ServletContainerInitializerListener();\n        listener.setWebAppContext(context);\n        context.addEventListener(listener);\n  \n        //may need to add a listener\n        \n        ArrayList<ContainerInitializer> initializers = new ArrayList<ContainerInitializer>();\n        context.setAttribute(CONTAINER_INITIALIZERS, initializers);\n\n        for (ServletContainerInitializer service : scis)\n        {\n            HandlesTypes annotation = service.getClass().getAnnotation(HandlesTypes.class);\n            ContainerInitializer initializer = new ContainerInitializer();\n            initializer.setTarget(service);\n            initializers.add(initializer);\n            if (annotation != null)\n            {\n                //There is a HandlesTypes annotation on the on the ServletContainerInitializer\n                Class[] classes = annotation.value();\n                if (classes != null)\n                {\n                    initializer.setInterestedTypes(classes);\n                    \n                    //We need to create a parser if we haven't already\n                    if (parser == null)\n                        parser = createAnnotationParser();\n                    \n                    //If we haven't already done so, we need to register a handler that will\n                    //process the whole class hierarchy\n                    if (context.getAttribute(CLASS_INHERITANCE_MAP) == null)\n                    {\n                        ClassInheritanceHandler classHandler = new ClassInheritanceHandler();\n                        context.setAttribute(CLASS_INHERITANCE_MAP, classHandler.getMap());\n                        parser.registerClassHandler(classHandler);\n                    }\n                                     \n                    for (Class c: classes)\n                    {\n                        //The value of one of the HandlesTypes classes is actually an Annotation itself so\n                        //register a handler for it\n                        if (c.isAnnotation())\n                        {\n                            if (LOG.isDebugEnabled()) LOG.debug(\"Registering annotation handler for \"+c.getName());\n                           \n                            parser.registerAnnotationHandler(c.getName(), new ContainerInitializerAnnotationHandler(initializer, c));\n                        }\n                    }\n                }\n                else\n                    if (LOG.isDebugEnabled()) LOG.debug(\"No classes in HandlesTypes on initializer \"+service.getClass());\n            }\n            else\n                if (LOG.isDebugEnabled()) LOG.debug(\"No annotation on initializer \"+service.getClass());\n        }\n        \n        //return the parser in case we lazily created it\n        return parser;\n    }","commit_id":"73a8065132b9d896c3fc567544828b5c956f6a23","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void configure(WebAppContext context) throws Exception\n    {\n       boolean metadataComplete = context.getMetaData().isMetaDataComplete();\n       context.addDecorator(new AnnotationDecorator(context));   \n      \n        if (metadataComplete)\n        {\n            //Never scan any jars or classes for annotations if metadata is complete\n            if (LOG.isDebugEnabled()) LOG.debug(\"Metadata-complete==true,  not processing annotations for context \"+context);\n            return;\n        }\n        else \n        {\n            //Only scan jars and classes if metadata is not complete and the web app is version 3.0, or\n            //a 2.5 version webapp that has specifically asked to discover annotations\n            if (LOG.isDebugEnabled()) LOG.debug(\"parsing annotations\");\n            \n            AnnotationParser parser = createAnnotationParser();\n            //Discoverable annotations - those that you have to look for without loading a class\n            parser.registerAnnotationHandler(\"javax.servlet.annotation.WebServlet\", new WebServletAnnotationHandler(context));\n            parser.registerAnnotationHandler(\"javax.servlet.annotation.WebFilter\", new WebFilterAnnotationHandler(context));\n            parser.registerAnnotationHandler(\"javax.servlet.annotation.WebListener\", new WebListenerAnnotationHandler(context));\n            ClassInheritanceHandler classHandler = new ClassInheritanceHandler();\n            parser.registerClassHandler(classHandler);\n            registerServletContainerInitializerAnnotationHandlers(context, parser);\n            \n            if (context.getServletContext().getEffectiveMajorVersion() >= 3 || context.isConfigurationDiscovered())\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(\"Scanning all classses for annotations: webxmlVersion=\"+context.getServletContext().getEffectiveMajorVersion()+\" configurationDiscovered=\"+context.isConfigurationDiscovered());\n                parseContainerPath(context, parser);\n                //email from Rajiv Mordani jsrs 315 7 April 2010\n                //    If there is a <others/> then the ordering should be \n                //          WEB-INF/classes the order of the declared elements + others.\n                //    In case there is no others then it is \n                //          WEB-INF/classes + order of the elements.\n                parseWebInfClasses(context, parser);\n                parseWebInfLib (context, parser);\n            } \n            \n            //save the type inheritance map created by the parser for later reference\n            context.setAttribute(CLASS_INHERITANCE_MAP, classHandler.getMap());\n        }    \n    }","id":3084,"modified_method":"@Override\n    public void configure(WebAppContext context) throws Exception\n    {\n       boolean metadataComplete = context.getMetaData().isMetaDataComplete();\n       context.addDecorator(new AnnotationDecorator(context));   \n      \n       \n       //Even if metadata is complete, we still need to scan for ServletContainerInitializers - if there are any\n       AnnotationParser parser = null;\n       if (!metadataComplete)\n       {\n           //If metadata isn't complete, if this is a servlet 3 webapp or isConfigDiscovered is true, we need to search for annotations\n           if (context.getServletContext().getEffectiveMajorVersion() >= 3 || context.isConfigurationDiscovered())\n           {\n               parser = createAnnotationParser();\n               parser.registerAnnotationHandler(\"javax.servlet.annotation.WebServlet\", new WebServletAnnotationHandler(context));\n               parser.registerAnnotationHandler(\"javax.servlet.annotation.WebFilter\", new WebFilterAnnotationHandler(context));\n               parser.registerAnnotationHandler(\"javax.servlet.annotation.WebListener\", new WebListenerAnnotationHandler(context));\n           }\n       }\n       else\n           if (LOG.isDebugEnabled()) LOG.debug(\"Metadata-complete==true,  not processing discoverable servlet annotations for context \"+context);\n       \n       \n       \n       //Regardless of metadata, if there are any ServletContainerInitializers with @HandlesTypes, then we need to scan all the\n       //classes so we can call their onStartup() methods correctly\n       List<ServletContainerInitializer> nonExcludedInitializers = getNonExcludedInitializers(context);\n       parser = registerServletContainerInitializerAnnotationHandlers(context, parser, nonExcludedInitializers);\n       \n       if (parser != null)\n       {           \n           if (LOG.isDebugEnabled()) LOG.debug(\"Scanning all classses for annotations: webxmlVersion=\"+context.getServletContext().getEffectiveMajorVersion()+\" configurationDiscovered=\"+context.isConfigurationDiscovered());\n           parseContainerPath(context, parser);\n           //email from Rajiv Mordani jsrs 315 7 April 2010\n           //    If there is a <others/> then the ordering should be \n           //          WEB-INF/classes the order of the declared elements + others.\n           //    In case there is no others then it is \n           //          WEB-INF/classes + order of the elements.\n           parseWebInfClasses(context, parser);\n           parseWebInfLib (context, parser);\n       }\n    }","commit_id":"73a8065132b9d896c3fc567544828b5c956f6a23","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * \n     */\n    @Override\n    public void preConfigure (WebAppContext context) throws Exception\n    {\n        //parse webdefault.xml\n        String defaultsDescriptor = context.getDefaultsDescriptor();\n        if (defaultsDescriptor != null && defaultsDescriptor.length() > 0)\n        {\n            Resource dftResource = Resource.newSystemResource(defaultsDescriptor);\n            if (dftResource == null) \n                dftResource = context.newResource(defaultsDescriptor);\n            context.getMetaData().setDefaults (dftResource);\n        }\n        \n        //parse, but don't process web.xml\n        Resource webxml = findWebXml(context);\n        if (webxml != null) \n        {      \n            context.getMetaData().setWebXml(webxml);\n        }\n        \n        //parse but don't process override-web.xml\n        for (String overrideDescriptor : context.getOverrideDescriptors())\n        {\n            if (overrideDescriptor != null && overrideDescriptor.length() > 0)\n            {\n                Resource orideResource = Resource.newSystemResource(overrideDescriptor);\n                if (orideResource == null) \n                    orideResource = context.newResource(overrideDescriptor);\n                context.getMetaData().addOverride(orideResource);\n            }\n        }\n    }","id":3085,"modified_method":"/**\n     * \n     */\n    @Override\n    public void preConfigure (WebAppContext context) throws Exception\n    {\n        //parse webdefault.xml\n        String defaultsDescriptor = context.getDefaultsDescriptor();\n        if (defaultsDescriptor != null && defaultsDescriptor.length() > 0)\n        {\n            Resource dftResource = Resource.newSystemResource(defaultsDescriptor);\n            if (dftResource == null) \n                dftResource = context.newResource(defaultsDescriptor);\n            context.getMetaData().setDefaults (dftResource);\n        }\n        \n        //parse, but don't process web.xml\n        Resource webxml = findWebXml(context);\n        if (webxml != null) \n        {      \n            context.getMetaData().setWebXml(webxml);\n            context.getServletContext().setEffectiveMajorVersion(context.getMetaData().getWebXml().getMajorVersion());\n            context.getServletContext().setEffectiveMinorVersion(context.getMetaData().getWebXml().getMinorVersion());\n        }\n        \n        //parse but don't process override-web.xml\n        for (String overrideDescriptor : context.getOverrideDescriptors())\n        {\n            if (overrideDescriptor != null && overrideDescriptor.length() > 0)\n            {\n                Resource orideResource = Resource.newSystemResource(overrideDescriptor);\n                if (orideResource == null) \n                    orideResource = context.newResource(overrideDescriptor);\n                context.getMetaData().addOverride(orideResource);\n            }\n        }\n    }","commit_id":"73a8065132b9d896c3fc567544828b5c956f6a23","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void insertHelperUtilities(\n\t\tVelocityContext vc, String[] restrictedVariables) {\n\n\t\t// Array util\n\n\t\tvc.put(\"arrayUtil\", ArrayUtil_IW.getInstance());\n\n\t\t// Browser sniffer\n\n\t\tvc.put(\"browserSniffer\", BrowserSniffer_IW.getInstance());\n\n\t\t// Date formats\n\n\t\tvc.put(\"dateFormats\", DateFormats_IW.getInstance());\n\n\t\t// Date tool\n\n\t\tvc.put(\"dateTool\", new DateTool());\n\n\t\t// Date util\n\n\t\tvc.put(\"dateUtil\", DateUtil_IW.getInstance());\n\n\t\t// Escape tool\n\n\t\tvc.put(\"escapeTool\", new EscapeTool());\n\n\t\t// Expando column service\n\n\t\tServiceLocator serviceLocator = ServiceLocator.getInstance();\n\n\t\tvc.put(\n\t\t\t\"expandoColumnService\",\n\t\t\tserviceLocator.findService(\n\t\t\t\tExpandoColumnService.class.getName()));\n\n\t\t// Expando row service\n\n\t\tvc.put(\"expandoRowService\",\n\t\t\tserviceLocator.findService(ExpandoRowService.class.getName()));\n\n\t\t// Expando table service\n\n\t\tvc.put(\"expandoTableService\",\n\t\t\tserviceLocator.findService(ExpandoTableService.class.getName()));\n\n\t\t// Expando value service\n\n\t\tvc.put(\"expandoValueService\",\n\t\t\tserviceLocator.findService(ExpandoValueService.class.getName()));\n\n\t\t// Getter util\n\n\t\tvc.put(\"getterUtil\", GetterUtil_IW.getInstance());\n\n\t\t// Html util\n\n\t\tvc.put(\"htmlUtil\", HtmlUtil.getHtml());\n\n\t\t// Http util\n\n\t\tvc.put(\"httpUtil\", HttpUtil.getHttp());\n\n\t\t// ImageServletToken\n\n\t\tvc.put(\"imageToken\", ImageServletTokenUtil.getImageServletToken());\n\n\t\t// Iterator tool\n\n\t\tvc.put(\"iteratorTool\", new IteratorTool());\n\n\t\t// Language util\n\n\t\tvc.put(\"languageUtil\", LanguageUtil.getLanguage());\n\t\tvc.put(\"unicodeLanguageUtil\", UnicodeLanguageUtil.getUnicodeLanguage());\n\n\t\t// List tool\n\n\t\tvc.put(\"listTool\", new ListTool());\n\n\t\t// Locale util\n\n\t\tvc.put(\"localeUtil\", LocaleUtil.getInstance());\n\n\t\t// Math tool\n\n\t\tvc.put(\"mathTool\", new MathTool());\n\n\t\t// Number tool\n\n\t\tvc.put(\"numberTool\", new NumberTool());\n\n\t\t// Param util\n\n\t\tvc.put(\"paramUtil\", ParamUtil_IW.getInstance());\n\n\t\t// Portal util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portalUtil\", PortalUtil.getPortal());\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portal\", PortalUtil.getPortal());\n\n\t\t// Prefs props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"prefsPropsUtil\",\n\t\t\tPrefsPropsUtil_IW.getInstance());\n\n\t\t// Props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"propsUtil\", PropsUtil_IW.getInstance());\n\n\t\t// Portlet URL factory\n\n\t\tvc.put(\"portletURLFactory\", PortletURLFactory.getInstance());\n\n\t\t// Portlet preferences\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"velocityPortletPreferences\",\n\t\t\tnew VelocityPortletPreferences());\n\n\t\t// Randomizer\n\n\t\tvc.put(\"randomizer\", Randomizer_IW.getInstance().getWrappedInstance());\n\n\t\t// Service locator\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"serviceLocator\", serviceLocator);\n\n\t\t// Session clicks\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"sessionClicks\",\n\t\t\tSessionClicks_IW.getInstance());\n\n\t\t// Sort tool\n\n\t\tvc.put(\"sortTool\", new SortTool());\n\n\t\t// Static field getter\n\n\t\tvc.put(\"staticFieldGetter\", StaticFieldGetter.getInstance());\n\n\t\t// String util\n\n\t\tvc.put(\"stringUtil\", StringUtil_IW.getInstance());\n\n\t\t// Unicode formatter\n\n\t\tvc.put(\"unicodeFormatter\", UnicodeFormatter_IW.getInstance());\n\n\t\t// Validator\n\n\t\tvc.put(\"validator\", Validator_IW.getInstance());\n\n\t\t// Permissions\n\n\t\tvc.put(\n\t\t\t\"accountPermission\", AccountPermissionUtil.getAccountPermission());\n\t\tvc.put(\"commonPermission\", CommonPermissionUtil.getCommonPermission());\n\t\tvc.put(\"groupPermission\", GroupPermissionUtil.getGroupPermission());\n\t\tvc.put(\"layoutPermission\", LayoutPermissionUtil.getLayoutPermission());\n\t\tvc.put(\n\t\t\t\"organizationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t\tvc.put(\n\t\t\t\"passwordPolicyPermission\",\n\t\t\tPasswordPolicyPermissionUtil.getPasswordPolicyPermission());\n\t\tvc.put(\"portalPermission\", PortalPermissionUtil.getPortalPermission());\n\t\tvc.put(\n\t\t\t\"portletPermission\", PortletPermissionUtil.getPortletPermission());\n\t\tvc.put(\"rolePermission\", RolePermissionUtil.getRolePermission());\n\t\tvc.put(\n\t\t\t\"userGroupPermission\",\n\t\t\tUserGroupPermissionUtil.getUserGroupPermission());\n\t\tvc.put(\"userPermission\", UserPermissionUtil.getUserPermission());\n\n\t\t// Deprecated permissions\n\n\t\tvc.put(\n\t\t\t\"locationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t}","id":3086,"modified_method":"public static void insertHelperUtilities(\n\t\tVelocityContext vc, String[] restrictedVariables) {\n\n\t\t// Array util\n\n\t\tvc.put(\"arrayUtil\", ArrayUtil_IW.getInstance());\n\n\t\t// Browser sniffer\n\n\t\tvc.put(\"browserSniffer\", BrowserSniffer_IW.getInstance());\n\n\t\t// Date formats\n\n\t\tvc.put(\"dateFormats\", DateFormats_IW.getInstance());\n\n\t\t// Date tool\n\n\t\tvc.put(\"dateTool\", new DateTool());\n\n\t\t// Date util\n\n\t\tvc.put(\"dateUtil\", DateUtil_IW.getInstance());\n\n\t\t// Escape tool\n\n\t\tvc.put(\"escapeTool\", new EscapeTool());\n\n\t\t// Expando column service\n\n\t\tServiceLocator serviceLocator = ServiceLocator.getInstance();\n\n\t\tvc.put(\"expandoColumnService\",\n\t\t\t(ExpandoColumnService)Proxy.newProxyInstance(\n\t\t\t\tExpandoColumnService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoColumnService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoColumnService.class.getName()))));\n\n\t\t// Expando row service\n\n\t\tvc.put(\"expandoRowService\",\n\t\t\t(ExpandoRowService)Proxy.newProxyInstance(\n\t\t\t\tExpandoRowService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoRowService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoRowService.class.getName()))));\n\n\t\t// Expando table service\n\n\t\tvc.put(\"expandoTableService\",\n\t\t\t(ExpandoTableService)Proxy.newProxyInstance(\n\t\t\t\tExpandoTableService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoTableService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoTableService.class.getName()))));\n\n\t\t// Expando value service\n\n\t\tvc.put(\"expandoValueService\",\n\t\t\t(ExpandoValueService)Proxy.newProxyInstance(\n\t\t\t\tExpandoValueService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoValueService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoValueService.class.getName()))));\n\n\t\t// Getter util\n\n\t\tvc.put(\"getterUtil\", GetterUtil_IW.getInstance());\n\n\t\t// Html util\n\n\t\tvc.put(\"htmlUtil\", HtmlUtil.getHtml());\n\n\t\t// Http util\n\n\t\tvc.put(\"httpUtil\", HttpUtil.getHttp());\n\n\t\t// ImageServletToken\n\n\t\tvc.put(\"imageToken\", ImageServletTokenUtil.getImageServletToken());\n\n\t\t// Iterator tool\n\n\t\tvc.put(\"iteratorTool\", new IteratorTool());\n\n\t\t// Language util\n\n\t\tvc.put(\"languageUtil\", LanguageUtil.getLanguage());\n\t\tvc.put(\"unicodeLanguageUtil\", UnicodeLanguageUtil.getUnicodeLanguage());\n\n\t\t// List tool\n\n\t\tvc.put(\"listTool\", new ListTool());\n\n\t\t// Locale util\n\n\t\tvc.put(\"localeUtil\", LocaleUtil.getInstance());\n\n\t\t// Math tool\n\n\t\tvc.put(\"mathTool\", new MathTool());\n\n\t\t// Number tool\n\n\t\tvc.put(\"numberTool\", new NumberTool());\n\n\t\t// Param util\n\n\t\tvc.put(\"paramUtil\", ParamUtil_IW.getInstance());\n\n\t\t// Portal util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portalUtil\", PortalUtil.getPortal());\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portal\", PortalUtil.getPortal());\n\n\t\t// Prefs props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"prefsPropsUtil\",\n\t\t\tPrefsPropsUtil_IW.getInstance());\n\n\t\t// Props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"propsUtil\", PropsUtil_IW.getInstance());\n\n\t\t// Portlet URL factory\n\n\t\tvc.put(\"portletURLFactory\", PortletURLFactory.getInstance());\n\n\t\t// Portlet preferences\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"velocityPortletPreferences\",\n\t\t\tnew VelocityPortletPreferences());\n\n\t\t// Randomizer\n\n\t\tvc.put(\"randomizer\", Randomizer_IW.getInstance().getWrappedInstance());\n\n\t\t// Service locator\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"serviceLocator\", serviceLocator);\n\n\t\t// Session clicks\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"sessionClicks\",\n\t\t\tSessionClicks_IW.getInstance());\n\n\t\t// Sort tool\n\n\t\tvc.put(\"sortTool\", new SortTool());\n\n\t\t// Static field getter\n\n\t\tvc.put(\"staticFieldGetter\", StaticFieldGetter.getInstance());\n\n\t\t// String util\n\n\t\tvc.put(\"stringUtil\", StringUtil_IW.getInstance());\n\n\t\t// Unicode formatter\n\n\t\tvc.put(\"unicodeFormatter\", UnicodeFormatter_IW.getInstance());\n\n\t\t// Validator\n\n\t\tvc.put(\"validator\", Validator_IW.getInstance());\n\n\t\t// Permissions\n\n\t\tvc.put(\n\t\t\t\"accountPermission\", AccountPermissionUtil.getAccountPermission());\n\t\tvc.put(\"commonPermission\", CommonPermissionUtil.getCommonPermission());\n\t\tvc.put(\"groupPermission\", GroupPermissionUtil.getGroupPermission());\n\t\tvc.put(\"layoutPermission\", LayoutPermissionUtil.getLayoutPermission());\n\t\tvc.put(\n\t\t\t\"organizationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t\tvc.put(\n\t\t\t\"passwordPolicyPermission\",\n\t\t\tPasswordPolicyPermissionUtil.getPasswordPolicyPermission());\n\t\tvc.put(\"portalPermission\", PortalPermissionUtil.getPortalPermission());\n\t\tvc.put(\n\t\t\t\"portletPermission\", PortletPermissionUtil.getPortletPermission());\n\t\tvc.put(\"rolePermission\", RolePermissionUtil.getRolePermission());\n\t\tvc.put(\n\t\t\t\"userGroupPermission\",\n\t\t\tUserGroupPermissionUtil.getUserGroupPermission());\n\t\tvc.put(\"userPermission\", UserPermissionUtil.getUserPermission());\n\n\t\t// Deprecated permissions\n\n\t\tvc.put(\n\t\t\t\"locationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t}","commit_id":"33ece30736ca92a48d09f87309d306624b99a34f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            cvs.add(factory.createValue(\n                    mapper.getOakName(value), PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","id":3087,"modified_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            String oakName = mapper.getOakName(value);\n            if (oakName == null) {\n                throw new IllegalArgumentException(\"Invalid name:\" + name);\n            }\n\n            cvs.add(factory.createValue(\n                    oakName, PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","commit_id":"1e7050dcb4423fb9c7876342939f3458c3dda439","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setName(String name, String value) {\n        tree.setProperty(name, factory.createValue(\n                mapper.getOakName(value), PropertyType.NAME));\n    }","id":3088,"modified_method":"public void setName(String name, String value) {\n        String oakName = mapper.getOakName(value);\n        if (oakName == null) {\n            throw new IllegalArgumentException(\"Invalid name:\" + name);\n        }\n\n        tree.setProperty(name, factory.createValue(\n                oakName, PropertyType.NAME));\n    }","commit_id":"1e7050dcb4423fb9c7876342939f3458c3dda439","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            String oakName = mapper.getOakName(value);\n            if (oakName == null) {\n                throw new IllegalArgumentException(\"Invalid name:\" + name);\n            }\n\n            cvs.add(factory.createValue(oakName, PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","id":3089,"modified_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            String oakName = mapper.getOakName(value);\n            if (oakName == null) {\n                throw new IllegalArgumentException(new RepositoryException(\"Invalid name:\" + name));\n            }\n\n            cvs.add(factory.createValue(oakName, PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"PrivilegeDefinitionImpl(String name, boolean isAbstract,\n                            String... declaredAggregateNames) {\n        this(name, isAbstract, ImmutableSet.copyOf(declaredAggregateNames  == null ? new String[0] : declaredAggregateNames));\n    }","id":3090,"modified_method":"PrivilegeDefinitionImpl(String name, boolean isAbstract,\n                            String... declaredAggregateNames) {\n        this(name, isAbstract, (declaredAggregateNames == null) ?\n                Collections.<String>emptySet() :\n                ImmutableSet.copyOf(declaredAggregateNames));\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Privilege registerPrivilege(String privilegeName, boolean isAbstract,\n                                       String[] declaredAggregateNames) throws RepositoryException {\n        PrivilegeDefinition def = provider.registerDefinition(getOakName(privilegeName), isAbstract, getOakNames(declaredAggregateNames));\n        return new PrivilegeImpl(def);\n    }","id":3091,"modified_method":"@Override\n    public Privilege registerPrivilege(String privilegeName, boolean isAbstract,\n                                       String[] declaredAggregateNames) throws RepositoryException {\n        if (privilegeName == null || privilegeName.isEmpty()) {\n            throw new RepositoryException(\"Invalid privilege name \" + privilegeName);\n        }\n        String oakName = getOakName(privilegeName);\n        if (oakName == null) {\n            throw new NamespaceException(\"Invalid privilege name \" + privilegeName);\n        }\n\n        PrivilegeDefinition def = provider.registerDefinition(oakName, isAbstract, getOakNames(declaredAggregateNames));\n        return new PrivilegeImpl(def);\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Set<String> getOakNames(String[] jcrNames) {\n        Set<String> oakNames;\n        if (jcrNames == null || jcrNames.length == 0) {\n            oakNames = Collections.emptySet();\n        } else {\n            oakNames = new HashSet<String>(jcrNames.length);\n            for (String jcrName : jcrNames) {\n                oakNames.add(getOakName(jcrName));\n            }\n        }\n        return oakNames;\n    }","id":3092,"modified_method":"private Set<String> getOakNames(String[] jcrNames) throws RepositoryException {\n        Set<String> oakNames;\n        if (jcrNames == null || jcrNames.length == 0) {\n            oakNames = Collections.emptySet();\n        } else {\n            oakNames = new HashSet<String>(jcrNames.length);\n            for (String jcrName : jcrNames) {\n                String oakName = getOakName(jcrName);\n                if (oakName == null) {\n                    throw new RepositoryException(\"Invalid name \" + jcrName);\n                }\n                oakNames.add(oakName);\n            }\n        }\n        return oakNames;\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testGetPrivilegesFromEmptyNames() {\n        try {\n            privilegeMgr.getPrivilege(\"\");\n            fail(\"invalid privilege name array\");\n        } catch (AccessControlException e) {\n            // OK\n        } catch (RepositoryException e) {\n            // OK\n        }\n    }","id":3093,"modified_method":"@Test\n    public void testGetPrivilegesFromEmptyNames() {\n        try {\n            privilegeManager.getPrivilege(\"\");\n            fail(\"invalid privilege name array\");\n        } catch (AccessControlException e) {\n            // OK\n        } catch (RepositoryException e) {\n            // OK\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        privilegeMgr = ((JackrabbitWorkspace) superuser.getWorkspace()).getPrivilegeManager();\n    }","id":3094,"modified_method":"@Before\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        privilegeManager = getPrivilegeManager(superuser);\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testRegisteredPrivileges() throws RepositoryException {\n        Privilege[] ps = privilegeMgr.getRegisteredPrivileges();\n\n        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(ps));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_NODE)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_WRITE)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ALL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:write\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:addProperties\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:alterProperties\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:removeProperties\")));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:namespaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:nodeTypeDefinitionManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:workspaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:privilegeManagement\")));\n\n        assertTrue(l.isEmpty());\n    }","id":3095,"modified_method":"@Test\n    public void testRegisteredPrivileges() throws RepositoryException {\n        Privilege[] ps = privilegeManager.getRegisteredPrivileges();\n\n        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(ps));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_REMOVE_NODE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_WRITE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_ALL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_WRITE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_ADD_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_ALTER_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_REMOVE_PROPERTIES)));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NAMESPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_WORKSPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_PRIVILEGE_MANAGEMENT)));\n\n        assertTrue(l.isEmpty());\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testGetPrivilegeFromName() throws AccessControlException, RepositoryException {\n        Privilege p = privilegeMgr.getPrivilege(Privilege.JCR_READ);\n\n        assertTrue(p != null);\n        assertEquals(\"jcr:read\", p.getName());\n        assertFalse(p.isAggregate());\n\n        p = privilegeMgr.getPrivilege(Privilege.JCR_WRITE);\n\n        assertTrue(p != null);\n        assertEquals(\"jcr:write\", p.getName());\n        assertTrue(p.isAggregate());\n    }","id":3096,"modified_method":"@Test\n    public void testGetPrivilegeFromName() throws AccessControlException, RepositoryException {\n        Privilege p = privilegeManager.getPrivilege(Privilege.JCR_READ);\n\n        assertTrue(p != null);\n        assertEquals(\"jcr:read\", p.getName());\n        assertFalse(p.isAggregate());\n\n        p = privilegeManager.getPrivilege(Privilege.JCR_WRITE);\n\n        assertTrue(p != null);\n        assertEquals(\"jcr:write\", p.getName());\n        assertTrue(p.isAggregate());\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testGetPrivilegesFromNullNames() {\n        try {\n            privilegeMgr.getPrivilege(null);\n            fail(\"invalid privilege name (null)\");\n        } catch (Exception e) {\n            // OK\n        }\n    }","id":3097,"modified_method":"@Test\n    public void testGetPrivilegesFromNullNames() {\n        try {\n            privilegeManager.getPrivilege(null);\n            fail(\"invalid privilege name (null)\");\n        } catch (Exception e) {\n            // OK\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testAllPrivilege() throws RepositoryException {\n        Privilege p = privilegeMgr.getPrivilege(Privilege.JCR_ALL);\n        assertEquals(\"jcr:all\",p.getName());\n        assertTrue(p.isAggregate());\n        assertFalse(p.isAbstract());\n\n        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(p.getAggregatePrivileges()));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_NODE)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_WRITE)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:write\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:addProperties\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:alterProperties\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:removeProperties\")));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:namespaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:nodeTypeDefinitionManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:workspaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:privilegeManagement\")));\n        assertTrue(l.isEmpty());\n\n        l = new ArrayList<Privilege>(Arrays.asList(p.getDeclaredAggregatePrivileges()));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:write\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:namespaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:nodeTypeDefinitionManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"jcr:workspaceManagement\")));\n        assertTrue(l.remove(privilegeMgr.getPrivilege(\"rep:privilegeManagement\")));\n\n        assertTrue(l.isEmpty());\n    }","id":3098,"modified_method":"@Test\n    public void testAllPrivilege() throws RepositoryException {\n        Privilege p = privilegeManager.getPrivilege(Privilege.JCR_ALL);\n        assertEquals(\"jcr:all\",p.getName());\n        assertTrue(p.isAggregate());\n        assertFalse(p.isAbstract());\n\n        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(p.getAggregatePrivileges()));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_REMOVE_NODE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_WRITE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_WRITE)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_ADD_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_ALTER_PROPERTIES)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_REMOVE_PROPERTIES)));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NAMESPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_WORKSPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_PRIVILEGE_MANAGEMENT)));\n        assertTrue(l.isEmpty());\n\n        l = new ArrayList<Privilege>(Arrays.asList(p.getDeclaredAggregatePrivileges()));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_WRITE)));\n        // including repo-level operation privileges\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NAMESPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.JCR_WORKSPACE_MANAGEMENT)));\n        assertTrue(l.remove(privilegeManager.getPrivilege(PrivilegeConstants.REP_PRIVILEGE_MANAGEMENT)));\n\n        assertTrue(l.isEmpty());\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testGetPrivilegesFromInvalidName() throws RepositoryException {\n        try {\n            privilegeMgr.getPrivilege(\"unknown\");\n            fail(\"invalid privilege name\");\n        } catch (AccessControlException e) {\n            // OK\n        }\n    }","id":3099,"modified_method":"@Test\n    public void testGetPrivilegesFromInvalidName() throws RepositoryException {\n        try {\n            privilegeManager.getPrivilege(\"unknown\");\n            fail(\"invalid privilege name\");\n        } catch (AccessControlException e) {\n            // OK\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     *\n     * @throws RepositoryException\n     */\n    public void migrateCustomPrivileges() throws RepositoryException {\n        PrivilegeRegistry pr = new PrivilegeRegistry(contentSession);\n        InputStream stream = null;\n        // TODO: order custom privileges such that validation succeeds.\n        // FIXME: user proper path to jr2 custom privileges stored in fs\n        // jr2 used to be:\n        // new FileSystemResource(fs, \"/privileges/custom_privileges.xml\").getInputStream()\n        if (stream != null) {\n            try {\n                NamespaceRegistry nsRegistry = new NamespaceRegistryImpl(contentSession);\n                PrivilegeDefinition[] custom = PrivilegeDefinitionReader.readCustomDefinitons(stream, nsRegistry);\n                for (PrivilegeDefinition def : custom) {\n                    pr.registerDefinition(def);\n                }\n            } catch (IOException e) {\n                throw new RepositoryException(e);\n            } finally {\n                try {\n                    stream.close();\n                } catch (IOException e) {\n                    // ignore.\n                }\n            }\n        }\n    }","id":3100,"modified_method":"/**\n     *\n     * @throws RepositoryException\n     */\n    public void migrateCustomPrivileges() throws RepositoryException {\n        PrivilegeRegistry pr = new PrivilegeRegistry(contentSession);\n        InputStream stream = null;\n        // TODO: order custom privileges such that validation succeeds.\n        // FIXME: user proper path to jr2 custom privileges stored in fs\n        // jr2 used to be:\n        // new FileSystemResource(fs, \"/privileges/custom_privileges.xml\").getInputStream()\n        if (stream != null) {\n            try {\n                NamespaceRegistry nsRegistry = new NamespaceRegistryImpl(contentSession);\n                PrivilegeDefinition[] custom = PrivilegeDefinitionReader.readCustomDefinitons(stream, nsRegistry);\n                pr.registerDefinitions(custom);\n            } catch (IOException e) {\n                throw new RepositoryException(e);\n            } finally {\n                try {\n                    stream.close();\n                } catch (IOException e) {\n                    // ignore.\n                }\n            }\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void internalRegisterDefinitions(PrivilegeDefinition toRegister) throws RepositoryException {\n        CoreValueFactory vf = contentSession.getCoreValueFactory();\n        Root root = contentSession.getCurrentRoot();\n\n        try {\n            // make sure the privileges path is defined\n            Tree privilegesTree = root.getTree(PRIVILEGES_PATH);\n            if (privilegesTree == null) {\n                throw new RepositoryException(\"Repository doesn't contain node \" + PRIVILEGES_PATH);\n            }\n\n            NodeUtil privilegesNode = new NodeUtil(privilegesTree, contentSession);\n            writeDefinition(privilegesNode, toRegister);\n\n            // delegate validation to the commit validation (see above)\n            root.commit(DefaultConflictHandler.OURS);\n\n        } catch (CommitFailedException e) {\n            throw new RepositoryException(e.getMessage());\n        }\n\n        definitions.put(toRegister.getName(), toRegister);\n        updateJcrAllPrivilege(definitions);\n    }","id":3101,"modified_method":"private void internalRegisterDefinitions(PrivilegeDefinition toRegister) throws RepositoryException {\n        CoreValueFactory vf = contentSession.getCoreValueFactory();\n        Root root = contentSession.getCurrentRoot();\n\n        try {\n            // make sure the privileges path is defined\n            Tree privilegesTree = root.getTree(PRIVILEGES_PATH);\n            if (privilegesTree == null) {\n                throw new RepositoryException(\"Repository doesn't contain node \" + PRIVILEGES_PATH);\n            }\n\n            NodeUtil privilegesNode = new NodeUtil(privilegesTree, contentSession);\n            writeDefinition(privilegesNode, toRegister);\n\n            // delegate validation to the commit validation (see above)\n            root.commit(DefaultConflictHandler.OURS);\n\n        } catch (CommitFailedException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RepositoryException) {\n                throw (RepositoryException) t;\n            } else {\n                throw new RepositoryException(e.getMessage());\n            }\n        }\n\n        definitions.put(toRegister.getName(), toRegister);\n        updateJcrAllPrivilege(definitions);\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void updateJcrAllPrivilege(Map<String, PrivilegeDefinition> definitions) {\n        // TODO: add proper implementation taking custom privileges into account.\n        definitions.put(JCR_ALL, new PrivilegeDefinitionImpl(JCR_ALL, false,\n                JCR_READ, JCR_READ_ACCESS_CONTROL, JCR_MODIFY_ACCESS_CONTROL,\n                JCR_VERSION_MANAGEMENT, JCR_LOCK_MANAGEMENT, JCR_LIFECYCLE_MANAGEMENT,\n                JCR_RETENTION_MANAGEMENT, JCR_WORKSPACE_MANAGEMENT, JCR_NODE_TYPE_DEFINITION_MANAGEMENT,\n                JCR_NAMESPACE_MANAGEMENT, REP_PRIVILEGE_MANAGEMENT, REP_WRITE));\n    }","id":3102,"modified_method":"private static void updateJcrAllPrivilege(Map<String, PrivilegeDefinition> definitions) {\n        // TODO: add proper implementation taking custom privileges into account.\n        Set<String> declaredAggregateNames = new HashSet<String>();\n        declaredAggregateNames.add(JCR_READ);\n        declaredAggregateNames.add(JCR_READ_ACCESS_CONTROL);\n        declaredAggregateNames.add(JCR_MODIFY_ACCESS_CONTROL);\n        declaredAggregateNames.add(JCR_VERSION_MANAGEMENT);\n        declaredAggregateNames.add(JCR_LOCK_MANAGEMENT);\n        declaredAggregateNames.add(JCR_LIFECYCLE_MANAGEMENT);\n        declaredAggregateNames.add(JCR_RETENTION_MANAGEMENT);\n        declaredAggregateNames.add(JCR_WORKSPACE_MANAGEMENT);\n        declaredAggregateNames.add(JCR_NODE_TYPE_DEFINITION_MANAGEMENT);\n        declaredAggregateNames.add(JCR_NAMESPACE_MANAGEMENT);\n        declaredAggregateNames.add(REP_PRIVILEGE_MANAGEMENT);\n        declaredAggregateNames.add(REP_WRITE);\n\n        definitions.put(JCR_ALL, new PrivilegeDefinitionImpl(JCR_ALL, false, declaredAggregateNames));\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void registerDefinition(PrivilegeDefinition definition) throws RepositoryException {\n        PrivilegeDefinition toRegister;\n        if (definition instanceof PrivilegeDefinitionImpl) {\n            toRegister = definition;\n        } else {\n            toRegister = new PrivilegeDefinitionImpl(definition.getName(), definition.isAbstract(), definition.getDeclaredAggregateNames());\n        }\n        internalRegisterDefinitions(toRegister);\n    }","id":3103,"modified_method":"void registerDefinitions(PrivilegeDefinition[] definitions) throws RepositoryException {\n        for (PrivilegeDefinition definition : definitions) {\n            PrivilegeDefinition toRegister;\n            if (definition instanceof PrivilegeDefinitionImpl) {\n                toRegister = definition;\n            } else {\n                toRegister = new PrivilegeDefinitionImpl(definition.getName(), definition.isAbstract(), definition.getDeclaredAggregateNames());\n            }\n            internalRegisterDefinitions(toRegister);\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Validation of the privilege definition including the following steps:\n     *\n     * - all aggregates must have been registered before\n     * - no existing privilege defines the same aggregation\n     * - no cyclic aggregation\n     *\n     * @param definition The new privilege definition to validate.\n     * @throws org.apache.jackrabbit.oak.api.CommitFailedException If any of\n     * the checks listed above fails.\n     */\n    private void validateDefinition(PrivilegeDefinition definition) throws CommitFailedException {\n        Set<String> aggrNames = definition.getDeclaredAggregateNames();\n        if (aggrNames.isEmpty()) {\n            return;\n        }\n\n        for (String aggrName : aggrNames) {\n            // aggregated privilege not registered\n            if (!definitions.containsKey(aggrName)) {\n                throw new CommitFailedException(\"Declared aggregate '\"+ aggrName +\"' is not a registered privilege.\");\n            }\n\n            // check for circular aggregation\n            if (isCircularAggregation(definition.getName(), aggrName)) {\n                String msg = \"Detected circular aggregation within custom privilege caused by \" + aggrName;\n                throw new CommitFailedException(msg);\n            }\n        }\n\n        for (PrivilegeDefinition existing : definitions.values()) {\n            if (aggrNames.equals(existing.getDeclaredAggregateNames())) {\n                String msg = \"Custom aggregate privilege '\" + definition.getName() + \"' is already covered by '\" + existing.getName() + '\\'';\n                throw new CommitFailedException(msg);\n            }\n        }\n    }","id":3104,"modified_method":"/**\n     * Validation of the privilege definition including the following steps:\n     *\n     * - all aggregates must have been registered before\n     * - no existing privilege defines the same aggregation\n     * - no cyclic aggregation\n     *\n     * @param definition The new privilege definition to validate.\n     * @throws org.apache.jackrabbit.oak.api.CommitFailedException If any of\n     * the checks listed above fails.\n     */\n    private void validateDefinition(PrivilegeDefinition definition) throws CommitFailedException {\n        Set<String> declaredNames = definition.getDeclaredAggregateNames();\n        if (declaredNames.isEmpty()) {\n            return;\n        }\n\n        if (declaredNames.size() == 1) {\n            throw new CommitFailedException(\"Singular aggregation is equivalent to existing privilege.\");\n        }\n\n        for (String aggrName : declaredNames) {\n            // aggregated privilege not registered\n            if (!definitions.containsKey(aggrName)) {\n                throw new CommitFailedException(\"Declared aggregate '\"+ aggrName +\"' is not a registered privilege.\");\n            }\n\n            // check for circular aggregation\n            if (isCircularAggregation(definition.getName(), aggrName)) {\n                String msg = \"Detected circular aggregation within custom privilege caused by \" + aggrName;\n                throw new CommitFailedException(msg);\n            }\n        }\n\n        Set<String> aggregateNames = resolveAggregates(declaredNames);\n        for (PrivilegeDefinition existing : definitions.values()) {\n            Set<String> existingDeclared = existing.getDeclaredAggregateNames();\n            if (existingDeclared.isEmpty()) {\n                continue;\n            }\n\n            // test for exact same aggregation or aggregation with the same net effect\n            if (declaredNames.equals(existingDeclared) || aggregateNames.equals(resolveAggregates(existingDeclared))) {\n                String msg = \"Custom aggregate privilege '\" + definition.getName() + \"' is already covered by '\" + existing.getName() + '\\'';\n                throw new CommitFailedException(msg);\n            }\n        }\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private AggregateStatus createAggregateStatus(Collection<OnmsCategory> rowCatNames, Collection<OnmsCategory> colCatNames) {\n        AggregateStatus status;\n        Collection<OnmsNode> nodes = m_nodeDao.findAllByCategoryLists(rowCatNames, colCatNames);\n        status = new AggregateStatus();\n        status.setDownEntityCount(computeDownCount(nodes));\n        status.setDownEntityCount(nodes.size());\n        status.setStatus(computeStatus(nodes, status));\n        return status;\n    }","id":3105,"modified_method":"private AggregateStatus createAggregateStatus(Collection<OnmsCategory> rowCatNames, Collection<OnmsCategory> colCatNames) {\n        AggregateStatus status;\n        Collection<OnmsNode> nodes = m_nodeDao.findAllByCategoryLists(rowCatNames, colCatNames);\n        status = new AggregateStatus();\n        if (nodes == null || nodes.isEmpty()) {\n            status.setDownEntityCount(0);\n            status.setTotalEntityCount(0);\n            status.setStatus(AggregateStatus.ALL_NODES_UP);\n        } else {\n            status.setDownEntityCount(computeDownCount(nodes));\n            status.setTotalEntityCount(nodes.size());\n            status.setStatus(computeStatus(nodes, status));\n        }\n        return status;\n    }","commit_id":"827689d6e2da056cf58f5098d0914ce81b14d50d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private TransUnit initTransUnit(HTextFlow textFlow, HLocale hLocale, int nPlurals)\n   {\n      String msgContext = null;\n      if (textFlow.getPotEntryData() != null)\n      {\n         msgContext = textFlow.getPotEntryData().getContext();\n      }\n      HTextFlowTarget target = textFlow.getTargets().get(hLocale);\n\n      List<String> targetContents = new ArrayList<String>(nPlurals - 1);\n      if (target != null && target.getContents() != null)\n      {\n         targetContents.addAll(target.getContents());\n      }\n\n      if (targetContents.size() > nPlurals)\n      {\n         targetContents = targetContents.subList(0, nPlurals);\n      }\n      else if (targetContents.size() < nPlurals)\n      {\n         while (targetContents.size() < nPlurals)\n         {\n            targetContents.add(\"\");\n         }\n      }\n\n      TransUnit tu = new TransUnit(new TransUnitId(textFlow.getId()), textFlow.getResId(), hLocale.getLocaleId(), textFlow.getContents(), CommentsUtil.toString(textFlow.getComment()), targetContents, ContentState.New, \"\", \"\", msgContext, textFlow.getPos());\n\n      tu.setStatus(target.getState());\n      if (target.getLastModifiedBy() != null)\n      {\n         tu.setLastModifiedBy(target.getLastModifiedBy().getName());\n      }\n      tu.setLastModifiedTime(SIMPLE_FORMAT.format(target.getLastChanged()));\n      return tu;\n   }","id":3106,"modified_method":"private TransUnit initTransUnit(HTextFlow textFlow, HLocale hLocale, int nPlurals)\n   {\n      String msgContext = null;\n      if (textFlow.getPotEntryData() != null)\n      {\n         msgContext = textFlow.getPotEntryData().getContext();\n      }\n      HTextFlowTarget target = textFlow.getTargets().get(hLocale);\n\n      List<String> targetContents = new ArrayList<String>(nPlurals - 1);\n      if (target != null && target.getContents() != null)\n      {\n         targetContents.addAll(target.getContents());\n      }\n\n      if (targetContents.size() > nPlurals)\n      {\n         targetContents = targetContents.subList(0, nPlurals);\n      }\n      else if (targetContents.size() < nPlurals)\n      {\n         while (targetContents.size() < nPlurals)\n         {\n            targetContents.add(\"\");\n         }\n      }\n\n      TransUnit tu = new TransUnit(new TransUnitId(textFlow.getId()), textFlow.getResId(), hLocale.getLocaleId(), textFlow.getContents(), CommentsUtil.toString(textFlow.getComment()), targetContents, ContentState.New, \"\", \"\", msgContext, textFlow.getPos());\n\n      if (target == null)\n      {\n         tu.setStatus(ContentState.New);\n      }\n      else\n      {\n         tu.setStatus(target.getState());\n         if (target.getLastModifiedBy() != null)\n         {\n            tu.setLastModifiedBy(target.getLastModifiedBy().getName());\n         }\n         tu.setLastModifiedTime(SIMPLE_FORMAT.format(target.getLastChanged()));\n      }\n      return tu;\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public TargetContentsPresenter(Provider<TargetContentsDisplay> displayProvider, final EventBus eventBus, final TableEditorMessages messages, final SourceContentsPresenter sourceContentsPresenter)\n   {\n      this.displayProvider = displayProvider;\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n\n      validationMessagePanel = new ValidationMessagePanel(true, messages);\n\n      eventBus.addHandler(UpdateValidationWarningsEvent.getType(), new UpdateValidationWarningsEventHandler()\n      {\n         @Override\n         public void onUpdate(UpdateValidationWarningsEvent event)\n         {\n            validationMessagePanel.setContent(event.getErrors());\n         }\n      });\n\n      eventBus.addHandler(RequestValidationEvent.getType(), new RequestValidationEventHandler()\n      {\n         @Override\n         public void onRequestValidation(RequestValidationEvent event)\n         {\n            if (isEditing())\n            {\n               eventBus.fireEvent(new RunValidationEvent(sourceContentsPresenter.getSelectedSource(), currentEditor.getText(), false));\n            }\n         }\n      });\n\n      eventBus.addHandler(InsertStringInEditorEvent.getType(), new InsertStringInEditorHandler()\n      {\n         @Override\n         public void onInsertString(InsertStringInEditorEvent event)\n         {\n            if (isEditing())\n            {\n               currentEditor.insertTextInCursorPosition(event.getSuggestion());\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyCopied()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Error, messages.notifyUnopened()));\n            }\n         }\n      });\n\n      eventBus.addHandler(CopyDataToEditorEvent.getType(), new CopyDataToEditorHandler()\n      {\n         @Override\n         public void onTransMemoryCopy(CopyDataToEditorEvent event)\n         {\n            if (isEditing())\n            {\n               currentEditor.setText(event.getTargetResult());\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyCopied()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Error, messages.notifyUnopened()));\n            }\n         }\n      });\n   }","id":3107,"modified_method":"@Inject\n   public TargetContentsPresenter(Provider<TargetContentsDisplay> displayProvider, final EventBus eventBus, final TableEditorMessages messages, final SourceContentsPresenter sourceContentsPresenter)\n   {\n      this.displayProvider = displayProvider;\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n\n      validationMessagePanel = new ValidationMessagePanel(true, messages);\n\n      eventBus.addHandler(UpdateValidationWarningsEvent.getType(), new UpdateValidationWarningsEventHandler()\n      {\n         @Override\n         public void onUpdate(UpdateValidationWarningsEvent event)\n         {\n            validationMessagePanel.setContent(event.getErrors());\n         }\n      });\n\n      eventBus.addHandler(RequestValidationEvent.getType(), new RequestValidationEventHandler()\n      {\n         @Override\n         public void onRequestValidation(RequestValidationEvent event)\n         {\n            if (isEditing())\n            {\n               eventBus.fireEvent(new RunValidationEvent(sourceContentsPresenter.getSelectedSource(),\n                     getCurrentEditor().getText(), false));\n            }\n         }\n      });\n\n      eventBus.addHandler(InsertStringInEditorEvent.getType(), new InsertStringInEditorHandler()\n      {\n         @Override\n         public void onInsertString(InsertStringInEditorEvent event)\n         {\n            if (isEditing())\n            {\n               getCurrentEditor().insertTextInCursorPosition(event.getSuggestion());\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyCopied()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Error, messages.notifyUnopened()));\n            }\n         }\n      });\n\n      eventBus.addHandler(CopyDataToEditorEvent.getType(), new CopyDataToEditorHandler()\n      {\n         @Override\n         public void onTransMemoryCopy(CopyDataToEditorEvent event)\n         {\n            if (isEditing())\n            {\n               getCurrentEditor().setText(event.getTargetResult());\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyCopied()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Error, messages.notifyUnopened()));\n            }\n         }\n      });\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setCurrentEditorText(String text)\n   {\n      if (currentEditor != null)\n      {\n         currentEditor.setText(text);\n      }\n   }","id":3108,"modified_method":"public void setCurrentEditorText(String text)\n   {\n      if (getCurrentEditor() != null)\n      {\n         getCurrentEditor().setText(text);\n      }\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void showEditors(int rowIndex)\n   {\n      TargetContentsDisplay previousDisplay = currentDisplay;\n      if (previousDisplay != null)\n      {\n         previousDisplay.setToView();\n         currentEditor = null;\n      }\n      currentDisplay = displayList.get(rowIndex);\n      currentEditors = currentDisplay.getEditors();\n\n      if (currentEditor != null && currentEditors.contains(currentEditor))\n      {\n         currentEditor = currentDisplay.openEditorAndCloseOthers(currentEditor);\n      \t Log.info(\"show editors at row:\" + rowIndex + \" current editor:\" + currentEditor);\n      }\n   }","id":3109,"modified_method":"public void showEditors(int rowIndex)\n   {\n      TargetContentsDisplay previousDisplay = currentDisplay;\n      if (previousDisplay != null)\n      {\n         previousDisplay.setToView();\n      }\n      currentDisplay = displayList.get(rowIndex);\n      if (previousDisplay != currentDisplay)\n      {\n//         currentEditor = null;\n         currentEditorIndex = -1;\n      }\n      currentEditors = currentDisplay.getEditors();\n\n      if (currentEditorIndex != -1)\n      {\n         currentDisplay.openEditorAndCloseOthers(currentEditorIndex);\n      \t Log.info(\"show editors at row:\" + rowIndex + \" current editor:\" + currentEditorIndex);\n      }\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setToViewMode()\n   {\n      if (currentDisplay != null)\n      {\n         currentDisplay.setToView();\n         Log.info(\"setting to view mode:\" + displayList.indexOf(currentDisplay));\n      }\n   }","id":3110,"modified_method":"public void setToViewMode()\n   {\n      if (currentDisplay != null)\n      {\n         currentDisplay.setToView();\n      }\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void saveAsApproved(ToggleEditor editor)\n   {\n      int editorIndex = currentEditors.indexOf(editor);\n      if (editorIndex + 1 < currentEditors.size())\n      {\n         currentEditor = currentDisplay.openEditorAndCloseOthers(currentEditors.get(editorIndex + 1));\n      }\n      else\n      {\n         eventBus.fireEvent(new NavTransUnitEvent(NavTransUnitEvent.NavigationType.NextEntry));\n      }\n   }","id":3111,"modified_method":"@Override\n   public void saveAsApproved(ToggleEditor editor)\n   {\n      int editorIndex = currentEditors.indexOf(editor);\n      if (editorIndex + 1 < currentEditors.size())\n      {\n         currentDisplay.openEditorAndCloseOthers(editorIndex + 1);\n         currentEditorIndex++;\n      }\n      else\n      {\n         eventBus.fireEvent(new NavTransUnitEvent(NavTransUnitEvent.NavigationType.NextEntry));\n      }\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void toggleView(ToggleEditor editor)\n   {\n      currentEditor = editor;\n      if (currentEditors.contains(editor))\n      {\n         //still in the same trans unit. won't trigger transunit selection or edit cell event\n         currentEditor = currentDisplay.openEditorAndCloseOthers(editor);\n      }\n      Log.info(\"current display:\" + currentDisplay);\n      //else, it's clicking an editor outside current selection. the table selection event will trigger and showEditors will take care of the rest\n   }","id":3112,"modified_method":"@Override\n   public void toggleView(ToggleEditor editor)\n   {\n      currentEditorIndex = editor.getIndex();\n      if (currentEditors.contains(editor))\n      {\n         //still in the same trans unit. won't trigger transunit selection or edit cell event\n         currentDisplay.openEditorAndCloseOthers(currentEditorIndex);\n      }\n      Log.info(\"current display:\" + currentDisplay);\n      //else, it's clicking an editor outside current selection. the table selection event will trigger and showEditors will take care of the rest\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public ToggleEditor openEditorAndCloseOthers(ToggleEditor currentEditor)\n   {\n      setToView();\n      currentEditor.setViewMode(ToggleEditor.ViewMode.EDIT);\n      return currentEditor;\n   }","id":3113,"modified_method":"@Override\n   public void openEditorAndCloseOthers(int currentEditor)\n   {\n      setToView();\n      editors.get(currentEditor).setViewMode(ToggleEditor.ViewMode.EDIT);\n   }","commit_id":"f8894217ca83a7f167f93917300a7a79abc7dd91","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Returns the list of version ids\n     */\n    @GET\n    @Path(\"versions\")\n    public Map<String,String> versions() {\n        FabricService fabricService = getFabricService();\n        if (fabricService != null) {\n            ProfileService profileService = fabricService.adapt(ProfileService.class);\n            List<String> versionIds = profileService.getVersions();\n            return mapToLinks(versionIds, \"/version/\");\n        } else {\n            noFabricService();\n        }\n        return Collections.EMPTY_MAP;\n    }","id":3114,"modified_method":"/**\n     * Returns the list of version ids\n     */\n    @GET\n    @Path(\"versions\")\n    public Map<String,String> versions() {\n        FabricService fabricService = getFabricService();\n        if (fabricService != null) {\n            ProfileService profileService = fabricService.adapt(ProfileService.class);\n            List<String> versionIds = profileService.getVersions();\n            return mapToLinks(versionIds, \"/version/\");\n        } else {\n            noFabricService();\n        }\n        return Collections.emptyMap();\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns the list of container IDs\n     */\n    @GET\n    @Path(\"containers\")\n    public Map<String, String> containers() {\n        FabricService fabricService = getFabricService();\n        if (fabricService != null) {\n            return mapToLinks(Containers.containerIds(fabricService.getContainers()), \"/container/\");\n        } else {\n            noFabricService();\n        }\n        return Collections.EMPTY_MAP;\n    }","id":3115,"modified_method":"/**\n     * Returns the list of container IDs\n     */\n    @GET\n    @Path(\"containers\")\n    public Map<String, String> containers() {\n        FabricService fabricService = getFabricService();\n        if (fabricService != null) {\n            return mapToLinks(Containers.containerIds(fabricService.getContainers()), \"/container/\");\n        } else {\n            noFabricService();\n        }\n        return Collections.emptyMap();\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public MavenDownloadProxyServlet(RuntimeProperties runtimeProperties, String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts) {\n        super(localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, proxyNonProxyHosts);\n        this.runtimeProperties = runtimeProperties;\n    }","id":3116,"modified_method":"public MavenDownloadProxyServlet(RuntimeProperties runtimeProperties, String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts, ProjectDeployer projectDeployer) {\n        super(localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, proxyNonProxyHosts, projectDeployer);\n        this.runtimeProperties = runtimeProperties;\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Activate\n    void init(Map<String, ?> configuration) throws Exception {\n        configurer.configure(configuration, this);\n        this.mavenDownloadProxyServlet = new MavenDownloadProxyServlet(runtimeProperties.get(), localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, nonProxyHosts);\n        this.mavenDownloadProxyServlet.start();\n        this.mavenUploadProxyServlet = new MavenUploadProxyServlet(runtimeProperties.get(), localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, nonProxyHosts);\n        this.mavenUploadProxyServlet.start();\n        try {\n            HttpContext base = httpService.get().createDefaultHttpContext();\n            HttpContext secure = new MavenSecureHttpContext(base, realm, role);\n            httpService.get().registerServlet(\"/maven/download\", mavenDownloadProxyServlet, createParams(\"maven-download\"), base);\n            httpService.get().registerServlet(\"/maven/upload\", mavenUploadProxyServlet, createParams(\"maven-upload\"), secure);\n        } catch (Throwable t) {\n            LOGGER.warn(\"Failed to register fabric maven proxy servlets, due to:\" + t.getMessage());\n        }\n        activateComponent();\n    }","id":3117,"modified_method":"@Activate\n    void init(Map<String, ?> configuration) throws Exception {\n        configurer.configure(configuration, this);\n        this.mavenDownloadProxyServlet = new MavenDownloadProxyServlet(runtimeProperties.get(), localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, nonProxyHosts, projectDeployer.get());\n        this.mavenDownloadProxyServlet.start();\n        this.mavenUploadProxyServlet = new MavenUploadProxyServlet(runtimeProperties.get(), localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, nonProxyHosts, projectDeployer.get());\n        this.mavenUploadProxyServlet.start();\n        try {\n            HttpContext base = httpService.get().createDefaultHttpContext();\n            HttpContext secure = new MavenSecureHttpContext(base, realm, role);\n            httpService.get().registerServlet(\"/maven/download\", mavenDownloadProxyServlet, createParams(\"maven-download\"), base);\n            httpService.get().registerServlet(\"/maven/upload\", mavenUploadProxyServlet, createParams(\"maven-upload\"), secure);\n        } catch (Throwable t) {\n            LOGGER.warn(\"Failed to register fabric maven proxy servlets, due to:\" + t.getMessage());\n        }\n        activateComponent();\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public MavenProxyServletSupport(String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts) {\n        this.localRepository = localRepository;\n        this.remoteRepositories = remoteRepositories;\n        this.appendSystemRepos = appendSystemRepos;\n        this.updatePolicy = updatePolicy;\n        this.checksumPolicy = checksumPolicy;\n        this.proxyProtocol = proxyProtocol;\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUsername = proxyUsername;\n        this.proxyPassword = proxyPassword;\n        this.proxyNonProxyHosts = proxyNonProxyHosts;\n    }","id":3118,"modified_method":"public MavenProxyServletSupport(String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts, ProjectDeployer projectDeployer) {\n        this.localRepository = localRepository;\n        this.remoteRepositories = remoteRepositories;\n        this.appendSystemRepos = appendSystemRepos;\n        this.updatePolicy = updatePolicy;\n        this.checksumPolicy = checksumPolicy;\n        this.proxyProtocol = proxyProtocol;\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUsername = proxyUsername;\n        this.proxyPassword = proxyPassword;\n        this.proxyNonProxyHosts = proxyNonProxyHosts;\n        this.projectDeployer = projectDeployer;\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public boolean upload(InputStream is, String path) throws InvalidMavenArtifactRequest {\n        boolean success = true;\n        Matcher artifactMatcher = ARTIFACT_REQUEST_URL_REGEX.matcher(path);\n        Matcher metdataMatcher = ARTIFACT_METADATA_URL_REGEX.matcher(path);\n        if (path == null) {\n            throw new InvalidMavenArtifactRequest();\n        } else if (metdataMatcher.matches()) {\n            LOGGER.log(Level.INFO, String.format(\"Received upload request for maven metadata : %s\", path));\n            try {\n                String filename = path.substring(path.lastIndexOf('/') + 1);\n                Metadata metadata = convertPathToMetadata(path);\n                metadata = metadata.setFile(readFile(is, tmpFolder, filename));\n                InstallRequest request = new InstallRequest();\n                request.addMetadata(metadata);\n                system.install(session, request);\n                success = true;\n                LOGGER.log(Level.INFO, \"Maven metadata installed: \" + request.toString());\n            } catch (Exception e) {\n                LOGGER.log(Level.WARNING, String.format(\"Failed to upload metadata: %s due to %s\", path, e), e);\n                success = false;\n            }\n            //If no matching metadata found return nothing\n        } else if (artifactMatcher.matches()) {\n            LOGGER.log(Level.INFO, String.format(\"Received upload request for maven artifact : %s\", path));\n            Artifact artifact = null;\n            try {\n                String filename = path.substring(path.lastIndexOf('/') + 1);\n                artifact = convertPathToArtifact(path);\n                artifact = artifact.setFile(readFile(is, tmpFolder, filename));\n                InstallRequest request = new InstallRequest();\n                request.addArtifact(artifact);\n                system.install(session, request);\n                success = true;\n                LOGGER.log(Level.INFO, \"Artifact installed: \" + artifact.toString());\n            } catch (Exception e) {\n                success = false;\n                LOGGER.log(Level.WARNING, String.format(\"Failed to upload artifact : %s due to %s\", artifact, e), e);\n            }\n        }\n        return success;\n\n    }","id":3119,"modified_method":"@Override\n    public boolean upload(InputStream is, String path) throws InvalidMavenArtifactRequest {\n        return doUpload(is, path).status();\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Before\n    public void setUp() {\n        runtimeProperties = EasyMock.createMock(RuntimeProperties.class);\n        servlet = new MavenDownloadProxyServlet(runtimeProperties, null, null, false, null,null,null,null,0,null, null, null);\n    }","id":3120,"modified_method":"@Before\n    public void setUp() {\n        runtimeProperties = EasyMock.createMock(RuntimeProperties.class);\n        projectDeployer = EasyMock.createMock(ProjectDeployer.class);\n        servlet = new MavenDownloadProxyServlet(runtimeProperties, null, null, false, null,null,null,null,0,null, null, null, projectDeployer);\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void testDownload(Handler serverHandler) throws Exception {\n        String old = System.getProperty(\"karaf.data\");\n        System.setProperty(\"karaf.data\", new File(\"target\").getCanonicalPath());\n        FileUtils.deleteDirectory(new File(\"target/tmp\"));\n\n        Server server = new Server(0);\n        server.setHandler(serverHandler);\n        server.start();\n\n        try {\n            int localPort = server.getConnectors()[0].getLocalPort();\n            List<String> remoteRepos = Arrays.asList(\"http://relevant.not/maven2@id=central\");\n            RuntimeProperties props = new MockRuntimeProperties();\n            MavenDownloadProxyServlet servlet = new MavenDownloadProxyServlet(props, \"target/tmp\", remoteRepos, false, \"always\", \"warn\", \"http\", \"localhost\", localPort, \"fuse\", \"fuse\", null);\n\n            HttpServletRequest request = EasyMock.createMock(HttpServletRequest.class);\n            EasyMock.expect(request.getPathInfo()).andReturn(\"org.apache.camel/camel-core/2.13.0/camel-core-2.13.0-sources.jar\");\n\n            HttpServletResponse response = EasyMock.createMock(HttpServletResponse.class);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            EasyMock.expect(response.getOutputStream()).andReturn(new ServletOutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    baos.write(b);\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    baos.write(b, off, len);\n                }\n            }).anyTimes();\n            response.setStatus(EasyMock.anyInt());\n            EasyMock.expectLastCall().anyTimes();\n            response.setContentLength(EasyMock.anyInt());\n            EasyMock.expectLastCall().anyTimes();\n            response.setContentType((String) EasyMock.anyObject());\n            EasyMock.expectLastCall().anyTimes();\n            response.setDateHeader((String) EasyMock.anyObject(), EasyMock.anyLong());\n            EasyMock.expectLastCall().anyTimes();\n            response.setHeader((String) EasyMock.anyObject(), (String) EasyMock.anyObject());\n            EasyMock.expectLastCall().anyTimes();\n\n            EasyMock.replay(request, response);\n\n            servlet.start();\n            servlet.doGet(request, response);\n            Assert.assertArrayEquals(new byte[] { 0x42 }, baos.toByteArray());\n\n            EasyMock.verify(request, response);\n        } finally {\n            server.stop();\n            if (old != null) {\n                System.setProperty(\"karaf.data\", old);\n            }\n        }\n    }","id":3121,"modified_method":"private void testDownload(Handler serverHandler) throws Exception {\n        String old = System.getProperty(\"karaf.data\");\n        System.setProperty(\"karaf.data\", new File(\"target\").getCanonicalPath());\n        FileUtils.deleteDirectory(new File(\"target/tmp\"));\n\n        Server server = new Server(0);\n        server.setHandler(serverHandler);\n        server.start();\n\n        try {\n            int localPort = server.getConnectors()[0].getLocalPort();\n            List<String> remoteRepos = Arrays.asList(\"http://relevant.not/maven2@id=central\");\n            RuntimeProperties props = new MockRuntimeProperties();\n            MavenDownloadProxyServlet servlet = new MavenDownloadProxyServlet(props, \"target/tmp\", remoteRepos, false, \"always\", \"warn\", \"http\", \"localhost\", localPort, \"fuse\", \"fuse\", null, projectDeployer);\n\n            HttpServletRequest request = EasyMock.createMock(HttpServletRequest.class);\n            EasyMock.expect(request.getPathInfo()).andReturn(\"org.apache.camel/camel-core/2.13.0/camel-core-2.13.0-sources.jar\");\n\n            HttpServletResponse response = EasyMock.createMock(HttpServletResponse.class);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            EasyMock.expect(response.getOutputStream()).andReturn(new ServletOutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    baos.write(b);\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    baos.write(b, off, len);\n                }\n            }).anyTimes();\n            response.setStatus(EasyMock.anyInt());\n            EasyMock.expectLastCall().anyTimes();\n            response.setContentLength(EasyMock.anyInt());\n            EasyMock.expectLastCall().anyTimes();\n            response.setContentType((String) EasyMock.anyObject());\n            EasyMock.expectLastCall().anyTimes();\n            response.setDateHeader((String) EasyMock.anyObject(), EasyMock.anyLong());\n            EasyMock.expectLastCall().anyTimes();\n            response.setHeader((String) EasyMock.anyObject(), (String) EasyMock.anyObject());\n            EasyMock.expectLastCall().anyTimes();\n\n            EasyMock.replay(request, response);\n\n            servlet.start();\n            servlet.doGet(request, response);\n            Assert.assertArrayEquals(new byte[] { 0x42 }, baos.toByteArray());\n\n            EasyMock.verify(request, response);\n        } finally {\n            server.stop();\n            if (old != null) {\n                System.setProperty(\"karaf.data\", old);\n            }\n        }\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStartServlet() throws Exception {\n        String old = System.getProperty(\"karaf.data\");\n        System.setProperty(\"karaf.data\", new File(\"target\").getCanonicalPath());\n        try {\n            MavenDownloadProxyServlet servlet = new MavenDownloadProxyServlet(runtimeProperties, System.getProperty(\"java.io.tmpdir\"), null, false, null,null,null,null,0,null, null, null);\n            servlet.start();\n        } finally {\n            if (old != null) {\n                System.setProperty(\"karaf.data\", old);\n            }\n        }\n    }","id":3122,"modified_method":"@Test\n    public void testStartServlet() throws Exception {\n        String old = System.getProperty(\"karaf.data\");\n        System.setProperty(\"karaf.data\", new File(\"target\").getCanonicalPath());\n        try {\n            MavenDownloadProxyServlet servlet = new MavenDownloadProxyServlet(runtimeProperties, System.getProperty(\"java.io.tmpdir\"), null, false, null,null,null,null,0,null, null, null, projectDeployer);\n            servlet.start();\n        } finally {\n            if (old != null) {\n                System.setProperty(\"karaf.data\", old);\n            }\n        }\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public MavenUploadProxyServlet(RuntimeProperties runtimeProperties, String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts) {\n        super(runtimeProperties, localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, proxyNonProxyHosts);\n    }","id":3123,"modified_method":"public MavenUploadProxyServlet(RuntimeProperties runtimeProperties, String localRepository, List<String> remoteRepositories, boolean appendSystemRepos, String updatePolicy, String checksumPolicy, String proxyProtocol, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword, String proxyNonProxyHosts, ProjectDeployer projectDeployer) {\n        super(runtimeProperties, localRepository, remoteRepositories, appendSystemRepos, updatePolicy, checksumPolicy, proxyProtocol, proxyHost, proxyPort, proxyUsername, proxyPassword, proxyNonProxyHosts, projectDeployer);\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        try {\n            String path = req.getPathInfo();\n            //Make sure path is valid\n            if (path == null) {\n                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n\n            if (upload(req.getInputStream(), path)) {\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n            }\n        } catch (InvalidMavenArtifactRequest ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        } catch (Exception ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        }\n\n    }","id":3124,"modified_method":"@Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        try {\n            String path = req.getPathInfo();\n            //Make sure path is valid\n            if (path == null) {\n                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n\n            // handle move\n            String location = req.getHeader(LOCATION_HEADER);\n            if (location != null) {\n                UploadContext result = move(location, path);\n                addHeaders(resp, result.headers());\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n                return;\n            }\n\n            UploadContext result = doUpload(req.getInputStream(), path);\n            if (result.status()) {\n                addHeaders(resp, result.headers());\n\n                String profile = req.getParameter(\"profile\");\n                String version = req.getParameter(\"version\");\n                if (profile != null && version != null) {\n                    ProjectRequirements requirements = toProjectRequirements(result);\n                    requirements.setProfileId(profile);\n                    requirements.setVersion(version);\n\n                    DeployResults deployResults = addToProfile(requirements);\n                    LOGGER.info(String.format(\"Deployed artifact %s to profile: %s\", result.toArtifact(), deployResults));\n                }\n\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n            }\n        } catch (InvalidMavenArtifactRequest ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        } catch (Exception ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        }\n\n    }","commit_id":"adb6486c7106e20921b031f7263e94cebcef9863","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private AggregateStatus createAggregateStatus(Collection<OnmsCategory> rowCatNames, Collection<OnmsCategory> colCatNames) {\n        AggregateStatus status;\n        Collection<OnmsNode> nodes = m_nodeDao.findAllByCategoryLists(rowCatNames, colCatNames);\n        status = new AggregateStatus();\n        status.setDownEntityCount(computeDownCount(nodes));\n        status.setDownEntityCount(nodes.size());\n        status.setStatus(computeStatus(nodes, status));\n        return status;\n    }","id":3125,"modified_method":"private AggregateStatus createAggregateStatus(Collection<OnmsCategory> rowCatNames, Collection<OnmsCategory> colCatNames) {\n        AggregateStatus status;\n        Collection<OnmsNode> nodes = m_nodeDao.findAllByCategoryLists(rowCatNames, colCatNames);\n        status = new AggregateStatus();\n        if (nodes == null || nodes.isEmpty()) {\n            status.setDownEntityCount(0);\n            status.setTotalEntityCount(0);\n            status.setStatus(AggregateStatus.ALL_NODES_UP);\n        } else {\n            status.setDownEntityCount(computeDownCount(nodes));\n            status.setTotalEntityCount(nodes.size());\n            status.setStatus(computeStatus(nodes, status));\n        }\n        return status;\n    }","commit_id":"7be59642a62835314083f04b39f84d6257899327","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public CharSequence quickLinksAndTweets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<div id=\\\"extra\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"inner\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"row\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3>Quick Links<\/h3>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"#\\\">Support<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"#\\\">License<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"#\\\">Terms of Use<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"#\\\">Privacy Policy<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org\\\">Eclipse.org<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://marketplace.eclipse.org/\\\">Eclipse Market Place<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://live.eclipse.org/\\\">Eclipse Live<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.planeteclipse.org/\\\">Eclipse Planet<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3><a href=\\\"https://twitter.com/#!/xtext\\\" style=\\\"color: white;\\\">@Xtext<\/a> Tweets<\/h3>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<br />\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<div id=\\\"tweet\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>Please wait while my tweets load<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<a href=\\\"http://twitter.com/rem\\\">If you can\\'t wait - check\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"out what I\\'ve been twittering<\/a>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    return _builder;\n  }","id":3126,"modified_method":"public CharSequence quickLinksAndTweets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<div id=\\\"extra\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"inner\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"row\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3>Quick Links<\/h3>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/privacy.php\\\">Privacy Policy<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/termsofuse.php\\\">Terms of Use<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/copyright.php\\\">Copyright Agent<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/\\\">Legal<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"<li><a href=\\\"/\\\">Home<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://marketplace.eclipse.org/\\\">Market Place<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://live.eclipse.org/\\\">Eclipse Live<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.planeteclipse.org/\\\">Eclipse Planet<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3><a href=\\\"https://twitter.com/#!/xtext\\\" style=\\\"color: white;\\\">@Xtext<\/a> Tweets<\/h3>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<br />\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<div id=\\\"tweet\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>Please wait while my tweets load<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<a href=\\\"http://twitter.com/rem\\\">If you can\\'t wait - check\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"out what I\\'ve been twittering<\/a>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"db31cfdd688182b25793971f5d53634ad1149103","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence navBar() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Navbar -->\");\n    _builder.newLine();\n    _builder.append(\"<div class=\\\"navbar navbar-fixed-top\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"style=\\\"border-bottom: 1px solid #000;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"navbar-inner\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<a class=\\\"btn btn-navbar\\\" data-toggle=\\\"collapse\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"data-target=\\\".nav-collapse\\\"> <span class=\\\"icon-bar\\\"><\/span> <span\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"class=\\\"icon-bar\\\"><\/span> <span class=\\\"icon-bar\\\"><\/span>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/a> <a class=\\\"brand\\\" href=\\\"index.html\\\"><\/a>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"nav-collapse collapse\\\" style=\\\"height: 0px;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"nav\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path = this.path();\n      boolean _equals = Objects.equal(_path, \"download.html\");\n      if (_equals) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"download.html\\\">Download<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_1 = this.path();\n      boolean _equals_1 = Objects.equal(_path_1, \"examples.html\");\n      if (_equals_1) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"examples.html\\\">Examples<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_2 = this.path();\n      boolean _equals_2 = Objects.equal(_path_2, \"documentation.html\");\n      if (_equals_2) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"documentation.html\\\">Documentation<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_3 = this.path();\n      boolean _equals_3 = Objects.equal(_path_3, \"community.html\");\n      if (_equals_3) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"community.html\\\">Community<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org\\\">Eclipse.org<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<!--/.nav-collapse -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<!-- Navbar End -->\");\n    _builder.newLine();\n    return _builder;\n  }","id":3127,"modified_method":"public CharSequence navBar() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Navbar -->\");\n    _builder.newLine();\n    _builder.append(\"<div class=\\\"navbar navbar-fixed-top\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"style=\\\"border-bottom: 1px solid #000;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"navbar-inner\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<a class=\\\"btn btn-navbar\\\" data-toggle=\\\"collapse\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"data-target=\\\".nav-collapse\\\"> <span class=\\\"icon-bar\\\"><\/span> <span\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"class=\\\"icon-bar\\\"><\/span> <span class=\\\"icon-bar\\\"><\/span>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/a> <a class=\\\"brand\\\" href=\\\"index.html\\\"><\/a>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"      \");\n    _builder.append(\"<div class=\\\"btn-group pull-right\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<g:plusone href=\\\"http://www.xtext.org\\\"><\/g:plusone>\");\n    _builder.newLine();\n    _builder.append(\"      \");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"nav-collapse collapse\\\" style=\\\"height: 0px;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"nav\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path = this.path();\n      boolean _equals = Objects.equal(_path, \"download.html\");\n      if (_equals) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"download.html\\\">Download<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_1 = this.path();\n      boolean _equals_1 = Objects.equal(_path_1, \"documentation.html\");\n      if (_equals_1) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"documentation.html\\\">Documentation<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_2 = this.path();\n      boolean _equals_2 = Objects.equal(_path_2, \"community.html\");\n      if (_equals_2) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"community.html\\\">Community<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org\\\">Eclipse.org<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<!--/.nav-collapse -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<!-- Navbar End -->\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"db31cfdd688182b25793971f5d53634ad1149103","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence javaScriptDocumentStart() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<script\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"src=\\\"js/twitter.js\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"getTwitters(\\'tweet\\', { \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"id: \\'xtext\\', \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"count: 5,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"includeRT: true,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"enableLinks: true, \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"clearContents: true,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"template: \\'\\\"%text%\\\" <a href=\\\"http://twitter.com/%user_screen_name%/statuses/%id_str%/\\\">%time%<\/a><br/><br/>\\'\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery-1.7.1.min.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"stylesheet\\\" media=\\\"screen\\\" href=\\\"css/prettyPhoto.css\\\" />\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.prettyPhoto.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"$(document).ready(function() {\");\n    _builder.newLine();\n    _builder.append(\"           \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"$(\\'a[data-rel]\\').each(function() {\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"$(this).attr(\\'rel\\', $(this).data(\\'rel\\'));\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"$(\\\"a[rel^=\\'prettyPhoto\\']\\\").prettyPhoto({\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"animation_speed: \\'fast\\',\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"slideshow: 5000,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"autoplay_slideshow: false,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"opacity: 0.80,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"show_title: true,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"theme: \\'ligh_square\\',\");\n    _builder.newLine();\n    _builder.append(\"//                     \\'pp_default\\', /* light_rounded / dark_rounded / light_square / dark_square / facebook */\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"overlay_gallery: false,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"social_tools: false\");\n    _builder.newLine();\n    _builder.append(\"              \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"$(function() {      \");\n    _builder.newLine();\n    _builder.append(\"    \\t\");\n    _builder.append(\"$(\\'#nav-outline > li > a\\').live(\\'click\\', function() {        \");\n    _builder.newLine();\n    _builder.append(\"    \\t\\t\");\n    _builder.append(\"$(this).parent().find(\\'ul\\').slideToggle();      \");\n    _builder.newLine();\n    _builder.append(\"    \\t\");\n    _builder.append(\"});    \");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"google-code-prettify/prettify.css\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" />\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/prettify.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/lang-xtend.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"var _gaq = _gaq || [];\\t\");\n    _builder.newLine();\n    _builder.append(\"  \\t\");\n    _builder.append(\"_gaq.push([ \\'_setAccount\\', \\'UA-2429174-4\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"_gaq.push([ \\'_trackPageview\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"(function() {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var ga = document.createElement(\\'script\\');\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.type = \\'text/javascript\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.src = (\\'https:\\' == document.location.protocol ? \\'https://ssl\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\": \\'http://www\\')\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"+ \\'.google-analytics.com/ga.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0];\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"s.parentNode.insertBefore(ga, s);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"})();\");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","id":3128,"modified_method":"public CharSequence javaScriptDocumentStart() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<script\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"src=\\\"js/twitter.js\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"getTwitters(\\'tweet\\', { \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"id: \\'xtext\\', \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"count: 5,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"includeRT: true,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"enableLinks: true, \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"clearContents: true,\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"template: \\'\\\"%text%\\\" <a href=\\\"http://twitter.com/%user_screen_name%/statuses/%id_str%/\\\">%time%<\/a><br/><br/>\\'\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery-1.7.1.min.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"stylesheet\\\" media=\\\"screen\\\" href=\\\"css/prettyPhoto.css\\\" />\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.prettyPhoto.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"$(document).ready(function() {\");\n    _builder.newLine();\n    _builder.append(\"           \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"$(\\'a[data-rel]\\').each(function() {\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"$(this).attr(\\'rel\\', $(this).data(\\'rel\\'));\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"$(\\\"a[rel^=\\'prettyPhoto\\']\\\").prettyPhoto({\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"animation_speed: \\'fast\\',\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"slideshow: 5000,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"autoplay_slideshow: false,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"opacity: 0.80,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"show_title: true,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"theme: \\'ligh_square\\',\");\n    _builder.newLine();\n    _builder.append(\"//                     \\'pp_default\\', /* light_rounded / dark_rounded / light_square / dark_square / facebook */\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"overlay_gallery: false,\");\n    _builder.newLine();\n    _builder.append(\"                    \");\n    _builder.append(\"social_tools: false\");\n    _builder.newLine();\n    _builder.append(\"              \");\n    _builder.newLine();\n    _builder.append(\"                \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"$(function() {      \");\n    _builder.newLine();\n    _builder.append(\"    \\t\");\n    _builder.append(\"$(\\'#nav-outline > li > a\\').live(\\'click\\', function() {        \");\n    _builder.newLine();\n    _builder.append(\"    \\t\\t\");\n    _builder.append(\"$(this).parent().find(\\'ul\\').slideToggle();      \");\n    _builder.newLine();\n    _builder.append(\"    \\t\");\n    _builder.append(\"});    \");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"google-code-prettify/prettify.css\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" />\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/prettify.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/lang-xtend.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"(function() {\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"var po = document.createElement(\\'script\\'); po.type = \\'text/javascript\\'; po.async = true;\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"po.src = \\'https://apis.google.com/js/plusone.js\\';\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0]; s.parentNode.insertBefore(po, s);\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"})();\");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"var _gaq = _gaq || [];\\t\");\n    _builder.newLine();\n    _builder.append(\"  \\t\");\n    _builder.append(\"_gaq.push([ \\'_setAccount\\', \\'UA-2429174-4\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"_gaq.push([ \\'_trackPageview\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"(function() {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var ga = document.createElement(\\'script\\');\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.type = \\'text/javascript\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.src = (\\'https:\\' == document.location.protocol ? \\'https://ssl\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\": \\'http://www\\')\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"+ \\'.google-analytics.com/ga.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0];\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"s.parentNode.insertBefore(ga, s);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"})();\");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"db31cfdd688182b25793971f5d53634ad1149103","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSetupGradleBuildFileWithContent() {\n    PsiFile _addFileToProject = this.myFixture.addFileToProject(\"build.gradle\", \"buildscript{dependencies{}}\");\n    final GroovyFile buildFile = ((GroovyFile) _addFileToProject);\n    TestCase.assertNotNull(buildFile);\n    Project _project = this.myFixture.getProject();\n    final Runnable _function = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project, _function);\n    Project _project_1 = this.myFixture.getProject();\n    final Runnable _function_1 = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project_1, _function_1);\n    this.assertTree(buildFile);\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript{dependencies{\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:\");\n    _builder.append(this.util.xtendGradlePluginVersion, \"    \");\n    _builder.append(\"\\'\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"}}\");\n    _builder.newLine();\n    _builder.append(\"apply plugin: \\'org.xtend.xtend\\' \");\n    String _string = _builder.toString();\n    String _trim = _string.trim();\n    String _text = buildFile.getText();\n    TestCase.assertEquals(_trim, _text);\n  }","id":3129,"modified_method":"public void testSetupGradleBuildFileWithContent() {\n    PsiFile _addFileToProject = this.myFixture.addFileToProject(\"build.gradle\", \"buildscript{dependencies{}}\");\n    final GroovyFile buildFile = ((GroovyFile) _addFileToProject);\n    TestCase.assertNotNull(buildFile);\n    Project _project = this.myFixture.getProject();\n    final Runnable _function = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project, _function);\n    Project _project_1 = this.myFixture.getProject();\n    final Runnable _function_1 = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project_1, _function_1);\n    this.assertTree(buildFile);\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript{dependencies{\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:0.4.7\\'\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"repositories {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"jcenter()\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"apply plugin: \\'org.xtend.xtend\\' \");\n    String _string = _builder.toString();\n    String _trim = _string.trim();\n    String _text = buildFile.getText();\n    TestCase.assertEquals(_trim, _text);\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSetupGradleBuildEmptyFile() {\n    PsiFile _addFileToProject = this.myFixture.addFileToProject(\"build.gradle\", \"\");\n    final GroovyFile buildFile = ((GroovyFile) _addFileToProject);\n    TestCase.assertNotNull(buildFile);\n    Project _project = this.myFixture.getProject();\n    final Runnable _function = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project, _function);\n    Project _project_1 = this.myFixture.getProject();\n    final Runnable _function_1 = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project_1, _function_1);\n    this.assertTree(buildFile);\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript {\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"dependencies {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:\");\n    _builder.append(this.util.xtendGradlePluginVersion, \"        \");\n    _builder.append(\"\\'\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"apply plugin: \\'org.xtend.xtend\\' \");\n    String _string = _builder.toString();\n    String _trim = _string.trim();\n    String _text = buildFile.getText();\n    TestCase.assertEquals(_trim, _text);\n  }","id":3130,"modified_method":"public void testSetupGradleBuildEmptyFile() {\n    PsiFile _addFileToProject = this.myFixture.addFileToProject(\"build.gradle\", \"\");\n    final GroovyFile buildFile = ((GroovyFile) _addFileToProject);\n    TestCase.assertNotNull(buildFile);\n    Project _project = this.myFixture.getProject();\n    final Runnable _function = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project, _function);\n    Project _project_1 = this.myFixture.getProject();\n    final Runnable _function_1 = new Runnable() {\n      @Override\n      public void run() {\n        GradleBuildFileUtilTest.this.util.setupGradleBuild(GradleBuildFileUtilTest.this.myModule, buildFile);\n      }\n    };\n    WriteCommandAction.runWriteCommandAction(_project_1, _function_1);\n    this.assertTree(buildFile);\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript {\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"repositories {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"jcenter()\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"dependencies {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:0.4.7\\'\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"apply plugin: \\'org.xtend.xtend\\' \");\n    String _string = _builder.toString();\n    String _trim = _string.trim();\n    String _text = buildFile.getText();\n    TestCase.assertEquals(_trim, _text);\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void assertTree(final GroovyFile buildFile) {\n    GrStatement[] _statements = buildFile.getStatements();\n    int _length = _statements.length;\n    TestCase.assertEquals(2, _length);\n    GrStatement[] _statements_1 = buildFile.getStatements();\n    Object _get = _statements_1[0];\n    TestCase.assertTrue((_get instanceof GrMethodCallExpression));\n    GrStatement[] _statements_2 = buildFile.getStatements();\n    GrStatement _get_1 = _statements_2[0];\n    final GrMethodCallExpression bs = ((GrMethodCallExpression) _get_1);\n    GrExpression _invokedExpression = bs.getInvokedExpression();\n    String _text = _invokedExpression.getText();\n    TestCase.assertEquals(\"buildscript\", _text);\n    GrClosableBlock[] _closureArguments = bs.getClosureArguments();\n    GrClosableBlock _head = IterableExtensions.<GrClosableBlock>head(((Iterable<GrClosableBlock>)Conversions.doWrapArray(_closureArguments)));\n    PsiElement[] _children = _head.getChildren();\n    Iterable<GrMethodCallExpression> _filter = Iterables.<GrMethodCallExpression>filter(((Iterable<?>)Conversions.doWrapArray(_children)), GrMethodCallExpression.class);\n    final GrMethodCallExpression dps = IterableExtensions.<GrMethodCallExpression>head(_filter);\n    GrExpression _invokedExpression_1 = dps.getInvokedExpression();\n    String _text_1 = _invokedExpression_1.getText();\n    TestCase.assertEquals(\"dependencies\", _text_1);\n    PsiElement[] _children_1 = dps.getChildren();\n    int _length_1 = _children_1.length;\n    TestCase.assertEquals(3, _length_1);\n    GrClosableBlock[] _closureArguments_1 = dps.getClosureArguments();\n    final GrClosableBlock closureBlock = IterableExtensions.<GrClosableBlock>head(((Iterable<GrClosableBlock>)Conversions.doWrapArray(_closureArguments_1)));\n    GrStatement[] _statements_3 = closureBlock.getStatements();\n    int _length_2 = _statements_3.length;\n    TestCase.assertEquals(1, _length_2);\n    GrStatement[] _statements_4 = closureBlock.getStatements();\n    Iterable<GrApplicationStatement> _filter_1 = Iterables.<GrApplicationStatement>filter(((Iterable<?>)Conversions.doWrapArray(_statements_4)), GrApplicationStatement.class);\n    final GrApplicationStatement clEntry = IterableExtensions.<GrApplicationStatement>head(_filter_1);\n    TestCase.assertNotNull(clEntry);\n    GrExpression _invokedExpression_2 = clEntry.getInvokedExpression();\n    String _text_2 = _invokedExpression_2.getText();\n    TestCase.assertEquals(\"classpath\", _text_2);\n    GrCommandArgumentList _argumentList = clEntry.getArgumentList();\n    String _text_3 = _argumentList.getText();\n    boolean _startsWith = _text_3.startsWith(\"\\'org.xtend:xtend-gradle-plugin:\");\n    TestCase.assertTrue(_startsWith);\n  }","id":3131,"modified_method":"public void assertTree(final GroovyFile buildFile) {\n    GrStatement[] _statements = buildFile.getStatements();\n    int _length = _statements.length;\n    TestCase.assertEquals(2, _length);\n    GrStatement[] _statements_1 = buildFile.getStatements();\n    Iterable<GrMethodCallExpression> _filter = Iterables.<GrMethodCallExpression>filter(((Iterable<?>)Conversions.doWrapArray(_statements_1)), GrMethodCallExpression.class);\n    final Function1<GrMethodCallExpression, Boolean> _function = new Function1<GrMethodCallExpression, Boolean>() {\n      @Override\n      public Boolean apply(final GrMethodCallExpression it) {\n        GrExpression _invokedExpression = it.getInvokedExpression();\n        String _text = _invokedExpression.getText();\n        return Boolean.valueOf(Objects.equal(_text, \"buildscript\"));\n      }\n    };\n    final Iterable<GrMethodCallExpression> bsCol = IterableExtensions.<GrMethodCallExpression>filter(_filter, _function);\n    int _size = IterableExtensions.size(bsCol);\n    TestCase.assertEquals(1, _size);\n    final GrMethodCallExpression bs = IterableExtensions.<GrMethodCallExpression>head(bsCol);\n    GrExpression _invokedExpression = bs.getInvokedExpression();\n    String _text = _invokedExpression.getText();\n    TestCase.assertEquals(\"buildscript\", _text);\n    GrClosableBlock[] _closureArguments = bs.getClosureArguments();\n    GrClosableBlock _head = IterableExtensions.<GrClosableBlock>head(((Iterable<GrClosableBlock>)Conversions.doWrapArray(_closureArguments)));\n    PsiElement[] _children = _head.getChildren();\n    final Iterable<GrMethodCallExpression> children = Iterables.<GrMethodCallExpression>filter(((Iterable<?>)Conversions.doWrapArray(_children)), GrMethodCallExpression.class);\n    int _size_1 = IterableExtensions.size(children);\n    TestCase.assertEquals(2, _size_1);\n    final Function1<GrMethodCallExpression, Boolean> _function_1 = new Function1<GrMethodCallExpression, Boolean>() {\n      @Override\n      public Boolean apply(final GrMethodCallExpression it) {\n        GrExpression _invokedExpression = it.getInvokedExpression();\n        String _text = _invokedExpression.getText();\n        return Boolean.valueOf(Objects.equal(_text, \"dependencies\"));\n      }\n    };\n    Iterable<GrMethodCallExpression> _filter_1 = IterableExtensions.<GrMethodCallExpression>filter(children, _function_1);\n    final GrMethodCallExpression dps = IterableExtensions.<GrMethodCallExpression>head(_filter_1);\n    TestCase.assertNotNull(dps);\n    PsiElement[] _children_1 = dps.getChildren();\n    int _length_1 = _children_1.length;\n    TestCase.assertEquals(3, _length_1);\n    GrClosableBlock[] _closureArguments_1 = dps.getClosureArguments();\n    final GrClosableBlock closureBlock = IterableExtensions.<GrClosableBlock>head(((Iterable<GrClosableBlock>)Conversions.doWrapArray(_closureArguments_1)));\n    GrStatement[] _statements_2 = closureBlock.getStatements();\n    int _length_2 = _statements_2.length;\n    TestCase.assertEquals(1, _length_2);\n    GrStatement[] _statements_3 = closureBlock.getStatements();\n    Iterable<GrApplicationStatement> _filter_2 = Iterables.<GrApplicationStatement>filter(((Iterable<?>)Conversions.doWrapArray(_statements_3)), GrApplicationStatement.class);\n    final GrApplicationStatement clEntry = IterableExtensions.<GrApplicationStatement>head(_filter_2);\n    TestCase.assertNotNull(clEntry);\n    GrExpression _invokedExpression_1 = clEntry.getInvokedExpression();\n    String _text_1 = _invokedExpression_1.getText();\n    TestCase.assertEquals(\"classpath\", _text_1);\n    GrCommandArgumentList _argumentList = clEntry.getArgumentList();\n    String _text_2 = _argumentList.getText();\n    boolean _startsWith = _text_2.startsWith(\"\\'org.xtend:xtend-gradle-plugin:\");\n    TestCase.assertTrue(_startsWith);\n    final Function1<GrMethodCallExpression, Boolean> _function_2 = new Function1<GrMethodCallExpression, Boolean>() {\n      @Override\n      public Boolean apply(final GrMethodCallExpression it) {\n        GrExpression _invokedExpression = it.getInvokedExpression();\n        String _text = _invokedExpression.getText();\n        return Boolean.valueOf(Objects.equal(_text, \"repositories\"));\n      }\n    };\n    Iterable<GrMethodCallExpression> _filter_3 = IterableExtensions.<GrMethodCallExpression>filter(children, _function_2);\n    final GrMethodCallExpression repos = IterableExtensions.<GrMethodCallExpression>head(_filter_3);\n    TestCase.assertNotNull(repos);\n    GrClosableBlock[] _closureArguments_2 = repos.getClosureArguments();\n    GrClosableBlock _head_1 = IterableExtensions.<GrClosableBlock>head(((Iterable<GrClosableBlock>)Conversions.doWrapArray(_closureArguments_2)));\n    GrStatement[] _statements_4 = _head_1.getStatements();\n    Iterable<GrMethodCallExpression> _filter_4 = Iterables.<GrMethodCallExpression>filter(((Iterable<?>)Conversions.doWrapArray(_statements_4)), GrMethodCallExpression.class);\n    final GrMethodCallExpression jcenterEntry = IterableExtensions.<GrMethodCallExpression>head(_filter_4);\n    GrExpression _invokedExpression_2 = jcenterEntry.getInvokedExpression();\n    String _text_3 = _invokedExpression_2.getText();\n    TestCase.assertEquals(\"jcenter\", _text_3);\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setupGradleBuild(final Module module, final GroovyFile buildFile) {\n    if ((buildFile == null)) {\n      return;\n    }\n    final boolean android = this.isAndroidGradleModule(module);\n    GrClosableBlock _createOrGetMethodCall = this.createOrGetMethodCall(buildFile, \"buildscript\");\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"classpath \\'org.xtend:xtend\");\n    String _xifexpression = null;\n    if (android) {\n      _xifexpression = \"-android\";\n    }\n    _builder.append(_xifexpression, \"\");\n    _builder.append(\"-gradle-plugin:\");\n    _builder.append(this.xtendGradlePluginVersion, \"\");\n    _builder.append(\"\\' \");\n    this.addDependency(_createOrGetMethodCall, _builder.toString());\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"apply plugin: \\'org.xtend.xtend\");\n    String _xifexpression_1 = null;\n    if (android) {\n      _xifexpression_1 = \"-android\";\n    }\n    _builder_1.append(_xifexpression_1, \"\");\n    _builder_1.append(\"\\' \");\n    this.createStatementIfNotExists(buildFile, _builder_1.toString());\n  }","id":3132,"modified_method":"public void setupGradleBuild(final Module module, final GroovyFile buildFile) {\n    if ((buildFile == null)) {\n      return;\n    }\n    final boolean android = this.isAndroidGradleModule(module);\n    final GrClosableBlock buildScript = this.createOrGetMethodCall(buildFile, \"buildscript\");\n    GrClosableBlock _createOrGetMethodCall = this.createOrGetMethodCall(buildScript, \"repositories\");\n    this.createStatementIfNotExists(_createOrGetMethodCall, \"jcenter()\");\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"classpath \\'org.xtend:xtend\");\n    String _xifexpression = null;\n    if (android) {\n      _xifexpression = \"-android\";\n    }\n    _builder.append(_xifexpression, \"\");\n    _builder.append(\"-gradle-plugin:\");\n    _builder.append(this.xtendGradlePluginVersion, \"\");\n    _builder.append(\"\\' \");\n    this.addDependency(buildScript, _builder.toString());\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"apply plugin: \\'org.xtend.xtend\");\n    String _xifexpression_1 = null;\n    if (android) {\n      _xifexpression_1 = \"-android\";\n    }\n    _builder_1.append(_xifexpression_1, \"\");\n    _builder_1.append(\"\\' \");\n    this.createStatementIfNotExists(buildFile, _builder_1.toString());\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider, final BuildScriptDataBuilder script) {\n    MavenId _xtendLibMavenId = XtendLibraryManager.xtendLibMavenId();\n    String _version = _xtendLibMavenId.getVersion();\n    boolean _endsWith = false;\n    if (_version!=null) {\n      _endsWith=_version.endsWith(\"-SNAPSHOT\");\n    }\n    final boolean snapshot = _endsWith;\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript {\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"repositories {\");\n    _builder.newLine();\n    {\n      if (snapshot) {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"maven {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"url \\'http://oss.sonatype.org/content/repositories/snapshots\\'\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t    \");\n    _builder.append(\"jcenter()\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"dependencies {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:\");\n    _builder.append(this.gradleUtility.xtendGradlePluginVersion, \"        \");\n    _builder.append(\"\\'\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    script.addOther(_builder.toString());\n    BuildScriptDataBuilder _addPluginDefinition = script.addPluginDefinition(\"apply plugin: \\'java\\'\");\n    BuildScriptDataBuilder _addPluginDefinition_1 = _addPluginDefinition.addPluginDefinition(\"apply plugin: \\'org.xtend.xtend\\'\");\n    BuildScriptDataBuilder _addPropertyDefinition = _addPluginDefinition_1.addPropertyDefinition(\"sourceCompatibility = 1.5\");\n    BuildScriptDataBuilder _addRepositoriesDefinition = _addPropertyDefinition.addRepositoriesDefinition(\"jcenter()\");\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"compile \\'\");\n    MavenId _xtendLibMavenId_1 = XtendLibraryManager.xtendLibMavenId();\n    String _key = _xtendLibMavenId_1.getKey();\n    _builder_1.append(_key, \"\");\n    _builder_1.append(\"\\' \");\n    _addRepositoriesDefinition.addDependencyNotation(_builder_1.toString());\n    if (snapshot) {\n      StringConcatenation _builder_2 = new StringConcatenation();\n      _builder_2.append(\"maven {\");\n      _builder_2.newLine();\n      _builder_2.append(\"\\t\");\n      _builder_2.append(\"url \\'http://oss.sonatype.org/content/repositories/snapshots\\'\");\n      _builder_2.newLine();\n      _builder_2.append(\"}\");\n      script.addRepositoriesDefinition(_builder_2.toString());\n    }\n    final XtendSupportConfigurable xtendSupport = this.xtendSupportConfigurableProvider.get();\n    final XtendFacetConfiguration conf = xtendSupport.createOrGetXtendFacetConf(module);\n    XbaseGeneratorConfigurationState _state = conf.getState();\n    xtendSupport.presetGradleOutputDirectories(_state, module);\n    XbaseGeneratorConfigurationState _state_1 = conf.getState();\n    xtendSupport.createOutputFolders(rootModel, _state_1);\n  }","id":3133,"modified_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider, final BuildScriptDataBuilder script) {\n    MavenId _xtendLibMavenId = XtendLibraryManager.xtendLibMavenId();\n    String _version = _xtendLibMavenId.getVersion();\n    boolean _endsWith = false;\n    if (_version!=null) {\n      _endsWith=_version.endsWith(\"-SNAPSHOT\");\n    }\n    final boolean snapshot = _endsWith;\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"buildscript {\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"repositories {\");\n    _builder.newLine();\n    {\n      if (snapshot) {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"maven {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"url \\'http://oss.sonatype.org/content/repositories/snapshots\\'\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t    \");\n    _builder.append(\"jcenter()\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"dependencies {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"classpath \\'org.xtend:xtend-gradle-plugin:\");\n    _builder.append(this.gradleUtility.xtendGradlePluginVersion, \"        \");\n    _builder.append(\"\\'\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    script.addOther(_builder.toString());\n    BuildScriptDataBuilder _addPluginDefinition = script.addPluginDefinition(\"apply plugin: \\'java\\'\");\n    BuildScriptDataBuilder _addPluginDefinition_1 = _addPluginDefinition.addPluginDefinition(\"apply plugin: \\'org.xtend.xtend\\'\");\n    BuildScriptDataBuilder _addPropertyDefinition = _addPluginDefinition_1.addPropertyDefinition(\"sourceCompatibility = 1.5\");\n    BuildScriptDataBuilder _addRepositoriesDefinition = _addPropertyDefinition.addRepositoriesDefinition(\"jcenter()\");\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"compile \\'\");\n    MavenId _xtendLibMavenId_1 = XtendLibraryManager.xtendLibMavenId();\n    String _key = _xtendLibMavenId_1.getKey();\n    _builder_1.append(_key, \"\");\n    _builder_1.append(\"\\' \");\n    _addRepositoriesDefinition.addDependencyNotation(_builder_1.toString());\n    if (snapshot) {\n      StringConcatenation _builder_2 = new StringConcatenation();\n      _builder_2.append(\"maven {\");\n      _builder_2.newLine();\n      _builder_2.append(\"\\t\");\n      _builder_2.append(\"url \\'http://oss.sonatype.org/content/repositories/snapshots\\'\");\n      _builder_2.newLine();\n      _builder_2.append(\"}\");\n      script.addRepositoriesDefinition(_builder_2.toString());\n    }\n    final XtendSupportConfigurable xtendSupport = this.xtendSupportConfigurableProvider.get();\n    Module _module = rootModel.getModule();\n    final XtendFacetConfiguration conf = xtendSupport.createOrGetXtendFacetConf(_module);\n    XbaseGeneratorConfigurationState _state = conf.getState();\n    xtendSupport.presetGradleOutputDirectories(_state, rootModel);\n    XbaseGeneratorConfigurationState _state_1 = conf.getState();\n    xtendSupport.createOutputFolders(rootModel, _state_1);\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void addAsSourceFolder(final ModifiableRootModel rootModel, final VirtualFile xtendGenMain, final JavaSourceRootType type) {\n    VirtualFile[] _contentRoots = rootModel.getContentRoots();\n    final Function1<VirtualFile, Boolean> _function = new Function1<VirtualFile, Boolean>() {\n      @Override\n      public Boolean apply(final VirtualFile it) {\n        return Boolean.valueOf(VfsUtil.isAncestor(it, xtendGenMain, true));\n      }\n    };\n    final VirtualFile contentRootFile = IterableExtensions.<VirtualFile>findFirst(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots)), _function);\n    ContentEntry[] _contentEntries = rootModel.getContentEntries();\n    final Function1<ContentEntry, Boolean> _function_1 = new Function1<ContentEntry, Boolean>() {\n      @Override\n      public Boolean apply(final ContentEntry it) {\n        VirtualFile _file = it.getFile();\n        return Boolean.valueOf(Objects.equal(_file, contentRootFile));\n      }\n    };\n    final ContentEntry contentRoot = IterableExtensions.<ContentEntry>findFirst(((Iterable<ContentEntry>)Conversions.doWrapArray(_contentEntries)), _function_1);\n    JpsJavaExtensionService _instance = JpsJavaExtensionService.getInstance();\n    final JavaSourceRootProperties properties = _instance.createSourceRootProperties(\"\", true);\n    if (contentRoot!=null) {\n      contentRoot.<JavaSourceRootProperties>addSourceFolder(xtendGenMain, type, properties);\n    }\n  }","id":3134,"modified_method":"public void addAsSourceFolder(final ModifiableRootModel rootModel, final VirtualFile xtendGenMain, final JavaSourceRootType type) {\n    ContentEntry[] _contentEntries = rootModel.getContentEntries();\n    final Function1<ContentEntry, Boolean> _function = new Function1<ContentEntry, Boolean>() {\n      @Override\n      public Boolean apply(final ContentEntry it) {\n        VirtualFile _file = it.getFile();\n        return Boolean.valueOf(VfsUtil.isAncestor(_file, xtendGenMain, true));\n      }\n    };\n    final ContentEntry contentRoot = IterableExtensions.<ContentEntry>findFirst(((Iterable<ContentEntry>)Conversions.doWrapArray(_contentEntries)), _function);\n    if ((contentRoot != null)) {\n      ExcludeFolder[] _excludeFolders = contentRoot.getExcludeFolders();\n      final Function1<ExcludeFolder, Boolean> _function_1 = new Function1<ExcludeFolder, Boolean>() {\n        @Override\n        public Boolean apply(final ExcludeFolder it) {\n          VirtualFile _file = it.getFile();\n          return Boolean.valueOf(VfsUtil.isAncestor(_file, xtendGenMain, true));\n        }\n      };\n      final ExcludeFolder excludedParent = IterableExtensions.<ExcludeFolder>findFirst(((Iterable<ExcludeFolder>)Conversions.doWrapArray(_excludeFolders)), _function_1);\n      if ((excludedParent != null)) {\n        contentRoot.removeExcludeFolder(excludedParent);\n      }\n      JpsJavaExtensionService _instance = JpsJavaExtensionService.getInstance();\n      final JavaSourceRootProperties properties = _instance.createSourceRootProperties(\"\", true);\n      contentRoot.<JavaSourceRootProperties>addSourceFolder(xtendGenMain, type, properties);\n    }\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider) {\n    final XtendFacetConfiguration conf = this.createOrGetXtendFacetConf(module);\n    this.setupOutputConfiguration(rootModel, conf);\n    XbaseGeneratorConfigurationState _state = conf.getState();\n    this.createOutputFolders(rootModel, _state);\n    this.xtendLibManager.ensureXtendLibAvailable(rootModel);\n  }","id":3135,"modified_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider) {\n    Module _module = rootModel.getModule();\n    final XtendFacetConfiguration conf = this.createOrGetXtendFacetConf(_module);\n    this.setupOutputConfiguration(rootModel, conf);\n    XbaseGeneratorConfigurationState _state = conf.getState();\n    this.createOutputFolders(rootModel, _state);\n    this.xtendLibManager.ensureXtendLibAvailable(rootModel);\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void presetGradleOutputDirectories(final XbaseGeneratorConfigurationState state, final Module module) {\n    ModuleRootManager _instance = ModuleRootManager.getInstance(module);\n    VirtualFile[] _contentRoots = _instance.getContentRoots();\n    VirtualFile _head = IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots)));\n    final String parentPath = _head.getPath();\n    boolean _isAndroidGradleModule = this._gradleBuildFileUtility.isAndroidGradleModule(module);\n    if (_isAndroidGradleModule) {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(parentPath, \"\");\n      _builder.append(\"/build/generated/source/xtend/debug\");\n      state.setOutputDirectory(_builder.toString());\n      StringConcatenation _builder_1 = new StringConcatenation();\n      _builder_1.append(parentPath, \"\");\n      _builder_1.append(\"/build/generated/source/xtend/androidTest/debug\");\n      state.setTestOutputDirectory(_builder_1.toString());\n    } else {\n      StringConcatenation _builder_2 = new StringConcatenation();\n      _builder_2.append(parentPath, \"\");\n      _builder_2.append(\"/build/xtend-gen/main\");\n      state.setOutputDirectory(_builder_2.toString());\n      StringConcatenation _builder_3 = new StringConcatenation();\n      _builder_3.append(parentPath, \"\");\n      _builder_3.append(\"/build/xtend-gen/test\");\n      state.setTestOutputDirectory(_builder_3.toString());\n    }\n  }","id":3136,"modified_method":"public void presetGradleOutputDirectories(final XbaseGeneratorConfigurationState state, final ModifiableRootModel rootModel) {\n    VirtualFile[] _contentRoots = rootModel.getContentRoots();\n    VirtualFile _head = IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots)));\n    final String parentPath = _head.getPath();\n    Module _module = rootModel.getModule();\n    boolean _isAndroidGradleModule = this._gradleBuildFileUtility.isAndroidGradleModule(_module);\n    if (_isAndroidGradleModule) {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(parentPath, \"\");\n      _builder.append(\"/build/generated/source/xtend/debug\");\n      state.setOutputDirectory(_builder.toString());\n      StringConcatenation _builder_1 = new StringConcatenation();\n      _builder_1.append(parentPath, \"\");\n      _builder_1.append(\"/build/generated/source/xtend/androidTest/debug\");\n      state.setTestOutputDirectory(_builder_1.toString());\n    } else {\n      StringConcatenation _builder_2 = new StringConcatenation();\n      _builder_2.append(parentPath, \"\");\n      _builder_2.append(\"/build/xtend-gen/main\");\n      state.setOutputDirectory(_builder_2.toString());\n      StringConcatenation _builder_3 = new StringConcatenation();\n      _builder_3.append(parentPath, \"\");\n      _builder_3.append(\"/build/xtend-gen/test\");\n      state.setTestOutputDirectory(_builder_3.toString());\n    }\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setupOutputConfiguration(final ModifiableRootModel rootModel, final XtendFacetConfiguration conf) {\n    final Module module = rootModel.getModule();\n    final GroovyFile buildFile = this._gradleBuildFileUtility.locateBuildFile(module);\n    boolean _and = false;\n    boolean _isGradleedModule = this._gradleBuildFileUtility.isGradleedModule(module);\n    if (!_isGradleedModule) {\n      _and = false;\n    } else {\n      _and = (buildFile != null);\n    }\n    if (_and) {\n      Project _project = module.getProject();\n      List<PsiFile> _newImmutableList = CollectionLiterals.<PsiFile>newImmutableList(buildFile);\n      new WriteCommandAction.Simple(_project, \"Gradle: Xtend Configuration\", ((PsiFile[])Conversions.unwrapArray(_newImmutableList, PsiFile.class))) {\n        @Override\n        protected void run() throws Throwable {\n          XtendSupportConfigurable.this._gradleBuildFileUtility.setupGradleBuild(module, buildFile);\n        }\n      }.execute();\n      XbaseGeneratorConfigurationState _state = conf.getState();\n      this.presetGradleOutputDirectories(_state, module);\n    } else {\n      XbaseGeneratorConfigurationState _state_1 = conf.getState();\n      this.presetPlainJavaOutputDirectories(_state_1, rootModel);\n    }\n  }","id":3137,"modified_method":"public void setupOutputConfiguration(final ModifiableRootModel rootModel, final XtendFacetConfiguration conf) {\n    final Module module = rootModel.getModule();\n    final GroovyFile buildFile = this._gradleBuildFileUtility.locateBuildFile(module);\n    boolean _and = false;\n    boolean _isGradleedModule = this._gradleBuildFileUtility.isGradleedModule(module);\n    if (!_isGradleedModule) {\n      _and = false;\n    } else {\n      _and = (buildFile != null);\n    }\n    if (_and) {\n      Project _project = module.getProject();\n      List<PsiFile> _newImmutableList = CollectionLiterals.<PsiFile>newImmutableList(buildFile);\n      new WriteCommandAction.Simple(_project, \"Gradle: Xtend Configuration\", ((PsiFile[])Conversions.unwrapArray(_newImmutableList, PsiFile.class))) {\n        @Override\n        protected void run() throws Throwable {\n          XtendSupportConfigurable.this._gradleBuildFileUtility.setupGradleBuild(module, buildFile);\n        }\n      }.execute();\n      XbaseGeneratorConfigurationState _state = conf.getState();\n      this.presetGradleOutputDirectories(_state, rootModel);\n    } else {\n      XbaseGeneratorConfigurationState _state_1 = conf.getState();\n      this.presetPlainJavaOutputDirectories(_state_1, rootModel);\n    }\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"private VirtualFile findBestContentRoot(final ModifiableRootModel model) {\n    final Module module = model.getModule();\n    Project _project = module.getProject();\n    VirtualFile contentRoot = _project.getBaseDir();\n    VirtualFile _moduleFile = module.getModuleFile();\n    boolean _tripleNotEquals = (_moduleFile != null);\n    if (_tripleNotEquals) {\n      Project _project_1 = module.getProject();\n      ProjectRootManager _instance = ProjectRootManager.getInstance(_project_1);\n      ProjectFileIndex _fileIndex = _instance.getFileIndex();\n      VirtualFile _moduleFile_1 = module.getModuleFile();\n      final VirtualFile moduleFileRoot = _fileIndex.getContentRootForFile(_moduleFile_1);\n      if ((moduleFileRoot != null)) {\n        return contentRoot;\n      }\n    }\n    VirtualFile[] _contentRoots = model.getContentRoots();\n    boolean _isEmpty = ((List<VirtualFile>)Conversions.doWrapArray(_contentRoots)).isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      VirtualFile[] _contentRoots_1 = model.getContentRoots();\n      VirtualFile _head = IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots_1)));\n      contentRoot = _head;\n    }\n    return contentRoot;\n  }","id":3138,"modified_method":"/**\n   * For single contentRoot use it\n   * \tFor multiple use first that not contains the module config file\n   * \tFor any use project baseDir\n   */\n  private VirtualFile findBestContentRoot(final ModifiableRootModel model) {\n    final Module module = model.getModule();\n    final VirtualFile[] roots = model.getContentRoots();\n    int _size = ((List<VirtualFile>)Conversions.doWrapArray(roots)).size();\n    boolean _equals = (_size == 1);\n    if (_equals) {\n      return roots[0];\n    } else {\n      int _size_1 = ((List<VirtualFile>)Conversions.doWrapArray(roots)).size();\n      boolean _greaterThan = (_size_1 > 1);\n      if (_greaterThan) {\n        VirtualFile _moduleFile = module.getModuleFile();\n        boolean _tripleNotEquals = (_moduleFile != null);\n        if (_tripleNotEquals) {\n          final Function1<VirtualFile, Boolean> _function = new Function1<VirtualFile, Boolean>() {\n            @Override\n            public Boolean apply(final VirtualFile it) {\n              VirtualFile _moduleFile = module.getModuleFile();\n              boolean _isAncestor = VfsUtil.isAncestor(it, _moduleFile, true);\n              return Boolean.valueOf((!_isAncestor));\n            }\n          };\n          return IterableExtensions.<VirtualFile>findFirst(((Iterable<VirtualFile>)Conversions.doWrapArray(roots)), _function);\n        } else {\n          return IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(roots)));\n        }\n      }\n    }\n    Project _project = model.getProject();\n    return _project.getBaseDir();\n  }","commit_id":"4baf8003607e9fe463b0d0aede8851b266609d56","url":"https://github.com/eclipse/xtext"},{"original_method":"@Before\n    @Override\n    public void prepare() throws Exception {\n        NodeStore source = getSourceContainer().open();\n        try {\n            initContent(source);\n        } finally {\n            getSourceContainer().close();\n        }\n\n        String[] args = getArgs();\n        log.info(\"oak2oak {}\", Joiner.on(' ').join(args));\n        try {\n            OptionSet options = OptionParserFactory.create().parse(args);\n            MigrationCliArguments cliArgs = new MigrationCliArguments(options);\n            OakUpgrade.migrate(cliArgs);\n            assertEquals(blobMigrationCase, cliArgs.getStoreArguments().getDatastores().getBlobMigrationCase());\n        } catch(CliArgumentException e) {\n            if (blobMigrationCase == DatastoreArguments.BlobMigrationCase.UNSUPPORTED) {\n                return;\n            } else {\n                throw e;\n            }\n        }\n        createSession();\n    }","id":3139,"modified_method":"@Before\n    @Override\n    public void prepare() throws Exception {\n        NodeStore source = getSourceContainer().open();\n        try {\n            initContent(source);\n        } finally {\n            getSourceContainer().close();\n        }\n\n        String[] args = getArgs();\n        log.info(\"oak2oak {}\", Joiner.on(' ').join(args));\n        try {\n            MigrationCliArguments cliArgs = new MigrationCliArguments(OptionParserFactory.create().parse(args));\n            MigrationOptions options = new MigrationOptions(cliArgs);\n            StoreArguments stores = new StoreArguments(options, cliArgs.getArguments());\n            DatastoreArguments datastores = new DatastoreArguments(options, stores, stores.srcUsesEmbeddedDatastore());\n            OakUpgrade.migrate(options, stores, datastores);\n            assertEquals(blobMigrationCase, datastores.getBlobMigrationCase());\n        } catch(CliArgumentException e) {\n            if (blobMigrationCase == DatastoreArguments.BlobMigrationCase.UNSUPPORTED) {\n                return;\n            } else {\n                throw e;\n            }\n        }\n        createSession();\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public DatastoreArguments(MigrationCliArguments parser, StoreArguments storeArguments) throws CliArgumentException {\n        this.storeArguments = storeArguments;\n        this.parser = parser;\n\n        try {\n            blobMigrationCase = discoverBlobMigrationCase();\n        } catch (IOException e) {\n            log.error(\"Can't figure out the right blob migration path\", e);\n            throw new CliArgumentException(1);\n        }\n\n        if (blobMigrationCase == BlobMigrationCase.UNSUPPORTED) {\n            throw new CliArgumentException(\"This combination of data- and node-stores is not supported\", 1);\n        }\n\n        try {\n            definedSrcBlob = isSrcBlobStoreDefined() ? getDefinedSrcBlobStore() : null;\n            definedDstBlob = isDstBlobStoreDefined() ? getDefinedDstBlobStore() : null;\n        } catch(IOException e) {\n            log.error(\"Can't read the blob configuration\", e);\n            throw new CliArgumentException(1);\n        }\n\n        log.info(blobMigrationCase.getDescription(this));\n    }","id":3140,"modified_method":"public DatastoreArguments(MigrationOptions options, StoreArguments storeArguments, boolean srcEmbedded) throws CliArgumentException {\n        this.storeArguments = storeArguments;\n        this.options = options;\n        this.srcEmbedded = srcEmbedded;\n\n        try {\n            blobMigrationCase = discoverBlobMigrationCase();\n        } catch (IOException e) {\n            log.error(\"Can't figure out the right blob migration path\", e);\n            throw new CliArgumentException(1);\n        }\n\n        if (blobMigrationCase == BlobMigrationCase.UNSUPPORTED) {\n            throw new CliArgumentException(\"This combination of data- and node-stores is not supported\", 1);\n        }\n\n        try {\n            definedSrcBlob = options.isSrcBlobStoreDefined() ? getDefinedSrcBlobStore() : null;\n            definedDstBlob = options.isDstBlobStoreDefined() ? getDefinedDstBlobStore() : null;\n        } catch(IOException e) {\n            log.error(\"Can't read the blob configuration\", e);\n            throw new CliArgumentException(1);\n        }\n\n        log.info(blobMigrationCase.getDescription(this));\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public BlobStoreFactory getSrcBlobStore() throws IOException {\n        BlobStoreFactory result;\n        if (isSrcBlobStoreDefined()) {\n            result = definedSrcBlob;\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES) {\n            result = new MissingBlobStoreFactory();\n        } else {\n            result = new DummyBlobStoreFactory(); // embedded\n        }\n        log.info(\"Source blob store: {}\", result);\n        return result;\n    }","id":3141,"modified_method":"public BlobStoreFactory getSrcBlobStore() throws IOException {\n        BlobStoreFactory result;\n        if (options.isSrcBlobStoreDefined()) {\n            result = definedSrcBlob;\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES) {\n            result = new MissingBlobStoreFactory();\n        } else {\n            result = new DummyBlobStoreFactory(); // embedded\n        }\n        log.info(\"Source blob store: {}\", result);\n        return result;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public BlobStoreFactory getDstBlobStore(BlobStore srcBlobStore) throws IOException {\n        BlobStoreFactory result;\n        if (isDstBlobStoreDefined()) {\n            result = definedDstBlob;\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES && (isSrcBlobStoreDefined() || storeArguments.getSrcType() == JCR2_DIR_XML)) {\n            result = new ConstantBlobStoreFactory(srcBlobStore);\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES) {\n            result = new MissingBlobStoreFactory();\n        } else {\n            result = new DummyBlobStoreFactory(); // embedded\n        }\n\n        log.info(\"Destination blob store: {}\", result);\n        return result;\n    }","id":3142,"modified_method":"public BlobStoreFactory getDstBlobStore(BlobStore srcBlobStore) throws IOException {\n        BlobStoreFactory result;\n        if (options.isDstBlobStoreDefined()) {\n            result = definedDstBlob;\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES && (options.isSrcBlobStoreDefined() || storeArguments.getSrcType() == JCR2_DIR_XML)) {\n            result = new ConstantBlobStoreFactory(srcBlobStore);\n        } else if (blobMigrationCase == BlobMigrationCase.COPY_REFERENCES) {\n            result = new MissingBlobStoreFactory();\n        } else {\n            result = new DummyBlobStoreFactory(); // embedded\n        }\n\n        log.info(\"Destination blob store: {}\", result);\n        return result;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private BlobMigrationCase discoverBlobMigrationCase() throws IOException {\n        boolean srcDefined = isSrcBlobStoreDefined() || storeArguments.getSrcType() == JCR2_DIR_XML;\n        boolean dstDefined = isDstBlobStoreDefined();\n        boolean srcEmbedded = !storeArguments.srcHasExternalBlobReferences();\n        boolean copyBinaries = parser.hasOption(COPY_BINARIES);\n\n        boolean srcSegment = storeArguments.getSrcType().isSegment();\n        boolean dstSegment = storeArguments.getDstType().isSegment();\n\n        // default case, no datastore-related arguments given, but blobs are stored externally\n        if (!srcDefined && !dstDefined && !srcEmbedded && !copyBinaries) {\n            if (srcSegment && !dstSegment) { // segment -> document is not supported for this case\n                return BlobMigrationCase.UNSUPPORTED;\n            } else { // we try to copy references using MissingBlobStore\n                return BlobMigrationCase.COPY_REFERENCES;\n            }\n            // can't copy binaries if they are stored externally and we don't know where\n        } else if (!srcDefined && !dstDefined && !srcEmbedded && copyBinaries) {\n            return BlobMigrationCase.UNSUPPORTED;\n            // can't copy binaries if they are stored externally and we don't know where\n            // (even if the destination datastore is defined)\n        } else if (!srcDefined && !srcEmbedded && dstDefined) {\n            return BlobMigrationCase.UNSUPPORTED;\n            // source is embedded and no destination given\n        } else if (!srcDefined && srcEmbedded && !dstDefined) {\n            return BlobMigrationCase.EMBEDDED_TO_EMBEDDED;\n            // source is embedded and the destination is given\n        } else if (!srcDefined && srcEmbedded && dstDefined) {\n            return BlobMigrationCase.EMBEDDED_TO_EXTERNAL;\n            // source is given, no destination, but also no --copy-binaries -> copy references\n        } else if (srcDefined && !dstDefined && !copyBinaries) {\n            return BlobMigrationCase.COPY_REFERENCES;\n            // source is given, no destination, but --copy-binaries -> copy to embedded\n        } else if (srcDefined && !dstDefined && copyBinaries) {\n            return BlobMigrationCase.EXTERNAL_TO_EMBEDDED;\n            // source and destination is given\n        } else if (srcDefined && dstDefined) {\n            return BlobMigrationCase.EXTERNAL_TO_EXTERNAL;\n        }\n        return BlobMigrationCase.UNSUPPORTED;\n    }","id":3143,"modified_method":"private BlobMigrationCase discoverBlobMigrationCase() throws IOException {\n        boolean srcDefined = options.isSrcBlobStoreDefined() || storeArguments.getSrcType() == JCR2_DIR_XML;\n        boolean dstDefined = options.isDstBlobStoreDefined();\n        boolean copyBinaries = options.isCopyBinaries();\n\n        boolean srcSegment = storeArguments.getSrcType().isSegment();\n        boolean dstSegment = storeArguments.getDstType().isSegment();\n\n        // default case, no datastore-related arguments given, but blobs are stored externally\n        if (!srcDefined && !dstDefined && !srcEmbedded && !copyBinaries) {\n            if (srcSegment && !dstSegment) { // segment -> document is not supported for this case\n                return BlobMigrationCase.UNSUPPORTED;\n            } else { // we try to copy references using MissingBlobStore\n                return BlobMigrationCase.COPY_REFERENCES;\n            }\n            // can't copy binaries if they are stored externally and we don't know where\n        } else if (!srcDefined && !dstDefined && !srcEmbedded && copyBinaries) {\n            return BlobMigrationCase.UNSUPPORTED;\n            // can't copy binaries if they are stored externally and we don't know where\n            // (even if the destination datastore is defined)\n        } else if (!srcDefined && !srcEmbedded && dstDefined) {\n            return BlobMigrationCase.UNSUPPORTED;\n            // source is embedded and no destination given\n        } else if (!srcDefined && srcEmbedded && !dstDefined) {\n            return BlobMigrationCase.EMBEDDED_TO_EMBEDDED;\n            // source is embedded and the destination is given\n        } else if (!srcDefined && srcEmbedded && dstDefined) {\n            return BlobMigrationCase.EMBEDDED_TO_EXTERNAL;\n            // source is given, no destination, but also no --copy-binaries -> copy references\n        } else if (srcDefined && !dstDefined && !copyBinaries) {\n            return BlobMigrationCase.COPY_REFERENCES;\n            // source is given, no destination, but --copy-binaries -> copy to embedded\n        } else if (srcDefined && !dstDefined && copyBinaries) {\n            return BlobMigrationCase.EXTERNAL_TO_EMBEDDED;\n            // source and destination is given\n        } else if (srcDefined && dstDefined) {\n            return BlobMigrationCase.EXTERNAL_TO_EXTERNAL;\n        }\n        return BlobMigrationCase.UNSUPPORTED;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private BlobStoreFactory getDefinedDstBlobStore() throws IOException {\n        if (parser.hasOption(DST_FBS)) {\n            return new FileBlobStoreFactory(parser.getOption(DST_FBS));\n        } else if (parser.hasOption(DST_S3_CONFIG) && parser.hasOption(DST_S3)) {\n            return new S3DataStoreFactory(parser.getOption(DST_S3_CONFIG), parser.getOption(DST_S3), false);\n        } else if (parser.hasOption(DST_FDS)) {\n            return new FileDataStoreFactory(parser.getOption(DST_FDS), false);\n        } else {\n            return null;\n        }\n    }","id":3144,"modified_method":"private BlobStoreFactory getDefinedDstBlobStore() throws IOException {\n        if (options.isDstFbs()) {\n            return new FileBlobStoreFactory(options.getDstFbs());\n        } else if (options.isDstS3()) {\n            return new S3DataStoreFactory(options.getDstS3Config(), options.getDstS3(), false);\n        } else if (options.isDstFds()) {\n            return new FileDataStoreFactory(options.getDstFds(), false);\n        } else {\n            return null;\n        }\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private BlobStoreFactory getDefinedSrcBlobStore() throws IOException {\n        boolean ignoreMissingBinaries = parser.hasOption(IGNORE_MISSING_BINARIES);\n        if (parser.hasOption(SRC_FBS)) {\n            return new FileBlobStoreFactory(parser.getOption(SRC_FBS));\n        } else if (parser.hasOption(SRC_S3_CONFIG) && parser.hasOption(SRC_S3)) {\n            return new S3DataStoreFactory(parser.getOption(SRC_S3_CONFIG), parser.getOption(SRC_S3), ignoreMissingBinaries);\n        } else if (parser.hasOption(SRC_FDS)) {\n            return new FileDataStoreFactory(parser.getOption(SRC_FDS), ignoreMissingBinaries);\n        } else {\n            return null;\n        }\n    }","id":3145,"modified_method":"private BlobStoreFactory getDefinedSrcBlobStore() throws IOException {\n        boolean ignoreMissingBinaries = options.isIgnoreMissingBinaries();\n        if (options.isSrcFbs()) {\n            return new FileBlobStoreFactory(options.getSrcFbs());\n        } else if (options.isSrcS3()) {\n            return new S3DataStoreFactory(options.getSrcS3Config(), options.getSrcS3(), ignoreMissingBinaries);\n        } else if (options.isSrcFds()) {\n            return new FileDataStoreFactory(options.getSrcFds(), ignoreMissingBinaries);\n        } else {\n            return null;\n        }\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MigrationCliArguments(OptionSet options) throws CliArgumentException {\n        this.options = options;\n        arguments = getNonOptionArguments();\n        migrationOptions = new MigrationOptions(this);\n        storeArguments = new StoreArguments(this);\n    }","id":3146,"modified_method":"public MigrationCliArguments(OptionSet options) throws CliArgumentException {\n        this.options = options;\n        this.arguments = getNonOptionArguments();\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"List<String> getArguments() {\n        return arguments;\n    }","id":3147,"modified_method":"public List<String> getArguments() {\n        return arguments;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected RepositoryUpgrade createUpgrade(RepositoryContext source, NodeStore dstStore) {\n        RepositoryUpgrade upgrade = new RepositoryUpgrade(source, dstStore);\n        upgrade.setCopyBinariesByReference(stores.getDatastores().getBlobMigrationCase() == DatastoreArguments.BlobMigrationCase.COPY_REFERENCES);\n        upgrade.setCopyVersions(options.getCopyVersions());\n        upgrade.setCopyOrphanedVersions(options.getCopyOrphanedVersions());\n        if (options.getIncludePaths() != null) {\n            upgrade.setIncludes(options.getIncludePaths());\n        }\n        if (options.getExcludePaths() != null) {\n            upgrade.setExcludes(options.getExcludePaths());\n        }\n        if (options.getMergePaths() != null) {\n            upgrade.setMerges(options.getMergePaths());\n        }\n        upgrade.setFilterLongNames(!stores.getDstType().isSupportLongNames());\n        upgrade.setCheckLongNames(!options.isSkipNameCheck() && !stores.getDstType().isSupportLongNames());\n        upgrade.setSkipOnError(!options.isFailOnError());\n        upgrade.setEarlyShutdown(options.isEarlyShutdown());\n        upgrade.setSkipInitialization(options.isSkipInitialization());\n        ServiceLoader<CommitHook> loader = ServiceLoader.load(CommitHook.class);\n        Iterator<CommitHook> iterator = loader.iterator();\n        ImmutableList.Builder<CommitHook> builder = ImmutableList.<CommitHook> builder().addAll(iterator);\n        upgrade.setCustomCommitHooks(builder.build());\n        return upgrade;\n    }","id":3148,"modified_method":"protected RepositoryUpgrade createUpgrade(RepositoryContext source, NodeStore dstStore) {\n        RepositoryUpgrade upgrade = new RepositoryUpgrade(source, dstStore);\n        upgrade.setCopyBinariesByReference(datastores.getBlobMigrationCase() == DatastoreArguments.BlobMigrationCase.COPY_REFERENCES);\n        upgrade.setCopyVersions(options.getCopyVersions());\n        upgrade.setCopyOrphanedVersions(options.getCopyOrphanedVersions());\n        if (options.getIncludePaths() != null) {\n            upgrade.setIncludes(options.getIncludePaths());\n        }\n        if (options.getExcludePaths() != null) {\n            upgrade.setExcludes(options.getExcludePaths());\n        }\n        if (options.getMergePaths() != null) {\n            upgrade.setMerges(options.getMergePaths());\n        }\n        upgrade.setFilterLongNames(!stores.getDstType().isSupportLongNames());\n        upgrade.setCheckLongNames(!options.isSkipNameCheck() && !stores.getDstType().isSupportLongNames());\n        upgrade.setSkipOnError(!options.isFailOnError());\n        upgrade.setEarlyShutdown(options.isEarlyShutdown());\n        upgrade.setSkipInitialization(options.isSkipInitialization());\n        ServiceLoader<CommitHook> loader = ServiceLoader.load(CommitHook.class);\n        Iterator<CommitHook> iterator = loader.iterator();\n        ImmutableList.Builder<CommitHook> builder = ImmutableList.<CommitHook> builder().addAll(iterator);\n        upgrade.setCustomCommitHooks(builder.build());\n        return upgrade;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MigrationFactory(MigrationOptions options, StoreArguments stores, Closer closer) {\n        this.options = options;\n        this.stores = stores;\n        this.closer = closer;\n    }","id":3149,"modified_method":"public MigrationFactory(MigrationOptions options, StoreArguments stores, DatastoreArguments datastores, Closer closer) {\n        this.options = options;\n        this.stores = stores;\n        this.datastores = datastores;\n        this.closer = closer;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected NodeStore createTarget(Closer closer, BlobStore srcBlobStore) throws IOException {\n        BlobStore dstBlobStore = stores.getDatastores().getDstBlobStore(srcBlobStore).create(closer);\n        NodeStore dstStore = stores.getDstStore().create(dstBlobStore, closer);\n        return dstStore;\n    }","id":3150,"modified_method":"protected NodeStore createTarget(Closer closer, BlobStore srcBlobStore) throws IOException {\n        BlobStore dstBlobStore = datastores.getDstBlobStore(srcBlobStore).create(closer);\n        NodeStore dstStore = stores.getDstStore().create(dstBlobStore, closer);\n        return dstStore;\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public RepositorySidegrade createSidegrade() throws IOException {\n        BlobStore srcBlobStore = stores.getDatastores().getSrcBlobStore().create(closer);\n        NodeStore srcStore = stores.getSrcStore().create(srcBlobStore, closer);\n        NodeStore dstStore = createTarget(closer, srcBlobStore);\n        return createSidegrade(srcStore, dstStore);\n    }","id":3151,"modified_method":"public RepositorySidegrade createSidegrade() throws IOException, CliArgumentException {\n        BlobStore srcBlobStore = datastores.getSrcBlobStore().create(closer);\n        NodeStore srcStore = stores.getSrcStore().create(srcBlobStore, closer);\n        NodeStore dstStore = createTarget(closer, srcBlobStore);\n        return createSidegrade(srcStore, dstStore);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void logOptions() {\n        if (disableMmap) {\n            log.info(\"Disabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","id":3152,"modified_method":"public void logOptions() {\n        if (disableMmap) {\n            log.info(\"Disabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.disableMmap = args.hasOption(OptionParserFactory.DISABLE_MMAP);\n        this.copyBinaries = args.hasOption(OptionParserFactory.COPY_BINARIES);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = split(args.getOption(OptionParserFactory.INCLUDE_PATHS));\n        this.excludePaths = split(args.getOption(OptionParserFactory.EXCLUDE_PATHS));\n        this.mergePaths = split(args.getOption(OptionParserFactory.MERGE_PATHS));\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n        logOptions();\n    }","id":3153,"modified_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.disableMmap = args.hasOption(OptionParserFactory.DISABLE_MMAP);\n        this.copyBinaries = args.hasOption(OptionParserFactory.COPY_BINARIES);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = args.getOptionList(OptionParserFactory.INCLUDE_PATHS);\n        this.excludePaths = args.getOptionList(OptionParserFactory.EXCLUDE_PATHS);\n        this.mergePaths = args.getOptionList(OptionParserFactory.MERGE_PATHS);\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n\n        this.srcUser = args.getOption(OptionParserFactory.SRC_USER);\n        this.srcPassword = args.getOption(OptionParserFactory.SRC_USER);\n        this.dstUser = args.getOption(OptionParserFactory.DST_USER);\n        this.dstPassword = args.getOption(OptionParserFactory.DST_PASSWORD);\n\n        this.srcFbs = args.getOption(OptionParserFactory.SRC_FBS);\n        this.srcFds = args.getOption(OptionParserFactory.SRC_FDS);\n        this.srcS3 = args.getOption(OptionParserFactory.SRC_S3);\n        this.srcS3Config = args.getOption(OptionParserFactory.SRC_S3_CONFIG);\n\n        this.dstFbs = args.getOption(OptionParserFactory.DST_FBS);\n        this.dstFds = args.getOption(OptionParserFactory.DST_FDS);\n        this.dstS3 = args.getOption(OptionParserFactory.DST_S3);\n        this.dstS3Config = args.getOption(OptionParserFactory.DST_S3_CONFIG);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static void main(String... args) throws IOException {\n        MigrationCliArguments cliArguments = CliUtils.parseOrExit(OptionParserFactory.create(), args);\n        if (cliArguments == null) {\n            return;\n        }\n        migrate(cliArguments);\n    }","id":3154,"modified_method":"public static void main(String... args) throws IOException {\n        OptionSet options = OptionParserFactory.create().parse(args);\n        try {\n            MigrationCliArguments cliArguments = new MigrationCliArguments(options);\n            if (cliArguments.hasOption(OptionParserFactory.HELP) || cliArguments.getArguments().isEmpty()) {\n                CliUtils.displayUsage();\n                return;\n            }\n            migrate(cliArguments);\n        } catch(CliArgumentException e) {\n            if (e.getMessage() != null) {\n                System.err.println(e.getMessage());\n            }\n            System.exit(e.getExitCode());\n        }\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static void migrate(MigrationCliArguments argumentParser) throws IOException {\n        MigrationOptions options = argumentParser.getOptions();\n        StoreArguments stores = argumentParser.getStoreArguments();\n        Closer closer = Closer.create();\n        CliUtils.handleSigInt(closer);\n        MigrationFactory factory = new MigrationFactory(options, stores, closer);\n        try {\n            if (stores.getSrcStore().isJcr2()) {\n                upgrade(factory);\n            } else {\n                sidegrade(factory);\n            }\n        } catch (Throwable t) {\n            throw closer.rethrow(t);\n        } finally {\n            closer.close();\n        }\n    }","id":3155,"modified_method":"public static void migrate(MigrationCliArguments argumentParser) throws IOException, CliArgumentException {\n        MigrationOptions options = new MigrationOptions(argumentParser);\n        options.logOptions();\n\n        StoreArguments stores = new StoreArguments(options, argumentParser.getArguments());\n        stores.logOptions();\n\n        boolean srcEmbedded = stores.srcUsesEmbeddedDatastore();\n        DatastoreArguments datastores = new DatastoreArguments(options, stores, srcEmbedded);\n\n        migrate(options, stores, datastores);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoreArguments(MigrationCliArguments parser) throws CliArgumentException {\n        this.parser = parser;\n\n        List<StoreDescriptor> descriptors = createStoreDescriptors(parser.getArguments());\n\n        src = descriptors.get(0);\n        dst = descriptors.get(1);\n\n        log.info(\"Source: {}\", src);\n        log.info(\"Destination: {}\", dst);\n\n        if (dst.getType() == SEGMENT) {\n            logSegmentVersion();\n        }\n\n        datastores = new DatastoreArguments(parser, this);\n    }","id":3156,"modified_method":"public StoreArguments(MigrationOptions options, List<String> arguments) throws CliArgumentException {\n        this.options = options;\n        List<StoreDescriptor> descriptors = createStoreDescriptors(arguments);\n\n        src = descriptors.get(0);\n        dst = descriptors.get(1);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoreFactory getDstStore() {\n        return dst.getFactory(MigrationDirection.DST, parser);\n    }","id":3157,"modified_method":"public StoreFactory getDstStore() {\n        return dst.getFactory(MigrationDirection.DST, options);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoreFactory getSrcStore() {\n        return src.getFactory(MigrationDirection.SRC, parser);\n    }","id":3158,"modified_method":"public StoreFactory getSrcStore() {\n        return src.getFactory(MigrationDirection.SRC, options);\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoreFactory getFactory(MigrationDirection direction, MigrationCliArguments arguments) {\n            return type.createFactory(paths, direction, arguments);\n        }","id":3159,"modified_method":"public StoreFactory getFactory(MigrationDirection direction, MigrationOptions options) {\n            return type.createFactory(paths, direction, options);\n        }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test(expected =  CliArgumentException.class)\n    public void testSameRepositoryFails() throws CliArgumentException {\n        OptionSet options = OptionParserFactory.create().parse( \"my/repo\", \"my/repo\");\n        new MigrationCliArguments(options);\n    }","id":3160,"modified_method":"@Test(expected =  CliArgumentException.class)\n    public void testSameRepositoryFails() throws CliArgumentException {\n        MigrationCliArguments parsed = new MigrationCliArguments(OptionParserFactory.create().parse(\"my/repo\", \"my/repo\"));\n        MigrationOptions options = new MigrationOptions(parsed);\n        new StoreArguments(options, parsed.getArguments());\n    }","commit_id":"0fa9d744005377f452dd9135636e37c7dd45705d","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n  public void paintComponent(final Graphics g) {\n    final Dimension size = getSize();\n\n    final boolean pressed = getModel().isPressed();\n    final boolean forced = myWasPressed && !pressed || !myWasPressed && pressed;\n    myWasPressed = pressed;\n\n    if (myBufferedImage == null || forced) {\n      myBufferedImage = UIUtil.createImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\n      final Graphics bg = myBufferedImage.getGraphics().create();\n\n      final Runtime runtime = Runtime.getRuntime();\n      final long maxMemory = runtime.maxMemory();\n      final long freeMemory = maxMemory - runtime.totalMemory() + runtime.freeMemory();\n\n      final Insets insets = SystemInfo.isMac ? getInsets() : new Insets(0, 0, 0, 0);\n\n      final int totalBarLength = size.width - insets.left - insets.right - (SystemInfo.isMac ? 0 : 0);\n      final int usedBarLength = totalBarLength - (int)(totalBarLength * freeMemory / maxMemory);\n      final int allocatedBarWidth = totalBarLength - (int)(totalBarLength * (freeMemory - runtime.freeMemory()) / maxMemory);\n      final int barHeight = SystemInfo.isMac ? HEIGHT : size.height - insets.top - insets.bottom;\n      final Graphics2D g2 = (Graphics2D)bg;\n\n      final int yOffset = (size.height - barHeight) / 2;\n      final int xOffset = insets.left + (SystemInfo.isMac ? 0 : 0);\n\n      g2.setPaint(new GradientPaint(0, 0, Gray._190, 0, size.height - 1, Gray._230));\n      g2.fillRect(xOffset, yOffset, totalBarLength, barHeight);\n\n      g2.setPaint(new GradientPaint(0, 0, new Gray(200, 100), 0, size.height - 1, new Gray(150, 130)));\n      g2.fillRect(xOffset + 1, yOffset, allocatedBarWidth, barHeight);\n\n      g2.setColor(Gray._175);\n      g2.drawLine(xOffset + allocatedBarWidth, yOffset + 1, xOffset + allocatedBarWidth, yOffset + barHeight - 1);\n\n      if (pressed) {\n        g2.setPaint(new GradientPaint(1, 1, new Color(101, 111, 135), 0, size.height - 2, new Color(175, 185, 202)));\n        g2.fillRect(xOffset + 1, yOffset, usedBarLength, barHeight);\n      } else {\n        g2.setPaint(new GradientPaint(1, 1, new Color(175, 185, 202), 0, size.height - 2, new Color(126, 138, 168)));\n        g2.fillRect(xOffset + 1, yOffset, usedBarLength, barHeight);\n\n        if (SystemInfo.isMac) {\n          g2.setColor(new Color(194, 197, 203));\n          g2.drawLine(xOffset + 1, yOffset+1, allocatedBarWidth, yOffset+1);\n        }\n      }\n\n      if (SystemInfo.isMac) {\n        g2.setColor(Gray._110);\n        g2.drawRect(xOffset, yOffset, totalBarLength, barHeight - 1);\n      }\n\n      g2.setFont(getFont());\n      final long used = (maxMemory - freeMemory) / MEGABYTE;\n      final long total = maxMemory / MEGABYTE;\n      final String info = UIBundle.message(\"memory.usage.panel.message.text\", Long.toString(used), Long.toString(total));\n      final FontMetrics fontMetrics = g.getFontMetrics();\n      final int infoWidth = fontMetrics.charsWidth(info.toCharArray(), 0, info.length());\n      final int infoHeight = fontMetrics.getHeight() - fontMetrics.getDescent();\n      UIUtil.applyRenderingHints(g2);\n\n      g2.setColor(Color.black);\n      g2.drawString(info, xOffset + (totalBarLength - infoWidth) / 2, yOffset + (barHeight + infoHeight) / 2 - 1);\n      bg.dispose();\n    }\n\n    g.drawImage(myBufferedImage, 0, 0, null);\n  }","id":3161,"modified_method":"@Override\n  public void paintComponent(final Graphics g) {\n    final Dimension size = getSize();\n\n    final boolean pressed = getModel().isPressed();\n    final boolean forced = myWasPressed && !pressed || !myWasPressed && pressed;\n    myWasPressed = pressed;\n\n    if (myBufferedImage == null || forced) {\n      myBufferedImage = UIUtil.createImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\n      final Graphics bg = myBufferedImage.getGraphics().create();\n\n      final Runtime runtime = Runtime.getRuntime();\n      final long maxMemory = runtime.maxMemory();\n      final long freeMemory = maxMemory - runtime.totalMemory() + runtime.freeMemory();\n\n      final Insets insets = SystemInfo.isMac ? getInsets() : new Insets(0, 0, 0, 0);\n\n      final int totalBarLength = size.width - insets.left - insets.right;\n      final int usedBarLength = totalBarLength - (int)(totalBarLength * freeMemory / maxMemory);\n      final int allocatedBarWidth = totalBarLength - (int)(totalBarLength * (freeMemory - runtime.freeMemory()) / maxMemory);\n      final int barHeight = SystemInfo.isMac ? HEIGHT : size.height - insets.top - insets.bottom;\n      final Graphics2D g2 = (Graphics2D)bg;\n\n      final int yOffset = (size.height - barHeight) / 2;\n      final int xOffset = insets.left;\n      if (!UIUtil.isUnderAquaLookAndFeel()) {\n        g2.setColor(UIUtil.getControlColor());\n        g2.fillRect(xOffset, yOffset, totalBarLength, barHeight);\n      } else {\n        g2.setPaint(new GradientPaint(0, 0, Gray._190, 0, size.height - 1, Gray._230));\n        g2.fillRect(xOffset, yOffset, totalBarLength, barHeight);\n\n        g2.setPaint(new GradientPaint(0, 0, new Gray(200, 100), 0, size.height - 1, new Gray(150, 130)));\n        g2.fillRect(xOffset + 1, yOffset, allocatedBarWidth, barHeight);\n\n        g2.setColor(Gray._175);\n        g2.drawLine(xOffset + allocatedBarWidth, yOffset + 1, xOffset + allocatedBarWidth, yOffset + barHeight - 1);\n      }\n\n      if (pressed) {\n        Color start = new Color(101, 111, 135);\n        Color end = new Color(175, 185, 202);\n        if (UIUtil.isUnderDarcula()) {\n          start = start.darker();\n          end = end.darker();\n        }\n        g2.setPaint(new GradientPaint(1, 1, start, 0, size.height - 2, end));\n        g2.fillRect(xOffset + 1, yOffset, usedBarLength, barHeight);\n      } else {\n        Color start = new Color(175, 185, 202);\n        Color end = new Color(126, 138, 168);\n        if (UIUtil.isUnderDarcula()) {\n          start = start.darker();\n          end = end.darker();\n        }\n        g2.setPaint(new GradientPaint(1, 1, start, 0, size.height - 2, end));\n        g2.fillRect(xOffset + 1, yOffset, usedBarLength, barHeight);\n\n        if (SystemInfo.isMac && !UIUtil.isUnderDarcula()) {\n          g2.setColor(new Color(194, 197, 203));\n          g2.drawLine(xOffset + 1, yOffset+1, allocatedBarWidth, yOffset+1);\n        }\n      }\n\n      if (SystemInfo.isMac && !UIUtil.isUnderDarcula()) {\n        g2.setColor(Gray._110);\n        g2.drawRect(xOffset, yOffset, totalBarLength, barHeight - 1);\n      }\n\n      g2.setFont(getFont());\n      final long used = (maxMemory - freeMemory) / MEGABYTE;\n      final long total = maxMemory / MEGABYTE;\n      final String info = UIBundle.message(\"memory.usage.panel.message.text\", Long.toString(used), Long.toString(total));\n      final FontMetrics fontMetrics = g.getFontMetrics();\n      final int infoWidth = fontMetrics.charsWidth(info.toCharArray(), 0, info.length());\n      final int infoHeight = fontMetrics.getHeight() - fontMetrics.getDescent();\n      UIUtil.applyRenderingHints(g2);\n\n      g2.setColor(UIUtil.getListForeground());\n      g2.drawString(info, xOffset + (totalBarLength - infoWidth) / 2, yOffset + (barHeight + infoHeight) / 2 - 1);\n      bg.dispose();\n    }\n\n    g.drawImage(myBufferedImage, 0, 0, null);\n  }","commit_id":"4d1fcc1c6770ea58a3a4ad67d25799b34275d368","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<ConfigItem> generateConfig(CreateIpAliasCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        StringBuilder args = new StringBuilder();\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            args.append(ipaliasto.getAlias_count());\n            args.append(':');\n            args.append(ipaliasto.getRouterip());\n            args.append(':');\n            args.append(ipaliasto.getNetmask());\n            args.append('-');\n        }\n        cfg.add(new ScriptConfigItem(VRScripts.IPALIAS_CREATE, args.toString()));\n        return cfg;\n    }","id":3162,"modified_method":"private static List<ConfigItem> generateConfig(CreateIpAliasCommand cmd) {\n        List<IpAddressAlias> ipAliases = new LinkedList<IpAddressAlias>();\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            IpAddressAlias alias = new IpAddressAlias(false, ipaliasto.getRouterip(), ipaliasto.getNetmask(), Long.parseLong(ipaliasto.getAlias_count()));\n            ipAliases.add(alias);\n        }\n\n        IpAliases ipAliasList = new IpAliases(ipAliases);\n        return generateConfigItems(ipAliasList);\n    }","commit_id":"2e968d85fe1c790b8848b6b4cd242d08910e106c","url":"https://github.com/apache/cloudstack"},{"original_method":"private static List<ConfigItem> generateConfig(DeleteIpAliasCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n\n        StringBuffer buff = new StringBuffer();\n        List<IpAliasTO> revokedIpAliasTOs = cmd.getDeleteIpAliasTos();\n        for (IpAliasTO ipAliasTO : revokedIpAliasTOs) {\n            buff.append(ipAliasTO.getAlias_count());\n            buff.append(\":\");\n            buff.append(ipAliasTO.getRouterip());\n            buff.append(\":\");\n            buff.append(ipAliasTO.getNetmask());\n            buff.append(\"-\");\n        }\n        //this is to ensure that thre is some argument passed to the deleteipAlias script  when there are no revoked rules.\n        buff.append(\"- \");\n        List<IpAliasTO> activeIpAliasTOs = cmd.getCreateIpAliasTos();\n        for (IpAliasTO ipAliasTO : activeIpAliasTOs) {\n            buff.append(ipAliasTO.getAlias_count());\n            buff.append(\":\");\n            buff.append(ipAliasTO.getRouterip());\n            buff.append(\":\");\n            buff.append(ipAliasTO.getNetmask());\n            buff.append(\"-\");\n        }\n        cfg.add(new ScriptConfigItem(VRScripts.IPALIAS_DELETE, buff.toString()));\n        return cfg;\n    }","id":3163,"modified_method":"private static List<ConfigItem> generateConfig(DeleteIpAliasCommand cmd) {\n        List<IpAddressAlias> ipAliases = new LinkedList<IpAddressAlias>();\n\n        List<IpAliasTO> revokedIpAliasTOs = cmd.getDeleteIpAliasTos();\n        for (IpAliasTO ipAliasTO : revokedIpAliasTOs) {\n            IpAddressAlias alias = new IpAddressAlias(true, ipAliasTO.getRouterip(), ipAliasTO.getNetmask(), Long.parseLong(ipAliasTO.getAlias_count()));\n            ipAliases.add(alias);\n        }\n\n        List<IpAliasTO> activeIpAliasTOs = cmd.getCreateIpAliasTos();\n        for (IpAliasTO ipAliasTO : activeIpAliasTOs) {\n            IpAddressAlias alias = new IpAddressAlias(false, ipAliasTO.getRouterip(), ipAliasTO.getNetmask(), Long.parseLong(ipAliasTO.getAlias_count()));\n            ipAliases.add(alias);\n        }\n\n        IpAliases ipAliasList = new IpAliases(ipAliases);\n        return generateConfigItems(ipAliasList);\n    }","commit_id":"2e968d85fe1c790b8848b6b4cd242d08910e106c","url":"https://github.com/apache/cloudstack"},{"original_method":"PatternElement( PatternNode pNode, Node node )\n\t{\n\t\tthis.pNode = pNode;\n\t\tthis.node = node;\n\t}","id":3164,"modified_method":"PatternElement( PatternNode pNode, PatternRelationship pRel, \n        Node node, Relationship rel )\n\t{\n\t\tthis.pNode = pNode;\n\t\tthis.node = node;\n        this.prevPatternRel = pRel;\n        this.prevRel = rel;\n\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"PatternMatch( Map<PatternNode,PatternElement> elements )\n\t{\n\t\tthis.elements = elements;\n\t}","id":3165,"modified_method":"PatternMatch( Map<PatternNode,PatternElement> elements, \n        Map<PatternRelationship,Relationship> relElements )\n\t{\n\t\tthis.elements = elements;\n        this.relElements = relElements;\n\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static PatternMatch merge( Iterable<PatternMatch> matches )\n\t{\n\t\tMap<PatternNode, PatternElement> matchMap =\n\t\t\tnew HashMap<PatternNode, PatternElement>();\n\t\tfor ( PatternMatch match : matches )\n\t\t{\n\t\t\tfor ( PatternNode node : match.elements.keySet() )\n\t\t\t{\n\t\t\t\tboolean exists = false;\n\t\t\t\tfor ( PatternNode existingNode : matchMap.keySet() )\n\t\t\t\t{\n\t\t\t\t\tif ( node.getLabel().equals( existingNode.getLabel() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\texists = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !exists )\n\t\t\t\t{\n\t\t\t\t\tmatchMap.put( node, match.elements.get( node ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPatternMatch mergedMatch = new PatternMatch( matchMap );\n\t\treturn mergedMatch;\n\t}","id":3166,"modified_method":"public static PatternMatch merge( Iterable<PatternMatch> matches )\n\t{\n\t\tMap<PatternNode, PatternElement> matchMap =\n\t\t\tnew HashMap<PatternNode, PatternElement>();\n        Map<PatternRelationship, Relationship> relElements = \n            new HashMap<PatternRelationship, Relationship>();\n\t\tfor ( PatternMatch match : matches )\n\t\t{\n\t\t\tfor ( PatternNode node : match.elements.keySet() )\n\t\t\t{\n\t\t\t\tboolean exists = false;\n\t\t\t\tfor ( PatternNode existingNode : matchMap.keySet() )\n\t\t\t\t{\n\t\t\t\t\tif ( node.getLabel().equals( existingNode.getLabel() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\texists = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !exists )\n\t\t\t\t{\n\t\t\t\t\tmatchMap.put( node, match.elements.get( node ) );\n                    relElements.put( \n                        match.elements.get( node ).getFromPatternRelationship(), \n                        match.elements.get( node ).getFromRelationship() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPatternMatch mergedMatch = new PatternMatch( matchMap, relElements );\n\t\treturn mergedMatch;\n\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean traverse( CallPosition callPos )\n\t\t{\n\t\t\t// make everything like it was before we returned previous match\n\t\t\tPatternPosition currentPos = callPos.getPatternPosition();\n\t\t\tPatternRelationship pRel = callPos.getPatternRelationship();\n\t\t\tpRel.mark();\n\t\t\tvisitedRels.remove( callPos.getLastVisitedRelationship() );\n\t\t\tNode currentNode = currentPos.getCurrentNode();\n\t\t\tIterator<Relationship> relItr = callPos.getRelationshipIterator();\n\t\t\twhile ( relItr.hasNext() )\n\t\t\t{\n\t\t\t\tRelationship rel = relItr.next();\n\t\t\t\tif ( visitedRels.contains( rel ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode otherNode = rel.getOtherNode( currentNode );\n\t\t\t\tPatternNode otherPosition = pRel.getOtherNode( \n\t\t\t\t\tcurrentPos.getPatternNode() );\n\t\t\t\tpRel.mark();\n\t\t\t\tvisitedRels.add( rel );\n\t\t\t\tif ( traverse( new PatternPosition( otherNode, \n\t\t\t\t\totherPosition, optional ), true ) )\n\t\t\t\t{\n\t\t\t\t\tcallPos.setLastVisitedRelationship( rel );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvisitedRels.remove( rel );\n\t\t\t\tpRel.unMark();\n\t\t\t}\n\t\t\tpRel.unMark();\n\t\t\tif ( callPos.shouldPopUncompleted() )\n\t\t\t{\n\t\t\t\tuncompletedPositions.pop();\n\t\t\t}\n\t\t\tcallStack.pop();\n\t\t\tfoundElements.pop();\n\t\t\treturn false;\n\t\t}","id":3167,"modified_method":"private boolean traverse( CallPosition callPos )\n\t\t{\n\t\t\t// make everything like it was before we returned previous match\n\t\t\tPatternPosition currentPos = callPos.getPatternPosition();\n\t\t\tPatternRelationship pRel = callPos.getPatternRelationship();\n\t\t\tpRel.mark();\n\t\t\tvisitedRels.remove( callPos.getLastVisitedRelationship() );\n\t\t\tNode currentNode = currentPos.getCurrentNode();\n\t\t\tIterator<Relationship> relItr = callPos.getRelationshipIterator();\n\t\t\twhile ( relItr.hasNext() )\n\t\t\t{\n\t\t\t\tRelationship rel = relItr.next();\n\t\t\t\tif ( visitedRels.contains( rel ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                if ( !checkProperties( pRel, rel ) )\n                {\n                    continue;\n                }\n\t\t\t\tNode otherNode = rel.getOtherNode( currentNode );\n\t\t\t\tPatternNode otherPosition = pRel.getOtherNode( \n\t\t\t\t\tcurrentPos.getPatternNode() );\n\t\t\t\tpRel.mark();\n\t\t\t\tvisitedRels.add( rel );\n\t\t\t\tif ( traverse( new PatternPosition( otherNode, \n\t\t\t\t\totherPosition, pRel, rel, optional ), true ) )\n\t\t\t\t{\n\t\t\t\t\tcallPos.setLastVisitedRelationship( rel );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvisitedRels.remove( rel );\n\t\t\t\tpRel.unMark();\n\t\t\t}\n\t\t\tpRel.unMark();\n\t\t\tif ( callPos.shouldPopUncompleted() )\n\t\t\t{\n\t\t\t\tuncompletedPositions.pop();\n\t\t\t}\n\t\t\tcallStack.pop();\n\t\t\tfoundElements.pop();\n\t\t\treturn false;\n\t\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean traverse( PatternPosition currentPos, \n\t\t\tboolean pushElement )\n\t\t{\n\t\t\tPatternNode pNode = currentPos.getPatternNode();\n\t\t\tNode currentNode = currentPos.getCurrentNode();\n\t\t\t\n\t\t\tif ( !checkProperties( pNode, currentNode ) )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\t\n\t\t\tif ( pushElement )\n\t\t\t{\n\t\t\t\tfoundElements.push( new PatternElement( \n\t\t\t\t\tcurrentPos.getPatternNode(), \n\t\t\t\t\tcurrentPos.getCurrentNode() ) );\n\t\t\t}\n\t\t\tif ( currentPos.hasNext() )\n\t\t\t{\n\t\t\t\tboolean popUncompleted = false;\n\t\t\t\tPatternRelationship pRel = currentPos.next();\n\t\t\t\tif ( currentPos.hasNext() )\n\t\t\t\t{\n\t\t\t\t\tuncompletedPositions.push( currentPos );\n\t\t\t\t\tpopUncompleted = true;\n\t\t\t\t}\n\t\t\t\tassert !pRel.isMarked();\n\t\t\t\tIterator<Relationship> relItr = \n\t\t\t\t\tcurrentNode.getRelationships( pRel.getType(), \n\t\t\t\t\t\tpRel.getDirectionFrom( \n\t\t\t\t\t\t\tcurrentPos.getPatternNode() ) ).iterator();\n\t\t\t\tpRel.mark();\n\t\t\t\twhile ( relItr.hasNext() )\n\t\t\t\t{\n\t\t\t\t\tRelationship rel = relItr.next();\n\t\t\t\t\tif ( visitedRels.contains( rel ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tNode otherNode = rel.getOtherNode( currentNode );\n\t\t\t\t\tPatternNode otherPosition = pRel.getOtherNode( \n\t\t\t\t\t\tcurrentPos.getPatternNode() );\n\t\t\t\t\tvisitedRels.add( rel );\n\t\t\t\t\t\n\t\t\t\t\tCallPosition callPos = new CallPosition(\n\t\t\t\t\t\tcurrentPos, rel, relItr, pRel, popUncompleted );\n\t\t\t\t\tcallStack.push( callPos );\n\t\t\t\t\tif ( traverse( new PatternPosition( otherNode, \n\t\t\t\t\t\totherPosition, optional ), true ) )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcallStack.pop();\n\t\t\t\t\tvisitedRels.remove( rel );\n\t\t\t\t}\n\t\t\t\tpRel.unMark();\n\t\t\t\tif ( popUncompleted )\n\t\t\t\t{\n\t\t\t\t\tuncompletedPositions.pop();\n\t\t\t\t}\n\t\t\t\tfoundElements.pop();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tboolean matchFound = true;\n\t\t\tif ( !uncompletedPositions.isEmpty() )\n\t\t\t{\n\t\t\t\tPatternPosition digPos = uncompletedPositions.pop();\n\t\t\t\tdigPos.reset();\n\t\t\t\tmatchFound = traverse( digPos, false );\n\t\t\t\tuncompletedPositions.push( digPos );\n\t\t\t\treturn matchFound;\n\t\t\t}\n\t\t\treturn true;\n\t\t}","id":3168,"modified_method":"private boolean traverse( PatternPosition currentPos, \n\t\t\tboolean pushElement )\n\t\t{\n\t\t\tPatternNode pNode = currentPos.getPatternNode();\n\t\t\tNode currentNode = currentPos.getCurrentNode();\n\t\t\t\n\t\t\tif ( !checkProperties( pNode, currentNode ) )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\t\n\t\t\tif ( pushElement )\n\t\t\t{\n\t\t\t\tfoundElements.push( new PatternElement( \n\t\t\t\t\tcurrentPos.getPatternNode(), \n                    currentPos.fromPatternRel(),  \n\t\t\t\t\tcurrentPos.getCurrentNode(),\n                    currentPos.fromRelationship() ) );\n\t\t\t}\n\t\t\tif ( currentPos.hasNext() )\n\t\t\t{\n\t\t\t\tboolean popUncompleted = false;\n\t\t\t\tPatternRelationship pRel = currentPos.next();\n\t\t\t\tif ( currentPos.hasNext() )\n\t\t\t\t{\n\t\t\t\t\tuncompletedPositions.push( currentPos );\n\t\t\t\t\tpopUncompleted = true;\n\t\t\t\t}\n\t\t\t\tassert !pRel.isMarked();\n\t\t\t\tIterator<Relationship> relItr = getRelationshipIterator( \n                    currentPos.getPatternNode(), currentNode, pRel );\n\t\t\t\tpRel.mark();\n\t\t\t\twhile ( relItr.hasNext() )\n\t\t\t\t{\n\t\t\t\t\tRelationship rel = relItr.next();\n\t\t\t\t\tif ( visitedRels.contains( rel ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n                    if ( !checkProperties( pRel, rel ) )\n                    {\n                        continue;\n                    }\n\t\t\t\t\tNode otherNode = rel.getOtherNode( currentNode );\n\t\t\t\t\tPatternNode otherPosition = pRel.getOtherNode( \n\t\t\t\t\t\tcurrentPos.getPatternNode() );\n\t\t\t\t\tvisitedRels.add( rel );\n\t\t\t\t\t\n\t\t\t\t\tCallPosition callPos = new CallPosition(\n\t\t\t\t\t\tcurrentPos, rel, relItr, pRel, popUncompleted );\n\t\t\t\t\tcallStack.push( callPos );\n\t\t\t\t\tif ( traverse( new PatternPosition( otherNode, \n\t\t\t\t\t\totherPosition, pRel, rel, optional ), true ) )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcallStack.pop();\n\t\t\t\t\tvisitedRels.remove( rel );\n\t\t\t\t}\n\t\t\t\tpRel.unMark();\n\t\t\t\tif ( popUncompleted )\n\t\t\t\t{\n\t\t\t\t\tuncompletedPositions.pop();\n\t\t\t\t}\n\t\t\t\tfoundElements.pop();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tboolean matchFound = true;\n\t\t\tif ( !uncompletedPositions.isEmpty() )\n\t\t\t{\n\t\t\t\tPatternPosition digPos = uncompletedPositions.pop();\n\t\t\t\tdigPos.reset();\n\t\t\t\tmatchFound = traverse( digPos, false );\n\t\t\t\tuncompletedPositions.push( digPos );\n\t\t\t\treturn matchFound;\n\t\t\t}\n\t\t\treturn true;\n\t\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private PatternMatch findNextMatch()\n\t\t{\n\t\t\tif ( callStack.isEmpty() && currentPosition != null )\n\t\t\t{\n\t\t\t\t// try find first match\n\t\t\t\tif ( traverse( currentPosition, true ) )\n\t\t\t\t{\n\t\t\t\t\t// found first match, return it\n\t\t\t\t\tcurrentPosition = null;\n\t\t\t\t\tHashMap<PatternNode,PatternElement> filteredElements =\n\t\t\t\t\t\tnew HashMap<PatternNode, PatternElement>();\n\t\t\t\t\tfor ( PatternElement element : foundElements )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredElements.put( element.getPatternNode(), element );\n\t\t\t\t\t}\n\t\t\t\t\tPatternMatch patternMatch = new PatternMatch( \n\t\t\t\t\t\tfilteredElements );\n\t\t\t\t\tfoundElements.pop();\n\t\t\t\t\treturn patternMatch;\n\t\t\t\t}\n\t\t\t\tcurrentPosition = null;\n\t\t\t}\n\t\t\telse if ( !callStack.isEmpty() )\n\t\t\t{\n\t\t\t\t// try find other match from last found match\n\t\t\t\tboolean matchFound = false;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tCallPosition callStackInformation = callStack.peek();\n\t\t\t\t\tmatchFound = traverse( callStackInformation );\n\t\t\t\t} while ( !callStack.isEmpty() && !matchFound ); \n\t\t\t\tif ( matchFound )\n\t\t\t\t{\n\t\t\t\t\t// found another match, returning it\n\t\t\t\t\tHashMap<PatternNode,PatternElement> filteredElements =\n\t\t\t\t\t\tnew HashMap<PatternNode, PatternElement>();\n\t\t\t\t\tfor ( PatternElement element : foundElements )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredElements.put( element.getPatternNode(), element );\n\t\t\t\t\t}\n\t\t\t\t\tPatternMatch patternMatch = new PatternMatch( \n\t\t\t\t\t\tfilteredElements);\n\t\t\t\t\tfoundElements.pop();\n\t\t\t\t\treturn patternMatch;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":3169,"modified_method":"private PatternMatch findNextMatch()\n\t\t{\n\t\t\tif ( callStack.isEmpty() && currentPosition != null )\n\t\t\t{\n\t\t\t\t// try find first match\n\t\t\t\tif ( traverse( currentPosition, true ) )\n\t\t\t\t{\n\t\t\t\t\t// found first match, return it\n\t\t\t\t\tcurrentPosition = null;\n\t\t\t\t\tHashMap<PatternNode,PatternElement> filteredElements =\n\t\t\t\t\t\tnew HashMap<PatternNode, PatternElement>();\n                    HashMap<PatternRelationship,Relationship> relElements = \n                        new HashMap<PatternRelationship,Relationship>();\n\t\t\t\t\tfor ( PatternElement element : foundElements )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredElements.put( element.getPatternNode(), \n                            element );\n                        relElements.put( element.getFromPatternRelationship(), \n                            element.getFromRelationship() );\n\t\t\t\t\t}\n\t\t\t\t\tPatternMatch patternMatch = new PatternMatch( \n\t\t\t\t\t\tfilteredElements, relElements );\n\t\t\t\t\tfoundElements.pop();\n\t\t\t\t\treturn patternMatch;\n\t\t\t\t}\n\t\t\t\tcurrentPosition = null;\n\t\t\t}\n\t\t\telse if ( !callStack.isEmpty() )\n\t\t\t{\n\t\t\t\t// try find other match from last found match\n\t\t\t\tboolean matchFound = false;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tCallPosition callStackInformation = callStack.peek();\n\t\t\t\t\tmatchFound = traverse( callStackInformation );\n\t\t\t\t} while ( !callStack.isEmpty() && !matchFound ); \n\t\t\t\tif ( matchFound )\n\t\t\t\t{\n\t\t\t\t\t// found another match, returning it\n\t\t\t\t\tHashMap<PatternNode,PatternElement> filteredElements =\n\t\t\t\t\t\tnew HashMap<PatternNode, PatternElement>();\n                    HashMap<PatternRelationship,Relationship> relElements = \n                        new HashMap<PatternRelationship,Relationship>();\n\t\t\t\t\tfor ( PatternElement element : foundElements )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredElements.put( element.getPatternNode(), element );\n                        relElements.put( element.getFromPatternRelationship(), \n                            element.getFromRelationship() );\n\t\t\t\t\t}\n\t\t\t\t\tPatternMatch patternMatch = new PatternMatch( \n\t\t\t\t\t\tfilteredElements, relElements );\n\t\t\t\t\tfoundElements.pop();\n\t\t\t\t\treturn patternMatch;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testNonCyclicABC()\n\t{\n\t\tNode a = createInstance( \"A\" );\n\t\tNode b1 = createInstance( \"B1\" );\n\t\tNode b2 = createInstance( \"B2\" );\n\t\tNode b3 = createInstance( \"B3\" );\n\t\tNode c = createInstance( \"C\" );\n\t\t\n\t\tfinal RelationshipType R = MyRelTypes.R1;\n\t\t\n\t\ta.createRelationshipTo( b1, R );\n\t\ta.createRelationshipTo( b2, R );\n\t\ta.createRelationshipTo( b3, R );\n\t\tb1.createRelationshipTo( c, R );\n\t\tb2.createRelationshipTo( c, R );\n\t\tb3.createRelationshipTo( c, R );\n\t\t\n\t\tPatternNode pA = new PatternNode();\n\t\tPatternNode pB = new PatternNode();\n\t\tPatternNode pC = new PatternNode();\n\t\t\n\t\tpA.createRelationshipTo( pB, R );\n\t\tpB.createRelationshipTo( pC, R );\n\t\t\n\t\tint count = 0;\n\t\tfor ( PatternMatch match : \n\t\t\tPatternMatcher.getMatcher().match( pA, a ) )\n\t\t{\n\t\t\tassertEquals( match.getNodeFor( pA ), a );\n\t\t\tNode b = match.getNodeFor( pB );\n\t\t\tif ( !b.equals( b1 ) && !b.equals( b2 ) && !b.equals( b3 ) )\n\t\t\t{\n\t\t\t\tfail( \"either b1 or b2 or b3\" );\n\t\t\t}\n\t\t\tassertEquals( match.getNodeFor( pC ), c );\n\t\t\tcount++;\n\t\t}\n\t\tassertEquals( 3, count );\n\t\tcount = 0;\n\t\tfor ( PatternMatch match : \n\t\t\tPatternMatcher.getMatcher().match( pB, b2 ) )\n\t\t{\n\t\t\tassertEquals( match.getNodeFor( pA ), a );\n\t\t\tassertEquals( match.getNodeFor( pB ), b2 );\n\t\t\tassertEquals( match.getNodeFor( pC ), c );\n\t\t\tcount++;\n\t\t}\n\t\tassertEquals( 1, count );\n\t}","id":3170,"modified_method":"public void testNonCyclicABC()\n\t{\n\t\tNode a = createInstance( \"A\" );\n\t\tNode b1 = createInstance( \"B1\" );\n\t\tNode b2 = createInstance( \"B2\" );\n\t\tNode b3 = createInstance( \"B3\" );\n\t\tNode c = createInstance( \"C\" );\n\t\t\n\t\tfinal RelationshipType R = MyRelTypes.R1;\n\t\t\n\t\tRelationship rAB1 = a.createRelationshipTo( b1, R );\n        Relationship rAB2 = a.createRelationshipTo( b2, R );\n        Relationship rAB3 = a.createRelationshipTo( b3, R );\n        Relationship rB1C = b1.createRelationshipTo( c, R );\n        Relationship rB2C = b2.createRelationshipTo( c, R );\n        Relationship rB3C = b3.createRelationshipTo( c, R );\n\t\t\n\t\tPatternNode pA = new PatternNode();\n\t\tPatternNode pB = new PatternNode();\n\t\tPatternNode pC = new PatternNode();\n\t\t\n\t\tPatternRelationship pAB = pA.createRelationshipTo( pB, R );\n\t\tPatternRelationship pBC = pB.createRelationshipTo( pC, R );\n\t\t\n\t\tint count = 0;\n\t\tfor ( PatternMatch match : \n\t\t\tPatternMatcher.getMatcher().match( pA, a ) )\n\t\t{\n\t\t\tassertEquals( match.getNodeFor( pA ), a );\n\t\t\tNode b = match.getNodeFor( pB );\n\t\t\tif ( !b.equals( b1 ) && !b.equals( b2 ) && !b.equals( b3 ) )\n\t\t\t{\n\t\t\t\tfail( \"either b1 or b2 or b3\" );\n\t\t\t}\n            Relationship rB = match.getRelationshipFor( pAB );\n            if ( !rAB1.equals( rB ) && !rAB2.equals( rB ) && !rAB3.equals( rB ))\n            {\n                fail( \"either rAB1, rAB2 or rAB3\" );\n            }\n\t\t\tassertEquals( match.getNodeFor( pC ), c );\n            Relationship rC = match.getRelationshipFor( pBC );\n            if ( !rB1C.equals( rC ) && !rB2C.equals( rC ) && !rB3C.equals( rC ))\n            {\n                fail( \"either rB1C, rB2C or rB3C\" );\n            }\n\t\t\tcount++;\n\t\t}\n\t\tassertEquals( 3, count );\n\t\tcount = 0;\n\t\tfor ( PatternMatch match : \n\t\t\tPatternMatcher.getMatcher().match( pB, b2 ) )\n\t\t{\n\t\t\tassertEquals( match.getNodeFor( pA ), a );\n\t\t\tassertEquals( match.getNodeFor( pB ), b2 );\n\t\t\tassertEquals( match.getNodeFor( pC ), c );\n\t\t\tcount++;\n\t\t}\n\t\tassertEquals( 1, count );\n\t}","commit_id":"f14673b26d16103a07d248924a2263da4c0a6ce1","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors<\/code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n        for (AnnotationNode annotation : (Collection<AnnotationNode>) node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            for (String transformClass : getTransformClasses(transformClassAnnotation)) {\n                try {\n                    Class klass = transformLoader.loadClass(transformClass, false, true, false);\n                    if (ASTTransformation.class.isAssignableFrom(klass)) {\n                        classNode.addTransform(klass, annotation);\n                    } else {\n                        source.getErrorCollector().addError(\n                                new SimpleMessage(\n                                        \"Not an ASTTransformation: \" + transformClass\n                                        + \" declared by \" + annotation.getClassNode().getName(),\n                                        source));\n                    }\n                } catch (ClassNotFoundException e) {\n                    source.getErrorCollector().addErrorAndContinue(\n                            new SimpleMessage(\n                                    \"Could not find class for Transformation Processor \" + transformClass\n                                    + \" declared by \" + annotation.getClassNode().getName(),\n                                    source));\n                }\n            }\n        }\n    }","id":3171,"modified_method":"/**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors<\/code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            for (String transformClass : getTransformClasses(transformClassAnnotation)) {\n                try {\n                    Class klass = transformLoader.loadClass(transformClass, false, true, false);\n                    if (ASTTransformation.class.isAssignableFrom(klass)) {\n                        classNode.addTransform(klass, annotation);\n                    } else {\n                        source.getErrorCollector().addError(\n                                new SimpleMessage(\n                                        \"Not an ASTTransformation: \" + transformClass\n                                                + \" declared by \" + annotation.getClassNode().getName(),\n                                        source));\n                    }\n                } catch (ClassNotFoundException e) {\n                    source.getErrorCollector().addErrorAndContinue(\n                            new SimpleMessage(\n                                    \"Could not find class for Transformation Processor \" + transformClass\n                                            + \" declared by \" + annotation.getClassNode().getName(),\n                                    source));\n                }\n            }\n        }\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getPropertyType(MethodNode m) {\n        String name = m.getName();\n        if (m.getReturnType() != ClassHelper.VOID_TYPE) {\n            return m.getReturnType();\n        }\n        return m.getParameters()[0].getType();\n    }","id":3172,"modified_method":"private ClassNode getPropertyType(MethodNode m) {\n        if (m.getReturnType() != ClassHelper.VOID_TYPE) {\n            return m.getReturnType();\n        }\n        return m.getParameters()[0].getType();\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"public void visitDeclarationExpression(DeclarationExpression expression) {\n        // visit right side first to avoid the usage of a \n        // variable before its declaration\n        expression.getRightExpression().visit(this);\n        \n        // no need to visit left side, just get the variable name\n        if (expression.isMultipleAssignmentDeclaration()) {\n            ArgumentListExpression list = (ArgumentListExpression) expression.getLeftExpression();\n            for (Iterator it=list.getExpressions().iterator(); it.hasNext();) {\n                VariableExpression exp = (VariableExpression) it.next();\n                declare(exp);\n            }\n        } else {\n            declare(expression.getVariableExpression());           \n        }        \n    }","id":3173,"modified_method":"public void visitDeclarationExpression(DeclarationExpression expression) {\n        // visit right side first to avoid the usage of a \n        // variable before its declaration\n        expression.getRightExpression().visit(this);\n\n        // no need to visit left side, just get the variable name\n        if (expression.isMultipleAssignmentDeclaration()) {\n            ArgumentListExpression list = (ArgumentListExpression) expression.getLeftExpression();\n            for (Expression e : list.getExpressions()) {\n                VariableExpression exp = (VariableExpression) e;\n                declare(exp);\n            }\n        } else {\n            declare(expression.getVariableExpression());\n        }\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private Variable checkVariableNameForDeclaration(String name, Expression expression) {\n        if (\"super\".equals(name) || \"this\".equals(name)) return null;\n\n        VariableScope scope = currentScope;\n        Variable var = new DynamicVariable(name, currentScope.isInStaticContext());\n        Variable dummyStart = var;\n        // try to find a declaration of a variable\n        VariableScope dynamicScope = null;\n        while (!scope.isRoot()) {\n            if (dynamicScope == null && scope.isResolvingDynamic()) {\n                dynamicScope = scope;\n            }\n\n            Variable var1;\n            var1 = scope.getDeclaredVariable(var.getName());\n\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            var1 = (Variable) scope.getReferencedLocalVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            var1 = scope.getReferencedClassVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            ClassNode classScope = scope.getClassScope();\n            if (classScope != null) {\n                Variable member = findClassMember(classScope, var.getName());\n                if (member != null) {\n                    boolean cc = currentScope.isInStaticContext() || isSpecialConstructorCall;\n                    boolean cm = member.isInStaticContext();\n                    //\n                    // we don't allow access from dynamic context to static context\n                    //\n                    // cm==cc: \n                    //   we always allow access if the context is in both cases static \n                    //   or dynamic\n                    // cm==true: \n                    //   the member is static, which means access is always allowed\n                    // cm||cm==cc:\n                    //   is false only for the case cc==true and cm==false, which means\n                    //   the member is a dynamic context, but the current scope is static.\n                    //\n                    // One example for (cm||cm==cc)==false is a static method trying to \n                    // access a non static field.\n                    //\n                    if (cm || cm == cc) var = member;\n                }\n                break;\n            }\n            scope = scope.getParent();\n        }\n\n        VariableScope end = scope;\n\n        if (scope.isRoot() && dynamicScope == null) {\n            // no matching scope found\n            declare(var, expression);\n            addError(\"The variable \" + var.getName() +\n                    \" is undefined in the current scope\", expression);\n        } else if (scope.isRoot() && dynamicScope != null) {\n            // no matching scope found, but there was a scope that\n            // resolves dynamic\n            scope = dynamicScope;\n        }\n\n        if (!scope.isRoot()) {\n            scope = currentScope;\n            while (scope != end) {\n                Map references = null;\n                if (end.isClassScope() || end.isRoot() ||\n                        (end.isReferencedClassVariable(name) && end.getDeclaredVariable(name) == null)) {\n                    scope.putReferencedClassVariable(var);\n                } else {\n                    var.setClosureSharedVariable(var.isClosureSharedVariable() || inClosure);\n                    scope.putReferencedLocalVariable(var);\n                }\n                scope = scope.getParent();\n            }\n            if (end.isResolvingDynamic()) {\n                if (end.getDeclaredVariable(var.getName()) == null) {\n                    end.putDeclaredVariable(var);\n                }\n            }\n        }\n\n        return var;\n    }","id":3174,"modified_method":"private Variable checkVariableNameForDeclaration(String name, Expression expression) {\n        if (\"super\".equals(name) || \"this\".equals(name)) return null;\n\n        VariableScope scope = currentScope;\n        Variable var = new DynamicVariable(name, currentScope.isInStaticContext());\n        // try to find a declaration of a variable\n        VariableScope dynamicScope = null;\n        while (!scope.isRoot()) {\n            if (dynamicScope == null && scope.isResolvingDynamic()) {\n                dynamicScope = scope;\n            }\n\n            Variable var1;\n            var1 = scope.getDeclaredVariable(var.getName());\n\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            var1 = scope.getReferencedLocalVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            var1 = scope.getReferencedClassVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n\n            ClassNode classScope = scope.getClassScope();\n            if (classScope != null) {\n                Variable member = findClassMember(classScope, var.getName());\n                if (member != null) {\n                    boolean cc = currentScope.isInStaticContext() || isSpecialConstructorCall;\n                    boolean cm = member.isInStaticContext();\n                    //\n                    // we don't allow access from dynamic context to static context\n                    //\n                    // cm==cc: \n                    //   we always allow access if the context is in both cases static \n                    //   or dynamic\n                    // cm==true: \n                    //   the member is static, which means access is always allowed\n                    // cm||cm==cc:\n                    //   is false only for the case cc==true and cm==false, which means\n                    //   the member is a dynamic context, but the current scope is static.\n                    //\n                    // One example for (cm||cm==cc)==false is a static method trying to \n                    // access a non static field.\n                    //\n                    if (cm || cm == cc) var = member;\n                }\n                break;\n            }\n            scope = scope.getParent();\n        }\n\n        VariableScope end = scope;\n\n        if (scope.isRoot() && dynamicScope == null) {\n            // no matching scope found\n            declare(var, expression);\n            addError(\"The variable \" + var.getName() +\n                    \" is undefined in the current scope\", expression);\n        } else if (scope.isRoot() && dynamicScope != null) {\n            // no matching scope found, but there was a scope that\n            // resolves dynamic\n            scope = dynamicScope;\n        }\n\n        if (!scope.isRoot()) {\n            scope = currentScope;\n            while (scope != end) {\n                if (end.isClassScope() || end.isRoot() ||\n                        (end.isReferencedClassVariable(name) && end.getDeclaredVariable(name) == null)) {\n                    scope.putReferencedClassVariable(var);\n                } else {\n                    var.setClosureSharedVariable(var.isClosureSharedVariable() || inClosure);\n                    scope.putReferencedLocalVariable(var);\n                }\n                scope = scope.getParent();\n            }\n            if (end.isResolvingDynamic()) {\n                if (end.getDeclaredVariable(var.getName()) == null) {\n                    end.putDeclaredVariable(var);\n                }\n            }\n        }\n\n        return var;\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"public void visitCatchStatement(CatchStatement statement) {\n        pushState();\n        Parameter p = (Parameter) statement.getVariable();\n        p.setInStaticContext(currentScope.isInStaticContext());\n        declare(p, statement);\n        super.visitCatchStatement(statement);\n        popState();\n    }","id":3175,"modified_method":"public void visitCatchStatement(CatchStatement statement) {\n        pushState();\n        Parameter p = statement.getVariable();\n        p.setInStaticContext(currentScope.isInStaticContext());\n        declare(p, statement);\n        super.visitCatchStatement(statement);\n        popState();\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"public void visitForLoop(ForStatement forLoop) {\n        pushState();\n        forLoop.setVariableScope(currentScope);\n        Parameter p = (Parameter) forLoop.getVariable();\n        p.setInStaticContext(currentScope.isInStaticContext());\n        if (p != ForStatement.FOR_LOOP_DUMMY) declare(p, forLoop);\n        super.visitForLoop(forLoop);\n        popState();\n    }","id":3176,"modified_method":"public void visitForLoop(ForStatement forLoop) {\n        pushState();\n        forLoop.setVariableScope(currentScope);\n        Parameter p = forLoop.getVariable();\n        p.setInStaticContext(currentScope.isInStaticContext());\n        if (p != ForStatement.FOR_LOOP_DUMMY) declare(p, forLoop);\n        super.visitForLoop(forLoop);\n        popState();\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * a property on \"this\", like this.x is transformed to a\n     * direct field access, so we need to check the\n     * static context here\n     */\n    private void checkPropertyOnExplicitThis(PropertyExpression pe) {\n        if (!currentScope.isInStaticContext()) return;\n        Expression object = pe.getObjectExpression();\n        if (!(object instanceof VariableExpression)) return;\n        VariableExpression ve = (VariableExpression) object;\n        if (!ve.getName().equals(\"this\")) return;\n        String name = pe.getPropertyAsString();\n        if (name == null) return;\n        Variable member = findClassMember(currentClass, name);\n        if (member == null) return;\n        checkVariableContextAccess(member, pe);\n    }","id":3177,"modified_method":"/**\n     * a property on \"this\", like this.x is transformed to a\n     * direct field access, so we need to check the\n     * static context here\n     *\n     * @param pe the property expression to check\n     */\n    private void checkPropertyOnExplicitThis(PropertyExpression pe) {\n        if (!currentScope.isInStaticContext()) return;\n        Expression object = pe.getObjectExpression();\n        if (!(object instanceof VariableExpression)) return;\n        VariableExpression ve = (VariableExpression) object;\n        if (!ve.getName().equals(\"this\")) return;\n        String name = pe.getPropertyAsString();\n        if (name == null) return;\n        Variable member = findClassMember(currentClass, name);\n        if (member == null) return;\n        checkVariableContextAccess(member, pe);\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {\n        pushState(node.isStatic());\n\n        node.setVariableScope(currentScope);\n\n        // GROOVY-2156\n        Parameter[] parameters = node.getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n            Parameter parameter = parameters[i];\n            visitAnnotations(parameter);\n        }\n\n        declare(node.getParameters(), node);\n\n        super.visitConstructorOrMethod(node, isConstructor);\n        popState();\n    }","id":3178,"modified_method":"protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {\n        pushState(node.isStatic());\n\n        node.setVariableScope(currentScope);\n\n        // GROOVY-2156\n        Parameter[] parameters = node.getParameters();\n        for (Parameter parameter : parameters) {\n            visitAnnotations(parameter);\n        }\n\n        declare(node.getParameters(), node);\n\n        super.visitConstructorOrMethod(node, isConstructor);\n        popState();\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private Variable findClassMember(ClassNode cn, String name) {\n        if (cn == null) return null;\n        if (cn.isScript()) {\n            return new DynamicVariable(name, false);\n        }\n        List l = cn.getFields();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            FieldNode f = (FieldNode) iter.next();\n            if (f.getName().equals(name)) return f;\n        }\n\n        l = cn.getMethods();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            MethodNode f = (MethodNode) iter.next();\n            String methodName = f.getName();\n            String pName = getPropertyName(f);\n            if (pName == null) continue;\n            if (!pName.equals(name)) continue;\n            PropertyNode var = new PropertyNode(pName, f.getModifiers(), getPropertyType(f), cn, null, null, null);\n            return var;\n        }\n\n        l = cn.getProperties();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            PropertyNode f = (PropertyNode) iter.next();\n            if (f.getName().equals(name)) return f;\n        }\n\n        Variable ret = findClassMember(cn.getSuperClass(), name);\n        if (ret != null) return ret;\n        return findClassMember(cn.getOuterClass(), name);\n    }","id":3179,"modified_method":"private Variable findClassMember(ClassNode cn, String name) {\n        if (cn == null) return null;\n        if (cn.isScript()) {\n            return new DynamicVariable(name, false);\n        }\n\n        for (FieldNode fn : cn.getFields()) {\n            if (fn.getName().equals(name)) return fn;\n        }\n\n        for (MethodNode mn : cn.getMethods()) {\n            String pName = getPropertyName(mn);\n            if (pName != null && pName.equals(name))\n                return new PropertyNode(pName, mn.getModifiers(), getPropertyType(mn), cn, null, null, null);\n        }\n\n        for (PropertyNode pn : cn.getProperties()) {\n            if (pn.getName().equals(name)) return pn;\n        }\n\n        Variable ret = findClassMember(cn.getSuperClass(), name);\n        if (ret != null) return ret;\n        return findClassMember(cn.getOuterClass(), name);\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private void declare(Parameter[] parameters, ASTNode node) {\n        for (int i = 0; i < parameters.length; i++) {\n            if (parameters[i].hasInitialExpression()) {\n                parameters[i].getInitialExpression().visit(this);\n            }\n            declare(parameters[i], node);\n        }\n    }","id":3180,"modified_method":"private void declare(Parameter[] parameters, ASTNode node) {\n        for (Parameter parameter : parameters) {\n            if (parameter.hasInitialExpression()) {\n                parameter.getInitialExpression().visit(this);\n            }\n            declare(parameter, node);\n        }\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"public void visitClosureExpression(ClosureExpression expression) {\n        pushState();\n\n        inClosure = true;\n        // as result of the Paris meeting Closure resolves\n        // always dynamically\n        currentScope.setDynamicResolving(true);\n\n        expression.setVariableScope(currentScope);\n\n        if (expression.isParameterSpecified()) {\n            Parameter[] parameters = expression.getParameters();\n            for (int i = 0; i < parameters.length; i++) {\n                parameters[i].setInStaticContext(currentScope.isInStaticContext());\n                if (parameters[i].hasInitialExpression()) {\n                    parameters[i].getInitialExpression().visit(this);\n                }\n                declare(parameters[i], expression);                \n            }\n        } else if (expression.getParameters() != null) {\n            Parameter var = new Parameter(ClassHelper.OBJECT_TYPE,\"it\");\n            var.setInStaticContext(currentScope.isInStaticContext());\n            currentScope.putDeclaredVariable(var);\n        }\n\n        super.visitClosureExpression(expression);\n        popState();\n    }","id":3181,"modified_method":"public void visitClosureExpression(ClosureExpression expression) {\n        pushState();\n\n        inClosure = true;\n        // as result of the Paris meeting Closure resolves\n        // always dynamically\n        currentScope.setDynamicResolving(true);\n\n        expression.setVariableScope(currentScope);\n\n        if (expression.isParameterSpecified()) {\n            Parameter[] parameters = expression.getParameters();\n            for (Parameter parameter : parameters) {\n                parameter.setInStaticContext(currentScope.isInStaticContext());\n                if (parameter.hasInitialExpression()) {\n                    parameter.getInitialExpression().visit(this);\n                }\n                declare(parameter, expression);\n            }\n        } else if (expression.getParameters() != null) {\n            Parameter var = new Parameter(ClassHelper.OBJECT_TYPE, \"it\");\n            var.setInStaticContext(currentScope.isInStaticContext());\n            currentScope.putDeclaredVariable(var);\n        }\n\n        super.visitClosureExpression(expression);\n        popState();\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private void checkNoAbstractMethodsNonabstractClass(ClassNode node) {\n        if (Modifier.isAbstract(node.getModifiers())) return;\n        List abstractMethods = node.getAbstractMethods();\n        if (abstractMethods == null) return;\n        for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {\n            MethodNode method = (MethodNode) iter.next();\n            addError(\"Can't have an abstract method in a non-abstract class.\" +\n                    \" The \" + getDescription(node) + \" must be declared abstract or\" +\n                    \" the \" + getDescription(method) + \" must be implemented.\", node);\n        }\n    }","id":3182,"modified_method":"private void checkNoAbstractMethodsNonabstractClass(ClassNode node) {\n        if (Modifier.isAbstract(node.getModifiers())) return;\n        List<MethodNode> abstractMethods = node.getAbstractMethods();\n        if (abstractMethods == null) return;\n        for (MethodNode method : abstractMethods) {\n            addError(\"Can't have an abstract method in a non-abstract class.\" +\n                    \" The \" + getDescription(node) + \" must be declared abstract or\" +\n                    \" the \" + getDescription(method) + \" must be implemented.\", node);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void addInvalidUseOfFinalError(MethodNode method, Parameter[] parameters, ClassNode superCN) {\n        StringBuffer msg = new StringBuffer();\n        msg.append(\"You are not allowed to override the final method \").append(method.getName());\n        msg.append(\"(\");\n        boolean needsComma = false;\n        for (int i = 0; i < parameters.length; i++) {\n            if (needsComma) {\n                msg.append(\",\");\n            } else {\n                needsComma = true;\n            }\n            msg.append(parameters[i].getType());\n        }\n        msg.append(\") from \").append(getDescription(superCN));\n        msg.append(\".\");\n        addError(msg.toString(), method);\n    }","id":3183,"modified_method":"private void addInvalidUseOfFinalError(MethodNode method, Parameter[] parameters, ClassNode superCN) {\n        StringBuffer msg = new StringBuffer();\n        msg.append(\"You are not allowed to override the final method \").append(method.getName());\n        msg.append(\"(\");\n        boolean needsComma = false;\n        for (Parameter parameter : parameters) {\n            if (needsComma) {\n                msg.append(\",\");\n            } else {\n                needsComma = true;\n            }\n            msg.append(parameter.getType());\n        }\n        msg.append(\") from \").append(getDescription(superCN));\n        msg.append(\".\");\n        addError(msg.toString(), method);\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkOverloadingPrivateAndPublic(MethodNode node) {\n        if (isConstructor(node)) return;\n        List methods = currentClass.getMethods(node.getName());\n        boolean hasPrivate=false;\n        boolean hasPublic=false;\n        for (Iterator iter = methods.iterator(); iter.hasNext();) {\n            MethodNode element = (MethodNode) iter.next();\n            if (element == node) continue;\n            if (!element.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            int modifiers = element.getModifiers();\n            if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)){\n                hasPublic=true;\n            } else {\n                hasPrivate=true;\n            }\n        }\n        if (hasPrivate && hasPublic) {\n            addError(\"Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden to avoid surprising behaviour. Renaming the private methods will solve the problem.\",node);\n        }\n    }","id":3184,"modified_method":"private void checkOverloadingPrivateAndPublic(MethodNode node) {\n        if (isConstructor(node)) return;\n        boolean hasPrivate = false;\n        boolean hasPublic = false;\n        for (MethodNode method : currentClass.getMethods(node.getName())) {\n            if (method == node) continue;\n            if (!method.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            int modifiers = method.getModifiers();\n            if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n                hasPublic = true;\n            } else {\n                hasPrivate = true;\n            }\n        }\n        if (hasPrivate && hasPublic) {\n            addError(\"Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden to avoid surprising behaviour. Renaming the private methods will solve the problem.\", node);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkImplementsAndExtends(ClassNode node) {\n        ClassNode cn = node.getSuperClass();\n        if (cn.isInterface() && !node.isInterface()) {\n            addError(\"You are not allowed to extend the \" + getDescription(cn) + \", use implements instead.\", node);\n        }\n        ClassNode[] interfaces = node.getInterfaces();\n        for (int i = 0; i < interfaces.length; i++) {\n            cn = interfaces[i];\n            if (!cn.isInterface()) {\n                addError(\"You are not allowed to implement the \" + getDescription(cn) + \", use extends instead.\", node);\n            }\n        }\n    }","id":3185,"modified_method":"private void checkImplementsAndExtends(ClassNode node) {\n        ClassNode cn = node.getSuperClass();\n        if (cn.isInterface() && !node.isInterface()) {\n            addError(\"You are not allowed to extend the \" + getDescription(cn) + \", use implements instead.\", node);\n        }\n        for (ClassNode anInterface : node.getInterfaces()) {\n            cn = anInterface;\n            if (!cn.isInterface()) {\n                addError(\"You are not allowed to implement the \" + getDescription(cn) + \", use extends instead.\", node);\n            }\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkMethodsForOverridingFinal(ClassNode cn) {\n        List methods = cn.getMethods();\n        for (Iterator cnIter = methods.iterator(); cnIter.hasNext();) {\n            MethodNode method = (MethodNode) cnIter.next();\n            Parameter[] params = method.getParameters();\n            List superMethods = cn.getSuperClass().getMethods(method.getName());\n            for (Iterator iter = superMethods.iterator(); iter.hasNext();) {\n                MethodNode superMethod = (MethodNode) iter.next();\n                Parameter[] superParams = superMethod.getParameters();\n                if (!hasEqualParameterTypes(params, superParams)) continue;\n                if (!Modifier.isFinal(superMethod.getModifiers())) break;\n                addInvalidUseOfFinalError(method, params, superMethod.getDeclaringClass());\n                return;\n            }\n        }\n    }","id":3186,"modified_method":"private void checkMethodsForOverridingFinal(ClassNode cn) {\n        for (MethodNode method : cn.getMethods()) {\n            Parameter[] params = method.getParameters();\n            for (MethodNode superMethod : cn.getSuperClass().getMethods(method.getName())) {\n                Parameter[] superParams = superMethod.getParameters();\n                if (!hasEqualParameterTypes(params, superParams)) continue;\n                if (!Modifier.isFinal(superMethod.getModifiers())) break;\n                addInvalidUseOfFinalError(method, params, superMethod.getDeclaringClass());\n                return;\n            }\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkRepetitiveMethod(MethodNode node) {\n        if (isConstructor(node)) return;\n        List methods = currentClass.getMethods(node.getName());\n        for (Iterator iter = methods.iterator(); iter.hasNext();) {\n            MethodNode element = (MethodNode) iter.next();\n            if (element == node) continue;\n            if (!element.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            Parameter[] p1 = node.getParameters();\n            Parameter[] p2 = element.getParameters();\n            if (p1.length != p2.length) continue;\n            addErrorIfParamsAndReturnTypeEqual(p2, p1, node, element);\n        }\n    }","id":3187,"modified_method":"private void checkRepetitiveMethod(MethodNode node) {\n        if (isConstructor(node)) return;\n        for (MethodNode method : currentClass.getMethods(node.getName())) {\n            if (method == node) continue;\n            if (!method.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            Parameter[] p1 = node.getParameters();\n            Parameter[] p2 = method.getParameters();\n            if (p1.length != p2.length) continue;\n            addErrorIfParamsAndReturnTypeEqual(p2, p1, node, method);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkMethodsForIncorrectModifiers(ClassNode cn) {\n        if (!cn.isInterface()) return;\n        List methods = cn.getMethods();\n        for (Iterator cnIter = methods.iterator(); cnIter.hasNext();) {\n            MethodNode method = (MethodNode) cnIter.next();\n            if (Modifier.isFinal(method.getModifiers())) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be final. It is by definition abstract.\", method);\n            }\n            if (Modifier.isStatic(method.getModifiers()) && !isConstructor(method)) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be static. Only fields may be static in an interface.\", method);\n            }\n        }\n    }","id":3188,"modified_method":"private void checkMethodsForIncorrectModifiers(ClassNode cn) {\n        if (!cn.isInterface()) return;\n        for (MethodNode method : cn.getMethods()) {\n            if (Modifier.isFinal(method.getModifiers())) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be final. It is by definition abstract.\", method);\n            }\n            if (Modifier.isStatic(method.getModifiers()) && !isConstructor(method)) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be static. Only fields may be static in an interface.\", method);\n            }\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkForInvalidDeclaration(Expression exp) {\n        if (!(exp instanceof DeclarationExpression)) return;\n        addError(\"invalid use of declartion inside method call.\",exp);\n    }","id":3189,"modified_method":"private void checkForInvalidDeclaration(Expression exp) {\n        if (!(exp instanceof DeclarationExpression)) return;\n        addError(\"Invalid use of declaration inside method call.\", exp);\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"public void visitGStringExpression(GStringExpression expression) {\n        super.visitGStringExpression(expression);\n        for (Iterator it = expression.getStrings().iterator(); it.hasNext();) {\n            checkStringExceedingMaximumLength((ConstantExpression) it.next());\n        }\n    }","id":3190,"modified_method":"public void visitGStringExpression(GStringExpression expression) {\n        super.visitGStringExpression(expression);\n        for (ConstantExpression ce : expression.getStrings()) {\n            checkStringExceedingMaximumLength(ce);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"public void visitMethodCallExpression(MethodCallExpression mce) {\n        super.visitMethodCallExpression(mce);\n        Expression aexp = mce.getArguments();\n        if (aexp instanceof TupleExpression) {\n            TupleExpression arguments = (TupleExpression) aexp;\n            for (Iterator it=arguments.getExpressions().iterator();it. hasNext();) {\n                checkForInvalidDeclaration((Expression) it.next());\n            }\n        } else {\n            checkForInvalidDeclaration(aexp);\n        }\n    }","id":3191,"modified_method":"public void visitMethodCallExpression(MethodCallExpression mce) {\n        super.visitMethodCallExpression(mce);\n        Expression aexp = mce.getArguments();\n        if (aexp instanceof TupleExpression) {\n            TupleExpression arguments = (TupleExpression) aexp;\n            for (Expression e : arguments.getExpressions()) {\n                checkForInvalidDeclaration(e);\n            }\n        } else {\n            checkForInvalidDeclaration(aexp);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"/**\n\t * Update the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  is the input stream of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the company's logo image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\t\t\n\t\tlong logoId = company.getLogoId();\n\t\t\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, is);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":3192,"modified_method":"/**\n\t * Update the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  is the input stream of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the company's logo image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), is);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  file the file of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\n\t\tlong logoId = company.getLogoId();\n\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, file);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":3193,"modified_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  file the file of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), file);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  bytes the bytes of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\n\t\tlong logoId = company.getLogoId();\n\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, bytes);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":3194,"modified_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  bytes the bytes of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), bytes);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Removes the activity interpreter from the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void deleteActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tString[] classNames = activityInterpreter.getClassNames();\n\n\t\tfor (String className : classNames) {\n\t\t\t_activityInterpreters.remove(className);\n\t\t}\n\t}","id":3195,"modified_method":"/**\n\t * Removes the activity interpreter from the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void deleteActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tif (activityInterpreter != null) {\n\t\t\tString[] classNames = activityInterpreter.getClassNames();\n\n\t\t\tfor (String className : classNames) {\n\t\t\t\t_activityInterpreters.remove(className);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d97c64e122d82f9121e5e75a2547d1d9996864e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialActivityFeedEntry interpret(\n\t\tSocialActivitySet activitySet, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(\n\t\t\tactivitySet.getClassNameId());\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(className);\n\n\t\tif (activityInterpreter != null) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activitySet, themeDisplay);\n\n\t\t\tif (activityFeedEntry != null) {\n\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\treturn activityFeedEntry;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":3196,"modified_method":"public SocialActivityFeedEntry interpret(\n\t\tSocialActivitySet activitySet, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(\n\t\t\t\tactivitySet.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activitySet, themeDisplay);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","commit_id":"d97c64e122d82f9121e5e75a2547d1d9996864e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @param  themeDisplay the theme display needed by interpreters to create\n\t *         links and get localized text fragments\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tSocialActivity activity, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(activity.getClassNameId());\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(className);\n\n\t\tif (activityInterpreter != null) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\tactivityInterpreter.interpret(activity, themeDisplay);\n\n\t\t\tif (activityFeedEntry != null) {\n\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\treturn activityFeedEntry;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":3197,"modified_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @param  themeDisplay the theme display needed by interpreters to create\n\t *         links and get localized text fragments\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tSocialActivity activity, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(\n\t\t\t\tactivity.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activity, themeDisplay);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","commit_id":"d97c64e122d82f9121e5e75a2547d1d9996864e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivitySet activitySet,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(\n\t\t\t\tactivitySet.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activitySet, serviceContext);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","id":3198,"modified_method":"public SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivitySet activitySet,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(\n\t\t\tactivitySet.getClassNameId());\n\n\t\tfor (int i = 0; i < activityInterpreters.size(); i++) {\n\t\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(i);\n\n\t\t\tif (activityInterpreter.hasClassName(className)) {\n\t\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activitySet, serviceContext);\n\n\t\t\t\tif (activityFeedEntry != null) {\n\t\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\t\treturn activityFeedEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivity activity,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(\n\t\t\t\tactivity.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activity, serviceContext);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","id":3199,"modified_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivity activity,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(activity.getClassNameId());\n\n\t\tfor (int i = 0; i < activityInterpreters.size(); i++) {\n\t\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(i);\n\n\t\t\tif (activityInterpreter.hasClassName(className)) {\n\t\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activity, serviceContext);\n\n\t\t\t\tif (activityFeedEntry != null) {\n\t\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\t\treturn activityFeedEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Adds the activity interpreter to the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void addActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tString[] classNames = activityInterpreter.getClassNames();\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\tnew HashMap<String, SocialActivityInterpreter>();\n\n\t\tfor (String className : classNames) {\n\t\t\tactivityInterpreters.put(className, activityInterpreter);\n\t\t}\n\n\t\t_activityInterpreters.put(\n\t\t\tactivityInterpreter.getSelector(), activityInterpreters);\n\t}","id":3200,"modified_method":"/**\n\t * Adds the activity interpreter to the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void addActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\tnew ArrayList<SocialActivityInterpreter>();\n\n\t\tactivityInterpreters.add(activityInterpreter);\n\n\t\t_activityInterpreters.put(\n\t\t\tactivityInterpreter.getSelector(), activityInterpreters);\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Removes the activity interpreter from the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void deleteActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tString[] classNames = activityInterpreter.getClassNames();\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(activityInterpreter.getSelector());\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String className : classNames) {\n\t\t\tactivityInterpreters.remove(className);\n\t\t}\n\t}","id":3201,"modified_method":"/**\n\t * Removes the activity interpreter from the list of available interpreters.\n\t *\n\t * @param activityInterpreter the activity interpreter\n\t */\n\tpublic void deleteActivityInterpreter(\n\t\tSocialActivityInterpreter activityInterpreter) {\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(activityInterpreter.getSelector());\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tactivityInterpreters.remove(activityInterpreter);\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Returns a selected user property, i.e. information about the currently\n     * logged in user, same as using \n     * the <code>&lt;cms:user property=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * @param property the user property to display, please see the tag documentation for valid options\n     * @return the value of the selected user property\n     * \n     * @see org.opencms.jsp.CmsJspTagUser\n     */\n    public String user(String property) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagUser.userTagAction(property, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return \"+++ error reading user property '\" + property + \"' +++\";\n    }","id":3202,"modified_method":"/**\n     * Returns a selected user property, i.e. information about the currently\n     * logged in user, same as using \n     * the <code>&lt;cms:user property=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * @param property the user property to display, please see the tag documentation for valid options\n     * @return the value of the selected user property\n     * \n     * @see org.opencms.jsp.CmsJspTagUser\n     */\n    public String user(String property) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagUser.userTagAction(property, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        CmsMessageContainer msgContainer = new CmsMessageContainer(\n            Messages.get(),\n            Messages.LOG_ERR_USER_PROP_READ_1,\n            new Object[] {property});\n        return this.getMessage(msgContainer);\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Calculate a link with the OpenCms link management,\n     * same as using the <code>&lt;cms:link&gt;...&lt;/cms:link&gt;<\/code> tag.<p>\n     * \n     * This is important to get the right link for exported resources, \n     * e.g. for images in the online project.\n     * \n     * @param link the uri in the OpenCms to link to\n     * @return the translated link\n     * \n     * @see org.opencms.jsp.CmsJspTagLink\n     */\n    public String link(String link) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagLink.linkTagAction(link, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return \"+++ error generating link to '\" + link + \"' +++\";\n    }","id":3203,"modified_method":"/**\n     * Calculate a link with the OpenCms link management,\n     * same as using the <code>&lt;cms:link&gt;...&lt;/cms:link&gt;<\/code> tag.<p>\n     * \n     * This is important to get the right link for exported resources, \n     * e.g. for images in the online project.\n     * \n     * @param link the uri in the OpenCms to link to\n     * @return the translated link\n     * \n     * @see org.opencms.jsp.CmsJspTagLink\n     */\n    public String link(String link) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagLink.linkTagAction(link, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        CmsMessageContainer msgContainer = new CmsMessageContainer(\n            Messages.get(),\n            Messages.LOG_ERR_GEN_LINK_0,\n            new Object[] {link});\n        return this.getMessage(msgContainer);\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns an OpenCms or JVM system info property value, same as using\n     * the <code>&lt;cms:info property=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * See the description of the class {@link CmsJspTagInfo} for a detailed list \n     * of available options for the property value.<p>\n     *  \n     * @param property the property to look up\n     * @return String the value of the system property\n     * @see org.opencms.jsp.CmsJspTagInfo\n     */\n    public String info(String property) {\n\n        try {\n            return CmsJspTagInfo.infoTagAction(property, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return \"+++ error reading info property '\" + property + \"' +++\";\n    }","id":3204,"modified_method":"/**\n     * Returns an OpenCms or JVM system info property value, same as using\n     * the <code>&lt;cms:info property=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * See the description of the class {@link CmsJspTagInfo} for a detailed list \n     * of available options for the property value.<p>\n     *  \n     * @param property the property to look up\n     * @return String the value of the system property\n     * @see org.opencms.jsp.CmsJspTagInfo\n     */\n    public String info(String property) {\n\n        try {\n            return CmsJspTagInfo.infoTagAction(property, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        CmsMessageContainer msgContainer = new CmsMessageContainer(\n            Messages.get(),\n            Messages.LOG_ERR_INFO_PROP_READ_1,\n            new Object[] {property});\n        return this.getMessage(msgContainer);\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a selected file property value with optional HTML escaping, same as using \n     * the <code>&lt;cms:property name=\"...\" file=\"...\" default=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * Please see the description of the class {@link org.opencms.jsp.CmsJspTagProperty} for\n     * valid options of the <code>file<\/code> parameter.<p>\n     * \n     * @param name the name of the property to look for\n     * @param file the file (or folder) to look at for the property\n     * @param defaultValue a default value in case the property was not found\n     * @param escapeHtml if <code>true<\/code>, special HTML characters in the return value\n     *     are escaped with their number representations (e.g. &amp; becomes &amp;#38;)\n     * @return the value of the property found, or the value of defaultValue \n     *     if the property could not be found\n     *\n     * @see org.opencms.jsp.CmsJspTagProperty\n     */\n    public String property(String name, String file, String defaultValue, boolean escapeHtml) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            if (file == null) {\n                file = getController().getCmsObject().getRequestContext().getUri();\n            }\n            return CmsJspTagProperty.propertyTagAction(name, file, defaultValue, escapeHtml, getRequest());\n        } catch (CmsSecurityException e) {\n            if (defaultValue == null) {\n                handleException(e);\n            }\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        if (defaultValue == null) {\n            return \"+++ file property '\" + name + \"' on '\" + file + \"' not found +++\";\n        } else {\n            return defaultValue;\n        }\n    }","id":3205,"modified_method":"/**\n     * Returns a selected file property value with optional HTML escaping, same as using \n     * the <code>&lt;cms:property name=\"...\" file=\"...\" default=\"...\" /&gt;<\/code> tag.<p>\n     * \n     * Please see the description of the class {@link org.opencms.jsp.CmsJspTagProperty} for\n     * valid options of the <code>file<\/code> parameter.<p>\n     * \n     * @param name the name of the property to look for\n     * @param file the file (or folder) to look at for the property\n     * @param defaultValue a default value in case the property was not found\n     * @param escapeHtml if <code>true<\/code>, special HTML characters in the return value\n     *     are escaped with their number representations (e.g. &amp; becomes &amp;#38;)\n     * @return the value of the property found, or the value of defaultValue \n     *     if the property could not be found\n     *\n     * @see org.opencms.jsp.CmsJspTagProperty\n     */\n    public String property(String name, String file, String defaultValue, boolean escapeHtml) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            if (file == null) {\n                file = getController().getCmsObject().getRequestContext().getUri();\n            }\n            return CmsJspTagProperty.propertyTagAction(name, file, defaultValue, escapeHtml, getRequest());\n        } catch (CmsSecurityException e) {\n            if (defaultValue == null) {\n                handleException(e);\n            }\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        if (defaultValue == null) {\n            CmsMessageContainer msgContainer = new CmsMessageContainer(\n                Messages.get(),\n                Messages.LOG_ERR_FILE_PROP_MISSING_2,\n                new Object[] {name, file});\n            return this.getMessage(msgContainer);\n        } else {\n            return defaultValue;\n        }\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns an initialized {@link CmsJspNavBuilder} instance.<p>\n     *  \n     * @return CmsJspNavBuilder an initialized <code>CmsJspNavBuilder<\/code>\n     * \n     * @see org.opencms.jsp.CmsJspNavBuilder\n     */\n    public CmsJspNavBuilder getNavigation() {\n\n        if (isNotInitialized()) {\n            return null;\n        }\n        try {\n            if (m_navigation == null) {\n                m_navigation = new CmsJspNavBuilder(getController().getCmsObject());\n            }\n            return m_navigation;\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return null;\n    }","id":3206,"modified_method":"/**\n     * Returns an initialized {@link CmsJspNavBuilder} instance.<p>\n     *  \n     * @return CmsJspNavBuilder an initialized <code>CmsJspNavBuilder<\/code>\n     * \n     * @see org.opencms.jsp.CmsJspNavBuilder\n     */\n    public CmsJspNavBuilder getNavigation() {\n\n        if (isNotInitialized()) {\n            return null;\n        }\n        if (m_navigation == null) {\n            m_navigation = new CmsJspNavBuilder(getController().getCmsObject());\n        }\n        return m_navigation;\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns an OpenCms workplace label.<p>\n     * \n     * You should consider using a standard \n     * {@link java.util.ResourceBundle java.util.ResourceBundle} instead of the \n     * OpenCms workplace language files.\n     * \n     * @param label the label to look up\n     * @return label the value of the label\n     * \n     * @see org.opencms.jsp.CmsJspTagLabel\n     */\n    public String label(String label) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagLabel.wpLabelTagAction(label, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return \"+++ error reading workplace label '\" + label + \"' +++\";\n    }","id":3207,"modified_method":"/**\n     * Returns an OpenCms workplace label.<p>\n     * \n     * You should consider using a standard \n     * {@link java.util.ResourceBundle java.util.ResourceBundle} instead of the \n     * OpenCms workplace language files.\n     * \n     * @param label the label to look up\n     * @return label the value of the label\n     * \n     * @see org.opencms.jsp.CmsJspTagLabel\n     */\n    public String label(String label) {\n\n        if (isNotInitialized()) {\n            return C_NOT_INITIALIZED;\n        }\n        try {\n            return CmsJspTagLabel.wpLabelTagAction(label, getRequest());\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        CmsMessageContainer msgContainer = new CmsMessageContainer(\n            Messages.get(),\n            Messages.LOG_ERR_WORKPL_LABEL_READ_1,\n            new Object[] {label});\n        return this.getMessage(msgContainer);\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the CmsObject from the wrapped request.<p>\n     *\n     * This is a convenience method in case you need access to\n     * the CmsObject in your JSP scriplets.\n     *\n     * @return the CmsObject from the wrapped request\n     */\n    public CmsObject getCmsObject() {\n\n        if (m_isNotInitialized) {\n            return null;\n        }\n        try {\n            return m_controller.getCmsObject();\n        } catch (Throwable t) {\n            handleException(t);\n        }\n        return null;\n    }","id":3208,"modified_method":"/**\n     * Returns the CmsObject from the wrapped request.<p>\n     *\n     * This is a convenience method in case you need access to\n     * the CmsObject in your JSP scriplets.\n     *\n     * @return the CmsObject from the wrapped request\n     */\n    public CmsObject getCmsObject() {\n\n        if (m_isNotInitialized) {\n            return null;\n        }\n        return m_controller.getCmsObject();\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Handles any exception that might occur in the context of this element to \n     * ensure that templates are not disturbed.<p>\n     * \n     * @param t the Throwable that was catched\n     */\n    protected void handleException(Throwable t) {\n\n        if (OpenCms.getLog(this).isErrorEnabled()) {\n            OpenCms.getLog(this).error(\"Error in JSP bean\", t);\n        }\n        if (!(m_isSupressingExceptions || getRequestContext().currentProject().isOnlineProject())) {\n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"Interrupted Exception in \" + this.getClass().getName(), t);\n            }\n            String uri = null;\n            Throwable u = getController().getThrowable();\n            if (u != null) {\n                uri = getController().getThrowableResourceUri();\n            } else {\n                u = t;\n            }\n            throw new RuntimeException(\"Exception in \" + ((uri != null) ? uri : this.getClass().getName()), u);\n        }\n    }","id":3209,"modified_method":"/**\n     * Handles any exception that might occur in the context of this element to \n     * ensure that templates are not disturbed.<p>\n     * \n     * @param t the Throwable that was catched\n     */\n    protected void handleException(Throwable t) {\n\n        if (LOG.isErrorEnabled()) {\n            LOG.error(Messages.get().key(Messages.LOG_ERR_JSP_BEAN_0), t);\n        }\n        if (!(m_isSupressingExceptions || getRequestContext().currentProject().isOnlineProject())) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(Messages.get().key(Messages.LOG_DEBUG_INTERRUPTED_EXCEPTION_1, this.getClass().getName()), t);\n            }\n            String uri = null;\n            Throwable u = getController().getThrowable();\n            if (u != null) {\n                uri = getController().getThrowableResourceUri();\n            } else {\n                u = t;\n            }\n            throw new CmsRuntimeException(Messages.get().container(\n                \"ERR_RUNTIME\",\n                (uri != null) ? uri : this.getClass().getName()), t);\n        }\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initialize this bean with the current page context, request and response.<p>\n     * \n     * It is required to call one of the init() methods before you can use the \n     * instance of this bean.\n     * \n     * @param context the JSP page context object\n     * @param req the JSP request \n     * @param res the JSP response \n     */\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        m_controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        if (m_controller == null) {\n            // controller not found - this request was not initialized properly\n            throw new RuntimeException(this.getClass().getName() + \" is usable only on a OpenCms controlled JSP page\");\n        }\n        m_context = context;\n        m_request = req;\n        m_response = res;\n        m_isNotInitialized = false;\n    }","id":3210,"modified_method":"/**\n     * Initialize this bean with the current page context, request and response.<p>\n     * \n     * It is required to call one of the init() methods before you can use the \n     * instance of this bean.\n     * \n     * @param context the JSP page context object\n     * @param req the JSP request \n     * @param res the JSP response \n     */\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        m_controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        if (m_controller == null) {\n            // controller not found - this request was not initialized properly\n            throw new CmsRuntimeException(Messages.get().container(\n                \"ERR_MISSING_CMS_CONTROLLER\",\n                CmsJspBean.class.getName()));\n        }\n        m_context = context;\n        m_request = req;\n        m_response = res;\n        m_isNotInitialized = false;\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Logs a system user in to OpenCms.<p>\n     * \n     * @param username the users name\n     * @param password the password\n     * @param login_project the project to switch to after login (if null project is not switched)\n     * @param login_redirect the URI to redirect to after login (if null the current URI is used)\n     * \n     * @throws IOException in case redirect after login was not successful\n     */\n    public void login(String username, String password, String login_project, String login_redirect) throws IOException {\n\n        HttpSession session = null;\n        m_loginException = null;\n        try {\n            // login the user and create a new session\n            getCmsObject().loginUser(\n                username,\n                password,\n                getRequestContext().getRemoteAddress(),\n                I_CmsConstants.C_USER_TYPE_SYSTEMUSER);\n            // make sure we have a new session after login for security reasons\n            session = getRequest().getSession(false);\n            if (session != null) {\n                session.invalidate();\n            }\n            session = getRequest().getSession(true);\n            if (login_project != null) {\n                getCmsObject().getRequestContext().setCurrentProject(getCmsObject().readProject(login_project));\n            }\n        } catch (CmsException e) {\n            // any exception here indicates that the login has failed\n            m_loginException = e;\n            if (session != null) {\n                session.invalidate();\n            }\n        }\n        if (m_loginException == null) {\n            // login was successful\n            if (OpenCms.getLog(CmsJspLoginBean.class).isInfoEnabled()) {\n                OpenCms.getLog(CmsJspLoginBean.class).info(\n                    \"Login of user '\"\n                        + username\n                        + \"' on page \"\n                        + getRequestContext().addSiteRoot(getRequestContext().getUri()));\n            }\n            if (login_redirect != null) {\n                getResponse().sendRedirect(link(login_redirect));\n            } else {\n                getResponse().sendRedirect(getFormLink());\n            }\n        } else {\n            // login was not successful\n            if (OpenCms.getLog(CmsJspLoginBean.class).isWarnEnabled()) {\n                OpenCms.getLog(CmsJspLoginBean.class).warn(\n                    \"Failed login attempt for user '\"\n                        + username\n                        + \"' on page \"\n                        + getRequestContext().addSiteRoot(getRequestContext().getUri()));\n            }\n        }\n    }","id":3211,"modified_method":"/**\n     * Logs a system user in to OpenCms.<p>\n     * \n     * @param username the users name\n     * @param password the password\n     * @param login_project the project to switch to after login (if null project is not switched)\n     * @param login_redirect the URI to redirect to after login (if null the current URI is used)\n     * \n     * @throws IOException in case redirect after login was not successful\n     */\n    public void login(String username, String password, String login_project, String login_redirect) throws IOException {\n\n        HttpSession session = null;\n        m_loginException = null;\n        try {\n            // login the user and create a new session\n            getCmsObject().loginUser(\n                username,\n                password,\n                getRequestContext().getRemoteAddress(),\n                I_CmsConstants.C_USER_TYPE_SYSTEMUSER);\n            // make sure we have a new session after login for security reasons\n            session = getRequest().getSession(false);\n            if (session != null) {\n                session.invalidate();\n            }\n            session = getRequest().getSession(true);\n            if (login_project != null) {\n                getCmsObject().getRequestContext().setCurrentProject(getCmsObject().readProject(login_project));\n            }\n        } catch (CmsException e) {\n            // any exception here indicates that the login has failed\n            m_loginException = e;\n            if (session != null) {\n                session.invalidate();\n            }\n        }\n        if (m_loginException == null) {\n            // login was successful\n            if (LOG.isInfoEnabled()) {\n                LOG.info(Messages.get().key(\n                    Messages.LOG_LOGIN_SUCCESSFUL_2,\n                    username,\n                    getRequestContext().addSiteRoot(getRequestContext().getUri())));\n            }\n            if (login_redirect != null) {\n                getResponse().sendRedirect(link(login_redirect));\n            } else {\n                getResponse().sendRedirect(getFormLink());\n            }\n        } else {\n            // login was not successful\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(Messages.get().key(\n                    Messages.LOG_LOGIN_FAILED_2,\n                    username,\n                    getRequestContext().addSiteRoot(getRequestContext().getUri())));\n            }\n        }\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Logs a user out, i.e. destroys the current users session,\n     * after that the current page will be redirected it itself one time to ensure\n     * the users session is truly destroyed.<p>\n     * \n     * @throws IOException if redirect after logout fails\n     */\n    public void logout() throws IOException {\n\n        HttpSession session = getRequest().getSession(false);\n        if (session != null) {\n            session.invalidate();\n        }\n        // login was successful\n        if (OpenCms.getLog(CmsJspLoginBean.class).isDebugEnabled()) {\n            OpenCms.getLog(CmsJspLoginBean.class).debug(\n                \"Logout of user '\"\n                    + getUserName()\n                    + \"' on page \"\n                    + getRequestContext().addSiteRoot(getRequestContext().getUri()));\n        }\n        getResponse().sendRedirect(getFormLink());\n    }","id":3212,"modified_method":"/**\n     * Logs a user out, i.e. destroys the current users session,\n     * after that the current page will be redirected it itself one time to ensure\n     * the users session is truly destroyed.<p>\n     * \n     * @throws IOException if redirect after logout fails\n     */\n    public void logout() throws IOException {\n\n        HttpSession session = getRequest().getSession(false);\n        if (session != null) {\n            session.invalidate();\n        }\n        // logout was successful\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(Messages.get().key(\n                Messages.LOG_LOGOUT_SUCCESFUL_2,\n                getRequestContext().addSiteRoot(getRequestContext().getUri())));\n        }\n        getResponse().sendRedirect(getFormLink());\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns all subfolders of a channel, or an empty array if \n     * the folder does not exist or has no subfolders.<p>\n     * \n     * @param cms context provider for the current request\n     * @param channel the channel to look for subfolders in\n     * @return an unsorted list of CmsResources\n     */\n    public static List getChannelSubFolders(CmsObject cms, String channel) {\n\n        if (!channel.startsWith(\"/\")) {\n            channel = \"/\" + channel;\n        }\n        if (!channel.endsWith(\"/\")) {\n            channel += \"/\";\n        }\n\n        // Now read all subchannels of this channel    \n        List subChannels = new ArrayList();\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(I_CmsConstants.VFS_FOLDER_CHANNELS);\n            subChannels = cms.getSubFolders(channel);\n        } catch (Exception e) {\n            System.err.println(\"Exception: \" + e);\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        // Create an ArrayList out of the Vector        \n        java.util.ArrayList list = new java.util.ArrayList(subChannels.size());\n        list.addAll(subChannels);\n        return list;\n    }","id":3213,"modified_method":"/**\n     * Returns all subfolders of a channel, or an empty array if \n     * the folder does not exist or has no subfolders.<p>\n     * \n     * @param cms context provider for the current request\n     * @param channel the channel to look for subfolders in\n     * @return an unsorted list of CmsResources\n     */\n    public static List getChannelSubFolders(CmsObject cms, String channel) {\n\n        if (!channel.startsWith(\"/\")) {\n            channel = \"/\" + channel;\n        }\n        if (!channel.endsWith(\"/\")) {\n            channel += \"/\";\n        }\n\n        // Now read all subchannels of this channel    \n        List subChannels = new ArrayList();\n        cms.getRequestContext().saveSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(I_CmsConstants.VFS_FOLDER_CHANNELS);\n            subChannels = cms.getSubFolders(channel);\n        } catch (CmsException e) {\n            if (LOG.isErrorEnabled()) {\n                // will be localized if the CmsException was constructoed localized.\n                LOG.error(e.getLocalizedMessage());\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n\n        // Create an ArrayList out of the Vector        \n        java.util.ArrayList list = new java.util.ArrayList(subChannels.size());\n        list.addAll(subChannels);\n        return list;\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Internal action method to show an element from a XML content document.<p>\n     * \n     * @param content the XML content to show the element from\n     * @param element the node name of the element to show\n     * @param locale the locale of the element to show\n     * @param req the current request \n     * \n     * @return the value of the selected content element\n     */\n    public static String contentShowTagAction(\n        A_CmsXmlDocument content,\n        String element,\n        Locale locale,\n        ServletRequest req) {\n\n        if (content == null) {\n            // no content was loaded\n            return null;\n        }\n\n        if (content.hasValue(element, locale)) {\n\n            // selected element is available in content\n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            CmsObject cms = controller.getCmsObject();\n\n            try {\n                // read the element from the content\n                return content.getStringValue(cms, element, locale);\n            } catch (CmsXmlException e) {\n                OpenCms.getLog(CmsJspTagContentShow.class).error(\"Error processing content element '\" + element, e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }","id":3214,"modified_method":"/**\n     * Internal action method to show an element from a XML content document.<p>\n     * \n     * @param content the XML content to show the element from\n     * @param element the node name of the element to show\n     * @param locale the locale of the element to show\n     * @param req the current request \n     * \n     * @return the value of the selected content element\n     */\n    public static String contentShowTagAction(\n        A_CmsXmlDocument content,\n        String element,\n        Locale locale,\n        ServletRequest req) {\n\n        if (content == null) {\n            // no content was loaded\n            return null;\n        }\n\n        if (content.hasValue(element, locale)) {\n\n            // selected element is available in content\n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            CmsObject cms = controller.getCmsObject();\n\n            try {\n                // read the element from the content\n                return content.getStringValue(cms, element, locale);\n            } catch (CmsXmlException e) {\n                LOG.error(Messages.get().key(Messages.LOG_ERR_CONTENT_SHOW_1, element), e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // initialize a string mapper to resolve EL like strings in tag attributes\n        CmsFlexController controller = \n            (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        CmsObject cms = controller.getCmsObject();\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n\n        String element = getElement();\n\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        } else {\n            element = CmsXmlUtils.concatXpath(contentContainer.getXmlDocumentElement(), element);\n        }\n\n        String content;\n        if (CmsMacroResolver.isMacro(element)) {\n            // this is a macro, initialize a macro resolver\n            String resourcename = CmsJspTagContentLoad.getResourceName(cms, contentContainer);\n            CmsMacroResolver resolver = CmsMacroResolver.newInstance()\n                .setCmsObject(cms)\n                .setJspPageContext(pageContext)\n                .setResourceName(resourcename)            \n                .setKeepEmptyMacros(true);\n            // resolve the macro\n            content = resolver.resolveMacros(element);\n        } else if (xmlContent == null) {\n            // no XML content- no output\n            content = null;\n        } else {\n\n            // now get the content element value to display\n            content = contentShowTagAction(xmlContent, element, locale, pageContext.getRequest());\n\n            // make sure that no null String is returned\n            if (content == null) {\n                content = CmsMessages.formatUnknownKey(element);\n            }\n        }\n\n        try {\n            if (content != null) {\n                pageContext.getOut().print(content);\n            }\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error in Jsp <contentshow> tag processing\", e);\n            }\n            throw new JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","id":3215,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // initialize a string mapper to resolve EL like strings in tag attributes\n        CmsFlexController controller = (CmsFlexController)pageContext.getRequest().getAttribute(\n            CmsFlexController.ATTRIBUTE_NAME);\n        CmsObject cms = controller.getCmsObject();\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n\n        String element = getElement();\n\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        } else {\n            element = CmsXmlUtils.concatXpath(contentContainer.getXmlDocumentElement(), element);\n        }\n\n        String content;\n        if (CmsMacroResolver.isMacro(element)) {\n            // this is a macro, initialize a macro resolver\n            String resourcename = CmsJspTagContentLoad.getResourceName(cms, contentContainer);\n            CmsMacroResolver resolver = CmsMacroResolver.newInstance().setCmsObject(cms).setJspPageContext(pageContext)\n                .setResourceName(resourcename).setKeepEmptyMacros(true);\n            // resolve the macro\n            content = resolver.resolveMacros(element);\n        } else if (xmlContent == null) {\n            // no XML content- no output\n            content = null;\n        } else {\n\n            // now get the content element value to display\n            content = contentShowTagAction(xmlContent, element, locale, pageContext.getRequest());\n\n            // make sure that no null String is returned\n            if (content == null) {\n                content = CmsMessages.formatUnknownKey(element);\n            }\n        }\n\n        try {\n            if (content != null) {\n                pageContext.getOut().print(content);\n            }\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                LOG.error(Messages.get().key(Messages.LOG_ERR_JSP_BEAN_0), e);\n            }\n            throw new JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","commit_id":"ad6c3d3d8c50f15998fc9ca5ae82c2f2691e7216","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void readProcessStatusFile(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/status\";\n      _processStatus = readFile(new File(s));\n    }\n    catch (Exception ignore) {}\n  }","id":3216,"modified_method":"private static String readProcessStatusFile(int pid) {\n    try { return pid== -1 ? null : readFile(new File(\"/proc/\"+pid+\"/status\")); }\n    catch( IOException ignore ) { return null; }\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @param s String containing contents of proc file.\n   */\n  private void parseSystemProcFile(String s) {\n    if (s == null) return;\n\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      String line = reader.readLine();\n\n      // Read aggregate cpu values\n      {\n        Pattern p = Pattern.compile(\"cpu\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+).*\");\n        Matcher m = p.matcher(line);\n        boolean b = m.matches();\n        if (!b) {\n          return;\n        }\n\n        int matchGroupBase = 0;\n        long systemUserTicks = 0;\n        long systemSystemTicks = 0;\n        long systemOtherTicks = 0;\n        _systemIdleTicks = 0;\n        systemUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        systemOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        _systemIdleTicks   += Long.parseLong(m.group(4 + matchGroupBase));\n        systemOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        _systemTotalTicks   = systemUserTicks + systemOtherTicks + systemSystemTicks + _systemIdleTicks;\n      }\n\n      // Read individual cpu values\n      _cpuTicks = new ArrayList<long[]>();\n      line = reader.readLine();\n      while (line != null) {\n        Pattern p = Pattern.compile(\"cpu(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+).*\");\n        Matcher m = p.matcher(line);\n        boolean b = m.matches();\n        if (! b) {\n          break;\n        }\n\n        // Copying algorithm from http://gee.cs.oswego.edu/dl/code/\n        // See perfbar.c in gtk_perfbar package.\n        // int cpuNum = Integer.parseInt(m.group(1));\n        int matchGroupBase = 1;\n        long cpuUserTicks = 0;\n        long cpuSystemTicks = 0;\n        long cpuOtherTicks = 0;\n        long cpuIdleTicks = 0;\n        cpuUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        cpuIdleTicks    += Long.parseLong(m.group(4 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        long[] oneCpuTicks = {cpuUserTicks, cpuSystemTicks, cpuOtherTicks, cpuIdleTicks};\n        _cpuTicks.add(oneCpuTicks);\n\n        line = reader.readLine();\n      }\n    }\n    catch (Exception ignore) {}\n  }","id":3217,"modified_method":"/** @param s String containing contents of proc file. */\n  private static void parseSystemProcFile(String s) {\n    if (s == null) return;\n    BufferedReader reader = new BufferedReader(new StringReader(s));\n    try {\n      // Read aggregate cpu values\n      String line = reader.readLine();\n      Matcher m = sysTicksPattern.matcher(line);\n      if( !m.matches() ) return;\n\n      int matchGroupBase = 0;\n      long systemUserTicks = 0;\n      long systemSystemTicks = 0;\n      long systemOtherTicks = 0;\n      systemUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n      systemOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n      _systemIdleTicks    = Long.parseLong(m.group(4 + matchGroupBase));\n      systemOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n      _systemTotalTicks   = systemUserTicks + systemOtherTicks + systemSystemTicks + _systemIdleTicks;\n\n      // Read individual cpu values\n      int cpu = 0;\n      line = reader.readLine();\n      while (line != null) {\n        m = cpuTicksPattern.matcher(line);\n        if( !m.matches() ) break;\n        // Copying algorithm from http://gee.cs.oswego.edu/dl/code/\n        // See perfbar.c in gtk_perfbar package.\n        // int cpuNum = Integer.parseInt(m.group(1));\n        matchGroupBase = 1;\n        long cpuUserTicks = 0;\n        long cpuSystemTicks = 0;\n        long cpuOtherTicks = 0;\n        long cpuIdleTicks = 0;\n        cpuUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        cpuIdleTicks    += Long.parseLong(m.group(4 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        CPUTICKS[cpu][0] = cpuUserTicks;\n        CPUTICKS[cpu][1] = cpuSystemTicks;\n        CPUTICKS[cpu][2] = cpuOtherTicks;\n        CPUTICKS[cpu][3] = cpuIdleTicks;\n        cpu++;\n        line = reader.readLine();\n      }\n    } catch( IOException ignore ) {/**/}\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private String readFile(File f) throws Exception {\n    char[] buffer = new char[16 * 1024];\n    FileReader fr = new FileReader(f);\n    int bytesRead = 0;\n    while (true) {\n      int n = fr.read(buffer, bytesRead, buffer.length - bytesRead);\n      if (n < 0) {\n        fr.close();\n        return new String (buffer, 0, bytesRead);\n      }\n      else if (n == 0) {\n        // This is weird.\n        fr.close();\n        throw new Exception(\"LinuxProcFileReader readFile read 0 bytes\");\n      }\n\n      bytesRead += n;\n\n      if (bytesRead >= buffer.length) {\n        fr.close();\n        throw new Exception(\"LinuxProcFileReader readFile unexpected buffer full\");\n      }\n    }\n  }","id":3218,"modified_method":"private static String readFile(File f) throws IOException {\n    int bytesRead = 0;\n    try(FileReader fr = new FileReader(f)) {\n        synchronized(buffer) {\n          while (true) {\n            int n = fr.read(buffer, bytesRead, buffer.length - bytesRead);\n            if( n < 0 ) return new String(buffer, 0, bytesRead);\n            bytesRead += n;\n            if( bytesRead >= buffer.length ) throw new IOException(\"LinuxProcFileReader readFile unexpected buffer full\");\n          }\n        }\n    }\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of CPUs allowed by this process.\n   */\n  public int getProcessCpusAllowed() {\n    if (! IS_OS_LINUX()) {\n      return Runtime.getRuntime().availableProcessors();\n    }\n\n    // _processCpusAllowed is not available on CentOS 5 and earlier.\n    // In this case, just return availableProcessors.\n    if (_processCpusAllowed < 0) {\n      return Runtime.getRuntime().availableProcessors();\n    }\n\n    return _processCpusAllowed;\n  }","id":3219,"modified_method":"/** @return number of CPUs allowed by this process. */\n  public static char getProcessCpusAllowed() { return PROCESS_CPUS_ALLOWED; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void parseProcessStatusFile(String s) {\n    if(s == null) return;\n    try {\n      Pattern p = Pattern.compile(\"Cpus_allowed:\\\\s+([A-Fa-f0-9,]+)\");\n      Matcher m = p.matcher(s);\n      boolean b = m.find();\n      if (! b) {\n        return;\n      }\n      _processCpusAllowed = numSetBitsHex(m.group(1));\n    }\n    catch (Exception ignore) {}\n  }","id":3220,"modified_method":"private static char parseProcessStatusFile(String s) {\n    char cpus = (char) Runtime.getRuntime().availableProcessors();\n    if(s == null) return cpus;\n    try {\n      Matcher m = Pattern.compile(\"Cpus_allowed:\\\\s+([A-Fa-f0-9,]+)\").matcher(s);\n      return m.find() ? numSetBitsHex(m.group(1)) : cpus;\n    }\n    catch( Exception ignore ) { return cpus; }\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return true if all the values are ok to use; false otherwise.\n   */\n  public boolean valid() {\n    return ((_systemIdleTicks >= 0) && (_systemTotalTicks >= 0) && (_processTotalTicks >= 0) &&\n            (_processNumOpenFds >= 0));\n  }","id":3221,"modified_method":"/** @return true if all the values are ok to use; false otherwise. */\n  private static boolean valid() {\n    return _systemIdleTicks >= 0 && _systemTotalTicks >= 0 && _processTotalTicks >= 0 && _processNumOpenFds >= 0;\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of set bits in hexadecimal string (chars must be 0-F)\n   */\n  public static int numSetBitsHex(String s) {\n    // Look-up table for num set bits in 4-bit char\n    final int[] bits_set = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n\n    int nset = 0;\n    for(int i = 0; i < s.length(); i++) {\n      Character ch = s.charAt(i);\n      if (ch == ',') {\n        continue;\n      }\n      int x = Integer.parseInt(ch.toString(), 16);\n      nset += bits_set[x];\n    }\n    return nset;\n  }","id":3222,"modified_method":"/** @return number of set bits in hexadecimal string (chars must be 0-F) */\n  private static char numSetBitsHex(String s) {\n    // Look-up table for num set bits in 4-bit char\n    final int[] bits_set = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n    char nset = 0;\n    for(int i = 0; i < s.length(); i++) {\n      Character ch = s.charAt(i);\n      if (ch == ',') continue;\n      int x = Integer.parseInt(ch.toString(), 16);\n      nset += bits_set[x];\n    }\n    return nset;\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readProcessNumOpenFds(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/fd\";\n      File f = new File(s);\n      String[] arr = f.list();\n      if (arr != null) {\n        _processNumOpenFds = arr.length;\n      }\n    }\n    catch (Exception ignore) {}\n  }","id":3223,"modified_method":"private static void readProcessNumOpenFds(int pid) {\n    if( pid == -1 ) return;\n    String[] arr = new File(\"/proc/\" + pid + \"/fd\").list();\n    _processNumOpenFds = arr == null ? 0 : arr.length;\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readProcessProcFile(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/stat\";\n      _processData = readFile(new File(s));\n    }\n    catch (Exception ignore) {}\n  }","id":3224,"modified_method":"private static String readProcessProcFile(int pid) {\n    try { return pid == -1 ? null : readFile(new File(\"/proc/\"+pid+\"/stat\")); }\n    catch( IOException ignore ) { return null; }\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static String getProcessId() throws Exception {\n    // Note: may fail in some JVM implementations\n    // therefore fallback has to be provided\n\n    // something like '<pid>@<hostname>', at least in SUN / Oracle JVMs\n    final String jvmName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();\n    final int index = jvmName.indexOf('@');\n\n    if (index < 1) {\n      // part before '@' empty (index = 0) / '@' not found (index = -1)\n      throw new Exception (\"Can't get process Id\");\n    }\n\n    return Long.toString(Long.parseLong(jvmName.substring(0, index)));\n  }","id":3225,"modified_method":"private static int getProcessIdFromJMX() {\n    // Note: may fail in some JVM implementations therefore fallback has to be provided.\n    // Something like '<pid>@<hostname>', at least in SUN / Oracle JVMs\n    final String jvmName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();\n    final int index = jvmName.indexOf('@');\n    return index < 1 ? -1 // part before '@' empty (index = 0) / '@' not found (index = -1)\n      : Integer.parseInt(jvmName.substring(0, index));\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks this process was running.\n   */\n  public long getProcessTotalTicks() { assert _processTotalTicks > 0;  return _processTotalTicks; }","id":3226,"modified_method":"/** @return ticks this process was running. */\n  public static long getProcessTotalTicks() { return _processTotalTicks; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks the system was idle.  in general:  idle + busy == 100%\n   */\n  public long getSystemIdleTicks()   { assert _systemIdleTicks > 0;    return _systemIdleTicks; }","id":3227,"modified_method":"/** @return ticks the system was idle.  in general:  idle + busy == 100% */\n  public static long getSystemIdleTicks() { return _systemIdleTicks; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return resident set size (RSS) of this process.\n   */\n  public long getProcessRss()        { assert _processRss > 0;         return _processRss; }","id":3228,"modified_method":"/** @return resident set size (RSS) of this process. */\n  public static long getProcessRss() { return _processRss; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readSystemProcFile() {\n    try {\n      _systemData = readFile(new File(\"/proc/stat\"));\n    }\n    catch (Exception ignore) {}\n  }","id":3229,"modified_method":"private static String readSystemProcFile() {\n    try { return readFile(new File(\"/proc/stat\")); }\n    catch( IOException ignore ) { return null; }\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Array of ticks.\n   * [cpu number][tick type]\n   *\n   * tick types are:\n   *\n   * [0] user ticks\n   * [1] system ticks\n   * [2] other ticks (i/o)\n   * [3] idle ticks\n   *\n   * @return ticks array for each cpu of the system.\n   */\n  public long[][] getCpuTicks()      { assert _cpuTicks != null;       return _cpuTicks.toArray(new long[0][0]); }","id":3230,"modified_method":"/**  Array of ticks:  [cpu number][tick type]\n   *\n   * tick types are:\n   * [0] user ticks\n   * [1] system ticks\n   * [2] other ticks (i/o)\n   * [3] idle ticks\n   *\n   * @return ticks array for each cpu of the system.\n   */\n  public static long[][] getCpuTicks() { return CPUTICKS; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of currently open fds of this process.\n   */\n  public int getProcessNumOpenFds() { assert _processNumOpenFds > 0;  return _processNumOpenFds; }","id":3231,"modified_method":"/** @return number of currently open fds of this process.  */\n  public static int getProcessNumOpenFds() { return _processNumOpenFds; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Main is purely for command-line testing.\n   */\n  public static void main(String[] args) {\n    final String sysTestData =\n            \"cpu  43559117 24094 1632164 1033740407 245624 29 200080 0 0 0\\n\"+\n                    \"cpu0 1630761 1762 62861 31960072 40486 15 10614 0 0 0\\n\"+\n                    \"cpu1 1531923 86 62987 32118372 13190 0 6806 0 0 0\\n\"+\n                    \"cpu2 1436788 332 66513 32210723 10867 0 6772 0 0 0\\n\"+\n                    \"cpu3 1428700 1001 64574 32223156 8751 0 6811 0 0 0\\n\"+\n                    \"cpu4 1424410 152 62649 32232602 6552 0 6836 0 0 0\\n\"+\n                    \"cpu5 1427172 1478 58744 32233938 5471 0 6708 0 0 0\\n\"+\n                    \"cpu6 1418433 348 60957 32241807 5301 0 6639 0 0 0\\n\"+\n                    \"cpu7 1404882 182 60640 32258150 3847 0 6632 0 0 0\\n\"+\n                    \"cpu8 1485698 3593 67154 32101739 38387 0 9016 0 0 0\\n\"+\n                    \"cpu9 1422404 1601 66489 32193865 15133 0 8800 0 0 0\\n\"+\n                    \"cpu10 1383939 3386 69151 32233567 11219 0 8719 0 0 0\\n\"+\n                    \"cpu11 1376904 3051 65256 32246197 8307 0 8519 0 0 0\\n\"+\n                    \"cpu12 1381437 1496 68003 32237894 6966 0 8676 0 0 0\\n\"+\n                    \"cpu13 1376250 1527 66598 32247951 7020 0 8554 0 0 0\\n\"+\n                    \"cpu14 1364352 1573 65520 32262764 5093 0 8531 0 0 0\\n\"+\n                    \"cpu15 1359076 1176 64380 32269336 5219 0 8593 0 0 0\\n\"+\n                    \"cpu16 1363844 6 29612 32344252 4830 2 4366 0 0 0\\n\"+\n                    \"cpu17 1477797 1019 70211 32190189 6278 0 3731 0 0 0\\n\"+\n                    \"cpu18 1285849 30 29219 32428612 3549 0 3557 0 0 0\\n\"+\n                    \"cpu19 1272308 0 27306 32445340 2089 0 3541 0 0 0\\n\"+\n                    \"cpu20 1326369 5 29152 32386824 2458 0 4416 0 0 0\\n\"+\n                    \"cpu21 1320883 28 31886 32384709 2327 1 4869 0 0 0\\n\"+\n                    \"cpu22 1259498 1 26954 32458931 2247 0 3511 0 0 0\\n\"+\n                    \"cpu23 1279464 0 26694 32439550 1914 0 3571 0 0 0\\n\"+\n                    \"cpu24 1229977 19 32308 32471217 4191 0 4732 0 0 0\\n\"+\n                    \"cpu25 1329079 92 79253 32324092 5267 0 4821 0 0 0\\n\"+\n                    \"cpu26 1225922 30 34837 32475220 4000 0 4711 0 0 0\\n\"+\n                    \"cpu27 1261848 56 43928 32397341 3552 0 5625 0 0 0\\n\"+\n                    \"cpu28 1226707 20 36281 32463498 3935 4 5943 0 0 0\\n\"+\n                    \"cpu29 1379751 19 35593 32317723 2872 4 5913 0 0 0\\n\"+\n                    \"cpu30 1247661 0 32636 32455845 2033 0 4775 0 0 0\\n\"+\n                    \"cpu31 1219016 10 33804 32484916 2254 0 4756 0 0 0\\n\"+\n                    \"intr 840450413 1194 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 55 0 0 0 0 0 0 45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 593665 88058 57766 41441 62426 61320 39848 39787 522984 116724 99144 95021 113975 99093 78676 78144 0 168858 168858 168858 162 2986764 4720950 3610168 5059579 3251008 2765017 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\"+\n                    \"ctxt 1506565570\\n\"+\n                    \"btime 1385196580\\n\"+\n                    \"processes 1226464\\n\"+\n                    \"procs_running 21\\n\"+\n                    \"procs_blocked 0\\n\"+\n                    \"softirq 793917930 0 156954983 77578 492842649 1992553 0 7758971 51856558 228040 82206598\\n\";\n\n    final String procTestData = \"16790 (java) S 1 16789 16789 0 -1 4202496 6714145 0 0 0 4773058 5391 0 0 20 0 110 0 33573283 64362651648 6467228 18446744073709551615 1073741824 1073778376 140734614041280 140734614032416 140242897981768 0 0 3 16800972 18446744073709551615 0 0 17 27 0 0 0 0 0\\n\";\n\n    LinuxProcFileReader lpfr = new LinuxProcFileReader();\n    lpfr.parseSystemProcFile(sysTestData);\n    lpfr.parseProcessProcFile(procTestData);\n    System.out.println(\"System idle ticks: \" + lpfr.getSystemIdleTicks());\n    System.out.println(\"System total ticks: \" + lpfr.getSystemTotalTicks());\n    System.out.println(\"Process total ticks: \" + lpfr.getProcessTotalTicks());\n    System.out.println(\"Process RSS: \" + lpfr.getProcessRss());\n    System.out.println(\"Number of cpus: \" + lpfr.getCpuTicks().length);\n  }","id":3232,"modified_method":"/**\n   * Main is purely for command-line testing.\n   */\n  public static void main(String[] args) {\n    final String sysTestData =\n            \"cpu  43559117 24094 1632164 1033740407 245624 29 200080 0 0 0\\n\"+\n                    \"cpu0 1630761 1762 62861 31960072 40486 15 10614 0 0 0\\n\"+\n                    \"cpu1 1531923 86 62987 32118372 13190 0 6806 0 0 0\\n\"+\n                    \"cpu2 1436788 332 66513 32210723 10867 0 6772 0 0 0\\n\"+\n                    \"cpu3 1428700 1001 64574 32223156 8751 0 6811 0 0 0\\n\"+\n                    \"cpu4 1424410 152 62649 32232602 6552 0 6836 0 0 0\\n\"+\n                    \"cpu5 1427172 1478 58744 32233938 5471 0 6708 0 0 0\\n\"+\n                    \"cpu6 1418433 348 60957 32241807 5301 0 6639 0 0 0\\n\"+\n                    \"cpu7 1404882 182 60640 32258150 3847 0 6632 0 0 0\\n\"+\n                    \"cpu8 1485698 3593 67154 32101739 38387 0 9016 0 0 0\\n\"+\n                    \"cpu9 1422404 1601 66489 32193865 15133 0 8800 0 0 0\\n\"+\n                    \"cpu10 1383939 3386 69151 32233567 11219 0 8719 0 0 0\\n\"+\n                    \"cpu11 1376904 3051 65256 32246197 8307 0 8519 0 0 0\\n\"+\n                    \"cpu12 1381437 1496 68003 32237894 6966 0 8676 0 0 0\\n\"+\n                    \"cpu13 1376250 1527 66598 32247951 7020 0 8554 0 0 0\\n\"+\n                    \"cpu14 1364352 1573 65520 32262764 5093 0 8531 0 0 0\\n\"+\n                    \"cpu15 1359076 1176 64380 32269336 5219 0 8593 0 0 0\\n\"+\n                    \"cpu16 1363844 6 29612 32344252 4830 2 4366 0 0 0\\n\"+\n                    \"cpu17 1477797 1019 70211 32190189 6278 0 3731 0 0 0\\n\"+\n                    \"cpu18 1285849 30 29219 32428612 3549 0 3557 0 0 0\\n\"+\n                    \"cpu19 1272308 0 27306 32445340 2089 0 3541 0 0 0\\n\"+\n                    \"cpu20 1326369 5 29152 32386824 2458 0 4416 0 0 0\\n\"+\n                    \"cpu21 1320883 28 31886 32384709 2327 1 4869 0 0 0\\n\"+\n                    \"cpu22 1259498 1 26954 32458931 2247 0 3511 0 0 0\\n\"+\n                    \"cpu23 1279464 0 26694 32439550 1914 0 3571 0 0 0\\n\"+\n                    \"cpu24 1229977 19 32308 32471217 4191 0 4732 0 0 0\\n\"+\n                    \"cpu25 1329079 92 79253 32324092 5267 0 4821 0 0 0\\n\"+\n                    \"cpu26 1225922 30 34837 32475220 4000 0 4711 0 0 0\\n\"+\n                    \"cpu27 1261848 56 43928 32397341 3552 0 5625 0 0 0\\n\"+\n                    \"cpu28 1226707 20 36281 32463498 3935 4 5943 0 0 0\\n\"+\n                    \"cpu29 1379751 19 35593 32317723 2872 4 5913 0 0 0\\n\"+\n                    \"cpu30 1247661 0 32636 32455845 2033 0 4775 0 0 0\\n\"+\n                    \"cpu31 1219016 10 33804 32484916 2254 0 4756 0 0 0\\n\"+\n                    \"intr 840450413 1194 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 55 0 0 0 0 0 0 45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 593665 88058 57766 41441 62426 61320 39848 39787 522984 116724 99144 95021 113975 99093 78676 78144 0 168858 168858 168858 162 2986764 4720950 3610168 5059579 3251008 2765017 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\"+\n                    \"ctxt 1506565570\\n\"+\n                    \"btime 1385196580\\n\"+\n                    \"processes 1226464\\n\"+\n                    \"procs_running 21\\n\"+\n                    \"procs_blocked 0\\n\"+\n                    \"softirq 793917930 0 156954983 77578 492842649 1992553 0 7758971 51856558 228040 82206598\\n\";\n\n    final String procTestData = \"16790 (java) S 1 16789 16789 0 -1 4202496 6714145 0 0 0 4773058 5391 0 0 20 0 110 0 33573283 64362651648 6467228 18446744073709551615 1073741824 1073778376 140734614041280 140734614032416 140242897981768 0 0 3 16800972 18446744073709551615 0 0 17 27 0 0 0 0 0\\n\";\n\n    parseSystemProcFile(sysTestData);\n    parseProcessProcFile(procTestData);\n    System.out.println(\"System idle ticks: \" + getSystemIdleTicks());\n    System.out.println(\"System total ticks: \" + getSystemTotalTicks());\n    System.out.println(\"Process total ticks: \" + getProcessTotalTicks());\n    System.out.println(\"Process RSS: \" + getProcessRss());\n    System.out.println(\"Number of cpus: \" + getCpuTicks().length);\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks the system was up.\n   */\n  public long getSystemTotalTicks()  { assert _systemTotalTicks > 0;   return _systemTotalTicks; }","id":3233,"modified_method":"/** @return ticks the system was up. */\n  public static long getSystemTotalTicks() { return _systemTotalTicks; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void parseProcessProcFile(String s) {\n    if (s == null) return;\n\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      String line = reader.readLine();\n\n      Pattern p = Pattern.compile(\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \".*\");\n      Matcher m = p.matcher(line);\n      boolean b = m.matches();\n      if (! b) {\n        return;\n      }\n\n      long processUserTicks   = Long.parseLong(m.group(14));\n      long processSystemTicks   = Long.parseLong(m.group(15));\n      _processTotalTicks = processUserTicks + processSystemTicks;\n      _processRss = Long.parseLong(m.group(24));\n    }\n    catch (Exception ignore) {}\n  }","id":3234,"modified_method":"private static void parseProcessProcFile(String s) {\n    if (s == null) return;\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      Matcher m = procPattern.matcher(reader.readLine());\n      if(!m.matches() ) return;\n      long processUserTicks   = Long.parseLong(m.group(14));\n      long processSystemTicks = Long.parseLong(m.group(15));\n      _processTotalTicks = processUserTicks + processSystemTicks;\n      _processRss = Long.parseLong(m.group(24));\n    }\n    catch (Exception ignore) {}\n  }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return process id for this node as a String.\n   */\n  public String getProcessID() { return _pid; }","id":3235,"modified_method":"/** @return process id for this node  */\n  public static int getProcessID() { return PID; }","commit_id":"614c9794cd66934ce7e1368f22624a232613d57e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void run() {\n    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n    ObjectName os;\n    try {\n      os = new ObjectName(\"java.lang:type=OperatingSystem\");\n    } catch( MalformedObjectNameException e ) {\n      throw Log.throwErr(e);\n    }\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    int counter = 0;\n    while( true ) {\n      // Update the interesting health self-info for publication also\n      H2O cloud = H2O.CLOUD;\n      HeartBeat hb = H2O.SELF._heartbeat;\n      hb._hb_version = HB_VERSION++;\n      hb._jvm_boot_msec= TimeLine.JVM_BOOT_MSEC;\n      final Runtime run = Runtime.getRuntime();\n      hb.set_free_mem  (run. freeMemory());\n      hb.set_max_mem   (run.  maxMemory());\n      hb.set_tot_mem   (run.totalMemory());\n      hb._keys       = (H2O.STORE.size ());\n      hb.set_mvalsz    (myHisto.histo(false)._cached);\n      hb.set_tvalsz    (myHisto             ._total );\n      hb._num_cpus   = (char)run.availableProcessors();\n\n      // Run mini-benchmark every 5 mins.  However, on startup - do not have\n      // all JVMs immediately launch a all-core benchmark - they will fight\n      // with each other.  Stagger them using the hashcode.\n      if( (counter+Math.abs(H2O.SELF.hashCode())) % 300 == 0) {\n        hb._gflops   = Linpack.run(hb._cpus_allowed);\n        hb._membw    = MemoryBandwidth.run(hb._cpus_allowed);\n      }\n\n      Object load = null;\n      try {\n        load = mbs.getAttribute(os, \"SystemLoadAverage\");\n        if( (double)load == -1 ) // SystemLoadAverage not available on windows\n          load = mbs.getAttribute(os, \"SystemCpuLoad\");\n      } catch( Exception e ) {\n        // Ignore, data probably not available on this VM\n      }\n      hb._system_load_average = load instanceof Double ? ((Double) load).floatValue() : 0;\n      int rpcs = 0;\n      for( H2ONode h2o : cloud._memary )\n        rpcs += h2o.taskSize();\n      hb._rpcs       = (char)rpcs;\n      // Scrape F/J pool counts\n      hb._fjthrds = new short[H2O.MAX_PRIORITY+1];\n      hb._fjqueue = new short[H2O.MAX_PRIORITY+1];\n      for( int i=0; i<hb._fjthrds.length; i++ ) {\n        hb._fjthrds[i] = (short)H2O.getWrkThrPoolSize(i);\n        hb._fjqueue[i] = (short)H2O.getWrkQueueSize(i);\n      }\n      hb._tcps_active= (char)H2ONode.TCPS.get();\n\n      // get the usable and total disk storage for the partition where the\n      // persistent KV pairs are stored\n      hb.set_free_disk(H2O.getPM().getIce().getUsableSpace());\n      hb.set_max_disk(H2O.getPM().getIce().getTotalSpace());\n\n      // get cpu utilization for the system and for this process.  (linux only.)\n      LinuxProcFileReader lpfr = new LinuxProcFileReader();\n      lpfr.read();\n      if (lpfr.valid()) {\n        hb._system_idle_ticks = lpfr.getSystemIdleTicks();\n        hb._system_total_ticks = lpfr.getSystemTotalTicks();\n        hb._process_total_ticks = lpfr.getProcessTotalTicks();\n        hb._process_num_open_fds = lpfr.getProcessNumOpenFds();\n      }\n      else {\n        hb._system_idle_ticks = -1;\n        hb._system_total_ticks = -1;\n        hb._process_total_ticks = -1;\n        hb._process_num_open_fds = -1;\n      }\n      hb._cpus_allowed = lpfr.getProcessCpusAllowed();\n      if (H2O.ARGS.nthreads < hb._cpus_allowed) {\n        hb._cpus_allowed = H2O.ARGS.nthreads;\n      }\n      hb._nthreads = H2O.ARGS.nthreads;\n      hb._pid = lpfr.getProcessID();\n\n      // Announce what Cloud we think we are in.\n      // Publish our health as well.\n      UDPHeartbeat.build_and_multicast(cloud, hb);\n\n      // If we have no internet connection, then the multicast goes\n      // nowhere and we never receive a heartbeat from ourselves!\n      // Fake it now.\n      long now = System.currentTimeMillis();\n      H2O.SELF._last_heard_from = now;\n\n      // Look for napping Nodes & propose removing from Cloud\n      for( H2ONode h2o : cloud._memary ) {\n        long delta = now - h2o._last_heard_from;\n        if( delta > SUSPECT ) {// We suspect this Node has taken a dirt nap\n          if( !h2o._announcedLostContact ) {\n            Paxos.print(\"hart: announce suspect node\",cloud._memary,h2o.toString());\n            h2o._announcedLostContact = true;\n          }\n        } else if( h2o._announcedLostContact ) {\n          Paxos.print(\"hart: regained contact with node\",cloud._memary,h2o.toString());\n          h2o._announcedLostContact = false;\n        }\n      }\n      counter++;\n\n      // Once per second, for the entire cloud a Node will multi-cast publish\n      // itself, so other unrelated Clouds discover each other and form up.\n      try { Thread.sleep(SLEEP); } // Only once-sec per entire Cloud\n      catch( InterruptedException ignore ) { }\n    }\n  }","id":3236,"modified_method":"public void run() {\n    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n    ObjectName os;\n    try {\n      os = new ObjectName(\"java.lang:type=OperatingSystem\");\n    } catch( MalformedObjectNameException e ) {\n      throw Log.throwErr(e);\n    }\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    int counter = 0;\n    while( true ) {\n      // Update the interesting health self-info for publication also\n      H2O cloud = H2O.CLOUD;\n      HeartBeat hb = H2O.SELF._heartbeat;\n      hb._hb_version = HB_VERSION++;\n      hb._jvm_boot_msec= TimeLine.JVM_BOOT_MSEC;\n      final Runtime run = Runtime.getRuntime();\n      hb.set_free_mem  (run. freeMemory());\n      hb.set_max_mem   (run.  maxMemory());\n      hb.set_tot_mem   (run.totalMemory());\n      hb._keys       = (H2O.STORE.size ());\n      hb.set_mvalsz    (myHisto.histo(false)._cached);\n      hb.set_tvalsz    (myHisto             ._total );\n      hb._num_cpus   = (char)run.availableProcessors();\n\n      // Run mini-benchmark every 5 mins.  However, on startup - do not have\n      // all JVMs immediately launch a all-core benchmark - they will fight\n      // with each other.  Stagger them using the hashcode.\n      if( (counter+Math.abs(H2O.SELF.hashCode())) % 300 == 0) {\n        hb._gflops   = Linpack.run(hb._cpus_allowed);\n        hb._membw    = MemoryBandwidth.run(hb._cpus_allowed);\n      }\n\n      Object load = null;\n      try {\n        load = mbs.getAttribute(os, \"SystemLoadAverage\");\n        if( (double)load == -1 ) // SystemLoadAverage not available on windows\n          load = mbs.getAttribute(os, \"SystemCpuLoad\");\n      } catch( Exception e ) {\n        // Ignore, data probably not available on this VM\n      }\n      hb._system_load_average = load instanceof Double ? ((Double) load).floatValue() : 0;\n      int rpcs = 0;\n      for( H2ONode h2o : cloud._memary )\n        rpcs += h2o.taskSize();\n      hb._rpcs       = (char)rpcs;\n      // Scrape F/J pool counts\n      hb._fjthrds = new short[H2O.MAX_PRIORITY+1];\n      hb._fjqueue = new short[H2O.MAX_PRIORITY+1];\n      for( int i=0; i<hb._fjthrds.length; i++ ) {\n        hb._fjthrds[i] = (short)H2O.getWrkThrPoolSize(i);\n        hb._fjqueue[i] = (short)H2O.getWrkQueueSize(i);\n      }\n      hb._tcps_active= (char)H2ONode.TCPS.get();\n\n      // get the usable and total disk storage for the partition where the\n      // persistent KV pairs are stored\n      hb.set_free_disk(H2O.getPM().getIce().getUsableSpace());\n      hb.set_max_disk(H2O.getPM().getIce().getTotalSpace());\n\n      // get cpu utilization for the system and for this process.  (linux only.)\n      LinuxProcFileReader.refresh();\n      hb._system_idle_ticks = LinuxProcFileReader.getSystemIdleTicks();\n      hb._system_total_ticks = LinuxProcFileReader.getSystemTotalTicks();\n      hb._process_total_ticks = LinuxProcFileReader.getProcessTotalTicks();\n      hb._process_num_open_fds = LinuxProcFileReader.getProcessNumOpenFds();\n      hb._cpus_allowed = LinuxProcFileReader.getProcessCpusAllowed();\n      if (H2O.ARGS.nthreads < hb._cpus_allowed) {\n        hb._cpus_allowed = H2O.ARGS.nthreads;\n      }\n      hb._nthreads = H2O.ARGS.nthreads;\n      hb._pid = LinuxProcFileReader.getProcessID();\n\n      // Announce what Cloud we think we are in.\n      // Publish our health as well.\n      UDPHeartbeat.build_and_multicast(cloud, hb);\n\n      // If we have no internet connection, then the multicast goes\n      // nowhere and we never receive a heartbeat from ourselves!\n      // Fake it now.\n      long now = System.currentTimeMillis();\n      H2O.SELF._last_heard_from = now;\n\n      // Look for napping Nodes & propose removing from Cloud\n      for( H2ONode h2o : cloud._memary ) {\n        long delta = now - h2o._last_heard_from;\n        if( delta > SUSPECT ) {// We suspect this Node has taken a dirt nap\n          if( !h2o._announcedLostContact ) {\n            Paxos.print(\"hart: announce suspect node\",cloud._memary,h2o.toString());\n            h2o._announcedLostContact = true;\n          }\n        } else if( h2o._announcedLostContact ) {\n          Paxos.print(\"hart: regained contact with node\",cloud._memary,h2o.toString());\n          h2o._announcedLostContact = false;\n        }\n      }\n      counter++;\n\n      // Once per second, for the entire cloud a Node will multi-cast publish\n      // itself, so other unrelated Clouds discover each other and form up.\n      try { Thread.sleep(SLEEP); } // Only once-sec per entire Cloud\n      catch( InterruptedException ignore ) { }\n    }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return true if all the values are ok to use; false otherwise.\n   */\n  public boolean valid() {\n    return ((_systemIdleTicks >= 0) && (_systemTotalTicks >= 0) && (_processTotalTicks >= 0) &&\n            (_processNumOpenFds >= 0));\n  }","id":3237,"modified_method":"/** @return true if all the values are ok to use; false otherwise. */\n  private static boolean valid() {\n    return _systemIdleTicks >= 0 && _systemTotalTicks >= 0 && _processTotalTicks >= 0 && _processNumOpenFds >= 0;\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static String getProcessId() throws Exception {\n    // Note: may fail in some JVM implementations\n    // therefore fallback has to be provided\n\n    // something like '<pid>@<hostname>', at least in SUN / Oracle JVMs\n    final String jvmName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();\n    final int index = jvmName.indexOf('@');\n\n    if (index < 1) {\n      // part before '@' empty (index = 0) / '@' not found (index = -1)\n      throw new Exception (\"Can't get process Id\");\n    }\n\n    return Long.toString(Long.parseLong(jvmName.substring(0, index)));\n  }","id":3238,"modified_method":"private static int getProcessIdFromJMX() {\n    // Note: may fail in some JVM implementations therefore fallback has to be provided.\n    // Something like '<pid>@<hostname>', at least in SUN / Oracle JVMs\n    final String jvmName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();\n    final int index = jvmName.indexOf('@');\n    return index < 1 ? -1 // part before '@' empty (index = 0) / '@' not found (index = -1)\n      : Integer.parseInt(jvmName.substring(0, index));\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void parseProcessProcFile(String s) {\n    if (s == null) return;\n\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      String line = reader.readLine();\n\n      Pattern p = Pattern.compile(\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \"\\\\s+\" +\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\" + \".*\");\n      Matcher m = p.matcher(line);\n      boolean b = m.matches();\n      if (! b) {\n        return;\n      }\n\n      long processUserTicks   = Long.parseLong(m.group(14));\n      long processSystemTicks   = Long.parseLong(m.group(15));\n      _processTotalTicks = processUserTicks + processSystemTicks;\n      _processRss = Long.parseLong(m.group(24));\n    }\n    catch (Exception ignore) {}\n  }","id":3239,"modified_method":"private static void parseProcessProcFile(String s) {\n    if (s == null) return;\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      Matcher m = procPattern.matcher(reader.readLine());\n      if(!m.matches() ) return;\n      long processUserTicks   = Long.parseLong(m.group(14));\n      long processSystemTicks = Long.parseLong(m.group(15));\n      _processTotalTicks = processUserTicks + processSystemTicks;\n      _processRss = Long.parseLong(m.group(24));\n    }\n    catch (Exception ignore) {}\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @param s String containing contents of proc file.\n   */\n  private void parseSystemProcFile(String s) {\n    if (s == null) return;\n\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      String line = reader.readLine();\n\n      // Read aggregate cpu values\n      {\n        Pattern p = Pattern.compile(\"cpu\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+).*\");\n        Matcher m = p.matcher(line);\n        boolean b = m.matches();\n        if (!b) {\n          return;\n        }\n\n        int matchGroupBase = 0;\n        long systemUserTicks = 0;\n        long systemSystemTicks = 0;\n        long systemOtherTicks = 0;\n        _systemIdleTicks = 0;\n        systemUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        systemOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        _systemIdleTicks   += Long.parseLong(m.group(4 + matchGroupBase));\n        systemOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        systemSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        _systemTotalTicks   = systemUserTicks + systemOtherTicks + systemSystemTicks + _systemIdleTicks;\n      }\n\n      // Read individual cpu values\n      _cpuTicks = new ArrayList<long[]>();\n      line = reader.readLine();\n      while (line != null) {\n        Pattern p = Pattern.compile(\"cpu(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+).*\");\n        Matcher m = p.matcher(line);\n        boolean b = m.matches();\n        if (! b) {\n          break;\n        }\n\n        // Copying algorithm from http://gee.cs.oswego.edu/dl/code/\n        // See perfbar.c in gtk_perfbar package.\n        // int cpuNum = Integer.parseInt(m.group(1));\n        int matchGroupBase = 1;\n        long cpuUserTicks = 0;\n        long cpuSystemTicks = 0;\n        long cpuOtherTicks = 0;\n        long cpuIdleTicks = 0;\n        cpuUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        cpuIdleTicks    += Long.parseLong(m.group(4 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        long[] oneCpuTicks = {cpuUserTicks, cpuSystemTicks, cpuOtherTicks, cpuIdleTicks};\n        _cpuTicks.add(oneCpuTicks);\n\n        line = reader.readLine();\n      }\n    }\n    catch (Exception ignore) {}\n  }","id":3240,"modified_method":"/** @param s String containing contents of proc file. */\n  private static void parseSystemProcFile(String s) {\n    if (s == null) return;\n    BufferedReader reader = new BufferedReader(new StringReader(s));\n    try { \n      // Read aggregate cpu values\n      String line = reader.readLine();\n      Matcher m = sysTicksPattern.matcher(line);\n      if( !m.matches() ) return;\n  \n      int matchGroupBase = 0;\n      long systemUserTicks = 0;\n      long systemSystemTicks = 0;\n      long systemOtherTicks = 0;\n      systemUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n      systemOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n      _systemIdleTicks    = Long.parseLong(m.group(4 + matchGroupBase));\n      systemOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n      systemSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n      _systemTotalTicks   = systemUserTicks + systemOtherTicks + systemSystemTicks + _systemIdleTicks;\n  \n      // Read individual cpu values\n      int cpu = 0;\n      line = reader.readLine();\n      while (line != null) {\n        m = cpuTicksPattern.matcher(line);\n        if( !m.matches() ) break;\n        // Copying algorithm from http://gee.cs.oswego.edu/dl/code/\n        // See perfbar.c in gtk_perfbar package.\n        // int cpuNum = Integer.parseInt(m.group(1));\n        matchGroupBase = 1;\n        long cpuUserTicks = 0;\n        long cpuSystemTicks = 0;\n        long cpuOtherTicks = 0;\n        long cpuIdleTicks = 0;\n        cpuUserTicks    += Long.parseLong(m.group(1 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(2 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(3 + matchGroupBase));\n        cpuIdleTicks    += Long.parseLong(m.group(4 + matchGroupBase));\n        cpuOtherTicks   += Long.parseLong(m.group(5 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(6 + matchGroupBase));\n        cpuSystemTicks  += Long.parseLong(m.group(7 + matchGroupBase));\n        CPUTICKS[cpu][0] = cpuUserTicks;\n        CPUTICKS[cpu][1] = cpuSystemTicks;\n        CPUTICKS[cpu][2] = cpuOtherTicks;\n        CPUTICKS[cpu][3] = cpuIdleTicks;\n        cpu++;\n        line = reader.readLine();\n      }\n    } catch( IOException _ ) {/**/}\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Array of ticks.\n   * [cpu number][tick type]\n   *\n   * tick types are:\n   *\n   * [0] user ticks\n   * [1] system ticks\n   * [2] other ticks (i/o)\n   * [3] idle ticks\n   *\n   * @return ticks array for each cpu of the system.\n   */\n  public long[][] getCpuTicks()      { assert _cpuTicks != null;       return _cpuTicks.toArray(new long[0][0]); }","id":3241,"modified_method":"/**  Array of ticks:  [cpu number][tick type]\n   *\n   * tick types are:\n   * [0] user ticks\n   * [1] system ticks\n   * [2] other ticks (i/o)\n   * [3] idle ticks\n   *\n   * @return ticks array for each cpu of the system.\n   */\n  public static long[][] getCpuTicks() { return CPUTICKS; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void parseProcessStatusFile(String s) {\n    if(s == null) return;\n    try {\n      Pattern p = Pattern.compile(\"Cpus_allowed:\\\\s+([A-Fa-f0-9,]+)\");\n      Matcher m = p.matcher(s);\n      boolean b = m.find();\n      if (! b) {\n        return;\n      }\n      _processCpusAllowed = numSetBitsHex(m.group(1));\n    }\n    catch (Exception ignore) {}\n  }","id":3242,"modified_method":"private static int parseProcessStatusFile(String s) {\n    int cpus = Runtime.getRuntime().availableProcessors();\n    if(s == null) return cpus;\n    try {\n      Matcher m = Pattern.compile(\"Cpus_allowed:\\\\s+([A-Fa-f0-9,]+)\").matcher(s);\n      return m.find() ? numSetBitsHex(m.group(1)) : cpus;\n    }\n    catch( Exception ignore ) { return cpus; }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readProcessProcFile(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/stat\";\n      _processData = readFile(new File(s));\n    }\n    catch (Exception ignore) {}\n  }","id":3243,"modified_method":"private static String readProcessProcFile(int pid) {\n    try { return pid == -1 ? null : readFile(new File(\"/proc/\"+pid+\"/stat\")); }\n    catch( IOException _ ) { return null; }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of CPUs allowed by this process.\n   */\n  public int getProcessCpusAllowed() {\n    if (! IS_OS_LINUX()) {\n      return Runtime.getRuntime().availableProcessors();\n    }\n\n    // _processCpusAllowed is not available on CentOS 5 and earlier.\n    // In this case, just return availableProcessors.\n    if (_processCpusAllowed < 0) {\n      return Runtime.getRuntime().availableProcessors();\n    }\n\n    return _processCpusAllowed;\n  }","id":3244,"modified_method":"/** @return number of CPUs allowed by this process. */\n  public static int getProcessCpusAllowed() { return PROCESS_CPUS_ALLOWED; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks the system was idle.  in general:  idle + busy == 100%\n   */\n  public long getSystemIdleTicks()   { assert _systemIdleTicks > 0;    return _systemIdleTicks; }","id":3245,"modified_method":"/** @return ticks the system was idle.  in general:  idle + busy == 100% */\n  public static long getSystemIdleTicks() { return _systemIdleTicks; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of set bits in hexadecimal string (chars must be 0-F)\n   */\n  public static int numSetBitsHex(String s) {\n    // Look-up table for num set bits in 4-bit char\n    final int[] bits_set = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n\n    int nset = 0;\n    for(int i = 0; i < s.length(); i++) {\n      Character ch = s.charAt(i);\n      if (ch == ',') {\n        continue;\n      }\n      int x = Integer.parseInt(ch.toString(), 16);\n      nset += bits_set[x];\n    }\n    return nset;\n  }","id":3246,"modified_method":"/** @return number of set bits in hexadecimal string (chars must be 0-F) */\n  private static int numSetBitsHex(String s) {\n    // Look-up table for num set bits in 4-bit char\n    final int[] bits_set = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n    int nset = 0;\n    for(int i = 0; i < s.length(); i++) {\n      Character ch = s.charAt(i);\n      if (ch == ',') continue;\n      int x = Integer.parseInt(ch.toString(), 16);\n      nset += bits_set[x];\n    }\n    return nset;\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return process id for this node as a String.\n   */\n  public String getProcessID() { return _pid; }","id":3247,"modified_method":"/** @return process id for this node  */\n  public static int getProcessID() { return PID; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return resident set size (RSS) of this process.\n   */\n  public long getProcessRss()        { assert _processRss > 0;         return _processRss; }","id":3248,"modified_method":"/** @return resident set size (RSS) of this process. */\n  public static long getProcessRss() { return _processRss; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return number of currently open fds of this process.\n   */\n  public int getProcessNumOpenFds() { assert _processNumOpenFds > 0;  return _processNumOpenFds; }","id":3249,"modified_method":"/** @return number of currently open fds of this process.  */\n  public static int getProcessNumOpenFds() { return _processNumOpenFds; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readProcessStatusFile(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/status\";\n      _processStatus = readFile(new File(s));\n    }\n    catch (Exception ignore) {}\n  }","id":3250,"modified_method":"private static String readProcessStatusFile(int pid) {\n    try { return pid== -1 ? null : readFile(new File(\"/proc/\"+pid+\"/status\")); }\n    catch( IOException _ ) { return null; }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks the system was up.\n   */\n  public long getSystemTotalTicks()  { assert _systemTotalTicks > 0;   return _systemTotalTicks; }","id":3251,"modified_method":"/** @return ticks the system was up. */\n  public static long getSystemTotalTicks() { return _systemTotalTicks; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * @return ticks this process was running.\n   */\n  public long getProcessTotalTicks() { assert _processTotalTicks > 0;  return _processTotalTicks; }","id":3252,"modified_method":"/** @return ticks this process was running. */\n  public static long getProcessTotalTicks() { return _processTotalTicks; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readSystemProcFile() {\n    try {\n      _systemData = readFile(new File(\"/proc/stat\"));\n    }\n    catch (Exception ignore) {}\n  }","id":3253,"modified_method":"private static String readSystemProcFile() {\n    try { return readFile(new File(\"/proc/stat\")); }\n    catch( IOException _ ) { return null; }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private String readFile(File f) throws Exception {\n    char[] buffer = new char[16 * 1024];\n    FileReader fr = new FileReader(f);\n    int bytesRead = 0;\n    while (true) {\n      int n = fr.read(buffer, bytesRead, buffer.length - bytesRead);\n      if (n < 0) {\n        fr.close();\n        return new String (buffer, 0, bytesRead);\n      }\n      else if (n == 0) {\n        // This is weird.\n        fr.close();\n        throw new Exception(\"LinuxProcFileReader readFile read 0 bytes\");\n      }\n\n      bytesRead += n;\n\n      if (bytesRead >= buffer.length) {\n        fr.close();\n        throw new Exception(\"LinuxProcFileReader readFile unexpected buffer full\");\n      }\n    }\n  }","id":3254,"modified_method":"private static String readFile(File f) throws IOException {\n    int bytesRead = 0;\n    try(FileReader fr = new FileReader(f)) {\n        synchronized(buffer) {\n          while (true) {\n            int n = fr.read(buffer, bytesRead, buffer.length - bytesRead);\n            if( n < 0 ) return new String(buffer, 0, bytesRead);\n            bytesRead += n;\n            if( bytesRead >= buffer.length ) throw new IOException(\"LinuxProcFileReader readFile unexpected buffer full\");\n          }\n        }\n    }\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void readProcessNumOpenFds(String pid) {\n    try {\n      String s = \"/proc/\" + pid + \"/fd\";\n      File f = new File(s);\n      String[] arr = f.list();\n      if (arr != null) {\n        _processNumOpenFds = arr.length;\n      }\n    }\n    catch (Exception ignore) {}\n  }","id":3255,"modified_method":"private static void readProcessNumOpenFds(int pid) {\n    if( pid == -1 ) return;\n    String[] arr = new File(\"/proc/\" + pid + \"/fd\").list();\n    _processNumOpenFds = arr == null ? 0 : arr.length;\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Main is purely for command-line testing.\n   */\n  public static void main(String[] args) {\n    final String sysTestData =\n            \"cpu  43559117 24094 1632164 1033740407 245624 29 200080 0 0 0\\n\"+\n                    \"cpu0 1630761 1762 62861 31960072 40486 15 10614 0 0 0\\n\"+\n                    \"cpu1 1531923 86 62987 32118372 13190 0 6806 0 0 0\\n\"+\n                    \"cpu2 1436788 332 66513 32210723 10867 0 6772 0 0 0\\n\"+\n                    \"cpu3 1428700 1001 64574 32223156 8751 0 6811 0 0 0\\n\"+\n                    \"cpu4 1424410 152 62649 32232602 6552 0 6836 0 0 0\\n\"+\n                    \"cpu5 1427172 1478 58744 32233938 5471 0 6708 0 0 0\\n\"+\n                    \"cpu6 1418433 348 60957 32241807 5301 0 6639 0 0 0\\n\"+\n                    \"cpu7 1404882 182 60640 32258150 3847 0 6632 0 0 0\\n\"+\n                    \"cpu8 1485698 3593 67154 32101739 38387 0 9016 0 0 0\\n\"+\n                    \"cpu9 1422404 1601 66489 32193865 15133 0 8800 0 0 0\\n\"+\n                    \"cpu10 1383939 3386 69151 32233567 11219 0 8719 0 0 0\\n\"+\n                    \"cpu11 1376904 3051 65256 32246197 8307 0 8519 0 0 0\\n\"+\n                    \"cpu12 1381437 1496 68003 32237894 6966 0 8676 0 0 0\\n\"+\n                    \"cpu13 1376250 1527 66598 32247951 7020 0 8554 0 0 0\\n\"+\n                    \"cpu14 1364352 1573 65520 32262764 5093 0 8531 0 0 0\\n\"+\n                    \"cpu15 1359076 1176 64380 32269336 5219 0 8593 0 0 0\\n\"+\n                    \"cpu16 1363844 6 29612 32344252 4830 2 4366 0 0 0\\n\"+\n                    \"cpu17 1477797 1019 70211 32190189 6278 0 3731 0 0 0\\n\"+\n                    \"cpu18 1285849 30 29219 32428612 3549 0 3557 0 0 0\\n\"+\n                    \"cpu19 1272308 0 27306 32445340 2089 0 3541 0 0 0\\n\"+\n                    \"cpu20 1326369 5 29152 32386824 2458 0 4416 0 0 0\\n\"+\n                    \"cpu21 1320883 28 31886 32384709 2327 1 4869 0 0 0\\n\"+\n                    \"cpu22 1259498 1 26954 32458931 2247 0 3511 0 0 0\\n\"+\n                    \"cpu23 1279464 0 26694 32439550 1914 0 3571 0 0 0\\n\"+\n                    \"cpu24 1229977 19 32308 32471217 4191 0 4732 0 0 0\\n\"+\n                    \"cpu25 1329079 92 79253 32324092 5267 0 4821 0 0 0\\n\"+\n                    \"cpu26 1225922 30 34837 32475220 4000 0 4711 0 0 0\\n\"+\n                    \"cpu27 1261848 56 43928 32397341 3552 0 5625 0 0 0\\n\"+\n                    \"cpu28 1226707 20 36281 32463498 3935 4 5943 0 0 0\\n\"+\n                    \"cpu29 1379751 19 35593 32317723 2872 4 5913 0 0 0\\n\"+\n                    \"cpu30 1247661 0 32636 32455845 2033 0 4775 0 0 0\\n\"+\n                    \"cpu31 1219016 10 33804 32484916 2254 0 4756 0 0 0\\n\"+\n                    \"intr 840450413 1194 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 55 0 0 0 0 0 0 45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 593665 88058 57766 41441 62426 61320 39848 39787 522984 116724 99144 95021 113975 99093 78676 78144 0 168858 168858 168858 162 2986764 4720950 3610168 5059579 3251008 2765017 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\"+\n                    \"ctxt 1506565570\\n\"+\n                    \"btime 1385196580\\n\"+\n                    \"processes 1226464\\n\"+\n                    \"procs_running 21\\n\"+\n                    \"procs_blocked 0\\n\"+\n                    \"softirq 793917930 0 156954983 77578 492842649 1992553 0 7758971 51856558 228040 82206598\\n\";\n\n    final String procTestData = \"16790 (java) S 1 16789 16789 0 -1 4202496 6714145 0 0 0 4773058 5391 0 0 20 0 110 0 33573283 64362651648 6467228 18446744073709551615 1073741824 1073778376 140734614041280 140734614032416 140242897981768 0 0 3 16800972 18446744073709551615 0 0 17 27 0 0 0 0 0\\n\";\n\n    LinuxProcFileReader lpfr = new LinuxProcFileReader();\n    lpfr.parseSystemProcFile(sysTestData);\n    lpfr.parseProcessProcFile(procTestData);\n    System.out.println(\"System idle ticks: \" + lpfr.getSystemIdleTicks());\n    System.out.println(\"System total ticks: \" + lpfr.getSystemTotalTicks());\n    System.out.println(\"Process total ticks: \" + lpfr.getProcessTotalTicks());\n    System.out.println(\"Process RSS: \" + lpfr.getProcessRss());\n    System.out.println(\"Number of cpus: \" + lpfr.getCpuTicks().length);\n  }","id":3256,"modified_method":"/**\n   * Main is purely for command-line testing.\n   */\n  public static void main(String[] args) {\n    final String sysTestData =\n            \"cpu  43559117 24094 1632164 1033740407 245624 29 200080 0 0 0\\n\"+\n                    \"cpu0 1630761 1762 62861 31960072 40486 15 10614 0 0 0\\n\"+\n                    \"cpu1 1531923 86 62987 32118372 13190 0 6806 0 0 0\\n\"+\n                    \"cpu2 1436788 332 66513 32210723 10867 0 6772 0 0 0\\n\"+\n                    \"cpu3 1428700 1001 64574 32223156 8751 0 6811 0 0 0\\n\"+\n                    \"cpu4 1424410 152 62649 32232602 6552 0 6836 0 0 0\\n\"+\n                    \"cpu5 1427172 1478 58744 32233938 5471 0 6708 0 0 0\\n\"+\n                    \"cpu6 1418433 348 60957 32241807 5301 0 6639 0 0 0\\n\"+\n                    \"cpu7 1404882 182 60640 32258150 3847 0 6632 0 0 0\\n\"+\n                    \"cpu8 1485698 3593 67154 32101739 38387 0 9016 0 0 0\\n\"+\n                    \"cpu9 1422404 1601 66489 32193865 15133 0 8800 0 0 0\\n\"+\n                    \"cpu10 1383939 3386 69151 32233567 11219 0 8719 0 0 0\\n\"+\n                    \"cpu11 1376904 3051 65256 32246197 8307 0 8519 0 0 0\\n\"+\n                    \"cpu12 1381437 1496 68003 32237894 6966 0 8676 0 0 0\\n\"+\n                    \"cpu13 1376250 1527 66598 32247951 7020 0 8554 0 0 0\\n\"+\n                    \"cpu14 1364352 1573 65520 32262764 5093 0 8531 0 0 0\\n\"+\n                    \"cpu15 1359076 1176 64380 32269336 5219 0 8593 0 0 0\\n\"+\n                    \"cpu16 1363844 6 29612 32344252 4830 2 4366 0 0 0\\n\"+\n                    \"cpu17 1477797 1019 70211 32190189 6278 0 3731 0 0 0\\n\"+\n                    \"cpu18 1285849 30 29219 32428612 3549 0 3557 0 0 0\\n\"+\n                    \"cpu19 1272308 0 27306 32445340 2089 0 3541 0 0 0\\n\"+\n                    \"cpu20 1326369 5 29152 32386824 2458 0 4416 0 0 0\\n\"+\n                    \"cpu21 1320883 28 31886 32384709 2327 1 4869 0 0 0\\n\"+\n                    \"cpu22 1259498 1 26954 32458931 2247 0 3511 0 0 0\\n\"+\n                    \"cpu23 1279464 0 26694 32439550 1914 0 3571 0 0 0\\n\"+\n                    \"cpu24 1229977 19 32308 32471217 4191 0 4732 0 0 0\\n\"+\n                    \"cpu25 1329079 92 79253 32324092 5267 0 4821 0 0 0\\n\"+\n                    \"cpu26 1225922 30 34837 32475220 4000 0 4711 0 0 0\\n\"+\n                    \"cpu27 1261848 56 43928 32397341 3552 0 5625 0 0 0\\n\"+\n                    \"cpu28 1226707 20 36281 32463498 3935 4 5943 0 0 0\\n\"+\n                    \"cpu29 1379751 19 35593 32317723 2872 4 5913 0 0 0\\n\"+\n                    \"cpu30 1247661 0 32636 32455845 2033 0 4775 0 0 0\\n\"+\n                    \"cpu31 1219016 10 33804 32484916 2254 0 4756 0 0 0\\n\"+\n                    \"intr 840450413 1194 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 55 0 0 0 0 0 0 45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 593665 88058 57766 41441 62426 61320 39848 39787 522984 116724 99144 95021 113975 99093 78676 78144 0 168858 168858 168858 162 2986764 4720950 3610168 5059579 3251008 2765017 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\"+\n                    \"ctxt 1506565570\\n\"+\n                    \"btime 1385196580\\n\"+\n                    \"processes 1226464\\n\"+\n                    \"procs_running 21\\n\"+\n                    \"procs_blocked 0\\n\"+\n                    \"softirq 793917930 0 156954983 77578 492842649 1992553 0 7758971 51856558 228040 82206598\\n\";\n\n    final String procTestData = \"16790 (java) S 1 16789 16789 0 -1 4202496 6714145 0 0 0 4773058 5391 0 0 20 0 110 0 33573283 64362651648 6467228 18446744073709551615 1073741824 1073778376 140734614041280 140734614032416 140242897981768 0 0 3 16800972 18446744073709551615 0 0 17 27 0 0 0 0 0\\n\";\n\n    parseSystemProcFile(sysTestData);\n    parseProcessProcFile(procTestData);\n    System.out.println(\"System idle ticks: \" + getSystemIdleTicks());\n    System.out.println(\"System total ticks: \" + getSystemTotalTicks());\n    System.out.println(\"Process total ticks: \" + getProcessTotalTicks());\n    System.out.println(\"Process RSS: \" + getProcessRss());\n    System.out.println(\"Number of cpus: \" + getCpuTicks().length);\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void doIt() {\n      String logPathFilename = \"/undefined\";        // Satisfy IDEA inspection.\n      try {\n        if (name == null || name.equals(\"default\")) {\n          name = \"debug\";\n        }\n\n        if (name.equals(\"stdout\") || name.equals(\"stderr\")) {\n          LinuxProcFileReader lpfr = new LinuxProcFileReader();\n          lpfr.read();\n          if (! lpfr.valid()) {\n            log = \"This option only works for Linux hosts\";\n          }\n          else {\n            String pid = lpfr.getProcessID();\n            String fdFileName = \"/proc/\" + pid + \"/fd/\" + (name.equals(\"stdout\") ? \"1\" : \"2\");\n            File f = new File(fdFileName);\n            logPathFilename = f.getCanonicalPath();\n            if (logPathFilename.startsWith(\"/dev\")) {\n              log = \"Unsupported when writing to console\";\n            }\n            if (logPathFilename.startsWith(\"socket\")) {\n              log = \"Unsupported when writing to a socket\";\n            }\n            if (logPathFilename.startsWith(\"pipe\")) {\n              log = \"Unsupported when writing to a pipe\";\n            }\n            if (logPathFilename.equals(fdFileName)) {\n              log = \"Unsupported when writing to a pipe\";\n            }\n            Log.trace(\"LogPathFilename calculation: \" + logPathFilename);\n          }\n        }\n        else if (  name.equals(\"trace\")\n                || name.equals(\"debug\")\n                || name.equals(\"info\")\n                || name.equals(\"warn\")\n                || name.equals(\"error\")\n                || name.equals(\"fatal\")\n                || name.equals(\"httpd\")\n                ) {\n          name = water.util.Log.getLogFileName(name);\n          try {\n            String logDir = Log.getLogDir();\n            logPathFilename = logDir + File.separator + name;\n          }\n          catch (Exception e) {\n            log = \"H2O logging not configured.\";\n          }\n        }\n        else {\n          throw new IllegalArgumentException(\"Illegal log file name requested (try 'default')\");\n        }\n\n        if (log == null) {\n          File f = new File(logPathFilename);\n          if (!f.exists()) {\n            throw new IllegalArgumentException(\"File \" + f + \" does not exist\");\n          }\n          if (!f.canRead()) {\n            throw new IllegalArgumentException(\"File \" + f + \" is not readable\");\n          }\n\n          BufferedReader reader = new BufferedReader(new FileReader(f));\n          String line;\n          StringBuilder sb = new StringBuilder();\n\n          line = reader.readLine();\n          while (line != null) {\n            sb.append(line);\n            sb.append(\"\\n\");\n            line = reader.readLine();\n          }\n          reader.close();\n\n          log = sb.toString();\n        }\n\n        success = true;\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }","id":3257,"modified_method":"public void doIt() {\n      String logPathFilename = \"/undefined\";        // Satisfy IDEA inspection.\n      try {\n        if (name == null || name.equals(\"default\")) {\n          name = \"debug\";\n        }\n\n        if (name.equals(\"stdout\") || name.equals(\"stderr\")) {\n          if (! LinuxProcFileReader.refresh()) {\n            log = \"This option only works for Linux hosts\";\n          }\n          else {\n            int pid = LinuxProcFileReader.getProcessID();\n            String fdFileName = \"/proc/\" + pid + \"/fd/\" + (name.equals(\"stdout\") ? \"1\" : \"2\");\n            File f = new File(fdFileName);\n            logPathFilename = f.getCanonicalPath();\n            if (logPathFilename.startsWith(\"/dev\")) {\n              log = \"Unsupported when writing to console\";\n            }\n            if (logPathFilename.startsWith(\"socket\")) {\n              log = \"Unsupported when writing to a socket\";\n            }\n            if (logPathFilename.startsWith(\"pipe\")) {\n              log = \"Unsupported when writing to a pipe\";\n            }\n            if (logPathFilename.equals(fdFileName)) {\n              log = \"Unsupported when writing to a pipe\";\n            }\n            Log.trace(\"LogPathFilename calculation: \" + logPathFilename);\n          }\n        }\n        else if (  name.equals(\"trace\")\n                || name.equals(\"debug\")\n                || name.equals(\"info\")\n                || name.equals(\"warn\")\n                || name.equals(\"error\")\n                || name.equals(\"fatal\")\n                || name.equals(\"httpd\")\n                ) {\n          name = water.util.Log.getLogFileName(name);\n          try {\n            String logDir = Log.getLogDir();\n            logPathFilename = logDir + File.separator + name;\n          }\n          catch (Exception e) {\n            log = \"H2O logging not configured.\";\n          }\n        }\n        else {\n          throw new IllegalArgumentException(\"Illegal log file name requested (try 'default')\");\n        }\n\n        if (log == null) {\n          File f = new File(logPathFilename);\n          if (!f.exists()) {\n            throw new IllegalArgumentException(\"File \" + f + \" does not exist\");\n          }\n          if (!f.canRead()) {\n            throw new IllegalArgumentException(\"File \" + f + \" is not readable\");\n          }\n\n          BufferedReader reader = new BufferedReader(new FileReader(f));\n          String line;\n          StringBuilder sb = new StringBuilder();\n\n          line = reader.readLine();\n          while (line != null) {\n            sb.append(line);\n            sb.append(\"\\n\");\n            line = reader.readLine();\n          }\n          reader.close();\n\n          log = sb.toString();\n        }\n\n        success = true;\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public byte priority() {\n      return H2O.MIN_HI_PRIORITY;\n    }","id":3258,"modified_method":"@Override public byte priority() { return H2O.GUI_PRIORITY; }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void doIt() {\n    H2ONode node = H2O.CLOUD._memary[nodeidx];\n    GetTicksTask ppt = new GetTicksTask();\n    Log.trace(\"GetTicksTask starting to node \" + nodeidx + \"...\");\n    // Synchronous RPC call to get ticks from remote (possibly this) node.\n    new RPC<>(node, ppt).call().get();\n    Log.trace(\"GetTicksTask completed to node \" + nodeidx);\n    cpu_ticks = ppt._cpuTicks;\n  }","id":3259,"modified_method":"public void doIt() {\n    H2ONode node = H2O.CLOUD._memary[nodeidx];\n    // Synchronous RPC call to get ticks from remote (possibly this) node.\n    cpu_ticks = new RPC<>(node, new GetTicksTask()).call().get()._cpuTicks;\n  }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void compute2() {\n      LinuxProcFileReader lpfr = new LinuxProcFileReader();\n      lpfr.read();\n      if (lpfr.valid()) {\n        _cpuTicks = lpfr.getCpuTicks();\n      }\n      else {\n        // In the case where there isn't any tick information, the client receives a json\n        // response object containing an array of length 0.\n        //\n        // e.g.\n        // { cpuTicks: [] }\n        _cpuTicks = new long[0][0];\n      }\n\n      tryComplete();\n    }","id":3260,"modified_method":"@Override public void compute2() {\n      // In the case where there isn't any tick information, the client\n      // receives a json response object containing an array of length 0;\n      // e.g. { cpuTicks: [] }\n      _cpuTicks = LinuxProcFileReader.refresh() ? LinuxProcFileReader.getCpuTicks() : new long[0][0];\n      tryComplete();\n    }","commit_id":"1639d7bb7b7f6e00f6404ea74c237a4cbf01c247","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n\tpublic void moveDependentSyncDLObjects(\n\t\t\tfinal SyncDLObject parentSyncDLObject)\n\t\tthrows PortalException {\n\n\t\tStringBundler sb = new StringBundler(3);\n\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(parentSyncDLObject.getTypePK());\n\t\tsb.append(StringPool.SLASH);\n\n\t\tfinal String searchTreePath = sb.toString();\n\n\t\tActionableDynamicQuery syncDLObjectActionableDynamicQuery =\n\t\t\tgetActionableDynamicQuery();\n\n\t\tsyncDLObjectActionableDynamicQuery.setAddCriteriaMethod(\n\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\t\tsb.append(StringPool.PERCENT);\n\t\t\t\t\tsb.append(searchTreePath);\n\t\t\t\t\tsb.append(StringPool.PERCENT);\n\n\t\t\t\t\tdynamicQuery.add(\n\t\t\t\t\t\tRestrictionsFactoryUtil.like(\n\t\t\t\t\t\t\t\"treePath\", sb.toString()));\n\t\t\t\t}\n\n\t\t\t});\n\t\tsyncDLObjectActionableDynamicQuery.setPerformActionMethod(\n\t\t\tnew ActionableDynamicQuery.PerformActionMethod<SyncDLObject>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void performAction(SyncDLObject dependentSyncDLObject)\n\t\t\t\t\tthrows PortalException {\n\n\t\t\t\t\tString treePath = dependentSyncDLObject.getTreePath();\n\n\t\t\t\t\tString oldParentTreePath = treePath.substring(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttreePath.indexOf(searchTreePath) +\n\t\t\t\t\t\t\tsearchTreePath.length());\n\n\t\t\t\t\ttreePath = StringUtil.replaceFirst(\n\t\t\t\t\t\ttreePath, oldParentTreePath,\n\t\t\t\t\t\tparentSyncDLObject.getTreePath());\n\n\t\t\t\t\tdependentSyncDLObject.setUserId(\n\t\t\t\t\t\tparentSyncDLObject.getUserId());\n\t\t\t\t\tdependentSyncDLObject.setUserName(\n\t\t\t\t\t\tparentSyncDLObject.getUserName());\n\t\t\t\t\tdependentSyncDLObject.setTreePath(treePath);\n\n\t\t\t\t\tsyncDLObjectPersistence.update(dependentSyncDLObject);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tsyncDLObjectActionableDynamicQuery.performActions();\n\t}","id":3261,"modified_method":"@Override\n\tpublic void moveDependentSyncDLObjects(\n\t\t\tfinal SyncDLObject parentSyncDLObject)\n\t\tthrows PortalException {\n\n\t\tfinal String searchTreePath = StringUtil.quote(\n\t\t\tString.valueOf(parentSyncDLObject.getTypePK()), StringPool.SLASH);\n\n\t\tActionableDynamicQuery syncDLObjectActionableDynamicQuery =\n\t\t\tgetActionableDynamicQuery();\n\n\t\tsyncDLObjectActionableDynamicQuery.setAddCriteriaMethod(\n\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tdynamicQuery.add(\n\t\t\t\t\t\tRestrictionsFactoryUtil.like(\n\t\t\t\t\t\t\t\"treePath\",\n\t\t\t\t\t\t\tStringUtil.quote(\n\t\t\t\t\t\t\t\tsearchTreePath, StringPool.PERCENT)));\n\t\t\t\t}\n\n\t\t\t});\n\t\tsyncDLObjectActionableDynamicQuery.setPerformActionMethod(\n\t\t\tnew ActionableDynamicQuery.PerformActionMethod<SyncDLObject>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void performAction(SyncDLObject dependentSyncDLObject)\n\t\t\t\t\tthrows PortalException {\n\n\t\t\t\t\tString treePath = dependentSyncDLObject.getTreePath();\n\n\t\t\t\t\tString oldParentTreePath = treePath.substring(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttreePath.indexOf(searchTreePath) +\n\t\t\t\t\t\t\tsearchTreePath.length());\n\n\t\t\t\t\ttreePath = StringUtil.replaceFirst(\n\t\t\t\t\t\ttreePath, oldParentTreePath,\n\t\t\t\t\t\tparentSyncDLObject.getTreePath());\n\n\t\t\t\t\tdependentSyncDLObject.setUserId(\n\t\t\t\t\t\tparentSyncDLObject.getUserId());\n\t\t\t\t\tdependentSyncDLObject.setUserName(\n\t\t\t\t\t\tparentSyncDLObject.getUserName());\n\t\t\t\t\tdependentSyncDLObject.setTreePath(treePath);\n\n\t\t\t\t\tsyncDLObjectPersistence.update(dependentSyncDLObject);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tsyncDLObjectActionableDynamicQuery.performActions();\n\t}","commit_id":"6473cdf12b95a219a92ce60fed8591cd709c2abc","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String getUuid() {\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(_layoutSet.getLayoutSetId());\n\t\tsb.append(StringPool.POUND);\n\t\tsb.append(_layoutSet.getGroupId());\n\t\tsb.append(StringPool.POUND);\n\t\tsb.append(_layoutSet.isPrivateLayout());\n\n\t\treturn sb.toString();\n\t}","id":3262,"modified_method":"public String getUuid() {\n\t\treturn String.valueOf(_layoutSet.isPrivateLayout());\n\t}","commit_id":"0ace6e830a7a2aea44fa471b6a870a1f0bf335eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(6);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\n\t\tUser receiverUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getReceiverUserId());\n\n\t\tsb.append(HtmlUtil.escapeURL(receiverUser.getScreenName()));\n\n\t\tsb.append(\"/profile/-/wall/\");\n\t\tsb.append(activity.getClassPK());\n\n\t\treturn sb.toString();\n\t}","id":3263,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tUser receiverUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getReceiverUserId());\n\n\t\tString wallLayoutFriendlyURL = WallUtil.getWallLayoutFriendlyURL(\n\t\t\treceiverUser);\n\n\t\treturn WallUtil.getWallLink(\n\t\t\treceiverUser, wallLayoutFriendlyURL,\n\t\t\tString.valueOf(activity.getClassPK()),\n\t\t\tserviceContext.getThemeDisplay());\n\t}","commit_id":"e6bbe001fce36a002bbb22dd9955519a521fde58","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private List<TemplateResponse> createSwiftTemplateResponses(long templateId) {\r\n        VirtualMachineTemplate template = findTemplateById(templateId);\r\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\r\n        VMTemplateSwiftVO templateSwiftRef = ApiDBUtils.findTemplateSwiftRef(templateId);\r\n        if (templateSwiftRef == null) {\r\n            return responses;\r\n        }\r\n\r\n        TemplateResponse templateResponse = new TemplateResponse();\r\n        templateResponse.setId(template.getId());\r\n        templateResponse.setName(template.getName());\r\n        templateResponse.setDisplayText(template.getDisplayText());\r\n        templateResponse.setPublic(template.isPublicTemplate());\r\n        templateResponse.setCreated(templateSwiftRef.getCreated());\r\n\r\n        templateResponse.setReady(true);\r\n        templateResponse.setFeatured(template.isFeatured());\r\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\r\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\r\n        templateResponse.setCrossZones(template.isCrossZones());\r\n        templateResponse.setFormat(template.getFormat());\r\n        templateResponse.setDetails(template.getDetails());\r\n        if (template.getTemplateType() != null) {\r\n            templateResponse.setTemplateType(template.getTemplateType().toString());\r\n        }\r\n        templateResponse.setHypervisor(template.getHypervisorType().toString());\r\n\r\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\r\n        if (os != null) {\r\n            templateResponse.setOsTypeId(os.getId());\r\n            templateResponse.setOsTypeName(os.getDisplayName());\r\n        } else {\r\n            templateResponse.setOsTypeId(-1L);\r\n            templateResponse.setOsTypeName(\"\");\r\n        }\r\n\r\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\r\n        populateAccount(templateResponse, account.getId());\r\n        populateDomain(templateResponse, account.getDomainId());\r\n\r\n        Account caller = UserContext.current().getCaller();\r\n        boolean isAdmin = false;\r\n        if ((caller == null) || BaseCmd.isAdmin(caller.getType())) {\r\n            isAdmin = true;\r\n        }\r\n\r\n        // If the user is an Admin, add the template download status\r\n        if (isAdmin || caller.getId() == template.getAccountId()) {\r\n            // add download status\r\n            templateResponse.setStatus(\"Successfully Installed\");\r\n        }\r\n\r\n        Long templateSize = templateSwiftRef.getSize();\r\n        if (templateSize > 0) {\r\n            templateResponse.setSize(templateSize);\r\n        }\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n        templateResponse.setSourceTemplateId(template.getSourceTemplateId());\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n\r\n        templateResponse.setTemplateTag(template.getTemplateTag());\r\n\r\n        templateResponse.setObjectName(\"template\");\r\n        responses.add(templateResponse);\r\n        return responses;\r\n    }","id":3264,"modified_method":"private List<TemplateResponse> createSwiftTemplateResponses(long templateId) {\r\n        VirtualMachineTemplate template = findTemplateById(templateId);\r\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\r\n        VMTemplateSwiftVO templateSwiftRef = ApiDBUtils.findTemplateSwiftRef(templateId);\r\n        if (templateSwiftRef == null) {\r\n            return responses;\r\n        }\r\n\r\n        TemplateResponse templateResponse = new TemplateResponse();\r\n        templateResponse.setId(template.getId());\r\n        templateResponse.setName(template.getName());\r\n        templateResponse.setDisplayText(template.getDisplayText());\r\n        templateResponse.setPublic(template.isPublicTemplate());\r\n        templateResponse.setCreated(templateSwiftRef.getCreated());\r\n\r\n        templateResponse.setReady(true);\r\n        templateResponse.setFeatured(template.isFeatured());\r\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\r\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\r\n        templateResponse.setCrossZones(template.isCrossZones());\r\n        templateResponse.setFormat(template.getFormat());\r\n        templateResponse.setDetails(template.getDetails());\r\n        if (template.getTemplateType() != null) {\r\n            templateResponse.setTemplateType(template.getTemplateType().toString());\r\n        }\r\n        \r\n        Account caller = UserContext.current().getCaller();\r\n        if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n            templateResponse.setHypervisor(template.getHypervisorType().toString());\r\n        }\r\n\r\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\r\n        if (os != null) {\r\n            templateResponse.setOsTypeId(os.getId());\r\n            templateResponse.setOsTypeName(os.getDisplayName());\r\n        } else {\r\n            templateResponse.setOsTypeId(-1L);\r\n            templateResponse.setOsTypeName(\"\");\r\n        }\r\n\r\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\r\n        populateAccount(templateResponse, account.getId());\r\n        populateDomain(templateResponse, account.getDomainId());\r\n\r\n        boolean isAdmin = false;\r\n        if (BaseCmd.isAdmin(caller.getType())) {\r\n            isAdmin = true;\r\n        }\r\n\r\n        // If the user is an Admin, add the template download status\r\n        if (isAdmin || caller.getId() == template.getAccountId()) {\r\n            // add download status\r\n            templateResponse.setStatus(\"Successfully Installed\");\r\n        }\r\n\r\n        Long templateSize = templateSwiftRef.getSize();\r\n        if (templateSize > 0) {\r\n            templateResponse.setSize(templateSize);\r\n        }\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n        templateResponse.setSourceTemplateId(template.getSourceTemplateId());\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n\r\n        templateResponse.setTemplateTag(template.getTemplateTag());\r\n\r\n        templateResponse.setObjectName(\"template\");\r\n        responses.add(templateResponse);\r\n        return responses;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"public UserVmData newUserVmData(UserVm userVm){\r\n        UserVmData userVmData = new UserVmData();\r\n        userVmData.setId(userVm.getId());\r\n        userVmData.setName(userVm.getHostName());\r\n        userVmData.setCreated(userVm.getCreated());\r\n        userVmData.setGuestOsId(userVm.getGuestOSId());\r\n        userVmData.setHaEnable(userVm.isHaEnabled());\r\n        if (userVm.getState() != null) {\r\n            userVmData.setState(userVm.getState().toString());\r\n        }\r\n        if (userVm.getDisplayName() != null) {\r\n            userVmData.setDisplayName(userVm.getDisplayName());\r\n        } else {\r\n            userVmData.setDisplayName(userVm.getHostName());\r\n        } \r\n        userVmData.setDomainId(userVm.getDomainId());\r\n\r\n        if (userVm.getHypervisorType() != null) {\r\n            userVmData.setHypervisor(userVm.getHypervisorType().toString());\r\n        }\r\n\r\n        if (userVm.getPassword() != null) {\r\n            userVmData.setPassword(userVm.getPassword());\r\n        }\r\n        return userVmData;\r\n    }","id":3265,"modified_method":"public UserVmData newUserVmData(UserVm userVm){\r\n        UserVmData userVmData = new UserVmData();\r\n        userVmData.setId(userVm.getId());\r\n        userVmData.setName(userVm.getHostName());\r\n        userVmData.setCreated(userVm.getCreated());\r\n        userVmData.setGuestOsId(userVm.getGuestOSId());\r\n        userVmData.setHaEnable(userVm.isHaEnabled());\r\n        if (userVm.getState() != null) {\r\n            userVmData.setState(userVm.getState().toString());\r\n        }\r\n        if (userVm.getDisplayName() != null) {\r\n            userVmData.setDisplayName(userVm.getDisplayName());\r\n        } else {\r\n            userVmData.setDisplayName(userVm.getHostName());\r\n        } \r\n        userVmData.setDomainId(userVm.getDomainId());\r\n\r\n        Account caller = UserContext.current().getCaller();\r\n        if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n        \tif (userVm.getHypervisorType() != null) {\r\n                userVmData.setHypervisor(userVm.getHypervisorType().toString());\r\n            }\r\n        }\r\n\r\n        if (userVm.getPassword() != null) {\r\n            userVmData.setPassword(userVm.getPassword());\r\n        }\r\n        return userVmData;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public TemplateResponse createIsoResponse(VirtualMachineTemplate result) {\r\n        TemplateResponse response = new TemplateResponse();\r\n        response.setId(result.getId());\r\n        response.setName(result.getName());\r\n        response.setDisplayText(result.getDisplayText());\r\n        response.setPublic(result.isPublicTemplate());\r\n        response.setCreated(result.getCreated());\r\n        response.setFormat(result.getFormat());\r\n        response.setOsTypeId(result.getGuestOSId());\r\n        response.setOsTypeName(ApiDBUtils.findGuestOSById(result.getGuestOSId()).getDisplayName());\r\n        response.setDetails(result.getDetails());\r\n\r\n        if (result.getFormat() == ImageFormat.ISO) { // Templates are always bootable\r\n            response.setBootable(result.isBootable());\r\n        } else {\r\n            response.setHypervisor(result.getHypervisorType().toString());// hypervisors are associated with templates\r\n        }\r\n\r\n        // add account ID and name\r\n        Account owner = ApiDBUtils.findAccountById(result.getAccountId());\r\n        populateAccount(response, owner.getId());\r\n        populateDomain(response, owner.getDomainId());\r\n        \r\n        response.setObjectName(\"iso\");\r\n        return response;\r\n    }","id":3266,"modified_method":"@Override\r\n    public TemplateResponse createIsoResponse(VirtualMachineTemplate result) {\r\n        TemplateResponse response = new TemplateResponse();\r\n        response.setId(result.getId());\r\n        response.setName(result.getName());\r\n        response.setDisplayText(result.getDisplayText());\r\n        response.setPublic(result.isPublicTemplate());\r\n        response.setCreated(result.getCreated());\r\n        response.setFormat(result.getFormat());\r\n        response.setOsTypeId(result.getGuestOSId());\r\n        response.setOsTypeName(ApiDBUtils.findGuestOSById(result.getGuestOSId()).getDisplayName());\r\n        response.setDetails(result.getDetails());\r\n        Account caller = UserContext.current().getCaller();\r\n\r\n        if (result.getFormat() == ImageFormat.ISO) { // Templates are always bootable\r\n            response.setBootable(result.isBootable()); \r\n        } else if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n            response.setHypervisor(result.getHypervisorType().toString());// hypervisors are associated with templates\r\n        }\r\n\r\n        // add account ID and name\r\n        Account owner = ApiDBUtils.findAccountById(result.getAccountId());\r\n        populateAccount(response, owner.getId());\r\n        populateDomain(response, owner.getDomainId());\r\n        \r\n        response.setObjectName(\"iso\");\r\n        return response;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public VolumeResponse createVolumeResponse(Volume volume) {\r\n        VolumeResponse volResponse = new VolumeResponse();\r\n        volResponse.setId(volume.getId());\r\n\r\n        if (volume.getName() != null) {\r\n            volResponse.setName(volume.getName());\r\n        } else {\r\n            volResponse.setName(\"\");\r\n        }\r\n\r\n        volResponse.setZoneId(volume.getDataCenterId());\r\n        volResponse.setZoneName(ApiDBUtils.findZoneById(volume.getDataCenterId()).getName());\r\n\r\n        volResponse.setVolumeType(volume.getVolumeType().toString());\r\n        volResponse.setDeviceId(volume.getDeviceId());\r\n\r\n        Long instanceId = volume.getInstanceId();\r\n        if (instanceId != null && volume.getState() != Volume.State.Destroy) {\r\n            VMInstanceVO vm = ApiDBUtils.findVMInstanceById(instanceId);\r\n            if(vm != null){\r\n            \tvolResponse.setVirtualMachineId(vm.getId());\r\n            \tvolResponse.setVirtualMachineName(vm.getHostName());\r\n            \tUserVm userVm = ApiDBUtils.findUserVmById(vm.getId());\r\n            \tif (userVm != null) {\r\n            \t\tvolResponse.setVirtualMachineDisplayName(userVm.getDisplayName());\r\n            \t\tvolResponse.setVirtualMachineState(vm.getState().toString());\r\n            \t} else {\r\n            \t\ts_logger.error(\"User Vm with Id: \"+instanceId+\" does not exist for volume \"+volume.getId());\t\r\n            \t}\r\n            } else {\r\n            \ts_logger.error(\"Vm with Id: \"+instanceId+\" does not exist for volume \"+volume.getId());\t\r\n            }\r\n        }\r\n\r\n        // Show the virtual size of the volume\r\n        volResponse.setSize(volume.getSize());\r\n\r\n        volResponse.setCreated(volume.getCreated());\r\n        volResponse.setState(volume.getState().toString());\r\n\r\n        populateOwner(volResponse, volume);\r\n\r\n        String storageType;\r\n        try {\r\n            if (volume.getPoolId() == null) {\r\n                if (volume.getState() == Volume.State.Allocated) {\r\n                    /* set it as shared, so the UI can attach it to VM */\r\n                    storageType = \"shared\";\r\n                } else {\r\n                    storageType = \"unknown\";\r\n                }\r\n            } else {\r\n                storageType = ApiDBUtils.volumeIsOnSharedStorage(volume.getId()) ? ServiceOffering.StorageType.shared.toString() : ServiceOffering.StorageType.local.toString();\r\n            }\r\n        } catch (InvalidParameterValueException e) {\r\n            s_logger.error(e.getMessage(), e);\r\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Volume \" + volume.getName() + \" does not have a valid ID\");\r\n        }\r\n\r\n        volResponse.setStorageType(storageType);\r\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\r\n            volResponse.setServiceOfferingId(volume.getDiskOfferingId());\r\n        } else {\r\n            volResponse.setDiskOfferingId(volume.getDiskOfferingId());\r\n        }\r\n\r\n        DiskOfferingVO diskOffering = ApiDBUtils.findDiskOfferingById(volume.getDiskOfferingId());\r\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\r\n            volResponse.setServiceOfferingName(diskOffering.getName());\r\n            volResponse.setServiceOfferingDisplayText(diskOffering.getDisplayText());\r\n        } else {\r\n            volResponse.setDiskOfferingName(diskOffering.getName());\r\n            volResponse.setDiskOfferingDisplayText(diskOffering.getDisplayText());\r\n        }\r\n\r\n        Long poolId = volume.getPoolId();\r\n        String poolName = (poolId == null) ? \"none\" : ApiDBUtils.findStoragePoolById(poolId).getName();\r\n        volResponse.setStoragePoolName(poolName);\r\n        // volResponse.setSourceId(volume.getSourceId());\r\n        // if (volume.getSourceType() != null) {\r\n        // volResponse.setSourceType(volume.getSourceType().toString());\r\n        // }\r\n        volResponse.setHypervisor(ApiDBUtils.getVolumeHyperType(volume.getId()).toString());\r\n        volResponse.setAttached(volume.getAttached());\r\n        volResponse.setDestroyed(volume.getState() == Volume.State.Destroy);\r\n        VMTemplateVO template = ApiDBUtils.findTemplateById(volume.getTemplateId());\r\n        boolean isExtractable = template != null && template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM);\r\n        volResponse.setExtractable(isExtractable);\r\n        volResponse.setObjectName(\"volume\");\r\n        return volResponse;\r\n    }","id":3267,"modified_method":"@Override\r\n    public VolumeResponse createVolumeResponse(Volume volume) {\r\n        VolumeResponse volResponse = new VolumeResponse();\r\n        volResponse.setId(volume.getId());\r\n\r\n        if (volume.getName() != null) {\r\n            volResponse.setName(volume.getName());\r\n        } else {\r\n            volResponse.setName(\"\");\r\n        }\r\n\r\n        volResponse.setZoneId(volume.getDataCenterId());\r\n        volResponse.setZoneName(ApiDBUtils.findZoneById(volume.getDataCenterId()).getName());\r\n\r\n        volResponse.setVolumeType(volume.getVolumeType().toString());\r\n        volResponse.setDeviceId(volume.getDeviceId());\r\n\r\n        Long instanceId = volume.getInstanceId();\r\n        if (instanceId != null && volume.getState() != Volume.State.Destroy) {\r\n            VMInstanceVO vm = ApiDBUtils.findVMInstanceById(instanceId);\r\n            if(vm != null){\r\n            \tvolResponse.setVirtualMachineId(vm.getId());\r\n            \tvolResponse.setVirtualMachineName(vm.getHostName());\r\n            \tUserVm userVm = ApiDBUtils.findUserVmById(vm.getId());\r\n            \tif (userVm != null) {\r\n            \t\tvolResponse.setVirtualMachineDisplayName(userVm.getDisplayName());\r\n            \t\tvolResponse.setVirtualMachineState(vm.getState().toString());\r\n            \t} else {\r\n            \t\ts_logger.error(\"User Vm with Id: \"+instanceId+\" does not exist for volume \"+volume.getId());\t\r\n            \t}\r\n            } else {\r\n            \ts_logger.error(\"Vm with Id: \"+instanceId+\" does not exist for volume \"+volume.getId());\t\r\n            }\r\n        }\r\n\r\n        // Show the virtual size of the volume\r\n        volResponse.setSize(volume.getSize());\r\n\r\n        volResponse.setCreated(volume.getCreated());\r\n        volResponse.setState(volume.getState().toString());\r\n\r\n        populateOwner(volResponse, volume);\r\n\r\n        String storageType;\r\n        try {\r\n            if (volume.getPoolId() == null) {\r\n                if (volume.getState() == Volume.State.Allocated) {\r\n                    /* set it as shared, so the UI can attach it to VM */\r\n                    storageType = \"shared\";\r\n                } else {\r\n                    storageType = \"unknown\";\r\n                }\r\n            } else {\r\n                storageType = ApiDBUtils.volumeIsOnSharedStorage(volume.getId()) ? ServiceOffering.StorageType.shared.toString() : ServiceOffering.StorageType.local.toString();\r\n            }\r\n        } catch (InvalidParameterValueException e) {\r\n            s_logger.error(e.getMessage(), e);\r\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Volume \" + volume.getName() + \" does not have a valid ID\");\r\n        }\r\n\r\n        volResponse.setStorageType(storageType);\r\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\r\n            volResponse.setServiceOfferingId(volume.getDiskOfferingId());\r\n        } else {\r\n            volResponse.setDiskOfferingId(volume.getDiskOfferingId());\r\n        }\r\n\r\n        DiskOfferingVO diskOffering = ApiDBUtils.findDiskOfferingById(volume.getDiskOfferingId());\r\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\r\n            volResponse.setServiceOfferingName(diskOffering.getName());\r\n            volResponse.setServiceOfferingDisplayText(diskOffering.getDisplayText());\r\n        } else {\r\n            volResponse.setDiskOfferingName(diskOffering.getName());\r\n            volResponse.setDiskOfferingDisplayText(diskOffering.getDisplayText());\r\n        }\r\n\r\n        Long poolId = volume.getPoolId();\r\n        String poolName = (poolId == null) ? \"none\" : ApiDBUtils.findStoragePoolById(poolId).getName();\r\n        volResponse.setStoragePoolName(poolName);\r\n        // volResponse.setSourceId(volume.getSourceId());\r\n        // if (volume.getSourceType() != null) {\r\n        // volResponse.setSourceType(volume.getSourceType().toString());\r\n        // }\r\n        \r\n        //return hypervisor for ROOT and Resource domain only\r\n        Account caller = UserContext.current().getCaller();\r\n        if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n            volResponse.setHypervisor(ApiDBUtils.getVolumeHyperType(volume.getId()).toString());\r\n        }\r\n        \r\n        volResponse.setAttached(volume.getAttached());\r\n        volResponse.setDestroyed(volume.getState() == Volume.State.Destroy);\r\n        VMTemplateVO template = ApiDBUtils.findTemplateById(volume.getTemplateId());\r\n        boolean isExtractable = template != null && template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM);\r\n        volResponse.setExtractable(isExtractable);\r\n        volResponse.setObjectName(\"volume\");\r\n        return volResponse;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public List<UserVmResponse> createUserVmResponse(String objectName, EnumSet<VMDetails> details, UserVm...userVms) {\r\n        Account caller = UserContext.current().getCaller();\r\n        Map<Long, DataCenter> dataCenters = new HashMap<Long, DataCenter>();\r\n        Map<Long, Host> hosts = new HashMap<Long, Host>();\r\n        Map<Long, VMTemplateVO> templates = new HashMap<Long, VMTemplateVO>();\r\n        Map<Long, ServiceOffering> serviceOfferings = new HashMap<Long, ServiceOffering>();\r\n        Map<Long, Network> networks = new HashMap<Long, Network>();\r\n        \r\n        List<UserVmResponse> vmResponses = new ArrayList<UserVmResponse>();\r\n         \r\n        for (UserVm userVm : userVms) {\r\n            UserVmResponse userVmResponse = new UserVmResponse();\r\n            Account acct = ApiDBUtils.findAccountById(Long.valueOf(userVm.getAccountId()));\r\n            if (acct != null) {\r\n                userVmResponse.setAccountName(acct.getAccountName());\r\n                userVmResponse.setDomainId(acct.getDomainId());\r\n                userVmResponse.setDomainName(ApiDBUtils.findDomainById(acct.getDomainId()).getName());\r\n            }\r\n\r\n            userVmResponse.setId(userVm.getId());\r\n            userVmResponse.setName(userVm.getHostName());\r\n            userVmResponse.setCreated(userVm.getCreated());\r\n\r\n            if (userVm.getState() != null) {\r\n                userVmResponse.setState(userVm.getState().toString());\r\n            }\r\n\r\n            userVmResponse.setHaEnable(userVm.isHaEnabled());\r\n\r\n            if (userVm.getDisplayName() != null) {\r\n                userVmResponse.setDisplayName(userVm.getDisplayName());\r\n            } else {\r\n                userVmResponse.setDisplayName(userVm.getHostName());\r\n            }\r\n            \r\n\r\n            if (userVm.getPassword() != null) {\r\n                userVmResponse.setPassword(userVm.getPassword());\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.group)){\r\n                InstanceGroupVO group = ApiDBUtils.findInstanceGroupForVM(userVm.getId());\r\n                if (group != null) {\r\n                    userVmResponse.setGroup(group.getName());\r\n                    userVmResponse.setGroupId(group.getId());\r\n                }\r\n            \t\r\n            }\r\n\r\n            // Data Center Info\r\n            DataCenter zone = dataCenters.get(userVm.getDataCenterIdToDeployIn());\r\n            if (zone == null) {\r\n                zone = ApiDBUtils.findZoneById(userVm.getDataCenterIdToDeployIn());\r\n                dataCenters.put(zone.getId(), zone);\r\n            }\r\n            \r\n            userVmResponse.setZoneId(zone.getId());\r\n            userVmResponse.setZoneName(zone.getName());\r\n\r\n            \r\n            // if user is an admin, display host id\r\n            if (((caller == null) || (caller.getType() == Account.ACCOUNT_TYPE_ADMIN)) && (userVm.getHostId() != null)) {\r\n                Host host = hosts.get(userVm.getHostId());\r\n                \r\n                if (host == null) {\r\n                    host = ApiDBUtils.findHostById(userVm.getHostId());\r\n                    hosts.put(host.getId(), host);\r\n                }\r\n                \r\n                userVmResponse.setHostId(host.getId());\r\n                userVmResponse.setHostName(host.getName());\r\n            }\r\n\r\n            if(userVm.getHypervisorType() != null){\r\n                userVmResponse.setHypervisor(userVm.getHypervisorType().toString());\r\n            }\r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.tmpl)){\r\n\t            // Template Info\r\n\t            VMTemplateVO template = templates.get(userVm.getTemplateId());\r\n\t            if (template == null) {\r\n\t                template =  ApiDBUtils.findTemplateById(userVm.getTemplateId());\r\n\t                if (template != null) {\r\n\t                    templates.put(template.getId(), template);\r\n\t                }\r\n\t            }\r\n\t            \r\n\t            if (template != null) {\r\n\t                userVmResponse.setTemplateId(userVm.getTemplateId());\r\n\t                userVmResponse.setTemplateName(template.getName());\r\n\t                userVmResponse.setTemplateDisplayText(template.getDisplayText());\r\n\t                userVmResponse.setPasswordEnabled(template.getEnablePassword());\r\n\t            } else {\r\n\t                userVmResponse.setTemplateId(-1L);\r\n\t                userVmResponse.setTemplateName(\"ISO Boot\");\r\n\t                userVmResponse.setTemplateDisplayText(\"ISO Boot\");\r\n\t                userVmResponse.setPasswordEnabled(false);\r\n\t            }\r\n            }\r\n\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.iso)){\r\n\t            // ISO Info\r\n\t            VMTemplateVO iso = templates.get(userVm.getIsoId());\r\n\t            if (iso == null) {\r\n\t                iso =  ApiDBUtils.findTemplateById(userVm.getIsoId());\r\n\t                if (iso != null) {\r\n\t                    templates.put(iso.getId(), iso);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (iso != null) {\r\n\t                userVmResponse.setIsoId(iso.getId());\r\n\t                userVmResponse.setIsoName(iso.getName());\r\n\t            }\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.servoff)){\r\n\t            // Service Offering Info\r\n\t            ServiceOffering offering = serviceOfferings.get(userVm.getServiceOfferingId());\r\n\t            \r\n\t            if (offering == null) {\r\n\t                offering = ApiDBUtils.findServiceOfferingById(userVm.getServiceOfferingId());\r\n\t                serviceOfferings.put(offering.getId(), offering);\r\n\t            }\r\n\t            \r\n\t            userVmResponse.setServiceOfferingId(offering.getId());\r\n\t            userVmResponse.setServiceOfferingName(offering.getName());\r\n\t            userVmResponse.setCpuNumber(offering.getCpu());\r\n\t            userVmResponse.setCpuSpeed(offering.getSpeed());\r\n\t            userVmResponse.setMemory(offering.getRamSize());\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.volume)){\r\n\t            VolumeVO rootVolume = ApiDBUtils.findRootVolume(userVm.getId());\r\n\t            if (rootVolume != null) {\r\n\t                userVmResponse.setRootDeviceId(rootVolume.getDeviceId());\r\n\t                String rootDeviceType = \"Not created\";\r\n\t                if (rootVolume.getPoolId() != null) {\r\n\t                    StoragePoolVO storagePool = ApiDBUtils.findStoragePoolById(rootVolume.getPoolId());\r\n\t                    rootDeviceType = storagePool.getPoolType().toString();\r\n\t                }\r\n\t                userVmResponse.setRootDeviceType(rootDeviceType);\r\n\t            }\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.stats)){\r\n\t            // stats calculation\r\n\t            DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\r\n\t            String cpuUsed = null;\r\n\t            VmStats vmStats = ApiDBUtils.getVmStatistics(userVm.getId());\r\n\t            if (vmStats != null) {\r\n\t                float cpuUtil = (float) vmStats.getCPUUtilization();\r\n\t                cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\r\n\t                userVmResponse.setCpuUsed(cpuUsed);\r\n\t\r\n\t                Double networkKbRead = Double.valueOf(vmStats.getNetworkReadKBs());\r\n\t                userVmResponse.setNetworkKbsRead(networkKbRead.longValue());\r\n\t\r\n\t                Double networkKbWrite = Double.valueOf(vmStats.getNetworkWriteKBs());\r\n\t                userVmResponse.setNetworkKbsWrite(networkKbWrite.longValue());\r\n\t            }\r\n            }\r\n\r\n            userVmResponse.setGuestOsId(userVm.getGuestOSId());\r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.secgrp)){\r\n\t            // security groups - list only when zone is security group enabled\r\n\t            if (zone.isSecurityGroupEnabled()) {\r\n\t                List<SecurityGroupVO> securityGroups = ApiDBUtils.getSecurityGroupsForVm(userVm.getId());\r\n\t                List<SecurityGroupResponse> securityGroupResponse = new ArrayList<SecurityGroupResponse>();\r\n\t                for(SecurityGroupVO grp : securityGroups) {\r\n\t                    SecurityGroupResponse resp = new SecurityGroupResponse();\r\n\t                    resp.setId(grp.getId());\r\n\t                    resp.setName(grp.getName());\r\n\t                    resp.setDescription(grp.getDescription());\r\n\t                    resp.setObjectName(\"securitygroup\");\r\n\t                    securityGroupResponse.add(resp);\r\n\t                }\r\n\t                userVmResponse.setSecurityGroupList(securityGroupResponse);\r\n\t            }\r\n            }\r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.nics)){\r\n\t            List<NicProfile> nicProfiles = ApiDBUtils.getNics(userVm);\r\n\t            List<NicResponse> nicResponses = new ArrayList<NicResponse>();\r\n\t            for (NicProfile singleNicProfile : nicProfiles) {\r\n\t                NicResponse nicResponse = new NicResponse();\r\n\t                nicResponse.setId(singleNicProfile.getId());\r\n\t                nicResponse.setIpaddress(singleNicProfile.getIp4Address());\r\n\t                nicResponse.setGateway(singleNicProfile.getGateway());\r\n\t                nicResponse.setNetmask(singleNicProfile.getNetmask());\r\n\t                nicResponse.setNetworkid(singleNicProfile.getNetworkId());\r\n\t                if (acct.getType() == Account.ACCOUNT_TYPE_ADMIN) {\r\n\t                    if (singleNicProfile.getBroadCastUri() != null) {\r\n\t                        nicResponse.setBroadcastUri(singleNicProfile.getBroadCastUri().toString());\r\n\t                    }\r\n\t                    if (singleNicProfile.getIsolationUri() != null) {\r\n\t                        nicResponse.setIsolationUri(singleNicProfile.getIsolationUri().toString());\r\n\t                    }\r\n\t                } \r\n\t                \r\n\t                //Long networkId = singleNicProfile.getNetworkId();\r\n\t                Network network = networks.get(singleNicProfile.getNetworkId());\r\n\t                if (network == null) {\r\n\t                    network = ApiDBUtils.findNetworkById(singleNicProfile.getNetworkId());\r\n\t                    networks.put(singleNicProfile.getNetworkId(), network);\r\n\t                }\r\n\t         \r\n\t                nicResponse.setTrafficType(network.getTrafficType().toString());\r\n\t                nicResponse.setType(network.getGuestType().toString());\r\n\t                nicResponse.setIsDefault(singleNicProfile.isDefaultNic());\r\n\t                nicResponse.setObjectName(\"nic\");\r\n\t                nicResponses.add(nicResponse);\r\n\t            }\r\n\t            userVmResponse.setNics(nicResponses);\r\n            }\r\n            \r\n            userVmResponse.setObjectName(objectName);\r\n            vmResponses.add(userVmResponse);\r\n        } \r\n       \r\n        return vmResponses;\r\n    }","id":3268,"modified_method":"@Override\r\n    public List<UserVmResponse> createUserVmResponse(String objectName, EnumSet<VMDetails> details, UserVm...userVms) {\r\n        Account caller = UserContext.current().getCaller();\r\n        Map<Long, DataCenter> dataCenters = new HashMap<Long, DataCenter>();\r\n        Map<Long, Host> hosts = new HashMap<Long, Host>();\r\n        Map<Long, VMTemplateVO> templates = new HashMap<Long, VMTemplateVO>();\r\n        Map<Long, ServiceOffering> serviceOfferings = new HashMap<Long, ServiceOffering>();\r\n        Map<Long, Network> networks = new HashMap<Long, Network>();\r\n        \r\n        List<UserVmResponse> vmResponses = new ArrayList<UserVmResponse>();\r\n         \r\n        for (UserVm userVm : userVms) {\r\n            UserVmResponse userVmResponse = new UserVmResponse();\r\n            Account acct = ApiDBUtils.findAccountById(Long.valueOf(userVm.getAccountId()));\r\n            if (acct != null) {\r\n                userVmResponse.setAccountName(acct.getAccountName());\r\n                userVmResponse.setDomainId(acct.getDomainId());\r\n                userVmResponse.setDomainName(ApiDBUtils.findDomainById(acct.getDomainId()).getName());\r\n            }\r\n\r\n            userVmResponse.setId(userVm.getId());\r\n            userVmResponse.setName(userVm.getHostName());\r\n            userVmResponse.setCreated(userVm.getCreated());\r\n\r\n            if (userVm.getState() != null) {\r\n                userVmResponse.setState(userVm.getState().toString());\r\n            }\r\n\r\n            userVmResponse.setHaEnable(userVm.isHaEnabled());\r\n\r\n            if (userVm.getDisplayName() != null) {\r\n                userVmResponse.setDisplayName(userVm.getDisplayName());\r\n            } else {\r\n                userVmResponse.setDisplayName(userVm.getHostName());\r\n            }\r\n            \r\n\r\n            if (userVm.getPassword() != null) {\r\n                userVmResponse.setPassword(userVm.getPassword());\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.group)){\r\n                InstanceGroupVO group = ApiDBUtils.findInstanceGroupForVM(userVm.getId());\r\n                if (group != null) {\r\n                    userVmResponse.setGroup(group.getName());\r\n                    userVmResponse.setGroupId(group.getId());\r\n                }\r\n            \t\r\n            }\r\n\r\n            // Data Center Info\r\n            DataCenter zone = dataCenters.get(userVm.getDataCenterIdToDeployIn());\r\n            if (zone == null) {\r\n                zone = ApiDBUtils.findZoneById(userVm.getDataCenterIdToDeployIn());\r\n                dataCenters.put(zone.getId(), zone);\r\n            }\r\n            \r\n            userVmResponse.setZoneId(zone.getId());\r\n            userVmResponse.setZoneName(zone.getName());\r\n\r\n            \r\n            // if user is an admin, display host id\r\n            if (((caller == null) || (caller.getType() == Account.ACCOUNT_TYPE_ADMIN)) && (userVm.getHostId() != null)) {\r\n                Host host = hosts.get(userVm.getHostId());\r\n                \r\n                if (host == null) {\r\n                    host = ApiDBUtils.findHostById(userVm.getHostId());\r\n                    hosts.put(host.getId(), host);\r\n                }\r\n                \r\n                userVmResponse.setHostId(host.getId());\r\n                userVmResponse.setHostName(host.getName());\r\n            }\r\n\r\n            if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n            \tif (userVm.getHypervisorType() != null){\r\n                    userVmResponse.setHypervisor(userVm.getHypervisorType().toString());\r\n                }\r\n            }   \r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.tmpl)){\r\n\t            // Template Info\r\n\t            VMTemplateVO template = templates.get(userVm.getTemplateId());\r\n\t            if (template == null) {\r\n\t                template =  ApiDBUtils.findTemplateById(userVm.getTemplateId());\r\n\t                if (template != null) {\r\n\t                    templates.put(template.getId(), template);\r\n\t                }\r\n\t            }\r\n\t            \r\n\t            if (template != null) {\r\n\t                userVmResponse.setTemplateId(userVm.getTemplateId());\r\n\t                userVmResponse.setTemplateName(template.getName());\r\n\t                userVmResponse.setTemplateDisplayText(template.getDisplayText());\r\n\t                userVmResponse.setPasswordEnabled(template.getEnablePassword());\r\n\t            } else {\r\n\t                userVmResponse.setTemplateId(-1L);\r\n\t                userVmResponse.setTemplateName(\"ISO Boot\");\r\n\t                userVmResponse.setTemplateDisplayText(\"ISO Boot\");\r\n\t                userVmResponse.setPasswordEnabled(false);\r\n\t            }\r\n            }\r\n\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.iso)){\r\n\t            // ISO Info\r\n\t            VMTemplateVO iso = templates.get(userVm.getIsoId());\r\n\t            if (iso == null) {\r\n\t                iso =  ApiDBUtils.findTemplateById(userVm.getIsoId());\r\n\t                if (iso != null) {\r\n\t                    templates.put(iso.getId(), iso);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (iso != null) {\r\n\t                userVmResponse.setIsoId(iso.getId());\r\n\t                userVmResponse.setIsoName(iso.getName());\r\n\t            }\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.servoff)){\r\n\t            // Service Offering Info\r\n\t            ServiceOffering offering = serviceOfferings.get(userVm.getServiceOfferingId());\r\n\t            \r\n\t            if (offering == null) {\r\n\t                offering = ApiDBUtils.findServiceOfferingById(userVm.getServiceOfferingId());\r\n\t                serviceOfferings.put(offering.getId(), offering);\r\n\t            }\r\n\t            \r\n\t            userVmResponse.setServiceOfferingId(offering.getId());\r\n\t            userVmResponse.setServiceOfferingName(offering.getName());\r\n\t            userVmResponse.setCpuNumber(offering.getCpu());\r\n\t            userVmResponse.setCpuSpeed(offering.getSpeed());\r\n\t            userVmResponse.setMemory(offering.getRamSize());\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.volume)){\r\n\t            VolumeVO rootVolume = ApiDBUtils.findRootVolume(userVm.getId());\r\n\t            if (rootVolume != null) {\r\n\t                userVmResponse.setRootDeviceId(rootVolume.getDeviceId());\r\n\t                String rootDeviceType = \"Not created\";\r\n\t                if (rootVolume.getPoolId() != null) {\r\n\t                    StoragePoolVO storagePool = ApiDBUtils.findStoragePoolById(rootVolume.getPoolId());\r\n\t                    rootDeviceType = storagePool.getPoolType().toString();\r\n\t                }\r\n\t                userVmResponse.setRootDeviceType(rootDeviceType);\r\n\t            }\r\n            }\r\n\r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.stats)){\r\n\t            // stats calculation\r\n\t            DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\r\n\t            String cpuUsed = null;\r\n\t            VmStats vmStats = ApiDBUtils.getVmStatistics(userVm.getId());\r\n\t            if (vmStats != null) {\r\n\t                float cpuUtil = (float) vmStats.getCPUUtilization();\r\n\t                cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\r\n\t                userVmResponse.setCpuUsed(cpuUsed);\r\n\t\r\n\t                Double networkKbRead = Double.valueOf(vmStats.getNetworkReadKBs());\r\n\t                userVmResponse.setNetworkKbsRead(networkKbRead.longValue());\r\n\t\r\n\t                Double networkKbWrite = Double.valueOf(vmStats.getNetworkWriteKBs());\r\n\t                userVmResponse.setNetworkKbsWrite(networkKbWrite.longValue());\r\n\t            }\r\n            }\r\n\r\n            userVmResponse.setGuestOsId(userVm.getGuestOSId());\r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.secgrp)){\r\n\t            // security groups - list only when zone is security group enabled\r\n\t            if (zone.isSecurityGroupEnabled()) {\r\n\t                List<SecurityGroupVO> securityGroups = ApiDBUtils.getSecurityGroupsForVm(userVm.getId());\r\n\t                List<SecurityGroupResponse> securityGroupResponse = new ArrayList<SecurityGroupResponse>();\r\n\t                for(SecurityGroupVO grp : securityGroups) {\r\n\t                    SecurityGroupResponse resp = new SecurityGroupResponse();\r\n\t                    resp.setId(grp.getId());\r\n\t                    resp.setName(grp.getName());\r\n\t                    resp.setDescription(grp.getDescription());\r\n\t                    resp.setObjectName(\"securitygroup\");\r\n\t                    securityGroupResponse.add(resp);\r\n\t                }\r\n\t                userVmResponse.setSecurityGroupList(securityGroupResponse);\r\n\t            }\r\n            }\r\n            \r\n            if (details.contains(VMDetails.all) || details.contains(VMDetails.nics)){\r\n\t            List<NicProfile> nicProfiles = ApiDBUtils.getNics(userVm);\r\n\t            List<NicResponse> nicResponses = new ArrayList<NicResponse>();\r\n\t            for (NicProfile singleNicProfile : nicProfiles) {\r\n\t                NicResponse nicResponse = new NicResponse();\r\n\t                nicResponse.setId(singleNicProfile.getId());\r\n\t                nicResponse.setIpaddress(singleNicProfile.getIp4Address());\r\n\t                nicResponse.setGateway(singleNicProfile.getGateway());\r\n\t                nicResponse.setNetmask(singleNicProfile.getNetmask());\r\n\t                nicResponse.setNetworkid(singleNicProfile.getNetworkId());\r\n\t                if (acct.getType() == Account.ACCOUNT_TYPE_ADMIN) {\r\n\t                    if (singleNicProfile.getBroadCastUri() != null) {\r\n\t                        nicResponse.setBroadcastUri(singleNicProfile.getBroadCastUri().toString());\r\n\t                    }\r\n\t                    if (singleNicProfile.getIsolationUri() != null) {\r\n\t                        nicResponse.setIsolationUri(singleNicProfile.getIsolationUri().toString());\r\n\t                    }\r\n\t                } \r\n\t                \r\n\t                //Long networkId = singleNicProfile.getNetworkId();\r\n\t                Network network = networks.get(singleNicProfile.getNetworkId());\r\n\t                if (network == null) {\r\n\t                    network = ApiDBUtils.findNetworkById(singleNicProfile.getNetworkId());\r\n\t                    networks.put(singleNicProfile.getNetworkId(), network);\r\n\t                }\r\n\t         \r\n\t                nicResponse.setTrafficType(network.getTrafficType().toString());\r\n\t                nicResponse.setType(network.getGuestType().toString());\r\n\t                nicResponse.setIsDefault(singleNicProfile.isDefaultNic());\r\n\t                nicResponse.setObjectName(\"nic\");\r\n\t                nicResponses.add(nicResponse);\r\n\t            }\r\n\t            userVmResponse.setNics(nicResponses);\r\n            }\r\n            \r\n            userVmResponse.setObjectName(objectName);\r\n            vmResponses.add(userVmResponse);\r\n        } \r\n       \r\n        return vmResponses;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public List<TemplateResponse> createTemplateResponses(long templateId, long zoneId, boolean readyOnly) {\r\n        if (zoneId == 0) {\r\n            return createSwiftTemplateResponses(templateId);\r\n        }\r\n        VirtualMachineTemplate template = findTemplateById(templateId);\r\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\r\n        VMTemplateHostVO templateHostRef = ApiDBUtils.findTemplateHostRef(templateId, zoneId, readyOnly);\r\n        if (templateHostRef == null) {\r\n            return responses;\r\n        }\r\n\r\n        HostVO host = ApiDBUtils.findHostById(templateHostRef.getHostId());\r\n        if (host.getType() == Host.Type.LocalSecondaryStorage && host.getStatus() != com.cloud.host.Status.Up) {\r\n            return responses;\r\n        }\r\n\r\n        TemplateResponse templateResponse = new TemplateResponse();\r\n        templateResponse.setId(template.getId());\r\n        templateResponse.setName(template.getName());\r\n        templateResponse.setDisplayText(template.getDisplayText());\r\n        templateResponse.setPublic(template.isPublicTemplate());\r\n        templateResponse.setCreated(templateHostRef.getCreated());\r\n\r\n        templateResponse.setReady(templateHostRef.getDownloadState() == Status.DOWNLOADED);\r\n        templateResponse.setFeatured(template.isFeatured());\r\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\r\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\r\n        templateResponse.setCrossZones(template.isCrossZones());\r\n        templateResponse.setFormat(template.getFormat());\r\n        if (template.getTemplateType() != null) {\r\n            templateResponse.setTemplateType(template.getTemplateType().toString());\r\n        }\r\n        templateResponse.setHypervisor(template.getHypervisorType().toString());\r\n        templateResponse.setDetails(template.getDetails());\r\n\r\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\r\n        if (os != null) {\r\n            templateResponse.setOsTypeId(os.getId());\r\n            templateResponse.setOsTypeName(os.getDisplayName());\r\n        } else {\r\n            templateResponse.setOsTypeId(-1L);\r\n            templateResponse.setOsTypeName(\"\");\r\n        }\r\n\r\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\r\n        populateAccount(templateResponse, account.getId());\r\n        populateDomain(templateResponse, account.getDomainId());\r\n\r\n        DataCenterVO datacenter = ApiDBUtils.findZoneById(zoneId);\r\n\r\n        // Add the zone ID\r\n        templateResponse.setZoneId(zoneId);\r\n        templateResponse.setZoneName(datacenter.getName());\r\n\r\n        Account caller = UserContext.current().getCaller();\r\n        boolean isAdmin = false;\r\n        if ((caller == null) || BaseCmd.isAdmin(caller.getType())) {\r\n            isAdmin = true;\r\n        }\r\n\r\n        // If the user is an Admin, add the template download status\r\n        if (isAdmin || caller.getId() == template.getAccountId()) {\r\n            // add download status\r\n            if (templateHostRef.getDownloadState() != Status.DOWNLOADED) {\r\n                String templateStatus = \"Processing\";\r\n                if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\r\n                    if (templateHostRef.getDownloadPercent() == 100) {\r\n                        templateStatus = \"Installing Template\";\r\n                    } else {\r\n                        templateStatus = templateHostRef.getDownloadPercent() + \"% Downloaded\";\r\n                    }\r\n                } else {\r\n                    templateStatus = templateHostRef.getErrorString();\r\n                }\r\n                templateResponse.setStatus(templateStatus);\r\n            } else if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\r\n                templateResponse.setStatus(\"Download Complete\");\r\n            } else {\r\n                templateResponse.setStatus(\"Successfully Installed\");\r\n            }\r\n        }\r\n\r\n        Long templateSize = templateHostRef.getSize();\r\n        if (templateSize > 0) {\r\n            templateResponse.setSize(templateSize);\r\n        }\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n        templateResponse.setSourceTemplateId(template.getSourceTemplateId());\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n\r\n        templateResponse.setTemplateTag(template.getTemplateTag());\r\n\r\n        templateResponse.setObjectName(\"template\");\r\n        responses.add(templateResponse);\r\n        return responses;\r\n    }","id":3269,"modified_method":"@Override\r\n    public List<TemplateResponse> createTemplateResponses(long templateId, long zoneId, boolean readyOnly) {\r\n        if (zoneId == 0) {\r\n            return createSwiftTemplateResponses(templateId);\r\n        }\r\n        VirtualMachineTemplate template = findTemplateById(templateId);\r\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\r\n        VMTemplateHostVO templateHostRef = ApiDBUtils.findTemplateHostRef(templateId, zoneId, readyOnly);\r\n        if (templateHostRef == null) {\r\n            return responses;\r\n        }\r\n\r\n        HostVO host = ApiDBUtils.findHostById(templateHostRef.getHostId());\r\n        if (host.getType() == Host.Type.LocalSecondaryStorage && host.getStatus() != com.cloud.host.Status.Up) {\r\n            return responses;\r\n        }\r\n\r\n        TemplateResponse templateResponse = new TemplateResponse();\r\n        templateResponse.setId(template.getId());\r\n        templateResponse.setName(template.getName());\r\n        templateResponse.setDisplayText(template.getDisplayText());\r\n        templateResponse.setPublic(template.isPublicTemplate());\r\n        templateResponse.setCreated(templateHostRef.getCreated());\r\n\r\n        templateResponse.setReady(templateHostRef.getDownloadState() == Status.DOWNLOADED);\r\n        templateResponse.setFeatured(template.isFeatured());\r\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\r\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\r\n        templateResponse.setCrossZones(template.isCrossZones());\r\n        templateResponse.setFormat(template.getFormat());\r\n        if (template.getTemplateType() != null) {\r\n            templateResponse.setTemplateType(template.getTemplateType().toString());\r\n        }\r\n        \r\n        Account caller = UserContext.current().getCaller();\r\n        if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) {\r\n            templateResponse.setHypervisor(template.getHypervisorType().toString());\r\n        }\r\n        \r\n        templateResponse.setDetails(template.getDetails());\r\n\r\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\r\n        if (os != null) {\r\n            templateResponse.setOsTypeId(os.getId());\r\n            templateResponse.setOsTypeName(os.getDisplayName());\r\n        } else {\r\n            templateResponse.setOsTypeId(-1L);\r\n            templateResponse.setOsTypeName(\"\");\r\n        }\r\n\r\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\r\n        populateAccount(templateResponse, account.getId());\r\n        populateDomain(templateResponse, account.getDomainId());\r\n\r\n        DataCenterVO datacenter = ApiDBUtils.findZoneById(zoneId);\r\n\r\n        // Add the zone ID\r\n        templateResponse.setZoneId(zoneId);\r\n        templateResponse.setZoneName(datacenter.getName());\r\n\r\n        boolean isAdmin = false;\r\n        if ((caller == null) || BaseCmd.isAdmin(caller.getType())) {\r\n            isAdmin = true;\r\n        }\r\n\r\n        // If the user is an Admin, add the template download status\r\n        if (isAdmin || caller.getId() == template.getAccountId()) {\r\n            // add download status\r\n            if (templateHostRef.getDownloadState() != Status.DOWNLOADED) {\r\n                String templateStatus = \"Processing\";\r\n                if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\r\n                    if (templateHostRef.getDownloadPercent() == 100) {\r\n                        templateStatus = \"Installing Template\";\r\n                    } else {\r\n                        templateStatus = templateHostRef.getDownloadPercent() + \"% Downloaded\";\r\n                    }\r\n                } else {\r\n                    templateStatus = templateHostRef.getErrorString();\r\n                }\r\n                templateResponse.setStatus(templateStatus);\r\n            } else if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\r\n                templateResponse.setStatus(\"Download Complete\");\r\n            } else {\r\n                templateResponse.setStatus(\"Successfully Installed\");\r\n            }\r\n        }\r\n\r\n        Long templateSize = templateHostRef.getSize();\r\n        if (templateSize > 0) {\r\n            templateResponse.setSize(templateSize);\r\n        }\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n        templateResponse.setSourceTemplateId(template.getSourceTemplateId());\r\n\r\n        templateResponse.setChecksum(template.getChecksum());\r\n\r\n        templateResponse.setTemplateTag(template.getTemplateTag());\r\n\r\n        templateResponse.setObjectName(\"template\");\r\n        responses.add(templateResponse);\r\n        return responses;\r\n    }","commit_id":"1ce1f520f13bff19a8f6663a2dff091451e28702","url":"https://github.com/apache/cloudstack"},{"original_method":"public static long getSizeAsNumber(final Object iSize) {\r\n\t\tif (iSize == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Size is null\");\r\n\r\n\t\tif (iSize instanceof Number)\r\n\t\t\treturn ((Number) iSize).longValue();\r\n\r\n\t\tString size = iSize.toString();\r\n\r\n\t\tboolean number = true;\r\n\t\tfor (int i = size.length() - 1; i >= 0; --i) {\r\n\t\t\tif (!Character.isDigit(size.charAt(i))) {\r\n\t\t\t\tnumber = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (number)\r\n\t\t\treturn Long.parseLong(size);\r\n\t\telse {\r\n\t\t\tsize = size.toUpperCase(Locale.ENGLISH);\r\n\t\t\tint pos = size.indexOf(\"KB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn Long.parseLong(size.substring(0, pos)) * KILOBYTE;\r\n\r\n\t\t\tpos = size.indexOf(\"MB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn Long.parseLong(size.substring(0, pos)) * MEGABYTE;\r\n\r\n\t\t\tpos = size.indexOf(\"GB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn Long.parseLong(size.substring(0, pos)) * GIGABYTE;\r\n\r\n\t\t\tpos = size.indexOf(\"TB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn Long.parseLong(size.substring(0, pos)) * TERABYTE;\r\n\r\n\t\t\tpos = size.indexOf('B');\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn Long.parseLong(size.substring(0, pos));\r\n\r\n\t\t\tpos = size.indexOf('%');\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn -1 * Long.parseLong(size.substring(0, pos));\r\n\r\n\t\t\t// RE-THROW THE EXCEPTION\r\n\t\t\tthrow new IllegalArgumentException(\"Size \" + size + \" has a unrecognizable format\");\r\n\t\t}\r\n\t}","id":3270,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic static long getSizeAsNumber(final Object iSize) {\r\n\t\tif (iSize == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Size is null\");\r\n\r\n\t\tif (iSize instanceof Number)\r\n\t\t\treturn ((Number) iSize).longValue();\r\n\r\n\t\tString size = iSize.toString();\r\n\r\n\t\tboolean number = true;\r\n\t\tfor (int i = size.length() - 1; i >= 0; --i) {\r\n\t\t\tif (!Character.isDigit(size.charAt(i))) {\r\n\t\t\t\tnumber = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (number)\r\n\t\t\treturn string2number(size).longValue();\r\n\t\telse {\r\n\t\t\tsize = size.toUpperCase(Locale.ENGLISH);\r\n\t\t\tint pos = size.indexOf(\"KB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) (string2number(size.substring(0, pos)).floatValue() * KILOBYTE);\r\n\r\n\t\t\tpos = size.indexOf(\"MB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) (string2number(size.substring(0, pos)).floatValue() * MEGABYTE);\r\n\r\n\t\t\tpos = size.indexOf(\"GB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) (string2number(size.substring(0, pos)).floatValue() * GIGABYTE);\r\n\r\n\t\t\tpos = size.indexOf(\"TB\");\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) (string2number(size.substring(0, pos)).floatValue() * TERABYTE);\r\n\r\n\t\t\tpos = size.indexOf('B');\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) string2number(size.substring(0, pos)).floatValue();\r\n\r\n\t\t\tpos = size.indexOf('%');\r\n\t\t\tif (pos > -1)\r\n\t\t\t\treturn (long) (-1 * string2number(size.substring(0, pos)).floatValue());\r\n\r\n\t\t\t// RE-THROW THE EXCEPTION\r\n\t\t\tthrow new IllegalArgumentException(\"Size \" + size + \" has a unrecognizable format\");\r\n\t\t}\r\n\t}","commit_id":"f6a7c963cc8152a209f9ca778e1acde4f86c4846","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        \n        if (enableJaxbAnnotationModule) {\n            // Enables JAXB processing\n            JaxbAnnotationModule module = new JaxbAnnotationModule();\n            LOG.info(\"Registering module: {}\", module);\n            objectMapper.registerModule(module);\n        }\n\n        if (useList) {\n            setCollectionType(ArrayList.class);\n        }\n        if (include != null) {\n            JsonInclude.Include inc = getCamelContext().getTypeConverter().mandatoryConvertTo(JsonInclude.Include.class, include);\n            objectMapper.setSerializationInclusion(inc);\n        }\n        if (prettyPrint) {\n            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);\n        }\n\n        if (enableFeatures != null) {\n            for (String enable : enableFeatures) {\n                // it can be different kind\n                SerializationFeature sf = getCamelContext().getTypeConverter().tryConvertTo(SerializationFeature.class, enable);\n                if (sf != null) {\n                    objectMapper.enable(sf);\n                    continue;\n                }\n                DeserializationFeature df = getCamelContext().getTypeConverter().tryConvertTo(DeserializationFeature.class, enable);\n                if (df != null) {\n                    objectMapper.enable(df);\n                    continue;\n                }\n                MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, enable);\n                if (mf != null) {\n                    objectMapper.enable(mf);\n                    continue;\n                }\n                throw new IllegalArgumentException(\"Enable feature: \" + enable + \" cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]\");\n            }\n        }\n        if (disableFeatures != null) {\n            for (String disable : disableFeatures) {\n                // it can be different kind\n                SerializationFeature sf = getCamelContext().getTypeConverter().tryConvertTo(SerializationFeature.class, disable);\n                if (sf != null) {\n                    objectMapper.disable(sf);\n                    continue;\n                }\n                DeserializationFeature df = getCamelContext().getTypeConverter().tryConvertTo(DeserializationFeature.class, disable);\n                if (df != null) {\n                    objectMapper.disable(df);\n                    continue;\n                }\n                MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, disable);\n                if (mf != null) {\n                    objectMapper.disable(mf);\n                    continue;\n                }\n                throw new IllegalArgumentException(\"Disable feature: \" + disable + \" cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]\");\n            }\n        }\n\n        if (modules != null) {\n            for (Module module : modules) {\n                LOG.info(\"Registering module: {}\", module);\n                objectMapper.registerModules(module);\n            }\n        }\n        if (moduleClassNames != null) {\n            Iterable<Object> it = ObjectHelper.createIterable(moduleClassNames);\n            for (Object o : it) {\n                String name = o.toString();\n                Class<Module> clazz = camelContext.getClassResolver().resolveMandatoryClass(name, Module.class);\n                Module module = camelContext.getInjector().newInstance(clazz);\n                LOG.info(\"Registering module: {} -> {}\", name, module);\n                objectMapper.registerModule(module);\n            }\n        }\n        if (moduleRefs != null) {\n            Iterable<Object> it = ObjectHelper.createIterable(moduleRefs);\n            for (Object o : it) {\n                String name = o.toString();\n                if (name.startsWith(\"#\")) {\n                    name = name.substring(1);\n                }\n                Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);\n                LOG.info(\"Registering module: {} -> {}\", name, module);\n                objectMapper.registerModule(module);\n            }\n        }\n    }","id":3271,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        \n        if (enableJaxbAnnotationModule) {\n            // Enables JAXB processing\n            JaxbAnnotationModule module = new JaxbAnnotationModule();\n            LOG.info(\"Registering module: {}\", module);\n            objectMapper.registerModule(module);\n        }\n\n        if (useList) {\n            setCollectionType(ArrayList.class);\n        }\n        if (include != null) {\n            JsonInclude.Include inc = getCamelContext().getTypeConverter().mandatoryConvertTo(JsonInclude.Include.class, include);\n            objectMapper.setSerializationInclusion(inc);\n        }\n        if (prettyPrint) {\n            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);\n        }\n\n        if (enableFeatures != null) {\n            Iterator<Object> it = ObjectHelper.createIterator(enableFeatures);\n            while (it.hasNext()) {\n                String enable = it.next().toString();\n                // it can be different kind\n                SerializationFeature sf = getCamelContext().getTypeConverter().tryConvertTo(SerializationFeature.class, enable);\n                if (sf != null) {\n                    objectMapper.enable(sf);\n                    continue;\n                }\n                DeserializationFeature df = getCamelContext().getTypeConverter().tryConvertTo(DeserializationFeature.class, enable);\n                if (df != null) {\n                    objectMapper.enable(df);\n                    continue;\n                }\n                MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, enable);\n                if (mf != null) {\n                    objectMapper.enable(mf);\n                    continue;\n                }\n                throw new IllegalArgumentException(\"Enable feature: \" + enable + \" cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]\");\n            }\n        }\n        if (disableFeatures != null) {\n            Iterator<Object> it = ObjectHelper.createIterator(enableFeatures);\n            while (it.hasNext()) {\n                String disable = it.next().toString();\n                // it can be different kind\n                SerializationFeature sf = getCamelContext().getTypeConverter().tryConvertTo(SerializationFeature.class, disable);\n                if (sf != null) {\n                    objectMapper.disable(sf);\n                    continue;\n                }\n                DeserializationFeature df = getCamelContext().getTypeConverter().tryConvertTo(DeserializationFeature.class, disable);\n                if (df != null) {\n                    objectMapper.disable(df);\n                    continue;\n                }\n                MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, disable);\n                if (mf != null) {\n                    objectMapper.disable(mf);\n                    continue;\n                }\n                throw new IllegalArgumentException(\"Disable feature: \" + disable + \" cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]\");\n            }\n        }\n\n        if (modules != null) {\n            for (Module module : modules) {\n                LOG.info(\"Registering module: {}\", module);\n                objectMapper.registerModules(module);\n            }\n        }\n        if (moduleClassNames != null) {\n            Iterable<Object> it = ObjectHelper.createIterable(moduleClassNames);\n            for (Object o : it) {\n                String name = o.toString();\n                Class<Module> clazz = camelContext.getClassResolver().resolveMandatoryClass(name, Module.class);\n                Module module = camelContext.getInjector().newInstance(clazz);\n                LOG.info(\"Registering module: {} -> {}\", name, module);\n                objectMapper.registerModule(module);\n            }\n        }\n        if (moduleRefs != null) {\n            Iterable<Object> it = ObjectHelper.createIterable(moduleRefs);\n            for (Object o : it) {\n                String name = o.toString();\n                if (name.startsWith(\"#\")) {\n                    name = name.substring(1);\n                }\n                Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);\n                LOG.info(\"Registering module: {} -> {}\", name, module);\n                objectMapper.registerModule(module);\n            }\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void disableFeature(DeserializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":3272,"modified_method":"public void disableFeature(DeserializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void disableFeature(SerializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":3273,"modified_method":"public void disableFeature(SerializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void disableFeature(MapperFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":3274,"modified_method":"public void disableFeature(MapperFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(SerializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":3275,"modified_method":"public void enableFeature(SerializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Set of features to disable on the Jackson {@link ObjectMapper}.\n     * The features should be a name that matches a enum from {@link SerializationFeature}, {@link DeserializationFeature}, or {@link MapperFeature}.\n     */\n    public void setDisableFeatures(Set<String> disableFeatures) {\n        this.disableFeatures = disableFeatures;\n    }","id":3276,"modified_method":"/**\n     * Set of features to disable on the Jackson {@link ObjectMapper}.\n     * The features should be a name that matches a enum from {@link SerializationFeature}, {@link DeserializationFeature}, or {@link MapperFeature}.\n     */\n    public void setDisableFeatures(String disableFeatures) {\n        this.disableFeatures = disableFeatures;\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Set of features to enable on the Jackson {@link ObjectMapper}.\n     * The features should be a name that matches a enum from {@link SerializationFeature}, {@link DeserializationFeature}, or {@link MapperFeature}.\n     */\n    public void setEnableFeatures(Set<String> enableFeatures) {\n        this.enableFeatures = enableFeatures;\n    }","id":3277,"modified_method":"/**\n     * Set of features to enable on the Jackson {@link ObjectMapper}.\n     * The features should be a name that matches a enum from {@link SerializationFeature}, {@link DeserializationFeature}, or {@link MapperFeature}.\n     */\n    public void setEnableFeatures(String enableFeatures) {\n        this.enableFeatures = enableFeatures;\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(MapperFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":3278,"modified_method":"public void enableFeature(MapperFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(DeserializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":3279,"modified_method":"public void enableFeature(DeserializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Set of features to enable on the Jackson <tt>com.fasterxml.jackson.databind.ObjectMapper<\/tt>.\n     * <p/>\n     * The features should be a name that matches a enum from <tt>com.fasterxml.jackson.databind.SerializationFeature<\/tt>,\n     * <tt>com.fasterxml.jackson.databind.DeserializationFeature<\/tt>, or <tt>com.fasterxml.jackson.databind.MapperFeature<\/tt>\n     */\n    public void setEnableFeatures(Set<String> enableFeatures) {\n        this.enableFeatures = enableFeatures;\n    }","id":3280,"modified_method":"/**\n     * Set of features to enable on the Jackson <tt>com.fasterxml.jackson.databind.ObjectMapper<\/tt>.\n     * <p/>\n     * The features should be a name that matches a enum from <tt>com.fasterxml.jackson.databind.SerializationFeature<\/tt>,\n     * <tt>com.fasterxml.jackson.databind.DeserializationFeature<\/tt>, or <tt>com.fasterxml.jackson.databind.MapperFeature<\/tt>\n     * <p/>\n     * Multiple features can be separated by comma\n     */\n    public void setEnableFeatures(String enableFeatures) {\n        this.enableFeatures = enableFeatures;\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Set of features to disable on the Jackson <tt>com.fasterxml.jackson.databind.ObjectMapper<\/tt>.\n     * <p/>\n     * The features should be a name that matches a enum from <tt>com.fasterxml.jackson.databind.SerializationFeature<\/tt>,\n     * <tt>com.fasterxml.jackson.databind.DeserializationFeature<\/tt>, or <tt>com.fasterxml.jackson.databind.MapperFeature<\/tt>\n     */\n    public void setDisableFeatures(Set<String> disableFeatures) {\n        this.disableFeatures = disableFeatures;\n    }","id":3281,"modified_method":"/**\n     * Set of features to disable on the Jackson <tt>com.fasterxml.jackson.databind.ObjectMapper<\/tt>.\n     * <p/>\n     * The features should be a name that matches a enum from <tt>com.fasterxml.jackson.databind.SerializationFeature<\/tt>,\n     * <tt>com.fasterxml.jackson.databind.DeserializationFeature<\/tt>, or <tt>com.fasterxml.jackson.databind.MapperFeature<\/tt>\n     * <p/>\n     * Multiple features can be separated by comma\n     */\n    public void setDisableFeatures(String disableFeatures) {\n        this.disableFeatures = disableFeatures;\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     *  Copies the file from temp dir to the news location,\n     *  calls checkForUpdates()\n     */\n    @Override\n    public void transferComplete(long alreadyTransferred, long bytesTransferred, long bytesRemaining, String url, String outputFile, boolean notModified) {\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"News fetched from \" + url + \" with \" + (alreadyTransferred+bytesTransferred));\n        \n        if (_tempFile.exists() && _tempFile.length() > 0) {\n            File from;\n            // TODO check magic number instead?\n            // But then a corrupt file would be displayed as-is...\n            if (url.endsWith(\".su3\") || url.contains(\".su3?\")) {\n                try {\n                    from = processSU3();\n                } catch (IOException ioe) {\n                    _log.error(\"Failed to extract the news file\", ioe);\n                    _tempFile.delete();\n                    return;\n                }\n            } else {\n                from = _tempFile;\n            }\n            boolean copied = FileUtil.rename(from, _newsFile);\n            _tempFile.delete();\n            if (copied) {\n                // this is either the start time or the Last-Modified header\n                String newVer = Long.toString(_newLastModified);\n                // fixme su3 version ? but it will be older than file version, which is older than now.\n                _mgr.notifyVersionAvailable(this, _currentURI, NEWS, \"\", HTTP,\n                                            null, newVer, \"\");\n                _isNewer = true;\n                checkForUpdates();\n            } else {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"Failed to copy the news file!\");\n            }\n        } else {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Transfer complete, but no file? - probably 304 Not Modified\");\n        }\n        _success = true;\n    }","id":3282,"modified_method":"/**\n     *  Copies the file from temp dir to the news location,\n     *  calls checkForUpdates()\n     */\n    @Override\n    public void transferComplete(long alreadyTransferred, long bytesTransferred, long bytesRemaining, String url, String outputFile, boolean notModified) {\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"News fetched from \" + url + \" with \" + (alreadyTransferred+bytesTransferred));\n        \n        if (_tempFile.exists() && _tempFile.length() > 0) {\n            File from;\n            // sud/su2 disabled\n            //if (url.endsWith(\".su3\") || url.contains(\".su3?\")) {\n                try {\n                    from = processSU3();\n                } catch (IOException ioe) {\n                    _log.error(\"Failed to extract the news file\", ioe);\n                    _tempFile.delete();\n                    return;\n                }\n            //} else {\n            //    from = _tempFile;\n            //}\n            boolean copied = FileUtil.rename(from, _newsFile);\n            _tempFile.delete();\n            if (copied) {\n                // this is either the start time or the Last-Modified header\n                String newVer = Long.toString(_newLastModified);\n                // fixme su3 version ? but it will be older than file version, which is older than now.\n                _mgr.notifyVersionAvailable(this, _currentURI, NEWS, \"\", HTTP,\n                                            null, newVer, \"\");\n                _isNewer = true;\n                checkForUpdates();\n            } else {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"Failed to copy the news file!\");\n            }\n        } else {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Transfer complete, but no file? - probably 304 Not Modified\");\n        }\n        _success = true;\n    }","commit_id":"b59a8027bb865b2405dafb25f5cd576b318c8aad","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Parse the installed (not the temp) news file for the latest version.\n     *  TODO: Real XML parsing\n     *  TODO: Check minVersion, use backup URLs specified\n     *  TODO: SU3\n     */\n    void checkForUpdates() {\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(_newsFile);\n            StringBuilder buf = new StringBuilder(128);\n            while (DataHelper.readLine(in, buf)) {\n                int index = buf.indexOf(VERSION_PREFIX);\n                if (index >= 0) {\n                    Map<String, String> args = parseArgs(buf.substring(index+VERSION_PREFIX.length()));\n                    String ver = args.get(VERSION_KEY);\n                    if (ver != null) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(\"Found version: [\" + ver + \"]\");\n                        if (TrustedUpdate.needsUpdate(RouterVersion.VERSION, ver)) {\n                            if (NewsHelper.isUpdateDisabled(_context)) {\n                                String msg = _mgr._t(\"In-network updates disabled. Check package manager.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            if (NewsHelper.isBaseReadonly(_context)) {\n                                String msg = _mgr._t(\"No write permission for I2P install directory.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            String minRouter = args.get(MIN_VERSION_KEY);\n                            if (minRouter != null) {\n                                if (VersionComparator.comp(RouterVersion.VERSION, minRouter) < 0) {\n                                    String msg = _mgr._t(\"You must first update to version {0}\", minRouter);\n                                    _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                    _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                    return;\n                                }\n                            }\n                            String minJava = args.get(MIN_JAVA_VERSION_KEY);\n                            if (minJava != null) {\n                                String ourJava = System.getProperty(\"java.version\");\n                                if (VersionComparator.comp(ourJava, minJava) < 0) {\n                                    String msg = _mgr._t(\"Requires Java version {0} but installed Java version is {1}\", minJava, ourJava);\n                                    _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                    _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                    return;\n                                }\n                            }\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Our version is out of date, update!\");\n                            // TODO if minversion > our version, continue\n                            // and look for a second entry with clearnet URLs\n                            // TODO clearnet URLs, notify with HTTP_CLEARNET and/or HTTPS_CLEARNET\n                            Map<UpdateMethod, List<URI>> sourceMap = new HashMap<UpdateMethod, List<URI>>(4);\n                            // Must do su3 first\n                            if (ConfigUpdateHandler.USE_SU3_UPDATE) {\n                                sourceMap.put(HTTP, _mgr.getUpdateURLs(ROUTER_SIGNED_SU3, \"\", HTTP));\n                                addMethod(TORRENT, args.get(SU3_KEY), sourceMap);\n                                addMethod(HTTP_CLEARNET, args.get(CLEARNET_HTTP_SU3_KEY), sourceMap);\n                                addMethod(HTTPS_CLEARNET, args.get(CLEARNET_HTTPS_SU3_KEY), sourceMap);\n                                // notify about all sources at once\n                                _mgr.notifyVersionAvailable(this, _currentURI, ROUTER_SIGNED_SU3,\n                                                            \"\", sourceMap, ver, \"\");\n                                sourceMap.clear();\n                            }\n                            // now do sud/su2\n                            sourceMap.put(HTTP, _mgr.getUpdateURLs(ROUTER_SIGNED, \"\", HTTP));\n                            String key = FileUtil.isPack200Supported() ? SU2_KEY : SUD_KEY;\n                            addMethod(TORRENT, args.get(key), sourceMap);\n                            // notify about all sources at once\n                            _mgr.notifyVersionAvailable(this, _currentURI, ROUTER_SIGNED,\n                                                        \"\", sourceMap, ver, \"\");\n                        } else {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Our version is current\");\n                        }\n                        return;\n                    } else {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"No version in \" + buf.toString());\n                    }\n                } else {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"No match in \" + buf.toString());\n                }\n                buf.setLength(0);\n            }\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Error checking the news for an update\", ioe);\n            return;\n        } finally {\n            if (in != null) try { in.close(); } catch (IOException ioe) {}\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No version found in news.xml file\");\n    }","id":3283,"modified_method":"/**\n     *  Parse the installed (not the temp) news file for the latest version.\n     *  TODO: Real XML parsing\n     *  TODO: Check minVersion, use backup URLs specified\n     *  TODO: SU3\n     */\n    void checkForUpdates() {\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(_newsFile);\n            StringBuilder buf = new StringBuilder(128);\n            while (DataHelper.readLine(in, buf)) {\n                int index = buf.indexOf(VERSION_PREFIX);\n                if (index >= 0) {\n                    Map<String, String> args = parseArgs(buf.substring(index+VERSION_PREFIX.length()));\n                    String ver = args.get(VERSION_KEY);\n                    if (ver != null) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(\"Found version: [\" + ver + \"]\");\n                        if (TrustedUpdate.needsUpdate(RouterVersion.VERSION, ver)) {\n                            if (NewsHelper.isUpdateDisabled(_context)) {\n                                String msg = _mgr._t(\"In-network updates disabled. Check package manager.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            if (NewsHelper.isBaseReadonly(_context)) {\n                                String msg = _mgr._t(\"No write permission for I2P install directory.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            if (!FileUtil.isPack200Supported()) {\n                                String msg = _mgr._t(\"No Pack200 support in Java runtime.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            if (!ConfigUpdateHandler.USE_SU3_UPDATE) {\n                                String msg = _mgr._t(\"No update certificates installed.\");\n                                _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                return;\n                            }\n                            String minRouter = args.get(MIN_VERSION_KEY);\n                            if (minRouter != null) {\n                                if (VersionComparator.comp(RouterVersion.VERSION, minRouter) < 0) {\n                                    String msg = _mgr._t(\"You must first update to version {0}\", minRouter);\n                                    _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                    _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                    return;\n                                }\n                            }\n                            String minJava = args.get(MIN_JAVA_VERSION_KEY);\n                            if (minJava != null) {\n                                String ourJava = System.getProperty(\"java.version\");\n                                if (VersionComparator.comp(ourJava, minJava) < 0) {\n                                    String msg = _mgr._t(\"Requires Java version {0} but installed Java version is {1}\", minJava, ourJava);\n                                    _log.logAlways(Log.WARN, \"Cannot update to version \" + ver + \": \" + msg);\n                                    _mgr.notifyVersionConstraint(this, _currentURI, ROUTER_SIGNED, \"\", ver, msg);\n                                    return;\n                                }\n                            }\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Our version is out of date, update!\");\n                            // TODO if minversion > our version, continue\n                            // and look for a second entry with clearnet URLs\n                            // TODO clearnet URLs, notify with HTTP_CLEARNET and/or HTTPS_CLEARNET\n                            Map<UpdateMethod, List<URI>> sourceMap = new HashMap<UpdateMethod, List<URI>>(4);\n                            // Must do su3 first\n                            //if (ConfigUpdateHandler.USE_SU3_UPDATE) {\n                                sourceMap.put(HTTP, _mgr.getUpdateURLs(ROUTER_SIGNED_SU3, \"\", HTTP));\n                                addMethod(TORRENT, args.get(SU3_KEY), sourceMap);\n                                addMethod(HTTP_CLEARNET, args.get(CLEARNET_HTTP_SU3_KEY), sourceMap);\n                                addMethod(HTTPS_CLEARNET, args.get(CLEARNET_HTTPS_SU3_KEY), sourceMap);\n                                // notify about all sources at once\n                                _mgr.notifyVersionAvailable(this, _currentURI, ROUTER_SIGNED_SU3,\n                                                            \"\", sourceMap, ver, \"\");\n                                sourceMap.clear();\n                            //}\n                            // now do sud/su2 - DISABLED\n                            //sourceMap.put(HTTP, _mgr.getUpdateURLs(ROUTER_SIGNED, \"\", HTTP));\n                            //String key = FileUtil.isPack200Supported() ? SU2_KEY : SUD_KEY;\n                            //addMethod(TORRENT, args.get(key), sourceMap);\n                            // notify about all sources at once\n                            //_mgr.notifyVersionAvailable(this, _currentURI, ROUTER_SIGNED,\n                            //                            \"\", sourceMap, ver, \"\");\n                        } else {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Our version is current\");\n                        }\n                        return;\n                    } else {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"No version in \" + buf.toString());\n                    }\n                } else {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"No match in \" + buf.toString());\n                }\n                buf.setLength(0);\n            }\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Error checking the news for an update\", ioe);\n            return;\n        } finally {\n            if (in != null) try { in.close(); } catch (IOException ioe) {}\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No version found in news.xml file\");\n    }","commit_id":"b59a8027bb865b2405dafb25f5cd576b318c8aad","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void checkUpdateAction() { \n        if (_nonce == null || _action == null) return;\n        if (_nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\")) ||\n            _nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\"))) {\n            if (_action.contains(\"Unsigned\")) {\n                update(ROUTER_UNSIGNED);\n            } else if (_action.contains(\"DevSU3\")) {\n                update(ROUTER_DEV_SU3);\n            } else if (ConfigUpdateHandler.USE_SU3_UPDATE) {\n                update(ROUTER_SIGNED_SU3);\n            } else {\n                update(ROUTER_SIGNED);\n            }\n        }\n    }","id":3284,"modified_method":"private void checkUpdateAction() { \n        if (_nonce == null || _action == null) return;\n        if (_nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\")) ||\n            _nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\"))) {\n            if (_action.contains(\"Unsigned\")) {\n                update(ROUTER_UNSIGNED);\n            } else if (_action.contains(\"DevSU3\")) {\n                update(ROUTER_DEV_SU3);\n            } else if (ConfigUpdateHandler.USE_SU3_UPDATE) {\n                update(ROUTER_SIGNED_SU3);\n            } else {\n                // disabled, shouldn't get here\n                //update(ROUTER_SIGNED);\n            }\n        }\n    }","commit_id":"b59a8027bb865b2405dafb25f5cd576b318c8aad","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public String getEncryptionKey() {\n        String value = EncryptionKey.value();\n        if (value == null) {\n            _configDepot.set(EncryptionKey, getBase64EncodedRandomKey(128));\n        }\n        return EncryptionKey.value();\n    }","id":3285,"modified_method":"@Override\n    public String getEncryptionKey() {\n        String value = EncryptionKey.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(EncryptionKey.key(), EncryptionKey.category(), getBase64EncodedRandomKey(128),\n                    EncryptionKey.description());\n        }\n        return EncryptionKey.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getHashKey() {\n        String value = HashKey.value();\n        if (value == null) {\n            _configDepot.set(HashKey, getBase64EncodedRandomKey(128));\n        }\n\n        return HashKey.value();\n    }","id":3286,"modified_method":"@Override\n    public String getHashKey() {\n        String value = HashKey.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(HashKey.key(), HashKey.category(), getBase64EncodedRandomKey(128), HashKey.description());\n        }\n\n        return HashKey.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getEncryptionIV() {\n        String value = EncryptionIV.value();\n        if (value == null) {\n            _configDepot.set(EncryptionIV, getBase64EncodedRandomKey(128));\n        }\n        return EncryptionIV.value();\n    }","id":3287,"modified_method":"@Override\n    public String getEncryptionIV() {\n        String value = EncryptionIV.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(EncryptionIV.key(), EncryptionIV.category(), getBase64EncodedRandomKey(128),\n                    EncryptionIV.description());\n        }\n        return EncryptionIV.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtAnnotationEntry> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3288,"modified_method":"@NotNull\n    @Override\n    public Collection<KtAnnotationEntry> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtAnnotationEntry.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3289,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtFile> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3290,"modified_method":"@NotNull\n    @Override\n    public Collection<KtFile> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtFile.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3291,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3292,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3293,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3294,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3295,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3296,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3297,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3298,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3299,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3300,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":3301,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n\t * Decodes a UTF-8 string element's content from an InputStream.\n\t * Expects to read a XML_UDATA type marker, and then the data. Has to peek\n\t * to cope with 0-length ustring. Inline the peek to avoid unneeded resets.\n\t * This will not decode a TAG or ATTR ustring.\n\t * @param istream stream to read from\n\t * @return returns decoded String\n\t * @throws IOException if stream cannot be read, decoded or reset\n\t */\n\tpublic static String decodeUString(InputStream istream) throws IOException {\n\t\tistream.mark(LONG_BYTES*2);\n\t\t\n\t\tTypeAndVal tv = decodeTypeAndVal(istream);\n\t\tif ((null == tv) || (XML_UDATA != tv.type())) { // if we just have closers left, will get back null\n\t\t\tLog.finest(\"Expected UDATA, got \" + ((null == tv) ? \" not a tag \" : tv.type()) + \", assuming elided 0-length blob.\");\n\t\t\tistream.reset();\n\t\t\treturn new String(\"\");\n\t\t}\n\t\treturn decodeUString(istream, (int)tv.val());\n\t}","id":3302,"modified_method":"/**\n\t * Decodes a UTF-8 string element's content from an InputStream.\n\t * Expects to read a XML_UDATA type marker, and then the data. Has to peek\n\t * to cope with 0-length ustring. Inline the peek to avoid unneeded resets.\n\t * This will not decode a TAG or ATTR ustring.\n\t * @param istream stream to read from\n\t * @return returns decoded String\n\t * @throws IOException if stream cannot be read, decoded or reset\n\t */\n\tpublic static String decodeUString(InputStream istream) throws IOException {\n\t\tistream.mark(LONG_BYTES*2);\n\t\t\n\t\tTypeAndVal tv = decodeTypeAndVal(istream);\n\t\tif ((null == tv) || (XML_UDATA != tv.type())) { // if we just have closers left, will get back null\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\t\tLog.finest(Log.FAC_ENCODING, \"Expected UDATA, got \" + ((null == tv) ? \" not a tag \" : tv.type()) + \", assuming elided 0-length blob.\");\n\t\t\tistream.reset();\n\t\t\treturn new String(\"\");\n\t\t}\n\t\treturn decodeUString(istream, (int)tv.val());\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Encode a type identifier (from the set listed above) and an integer value\n\t * together in a composite encoding.\n\t * Value is encoded in the first several bytes; with the tag encoded in the\n\t * last three bits. The encoding of value is variable length in the bottom\n\t * 7 bits of every byte except for the last one, where it is in the next to top\n\t * 4 bits; the high order bit is set on every byte where there are more bytes\n\t * to follow.\n\t *\n\t * @param type the type value to encode\n\t * @param val Positive integer, potentially of any length, allow only longs\n\t * \t   here.\n\t * @param buf the buffer to encode into\n\t * @param offset the offset into buf at which to start encoding\n\t * @return the number of bytes used to encode.\n\t */\n\tpublic static int encodeTypeAndVal(int type, long val, byte [] buf, int offset) {\n\t\t\n\t\tif ((type > XML_UDATA) || (type < 0) || (val < 0)) {\n\t\t\tthrow new IllegalArgumentException(\"Tag and value must be positive, and tag valid.\");\n\t\t}\n\t\t\n\t\t// Encode backwards. Calculate how many bytes we need:\n\t\tint numEncodingBytes = numEncodingBytes(val);\n\t\t\n\t\tif ((offset + numEncodingBytes) > buf.length) {\n\t\t\tthrow new IllegalArgumentException(\"Buffer space of \" + (buf.length-offset) + \n\t\t\t\t\t\t\t\t\t\t\t\t\" bytes insufficient to hold \" + \n\t\t\t\t\t\t\t\t\t\t\t\tnumEncodingBytes + \" of encoded type and value.\");\n\t\t}\n\t\t\n\t\t// Bottom 4 bits of val go in last byte with tag.\n\t\tbuf[offset + numEncodingBytes - 1] = \n\t\t\t(byte)(BYTE_MASK &\n\t\t\t\t\t\t(((XML_TT_MASK & type) | \n\t\t\t\t\t\t ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n\t\t\t\t\t\t XML_TT_NO_MORE); // set top bit for last byte\n\t\tval = val >>> XML_TT_VAL_BITS;;\n\t\t\n\t\t// Rest of val goes into preceding bytes, 7 bits per byte, top bit\n\t\t// is \"more\" flag.\n\t\tint i = offset + numEncodingBytes - 2;\n\t\twhile ((0 != val) && (i >= offset)) {\n\t\t\tbuf[i] = (byte)(BYTE_MASK &\n\t\t\t\t\t\t\t    (val & XML_REG_VAL_MASK)); // leave top bit unset\n\t\t\tval = val >>> XML_REG_VAL_BITS;\n\t\t\t--i;\n\t\t}\n\t\tif (val != 0) {\n\t\t\tLog.info(\"This should not happen: miscalculated encoding length, have \" + val + \" left.\");\n\t\t}\n\t\t\n\t\treturn numEncodingBytes;\n\t}","id":3303,"modified_method":"/**\n\t * Encode a type identifier (from the set listed above) and an integer value\n\t * together in a composite encoding.\n\t * Value is encoded in the first several bytes; with the tag encoded in the\n\t * last three bits. The encoding of value is variable length in the bottom\n\t * 7 bits of every byte except for the last one, where it is in the next to top\n\t * 4 bits; the high order bit is set on every byte where there are more bytes\n\t * to follow.\n\t *\n\t * @param type the type value to encode\n\t * @param val Positive integer, potentially of any length, allow only longs\n\t * \t   here.\n\t * @param buf the buffer to encode into\n\t * @param offset the offset into buf at which to start encoding\n\t * @return the number of bytes used to encode.\n\t */\n\tpublic static int encodeTypeAndVal(int type, long val, byte [] buf, int offset) {\n\t\t\n\t\tif ((type > XML_UDATA) || (type < 0) || (val < 0)) {\n\t\t\tthrow new IllegalArgumentException(\"Tag and value must be positive, and tag valid.\");\n\t\t}\n\t\t\n\t\t// Encode backwards. Calculate how many bytes we need:\n\t\tint numEncodingBytes = numEncodingBytes(val);\n\t\t\n\t\tif ((offset + numEncodingBytes) > buf.length) {\n\t\t\tthrow new IllegalArgumentException(\"Buffer space of \" + (buf.length-offset) + \n\t\t\t\t\t\t\t\t\t\t\t\t\" bytes insufficient to hold \" + \n\t\t\t\t\t\t\t\t\t\t\t\tnumEncodingBytes + \" of encoded type and value.\");\n\t\t}\n\t\t\n\t\t// Bottom 4 bits of val go in last byte with tag.\n\t\tbuf[offset + numEncodingBytes - 1] = \n\t\t\t(byte)(BYTE_MASK &\n\t\t\t\t\t\t(((XML_TT_MASK & type) | \n\t\t\t\t\t\t ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n\t\t\t\t\t\t XML_TT_NO_MORE); // set top bit for last byte\n\t\tval = val >>> XML_TT_VAL_BITS;;\n\t\t\n\t\t// Rest of val goes into preceding bytes, 7 bits per byte, top bit\n\t\t// is \"more\" flag.\n\t\tint i = offset + numEncodingBytes - 2;\n\t\twhile ((0 != val) && (i >= offset)) {\n\t\t\tbuf[i] = (byte)(BYTE_MASK &\n\t\t\t\t\t\t\t    (val & XML_REG_VAL_MASK)); // leave top bit unset\n\t\t\tval = val >>> XML_REG_VAL_BITS;\n\t\t\t--i;\n\t\t}\n\t\tif (val != 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_ENCODING, \"This should not happen: miscalculated encoding length, have \" + val + \" left.\");\n\t\t}\n\t\t\n\t\treturn numEncodingBytes;\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Encodes a binary BLOB (binary content) to an output stream.\n\t * @param ostream the stream to write to\n\t * @param blob the binary content to write\n\t * @param offset the offset into blob at which to start encoding data\n\t * @param length the number of bytes of blob to encode\n\t * @throws IOException if there is an error encoding or writing the data\n\t */\n\tpublic static void encodeBlob(OutputStream ostream, byte [] blob, int offset, int length) throws IOException {\n\t\t// We elide the encoding of a 0-length blob\n\t\tif ((null == blob) || (length == 0)) {\n\t\t\tLog.finer(\"Eliding 0-length blob.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tencodeTypeAndVal(XML_BLOB, length, ostream);\n\t\tif (null != blob) {\n\t\t\tostream.write(blob, offset, length);\n\t\t}\n\t}","id":3304,"modified_method":"/**\n\t * Encodes a binary BLOB (binary content) to an output stream.\n\t * @param ostream the stream to write to\n\t * @param blob the binary content to write\n\t * @param offset the offset into blob at which to start encoding data\n\t * @param length the number of bytes of blob to encode\n\t * @throws IOException if there is an error encoding or writing the data\n\t */\n\tpublic static void encodeBlob(OutputStream ostream, byte [] blob, int offset, int length) throws IOException {\n\t\t// We elide the encoding of a 0-length blob\n\t\tif ((null == blob) || (length == 0)) {\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINER))\n\t\t\t\tLog.finer(Log.FAC_ENCODING, \"Eliding 0-length blob.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tencodeTypeAndVal(XML_BLOB, length, ostream);\n\t\tif (null != blob) {\n\t\t\tostream.write(blob, offset, length);\n\t\t}\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Decodes a binary blob (encoded binary content) from an InputStream.\n\t * Expects to read a XML_BLOB type marker, and then the data. Has to peek\n\t * to cope with 0-length blob. Inline the peek to avoid unneeded resets.\n\t * @param istream stream to read from\n\t * @return returns decoded blob (binary content)\n\t * @throws IOException if stream cannot be read, decoded or reset\n\t */\n\tpublic static byte [] decodeBlob(InputStream istream) throws IOException {\n\t\tistream.mark(LONG_BYTES*2);\n\t\t\n\t\tTypeAndVal tv = decodeTypeAndVal(istream);\n\t\tif ((null == tv) || (XML_BLOB != tv.type())) { // if we just have closers left, will get back null\n\t\t\tLog.finest(\"Expected BLOB, got \" + ((null == tv) ? \" not a tag \" : tv.type()) + \", assuming elided 0-length blob.\");\n\t\t\tistream.reset();\n\t\t\treturn new byte[0];\n\t\t}\n\t\treturn decodeBlob(istream, (int)tv.val());\n\t}","id":3305,"modified_method":"/**\n\t * Decodes a binary blob (encoded binary content) from an InputStream.\n\t * Expects to read a XML_BLOB type marker, and then the data. Has to peek\n\t * to cope with 0-length blob. Inline the peek to avoid unneeded resets.\n\t * @param istream stream to read from\n\t * @return returns decoded blob (binary content)\n\t * @throws IOException if stream cannot be read, decoded or reset\n\t */\n\tpublic static byte [] decodeBlob(InputStream istream) throws IOException {\n\t\tistream.mark(LONG_BYTES*2);\n\t\t\n\t\tTypeAndVal tv = decodeTypeAndVal(istream);\n\t\tif ((null == tv) || (XML_BLOB != tv.type())) { // if we just have closers left, will get back null\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\t\tLog.finest(Log.FAC_ENCODING, \"Expected BLOB, got \" + ((null == tv) ? \" not a tag \" : tv.type()) + \", assuming elided 0-length blob.\");\n\t\t\tistream.reset();\n\t\t\treturn new byte[0];\n\t\t}\n\t\treturn decodeBlob(istream, (int)tv.val());\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void readStartElement(long startTag,\n\t\t\tTreeMap<String, String> attributes) throws ContentDecodingException {\n\t\ttry {\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null == tv) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got something not a tag.\");\n\t\t\t}\n\n\t\t\tLong decodedTag = null;\n\n\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\tLog.info(\"Unexpected: got tag in readStartElement; looking for tag \" + startTag + \" got length: \" + (int)tv.val()+1);\n\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\tString strTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\n\t\t\t\tdecodedTag = stringToTag(strTag);\n\n\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\tdecodedTag = tv.val();\n\t\t\t}\n\n\t\t\tif ((null ==  decodedTag) || (decodedTag.longValue() != startTag)) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got: \" + decodedTag + \"(\" + tv.val() + \")\");\n\t\t\t}\n\n\t\t\t// DKS: does not read attributes out of stream if caller doesn't\n\t\t\t// ask for them. Should possibly peek and skip over them regardless.\n\t\t\t// TODO: fix this\n\t\t\tif (null != attributes) {\n\t\t\t\treadAttributes(attributes); \n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","id":3306,"modified_method":"public void readStartElement(long startTag,\n\t\t\tTreeMap<String, String> attributes) throws ContentDecodingException {\n\t\ttry {\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null == tv) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got something not a tag.\");\n\t\t\t}\n\n\t\t\tLong decodedTag = null;\n\n\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"Unexpected: got tag in readStartElement; looking for tag \" + startTag + \" got length: \" + (int)tv.val()+1);\n\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\tString strTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\n\t\t\t\tdecodedTag = stringToTag(strTag);\n\n\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\tdecodedTag = tv.val();\n\t\t\t}\n\n\t\t\tif ((null ==  decodedTag) || (decodedTag.longValue() != startTag)) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got: \" + decodedTag + \"(\" + tv.val() + \")\");\n\t\t\t}\n\n\t\t\t// DKS: does not read attributes out of stream if caller doesn't\n\t\t\t// ask for them. Should possibly peek and skip over them regardless.\n\t\t\t// TODO: fix this\n\t\t\tif (null != attributes) {\n\t\t\t\treadAttributes(attributes); \n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Long peekStartElementAsLong() throws ContentDecodingException {\n\t\t_istream.mark(MARK_LEN);\n\n\t\tLong decodedTag = null;\n\t\ttry {\n\t\t\t// Have to distinguish genuine errors from wrong tags. Could either use\n\t\t\t// a special exception subtype, or redo the work here.\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null != tv) {\n\n\t\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\t\tif (tv.val()+1 > DEBUG_MAX_LEN) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Decoding error: length \" + tv.val()+1 + \" longer than expected maximum length!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\t\tString strTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\t\n\t\t\t\t\tdecodedTag = stringToTag(strTag);\n\t\t\t\t\t\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\t\tLog.info(\"Unexpected: got text tag in peekStartElement; length: \" + (int)tv.val()+1 + \" decoded tag = \" + decodedTag);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\t\tdecodedTag = tv.val();\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} // else, not a type and val, probably an end element. rewind and return false.\n\n\t\t} catch (ContentDecodingException e) {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t\t_istream.mark(MARK_LEN);\n\t\t\t\tlong ms = System.currentTimeMillis();\n\t\t\t\tFile tempFile = new File(\"data_\" + Long.toString(ms) + \".ccnb\");\n\t\t\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t\t\ttry {\n\t\t\t\t\tbyte buf[] = new byte[1024];\n\t\t\t\t\twhile (_istream.available() > 0) {\n\t\t\t\t\t\tint count = _istream.read(buf);\n\t\t\t\t\t\tfos.write(buf,0, count);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\t_istream.reset();\n\t\t\t\tLog.info(\"BinaryXMLDecoder: exception in peekStartElement, dumping offending object to file: \" + tempFile.getAbsolutePath());\n\t\t\t\tthrow e;\n\t\t\t\t\n\t\t\t} catch (IOException ie) {\n\t\t\t\tLog.info(\"IOException in BinaryXMLDecoder error handling: \" + e.getMessage());\n\t\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.info(\"IOException in BinaryXMLDecoder peekStartElementAsLong: \" + e.getMessage());\n\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"Cannot reset stream! \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn decodedTag;\n\t}","id":3307,"modified_method":"public Long peekStartElementAsLong() throws ContentDecodingException {\n\t\t_istream.mark(MARK_LEN);\n\n\t\tLong decodedTag = null;\n\t\ttry {\n\t\t\t// Have to distinguish genuine errors from wrong tags. Could either use\n\t\t\t// a special exception subtype, or redo the work here.\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null != tv) {\n\n\t\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\t\tif (tv.val()+1 > DEBUG_MAX_LEN) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Decoding error: length \" + tv.val()+1 + \" longer than expected maximum length!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\t\tString strTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\t\n\t\t\t\t\tdecodedTag = stringToTag(strTag);\n\t\t\t\t\t\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO)) {\n\t\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"Unexpected: got text tag in peekStartElement; length: \" + (int)tv.val()+1 + \" decoded tag = \" + decodedTag);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\t\tdecodedTag = tv.val();\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} // else, not a type and val, probably an end element. rewind and return false.\n\n\t\t} catch (ContentDecodingException e) {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t\t_istream.mark(MARK_LEN);\n\t\t\t\tlong ms = System.currentTimeMillis();\n\t\t\t\tFile tempFile = new File(\"data_\" + Long.toString(ms) + \".ccnb\");\n\t\t\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t\t\ttry {\n\t\t\t\t\tbyte buf[] = new byte[1024];\n\t\t\t\t\twhile (_istream.available() > 0) {\n\t\t\t\t\t\tint count = _istream.read(buf);\n\t\t\t\t\t\tfos.write(buf,0, count);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\t_istream.reset();\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"BinaryXMLDecoder: exception in peekStartElement, dumping offending object to file: \" + tempFile.getAbsolutePath());\n\t\t\t\tthrow e;\n\t\t\t\t\n\t\t\t} catch (IOException ie) {\n\t\t\t\tLog.info(Log.FAC_ENCODING, \"IOException in BinaryXMLDecoder error handling: \" + e.getMessage());\n\t\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.info(Log.FAC_ENCODING, \"IOException in BinaryXMLDecoder peekStartElementAsLong: \" + e.getMessage());\n\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"Cannot reset stream! \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn decodedTag;\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public String peekStartElementAsString() throws ContentDecodingException {\n\t\t_istream.mark(MARK_LEN);\n\n\t\tString decodedTag = null;\n\t\ttry {\n\t\t\t// Have to distinguish genuine errors from wrong tags. Could either use\n\t\t\t// a special exception subtype, or redo the work here.\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null != tv) {\n\n\t\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\t\tif (tv.val()+1 > DEBUG_MAX_LEN) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Decoding error: length \" + tv.val()+1 + \" longer than expected maximum length!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\t\tdecodedTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\t\n\t\t\t\t\tLog.info(\"Unexpected: got text tag in peekStartElement; length: \" + (int)tv.val()+1 + \" decoded tag = \" + decodedTag);\n\n\t\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\t\tdecodedTag = tagToString(tv.val());\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} // else, not a type and val, probably an end element. rewind and return false.\n\n\t\t} catch (ContentDecodingException e) {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t\t_istream.mark(MARK_LEN);\n\t\t\t\tlong ms = System.currentTimeMillis();\n\t\t\t\tFile tempFile = new File(\"data_\" + Long.toString(ms) + \".ccnb\");\n\t\t\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t\t\ttry {\n\t\t\t\t\tbyte buf[] = new byte[1024];\n\t\t\t\t\twhile (_istream.available() > 0) {\n\t\t\t\t\t\tint count = _istream.read(buf);\n\t\t\t\t\t\tfos.write(buf,0, count);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\t_istream.reset();\n\t\t\t\tLog.info(\"BinaryXMLDecoder: exception in peekStartElement, dumping offending object to file: \" + tempFile.getAbsolutePath());\n\t\t\t\tthrow e;\n\t\t\t\t\n\t\t\t} catch (IOException ie) {\n\t\t\t\tLog.info(\"IOException in BinaryXMLDecoder error handling: \" + e.getMessage());\n\t\t\t\tLog.logStackTrace(Level.INFO, ie);\n\t\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.info(\"IOException in BinaryXMLDecoder: \" + e.getMessage());\n\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"Cannot reset stream! \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn decodedTag;\n\t}","id":3308,"modified_method":"public String peekStartElementAsString() throws ContentDecodingException {\n\t\t_istream.mark(MARK_LEN);\n\n\t\tString decodedTag = null;\n\t\ttry {\n\t\t\t// Have to distinguish genuine errors from wrong tags. Could either use\n\t\t\t// a special exception subtype, or redo the work here.\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\tif (null != tv) {\n\n\t\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\t\tif (tv.val()+1 > DEBUG_MAX_LEN) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Decoding error: length \" + tv.val()+1 + \" longer than expected maximum length!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\t\tdecodedTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\t\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"Unexpected: got text tag in peekStartElement; length: \" + (int)tv.val()+1 + \" decoded tag = \" + decodedTag);\n\n\t\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\t\tdecodedTag = tagToString(tv.val());\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} // else, not a type and val, probably an end element. rewind and return false.\n\n\t\t} catch (ContentDecodingException e) {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t\t_istream.mark(MARK_LEN);\n\t\t\t\tlong ms = System.currentTimeMillis();\n\t\t\t\tFile tempFile = new File(\"data_\" + Long.toString(ms) + \".ccnb\");\n\t\t\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t\t\ttry {\n\t\t\t\t\tbyte buf[] = new byte[1024];\n\t\t\t\t\twhile (_istream.available() > 0) {\n\t\t\t\t\t\tint count = _istream.read(buf);\n\t\t\t\t\t\tfos.write(buf,0, count);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\t_istream.reset();\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"BinaryXMLDecoder: exception in peekStartElement, dumping offending object to file: \" + tempFile.getAbsolutePath());\n\t\t\t\tthrow e;\n\t\t\t\t\n\t\t\t} catch (IOException ie) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO)) {\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"IOException in BinaryXMLDecoder error handling: \" + e.getMessage());\n\t\t\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, ie);\n\t\t\t\t}\n\t\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.info(Log.FAC_ENCODING, \"IOException in BinaryXMLDecoder: \" + e.getMessage());\n\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"peekStartElement\", e);\n\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\t_istream.reset();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\t\tthrow new ContentDecodingException(\"Cannot reset stream! \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn decodedTag;\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void readAttributes(TreeMap<String,String> attributes) throws ContentDecodingException {\n\t\t\n\t\tif (null == attributes) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Now need to get attributes.\n\t\t\tBinaryXMLCodec.TypeAndVal nextTV = BinaryXMLCodec.peekTypeAndVal(_istream);\n\n\t\t\twhile ((null != nextTV) && ((BinaryXMLCodec.XML_ATTR == nextTV.type()) ||\n\t\t\t\t\t(BinaryXMLCodec.XML_DATTR == nextTV.type()))) {\n\n\t\t\t\t// Decode this attribute. First, really read the type and value.\n\t\t\t\tBinaryXMLCodec.TypeAndVal thisTV = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\t\tString attributeName = null;\n\t\t\t\tif (BinaryXMLCodec.XML_ATTR == thisTV.type()) {\n\t\t\t\t\t// Tag value represents length-1 as attribute names cannot be empty.\n\t\t\t\t\tattributeName = BinaryXMLCodec.decodeUString(_istream, (int)thisTV.val()+1);\n\n\t\t\t\t} else if (BinaryXMLCodec.XML_DATTR == thisTV.type()) {\n\t\t\t\t\t// DKS TODO are attributes same or different dictionary?\n\t\t\t\t\tattributeName = tagToString(thisTV.val());\n\t\t\t\t\tif (null == attributeName) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Unknown DATTR value\" + thisTV.val());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Attribute values are always UDATA\n\t\t\t\tString attributeValue = BinaryXMLCodec.decodeUString(_istream);\n\n\t\t\t\tattributes.put(attributeName, attributeValue);\n\n\t\t\t\tnextTV = BinaryXMLCodec.peekTypeAndVal(_istream);\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.logStackTrace(Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","id":3309,"modified_method":"public void readAttributes(TreeMap<String,String> attributes) throws ContentDecodingException {\n\t\t\n\t\tif (null == attributes) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Now need to get attributes.\n\t\t\tBinaryXMLCodec.TypeAndVal nextTV = BinaryXMLCodec.peekTypeAndVal(_istream);\n\n\t\t\twhile ((null != nextTV) && ((BinaryXMLCodec.XML_ATTR == nextTV.type()) ||\n\t\t\t\t\t(BinaryXMLCodec.XML_DATTR == nextTV.type()))) {\n\n\t\t\t\t// Decode this attribute. First, really read the type and value.\n\t\t\t\tBinaryXMLCodec.TypeAndVal thisTV = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\n\t\t\t\tString attributeName = null;\n\t\t\t\tif (BinaryXMLCodec.XML_ATTR == thisTV.type()) {\n\t\t\t\t\t// Tag value represents length-1 as attribute names cannot be empty.\n\t\t\t\t\tattributeName = BinaryXMLCodec.decodeUString(_istream, (int)thisTV.val()+1);\n\n\t\t\t\t} else if (BinaryXMLCodec.XML_DATTR == thisTV.type()) {\n\t\t\t\t\t// DKS TODO are attributes same or different dictionary?\n\t\t\t\t\tattributeName = tagToString(thisTV.val());\n\t\t\t\t\tif (null == attributeName) {\n\t\t\t\t\t\tthrow new ContentDecodingException(\"Unknown DATTR value\" + thisTV.val());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Attribute values are always UDATA\n\t\t\t\tString attributeValue = BinaryXMLCodec.decodeUString(_istream);\n\n\t\t\t\tattributes.put(attributeName, attributeValue);\n\n\t\t\t\tnextTV = BinaryXMLCodec.peekTypeAndVal(_istream);\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.logStackTrace(Log.FAC_ENCODING, Level.INFO, e);\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void readStartElement(String startTag,\n\t\t\t\t\t\t\t    TreeMap<String, String> attributes) throws ContentDecodingException {\n\t\ttry {\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\t\t\t\n\t\t\tif (null == tv) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got something not a tag.\");\n\t\t\t}\n\t\t\t\n\t\t\tString decodedTag = null;\n\t\t\t\n\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\tLog.info(\"Unexpected: got tag in readStartElement; looking for tag \" + startTag + \" got length: \" + (int)tv.val()+1);\n\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\tdecodedTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\n\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\tdecodedTag = tagToString(tv.val());\t\n\t\t\t}\n\t\t\t\n\t\t\tif ((null ==  decodedTag) || (!decodedTag.equals(startTag))) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got: \" + decodedTag + \"(\" + tv.val() + \")\");\n\t\t\t}\n\t\t\t\n\t\t\t// DKS: does not read attributes out of stream if caller doesn't\n\t\t\t// ask for them. Should possibly peek and skip over them regardless.\n\t\t\t// TODO: fix this\n\t\t\tif (null != attributes) {\n\t\t\t\treadAttributes(attributes); \n\t\t\t}\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","id":3310,"modified_method":"public void readStartElement(String startTag,\n\t\t\t\t\t\t\t    TreeMap<String, String> attributes) throws ContentDecodingException {\n\t\ttry {\n\t\t\tBinaryXMLCodec.TypeAndVal tv = BinaryXMLCodec.decodeTypeAndVal(_istream);\n\t\t\t\n\t\t\tif (null == tv) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got something not a tag.\");\n\t\t\t}\n\t\t\t\n\t\t\tString decodedTag = null;\n\t\t\t\n\t\t\tif (tv.type() == BinaryXMLCodec.XML_TAG) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"Unexpected: got tag in readStartElement; looking for tag \" + startTag + \" got length: \" + (int)tv.val()+1);\n\t\t\t\t// Tag value represents length-1 as tags can never be empty.\n\t\t\t\tdecodedTag = BinaryXMLCodec.decodeUString(_istream, (int)tv.val()+1);\n\t\t\t\t\n\t\t\t} else if (tv.type() == BinaryXMLCodec.XML_DTAG) {\n\t\t\t\tdecodedTag = tagToString(tv.val());\t\n\t\t\t}\n\t\t\t\n\t\t\tif ((null ==  decodedTag) || (!decodedTag.equals(startTag))) {\n\t\t\t\tthrow new ContentDecodingException(\"Expected start element: \" + startTag + \" got: \" + decodedTag + \"(\" + tv.val() + \")\");\n\t\t\t}\n\t\t\t\n\t\t\t// DKS: does not read attributes out of stream if caller doesn't\n\t\t\t// ask for them. Should possibly peek and skip over them regardless.\n\t\t\t// TODO: fix this\n\t\t\tif (null != attributes) {\n\t\t\t\treadAttributes(attributes); \n\t\t\t}\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentDecodingException(\"readStartElement\", e);\n\t\t}\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void writeStartElement(String tag, TreeMap<String,String> attributes) throws ContentEncodingException {\n\t\ttry {\n\t\t\tLong dictionaryVal = stringToTag(tag);\n\t\t\t\n\t\t\tif (null == dictionaryVal) {\n\t\t\t\tLog.info(\"Unexpected: tag found that is not in our dictionary: \" + tag);\n\t\t\t\t// not in dictionary\n\t\t\t\t// compressed format wants length of tag represented as length-1\n\t\t\t\t// to save that extra bit, as tag cannot be 0 length.\n\t\t\t\t// encodeUString knows to do that.\n\t\t\t\tBinaryXMLCodec.encodeUString(_ostream, tag, BinaryXMLCodec.XML_TAG);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tBinaryXMLCodec.encodeTypeAndVal(BinaryXMLCodec.XML_DTAG, dictionaryVal, _ostream);\n\t\t\t}\n\t\t\t\n\t\t\tif (null != attributes) {\n\t\t\t\twriteAttributes(attributes); \n\t\t\t}\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentEncodingException(e.getMessage(),e);\n\t\t}\n\t}","id":3311,"modified_method":"public void writeStartElement(String tag, TreeMap<String,String> attributes) throws ContentEncodingException {\n\t\ttry {\n\t\t\tLong dictionaryVal = stringToTag(tag);\n\t\t\t\n\t\t\tif (null == dictionaryVal) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_ENCODING, \"Unexpected: tag found that is not in our dictionary: \" + tag);\n\t\t\t\t// not in dictionary\n\t\t\t\t// compressed format wants length of tag represented as length-1\n\t\t\t\t// to save that extra bit, as tag cannot be 0 length.\n\t\t\t\t// encodeUString knows to do that.\n\t\t\t\tBinaryXMLCodec.encodeUString(_ostream, tag, BinaryXMLCodec.XML_TAG);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tBinaryXMLCodec.encodeTypeAndVal(BinaryXMLCodec.XML_DTAG, dictionaryVal, _ostream);\n\t\t\t}\n\t\t\t\n\t\t\tif (null != attributes) {\n\t\t\t\twriteAttributes(attributes); \n\t\t\t}\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ContentEncodingException(e.getMessage(),e);\n\t\t}\n\t}","commit_id":"e4c8640741d61f07e79b3f5c375e46485902c77f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsMethodImpl clsMethod) {\n        return getJetDeclarationByClsElement(clsMethod);\n    }","id":3312,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsMethodImpl clsMethod) {\n        JetDeclaration jetDeclaration = getJetDeclarationByClsElement(clsMethod);\n        if (jetDeclaration instanceof JetProperty) {\n            JetProperty sourceProperty = JetSourceNavigationHelper.getSourceProperty((JetProperty) jetDeclaration);\n            if (sourceProperty != null) {\n                return sourceProperty;\n            }\n        }\n        return jetDeclaration;\n    }","commit_id":"a86c3a5fa3c5bc09382257b45f2246fced85d8c0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsClassImpl clsClass) {\n        return getJetDeclarationByClsElement(clsClass);\n    }","id":3313,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsClassImpl clsClass) {\n        JetClass jetClass = (JetClass) getJetDeclarationByClsElement(clsClass);\n        if (jetClass != null) {\n            JetClass sourceClass = JetSourceNavigationHelper.getSourceClass(jetClass);\n            if (sourceClass != null) {\n                return sourceClass;\n            }\n        }\n        return jetClass;\n    }","commit_id":"2b52caf1feefeb8e2af433da91688b437c0cbedb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsFieldImpl clsField) {\n        return getJetDeclarationByClsElement(clsField);\n    }","id":3314,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsFieldImpl clsField) {\n        JetDeclaration jetDeclaration = getJetDeclarationByClsElement(clsField);\n        if (jetDeclaration instanceof JetProperty) {\n            JetDeclaration sourceProperty = JetSourceNavigationHelper.getSourceProperty((JetProperty) jetDeclaration);\n            if (sourceProperty != null) {\n                return sourceProperty;\n            }\n        }\n        return jetDeclaration;\n    }","commit_id":"d825fb25a0a57574e7a61662d144e5b1993611f1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n   * @summary get the used disk capacity, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsUsedBytes() {\n    try {\n      return Response.ok(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_USED)).build();\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return Response.serverError().entity(e.getMessage()).build();\n    }\n  }","id":3315,"modified_method":"/**\n   * @summary get the used disk capacity, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsUsedBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_USED));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the list of worker descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.WorkerInfo>\")\n  public Response getWorkerInfoList() {\n    return Response.ok(mBlockMaster.getWorkerInfoList()).build();\n  }","id":3316,"modified_method":"/**\n   * @summary get the list of worker descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.WorkerInfo>\")\n  public Response getWorkerInfoList() {\n    return RestUtils.createResponse(mBlockMaster.getWorkerInfoList());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to total capacity of the tier in bytes, keys are in\n   *    the order from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getTotalBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return Response.ok(capacityBytesOnTiers).build();\n  }","id":3317,"modified_method":"/**\n   * @summary get the mapping from tier alias to total capacity of the tier in bytes, keys are in\n   *    the order from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getTotalBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(capacityBytesOnTiers);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the total capacity of all workers in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return Response.ok(mBlockMaster.getCapacityBytes()).build();\n  }","id":3318,"modified_method":"/**\n   * @summary get the total capacity of all workers in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.createResponse(mBlockMaster.getCapacityBytes());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the version of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Version.VERSION)).build();\n  }","id":3319,"modified_method":"/**\n   * @summary get the version of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.createResponse(Version.VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the uptime of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return Response.ok(mMaster.getUptimeMs()).build();\n  }","id":3320,"modified_method":"/**\n   * @summary get the uptime of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.createResponse(mMaster.getUptimeMs());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<String, String>\")\n  public Response getConfiguration() {\n    Set<Map.Entry<Object, Object>> properties = mMasterConf.getInternalProperties().entrySet();\n    SortedMap<String, String> configuration = new TreeMap<>();\n    for (Map.Entry<Object, Object> entry : properties) {\n      String key = entry.getKey().toString();\n      if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n        configuration.put(key, (String) entry.getValue());\n      }\n    }\n    return Response.ok(configuration).build();\n  }","id":3321,"modified_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<String, String>\")\n  public Response getConfiguration() {\n    Set<Map.Entry<Object, Object>> properties = mMasterConf.getInternalProperties().entrySet();\n    SortedMap<String, String> configuration = new TreeMap<>();\n    for (Map.Entry<Object, Object> entry : properties) {\n      String key = entry.getKey().toString();\n      if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n        configuration.put(key, (String) entry.getValue());\n      }\n    }\n    return RestUtils.createResponse(configuration);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, keys are in the order\n   *    from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return Response.ok(usedBytesOnTiers).build();\n  }","id":3322,"modified_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, keys are in the order\n   *    from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(usedBytesOnTiers);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the total ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsCapacityBytes() {\n    try {\n      return Response.ok(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_TOTAL)).build();\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return Response.serverError().entity(e.getMessage()).build();\n    }\n  }","id":3323,"modified_method":"/**\n   * @summary get the total ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsCapacityBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_TOTAL));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the count of workers\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_COUNT)\n  @ReturnType(\"java.lang.Integer\")\n  public Response getWorkerCount() {\n    return Response.ok(mBlockMaster.getWorkerCount()).build();\n  }","id":3324,"modified_method":"/**\n   * @summary get the count of workers\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_COUNT)\n  @ReturnType(\"java.lang.Integer\")\n  public Response getWorkerCount() {\n    return RestUtils.createResponse(mBlockMaster.getWorkerCount());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the free ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsFreeBytes() {\n    try {\n      return Response.ok(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_FREE)).build();\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return Response.serverError().entity(e.getMessage()).build();\n    }\n  }","id":3325,"modified_method":"/**\n   * @summary get the free ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsFreeBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_FREE));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the start time of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return Response.ok(mMaster.getStartTimeMs()).build();\n  }","id":3326,"modified_method":"/**\n   * @summary get the start time of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.createResponse(mMaster.getStartTimeMs());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the master rpc address\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(mMaster.getMasterAddress().toString())).build();\n  }","id":3327,"modified_method":"/**\n   * @summary get the master rpc address\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.createResponse(mMaster.getMasterAddress().toString());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the master metrics, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mMaster.getMasterMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for pinned files is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String filesPinnedProperty = CommonUtils.argsToString(\".\",\n        MasterContext.getMasterSource().getName(), MasterSource.FILES_PINNED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> filesPinned =\n        (Gauge<Integer>) metricRegistry.getGauges().get(filesPinnedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(filesPinnedProperty, filesPinned.getValue().longValue());\n\n    return Response.ok(metrics).build();\n  }","id":3328,"modified_method":"/**\n   * @summary get the master metrics, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mMaster.getMasterMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for pinned files is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String filesPinnedProperty = CommonUtils.argsToString(\".\",\n        MasterContext.getMasterSource().getName(), MasterSource.FILES_PINNED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> filesPinned =\n        (Gauge<Integer>) metricRegistry.getGauges().get(filesPinnedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(filesPinnedProperty, filesPinned.getValue().longValue());\n\n    return RestUtils.createResponse(metrics);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the free capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getFreeBytes() {\n    return Response.ok(mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes()).build();\n  }","id":3329,"modified_method":"/**\n   * @summary get the free capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getFreeBytes() {\n    return RestUtils.createResponse(mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the used capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return Response.ok(mBlockMaster.getUsedBytes()).build();\n  }","id":3330,"modified_method":"/**\n   * @summary get the used capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.createResponse(mBlockMaster.getUsedBytes());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the paths of the directories in the tier\n   * @return the response object\n   */\n  @GET\n  @Path(GET_DIRECTORY_PATHS_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, java.util.List<String>>\")\n  public Response getDirectoryPathsOnTiers() {\n    SortedMap<String, List<String>> tierToDirPaths = new TreeMap<>(getTierAliasComparator());\n    tierToDirPaths.putAll(mStoreMeta.getDirectoryPathsOnTiers());\n    return Response.ok(tierToDirPaths).build();\n  }","id":3331,"modified_method":"/**\n   * @summary get the mapping from tier alias to the paths of the directories in the tier\n   * @return the response object\n   */\n  @GET\n  @Path(GET_DIRECTORY_PATHS_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, java.util.List<String>>\")\n  public Response getDirectoryPathsOnTiers() {\n    SortedMap<String, List<String>> tierToDirPaths = new TreeMap<>(getTierAliasComparator());\n    tierToDirPaths.putAll(mStoreMeta.getDirectoryPathsOnTiers());\n    return RestUtils.createResponse(tierToDirPaths);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the uptime of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return Response.ok(mWorker.getUptimeMs()).build();\n  }","id":3332,"modified_method":"/**\n   * @summary get the uptime of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.createResponse(mWorker.getUptimeMs());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the worker metrics\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mWorker.getWorkerMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for cached blocks is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String blocksCachedProperty = CommonUtils.argsToString(\".\",\n        WorkerContext.getWorkerSource().getName(), WorkerSource.BLOCKS_CACHED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> blocksCached =\n        (Gauge<Integer>) metricRegistry.getGauges().get(blocksCachedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(blocksCachedProperty, blocksCached.getValue().longValue());\n\n    return Response.ok(metrics).build();\n  }","id":3333,"modified_method":"/**\n   * @summary get the worker metrics\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mWorker.getWorkerMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for cached blocks is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String blocksCachedProperty = CommonUtils.argsToString(\".\",\n        WorkerContext.getWorkerSource().getName(), WorkerSource.BLOCKS_CACHED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> blocksCached =\n        (Gauge<Integer>) metricRegistry.getGauges().get(blocksCachedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(blocksCachedProperty, blocksCached.getValue().longValue());\n\n    return RestUtils.createResponse(metrics);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the total capacity of the tier in bytes, the keys\n   *    are in the order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getCapacityBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return Response.ok(capacityBytesOnTiers).build();\n  }","id":3334,"modified_method":"/**\n   * @summary get the mapping from tier alias to the total capacity of the tier in bytes, the keys\n   *    are in the order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getCapacityBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(capacityBytesOnTiers);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the total capacity of the worker in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return Response.ok(mStoreMeta.getCapacityBytes()).build();\n  }","id":3335,"modified_method":"/**\n   * @summary get the total capacity of the worker in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.createResponse(mStoreMeta.getCapacityBytes());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the start time of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return Response.ok(mWorker.getStartTimeMs()).build();\n  }","id":3336,"modified_method":"/**\n   * @summary get the start time of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.createResponse(mWorker.getStartTimeMs());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the address of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(mWorker.getWorkerAddress().toString())).build();\n  }","id":3337,"modified_method":"/**\n   * @summary get the address of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.createResponse(mWorker.getWorkerAddress().toString());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the version of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Version.VERSION)).build();\n  }","id":3338,"modified_method":"/**\n   * @summary get the version of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.createResponse(Version.VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the used bytes of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return Response.ok(mStoreMeta.getUsedBytes()).build();\n  }","id":3339,"modified_method":"/**\n   * @summary get the used bytes of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.createResponse(mStoreMeta.getUsedBytes());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, the keys are in the\n   *    order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return Response.ok(usedBytesOnTiers).build();\n  }","id":3340,"modified_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, the keys are in the\n   *    order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<String, Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(usedBytesOnTiers);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return Response.ok(Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION).build();\n  }","id":3341,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME)).build();\n  }","id":3342,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME)).build();\n  }","id":3343,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return RestUtils.createResponse(Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return Response.ok(Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION).build();\n  }","id":3344,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the UFS address\n   * @return the UFS address\n   * @deprecated since version 1.1 and will be removed in version 2.0\n   */\n  @Deprecated\n  @GET\n  @Path(GET_UFS_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getUfsAddress() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(mFileSystemMaster.getUfsAddress())).build();\n  }","id":3345,"modified_method":"/**\n   * @summary get the UFS address\n   * @return the UFS address\n   * @deprecated since version 1.1 and will be removed in version 2.0\n   */\n  @Deprecated\n  @GET\n  @Path(GET_UFS_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getUfsAddress() {\n    return RestUtils.createResponse(mFileSystemMaster.getUfsAddress());\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return Response.ok(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_VERSION).build();\n  }","id":3346,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_NAME))\n        .build();\n  }","id":3347,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_NAME);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return Response.ok(Constants.LINEAGE_MASTER_CLIENT_SERVICE_VERSION).build();\n  }","id":3348,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.LINEAGE_MASTER_CLIENT_SERVICE_VERSION);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the list of lineage descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_LINEAGE_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.LineageInfo>\")\n  public Response getLineageInfoList() {\n    try {\n      return Response.ok(mLineageMaster.getLineageInfoList()).build();\n    } catch (AlluxioException e) {\n      LOG.warn(e.getMessage());\n      return Response.serverError().entity(e.getMessage()).build();\n    }\n  }","id":3349,"modified_method":"/**\n   * @summary get the list of lineage descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_LINEAGE_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.LineageInfo>\")\n  public Response getLineageInfoList() {\n    try {\n      return RestUtils.createResponse(mLineageMaster.getLineageInfoList());\n    } catch (AlluxioException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return Response.ok(FormatUtils.encodeJson(Constants.LINEAGE_MASTER_CLIENT_SERVICE_NAME))\n        .build();\n  }","id":3350,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.LINEAGE_MASTER_CLIENT_SERVICE_NAME);\n  }","commit_id":"72c9f40f2fe7f128bb604d74d06e73cfe417edbc","url":"https://github.com/amplab/tachyon"},{"original_method":"private void loadExternalConfig()\n   {\n      Properties config = getExternalConfig();\n\n      // Authentication policies\n      for( AuthenticationType authType : AuthenticationType.values() )\n      {\n         String key = KEY_AUTH_POLICY + \".\" + authType.name().toLowerCase();\n         if( config.containsKey( key ) )\n         {\n            loginModuleNames.put( authType, config.getProperty(key) );\n         }\n      }\n\n      // Admin users\n      if( config.containsKey( KEY_ADMIN_USERS ) )\n      {\n         String userList = config.getProperty(KEY_ADMIN_USERS);\n\n         for( String userName : userList.split(\",\") )\n         {\n            adminUsers.add( userName.trim() );\n         }\n      }\n   }","id":3351,"modified_method":"private void loadExternalConfig()\n   {\n      // Authentication policies\n      for( AuthenticationType authType : AuthenticationType.values() )\n      {\n         String key = KEY_AUTH_POLICY + \".\" + authType.name().toLowerCase();\n         if( externalConfig.containsKey( key ) )\n         {\n            loginModuleNames.put( authType, externalConfig.getProperty(key) );\n         }\n      }\n\n      // Admin users\n      if( externalConfig.containsKey( KEY_ADMIN_USERS ) )\n      {\n         String userList = externalConfig.getProperty(KEY_ADMIN_USERS);\n\n         for( String userName : userList.split(\",\") )\n         {\n            adminUsers.add( userName.trim() );\n         }\n      }\n   }","commit_id":"b44f3850b40e54aa6ba98fa25ac85b48a404a854","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)\n   {\n      this.subject = subject;\n      this.callbackHandler = callbackHandler;\n      this.options = options;\n\n      // TODO USe JNDI variables to get this information\n      ApplicationConfiguration appConfig = (ApplicationConfiguration)Component.getInstance(ApplicationConfiguration.class);\n\n      internalAuthDomain = appConfig.getLoginModuleName(AuthenticationType.INTERNAL);\n      kerberosDomain = appConfig.getLoginModuleName(AuthenticationType.KERBEROS);\n      openIdDomain = appConfig.getLoginModuleName(AuthenticationType.OPENID);\n      jaasDomain = appConfig.getLoginModuleName(AuthenticationType.JAAS);\n   }","id":3352,"modified_method":"@Override\n   public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)\n   {\n      this.subject = subject;\n      this.callbackHandler = callbackHandler;\n      this.options = options;\n\n      // TODO Use JNDI variables to get this information\n      ZanataBasicConfig basicConfig = ZanataBasicConfig.getInstance();\n\n      internalAuthDomain = basicConfig.getProperty(KEY_AUTH_POLICY + \".\" + AuthenticationType.INTERNAL.name().toLowerCase());\n      kerberosDomain = basicConfig.getProperty(KEY_AUTH_POLICY + \".\" + AuthenticationType.KERBEROS.name().toLowerCase());\n      openIdDomain = basicConfig.getProperty(KEY_AUTH_POLICY + \".\" + AuthenticationType.OPENID.name().toLowerCase());\n      jaasDomain = basicConfig.getProperty(KEY_AUTH_POLICY + \".\" + AuthenticationType.JAAS.name().toLowerCase());\n   }","commit_id":"b44f3850b40e54aa6ba98fa25ac85b48a404a854","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public boolean login() throws LoginException\n   {\n      AuthenticationTypeCallback authTypeCallback = new AuthenticationTypeCallback();\n\n      // Get the authentication type\n      try\n      {\n         callbackHandler.handle(new Callback[]{authTypeCallback});\n      }\n      catch (Exception e)\n      {\n         LoginException lex = new LoginException(e.getMessage());\n         lex.initCause(e);\n         throw lex;\n      }\n      AuthenticationType authType = authTypeCallback.getAuthType();\n      if( !isAuthTypeValid(authType) )\n      {\n         throw new LoginException(\"Invalid Authentication type: \" + authType + \". Please check your server configuration\");\n      }\n\n      String delegateName = null;\n      switch (authType)\n      {\n         case INTERNAL:\n            delegateName = internalAuthDomain;\n            break;\n         case KERBEROS:\n            delegateName = kerberosDomain;\n            break;\n         case OPENID:\n            delegateName = openIdDomain;\n            break;\n         case JAAS:\n            delegateName = jaasDomain;\n            break;\n      }\n\n      delegate = new LoginContext(delegateName, subject, callbackHandler);\n      delegate.login();\n      return true;\n   }","id":3353,"modified_method":"@Override\n   public boolean login() throws LoginException\n   {\n      AuthenticationTypeCallback authTypeCallback = new AuthenticationTypeCallback();\n\n      // Get the authentication type\n      try\n      {\n         callbackHandler.handle(new Callback[]{authTypeCallback});\n      }\n      catch( UnsupportedCallbackException ucex )\n      {\n         // This happens on kerberos authentication\n         // NB: A custom callback handler could be configured on the app server to avoid this.\n         authTypeCallback.setAuthType( AuthenticationType.KERBEROS );\n      }\n      catch (Exception e)\n      {\n         LoginException lex = new LoginException(e.getMessage());\n         lex.initCause(e);\n         throw lex;\n      }\n      AuthenticationType authType = authTypeCallback.getAuthType();\n\n      String delegateName = null;\n      switch (authType)\n      {\n         case INTERNAL:\n            delegateName = internalAuthDomain;\n            break;\n         case KERBEROS:\n            delegateName = kerberosDomain;\n            break;\n         case OPENID:\n            delegateName = openIdDomain;\n            break;\n         case JAAS:\n            delegateName = jaasDomain;\n            break;\n      }\n\n      delegate = new LoginContext(delegateName, subject, callbackHandler);\n      delegate.login();\n      return true;\n   }","commit_id":"b44f3850b40e54aa6ba98fa25ac85b48a404a854","url":"https://github.com/zanata/zanata-server"},{"original_method":"private Map<String, ModelService> getGlobalServiceMap() {\n        Map<String, ModelService> serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n        if (serviceMap == null) {\n            synchronized (this) {\n                serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n                if (serviceMap == null) {\n                    serviceMap = FastMap.newInstance();\n\n                    Element rootElement;\n\n                    try {\n                        rootElement = ServiceConfigUtil.getXmlRootElement();\n                    } catch (GenericConfigException e) {\n                        Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n                        return null;\n                    }\n\n                    for (Element globalServicesElement: UtilXml.childElementList(rootElement, \"global-services\")) {\n                        ResourceHandler handler = new MainResourceHandler(\n                                ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, globalServicesElement);\n\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(handler, this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n                    \n                    // get all of the component resource model stuff, ie specified in each ofbiz-component.xml file\n                    List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"model\");\n                    Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n                    while (componentResourceInfoIter.hasNext()) {\n                        ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(componentResourceInfo.createResourceHandler(), this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n\n                    if (serviceMap != null) {\n                        modelServiceMapByDispatcher.put(GLOBAL_KEY, serviceMap);\n                        ServiceEcaUtil.reloadConfig();\n                    }\n                }\n            }\n        }\n\n        return serviceMap;\n    }","id":3354,"modified_method":"private Map<String, ModelService> getGlobalServiceMap() {\n        Map<String, ModelService> serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n        if (serviceMap == null) {\n            synchronized (this) {\n                serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n                if (serviceMap == null) {\n                    serviceMap = FastMap.newInstance();\n\n                    Element rootElement;\n\n                    try {\n                        rootElement = ServiceConfigUtil.getXmlRootElement();\n                    } catch (GenericConfigException e) {\n                        Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n                        return null;\n                    }\n\n                    for (Element globalServicesElement: UtilXml.childElementList(rootElement, \"global-services\")) {\n                        ResourceHandler handler = new MainResourceHandler(\n                                ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, globalServicesElement);\n\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(handler, this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n                    \n                    // get all of the component resource model stuff, ie specified in each ofbiz-component.xml file\n                    for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"model\")) {\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(componentResourceInfo.createResourceHandler(), this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n\n                    if (serviceMap != null) {\n                        modelServiceMapByDispatcher.put(GLOBAL_KEY, serviceMap);\n                        ServiceEcaUtil.reloadConfig();\n                    }\n                }\n            }\n        }\n\n        return serviceMap;\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Start the container\n     *\n     * @return true if server started\n     * @throws org.ofbiz.base.container.ContainerException\n     *\n     */\n    public boolean start() throws ContainerException {\n        ContainerConfig.Container cfg = ContainerConfig.getContainer(\"javamail-container\", configFile);\n        String dispatcherName = ContainerConfig.getPropertyValue(cfg, \"dispatcher-name\", \"JavaMailDispatcher\");\n        String delegatorName = ContainerConfig.getPropertyValue(cfg, \"delegator-name\", \"default\");\n        this.deleteMail = \"true\".equals(ContainerConfig.getPropertyValue(cfg, \"delete-mail\", \"false\"));\n        \n        this.delegator = GenericDelegator.getGenericDelegator(delegatorName);\n        this.dispatcher = GenericDispatcher.getLocalDispatcher(dispatcherName, delegator);\n        this.timerDelay = (long) ContainerConfig.getPropertyValue(cfg, \"poll-delay\", 300000);\n        this.maxSize = (long) ContainerConfig.getPropertyValue(cfg, \"maxSize\", 1000000); // maximum size in bytes\n\n        // load the userLogin object\n        String runAsUser = ContainerConfig.getPropertyValue(cfg, \"run-as-user\", \"system\");\n        try {\n            this.userLogin = delegator.findByPrimaryKey(\"UserLogin\", \"userLoginId\", runAsUser);\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Unable to load run-as-user UserLogin; cannot start container\", module);\n            return false;\n        }\n\n        // load the MCA configuration\n        ServiceMcaUtil.readConfig();\n\n        // load the listeners\n        List configs = cfg.getPropertiesWithValue(\"store-listener\");\n        Iterator i = configs.iterator();\n        while (i.hasNext()) {\n            ContainerConfig.Container.Property prop = (ContainerConfig.Container.Property) i.next();\n            Session session = this.makeSession(prop);\n            Store store = this.getStore(session);\n            if (store != null) {\n                stores.put(store, session);\n                store.addStoreListener(new LoggingStoreListener());\n            }\n        }\n\n        // start the polling timer\n        if (stores != null && stores.size() > 0) {\n            pollTimer.schedule(new PollerTask(dispatcher, userLogin), timerDelay, timerDelay);\n        } else {\n            Debug.logWarning(\"No JavaMail Store(s) configured; poller disabled.\", module);\n        }\n\n        return true;\n    }","id":3355,"modified_method":"/**\n     * Start the container\n     *\n     * @return true if server started\n     * @throws org.ofbiz.base.container.ContainerException\n     *\n     */\n    public boolean start() throws ContainerException {\n        ContainerConfig.Container cfg = ContainerConfig.getContainer(\"javamail-container\", configFile);\n        String dispatcherName = ContainerConfig.getPropertyValue(cfg, \"dispatcher-name\", \"JavaMailDispatcher\");\n        String delegatorName = ContainerConfig.getPropertyValue(cfg, \"delegator-name\", \"default\");\n        this.deleteMail = \"true\".equals(ContainerConfig.getPropertyValue(cfg, \"delete-mail\", \"false\"));\n        \n        this.delegator = GenericDelegator.getGenericDelegator(delegatorName);\n        this.dispatcher = GenericDispatcher.getLocalDispatcher(dispatcherName, delegator);\n        this.timerDelay = (long) ContainerConfig.getPropertyValue(cfg, \"poll-delay\", 300000);\n        this.maxSize = (long) ContainerConfig.getPropertyValue(cfg, \"maxSize\", 1000000); // maximum size in bytes\n\n        // load the userLogin object\n        String runAsUser = ContainerConfig.getPropertyValue(cfg, \"run-as-user\", \"system\");\n        try {\n            this.userLogin = delegator.findByPrimaryKey(\"UserLogin\", \"userLoginId\", runAsUser);\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Unable to load run-as-user UserLogin; cannot start container\", module);\n            return false;\n        }\n\n        // load the MCA configuration\n        ServiceMcaUtil.readConfig();\n\n        // load the listeners\n        List<ContainerConfig.Container.Property> configs = cfg.getPropertiesWithValue(\"store-listener\");\n        for (ContainerConfig.Container.Property prop: configs) {\n            Session session = this.makeSession(prop);\n            Store store = this.getStore(session);\n            if (store != null) {\n                stores.put(store, session);\n                store.addStoreListener(new LoggingStoreListener());\n            }\n        }\n\n        // start the polling timer\n        if (stores != null && stores.size() > 0) {\n            pollTimer.schedule(new PollerTask(dispatcher, userLogin), timerDelay, timerDelay);\n        } else {\n            Debug.logWarning(\"No JavaMail Store(s) configured; poller disabled.\", module);\n        }\n\n        return true;\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"protected Session makeSession(ContainerConfig.Container.Property client) {\n        Properties props = new Properties();\n        Map clientProps = client.properties;\n        if (clientProps != null) {\n            Iterator i = clientProps.entrySet().iterator();\n            while (i.hasNext()) {\n                Map.Entry e = (Map.Entry) i.next();\n                ContainerConfig.Container.Property p = (ContainerConfig.Container.Property) e.getValue();\n                props.setProperty(p.name.toLowerCase(), p.value);\n            }\n        }\n        return Session.getInstance(props);\n    }","id":3356,"modified_method":"protected Session makeSession(ContainerConfig.Container.Property client) {\n        Properties props = new Properties();\n        Map<String, ContainerConfig.Container.Property> clientProps = client.properties;\n        if (clientProps != null) {\n            for (ContainerConfig.Container.Property p: clientProps.values()) {\n                props.setProperty(p.name.toLowerCase(), p.value);\n            }\n        }\n        return Session.getInstance(props);\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceEcasElement: UtilXml.childElementList(rootElement, \"service-ecas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"eca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":3357,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceEcasElement: UtilXml.childElementList(rootElement, \"service-ecas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"eca\")) {\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceGroupElement: UtilXml.childElementList(rootElement, \"service-groups\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceGroupElement);\n            addGroupDefinitions(handler);\n        }\n\n        // get all of the component resource group stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"group\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addGroupDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":3358,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceGroupElement: UtilXml.childElementList(rootElement, \"service-groups\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceGroupElement);\n            addGroupDefinitions(handler);\n        }\n\n        // get all of the component resource group stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"group\")) {\n            addGroupDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceMcasElement: UtilXml.childElementList(rootElement, \"service-mcas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceMcasElement);\n            addMcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"mca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addMcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":3359,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceMcasElement: UtilXml.childElementList(rootElement, \"service-mcas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceMcasElement);\n            addMcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"mca\")) {\n            addMcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"private void writeParameter(@NotNull BothSignatureWriter sw, @NotNull JetType type) {\n        sw.writeParameterType(JvmMethodParameterKind.VALUE);\n        mapType(type, sw, JetTypeMapperMode.VALUE);\n        sw.writeParameterTypeEnd();\n    }","id":3360,"modified_method":"private void writeParameter(@NotNull BothSignatureWriter sw, @NotNull JetType type) {\n        writeParameter(sw, JvmMethodParameterKind.VALUE, type);\n    }","commit_id":"0caf0cffaba609ae8248120db93604b3becc29c3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JvmMethodSignature mapScriptSignature(@NotNull ScriptDescriptor script, @NotNull List<ScriptDescriptor> importedScripts) {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD);\n\n        sw.writeParametersStart();\n\n        for (ScriptDescriptor importedScript : importedScripts) {\n            sw.writeParameterType(JvmMethodParameterKind.VALUE);\n            ClassDescriptor descriptor = bindingContext.get(CLASS_FOR_SCRIPT, importedScript);\n            assert descriptor != null;\n            mapType(descriptor.getDefaultType(), sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n        }\n\n        for (ValueParameterDescriptor valueParameter : script.getScriptCodeDescriptor().getValueParameters()) {\n            writeParameter(sw, valueParameter.getType());\n        }\n\n        writeVoidReturn(sw);\n\n        return sw.makeJvmMethodSignature(\"<init>\");\n    }","id":3361,"modified_method":"@NotNull\n    public JvmMethodSignature mapScriptSignature(@NotNull ScriptDescriptor script, @NotNull List<ScriptDescriptor> importedScripts) {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD);\n\n        sw.writeParametersStart();\n\n        for (ScriptDescriptor importedScript : importedScripts) {\n            ClassDescriptor descriptor = bindingContext.get(CLASS_FOR_SCRIPT, importedScript);\n            assert descriptor != null : \"Script not found: \" + importedScript;\n            writeParameter(sw, descriptor.getDefaultType());\n        }\n\n        for (ValueParameterDescriptor valueParameter : script.getScriptCodeDescriptor().getValueParameters()) {\n            writeParameter(sw, valueParameter.getType());\n        }\n\n        writeVoidReturn(sw);\n\n        return sw.makeJvmMethodSignature(\"<init>\");\n    }","commit_id":"0caf0cffaba609ae8248120db93604b3becc29c3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull OwnerKind kind) {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD);\n\n        if (f instanceof ConstructorDescriptor) {\n            sw.writeParametersStart();\n            writeAdditionalConstructorParameters((ConstructorDescriptor) f, sw);\n\n            for (ValueParameterDescriptor parameter : f.getOriginal().getValueParameters()) {\n                writeParameter(sw, parameter.getType());\n            }\n\n            writeVoidReturn(sw);\n        }\n        else {\n            writeFormalTypeParameters(getDirectMember(f).getTypeParameters(), sw);\n\n            sw.writeParametersStart();\n            writeThisIfNeeded(f, kind, sw);\n            writeReceiverIfNeeded(f.getReceiverParameter(), sw);\n\n            for (ValueParameterDescriptor parameter : f.getValueParameters()) {\n                writeParameter(sw, parameter.getType());\n            }\n\n            sw.writeReturnType();\n            if (forceBoxedReturnType(f)) {\n                // TYPE_PARAMETER is a hack to automatically box the return type\n                //noinspection ConstantConditions\n                mapType(f.getReturnType(), sw, JetTypeMapperMode.TYPE_PARAMETER);\n            }\n            else {\n                mapReturnType(f, sw);\n            }\n            sw.writeReturnTypeEnd();\n        }\n\n        return sw.makeJvmMethodSignature(mapFunctionName(f));\n    }","id":3362,"modified_method":"@NotNull\n    public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull OwnerKind kind) {\n        BothSignatureWriter sw = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD);\n\n        if (f instanceof ConstructorDescriptor) {\n            sw.writeParametersStart();\n            writeAdditionalConstructorParameters((ConstructorDescriptor) f, sw);\n\n            for (ValueParameterDescriptor parameter : f.getOriginal().getValueParameters()) {\n                writeParameter(sw, parameter.getType());\n            }\n\n            writeVoidReturn(sw);\n        }\n        else {\n            writeFormalTypeParameters(getDirectMember(f).getTypeParameters(), sw);\n\n            sw.writeParametersStart();\n            writeThisIfNeeded(f, kind, sw);\n\n            ReceiverParameterDescriptor receiverParameter = f.getReceiverParameter();\n            if (receiverParameter != null) {\n                writeParameter(sw, JvmMethodParameterKind.RECEIVER, receiverParameter.getType());\n            }\n\n            for (ValueParameterDescriptor parameter : f.getValueParameters()) {\n                writeParameter(sw, parameter.getType());\n            }\n\n            sw.writeReturnType();\n            if (forceBoxedReturnType(f)) {\n                // TYPE_PARAMETER is a hack to automatically box the return type\n                //noinspection ConstantConditions\n                mapType(f.getReturnType(), sw, JetTypeMapperMode.TYPE_PARAMETER);\n            }\n            else {\n                mapReturnType(f, sw);\n            }\n            sw.writeReturnTypeEnd();\n        }\n\n        return sw.makeJvmMethodSignature(mapFunctionName(f));\n    }","commit_id":"0caf0cffaba609ae8248120db93604b3becc29c3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void writeThisIfNeeded(\n            @NotNull CallableMemberDescriptor descriptor,\n            @NotNull OwnerKind kind,\n            @NotNull BothSignatureWriter sw\n    ) {\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            ClassDescriptor containingDeclaration = (ClassDescriptor) descriptor.getContainingDeclaration();\n            Type type = getTraitImplThisParameterType(containingDeclaration, this);\n\n            sw.writeParameterType(JvmMethodParameterKind.THIS);\n            sw.writeAsmType(type);\n            sw.writeParameterTypeEnd();\n        }\n        else if (isAccessor(descriptor) && descriptor.getExpectedThisObject() != null) {\n            sw.writeParameterType(JvmMethodParameterKind.THIS);\n            mapType(((ClassifierDescriptor) descriptor.getContainingDeclaration()).getDefaultType(), sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n        }\n    }","id":3363,"modified_method":"private void writeThisIfNeeded(\n            @NotNull CallableMemberDescriptor descriptor,\n            @NotNull OwnerKind kind,\n            @NotNull BothSignatureWriter sw\n    ) {\n        Type thisType;\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            thisType = getTraitImplThisParameterType((ClassDescriptor) descriptor.getContainingDeclaration(), this);\n        }\n        else if (isAccessor(descriptor) && descriptor.getExpectedThisObject() != null) {\n            thisType = mapClass((ClassifierDescriptor) descriptor.getContainingDeclaration());\n        }\n        else return;\n\n        writeParameter(sw, JvmMethodParameterKind.THIS, thisType);\n    }","commit_id":"0caf0cffaba609ae8248120db93604b3becc29c3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void writeAdditionalConstructorParameters(@NotNull ConstructorDescriptor descriptor, @NotNull BothSignatureWriter sw) {\n        CalculatedClosure closure = bindingContext.get(CodegenBinding.CLOSURE, descriptor.getContainingDeclaration());\n\n        ClassDescriptor captureThis = getExpectedThisObjectForConstructorCall(descriptor, closure);\n        if (captureThis != null) {\n            sw.writeParameterType(JvmMethodParameterKind.OUTER);\n            mapType(captureThis.getDefaultType(), sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n        }\n\n        JetType captureReceiverType = closure != null ? closure.getCaptureReceiverType() : null;\n        if (captureReceiverType != null) {\n            sw.writeParameterType(JvmMethodParameterKind.RECEIVER);\n            mapType(captureReceiverType, sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n        }\n\n        ClassDescriptor containingDeclaration = descriptor.getContainingDeclaration();\n        if (containingDeclaration.getKind() == ClassKind.ENUM_CLASS || containingDeclaration.getKind() == ClassKind.ENUM_ENTRY) {\n            sw.writeParameterType(JvmMethodParameterKind.ENUM_NAME);\n            mapType(KotlinBuiltIns.getInstance().getStringType(), sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n            sw.writeParameterType(JvmMethodParameterKind.ENUM_ORDINAL);\n            mapType(KotlinBuiltIns.getInstance().getIntType(), sw, JetTypeMapperMode.VALUE);\n            sw.writeParameterTypeEnd();\n        }\n\n        if (closure == null) return;\n\n        for (DeclarationDescriptor variableDescriptor : closure.getCaptureVariables().keySet()) {\n            Type type;\n            if (variableDescriptor instanceof VariableDescriptor && !(variableDescriptor instanceof PropertyDescriptor)) {\n                Type sharedVarType = getSharedVarType(variableDescriptor);\n                if (sharedVarType == null) {\n                    sharedVarType = mapType(((VariableDescriptor) variableDescriptor).getType());\n                }\n                type = sharedVarType;\n            }\n            else if (isLocalNamedFun(variableDescriptor)) {\n                type = asmTypeForAnonymousClass(bindingContext, (FunctionDescriptor) variableDescriptor);\n            }\n            else {\n                type = null;\n            }\n\n            if (type != null) {\n                sw.writeParameterType(JvmMethodParameterKind.CAPTURED_LOCAL_VARIABLE);\n                sw.writeAsmType(type);\n                sw.writeParameterTypeEnd();\n            }\n        }\n\n        ResolvedCall<ConstructorDescriptor> superCall = closure.getSuperCall();\n        if (superCall != null && isAnonymousObject(descriptor.getContainingDeclaration())) {\n            for (JvmMethodParameterSignature parameter : mapSignature(superCall.getResultingDescriptor()).getValueParameters()) {\n                sw.writeParameterType(JvmMethodParameterKind.SUPER_OF_ANONYMOUS_CALL_PARAM);\n                sw.writeAsmType(parameter.getAsmType());\n                sw.writeParameterTypeEnd();\n            }\n        }\n    }","id":3364,"modified_method":"private void writeAdditionalConstructorParameters(@NotNull ConstructorDescriptor descriptor, @NotNull BothSignatureWriter sw) {\n        CalculatedClosure closure = bindingContext.get(CodegenBinding.CLOSURE, descriptor.getContainingDeclaration());\n\n        ClassDescriptor captureThis = getExpectedThisObjectForConstructorCall(descriptor, closure);\n        if (captureThis != null) {\n            writeParameter(sw, JvmMethodParameterKind.OUTER, captureThis.getDefaultType());\n        }\n\n        JetType captureReceiverType = closure != null ? closure.getCaptureReceiverType() : null;\n        if (captureReceiverType != null) {\n            writeParameter(sw, JvmMethodParameterKind.RECEIVER, captureReceiverType);\n        }\n\n        ClassDescriptor containingDeclaration = descriptor.getContainingDeclaration();\n        if (containingDeclaration.getKind() == ClassKind.ENUM_CLASS || containingDeclaration.getKind() == ClassKind.ENUM_ENTRY) {\n            writeParameter(sw, JvmMethodParameterKind.ENUM_NAME, KotlinBuiltIns.getInstance().getStringType());\n            writeParameter(sw, JvmMethodParameterKind.ENUM_ORDINAL, KotlinBuiltIns.getInstance().getIntType());\n        }\n\n        if (closure == null) return;\n\n        for (DeclarationDescriptor variableDescriptor : closure.getCaptureVariables().keySet()) {\n            Type type;\n            if (variableDescriptor instanceof VariableDescriptor && !(variableDescriptor instanceof PropertyDescriptor)) {\n                Type sharedVarType = getSharedVarType(variableDescriptor);\n                if (sharedVarType == null) {\n                    sharedVarType = mapType(((VariableDescriptor) variableDescriptor).getType());\n                }\n                type = sharedVarType;\n            }\n            else if (isLocalNamedFun(variableDescriptor)) {\n                type = asmTypeForAnonymousClass(bindingContext, (FunctionDescriptor) variableDescriptor);\n            }\n            else {\n                type = null;\n            }\n\n            if (type != null) {\n                writeParameter(sw, JvmMethodParameterKind.CAPTURED_LOCAL_VARIABLE, type);\n            }\n        }\n\n        ResolvedCall<ConstructorDescriptor> superCall = closure.getSuperCall();\n        if (superCall != null && isAnonymousObject(descriptor.getContainingDeclaration())) {\n            for (JvmMethodParameterSignature parameter : mapSignature(superCall.getResultingDescriptor()).getValueParameters()) {\n                writeParameter(sw, JvmMethodParameterKind.SUPER_OF_ANONYMOUS_CALL_PARAM, parameter.getAsmType());\n            }\n        }\n    }","commit_id":"0caf0cffaba609ae8248120db93604b3becc29c3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(criteria));\n    }","id":3365,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(getDistinctIdCriteria(OnmsAcknowledgment.class, criteria)));\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(criteria));\n    }","id":3366,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(getDistinctIdCriteria(OnmsAlarm.class, criteria)));\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(criteria);\n    }","id":3367,"modified_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(OnmsNode.class, criteria);\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(criteria));\n    }","id":3368,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(getDistinctIdCriteria(OnmsNotification.class,criteria)));\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return criteria;\r\n    }","id":3369,"modified_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddOrdering(params, criteria);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return getDistinctIdCriteria(OnmsMap.class, criteria);\r\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":3370,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t    System.err.println(\"params = \" + paramsCopy);\n\t    \n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\tSystem.err.println(\"matchType = \" + matchType);\n\n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n\t\t        System.err.println(String.format(\"parsing key/value: %s/%s\", key, stringValue));\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    System.err.println(\"criterion = \" + or);\n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","id":3371,"modified_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected OnmsCriteria getDistinctIdCriteria(OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n                           \n        OnmsCriteria rootCriteria = new OnmsCriteria(OnmsNode.class);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        return rootCriteria;\n    }","id":3372,"modified_method":"protected OnmsCriteria getDistinctIdCriteria(Class<?> clazz, OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n\n        OnmsCriteria rootCriteria = new OnmsCriteria(clazz);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        for (Order o : m_ordering) {\n            rootCriteria.addOrder(o);\n        }\n        return rootCriteria;\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(criteria)));\n    }","id":3373,"modified_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(OnmsOutage.class, criteria)));\n    }","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(criteria));\n    }","id":3374,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(getDistinctIdCriteria(OnmsAcknowledgment.class, criteria)));\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(criteria));\n    }","id":3375,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(getDistinctIdCriteria(OnmsAlarm.class, criteria)));\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(criteria);\n    }","id":3376,"modified_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(OnmsNode.class, criteria);\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(criteria));\n    }","id":3377,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(getDistinctIdCriteria(OnmsNotification.class,criteria)));\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return criteria;\r\n    }","id":3378,"modified_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddOrdering(params, criteria);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return getDistinctIdCriteria(OnmsMap.class, criteria);\r\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected OnmsCriteria getDistinctIdCriteria(OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n                           \n        OnmsCriteria rootCriteria = new OnmsCriteria(OnmsNode.class);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        return rootCriteria;\n    }","id":3379,"modified_method":"protected OnmsCriteria getDistinctIdCriteria(Class<?> clazz, OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n\n        OnmsCriteria rootCriteria = new OnmsCriteria(clazz);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        for (Order o : m_ordering) {\n            rootCriteria.addOrder(o);\n        }\n        return rootCriteria;\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t    System.err.println(\"params = \" + paramsCopy);\n\t    \n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\tSystem.err.println(\"matchType = \" + matchType);\n\n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n\t\t        System.err.println(String.format(\"parsing key/value: %s/%s\", key, stringValue));\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    System.err.println(\"criterion = \" + or);\n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","id":3380,"modified_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":3381,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(criteria)));\n    }","id":3382,"modified_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(OnmsOutage.class, criteria)));\n    }","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(criteria));\n    }","id":3383,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAcknowledgmentCollection getAcks() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAcknowledgment.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAcknowledgment.class);\n\n        return new OnmsAcknowledgmentCollection(m_ackDao.findMatching(getDistinctIdCriteria(OnmsAcknowledgment.class, criteria)));\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(criteria));\n    }","id":3384,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsAlarmCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsAlarm.class);\n\n    \tsetLimitOffset(params, criteria);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsAlarm.class);\n\n        return new OnmsAlarmCollection(m_alarmDao.findMatching(getDistinctIdCriteria(OnmsAlarm.class, criteria)));\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(criteria);\n    }","id":3385,"modified_method":"private OnmsCriteria getQueryFilters() {\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNode.class);\n\n    \tsetLimitOffset(params, criteria, LIMIT);\n        addOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNode.class);\n\n    \tcriteria.createAlias(\"snmpInterfaces\", \"snmpInterface\", CriteriaSpecification.LEFT_JOIN);\n        criteria.createAlias(\"ipInterfaces\", \"ipInterface\", CriteriaSpecification.LEFT_JOIN);\n        return getDistinctIdCriteria(OnmsNode.class, criteria);\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(criteria));\n    }","id":3386,"modified_method":"@GET\n    @Produces(\"text/xml\")\n    @Transactional\n    public OnmsNotificationCollection getNotifications() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsNotification.class);\n\n    \tsetLimitOffset(params, criteria, 10);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsNotification.class);\n\n        return new OnmsNotificationCollection(m_notifDao.findMatching(getDistinctIdCriteria(OnmsNotification.class,criteria)));\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return criteria;\r\n    }","id":3387,"modified_method":"private OnmsCriteria getQueryFilters() {\r\n        MultivaluedMap<String,String> params = m_uriInfo.getQueryParameters();\r\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMap.class);\r\n\r\n    \tsetLimitOffset(params, criteria, LIMIT);\r\n    \taddOrdering(params, criteria);\r\n    \taddFiltersToCriteria(params, criteria, OnmsMap.class);\r\n\r\n        return getDistinctIdCriteria(OnmsMap.class, criteria);\r\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":3388,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected OnmsCriteria getDistinctIdCriteria(OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n                           \n        OnmsCriteria rootCriteria = new OnmsCriteria(OnmsNode.class);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        return rootCriteria;\n    }","id":3389,"modified_method":"protected OnmsCriteria getDistinctIdCriteria(Class<?> clazz, OnmsCriteria criteria) {\n        criteria.setProjection(\n                               Projections.distinct(\n                                   Projections.projectionList().add(\n                                       Projections.alias( Projections.property(\"id\"), \"id\" )\n                                   )\n                               )\n                           );\n\n        OnmsCriteria rootCriteria = new OnmsCriteria(clazz);\n        rootCriteria.add(Subqueries.propertyIn(\"id\", criteria.getDetachedCriteria()));\n        for (Order o : m_ordering) {\n            rootCriteria.addOrder(o);\n        }\n        return rootCriteria;\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t    System.err.println(\"params = \" + paramsCopy);\n\t    \n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\tSystem.err.println(\"matchType = \" + matchType);\n\n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n\t\t        System.err.println(String.format(\"parsing key/value: %s/%s\", key, stringValue));\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    System.err.println(\"criterion = \" + or);\n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","id":3390,"modified_method":"/**\n\t * Method to pull out all the named params in params and use them to add restriction filters to a criteria object.  \n\t * Uses the objectClass to determine parameters and types; auto converts from strings to appropriate types, if at all possible.\n\t * Additionally, the param \"comparator\", if set, will change the comparision from the default of equality.  Acceptable comparators are:\n\t * \"equals\", \"ilike\", \"like\", \"gt\", \"lt\", \"ge\", \"le\", \"ne\" (other values will default to equality).\n\t * If there is an \"orderBy\" param, results will be ordered by the property name given.  Default is ascending, unless \"order\" is set to \"desc\"\n\t * If there is a \"query\" param, it will be added to the criteria as a raw hibernate SQL statement (in addition to any other parameters specified\n\t * \n\t * The \"criteria\" object will be populated with the filter and ordering details provided\n\t * \n\t * @param params set of string parameters from which various configuration properties are extracted\n\t * @param criteria the object which will be populated with the filter/ordering\n\t * @param objectClass the type of thing being filtered.\n\t */\n\tprotected void addFiltersToCriteria(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria, Class<?> objectClass) {\n\t\t\n\t\tMultivaluedMap<String, String> paramsCopy = new MultivaluedMapImpl();\n\t    paramsCopy.putAll(params);\n\n\t\tif(paramsCopy.containsKey(\"query\")) {\n\t\t\tString query=paramsCopy.getFirst(\"query\");\n\t\t\tcriteria.add(Restrictions.sqlRestriction(query));\n\t\t\tparamsCopy.remove(\"query\");\n\t\t}\n\n\t\tparamsCopy.remove(\"_dc\");\n\n\t\tString matchType=\"all\";\n\t\tif (paramsCopy.containsKey(\"match\")) {\n\t\t    matchType = paramsCopy.getFirst(\"match\");\n\t\t    paramsCopy.remove(\"match\");\n\t\t}\n\n        if(paramsCopy.containsKey(\"node.id\") && !matchType.equalsIgnoreCase(\"any\")) {\n            String nodeId = paramsCopy.getFirst(\"node.id\");\n            Integer id = new Integer(nodeId);\n            criteria.createCriteria(\"node\").add(Restrictions.eq(\"id\", id));\n            paramsCopy.remove(\"node.id\");\n        }\n        \n\t\t//By default, just do equals comparison\n\t\tComparisonOperation op=ComparisonOperation.EQ;\n\t\tif(paramsCopy.containsKey(\"comparator\")) {\n\t\t\tString comparatorLabel=paramsCopy.getFirst(\"comparator\");\n\t\t\tparamsCopy.remove(\"comparator\");\n\t\n\t\t\tif(comparatorLabel.equals(\"equals\")) {\n\t\t\t\top=ComparisonOperation.EQ;\n\t\t\t}else if (comparatorLabel.equals(\"ilike\")) {\n\t\t\t\top=ComparisonOperation.ILIKE;\n\t\t\t}else if (comparatorLabel.equals(\"like\")) {\n\t\t\t\top=ComparisonOperation.LIKE;\n\t\t\t}else if (comparatorLabel.equals(\"gt\")) {\n\t\t\t\top=ComparisonOperation.GT;\n\t\t\t}else if (comparatorLabel.equals(\"lt\")) {\n\t\t\t\top=ComparisonOperation.LT;\n\t\t\t}else if (comparatorLabel.equals(\"ge\")) {\n\t\t\t\top=ComparisonOperation.GE;\n\t\t\t}else if (comparatorLabel.equals(\"le\")) {\n\t\t\t\top=ComparisonOperation.LE;\n\t\t\t}else if (comparatorLabel.equals(\"ne\")) {\n\t\t\t\top=ComparisonOperation.NE;\n\t\t\t} else if (comparatorLabel.equals(\"contains\")) {\n\t\t\t    op=ComparisonOperation.CONTAINS;\n\t\t\t}\n\t\t}\n\t\tBeanWrapper wrapper = new BeanWrapperImpl(objectClass);\n\t\twrapper.registerCustomEditor(java.util.Date.class, new ISO8601DateEditor());\n\t\t\n\t\tList<Criterion> criteriaList = new ArrayList<Criterion>();\n\t\t\n\t\tfor(String key: paramsCopy.keySet()) {\n\n\t\t    for (String stringValue : paramsCopy.get(key)) {\n    \t\t\tif(\"null\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNull(key));\n    \t\t\t} else if (\"notnull\".equals(stringValue)) {\n    \t\t\t\tcriteriaList.add(Restrictions.isNotNull(key));\n    \t\t\t} else {\n    \t\t\t\tObject thisValue=wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n    \t\t\t\tswitch(op) {\n    \t\t   \t\tcase EQ:\n    \t\t    \t\tcriteriaList.add(Restrictions.eq(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t  \t\tcase NE:\n    \t\t  \t\t    criteriaList.add(Restrictions.ne(key,thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase ILIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LIKE:\n    \t\t   \t\t    criteriaList.add(Restrictions.like(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GT:\n    \t\t   \t\t    criteriaList.add(Restrictions.gt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LT:\n    \t\t    \t\tcriteriaList.add(Restrictions.lt(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase GE:\n    \t\t    \t\tcriteriaList.add(Restrictions.ge(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase LE:\n    \t\t    \t\tcriteriaList.add(Restrictions.le(key, thisValue));\n    \t\t\t\t\tbreak;\n    \t\t   \t\tcase CONTAINS:\n    \t\t   \t\t    criteriaList.add(Restrictions.ilike(key, stringValue, MatchMode.ANYWHERE));\n    \t\t\t\t}\n    \t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (criteriaList.size() > 1 && matchType.equalsIgnoreCase(\"any\")) {\n\t\t    // OR everything\n\t\t    Criterion lhs = criteriaList.remove(0);\n\t\t    Criterion rhs = criteriaList.remove(0);\n\t            \n\t\t    Criterion or = Restrictions.or(lhs, rhs);\n\t\t    while (criteriaList.size() > 0) {\n\t\t        rhs = criteriaList.remove(0);\n\t\t        or = Restrictions.or(or, rhs);\n\t\t    }\n\t\t    \n\t\t    criteria.add(or);\n\t\t} else {\n\t\t    for (Criterion c : criteriaList) {\n\t\t        criteria.add(c);\n\t\t    }\n\t\t}\n\t}","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(criteria)));\n    }","id":3391,"modified_method":"@GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    @Transactional\n    public OnmsOutageCollection getOutages() {\n    \tMultivaluedMap<java.lang.String,java.lang.String> params=m_uriInfo.getQueryParameters();\n\t\tOnmsCriteria criteria=new OnmsCriteria(OnmsOutage.class);\n\n    \tsetLimitOffset(params, criteria);\n    \taddOrdering(params, criteria);\n    \taddFiltersToCriteria(params, criteria, OnmsOutage.class);\n\n    \treturn new OnmsOutageCollection(m_outageDao.findMatching(getDistinctIdCriteria(OnmsOutage.class, criteria)));\n    }","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<AegisType> getDependencies() {\n        Set<AegisType> deps = new HashSet<AegisType>();\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        for (QName name : inf.getAttributes()) {\n            deps.add(inf.getType(name));\n        }\n\n        for (QName name : inf.getElements()) {\n            if (inf.isExtension()\n                && inf.getPropertyDescriptorFromMappedName(name).getReadMethod().getDeclaringClass() != inf\n                    .getTypeClass()) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        /*\n         * Automagically add chain of superclasses if this is an an extension.\n         */\n        AegisType sooperType = getSuperType();\n        if (sooperType != null) {\n            deps.add(sooperType);\n        }\n\n        return deps;\n    }","id":3392,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<AegisType> getDependencies() {\n        Set<AegisType> deps = new HashSet<AegisType>();\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        for (QName name : inf.getAttributes()) {\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        for (QName name : inf.getElements()) {\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        /*\n         * Automagically add chain of superclasses if this is an an extension.\n         */\n        AegisType sooperType = getSuperType();\n        if (sooperType != null) {\n            deps.add(sooperType);\n        }\n\n        return deps;\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"private void writeObjectInternal(Object object, MessageWriter writer, Context context,\n                                     boolean wroteXsiType) throws DatabindingException {\n        if (object == null) {\n            return;\n        }\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        if (!wroteXsiType && object.getClass() == getTypeClass() && context.isWriteXsiTypes()) {\n            writer.writeXsiType(getSchemaType());\n        }\n\n        for (QName name : inf.getAttributes()) {\n\n            Object value = readProperty(object, name);\n            if (value != null) {\n                AegisType type = getType(inf, name);\n\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                MessageWriter cwriter = writer.getAttributeWriter(name);\n\n                type.writeObject(value, cwriter, context);\n\n                cwriter.close();\n            }\n        }\n\n        if (inf.isExtension()) {\n            AegisType t = getSuperType();\n            if (t != null) {\n                t.writeObject(object, writer, context);\n            }\n        }\n\n        for (QName name : inf.getElements()) {\n\n            if (inf.isExtension()\n                && inf.getPropertyDescriptorFromMappedName(name).getReadMethod().getDeclaringClass() != inf\n                    .getTypeClass()) {\n                continue;\n            }\n            Object value = readProperty(object, name);\n\n            AegisType defaultType = getType(inf, name);\n            AegisType type = TypeUtil.getWriteType(context.getGlobalContext(), value, defaultType);\n\n            // Write the value if it is not null.\n            if (value != null) {\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                writeElement(name, value, type, writer, context);\n            } else if (inf.isNillable(name)) {\n                MessageWriter cwriter = getWriter(writer, name, type);\n\n                // Write the xsi:nil if it is null.\n                cwriter.writeXsiNil();\n\n                cwriter.close();\n            }\n        }\n    }","id":3393,"modified_method":"private void writeObjectInternal(Object object, MessageWriter writer, Context context,\n                                     boolean wroteXsiType) throws DatabindingException {\n        if (object == null) {\n            return;\n        }\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        if (!wroteXsiType && object.getClass() == getTypeClass() && context.isWriteXsiTypes()) {\n            writer.writeXsiType(getSchemaType());\n        }\n\n        for (QName name : inf.getAttributes()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            Object value = readProperty(object, name);\n            if (value != null) {\n                AegisType type = getType(inf, name);\n\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                MessageWriter cwriter = writer.getAttributeWriter(name);\n\n                type.writeObject(value, cwriter, context);\n\n                cwriter.close();\n            }\n        }\n\n        if (inf.isExtension()) {\n            AegisType t = getSuperType();\n            if (t != null) {\n                t.writeObject(object, writer, context);\n            }\n        }\n\n        for (QName name : inf.getElements()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            Object value = readProperty(object, name);\n\n            AegisType defaultType = getType(inf, name);\n            AegisType type = TypeUtil.getWriteType(context.getGlobalContext(), value, defaultType);\n\n            // Write the value if it is not null.\n            if (value != null) {\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                writeElement(name, value, type, writer, context);\n            } else if (inf.isNillable(name)) {\n                MessageWriter cwriter = getWriter(writer, name, type);\n\n                // Write the xsi:nil if it is null.\n                cwriter.writeXsiNil();\n\n                cwriter.close();\n            }\n        }\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void writeSchema(XmlSchema root) {\n        BeanTypeInfo inf = getTypeInfo();\n        XmlSchemaComplexType complex = new XmlSchemaComplexType(root, true);\n        complex.setName(getSchemaType().getLocalPart());\n\n        AegisType sooperType = getSuperType();\n\n        /*\n         * See Java Virtual Machine specification:\n         * http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#75734\n         */\n        if (((inf.getTypeClass().getModifiers() & Modifier.ABSTRACT) != 0)\n            && !inf.getTypeClass().isInterface()) {\n            complex.setAbstract(true);\n        }\n\n        XmlSchemaSequence sequence = new XmlSchemaSequence();\n        /*\n         * Decide if we're going to extend another type. If we are going to defer, then make sure that we\n         * extend the type for our superclass.\n         */\n        boolean isExtension = inf.isExtension();\n\n        if (isExtension && sooperType != null) {\n            // if sooperType is null, things are confused.\n            XmlSchemaComplexContent content = new XmlSchemaComplexContent();\n            complex.setContentModel(content);\n            XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();\n            content.setContent(extension);\n            extension.setBaseTypeName(sooperType.getSchemaType());\n            extension.setParticle(sequence);\n        } else {\n            complex.setParticle(sequence);\n        }\n\n        boolean needXmime = false;\n        boolean needUtilityTypes = false;\n\n        // Write out schema for elements\n        for (QName name : inf.getElements()) {\n\n            if (isExtension) {\n                PropertyDescriptor pd = inf.getPropertyDescriptorFromMappedName(name);\n\n                // assert pd.getReadMethod() != null && pd.getWriteMethod() != null;\n\n                if (pd.getReadMethod().getDeclaringClass() != inf.getTypeClass()) {\n                    continue;\n                }\n            }\n\n            XmlSchemaElement element = new XmlSchemaElement(root, false);\n            element.setName(name.getLocalPart());\n            sequence.getItems().add(element);\n\n            AegisType type = getType(inf, name);\n            if (type.isFlatArray()) {\n                // ok, we need some tricks here\n                element.setMinOccurs(type.getMinOccurs());\n                element.setMaxOccurs(type.getMaxOccurs());\n                // for now, assume ArrayType. Look at lists or more general solutions later.\n                ArrayType aType = (ArrayType)type;\n                type = aType.getComponentType();\n                element.setNillable(type.isNillable());\n            } else {\n                if (AbstractTypeCreator.\n                    HTTP_CXF_APACHE_ORG_ARRAYS.equals(type.getSchemaType().getNamespaceURI())) {\n                    XmlSchemaUtils.addImportIfNeeded(root, AbstractTypeCreator.HTTP_CXF_APACHE_ORG_ARRAYS);\n                }\n            }\n            writeTypeReference(name, element, type, root);\n            needXmime |= type.usesXmime();\n            needUtilityTypes |= type.usesUtilityTypes();\n\n        }\n\n        if (needXmime) {\n            addXmimeToSchema(root);\n        }\n\n        if (needUtilityTypes) {\n            AegisContext.addUtilityTypesToSchema(root);\n        }\n\n        /**\n         * if future proof then add <xsd:any/> element\n         */\n        if (inf.isExtensibleElements()) {\n            XmlSchemaAny any = new XmlSchemaAny();\n            any.setMinOccurs(0);\n            any.setMaxOccurs(Long.MAX_VALUE);\n            sequence.getItems().add(any);\n        }\n\n        // Write out schema for attributes\n        for (QName name : inf.getAttributes()) {\n            XmlSchemaAttribute attribute = new XmlSchemaAttribute(root, false);\n            complex.getAttributes().add(attribute);\n            attribute.setName(name.getLocalPart());\n            AegisType type = getType(inf, name);\n            attribute.setSchemaTypeName(type.getSchemaType());\n            String ns = name.getNamespaceURI();\n            if (!ns.equals(root.getTargetNamespace())) {\n                XmlSchemaUtils.addImportIfNeeded(root, ns);\n            }\n        }\n\n        /**\n         * If extensible attributes then add <xsd:anyAttribute/>\n         */\n        if (inf.isExtensibleAttributes()) {\n            complex.setAnyAttribute(new XmlSchemaAnyAttribute());\n        }\n    }","id":3394,"modified_method":"@Override\n    public void writeSchema(XmlSchema root) {\n        BeanTypeInfo inf = getTypeInfo();\n        XmlSchemaComplexType complex = new XmlSchemaComplexType(root, true);\n        complex.setName(getSchemaType().getLocalPart());\n\n        AegisType sooperType = getSuperType();\n\n        /*\n         * See Java Virtual Machine specification:\n         * http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#75734\n         */\n        if (((inf.getTypeClass().getModifiers() & Modifier.ABSTRACT) != 0)\n            && !inf.getTypeClass().isInterface()) {\n            complex.setAbstract(true);\n        }\n\n        XmlSchemaSequence sequence = new XmlSchemaSequence();\n        /*\n         * Decide if we're going to extend another type. If we are going to defer, then make sure that we\n         * extend the type for our superclass.\n         */\n        boolean isExtension = inf.isExtension();\n\n        if (isExtension && sooperType != null) {\n            // if sooperType is null, things are confused.\n            XmlSchemaComplexContent content = new XmlSchemaComplexContent();\n            complex.setContentModel(content);\n            XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();\n            content.setContent(extension);\n            extension.setBaseTypeName(sooperType.getSchemaType());\n            extension.setParticle(sequence);\n        } else {\n            complex.setParticle(sequence);\n        }\n\n        boolean needXmime = false;\n        boolean needUtilityTypes = false;\n\n        // Write out schema for elements\n        for (QName name : inf.getElements()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            XmlSchemaElement element = new XmlSchemaElement(root, false);\n            element.setName(name.getLocalPart());\n            sequence.getItems().add(element);\n\n            AegisType type = getType(inf, name);\n            if (type.isFlatArray()) {\n                // ok, we need some tricks here\n                element.setMinOccurs(type.getMinOccurs());\n                element.setMaxOccurs(type.getMaxOccurs());\n                // for now, assume ArrayType. Look at lists or more general solutions later.\n                ArrayType aType = (ArrayType)type;\n                type = aType.getComponentType();\n                element.setNillable(type.isNillable());\n            } else {\n                if (AbstractTypeCreator.\n                    HTTP_CXF_APACHE_ORG_ARRAYS.equals(type.getSchemaType().getNamespaceURI())) {\n                    XmlSchemaUtils.addImportIfNeeded(root, AbstractTypeCreator.HTTP_CXF_APACHE_ORG_ARRAYS);\n                }\n            }\n            writeTypeReference(name, element, type, root);\n            needXmime |= type.usesXmime();\n            needUtilityTypes |= type.usesUtilityTypes();\n\n        }\n\n        if (needXmime) {\n            addXmimeToSchema(root);\n        }\n\n        if (needUtilityTypes) {\n            AegisContext.addUtilityTypesToSchema(root);\n        }\n\n        /**\n         * if future proof then add <xsd:any/> element\n         */\n        if (inf.isExtensibleElements()) {\n            XmlSchemaAny any = new XmlSchemaAny();\n            any.setMinOccurs(0);\n            any.setMaxOccurs(Long.MAX_VALUE);\n            sequence.getItems().add(any);\n        }\n\n        // Write out schema for attributes\n        for (QName name : inf.getAttributes()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            XmlSchemaAttribute attribute = new XmlSchemaAttribute(root, false);\n            complex.getAttributes().add(attribute);\n            attribute.setName(name.getLocalPart());\n            AegisType type = getType(inf, name);\n            attribute.setSchemaTypeName(type.getSchemaType());\n            String ns = name.getNamespaceURI();\n            if (!ns.equals(root.getTargetNamespace())) {\n                XmlSchemaUtils.addImportIfNeeded(root, ns);\n            }\n        }\n\n        /**\n         * If extensible attributes then add <xsd:anyAttribute/>\n         */\n        if (inf.isExtensibleAttributes()) {\n            complex.setAnyAttribute(new XmlSchemaAnyAttribute());\n        }\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testGenerateWsdl() throws Exception {\n        Document d = getWSDLDocument(\"InheritanceService\");\n\n        String types = \"//wsdl:types/xsd:schema/\";\n\n        // check for Employee as extension\n        String employeeType = types + \"xsd:complexType[@name='Employee']\";\n        assertValid(employeeType, d);\n        String extension = \"/xsd:complexContent/xsd:extension[@base='tns:AbstractUser']\";\n        assertValid(employeeType + extension, d);\n        assertValid(employeeType + extension + \"/xsd:sequence/xsd:element[@name='division']\", d);\n        // assertValid(\"count(\" + employeeType + extension +\n        // \"/xsd:sequence/*)=1\", d);\n\n        // check for BaseUser as abstract\n        String baseUserType = types + \"xsd:complexType[(@name='AbstractUser') and (@abstract='true')]\";\n        assertValid(baseUserType, d);\n        assertValid(baseUserType + \"/xsd:sequence/xsd:element[@name='name']\", d);\n        // assertValid(\"count(\" + baseUserType + \"/xsd:sequence/*)=1\", d);\n    }","id":3395,"modified_method":"@Test\n    public void testGenerateWsdl() throws Exception {\n        Document d = getWSDLDocument(\"InheritanceService\");\n\n        String types = \"//wsdl:types/xsd:schema/\";\n\n        // check for Employee as extension\n        String employeeType = types + \"xsd:complexType[@name='Employee']\";\n        assertValid(employeeType, d);\n        String extension = \"/xsd:complexContent/xsd:extension[@base='tns:AbstractUser']\";\n        assertValid(employeeType + extension, d);\n        assertValid(employeeType + extension + \"/xsd:sequence/xsd:element[@name='division']\", d);\n\n        // Check elements/attributes from abstract type are not in the extended type\n        assertInvalid(employeeType + extension + \"/xsd:sequence/xsd:element[@name='name']\", d);\n        assertInvalid(employeeType + \"/xsd:attribute[@name='nickname']\", d);\n\n        // check for BaseUser as abstract\n        String baseUserType = types + \"xsd:complexType[(@name='AbstractUser') and (@abstract='true')]\";\n        assertValid(baseUserType, d);\n        assertValid(baseUserType + \"/xsd:sequence/xsd:element[@name='name']\", d);\n        assertValid(baseUserType + \"/xsd:attribute[@name='nickname']\", d);\n        // assertValid(\"count(\" + baseUserType + \"/xsd:sequence/*)=1\", d);\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"public AbstractUser getEmployee() {\n        Employee e = new Employee();\n        e.setDivision(\"foo\");\n        e.setName(\"Dan D. Man\");\n        return e;\n    }","id":3396,"modified_method":"public AbstractUser getEmployee() {\n        Employee e = new Employee();\n        e.setDivision(\"foo\");\n        e.setName(\"Dan D. Man\");\n        e.setNickname(\"bar\");\n        return e;\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n  public void resetEditorFrom(AbstractFileType fileType) {\n    myFileTypeName.setText(fileType.getName());\n    myFileTypeDescr.setText(fileType.getDescription());\n\n    SyntaxTable table = fileType.getSyntaxTable();\n\n    if (table != null) {\n      myLineComment.setText(table.getLineComment());\n      myBlockCommentEnd.setText(table.getEndComment());\n      myBlockCommentStart.setText(table.getStartComment());\n      myHexPrefix.setText(table.getHexPrefix());\n      myNumPostfixes.setText(table.getNumPostfixChars());\n      myIgnoreCase.setSelected(table.isIgnoreCase());\n      myCommentAtLineStart.setSelected(table.lineCommentOnlyAtStart);\n\n      mySupportBraces.setSelected(table.isHasBraces());\n      mySupportBrackets.setSelected(table.isHasBrackets());\n      mySupportParens.setSelected(table.isHasParens());\n      mySupportEscapes.setSelected(table.isHasStringEscapes());\n\n      for (String s : sorted(table.getKeywords1())) {\n        myKeywordModels[0].addElement(s);\n      }\n      for (String s : sorted(table.getKeywords2())) {\n        myKeywordModels[1].addElement(s);\n      }\n      for (String s : sorted(table.getKeywords3())) {\n        myKeywordModels[2].addElement(s);\n      }\n      for (String s : sorted(table.getKeywords4())) {\n        myKeywordModels[3].addElement(s);\n      }\n    }\n  }","id":3397,"modified_method":"@Override\n  public void resetEditorFrom(AbstractFileType fileType) {\n    myFileTypeName.setText(fileType.getName());\n    myFileTypeDescr.setText(fileType.getDescription());\n\n    SyntaxTable table = fileType.getSyntaxTable();\n\n    if (table != null) {\n      myLineComment.setText(table.getLineComment());\n      myBlockCommentEnd.setText(table.getEndComment());\n      myBlockCommentStart.setText(table.getStartComment());\n      myHexPrefix.setText(table.getHexPrefix());\n      myNumPostfixes.setText(table.getNumPostfixChars());\n      myIgnoreCase.setSelected(table.isIgnoreCase());\n      myCommentAtLineStart.setSelected(table.lineCommentOnlyAtStart);\n\n      mySupportBraces.setSelected(table.isHasBraces());\n      mySupportBrackets.setSelected(table.isHasBrackets());\n      mySupportParens.setSelected(table.isHasParens());\n      mySupportEscapes.setSelected(table.isHasStringEscapes());\n\n      table.getKeywords1().stream().sorted().forEach(s -> myKeywordModels[0].addElement(s));\n      table.getKeywords2().stream().sorted().forEach(s -> myKeywordModels[1].addElement(s));\n      table.getKeywords3().stream().sorted().forEach(s -> myKeywordModels[2].addElement(s));\n      table.getKeywords4().stream().sorted().forEach(s -> myKeywordModels[3].addElement(s));\n    }\n  }","commit_id":"461534c91683fafbf84d41e8c914748ec076b8a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static final String buildMessage(String phaseName, String msg, ShardSearchFailure[] shardFailures) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Failed to execute phase [\").append(phaseName).append(\"], \").append(msg);\n        if (shardFailures != null && shardFailures.length > 0) {\n            sb.append(\"; shardFailures \");\n            for (ShardSearchFailure shardFailure : shardFailures) {\n                sb.append(\"{\").append(shardFailure.shard()).append(\": \").append(shardFailure.reason()).append(\"}\");\n            }\n        }\n        return sb.toString();\n    }","id":3398,"modified_method":"private static String buildMessage(String phaseName, String msg, ShardSearchFailure[] shardFailures) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Failed to execute phase [\").append(phaseName).append(\"], \").append(msg);\n        if (shardFailures != null && shardFailures.length > 0) {\n            sb.append(\"; shardFailures \");\n            for (ShardSearchFailure shardFailure : shardFailures) {\n                if (shardFailure.shard() != null) {\n                    sb.append(\"{\").append(shardFailure.shard()).append(\": \").append(shardFailure.reason()).append(\"}\");\n                } else {\n                    sb.append(\"{\").append(shardFailure.reason()).append(\"}\");\n                }\n            }\n        }\n        return sb.toString();\n    }","commit_id":"ba725f8986463d41d14fd331b82702ab65a2e87e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public String toString() {\n        return \"[\" + nodeId + \"][\" + index + \"][\" + shardId + \"]\";\n    }","id":3399,"modified_method":"@Override public String toString() {\n        if (nodeId == null) {\n            return \"[_na_][\" + index + \"][\" + shardId + \"]\";\n        }\n        return \"[\" + nodeId + \"][\" + index + \"][\" + shardId + \"]\";\n    }","commit_id":"ba725f8986463d41d14fd331b82702ab65a2e87e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void readFrom(StreamInput in) throws IOException {\n        nodeId = in.readUTF();\n        index = in.readUTF();\n        shardId = in.readVInt();\n    }","id":3400,"modified_method":"@Override public void readFrom(StreamInput in) throws IOException {\n        if (in.readBoolean()) {\n            nodeId = in.readUTF();\n        }\n        index = in.readUTF();\n        shardId = in.readVInt();\n    }","commit_id":"ba725f8986463d41d14fd331b82702ab65a2e87e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        out.writeUTF(nodeId);\n        out.writeUTF(index);\n        out.writeVInt(shardId);\n    }","id":3401,"modified_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        if (nodeId == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(nodeId);\n        }\n        out.writeUTF(index);\n        out.writeVInt(shardId);\n    }","commit_id":"ba725f8986463d41d14fd331b82702ab65a2e87e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testSnapshotOperations() throws Exception {\n        server(\"server1\").start();\n\n        // Translog tests\n\n        logger.info(\"Creating index [{}]\", \"test\");\n        client(\"server1\").admin().indices().create(createIndexRequest(\"test\")).actionGet();\n        // create two and delete the first\n        logger.info(\"Indexing #1\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        logger.info(\"Indexing #2\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"2\").source(source(\"2\", \"test\"))).actionGet();\n        logger.info(\"Deleting #1\");\n        client(\"server1\").delete(deleteRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n\n        // perform snapshot to the index\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        // do it again, it should be a no op\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (only translog should be populated)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        GetResponse getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.empty(), equalTo(true));\n        logger.info(\"Getting #2\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n\n        // Now flush and add some data (so we have index recovery as well)\n        logger.info(\"Flushing, so we have actual content in the index files (#2 should be in the index)\");\n        client(\"server1\").admin().indices().flush(flushRequest(\"test\")).actionGet();\n        logger.info(\"Indexing #3, so we have something in the translog as well\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"3\").source(source(\"3\", \"test\"))).actionGet();\n\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (both index and translog)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.empty(), equalTo(true));\n        logger.info(\"Getting #2 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        logger.info(\"Getting #3 (from the translog)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"3\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"3\", \"test\")));\n\n        logger.info(\"Flushing, so we have actual content in the index files (#3 should be in the index now as well)\");\n        client(\"server1\").admin().indices().flush(flushRequest(\"test\")).actionGet();\n\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (just from the index, nothing in the translog)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.empty(), equalTo(true));\n        logger.info(\"Getting #2 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        logger.info(\"Getting #3 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"3\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"3\", \"test\")));\n    }","id":3402,"modified_method":"@Test public void testSnapshotOperations() throws Exception {\n        server(\"server1\").start();\n\n        // Translog tests\n\n        logger.info(\"Creating index [{}]\", \"test\");\n        client(\"server1\").admin().indices().create(createIndexRequest(\"test\")).actionGet();\n        // create two and delete the first\n        logger.info(\"Indexing #1\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        logger.info(\"Indexing #2\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"2\").source(source(\"2\", \"test\"))).actionGet();\n        logger.info(\"Deleting #1\");\n        client(\"server1\").delete(deleteRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n\n        // perform snapshot to the index\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        // do it again, it should be a no op\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (only translog should be populated)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        GetResponse getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.exists(), equalTo(true));\n        logger.info(\"Getting #2\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n\n        // Now flush and add some data (so we have index recovery as well)\n        logger.info(\"Flushing, so we have actual content in the index files (#2 should be in the index)\");\n        client(\"server1\").admin().indices().flush(flushRequest(\"test\")).actionGet();\n        logger.info(\"Indexing #3, so we have something in the translog as well\");\n        client(\"server1\").index(Requests.indexRequest(\"test\").type(\"type1\").id(\"3\").source(source(\"3\", \"test\"))).actionGet();\n\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (both index and translog)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.exists(), equalTo(true));\n        logger.info(\"Getting #2 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        logger.info(\"Getting #3 (from the translog)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"3\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"3\", \"test\")));\n\n        logger.info(\"Flushing, so we have actual content in the index files (#3 should be in the index now as well)\");\n        client(\"server1\").admin().indices().flush(flushRequest(\"test\")).actionGet();\n\n        logger.info(\"Gateway Snapshot\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n        logger.info(\"Gateway Snapshot (should be a no op)\");\n        client(\"server1\").admin().indices().gatewaySnapshot(gatewaySnapshotRequest(\"test\")).actionGet();\n\n        logger.info(\"Closing the server\");\n        closeServer(\"server1\");\n        Thread.sleep(500);\n        logger.info(\"Starting the server, should recover from the gateway (just from the index, nothing in the translog)\");\n        startServer(\"server1\");\n        Thread.sleep(1000);\n\n        logger.info(\"Getting #1, should not exists\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(getResponse.exists(), equalTo(true));\n        logger.info(\"Getting #2 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        logger.info(\"Getting #3 (not from the translog, but from the index)\");\n        getResponse = client(\"server1\").get(getRequest(\"test\").type(\"type1\").id(\"3\")).actionGet();\n        assertThat(getResponse.sourceAsString(), equalTo(source(\"3\", \"test\")));\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testIndexActions() throws Exception {\n        logger.info(\"Creating index test\");\n        client1.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n        logger.info(\"Running Cluster Health\");\n        ClusterHealthResponse clusterHealth = client1.admin().cluster().health(clusterHealth().waitForGreenStatus()).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.GREEN));\n\n        logger.info(\"Indexing [type1/1]\");\n        IndexResponse indexResponse = client1.index(indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        assertThat(indexResponse.id(), equalTo(\"1\"));\n        assertThat(indexResponse.type(), equalTo(\"type1\"));\n        logger.info(\"Refreshing\");\n        RefreshResponse refreshResponse = client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n        assertThat(refreshResponse.successfulShards(), equalTo(10));\n        assertThat(refreshResponse.failedShards(), equalTo(0));\n\n        logger.info(\"Optimizing\");\n        OptimizeResponse optimizeResponse = client1.admin().indices().optimize(optimizeRequest(\"test\")).actionGet();\n        assertThat(optimizeResponse.successfulShards(), equalTo(10));\n        assertThat(optimizeResponse.failedShards(), equalTo(0));\n\n        GetResponse getResult;\n\n        logger.info(\"Get [type1/1]\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\").threadedOperation(false)).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\").threadedOperation(true)).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n        }\n\n        logger.info(\"Get [type1/2] (should be empty)\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(getResult.empty(), equalTo(true));\n        }\n\n        logger.info(\"Delete [type1/1]\");\n        DeleteResponse deleteResponse = client1.delete(deleteRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(deleteResponse.id(), equalTo(\"1\"));\n        assertThat(deleteResponse.type(), equalTo(\"type1\"));\n        logger.info(\"Refreshing\");\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] (should be empty)\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(getResult.empty(), equalTo(true));\n        }\n\n        logger.info(\"Index [type1/1]\");\n        client1.index(indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        logger.info(\"Index [type1/2]\");\n        client1.index(indexRequest(\"test\").type(\"type1\").id(\"2\").source(source(\"2\", \"test\"))).actionGet();\n\n        logger.info(\"Flushing\");\n        FlushResponse flushResult = client1.admin().indices().flush(flushRequest(\"test\")).actionGet();\n        assertThat(flushResult.successfulShards(), equalTo(10));\n        assertThat(flushResult.failedShards(), equalTo(0));\n        logger.info(\"Refreshing\");\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] and [type1/2]\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        }\n\n        logger.info(\"Count\");\n        // check count\n        for (int i = 0; i < 5; i++) {\n            // test successful\n            CountResponse countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.NO_THREADS)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.SINGLE_THREAD)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.THREAD_PER_SHARD)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            // test failed (simply query that can't be parsed)\n            countResponse = client1.count(countRequest(\"test\").querySource(Unicode.fromStringAsBytes(\"{ term : { _type : \\\"type1 } }\"))).actionGet();\n\n            assertThat(countResponse.count(), equalTo(0l));\n            assertThat(countResponse.successfulShards(), equalTo(0));\n            assertThat(countResponse.failedShards(), equalTo(5));\n        }\n\n        logger.info(\"Delete by query\");\n        DeleteByQueryResponse queryResponse = client2.deleteByQuery(deleteByQueryRequest(\"test\").querySource(termQuery(\"name\", \"test2\"))).actionGet();\n        assertThat(queryResponse.index(\"test\").successfulShards(), equalTo(5));\n        assertThat(queryResponse.index(\"test\").failedShards(), equalTo(0));\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] and [type1/2], should be empty\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.empty(), equalTo(false));\n        }\n    }","id":3403,"modified_method":"@Test public void testIndexActions() throws Exception {\n        logger.info(\"Creating index test\");\n        client1.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n        logger.info(\"Running Cluster Health\");\n        ClusterHealthResponse clusterHealth = client1.admin().cluster().health(clusterHealth().waitForGreenStatus()).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.GREEN));\n\n        logger.info(\"Indexing [type1/1]\");\n        IndexResponse indexResponse = client1.index(indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        assertThat(indexResponse.id(), equalTo(\"1\"));\n        assertThat(indexResponse.type(), equalTo(\"type1\"));\n        logger.info(\"Refreshing\");\n        RefreshResponse refreshResponse = client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n        assertThat(refreshResponse.successfulShards(), equalTo(10));\n        assertThat(refreshResponse.failedShards(), equalTo(0));\n\n        logger.info(\"Optimizing\");\n        OptimizeResponse optimizeResponse = client1.admin().indices().optimize(optimizeRequest(\"test\")).actionGet();\n        assertThat(optimizeResponse.successfulShards(), equalTo(10));\n        assertThat(optimizeResponse.failedShards(), equalTo(0));\n\n        GetResponse getResult;\n\n        logger.info(\"Get [type1/1]\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\").threadedOperation(false)).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\").threadedOperation(true)).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n        }\n\n        logger.info(\"Get [type1/2] (should be empty)\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(getResult.exists(), equalTo(true));\n        }\n\n        logger.info(\"Delete [type1/1]\");\n        DeleteResponse deleteResponse = client1.delete(deleteRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n        assertThat(deleteResponse.id(), equalTo(\"1\"));\n        assertThat(deleteResponse.type(), equalTo(\"type1\"));\n        logger.info(\"Refreshing\");\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] (should be empty)\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(getResult.exists(), equalTo(true));\n        }\n\n        logger.info(\"Index [type1/1]\");\n        client1.index(indexRequest(\"test\").type(\"type1\").id(\"1\").source(source(\"1\", \"test\"))).actionGet();\n        logger.info(\"Index [type1/2]\");\n        client1.index(indexRequest(\"test\").type(\"type1\").id(\"2\").source(source(\"2\", \"test\"))).actionGet();\n\n        logger.info(\"Flushing\");\n        FlushResponse flushResult = client1.admin().indices().flush(flushRequest(\"test\")).actionGet();\n        assertThat(flushResult.successfulShards(), equalTo(10));\n        assertThat(flushResult.failedShards(), equalTo(0));\n        logger.info(\"Refreshing\");\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] and [type1/2]\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"2\", \"test\")));\n        }\n\n        logger.info(\"Count\");\n        // check count\n        for (int i = 0; i < 5; i++) {\n            // test successful\n            CountResponse countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.NO_THREADS)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.SINGLE_THREAD)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            countResponse = client1.count(countRequest(\"test\").querySource(termQuery(\"_type\", \"type1\")).operationThreading(BroadcastOperationThreading.THREAD_PER_SHARD)).actionGet();\n            assertThat(countResponse.count(), equalTo(2l));\n            assertThat(countResponse.successfulShards(), equalTo(5));\n            assertThat(countResponse.failedShards(), equalTo(0));\n\n            // test failed (simply query that can't be parsed)\n            countResponse = client1.count(countRequest(\"test\").querySource(Unicode.fromStringAsBytes(\"{ term : { _type : \\\"type1 } }\"))).actionGet();\n\n            assertThat(countResponse.count(), equalTo(0l));\n            assertThat(countResponse.successfulShards(), equalTo(0));\n            assertThat(countResponse.failedShards(), equalTo(5));\n        }\n\n        logger.info(\"Delete by query\");\n        DeleteByQueryResponse queryResponse = client2.deleteByQuery(deleteByQueryRequest(\"test\").querySource(termQuery(\"name\", \"test2\"))).actionGet();\n        assertThat(queryResponse.index(\"test\").successfulShards(), equalTo(5));\n        assertThat(queryResponse.index(\"test\").failedShards(), equalTo(0));\n        client1.admin().indices().refresh(refreshRequest(\"test\")).actionGet();\n\n        logger.info(\"Get [type1/1] and [type1/2], should be empty\");\n        for (int i = 0; i < 5; i++) {\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"1\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.sourceAsString(), equalTo(source(\"1\", \"test\")));\n            getResult = client1.get(getRequest(\"test\").type(\"type1\").id(\"2\")).actionGet();\n            assertThat(\"cycle #\" + i, getResult.exists(), equalTo(false));\n        }\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public GetRequest threadedOperation(boolean threadedOperation) {\n        super.threadedOperation(threadedOperation);\n        return this;\n    }","id":3404,"modified_method":"/**\n     * Controls if the operation will be executed on a separate thread when executed locally.\n     */\n    @Override public GetRequest threadedOperation(boolean threadedOperation) {\n        super.threadedOperation(threadedOperation);\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetRequest(String index) {\n        super(index, null, null);\n    }","id":3405,"modified_method":"/**\n     * Constructs a new get request against the specified index. The {@link #type(String)} and {@link #id(String)}\n     * must be set.\n     */\n    public GetRequest(String index) {\n        super(index, null, null);\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public GetRequest type(String type) {\n        this.type = type;\n        return this;\n    }","id":3406,"modified_method":"/**\n     * Sets the type of the document to fetch.\n     */\n    @Required public GetRequest type(String type) {\n        this.type = type;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetRequest(String index, String type, String id) {\n        super(index, type, id);\n    }","id":3407,"modified_method":"/**\n     * Constructs a new get request against the specified index with the type and id.\n     *\n     * @param index The index to get the document from\n     * @param type  The type of the document\n     * @param id    The id of the document\n     */\n    public GetRequest(String index, String type, String id) {\n        super(index, type, id);\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public GetRequest listenerThreaded(boolean threadedListener) {\n        super.listenerThreaded(threadedListener);\n        return this;\n    }","id":3408,"modified_method":"/**\n     * Should the listener be called on a separate thread if needed.\n     */\n    @Override public GetRequest listenerThreaded(boolean threadedListener) {\n        super.listenerThreaded(threadedListener);\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public GetRequest id(String id) {\n        this.id = id;\n        return this;\n    }","id":3409,"modified_method":"/**\n     * Sets the id of the document to fetch.\n     */\n    @Required public GetRequest id(String id) {\n        this.id = id;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String sourceAsString() {\n        return Unicode.fromBytes(source);\n    }","id":3410,"modified_method":"/**\n     * The source of the document (as a string).\n     */\n    public String sourceAsString() {\n        return Unicode.fromBytes(source);\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String type() {\n        return type;\n    }","id":3411,"modified_method":"/**\n     * The type of the document.\n     */\n    public String type() {\n        return type;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String id() {\n        return id;\n    }","id":3412,"modified_method":"/**\n     * The id of the document.\n     */\n    public String id() {\n        return id;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetResponse() {\n    }","id":3413,"modified_method":"GetResponse() {\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public byte[] source() {\n        return this.source;\n    }","id":3414,"modified_method":"/**\n     * The source of the document if exists.\n     */\n    public byte[] source() {\n        return this.source;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String index() {\n        return this.index;\n    }","id":3415,"modified_method":"/**\n     * The index the document was fetched from.\n     */\n    public String index() {\n        return this.index;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetResponse(String index, String type, String id, byte[] source) {\n        this.index = index;\n        this.type = type;\n        this.id = id;\n        this.source = source;\n    }","id":3416,"modified_method":"GetResponse(String index, String type, String id, byte[] source) {\n        this.index = index;\n        this.type = type;\n        this.id = id;\n        this.source = source;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public IndexRequest source(String source) {\n        this.source = Unicode.fromStringAsBytes(source);\n        return this;\n    }","id":3417,"modified_method":"/**\n     * Sets the JSON source to index.\n     *\n     * <p>Note, its preferable to either set it using {@link #source(org.elasticsearch.util.json.JsonBuilder)}\n     * or using the {@link #source(byte[])}.\n     */\n    @Required public IndexRequest source(String source) {\n        this.source = Unicode.fromStringAsBytes(source);\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void readFrom(DataInput in) throws IOException, ClassNotFoundException {\n        super.readFrom(in);\n        type = in.readUTF();\n        id = in.readUTF();\n        source = new byte[in.readInt()];\n        in.readFully(source, 0, source.length);\n        opType = OpType.fromId(in.readByte());\n    }","id":3418,"modified_method":"@Override public void readFrom(DataInput in) throws IOException, ClassNotFoundException {\n        super.readFrom(in);\n        type = in.readUTF();\n        if (in.readBoolean()) {\n            id = in.readUTF();\n        }\n        source = new byte[in.readInt()];\n        in.readFully(source, 0, source.length);\n        opType = OpType.fromId(in.readByte());\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void writeTo(DataOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeUTF(type);\n        out.writeUTF(id);\n        out.writeInt(source.length);\n        out.write(source);\n        out.writeByte(opType.id());\n    }","id":3419,"modified_method":"@Override public void writeTo(DataOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeUTF(type);\n        if (id == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(id);\n        }\n        out.writeInt(source.length);\n        out.write(source);\n        out.writeByte(opType.id());\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexRequest timeout(TimeValue timeout) {\n        this.timeout = timeout;\n        return this;\n    }","id":3420,"modified_method":"/**\n     * A timeout to wait if the index operation can't be performed immediately. Defaults to <tt>1m<\/tt>.\n     */\n    public IndexRequest timeout(TimeValue timeout) {\n        this.timeout = timeout;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexRequest opType(OpType opType) {\n        this.opType = opType;\n        return this;\n    }","id":3421,"modified_method":"/**\n     * Sets the type of operation to perform.\n     */\n    public IndexRequest opType(OpType opType) {\n        this.opType = opType;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"String id() {\n        return id;\n    }","id":3422,"modified_method":"/**\n     * The id of the indexed document. If not set, will be automatically generated.\n     */\n    String id() {\n        return id;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public IndexRequest listenerThreaded(boolean threadedListener) {\n        super.listenerThreaded(threadedListener);\n        return this;\n    }","id":3423,"modified_method":"/**\n     * Should the listener be called on a separate thread if needed.\n     */\n    @Override public IndexRequest listenerThreaded(boolean threadedListener) {\n        super.listenerThreaded(threadedListener);\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"String type() {\n        return type;\n    }","id":3424,"modified_method":"/**\n     * The type of the indexed document.\n     */\n    String type() {\n        return type;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public IndexRequest operationThreaded(boolean threadedOperation) {\n        super.operationThreaded(threadedOperation);\n        return this;\n    }","id":3425,"modified_method":"/**\n     * Controls if the operation will be executed on a separate thread when executed locally.\n     */\n    @Override public IndexRequest operationThreaded(boolean threadedOperation) {\n        super.operationThreaded(threadedOperation);\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public IndexRequest source(JsonBuilder jsonBuilder) {\n        try {\n            jsonBuilder.flush();\n            return source(jsonBuilder.copiedBytes());\n        } catch (IOException e) {\n            throw new ElasticSearchIllegalArgumentException(\"Failed to build json for index request\", e);\n        }\n    }","id":3426,"modified_method":"/**\n     * Sets the JSON source to index.\n     */\n    @Required public IndexRequest source(JsonBuilder jsonBuilder) {\n        try {\n            jsonBuilder.flush();\n            return source(jsonBuilder.copiedBytes());\n        } catch (IOException e) {\n            throw new ElasticSearchIllegalArgumentException(\"Failed to build json for index request\", e);\n        }\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexRequest(String index) {\n        this.index = index;\n    }","id":3427,"modified_method":"/**\n     * Constructs a new index request against the specific index. The {@link #type(String)},\n     * {@link #id(String)} and {@link #source(byte[])} must be set.\n     */\n    public IndexRequest(String index) {\n        this.index = index;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public OpType opType() {\n        return this.opType;\n    }","id":3428,"modified_method":"/**\n     * The type of operation to perform.\n     */\n    public OpType opType() {\n        return this.opType;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"byte[] source() {\n        return source;\n    }","id":3429,"modified_method":"/**\n     * The source of the JSON document to index.\n     */\n    byte[] source() {\n        return source;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexRequest(String index, String type, String id, byte[] source) {\n        this.index = index;\n        this.type = type;\n        this.id = id;\n        this.source = source;\n    }","id":3430,"modified_method":"/**\n     * Constructs a new index request against the index, type, id and using the source.\n     *\n     * @param index  The index to index into\n     * @param type   The type to index into\n     * @param id     The id of document\n     * @param source The JSON source document\n     */\n    public IndexRequest(String index, String type, String id, byte[] source) {\n        this.index = index;\n        this.type = type;\n        this.id = id;\n        this.source = source;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexRequest id(String id) {\n        this.id = id;\n        return this;\n    }","id":3431,"modified_method":"/**\n     * Sets the id of the indexed document. If not set, will be automatically generated.\n     */\n    public IndexRequest id(String id) {\n        this.id = id;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public IndexRequest type(String type) {\n        this.type = type;\n        return this;\n    }","id":3432,"modified_method":"/**\n     * Sets the type of the indexed document.\n     */\n    @Required public IndexRequest type(String type) {\n        this.type = type;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Required public IndexRequest source(byte[] source) {\n        this.source = source;\n        return this;\n    }","id":3433,"modified_method":"/**\n     * Sets the JSON source to index.\n     */\n    @Required public IndexRequest source(byte[] source) {\n        this.source = source;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexResponse(String index, String type, String id) {\n        this.index = index;\n        this.id = id;\n        this.type = type;\n    }","id":3434,"modified_method":"IndexResponse(String index, String type, String id) {\n        this.index = index;\n        this.id = id;\n        this.type = type;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexResponse() {\n\n    }","id":3435,"modified_method":"IndexResponse() {\n\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String type() {\n        return this.type;\n    }","id":3436,"modified_method":"/**\n     * The type of the document indexed.\n     */\n    public String type() {\n        return this.type;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String id() {\n        return this.id;\n    }","id":3437,"modified_method":"/**\n     * The id of the document indexed.\n     */\n    public String id() {\n        return this.id;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String index() {\n        return this.index;\n    }","id":3438,"modified_method":"/**\n     * The index the document was indexed into.\n     */\n    public String index() {\n        return this.index;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void handleRequest(final RestRequest request, final RestChannel channel) {\n        final GetRequest getRequest = new GetRequest(request.param(\"index\"), request.param(\"type\"), request.param(\"id\"));\n        // no need to have a threaded listener since we just send back a response\n        getRequest.listenerThreaded(false);\n        // if we have a local operation, execute it on a thread since we don't spawn\n        getRequest.threadedOperation(true);\n        client.execGet(getRequest, new ActionListener<GetResponse>() {\n            @Override public void onResponse(GetResponse result) {\n                try {\n                    if (result.empty()) {\n                        channel.sendResponse(new JsonRestResponse(request, NOT_FOUND));\n                    } else {\n                        JsonBuilder builder = restJsonBuilder(request);\n                        builder.startObject();\n                        builder.field(\"_index\", result.index());\n                        builder.field(\"_type\", result.type());\n                        builder.field(\"_id\", result.id());\n                        builder.raw(\", \\\"_source\\\" : \");\n                        builder.raw(result.source());\n                        builder.endObject();\n                        channel.sendResponse(new JsonRestResponse(request, OK, builder));\n                    }\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new JsonThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":3439,"modified_method":"@Override public void handleRequest(final RestRequest request, final RestChannel channel) {\n        final GetRequest getRequest = new GetRequest(request.param(\"index\"), request.param(\"type\"), request.param(\"id\"));\n        // no need to have a threaded listener since we just send back a response\n        getRequest.listenerThreaded(false);\n        // if we have a local operation, execute it on a thread since we don't spawn\n        getRequest.threadedOperation(true);\n        client.execGet(getRequest, new ActionListener<GetResponse>() {\n            @Override public void onResponse(GetResponse result) {\n                try {\n                    if (result.exists()) {\n                        channel.sendResponse(new JsonRestResponse(request, NOT_FOUND));\n                    } else {\n                        JsonBuilder builder = restJsonBuilder(request);\n                        builder.startObject();\n                        builder.field(\"_index\", result.index());\n                        builder.field(\"_type\", result.type());\n                        builder.field(\"_id\", result.id());\n                        builder.raw(\", \\\"_source\\\" : \");\n                        builder.raw(result.source());\n                        builder.endObject();\n                        channel.sendResponse(new JsonRestResponse(request, OK, builder));\n                    }\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new JsonThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public boolean listenerThreaded() {\n        return threadedListener;\n    }","id":3440,"modified_method":"/**\n     * Should the listener be called on a separate thread if needed.\n     */\n    @Override public boolean listenerThreaded() {\n        return threadedListener;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public ShardReplicationOperationRequest listenerThreaded(boolean threadedListener) {\n        this.threadedListener = threadedListener;\n        return this;\n    }","id":3441,"modified_method":"/**\n     * Should the listener be called on a separate thread if needed.\n     */\n    @Override public ShardReplicationOperationRequest listenerThreaded(boolean threadedListener) {\n        this.threadedListener = threadedListener;\n        return this;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public boolean listenerThreaded() {\n        return threadedListener;\n    }","id":3442,"modified_method":"/**\n     * Should the listener be called on a separate thread if needed.\n     */\n    @Override public boolean listenerThreaded() {\n        return threadedListener;\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override protected void doExecute(final MoreLikeThisRequest request, final ActionListener<SearchResponse> listener) {\n        GetRequest getRequest = getRequest(request.index())\n                .type(request.type())\n                .id(request.id())\n                .listenerThreaded(false);\n        getAction.execute(getRequest, new ActionListener<GetResponse>() {\n            @Override public void onResponse(GetResponse getResponse) {\n                if (getResponse.empty()) {\n                    listener.onFailure(new ElasticSearchException(\"document missing\"));\n                    return;\n                }\n                final BoolJsonQueryBuilder boolBuilder = boolQuery();\n                try {\n                    DocumentMapper docMapper = indicesService.indexServiceSafe(request.index()).mapperService().documentMapper(request.type());\n                    final Set<String> fields = Sets.newHashSet();\n                    if (request.fields() != null) {\n                        for (String field : request.fields()) {\n                            FieldMappers fieldMappers = docMapper.mappers().smartName(field);\n                            if (fieldMappers != null) {\n                                fields.add(fieldMappers.mapper().names().indexName());\n                            } else {\n                                fields.add(field);\n                            }\n                        }\n                    }\n                    docMapper.parse(request.type(), request.id(), getResponse.source(), new DocumentMapper.ParseListenerAdapter() {\n                        @Override public boolean beforeFieldAdded(FieldMapper fieldMapper, Fieldable field, Object parseContext) {\n                            if (fieldMapper instanceof InternalMapper) {\n                                return true;\n                            }\n                            String value = fieldMapper.valueAsString(field);\n                            if (value == null) {\n                                return false;\n                            }\n\n                            if (fields.isEmpty() || fields.contains(field.name())) {\n                                addMoreLikeThis(request, boolBuilder, fieldMapper, field);\n                            }\n\n                            return false;\n                        }\n                    });\n                    // exclude myself\n                    Term uidTerm = docMapper.uidMapper().term(request.type(), request.id());\n                    boolBuilder.mustNot(termQuery(uidTerm.field(), uidTerm.text()));\n                } catch (Exception e) {\n                    listener.onFailure(e);\n                }\n\n                String[] searchIndices = request.searchIndices();\n                if (searchIndices == null) {\n                    searchIndices = new String[]{request.index()};\n                }\n                String[] searchTypes = request.searchTypes();\n                if (searchTypes == null) {\n                    searchTypes = new String[]{request.type()};\n                }\n\n                SearchRequest searchRequest = searchRequest(searchIndices)\n                        .types(searchTypes)\n                        .searchType(request.searchType())\n                        .source(request.searchSource())\n                        .scroll(request.searchScroll())\n                        .extraSource(searchSource()\n                                .query(boolBuilder)\n                        )\n                        .listenerThreaded(request.listenerThreaded());\n                searchAction.execute(searchRequest, new ActionListener<SearchResponse>() {\n                    @Override public void onResponse(SearchResponse response) {\n                        listener.onResponse(response);\n                    }\n\n                    @Override public void onFailure(Throwable e) {\n                        listener.onFailure(e);\n                    }\n                });\n\n            }\n\n            @Override public void onFailure(Throwable e) {\n                listener.onFailure(e);\n            }\n        });\n    }","id":3443,"modified_method":"@Override protected void doExecute(final MoreLikeThisRequest request, final ActionListener<SearchResponse> listener) {\n        GetRequest getRequest = getRequest(request.index())\n                .type(request.type())\n                .id(request.id())\n                .listenerThreaded(false);\n        getAction.execute(getRequest, new ActionListener<GetResponse>() {\n            @Override public void onResponse(GetResponse getResponse) {\n                if (getResponse.exists()) {\n                    listener.onFailure(new ElasticSearchException(\"document missing\"));\n                    return;\n                }\n                final BoolJsonQueryBuilder boolBuilder = boolQuery();\n                try {\n                    DocumentMapper docMapper = indicesService.indexServiceSafe(request.index()).mapperService().documentMapper(request.type());\n                    final Set<String> fields = Sets.newHashSet();\n                    if (request.fields() != null) {\n                        for (String field : request.fields()) {\n                            FieldMappers fieldMappers = docMapper.mappers().smartName(field);\n                            if (fieldMappers != null) {\n                                fields.add(fieldMappers.mapper().names().indexName());\n                            } else {\n                                fields.add(field);\n                            }\n                        }\n                    }\n                    docMapper.parse(request.type(), request.id(), getResponse.source(), new DocumentMapper.ParseListenerAdapter() {\n                        @Override public boolean beforeFieldAdded(FieldMapper fieldMapper, Fieldable field, Object parseContext) {\n                            if (fieldMapper instanceof InternalMapper) {\n                                return true;\n                            }\n                            String value = fieldMapper.valueAsString(field);\n                            if (value == null) {\n                                return false;\n                            }\n\n                            if (fields.isEmpty() || fields.contains(field.name())) {\n                                addMoreLikeThis(request, boolBuilder, fieldMapper, field);\n                            }\n\n                            return false;\n                        }\n                    });\n                    // exclude myself\n                    Term uidTerm = docMapper.uidMapper().term(request.type(), request.id());\n                    boolBuilder.mustNot(termQuery(uidTerm.field(), uidTerm.text()));\n                } catch (Exception e) {\n                    listener.onFailure(e);\n                }\n\n                String[] searchIndices = request.searchIndices();\n                if (searchIndices == null) {\n                    searchIndices = new String[]{request.index()};\n                }\n                String[] searchTypes = request.searchTypes();\n                if (searchTypes == null) {\n                    searchTypes = new String[]{request.type()};\n                }\n\n                SearchRequest searchRequest = searchRequest(searchIndices)\n                        .types(searchTypes)\n                        .searchType(request.searchType())\n                        .source(request.searchSource())\n                        .scroll(request.searchScroll())\n                        .extraSource(searchSource()\n                                .query(boolBuilder)\n                        )\n                        .listenerThreaded(request.listenerThreaded());\n                searchAction.execute(searchRequest, new ActionListener<SearchResponse>() {\n                    @Override public void onResponse(SearchResponse response) {\n                        listener.onResponse(response);\n                    }\n\n                    @Override public void onFailure(Throwable e) {\n                        listener.onFailure(e);\n                    }\n                });\n\n            }\n\n            @Override public void onFailure(Throwable e) {\n                listener.onFailure(e);\n            }\n        });\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            sender=(Address)in.readObject();\n            id=in.readLong();\n            type=in.readByte();\n            my_digest=(Digest)in.readObject();\n            state_id=in.readUTF();\n        }","id":3444,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            sender=(Address)in.readObject();\n            id=in.readLong();\n            type=in.readByte();\n            my_digest=(Digest)in.readObject();\n            if(in.readBoolean())\n                state_id=in.readUTF();\n        }","commit_id":"93efa0ef46c41f8e4ebda2e451782b0aad89f0f5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            out.writeUTF(state_id);\n        }","id":3445,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            if(state_id == null) {\n                out.writeBoolean(false);\n            }\n            else {\n                out.writeBoolean(true);\n                out.writeUTF(state_id);\n            }\n        }","commit_id":"93efa0ef46c41f8e4ebda2e451782b0aad89f0f5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            out.writeUTF(state_id);\n        }","id":3446,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            if(state_id == null) {\n                out.writeBoolean(false);\n            }\n            else {\n                out.writeBoolean(true);\n                out.writeUTF(state_id);\n            }\n        }","commit_id":"82377374eaab68038ac7920b17b1cf235f0b7b10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            sender=(Address)in.readObject();\n            id=in.readLong();\n            type=in.readByte();\n            my_digest=(Digest)in.readObject();\n            state_id=in.readUTF();\n        }","id":3447,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            sender=(Address)in.readObject();\n            id=in.readLong();\n            type=in.readByte();\n            my_digest=(Digest)in.readObject();\n            if(in.readBoolean())\n                state_id=in.readUTF();\n        }","commit_id":"82377374eaab68038ac7920b17b1cf235f0b7b10","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Init watchlist store. Get all the jobs present in the wiki. Create the list of subscribers.\n     * \n     * @param context the XWiki context\n     * @throws XWikiException if the watchlist XWiki class creation fails\n     */\n    public void init(XWikiContext context) throws XWikiException\n    {\n        // Retreive jobs in the wiki, must be done first since initWatchListClass relies on them\n        jobDocumentNames =\n            context\n                .getWiki()\n                .getStore()\n                .searchDocumentsNames(\n                    \", BaseObject as obj where doc.fullName=obj.name and obj.className='\"\n                        + WatchListJobManager.WATCHLIST_JOB_CLASS + \"'\", context);\n\n        initWatchListClass(context);\n\n        for (String jobDocumentName : jobDocumentNames) {\n            initSubscribersCache(jobDocumentName, context);\n        }\n    }","id":3448,"modified_method":"/**\n     * Init watchlist store. Get all the jobs present in the wiki. Create the list of subscribers.\n     * \n     * @param context the XWiki context\n     * @throws XWikiException if the watchlist XWiki class creation fails\n     */\n    public void init(XWikiContext context) throws XWikiException\n    {\n        try {\n            final Query q =\n                context.getWiki().getStore().getQueryManager().getNamedQuery(\"getWatchlistJobDocuments\");\n            this.jobDocumentNames = (List<String>) (List) q.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(0, 0, \"Failed to run query for watchlist jobs.\", e);\n        }\n\n        initWatchListClass(context);\n\n        for (String jobDocumentName : jobDocumentNames) {\n            initSubscribersCache(jobDocumentName, context);\n        }\n    }","commit_id":"07eff72aa6c2c15906f831a5030f3ba941c988fd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Init watchlist store. Get all the jobs present in the wiki. Create the list of subscribers.\n     * \n     * @param context the XWiki context\n     * @throws XWikiException if the watchlist XWiki class creation fails\n     */\n    public void init(XWikiContext context) throws XWikiException\n    {\n        // Retreive jobs in the wiki, must be done first since initWatchListClass relies on them\n        jobDocumentNames =\n            context\n                .getWiki()\n                .getStore()\n                .searchDocumentsNames(\n                    \", BaseObject as obj where doc.fullName=obj.name and obj.className='\"\n                        + WatchListJobManager.WATCHLIST_JOB_CLASS + \"'\", context);\n\n        initWatchListClass(context);\n\n        for (String jobDocumentName : jobDocumentNames) {\n            initSubscribersCache(jobDocumentName, context);\n        }\n    }","id":3449,"modified_method":"/**\n     * Init watchlist store. Get all the jobs present in the wiki. Create the list of subscribers.\n     * \n     * @param context the XWiki context\n     * @throws XWikiException if the watchlist XWiki class creation fails\n     */\n    public void init(XWikiContext context) throws XWikiException\n    {\n        try {\n            final Query q =\n                context.getWiki().getStore().getQueryManager().getNamedQuery(\"getWatchlistJobDocuments\");\n            this.jobDocumentNames = (List<String>) (List) q.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(0, 0, \"Failed to run query for watchlist jobs.\", e);\n        }\n\n        initWatchListClass(context);\n\n        for (String jobDocumentName : jobDocumentNames) {\n            initSubscribersCache(jobDocumentName, context);\n        }\n    }","commit_id":"353368d06ac1369fbe77aee3ac5628077a663db9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @deprecated Use {@link #getAllMembersNamesForGroup(String, int, int, XWikiContext)}.\n     */\n    @Deprecated\n    public List<String> listMemberForGroup(String group, XWikiContext context) throws XWikiException\n    {\n        List<String> list = new ArrayList<String>();\n        String sql = \"\";\n\n        try {\n            if (group == null) {\n                if (context.getWiki().getHibernateStore() != null) {\n                    sql = \", BaseObject as obj where obj.name=doc.fullName and obj.className='XWiki.XWikiUsers'\";\n                    return context.getWiki().getStore().searchDocumentsNames(sql, context);\n                } else if (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\n                    String xpath = \"/*/*/obj/XWiki/XWikiUsers/jcr:deref(@doc, '*')/@fullName\";\n                    QueryPlugin qp = (QueryPlugin) context.getWiki().getPlugin(\"query\", context);\n                    return qp.xpath(xpath).list();\n                } else {\n                    return list;\n                }\n            } else {\n                String gshortname = Util.getName(group, context);\n                XWikiDocument docgroup = context.getWiki().getDocument(gshortname, context);\n\n                Vector<BaseObject> groups = docgroup.getObjects(\"XWiki.XWikiGroups\");\n                if (groups != null) {\n                    for (BaseObject bobj : groups) {\n                        if (bobj != null) {\n                            String members = bobj.getStringValue(FIELD_XWIKIGROUPS_MEMBER);\n                            if (members.length() > 0) {\n                                list.addAll(ListClass.getListFromString(members, \" ,\", false));\n                            }\n                        }\n                    }\n                }\n\n                return list;\n            }\n        } catch (XWikiException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }","id":3450,"modified_method":"/**\n     * @deprecated Use {@link #getAllMembersNamesForGroup(String, int, int, XWikiContext)}.\n     */\n    @Deprecated\n    public List<String> listMemberForGroup(String group, XWikiContext context) throws XWikiException\n    {\n        List<String> list = new ArrayList<String>();\n        String sql = \"\";\n\n        try {\n            if (group == null) {\n                return context.getWiki().getStore().getQueryManager().getNamedQuery(\"getAllUsers\").execute();\n            } else {\n                String gshortname = Util.getName(group, context);\n                XWikiDocument docgroup = context.getWiki().getDocument(gshortname, context);\n\n                Vector<BaseObject> groups = docgroup.getObjects(\"XWiki.XWikiGroups\");\n                if (groups != null) {\n                    for (BaseObject bobj : groups) {\n                        if (bobj != null) {\n                            String members = bobj.getStringValue(FIELD_XWIKIGROUPS_MEMBER);\n                            if (members.length() > 0) {\n                                list.addAll(ListClass.getListFromString(members, \" ,\", false));\n                            }\n                        }\n                    }\n                }\n\n                return list;\n            }\n        } catch (XWikiException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }","commit_id":"6d1ce5aaa7ac768e3ff87edf41090c5ca8e351a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @deprecated Use {@link #getAllMatchedGroups(Object[][], boolean, int, int, Object[][], XWikiContext)}.\n     */\n    @Deprecated\n    public List<String> listAllGroups(XWikiContext context) throws XWikiException\n    {\n        if (context.getWiki().getHibernateStore() != null) {\n            String sql = \", BaseObject as obj where obj.name=doc.fullName and obj.className='XWiki.XWikiGroups'\";\n            return context.getWiki().getStore().searchDocumentsNames(sql, context);\n        } else if (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\n            String xpath = \"/*/*/obj/XWiki/XWikiGroups/jcr:deref(@doc, '*')/@fullName\";\n            QueryPlugin qp = (QueryPlugin) context.getWiki().getPlugin(\"query\", context);\n            return qp.xpath(xpath).list();\n        } else {\n            return null;\n        }\n    }","id":3451,"modified_method":"/**\n     * @deprecated Use {@link #getAllMatchedGroups(Object[][], boolean, int, int, Object[][], XWikiContext)}.\n     */\n    @Deprecated\n    public List<String> listAllGroups(XWikiContext context) throws XWikiException\n    {\n        if (context.getWiki().getHibernateStore() != null) {\n            String sql = \", BaseObject as obj where obj.name=doc.fullName and obj.className='XWiki.XWikiGroups'\";\n            return context.getWiki().getStore().searchDocumentsNames(sql, context);\n        } else {\n            return null;\n        }\n    }","commit_id":"6d1ce5aaa7ac768e3ff87edf41090c5ca8e351a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Collection<String> listGroupsForUser(String username, XWikiContext context) throws XWikiException\n    {\n        List<String> list = null;\n\n        String database = context.getDatabase();\n        try {\n            String shortname = Util.getName(username);\n            String veryshortname = shortname.substring(shortname.indexOf(\".\") + 1);\n            String key = database + \":\" + shortname;\n            synchronized (key) {\n                if (this.groupCache == null) {\n                    initCache(context);\n                }\n\n                list = this.groupCache.get(key);\n\n                if (list == null) {\n                    if (context.getWiki().getNotCacheStore() instanceof XWikiHibernateStore) {\n                        list =\n                            context.getWiki().getStore().searchDocumentsNames(\n                                \", BaseObject as obj, StringProperty as prop \" + \"where obj.name=\"\n                                    + context.getWiki().getFullNameSQL() + \" and obj.className='XWiki.XWikiGroups' \"\n                                    + \"and obj.id = prop.id.id and prop.id.name='member' \" + \"and (prop.value='\"\n                                    + Utils.SQLFilter(username) + \"' or prop.value='\" + Utils.SQLFilter(shortname)\n                                    + \"' or prop.value='\" + Utils.SQLFilter(veryshortname) + \"')\", context);\n                    } else if (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\n                        list =\n                            ((XWikiJcrStore) context.getWiki().getNotCacheStore()).listGroupsForUser(username, context);\n                    }\n                    this.groupCache.set(key, list);\n                }\n            }\n\n            return list;\n        } finally {\n            context.setDatabase(database);\n        }\n    }","id":3452,"modified_method":"public Collection<String> listGroupsForUser(String username, XWikiContext context) throws XWikiException\n    {\n        List<String> list = null;\n\n        String database = context.getDatabase();\n        try {\n            String shortname = Util.getName(username);\n            String veryshortname = shortname.substring(shortname.indexOf(\".\") + 1);\n            String key = database + \":\" + shortname;\n            synchronized (key) {\n                if (this.groupCache == null) {\n                    initCache(context);\n                }\n\n                list = this.groupCache.get(key);\n\n                if (list == null) {\n                    list = context.getWiki().getStore().getQueryManager().getNamedQuery(\"listGroupsForUser\")\n                        .bindValue(\"username\", username)\n                        .bindValue(\"shortname\", shortname)\n                        .bindValue(\"veryshortname\", veryshortname)\n                        .execute();\n                    this.groupCache.set(key, list);\n                }\n            }\n\n            return list;\n        } finally {\n            context.setDatabase(database);\n        }\n    }","commit_id":"6d1ce5aaa7ac768e3ff87edf41090c5ca8e351a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for all users or group with provided constraints and in a provided order.\n     * \n     * @param user if true search for users, otherwise search for groups.\n     * @param matchFields the field to math with values. It is a table of table with :\n     *            <ul>\n     *            <li>fiedname : the name of the field<\/li>\n     *            <li>fieldtype : for example StringProperty. If null the field is considered as document field<\/li>\n     *            <li>pattern matching : based on HQL \"like\" command<\/li>\n     *            <\/ul>.\n     * @param withdetails indicate if a {@link List} containing {@link String} names is returned or {@link List}\n     *            containing {@link XWikiDocument}.\n     * @param nb the maximum number od result to return.\n     * @param start the index of the first found user or group to return.\n     * @param order the field to order from. It is a table of table with :\n     *            <ul>\n     *            <li>fieldname : the name of the field<\/li>\n     *            <li>fieldtype : for example StringProperty. If null the field is considered as document field<\/li>\n     *            <\/ul>\n     * @param context the {@link XWikiContext}.\n     * @return the list of users or groups.\n     * @throws XWikiException error when calling for\n     *             {@link XWikiStoreInterface#searchDocuments(String, int, int, List, XWikiContext)} or\n     *             {@link XWikiStoreInterface#searchDocumentsNames(String, int, int, List, XWikiContext)}\n     */\n    protected List getAllMatchedUsersOrGroups(boolean user, Object[][] matchFields, boolean withdetails, int nb,\n        int start, Object[][] order, XWikiContext context) throws XWikiException\n    {\n        List groups = null;\n\n        if (context.getWiki().getHibernateStore() != null) {\n            List<Object> parameterValues = new ArrayList<Object>();\n            String where = createWhereClause(user, matchFields, order, parameterValues);\n\n            if (withdetails) {\n                groups = context.getWiki().getStore().searchDocuments(where, nb, start, parameterValues, context);\n            } else {\n                groups = context.getWiki().getStore().searchDocumentsNames(where, nb, start, parameterValues, context);\n            }\n        } else if (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\n            // TODO : fully implement this methods for XPATH platform\n\n            if ((matchFields != null && matchFields.length > 0) || withdetails) {\n                throw new NotImplementedException();\n            }\n\n            String xpath =\n                \"/*/*/obj/XWiki/\" + (user ? CLASS_SUFFIX_XWIKIUSERS : CLASS_SUFFIX_XWIKIGROUPS)\n                    + \"/jcr:deref(@doc, '*')/@fullName\";\n            QueryPlugin qp = (QueryPlugin) context.getWiki().getPlugin(\"query\", context);\n            List list = qp.xpath(xpath).list();\n\n            if (nb > 0 || start > 0) {\n                int fromIndex = start < 0 ? 0 : start;\n                int toIndex = fromIndex + (nb <= 0 ? list.size() - 1 : nb);\n\n                list = list.subList(fromIndex, toIndex);\n            }\n\n            groups = list;\n        }\n\n        return groups;\n    }","id":3453,"modified_method":"/**\n     * Search for all users or group with provided constraints and in a provided order.\n     * \n     * @param user if true search for users, otherwise search for groups.\n     * @param matchFields the field to math with values. It is a table of table with :\n     *            <ul>\n     *            <li>fiedname : the name of the field<\/li>\n     *            <li>fieldtype : for example StringProperty. If null the field is considered as document field<\/li>\n     *            <li>pattern matching : based on HQL \"like\" command<\/li>\n     *            <\/ul>.\n     * @param withdetails indicate if a {@link List} containing {@link String} names is returned or {@link List}\n     *            containing {@link XWikiDocument}.\n     * @param nb the maximum number od result to return.\n     * @param start the index of the first found user or group to return.\n     * @param order the field to order from. It is a table of table with :\n     *            <ul>\n     *            <li>fieldname : the name of the field<\/li>\n     *            <li>fieldtype : for example StringProperty. If null the field is considered as document field<\/li>\n     *            <\/ul>\n     * @param context the {@link XWikiContext}.\n     * @return the list of users or groups.\n     * @throws XWikiException error when calling for\n     *             {@link XWikiStoreInterface#searchDocuments(String, int, int, List, XWikiContext)} or\n     *             {@link XWikiStoreInterface#searchDocumentsNames(String, int, int, List, XWikiContext)}\n     */\n    protected List getAllMatchedUsersOrGroups(boolean user, Object[][] matchFields, boolean withdetails, int nb,\n        int start, Object[][] order, XWikiContext context) throws XWikiException\n    {\n        List groups = null;\n\n        if (context.getWiki().getHibernateStore() != null) {\n            List<Object> parameterValues = new ArrayList<Object>();\n            String where = createWhereClause(user, matchFields, order, parameterValues);\n\n            if (withdetails) {\n                groups = context.getWiki().getStore().searchDocuments(where, nb, start, parameterValues, context);\n            } else {\n                groups = context.getWiki().getStore().searchDocumentsNames(where, nb, start, parameterValues, context);\n            }\n        } else if (context.getWiki().getStore().getQueryManager().hasLanguage(Query.XPATH)) {\n            // TODO : fully implement this methods for XPATH platform\n\n            if ((matchFields != null && matchFields.length > 0) || withdetails) {\n                throw new NotImplementedException();\n            }\n\n            groups = context.getWiki().getStore().getQueryManager().createQuery(\n                \"/*/*[obj/XWiki/\" + (user ? CLASS_SUFFIX_XWIKIUSERS : CLASS_SUFFIX_XWIKIGROUPS) + \"]/@fullName\", \n                Query.XPATH)\n                    .setLimit(nb).setOffset(start)\n                    .execute();\n        }\n\n        return groups;\n    }","commit_id":"6d1ce5aaa7ac768e3ff87edf41090c5ca8e351a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public PsiFile[] getFilesWithWord(String word, short occurenceMask, GlobalSearchScope scope, final boolean caseSensitively) {\n    List<PsiFile> files = new ArrayList<PsiFile>();\n    for (CacheManager cacheManager : myManagers) {\n      files.addAll(Arrays.asList(cacheManager.getFilesWithWord(word, occurenceMask, scope, caseSensitively)));\n    }\n    return files.toArray(new PsiFile[files.size()]);\n  }","id":3454,"modified_method":"public PsiFile[] getFilesWithWord(String word, short occurenceMask, GlobalSearchScope scope, final boolean caseSensitively) {\n    CommonProcessors.CollectProcessor<PsiFile> processor = new CommonProcessors.CollectProcessor<PsiFile>();\n    processFilesWithWord(processor, word, occurenceMask, scope, caseSensitively);\n    return processor.toArray(PsiFile.EMPTY_ARRAY);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPrefixByNamespace(String namespace) {\n    if (namespace.equals(XmlUtil.HTML_URI)) namespace = XmlUtil.XHTML_URI;\n    return super.getPrefixByNamespace(namespace);\n  }","id":3455,"modified_method":"public String getPrefixByNamespace(String namespace) {\n    if (XmlUtil.HTML_URI.equals(namespace)) namespace = XmlUtil.XHTML_URI;\n    return super.getPrefixByNamespace(namespace);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAllFilesWithWord(String word, GlobalSearchScope scope, Processor<PsiFile> processor, final boolean caseSensitively) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":3456,"modified_method":"public void processAllFilesWithWord(String word, GlobalSearchScope scope, Processor<PsiFile> processor, final boolean caseSensitively) {\n    myManager.getCacheManager().processFilesWithWord(processor,word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAllFilesWithWordInComments(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_COMMENTS, scope, true);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":3457,"modified_method":"public void processAllFilesWithWordInComments(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    myManager.getCacheManager().processFilesWithWord(processor, word, UsageSearchContext.IN_COMMENTS, scope, true);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAllFilesWithWordInLiterals(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_STRINGS, scope, true);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":3458,"modified_method":"public void processAllFilesWithWordInLiterals(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    myManager.getCacheManager().processFilesWithWord(processor, word, UsageSearchContext.IN_STRINGS, scope, true);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateless bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSLSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SLSBImplementingSessionBean slsb = (SLSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SLSBImplementingSessionBean.class.getSimpleName() + \"!\" + SLSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"SessionContext was not injectd in stateless bean\", slsb.wasSessionContextInjected());\n    }","id":3459,"modified_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateless bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSLSB() throws Exception {\n        final SLSBImplementingSessionBean slsb = lookup(SLSBImplementingSessionBean.class);\n        Assert.assertTrue(\"SessionContext was not injectd in stateless bean\", slsb.wasSessionContextInjected());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateful bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSFSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SFSBImplementingSessionBean sfsb = (SFSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SFSBImplementingSessionBean.class.getSimpleName() + \"!\" + SFSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"SessionContext was not injectd in stateful bean\", sfsb.wasSessionContextInjected());\n    }","id":3460,"modified_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateful bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSFSB() throws Exception {\n        final SFSBImplementingSessionBean sfsb = lookup(SFSBImplementingSessionBean.class);\n        Assert.assertTrue(\"SessionContext was not injectd in stateful bean\", sfsb.wasSessionContextInjected());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateful\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSFSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SFSBImplementingSessionBean sfsb = (SFSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SFSBImplementingSessionBean.class.getSimpleName() + \"!\" + SFSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateful bean implementing javax.ejb.SessionBean\", sfsb.wasSetSessionContextMethodInvoked());\n    }","id":3461,"modified_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateful\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSFSB() throws Exception {\n        final SFSBImplementingSessionBean sfsb = lookup(SFSBImplementingSessionBean.class);\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateful bean implementing javax.ejb.SessionBean\", \n                sfsb.wasSetSessionContextMethodInvoked());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateless\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSLSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SLSBImplementingSessionBean slsb = (SLSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SLSBImplementingSessionBean.class.getSimpleName() + \"!\" + SLSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateless bean implementing javax.ejb.SessionBean\", slsb.wasSetSessionContextMethodInvoked());\n    }","id":3462,"modified_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateless\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSLSB() throws Exception {\n        final SLSBImplementingSessionBean slsb = lookup(SLSBImplementingSessionBean.class);\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateless bean implementing javax.ejb.SessionBean\", \n                slsb.wasSetSessionContextMethodInvoked());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setFontType(MPSFonts.ITALIC);\n    editorCell.getTextLine().setTextColor(Color.darkGray);\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1170384687660\");\n    editorCell.setLayoutConstraint(\"\");\n    editorCell.putUserObject(EditorCell.ATTRACTS_FOCUS_POLICY, EditorCell.ATTRACTS_FOCUS);\n    return editorCell;\n  }","id":3463,"modified_method":"public EditorCell createConstantCell(EditorContext context, SNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1170384687660\");\n    editorCell.setLayoutConstraint(\"\");\n    editorCell.putUserObject(EditorCell.ATTRACTS_FOCUS_POLICY, EditorCell.ATTRACTS_FOCUS);\n    return editorCell;\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean checkAppliedCorrectly_generic(SNode op) {\n    List<String> applicables = new ArrayList<String>();\n    // ===========\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_model\")) {\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_46().createNode())) {\n        return true;\n      }\n      applicables.add(\"model\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_concept\")) {\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_47().createNode())) {\n        return true;\n      }\n      applicables.add(\"concept\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_node\")) {\n      // todo: get type of left expression and try to 'adapt' to snode\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_48().createNode())) {\n        return true;\n      }\n      applicables.add(\"node\");\n    }\n    // ===========\n    SNode leftExpression = RulesUtil.leftExpression(op);\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_link\")) {\n      SNode leftOp = SLinkOperations.getTarget(leftExpression, \"nodeOperation\", true);\n      if(SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(leftOp), \"jetbrains.mps.bootstrap.smodelLanguage.structure.SLinkAccess\")) {\n        return true;\n      }\n      applicables.add(\"link-access\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_linkList\")) {\n      SNode leftOp = SLinkOperations.getTarget(leftExpression, \"nodeOperation\", true);\n      if(SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(leftOp), \"jetbrains.mps.bootstrap.smodelLanguage.structure.SLinkListAccess\")) {\n        return true;\n      }\n      applicables.add(\"link-list-access\");\n    }\n    // ===========\n    String applicableTo = \"\";\n    Iterator<String> iter = applicables.iterator();\n    while(iter.hasNext()) {\n      applicableTo = applicableTo + iter.next();\n      if(iter.hasNext()) {\n        applicableTo = applicableTo + \",\";\n      }\n    }\n    TypeChecker.getInstance().reportTypeError(op, \"operation is only applicable to \" + applicableTo);\n    return false;\n  }","id":3464,"modified_method":"public static boolean checkAppliedCorrectly_generic(SNode op) {\n    List<String> applicables = new ArrayList<String>();\n    // ===========\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_model\")) {\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_46().createNode())) {\n        return true;\n      }\n      applicables.add(\"model\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_concept\")) {\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_47().createNode())) {\n        return true;\n      }\n      applicables.add(\"concept\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_node\")) {\n      // todo: get type of left expression and try to 'adapt' to snode\n      SNode leftType = RulesUtil.typeOf_leftExpression(op);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, new QuotationClass_48().createNode())) {\n        return true;\n      }\n      applicables.add(\"node\");\n    }\n    // ===========\n    SNode leftExpression = RulesUtil.leftExpression(op);\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_link\")) {\n      SNode leftOp = SLinkOperations.getTarget(leftExpression, \"nodeOperation\", true);\n      if(SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(leftOp), \"jetbrains.mps.bootstrap.smodelLanguage.structure.SLinkAccess\")) {\n        return true;\n      }\n      applicables.add(\"link-access\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_linkList\")) {\n      SNode leftOp = SLinkOperations.getTarget(leftExpression, \"nodeOperation\", true);\n      if(SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(leftOp), \"jetbrains.mps.bootstrap.smodelLanguage.structure.SLinkListAccess\")) {\n        return true;\n      }\n      applicables.add(\"link-list-access\");\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_simple_property\")) {\n      // ???\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_concept_property\")) {\n      // ???\n    }\n    if(SConceptPropertyOperations.getBoolean(op, \"applicable_to_enum_property\")) {\n      SNode leftOp = SLinkOperations.getTarget(leftExpression, \"nodeOperation\", true);\n      if(SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(leftOp), \"jetbrains.mps.bootstrap.smodelLanguage.structure.SPropertyAccess\")) {\n        SNode propertyDecl = SLinkOperations.getTarget(leftOp, \"property\", false);\n        if(DataTypeUtil.isEnum(((DataTypeDeclaration)SNodeOperations.getAdapter(SLinkOperations.getTarget(propertyDecl, \"dataType\", false))))) {\n          return true;\n        }\n      }\n      applicables.add(\"enum-property-access\");\n    }\n    // ===========\n    String applicableTo = \"\";\n    Iterator<String> iter = applicables.iterator();\n    while(iter.hasNext()) {\n      applicableTo = applicableTo + iter.next();\n      if(iter.hasNext()) {\n        applicableTo = applicableTo + \",\";\n      }\n    }\n    TypeChecker.getInstance().reportTypeError(op, \"operation is only applicable to \" + applicableTo);\n    return false;\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_24().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":3465,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_24().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"parameter\", true) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(SLinkOperations.getTarget(argument, \"parameter\", true));\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)) == null)))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)), new QuotationClass_25().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"incompatible type: snode expected\");\n      }\n    }\n  }","id":3466,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    SNode parameter = SLinkOperations.getTarget(argument, \"parameter\", true);\n    if(!((parameter == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(parameter);\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter) == null)))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter), new QuotationClass_25().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"incompatible type: snode expected\");\n      }\n    }\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"parameter\", true) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(SLinkOperations.getTarget(argument, \"parameter\", true));\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)) == null)))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)), new QuotationClass_26().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"incompatible type: snode expected\");\n      }\n    }\n  }","id":3467,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    SNode parameter = SLinkOperations.getTarget(argument, \"parameter\", true);\n    if(!((parameter == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(parameter);\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter) == null)))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter), new QuotationClass_26().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"incompatible type: snode expected\");\n      }\n    }\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"parameter\", true) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(SLinkOperations.getTarget(argument, \"parameter\", true));\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)) == null)))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(argument, \"parameter\", true)), new QuotationClass_28().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(SLinkOperations.getTarget(argument, \"parameter\", true), \"incompatible type: snode expected\");\n      }\n    }\n  }","id":3468,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    SNode parameter = SLinkOperations.getTarget(argument, \"parameter\", true);\n    if(!((parameter == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().check(parameter);\n      if(!(!((TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter) == null)))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"no type\");\n      }\n      if(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getRuntimeSupport().typeOf(parameter), new QuotationClass_28().createNode()))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"incompatible type: snode expected\");\n      }\n    }\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_27().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":3469,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_27().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_23().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":3470,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_23().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"de417424c372d0c98b52ceaee072bf257ec3c43a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     *\n     * @param channel channel info\n     * @return filelistxml for given channel\n     * @throws Exception exception\n     */\n    public String getFilelistsXml(Channel channel) throws Exception {\n        begin(channel);\n\n        Iterator iter = TaskManager.getChannelPackageDtoIterator(channel);\n        while (iter.hasNext()) {\n            addPackage((PackageDto) iter.next());\n        }\n\n        end();\n\n        return \"\";\n\n    }","id":3471,"modified_method":"/**\n     *\n     * @param channel channel info\n     * @return filelistxml for given channel\n     * @throws Exception exception\n     */\n    public String getFilelistsXml(Channel channel) throws Exception {\n        begin(channel);\n\n        for (PackageDto pkgDto : TaskManager.getChannelPackageDtos(channel)) {\n            addPackage(pkgDto);\n        }\n\n        end();\n\n        return \"\";\n\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     *\n     * @param channel channel info\n     * @return other.xml for given channel\n     * @throws Exception exception\n     */\n    public String getOtherXml(Channel channel) throws Exception {\n        begin(channel);\n\n        Iterator iter = TaskManager.getChannelPackageDtoIterator(channel);\n        while (iter.hasNext()) {\n            addPackage((PackageDto) iter.next());\n        }\n\n        end();\n\n        return \"\";\n\n    }","id":3472,"modified_method":"/**\n     *\n     * @param channel channel info\n     * @return other.xml for given channel\n     * @throws Exception exception\n     */\n    public String getOtherXml(Channel channel) throws Exception {\n        begin(channel);\n\n        for (PackageDto pkgDto : TaskManager.getChannelPackageDtos(channel)) {\n            addPackage(pkgDto);\n        }\n\n        end();\n\n        return \"\";\n\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     *\n     * @param channel channel info\n     * @return primaryXml for the given channel\n     * @throws Exception exception\n     */\n    public String getPrimaryXml(Channel channel) throws Exception {\n        begin(channel);\n\n        Iterator iter = TaskManager.getChannelPackageDtoIterator(channel);\n        while (iter.hasNext()) {\n            addPackage((PackageDto) iter.next());\n        }\n\n        end();\n\n        return \"\";\n    }","id":3473,"modified_method":"/**\n     *\n     * @param channel channel info\n     * @return primaryXml for the given channel\n     * @throws Exception exception\n     */\n    public String getPrimaryXml(Channel channel) throws Exception {\n        begin(channel);\n\n        for (PackageDto pkgDto : TaskManager.getChannelPackageDtos(channel)) {\n            addPackage(pkgDto);\n        }\n\n        end();\n\n        return \"\";\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     *\n     * @param channel channelinfo for repomd file creation\n     */\n    public void writeRepomdFiles(Channel channel) {\n\n        PackageManager.createRepoEntrys(channel.getId());\n\n        String prefix = mountPoint + File.separator + pathPrefix +\n        File.separator + channel.getLabel() + File.separator;\n\n        // we closed the session, so we need to reload the object\n        channel = (Channel) HibernateFactory.getSession().get(channel.getClass(),\n                channel.getId());\n        if (channel.getChannelArch().getArchType().getLabel().equalsIgnoreCase(\"deb\")) {\n            log.info(\"Generating new DEB repository for channel \" + channel.getLabel());\n            generateDebRepository(channel, prefix);\n        }\n        else {\n            if (!new File(prefix).mkdirs() && !new File(prefix).exists()) {\n                throw new RepomdRuntimeException(\"Unable to create directory: \" +\n                        prefix);\n            }\n            // Get compatible checksumType\n            this.checksumtype = channel.getChecksumTypeLabel();\n            if (checksumtype == null) {\n                log.warn(\"No repo will be generated for channel \" + channel.getLabel());\n                deleteRepomdFiles(channel.getLabel(), false);\n                try {\n                    FileWriter norepo = new FileWriter(prefix + NOREPO_FILE);\n                    norepo.write(\"No repo will be generated for channel \" + channel.getLabel() + \".\\n\");\n                    norepo.close();\n                }\n                catch (IOException e) {\n                    log.warn(\"Cannot create \" + NOREPO_FILE + \" file.\");\n                }\n                return;\n            }\n            new File(prefix + NOREPO_FILE).delete();\n            log.info(\"Checksum Type Value: \" + this.checksumtype);\n\n            // java.security.MessageDigest recognizes:\n            // MD2, MD5, SHA-1, SHA-256, SHA-384, SHA-512\n            String checksumAlgo = this.checksumtype;\n            if (checksumAlgo.toUpperCase().startsWith(\"SHA\")) {\n                checksumAlgo = this.checksumtype.substring(0, 3) + \"-\" +\n                this.checksumtype.substring(3);\n            }\n            // translate sha1 to sha for xml repo files\n            String checksumLabel = this.checksumtype;\n            if (checksumLabel.equals(\"sha1\")) {\n                checksumLabel = \"sha\";\n            }\n\n            log.info(\"Generating new repository metatada for channel '\" +\n                    channel.getLabel() + \"' \" + channel.getPackageCount() +\n                    \" packages, \" + channel.getErrataCount() + \" updates\");\n\n            CompressingDigestOutputWriter primaryFile;\n            CompressingDigestOutputWriter filelistsFile;\n            CompressingDigestOutputWriter otherFile;\n\n            try {\n                primaryFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + PRIMARY_FILE),\n                        checksumAlgo);\n                filelistsFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + FILELISTS_FILE),\n                        checksumAlgo);\n                otherFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + OTHER_FILE), checksumAlgo);\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n            catch (NoSuchAlgorithmException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            BufferedWriter primaryBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(primaryFile));\n            BufferedWriter filelistsBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(filelistsFile));\n            BufferedWriter otherBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(otherFile));\n            PrimaryXmlWriter primary = new PrimaryXmlWriter(\n                    primaryBufferedWriter);\n            FilelistsXmlWriter filelists = new FilelistsXmlWriter(\n                    filelistsBufferedWriter);\n            OtherXmlWriter other = new OtherXmlWriter(otherBufferedWriter);\n            Date start = new Date();\n\n            primary.begin(channel);\n            filelists.begin(channel);\n            other.begin(channel);\n\n            Iterator iter = TaskManager.getChannelPackageDtoIterator(channel);\n            while (iter.hasNext()) {\n                PackageDto pkgDto = (PackageDto) iter.next();\n                primary.addPackage(pkgDto);\n                filelists.addPackage(pkgDto);\n                other.addPackage(pkgDto);\n                try {\n                    primaryFile.flush();\n                    filelistsFile.flush();\n                    otherFile.flush();\n                }\n                catch (IOException e) {\n                    throw new RepomdRuntimeException(e);\n                }\n            }\n            primary.end();\n            filelists.end();\n            other.end();\n            try {\n                primaryBufferedWriter.close();\n                filelistsBufferedWriter.close();\n                otherBufferedWriter.close();\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            RepomdIndexData primaryData = new RepomdIndexData(primaryFile\n                    .getCompressedChecksum(), primaryFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n            RepomdIndexData filelistsData = new RepomdIndexData(filelistsFile\n                    .getCompressedChecksum(), filelistsFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n            RepomdIndexData otherData = new RepomdIndexData(otherFile\n                    .getCompressedChecksum(), otherFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n\n            log.info(\"Starting updateinfo generation for '\" +\n                    channel.getLabel() + '\"');\n            log.info(\"Checksum Type Value for generate updateinfo \" +\n                    this.checksumtype);\n            RepomdIndexData updateinfoData = generateUpdateinfo(channel,\n                    prefix, checksumAlgo);\n\n            RepomdIndexData groupsData = loadCompsFile(channel, checksumAlgo);\n\n            // Set the type so yum can read and perform checksum\n            primaryData.setType(checksumLabel);\n            filelistsData.setType(checksumLabel);\n            otherData.setType(checksumLabel);\n            if (updateinfoData != null) {\n                updateinfoData.setType(checksumLabel);\n            }\n\n            if (groupsData != null) {\n                groupsData.setType(checksumLabel);\n            }\n\n            log.info(\"Primary xml's type: \" + primaryData.getType());\n            log.info(\"filelists xml's type: \" + filelistsData.getType());\n            log.info(\"other xml's type: \" + otherData.getType());\n\n            FileWriter indexFile;\n\n            try {\n                indexFile = new FileWriter(prefix + REPOMD_FILE);\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            RepomdIndexWriter index = new RepomdIndexWriter(indexFile,\n                    primaryData, filelistsData, otherData, updateinfoData,\n                    groupsData);\n\n            index.writeRepomdIndex();\n\n            try {\n                indexFile.close();\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            renameFiles(prefix, channel.getLastModified().getTime(),\n                    updateinfoData != null);\n\n            log.info(\"Repository metadata generation for '\" +\n                    channel.getLabel() + \"' finished in \" +\n                    (int) (new Date().getTime() - start.getTime()) / 1000 + \" seconds\");\n        }\n    }","id":3474,"modified_method":"/**\n     *\n     * @param channel channelinfo for repomd file creation\n     */\n    public void writeRepomdFiles(Channel channel) {\n\n        PackageManager.createRepoEntrys(channel.getId());\n\n        String prefix = mountPoint + File.separator + pathPrefix +\n        File.separator + channel.getLabel() + File.separator;\n\n        // we closed the session, so we need to reload the object\n        channel = (Channel) HibernateFactory.getSession().get(channel.getClass(),\n                channel.getId());\n        if (channel.getChannelArch().getArchType().getLabel().equalsIgnoreCase(\"deb\")) {\n            log.info(\"Generating new DEB repository for channel \" + channel.getLabel());\n            generateDebRepository(channel, prefix);\n        }\n        else {\n            if (!new File(prefix).mkdirs() && !new File(prefix).exists()) {\n                throw new RepomdRuntimeException(\"Unable to create directory: \" +\n                        prefix);\n            }\n            // Get compatible checksumType\n            this.checksumtype = channel.getChecksumTypeLabel();\n            if (checksumtype == null) {\n                generateBadRepo(channel, prefix);\n                return;\n            }\n            new File(prefix + NOREPO_FILE).delete();\n            log.info(\"Checksum Type Value: \" + this.checksumtype);\n\n            // java.security.MessageDigest recognizes:\n            // MD2, MD5, SHA-1, SHA-256, SHA-384, SHA-512\n            String checksumAlgo = this.checksumtype;\n            if (checksumAlgo.toUpperCase().startsWith(\"SHA\")) {\n                checksumAlgo = this.checksumtype.substring(0, 3) + \"-\" +\n                this.checksumtype.substring(3);\n            }\n            // translate sha1 to sha for xml repo files\n            String checksumLabel = this.checksumtype;\n            if (checksumLabel.equals(\"sha1\")) {\n                checksumLabel = \"sha\";\n            }\n\n            log.info(\"Generating new repository metatada for channel '\" +\n                    channel.getLabel() + \"' \" + channel.getPackageCount() +\n                    \" packages, \" + channel.getErrataCount() + \" updates\");\n\n            CompressingDigestOutputWriter primaryFile;\n            CompressingDigestOutputWriter filelistsFile;\n            CompressingDigestOutputWriter otherFile;\n\n            try {\n                primaryFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + PRIMARY_FILE),\n                        checksumAlgo);\n                filelistsFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + FILELISTS_FILE),\n                        checksumAlgo);\n                otherFile = new CompressingDigestOutputWriter(\n                        new FileOutputStream(prefix + OTHER_FILE), checksumAlgo);\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n            catch (NoSuchAlgorithmException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            BufferedWriter primaryBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(primaryFile));\n            BufferedWriter filelistsBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(filelistsFile));\n            BufferedWriter otherBufferedWriter = new BufferedWriter(\n                    new OutputStreamWriter(otherFile));\n            PrimaryXmlWriter primary = new PrimaryXmlWriter(\n                    primaryBufferedWriter);\n            FilelistsXmlWriter filelists = new FilelistsXmlWriter(\n                    filelistsBufferedWriter);\n            OtherXmlWriter other = new OtherXmlWriter(otherBufferedWriter);\n            Date start = new Date();\n\n            primary.begin(channel);\n            filelists.begin(channel);\n            other.begin(channel);\n\n            for (PackageDto pkgDto : TaskManager.getChannelPackageDtos(channel)) {\n                primary.addPackage(pkgDto);\n                filelists.addPackage(pkgDto);\n                other.addPackage(pkgDto);\n                try {\n                    primaryFile.flush();\n                    filelistsFile.flush();\n                    otherFile.flush();\n                }\n                catch (IOException e) {\n                    throw new RepomdRuntimeException(e);\n                }\n            }\n            primary.end();\n            filelists.end();\n            other.end();\n            try {\n                primaryBufferedWriter.close();\n                filelistsBufferedWriter.close();\n                otherBufferedWriter.close();\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            RepomdIndexData primaryData = new RepomdIndexData(primaryFile\n                    .getCompressedChecksum(), primaryFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n            RepomdIndexData filelistsData = new RepomdIndexData(filelistsFile\n                    .getCompressedChecksum(), filelistsFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n            RepomdIndexData otherData = new RepomdIndexData(otherFile\n                    .getCompressedChecksum(), otherFile\n                    .getUncompressedChecksum(), channel.getLastModified());\n\n            log.info(\"Starting updateinfo generation for '\" + channel.getLabel() + '\"');\n            log.info(\"Checksum Type Value for generate updateinfo \" + this.checksumtype);\n            RepomdIndexData updateinfoData = generateUpdateinfo(channel,\n                    prefix, checksumAlgo);\n\n            RepomdIndexData groupsData = loadCompsFile(channel, checksumAlgo);\n\n            // Set the type so yum can read and perform checksum\n            primaryData.setType(checksumLabel);\n            filelistsData.setType(checksumLabel);\n            otherData.setType(checksumLabel);\n            if (updateinfoData != null) {\n                updateinfoData.setType(checksumLabel);\n            }\n\n            if (groupsData != null) {\n                groupsData.setType(checksumLabel);\n            }\n\n            log.info(\"Primary xml's type: \" + primaryData.getType());\n            log.info(\"filelists xml's type: \" + filelistsData.getType());\n            log.info(\"other xml's type: \" + otherData.getType());\n\n            FileWriter indexFile;\n\n            try {\n                indexFile = new FileWriter(prefix + REPOMD_FILE);\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            RepomdIndexWriter index = new RepomdIndexWriter(indexFile, primaryData,\n                    filelistsData, otherData, updateinfoData, groupsData);\n\n            index.writeRepomdIndex();\n\n            try {\n                indexFile.close();\n            }\n            catch (IOException e) {\n                throw new RepomdRuntimeException(e);\n            }\n\n            renameFiles(prefix, channel.getLastModified().getTime(),\n                    updateinfoData != null);\n\n            log.info(\"Repository metadata generation for '\" +\n                    channel.getLabel() + \"' finished in \" +\n                    (int) (new Date().getTime() - start.getTime()) / 1000 + \" seconds\");\n        }\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Create repository for APT\n     * @param channel\n     */\n    private void generateDebRepository(Channel channel, String prefix) {\n        DebPackageWriter writer = new DebPackageWriter(channel, prefix);\n        Iterator iter = TaskManager.getChannelPackageDtoIterator(channel);\n        while (iter.hasNext()) {\n            PackageDto pkgDto = (PackageDto) iter.next();\n            writer.addPackage(pkgDto);\n        }\n        writer.generatePackagesGz();\n    }","id":3475,"modified_method":"/**\n     * Create repository for APT\n     * @param channel\n     */\n    private void generateDebRepository(Channel channel, String prefix) {\n        DebPackageWriter writer = new DebPackageWriter(channel, prefix);\n        for (PackageDto pkgDto : TaskManager.getChannelPackageDtos(channel)) {\n            writer.addPackage(pkgDto);\n        }\n        writer.generatePackagesGz();\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Deletes repomd files\n     * @param channelLabelToProcess channel label\n     */\n    public void deleteRepomdFiles(String channelLabelToProcess, boolean deleteDir) {\n        log.info(\"Removing \" + channelLabelToProcess);\n        String prefix = mountPoint + File.separator + pathPrefix + File.separator +\n                channelLabelToProcess;\n        File primary = new File(prefix + File.separator + \"primary.xml.gz\");\n        File filelists = new File(prefix + File.separator + \"filelists.xml.gz\");\n        File other = new File(prefix + File.separator + \"other.xml.gz\");\n        File repomd = new File(prefix + File.separator + \"repomd.xml\");\n        File updateinfo = new File(prefix + File.separator + \"updateinfo.xml.gz\");\n        File norepo = new File(prefix + File.separator + NOREPO_FILE);\n        File theDirectory = new File(prefix);\n\n        if (!primary.delete()) {\n            log.info(\"Couldn't remove \" + primary.getAbsolutePath());\n        }\n        if (!filelists.delete()) {\n            log.info(\"Couldn't remove \" + filelists.getAbsolutePath());\n        }\n        if (!other.delete()) {\n            log.info(\"Couldn't remove \" + other.getAbsolutePath());\n        }\n        if (!repomd.delete()) {\n            log.info(\"Couldn't remove \" + repomd.getAbsolutePath());\n        }\n        updateinfo.delete();\n        norepo.delete();\n        if (deleteDir) {\n            if (!theDirectory.delete()) {\n                log.info(\"Couldn't remove \" + prefix);\n            }\n        }\n    }","id":3476,"modified_method":"/**\n     * Deletes repomd files\n     * @param channelLabelToProcess channel label\n     * @param deleteDir directory to delete\n     */\n    public void deleteRepomdFiles(String channelLabelToProcess, boolean deleteDir) {\n        log.info(\"Removing \" + channelLabelToProcess);\n        String prefix = mountPoint + File.separator + pathPrefix + File.separator +\n                channelLabelToProcess;\n        File primary = new File(prefix + File.separator + \"primary.xml.gz\");\n        File filelists = new File(prefix + File.separator + \"filelists.xml.gz\");\n        File other = new File(prefix + File.separator + \"other.xml.gz\");\n        File repomd = new File(prefix + File.separator + \"repomd.xml\");\n        File updateinfo = new File(prefix + File.separator + \"updateinfo.xml.gz\");\n        File norepo = new File(prefix + File.separator + NOREPO_FILE);\n        File theDirectory = new File(prefix);\n\n        if (!primary.delete()) {\n            log.info(\"Couldn't remove \" + primary.getAbsolutePath());\n        }\n        if (!filelists.delete()) {\n            log.info(\"Couldn't remove \" + filelists.getAbsolutePath());\n        }\n        if (!other.delete()) {\n            log.info(\"Couldn't remove \" + other.getAbsolutePath());\n        }\n        if (!repomd.delete()) {\n            log.info(\"Couldn't remove \" + repomd.getAbsolutePath());\n        }\n        updateinfo.delete();\n        norepo.delete();\n        if (deleteDir) {\n            if (!theDirectory.delete()) {\n                log.info(\"Couldn't remove \" + prefix);\n            }\n        }\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     *  Get the channel package list for a channel\n     * @param channel channel info\n     * @return the iterator\n     */\n    public static Iterator getChannelPackageDtoIterator(Channel channel) {\n        SelectMode m = ModeFactory.getMode(TaskConstants.MODE_NAME,\n                TaskConstants.TASK_QUERY_REPOMD_GENERATOR_CHANNEL_PACKAGES);\n        Map params = new HashMap();\n        params.put(\"channel_id\", channel.getId());\n        return m.execute(params).iterator();\n    }","id":3477,"modified_method":"/**\n     *  Get the channel package list for a channel\n     * @param channel channel info\n     * @return the iterator\n     */\n    public static Collection<PackageDto> getChannelPackageDtos(Channel channel) {\n        SelectMode m = ModeFactory.getMode(TaskConstants.MODE_NAME,\n                TaskConstants.TASK_QUERY_REPOMD_GENERATOR_CHANNEL_PACKAGES);\n        Map params = new HashMap();\n        params.put(\"channel_id\", channel.getId());\n        return m.execute(params);\n    }","commit_id":"2f6aca969a115b5719cbd1c4b438ecdef524c606","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void performOnElement(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    final Document document = editor.getDocument();\n\n    final TextRange textRange = getTextRange(element, editor);\n    if (textRange.isEmpty()) return;\n    final String text = textRange.substring(element.getContainingFile().getText());\n\n    final List<String> subStrings = StringUtil.split(text, \"\\n\", true);\n    final StringBuilder stringBuilder = new StringBuilder();\n    for (String string : subStrings) {\n      stringBuilder.append(StringUtil.trimStart(string.trim(), getPrefix(element))).append(\" \");\n    }\n    final String replacementText = stringBuilder.toString();\n\n    CommandProcessor.getInstance().executeCommand(element.getProject(), new Runnable() {\n      public void run() {\n        document.replaceString(textRange.getStartOffset(), textRange.getEndOffset(),\n                               getPrefix(element) + replacementText);\n        final CodeFormatterFacade codeFormatter = new CodeFormatterFacade(\n                                        CodeStyleSettingsManager.getSettings(element.getProject()));\n        codeFormatter.doWrapLongLinesIfNecessary(editor, element.getProject(), document,\n                                                 textRange.getStartOffset(),\n                                                 textRange.getStartOffset() + replacementText.length() + 1);\n      }\n    }, null, document);\n\n  }","id":3478,"modified_method":"protected void performOnElement(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    final Document document = editor.getDocument();\n\n    final TextRange textRange = getTextRange(element, editor);\n    if (textRange.isEmpty()) return;\n    final String text = textRange.substring(element.getContainingFile().getText());\n\n    final List<String> subStrings = StringUtil.split(text, \"\\n\", true);\n    final String prefix = getPrefix(element);\n    final String postfix = getPostfix(element);\n\n    final StringBuilder stringBuilder = new StringBuilder();\n    appendPrefix(element, text, stringBuilder);\n\n    for (String string : subStrings) {\n      final String startTrimmed = StringUtil.trimStart(string.trim(), prefix.trim());\n      final String str = StringUtil.trimEnd(startTrimmed, postfix.trim());\n      stringBuilder.append(str).append(\" \");\n    }\n    appendPostfix(element, text, stringBuilder);\n\n    final String replacementText = stringBuilder.toString();\n\n    CommandProcessor.getInstance().executeCommand(element.getProject(), new Runnable() {\n      public void run() {\n        document.replaceString(textRange.getStartOffset(), textRange.getEndOffset(),\n                               replacementText);\n        final CodeFormatterFacade codeFormatter = new CodeFormatterFacade(\n                                        CodeStyleSettingsManager.getSettings(element.getProject()));\n        codeFormatter.doWrapLongLinesIfNecessary(editor, element.getProject(), document,\n                                                 textRange.getStartOffset(),\n                                                 textRange.getStartOffset() + replacementText.length() + 1);\n      }\n    }, null, document);\n\n  }","commit_id":"7fadb6ed91ef672e9942bf90b4299e71893951c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiElement getFirstElement(@NotNull final PsiElement element) {\n    final IElementType elementType = element.getNode().getElementType();\n    PsiElement prevSibling = element.getPrevSibling();\n    PsiElement result = element;\n    while (prevSibling != null && (prevSibling.getNode().getElementType().equals(elementType) ||\n                                   (atWhitespaceToken(prevSibling) &&\n                                   StringUtil.countChars(prevSibling.getText(), '\\n') <= 1))) {\n      final String text = prevSibling.getText();\n      if (prevSibling.getNode().getElementType().equals(elementType) && StringUtil.isEmptyOrSpaces(\n        StringUtil.trimStart(text.trim(), getPrefix(element)))) {\n        break;\n      }\n      if (prevSibling.getNode().getElementType().equals(elementType))\n        result = prevSibling;\n      prevSibling = prevSibling.getPrevSibling();\n    }\n    return result;\n  }","id":3479,"modified_method":"@Nullable\n  private PsiElement getFirstElement(@NotNull final PsiElement element) {\n    final IElementType elementType = element.getNode().getElementType();\n    PsiElement prevSibling = element.getPrevSibling();\n    PsiElement result = element;\n    while (prevSibling != null && (prevSibling.getNode().getElementType().equals(elementType) ||\n                                   (atWhitespaceToken(prevSibling) &&\n                                   StringUtil.countChars(prevSibling.getText(), '\\n') <= 1))) {\n      String text = prevSibling.getText();\n      final String prefix = getPrefix(element);\n      final String postfix = getPostfix(element);\n      text = StringUtil.trimStart(text.trim(), prefix.trim());\n      text = StringUtil.trimEnd(text, postfix);\n\n      if (prevSibling.getNode().getElementType().equals(elementType) &&\n          StringUtil.isEmptyOrSpaces(text)) {\n        break;\n      }\n      if (prevSibling.getNode().getElementType().equals(elementType))\n        result = prevSibling;\n      prevSibling = prevSibling.getPrevSibling();\n    }\n    return result;\n  }","commit_id":"7fadb6ed91ef672e9942bf90b4299e71893951c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getStartOffset(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    if (isBunchOfElement(element)) {\n      final PsiElement firstCommentElement = getFirstElement(element);\n      return firstCommentElement != null? firstCommentElement.getTextRange().getStartOffset()\n                                        : element.getTextRange().getStartOffset();\n    }\n    final int offset = editor.getCaretModel().getOffset();\n    final int elementTextOffset = element.getTextOffset();\n    final Document document = editor.getDocument();\n    int lineNumber = document.getLineNumber(offset);\n\n    while (lineNumber != document.getLineNumber(elementTextOffset)) {\n      final String text = document.getText(TextRange.create(document.getLineStartOffset(lineNumber),\n                                                            document.getLineEndOffset(lineNumber)));\n      if (StringUtil.isEmptyOrSpaces(text)) {\n        lineNumber += 1;\n        break;\n      }\n      lineNumber -= 1;\n    }\n    final int lineStartOffset = document.getLineStartOffset(lineNumber);\n    final String lineText = document\n      .getText(TextRange.create(lineStartOffset, document.getLineEndOffset(lineNumber)));\n    int shift = StringUtil.findFirst(lineText, CharFilter.NOT_WHITESPACE_FILTER);\n\n    return lineStartOffset + shift;\n  }","id":3480,"modified_method":"private int getStartOffset(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    if (isBunchOfElement(element)) {\n      final PsiElement firstElement = getFirstElement(element);\n      return firstElement != null? firstElement.getTextRange().getStartOffset()\n                                        : element.getTextRange().getStartOffset();\n    }\n    final int offset = editor.getCaretModel().getOffset();\n    final int elementTextOffset = element.getTextOffset();\n    final Document document = editor.getDocument();\n    int lineNumber = document.getLineNumber(offset);\n\n    while (lineNumber != document.getLineNumber(elementTextOffset)) {\n      final String text = document.getText(TextRange.create(document.getLineStartOffset(lineNumber),\n                                                            document.getLineEndOffset(lineNumber)));\n      if (StringUtil.isEmptyOrSpaces(text)) {\n        lineNumber += 1;\n        break;\n      }\n      lineNumber -= 1;\n    }\n    final int lineStartOffset = document.getLineStartOffset(lineNumber);\n    final String lineText = document\n      .getText(TextRange.create(lineStartOffset, document.getLineEndOffset(lineNumber)));\n    int shift = StringUtil.findFirst(lineText, CharFilter.NOT_WHITESPACE_FILTER);\n\n    return lineStartOffset + shift;\n  }","commit_id":"7fadb6ed91ef672e9942bf90b4299e71893951c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiElement getLastElement(@NotNull final PsiElement element) {\n    final IElementType elementType = element.getNode().getElementType();\n    PsiElement nextSibling = element.getNextSibling();\n    PsiElement result = element;\n    while (nextSibling != null && (nextSibling.getNode().getElementType().equals(elementType) ||\n                                   (atWhitespaceToken(nextSibling) &&\n                                   StringUtil.countChars(nextSibling.getText(), '\\n') <= 1))) {\n      final String text = nextSibling.getText();\n      if (nextSibling.getNode().getElementType().equals(elementType) && StringUtil.isEmptyOrSpaces(\n        StringUtil.trimStart(text.trim(), getPrefix(element)))) {\n        break;\n      }\n      if (nextSibling.getNode().getElementType().equals(elementType))\n        result = nextSibling;\n      nextSibling = nextSibling.getNextSibling();\n    }\n    return result;\n  }","id":3481,"modified_method":"@Nullable\n  private PsiElement getLastElement(@NotNull final PsiElement element) {\n    final IElementType elementType = element.getNode().getElementType();\n    PsiElement nextSibling = element.getNextSibling();\n    PsiElement result = element;\n    while (nextSibling != null && (nextSibling.getNode().getElementType().equals(elementType) ||\n                                   (atWhitespaceToken(nextSibling) &&\n                                   StringUtil.countChars(nextSibling.getText(), '\\n') <= 1))) {\n      String text = nextSibling.getText();\n      final String prefix = getPrefix(element);\n      final String postfix = getPostfix(element);\n      text = StringUtil.trimStart(text.trim(), prefix.trim());\n      text = StringUtil.trimEnd(text, postfix);\n\n      if (nextSibling.getNode().getElementType().equals(elementType) &&\n          StringUtil.isEmptyOrSpaces(text)) {\n        break;\n      }\n      if (nextSibling.getNode().getElementType().equals(elementType))\n        result = nextSibling;\n      nextSibling = nextSibling.getNextSibling();\n    }\n    return result;\n  }","commit_id":"7fadb6ed91ef672e9942bf90b4299e71893951c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","id":3482,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            else\n            {\n                ((SlaveIdGeneratorFactory) getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster( \" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown();\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","id":3483,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster(\" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown( t instanceof RuntimeException ? (RuntimeException) t : new RuntimeException( t ) );\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n//                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","id":3484,"modified_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            IdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker, receiver,\n                    localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","id":3485,"modified_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            SlaveIdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker,\n                    receiver, localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":3486,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                if ( newSessionId != sessionId || masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId() )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n    //                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n    //                {\n                        setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n    //                }\n                    receiver.newMaster( masterAfterIWrote, new Exception() );\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","id":3487,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                boolean masterBeforeIWriteDiffers = masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId();\n                if ( newSessionId != sessionId || masterBeforeIWriteDiffers )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                    if ( sessionId != -1 )\n                    {\n                        receiver.newMaster( masterAfterIWrote, new Exception() );\n                    }\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster( \" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown();\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","id":3488,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster(\" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown( t instanceof RuntimeException ? (RuntimeException) t : new RuntimeException( t ) );\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","id":3489,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            else\n            {\n                ((SlaveIdGeneratorFactory) getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n//                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","id":3490,"modified_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":3491,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            IdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker, receiver,\n                    localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","id":3492,"modified_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            SlaveIdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker,\n                    receiver, localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                if ( newSessionId != sessionId || masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId() )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n    //                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n    //                {\n                        setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n    //                }\n                    receiver.newMaster( masterAfterIWrote, new Exception() );\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","id":3493,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                boolean masterBeforeIWriteDiffers = masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId();\n                if ( newSessionId != sessionId || masterBeforeIWriteDiffers )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                    if ( sessionId != -1 )\n                    {\n                        receiver.newMaster( masterAfterIWrote, new Exception() );\n                    }\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","id":3494,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            else\n            {\n                ((SlaveIdGeneratorFactory) getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n        if ( restarted )\n        {\n            broker.setConnectionInformation( this.localGraph.getKernelData() );\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                localGraph().registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                localGraph().registerKernelEventHandler( handler );\n            }\n        }\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster( \" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown();\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","id":3495,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            msgLog.logMessage( \"newMaster(\" + master + \") called\", e, true );\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            msgLog.logMessage( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\", true );\n            shutdown( t instanceof RuntimeException ? (RuntimeException) t : new RuntimeException( t ) );\n            if ( t instanceof RuntimeException )\n            {\n                throw (RuntimeException) t;\n            }\n            throw new RuntimeException( t );\n        }\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n//                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","id":3496,"modified_method":"public MasterServer( Master realMaster, final int port, String storeDir )\n    {\n        this.realMaster = realMaster;\n        this.msgLog = StringLogger.getLogger( storeDir + \"/messages.log\" );\n        executor = Executors.newCachedThreadPool();\n        channelFactory = new NioServerSocketChannelFactory(\n                executor, executor, MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS );\n        bootstrap = new ServerBootstrap( channelFactory );\n        bootstrap.setPipelineFactory( this );\n        channelGroup = new DefaultChannelGroup();\n        executor.execute( new Runnable()\n        {\n            public void run()\n            {\n                Channel channel = bootstrap.bind( new InetSocketAddress( port ) );\n                // Add the \"server\" channel\n                channelGroup.add( channel );\n                msgLog.logMessage( \"Master server bound to \" + port, true );\n            }\n        } );\n        deadConnectionsPoller = new ScheduledThreadPoolExecutor( 1 );\n        deadConnectionsPoller.scheduleWithFixedDelay( new Runnable()\n        {\n            public void run()\n            {\n                checkForDeadChannels();\n            }\n        }, DEAD_CONNECTIONS_CHECK_INTERVAL, DEAD_CONNECTIONS_CHECK_INTERVAL, TimeUnit.SECONDS );\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":3497,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            IdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker, receiver,\n                    localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","id":3498,"modified_method":"public IdGenerator open( String fileName, int grabSize, IdType idType, long highestIdInUse )\n        {\n            IdGenerator localIdGenerator = localFactory.open( fileName, grabSize,\n                    idType, highestIdInUse );\n            SlaveIdGenerator generator = new SlaveIdGenerator( idType, highestIdInUse, broker,\n                    receiver, localIdGenerator );\n            generators.put( idType, generator );\n            return generator;\n        }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                if ( newSessionId != sessionId || masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId() )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n    //                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n    //                {\n                        setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n    //                }\n                    receiver.newMaster( masterAfterIWrote, new Exception() );\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","id":3499,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\", true );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                if ( zooKeeper != null )\n                {\n                    try\n                    {\n                        zooKeeper.close();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        e.printStackTrace();\n                        Thread.interrupted();\n                    }\n                }\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                long newSessionId = zooKeeper.getSessionId();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                boolean masterBeforeIWriteDiffers = masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId();\n                if ( newSessionId != sessionId || masterBeforeIWriteDiffers )\n                {\n                    sequenceNr = setup();\n                    msgLog.logMessage( \"Did setup, seq=\" + sequenceNr + \" new sessionId=\" + newSessionId );\n                    keeperState = KeeperState.SyncConnected;\n                    Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                    msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                    int masterId = masterAfterIWrote.other().getMachineId();\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                    if ( sessionId != -1 )\n                    {\n                        receiver.newMaster( masterAfterIWrote, new Exception() );\n                    }\n                    sessionId = newSessionId;\n                }\n                else\n                {\n                    msgLog.logMessage( \"SyncConnected with same session id: \" + sessionId );\n                    keeperState = KeeperState.SyncConnected;\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e, true );\n            e.printStackTrace();\n            throw e;\n        }\n        finally\n        {\n            msgLog.flush();\n        }\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"public java.awt.Component getTableCellEditorComponent(final JTable table,final Object value,boolean isSelected,final int row,final int col)\n       {\n           field = new JTextField();\n           categories = new JComboBox();//new JComboBox(dublinCoreTemp);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n          /* categories.addFocusListener(new FocusAdapter(){\n               public void focusLost(java.awt.event.FocusEvent fe)\n               {\n                   System.out.println(\"MetadataEditor - focus lost on categories drop down \");\n                   System.out.println(\"value: \" + value);\n                   System.out.println(\"vme value \" + table.getModel().getValueAt(row,buttonColumn - 1));\n                   //table.getModel().setValueAt(vme,row,col);\n               }\n           });*/\n           \n           categories.addItemListener(new java.awt.event.ItemListener(){\n              public void itemStateChanged(java.awt.event.ItemEvent ie)\n              {\n                  if(ie.getStateChange()==java.awt.event.ItemEvent.SELECTED)\n                  {\n                    //System.out.println(\"MetadataEditor - categories item state changed: \" + ie);\n                    //System.out.println(\"MetadataEditor -- textfield value: \" + table.getModel().getValueAt(row,buttonColumn - 1));\n                    VueMetadataElement vme = new VueMetadataElement();\n                    String[] keyValuePair = {categories.getSelectedItem().toString(),table.getModel().getValueAt(row,buttonColumn - 1).toString()};\n                    vme.setObject(keyValuePair);\n                    vme.setType(VueMetadataElement.CATEGORY);\n                    //table.getModel().setValueAt(vme,row,col);\n                    if(current.getMetadataList().getMetadata().size() > (row))\n                    {\n                      current.getMetadataList().getMetadata().set(row,vme);\n                    }\n                    else\n                    {\n                      current.getMetadataList().getMetadata().add(vme); \n                    }\n                  }\n              }\n           });\n           \n           field.addFocusListener(new FocusAdapter(){\n              public void focusLost(java.awt.event.FocusEvent fe)\n              {  \n                  java.util.List<VueMetadataElement> metadata = current.getMetadataList().getMetadata();\n                  \n                  VueMetadataElement currentVME = null;\n                  \n                  if(metadata.size() > 0)\n                   currentVME = metadata.get(row);\n                  \n                  VueMetadataElement vme = new VueMetadataElement();\n                  //System.out.println(\"MetadataEditor -- value at position where text field focus lost: \" +  table.getModel().getValueAt(row,col));\n                  \n                  if(currentVME==null)\n                  {\n                    vme.setObject(field.getText());   \n                  }\n                  else\n                  if(!(currentVME.getObject() instanceof String[]))\n                  {\n                    vme.setObject(field.getText());\n                  }\n                  else\n                  {\n                    String[] obj = (String[])currentVME.getObject();  \n                    String[] pairedValue = {obj[0],field.getText()};\n                    vme.setObject(pairedValue);\n                  }\n                  //table.getModel().setValueAt(vme,row,col);\n                  if(current.getMetadataList().getMetadata().size() > (row))\n                  {\n                    current.getMetadataList().getMetadata().set(row,vme);\n                  }\n                  else\n                  {\n                    current.getMetadataList().getMetadata().add(vme); \n                  }\n                  //System.out.println(\"MetadataEditor -- value at position where text field focus lost - after set: \" +  table.getModel().getValueAt(row,col));\n                  if(buttonColumn == 2)\n                  {\n                      //System.out.println(\"MetadataEditor -- drop down value :\" + table.getModel().getValueAt(row,buttonColumn-2));\n                  }\n                  stopCellEditing();\n              }\n           });\n           final JPanel comp = new JPanel();\n           comp.setLayout(new java.awt.BorderLayout());\n           if(col == buttonColumn - 2)\n           {\n               //categories.setSelectedIndex(1);\n               //int loc = 0;\n               int n = categories.getModel().getSize();\n               String currValue = table.getModel().getValueAt(row,col).toString();\n               //System.out.println(\"Editor -- currValue: \" + currValue);\n               for(int i=0;i<n;i++)\n               {\n                   if(categories.getModel().getElementAt(i).equals(currValue))\n                   {\n                       //System.out.println(\"found category\");\n                       categories.setSelectedIndex(i);\n                   }\n               }\n               comp.add(categories);\n           }\n           else\n           if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               comp.add(field);\n           }\n           else if(col ==  buttonColumn)               \n           {\n               JLabel buttonLabel = new JLabel();\n               buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               comp.add(buttonLabel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(BorderFactory.createEmptyBorder(ROW_GAP,ROW_INSET,ROW_GAP,ROW_INSET));\n           \n           /*field. metadataTable. getParent(). */ /*getRootPane().addMouseListener(new MouseAdapter() {\n               public void mouseExited(MouseEvent me)\n               {\n                   //System.out.println(\"MetadataEditor table cell - exited: \" + me);\n                   System.out.println(\"MetadataEditor -  mouse exited table - \" + me);\n                     stopCellEditing();\n               }\n           });*/\n           \n           return comp;\n       }","id":3500,"modified_method":"public java.awt.Component getTableCellEditorComponent(final JTable table,final Object value,boolean isSelected,final int row,final int col)\n       {\n           field = new JTextField();\n           categories = new JComboBox();//new JComboBox(dublinCoreTemp);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           categories.addItemListener(new ItemListener() \n           {\n               public void itemStateChanged(ItemEvent e) \n               {\n                   if(e.getStateChange() == ItemEvent.SELECTED)\n                   {\n                       if(e.getItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                       {\n                           //System.out.println(\"MetdataEditor edit item selected: \" + e);\n                           tufts.vue.gui.DockWindow ec = tufts.vue.gui.GUI.createDockWindow(\"Edit Categories\", new CategoryEditor());\n                           ec.setBounds(200,200,300,300);\n                           ec.setVisible(true);\n                       }\n                   }\n               }\n           });\n           \n          /* categories.addFocusListener(new FocusAdapter(){\n               public void focusLost(java.awt.event.FocusEvent fe)\n               {\n                   System.out.println(\"MetadataEditor - focus lost on categories drop down \");\n                   System.out.println(\"value: \" + value);\n                   System.out.println(\"vme value \" + table.getModel().getValueAt(row,buttonColumn - 1));\n                   //table.getModel().setValueAt(vme,row,col);\n               }\n           });*/\n           \n           categories.addItemListener(new java.awt.event.ItemListener(){\n              public void itemStateChanged(java.awt.event.ItemEvent ie)\n              {\n                  if(ie.getStateChange()==java.awt.event.ItemEvent.SELECTED)\n                  {\n                    //System.out.println(\"MetadataEditor - categories item state changed: \" + ie);\n                    //System.out.println(\"MetadataEditor -- textfield value: \" + table.getModel().getValueAt(row,buttonColumn - 1));\n                    VueMetadataElement vme = new VueMetadataElement();\n                    String[] keyValuePair = {categories.getSelectedItem().toString(),table.getModel().getValueAt(row,buttonColumn - 1).toString()};\n                    vme.setObject(keyValuePair);\n                    vme.setType(VueMetadataElement.CATEGORY);\n                    //table.getModel().setValueAt(vme,row,col);\n                    if(current.getMetadataList().getMetadata().size() > (row))\n                    {\n                      current.getMetadataList().getMetadata().set(row,vme);\n                    }\n                    else\n                    {\n                      current.getMetadataList().getMetadata().add(vme); \n                    }\n                  }\n              }\n           });\n           \n           field.addFocusListener(new FocusAdapter(){\n              public void focusLost(java.awt.event.FocusEvent fe)\n              {  \n                  java.util.List<VueMetadataElement> metadata = current.getMetadataList().getMetadata();\n                  \n                  VueMetadataElement currentVME = null;\n                  \n                  if(metadata.size() > 0)\n                   currentVME = metadata.get(row);\n                  \n                  VueMetadataElement vme = new VueMetadataElement();\n                  //System.out.println(\"MetadataEditor -- value at position where text field focus lost: \" +  table.getModel().getValueAt(row,col));\n                  \n                  if(currentVME==null)\n                  {\n                    vme.setObject(field.getText());   \n                  }\n                  else\n                  if(!(currentVME.getObject() instanceof String[]))\n                  {\n                    vme.setObject(field.getText());\n                  }\n                  else\n                  {\n                    String[] obj = (String[])currentVME.getObject();  \n                    String[] pairedValue = {obj[0],field.getText()};\n                    vme.setObject(pairedValue);\n                  }\n                  //table.getModel().setValueAt(vme,row,col);\n                  if(current.getMetadataList().getMetadata().size() > (row))\n                  {\n                    current.getMetadataList().getMetadata().set(row,vme);\n                  }\n                  else\n                  {\n                    current.getMetadataList().getMetadata().add(vme); \n                  }\n                  //System.out.println(\"MetadataEditor -- value at position where text field focus lost - after set: \" +  table.getModel().getValueAt(row,col));\n                  if(buttonColumn == 2)\n                  {\n                      //System.out.println(\"MetadataEditor -- drop down value :\" + table.getModel().getValueAt(row,buttonColumn-2));\n                  }\n                  stopCellEditing();\n              }\n           });\n           final JPanel comp = new JPanel();\n           comp.setLayout(new java.awt.BorderLayout());\n           if(col == buttonColumn - 2)\n           {\n               //categories.setSelectedIndex(1);\n               //int loc = 0;\n               int n = categories.getModel().getSize();\n               Object currValue = table.getModel().getValueAt(row,col); //.toString();\n               //System.out.println(\"Editor -- currValue: \" + currValue);\n               for(int i=0;i<n;i++)\n               {\n                   System.out.println(\"MetadataTable looking for category currValue: \" + currValue);\n                   System.out.println(\"MetadataTable looking for category model element at \" + i + \" \" +\n                           categories.getModel().getElementAt(i));\n                   \n                   Object item = categories.getModel().getElementAt(i);\n                   String currLabel = \"\";\n                   if(currValue instanceof OntType)\n                       currLabel = ((OntType)currValue).getLabel();\n                   else\n                       currLabel = currValue.toString();\n                   \n                   if(item instanceof OntType)\n                     System.out.println(\"MetadataTable looking at category model OntType element at \" + i + \" \" +\n                           ((OntType)item).getLabel());\n                   \n                   if(item instanceof OntType &&\n                           ((OntType)item).getLabel().equals(currLabel))\n                   {\n                       //System.out.println(\"found category\");\n                       categories.setSelectedIndex(i);\n                   }\n               }\n               comp.add(categories);\n           }\n           else\n           if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               comp.add(field);\n           }\n           else if(col ==  buttonColumn)               \n           {\n               JLabel buttonLabel = new JLabel();\n               buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               comp.add(buttonLabel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(BorderFactory.createEmptyBorder(ROW_GAP,ROW_INSET,ROW_GAP,ROW_INSET));\n           \n           /*field. metadataTable. getParent(). */ /*getRootPane().addMouseListener(new MouseAdapter() {\n               public void mouseExited(MouseEvent me)\n               {\n                   //System.out.println(\"MetadataEditor table cell - exited: \" + me);\n                   System.out.println(\"MetadataEditor -  mouse exited table - \" + me);\n                     stopCellEditing();\n               }\n           });*/\n           \n           return comp;\n       }","commit_id":"38e52001e5bab82ca7497482767b2a98a8e256f0","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox(dublinCoreTemp);\n           JComboBox categories = new JComboBox();\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           comp.setLayout(new java.awt.BorderLayout());\n           if(col == buttonColumn-2)\n           {\n               int n = categories.getModel().getSize();\n               String currValue = table.getModel().getValueAt(row,col).toString();\n               //System.out.println(\"Renderer -- currValue: \" + currValue);\n               //categories.setSelectedIndex(0);\n               for(int i=0;i<n;i++)\n               {\n                   if(categories.getModel().getElementAt(i).equals(currValue))\n                   {\n                      //System.out.println(\"found category\");\n                       categories.setSelectedIndex(i);\n                   }\n               }\n               comp.add(categories);\n           }\n           else if(col == buttonColumn-1)\n           {\n               if(value instanceof OntType)\n               {\n                 comp.add(new JLabel(((OntType)value).getLabel()));\n               }\n               else\n               if(value instanceof VueMetadataElement)\n               {\n                   VueMetadataElement vme = (VueMetadataElement)value;\n                   if(vme.getType() == VueMetadataElement.CATEGORY)\n                   {\n                      comp.add(new JTextField(vme.getValue()));\n                   }\n               }\n               else\n                 comp.add(new JTextField(value.toString()));\n           }\n           else if(col == buttonColumn)               \n           {\n               JLabel buttonLabel = new JLabel();\n               buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               comp.add(buttonLabel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(BorderFactory.createEmptyBorder(ROW_GAP,ROW_INSET,ROW_GAP,ROW_INSET));\n           \n           return comp;\n       }","id":3501,"modified_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox(dublinCoreTemp);\n           JComboBox categories = new JComboBox();\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           comp.setLayout(new java.awt.BorderLayout());\n           if(col == buttonColumn-2)\n           {\n               int n = categories.getModel().getSize();\n               \n               Object currValue = table.getModel().getValueAt(row,col); //.toString();\n               //System.out.println(\"Editor -- currValue: \" + currValue);\n               for(int i=0;i<n;i++)\n               {\n                   System.out.println(\"MetadataTable looking for category currValue: \" + currValue);\n                   System.out.println(\"MetadataTable looking for category model element at \" + i + \" \" +\n                           categories.getModel().getElementAt(i));\n                   \n                   Object item = categories.getModel().getElementAt(i);\n                   String currLabel = \"\";\n                   if(currValue instanceof OntType)\n                       currLabel = ((OntType)currValue).getLabel();\n                   else\n                       currLabel = currValue.toString();\n                   \n                   if(item instanceof OntType)\n                     System.out.println(\"MetadataTable looking at category model OntType element at \" + i + \" \" +\n                           ((OntType)item).getLabel());\n                   \n                   if(item instanceof OntType &&\n                           ((OntType)item).getLabel().equals(currLabel))\n                   {\n                       //System.out.println(\"found category\");\n                       categories.setSelectedIndex(i);\n                   }\n                   \n               }\n               \n               \n               /*String currValue = table.getModel().getValueAt(row,col).toString();\n               //System.out.println(\"Renderer -- currValue: \" + currValue);\n               //categories.setSelectedIndex(0);\n               for(int i=0;i<n;i++)\n               {\n                   if(categories.getModel().getElementAt(i).equals(currValue))\n                   {\n                      //System.out.println(\"found category\");\n                       categories.setSelectedIndex(i);\n                   }\n               }*/\n               comp.add(categories); \n           }\n           else if(col == buttonColumn-1)\n           {\n               if(value instanceof OntType)\n               {\n                 comp.add(new JLabel(((OntType)value).getLabel()));\n               }\n               else\n               if(value instanceof VueMetadataElement)\n               {\n                   VueMetadataElement vme = (VueMetadataElement)value;\n                   if(vme.getType() == VueMetadataElement.CATEGORY)\n                   {\n                      comp.add(new JTextField(vme.getValue()));\n                   }\n               }\n               else\n                 comp.add(new JTextField(value.toString()));\n           }\n           else if(col == buttonColumn)               \n           {\n               JLabel buttonLabel = new JLabel();\n               buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               comp.add(buttonLabel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(BorderFactory.createEmptyBorder(ROW_GAP,ROW_INSET,ROW_GAP,ROW_INSET));\n           \n           return comp;\n       }","commit_id":"38e52001e5bab82ca7497482767b2a98a8e256f0","url":"https://github.com/VUE/VUE"},{"original_method":"public void propertyChange(PropertyChangeEvent e){\n   if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n     this.mbsc=(MBeanServerConnection)e.getNewValue();\n   }else if(e.getPropertyName().equals(Plugin.EMPTY_NODE)){\n     this.mbsc=null;\n   }\n  }","id":3502,"modified_method":"public void propertyChange(PropertyChangeEvent e){\nSystem.out.println(\"TEST\"+e.getPropertyName());\t\n   if (e.getPropertyName().equals(Plugin.NEW_NODE_READY)){\n     this.mbsc=(MBeanServerConnection)e.getNewValue();\nSystem.out.println(\"TESTE\"+this.mbsc);\t\n   }else if(e.getPropertyName().equals(Plugin.EMPTY_NODE)){\n     this.mbsc=null;\n   }\n  }","commit_id":"aa4f69d8d821e04bb4d70df906bf2a04e57739a3","url":"https://github.com/apache/felix"},{"original_method":"private void loadChanges() {\n    myChanges = new ArrayList<Change>();\n    for(String path: myAddedPaths) {\n      myChanges.add(new Change(null,\n                               new SvnRepositoryContentRevision(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision)));\n    }\n    for(String path: myDeletedPaths) {\n      myChanges.add(new Change(new SvnRepositoryContentRevision(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision-1),\n                               null));\n\n    }\n    for(String path: myChangedPaths) {\n      SvnRepositoryContentRevision beforeRevision = new SvnRepositoryContentRevision(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision-1);\n      SvnRepositoryContentRevision afterRevision = new SvnRepositoryContentRevision(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision);\n      myChanges.add(new Change(beforeRevision, afterRevision));\n    }\n  }","id":3503,"modified_method":"private void loadChanges() {\n    myChanges = new ArrayList<Change>();\n    for(String path: myAddedPaths) {\n      myChanges.add(new Change(null, SvnRepositoryContentRevision.create(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision)));\n    }\n    for(String path: myDeletedPaths) {\n      myChanges.add(new Change(SvnRepositoryContentRevision.create(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision-1), null));\n    }\n    for(String path: myChangedPaths) {\n      SvnRepositoryContentRevision beforeRevision = SvnRepositoryContentRevision.create(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision-1);\n      SvnRepositoryContentRevision afterRevision = SvnRepositoryContentRevision.create(myVcs, myRepositoryRoot, path, getLocalPath(path), myRevision);\n      myChanges.add(new Change(beforeRevision, afterRevision));\n    }\n  }","commit_id":"218341e05824e1f3b251f4a94797d5963f080107","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SvnRepositoryContentRevision(final SvnVcs vcs, final String repositoryRoot, final String path, @Nullable final FilePath localPath,\n                                      final long revision) {\n    myVcs = vcs;\n    myPath = path;\n    myRepositoryRoot = repositoryRoot;\n    myLocalPath = localPath;\n    myRevision = revision;\n  }","id":3504,"modified_method":"SvnRepositoryContentRevision(final SvnVcs vcs, final String repositoryRoot, final String path, @Nullable final FilePath localPath,\n                                      final long revision) {\n    myVcs = vcs;\n    myPath = path;\n    myRepositoryRoot = repositoryRoot;\n    myLocalPath = localPath;\n    myRevision = revision;\n  }","commit_id":"218341e05824e1f3b251f4a94797d5963f080107","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myContent == null) {\n      final OutputStream buffer = new ByteArrayOutputStream();\n      ContentLoader loader = new ContentLoader(myPath, buffer, myRevision);\n      if (ApplicationManager.getApplication().isDispatchThread()) {\n        ProgressManager.getInstance()\n          .runProcessWithProgressSynchronously(loader, SvnBundle.message(\"progress.title.loading.file.content\"), false, null);\n      }\n      else {\n        loader.run();\n      }\n      final SVNException exception = loader.getException();\n      if (exception != null) {\n        throw new VcsException(exception);\n      }\n      myContent = buffer.toString();\n    }\n    return myContent;\n  }","id":3505,"modified_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myContent == null) {\n      final OutputStream buffer = loadContent();\n      myContent = buffer.toString();\n    }\n    return myContent;\n  }","commit_id":"218341e05824e1f3b251f4a94797d5963f080107","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Create a new BeanNotOfRequiredTypeException.\n\t * @param beanName the name of the bean requested\n\t * @param requiredType the required type\n\t * @param actualType the actual type returned, which did not match\n\t * the expected type\n\t */\n\tpublic BeanNotOfRequiredTypeException(String beanName, Class<?> requiredType, Class<?> actualType) {\n\t\tsuper(\"Bean named '\" + beanName + \"' must be of type [\" + requiredType.getName() +\n\t\t\t\t\"], but was actually of type [\" + actualType.getName() + \"]\");\n\t\tthis.beanName = beanName;\n\t\tthis.requiredType = requiredType;\n\t\tthis.actualType = actualType;\n\t}","id":3506,"modified_method":"/**\n\t * Create a new BeanNotOfRequiredTypeException.\n\t * @param beanName the name of the bean requested\n\t * @param requiredType the required type\n\t * @param actualType the actual type returned, which did not match\n\t * the expected type\n\t */\n\tpublic BeanNotOfRequiredTypeException(String beanName, Class<?> requiredType, Class<?> actualType) {\n\t\tsuper(\"Bean named '\" + beanName + \"' is expected to be of type [\" + requiredType.getName() +\n\t\t\t\t\"] but was actually of type [\" + actualType.getName() + \"]\");\n\t\tthis.beanName = beanName;\n\t\tthis.requiredType = requiredType;\n\t\tthis.actualType = actualType;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Resolve the constructor arguments for this bean into the resolvedValues object.\n\t * This may involve looking up other beans.\n\t * <p>This method is also used for handling invocations of static factory methods.\n\t */\n\tprivate int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,\n\t\t\tConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {\n\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\n\t\tint minNrOfArgs = cargs.getArgumentCount();\n\n\t\tfor (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {\n\t\t\tint index = entry.getKey();\n\t\t\tif (index < 0) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid constructor argument index: \" + index);\n\t\t\t}\n\t\t\tif (index > minNrOfArgs) {\n\t\t\t\tminNrOfArgs = index + 1;\n\t\t\t}\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addGenericArgumentValue(resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\treturn minNrOfArgs;\n\t}","id":3507,"modified_method":"/**\n\t * Resolve the constructor arguments for this bean into the resolvedValues object.\n\t * This may involve looking up other beans.\n\t * <p>This method is also used for handling invocations of static factory methods.\n\t */\n\tprivate int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,\n\t\t\tConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\n\t\tint minNrOfArgs = cargs.getArgumentCount();\n\n\t\tfor (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {\n\t\t\tint index = entry.getKey();\n\t\t\tif (index < 0) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid constructor argument index: \" + index);\n\t\t\t}\n\t\t\tif (index > minNrOfArgs) {\n\t\t\t\tminNrOfArgs = index + 1;\n\t\t\t}\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addGenericArgumentValue(resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\treturn minNrOfArgs;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Resolve the prepared arguments stored in the given bean definition.\n\t */\n\tprivate Object[] resolvePreparedArguments(\n\t\t\tString beanName, RootBeanDefinition mbd, BeanWrapper bw, Executable executable, Object[] argsToResolve) {\n\n\t\tClass<?>[] paramTypes = executable.getParameterTypes();\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\tObject[] resolvedArgs = new Object[argsToResolve.length];\n\t\tfor (int argIndex = 0; argIndex < argsToResolve.length; argIndex++) {\n\t\t\tObject argValue = argsToResolve[argIndex];\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, argIndex);\n\t\t\tGenericTypeResolver.resolveParameterType(methodParam, executable.getDeclaringClass());\n\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t}\n\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t}\n\t\t\telse if (argValue instanceof String) {\n\t\t\t\targValue = this.beanFactory.evaluateBeanDefinitionString((String) argValue, mbd);\n\t\t\t}\n\t\t\tClass<?> paramType = paramTypes[argIndex];\n\t\t\ttry {\n\t\t\t\tresolvedArgs[argIndex] = converter.convertIfNecessary(argValue, paramType, methodParam);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\"Could not convert argument value of type [\" + ObjectUtils.nullSafeClassName(argValue) +\n\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs;\n\t}","id":3508,"modified_method":"/**\n\t * Resolve the prepared arguments stored in the given bean definition.\n\t */\n\tprivate Object[] resolvePreparedArguments(\n\t\t\tString beanName, RootBeanDefinition mbd, BeanWrapper bw, Executable executable, Object[] argsToResolve) {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\tClass<?>[] paramTypes = executable.getParameterTypes();\n\n\t\tObject[] resolvedArgs = new Object[argsToResolve.length];\n\t\tfor (int argIndex = 0; argIndex < argsToResolve.length; argIndex++) {\n\t\t\tObject argValue = argsToResolve[argIndex];\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, argIndex);\n\t\t\tGenericTypeResolver.resolveParameterType(methodParam, executable.getDeclaringClass());\n\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t}\n\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t}\n\t\t\telse if (argValue instanceof String) {\n\t\t\t\targValue = this.beanFactory.evaluateBeanDefinitionString((String) argValue, mbd);\n\t\t\t}\n\t\t\tClass<?> paramType = paramTypes[argIndex];\n\t\t\ttry {\n\t\t\t\tresolvedArgs[argIndex] = converter.convertIfNecessary(argValue, paramType, methodParam);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\"Could not convert argument value of type [\" + ObjectUtils.nullSafeClassName(argValue) +\n\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create an array of arguments to invoke a constructor or factory method,\n\t * given the resolved constructor argument values.\n\t */\n\tprivate ArgumentsHolder createArgumentArray(\n\t\t\tString beanName, RootBeanDefinition mbd, ConstructorArgumentValues resolvedValues,\n\t\t\tBeanWrapper bw, Class<?>[] paramTypes, String[] paramNames, Executable executable,\n\t\t\tboolean autowiring) throws UnsatisfiedDependencyException {\n\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\n\t\tArgumentsHolder args = new ArgumentsHolder(paramTypes.length);\n\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders =\n\t\t\t\tnew HashSet<>(paramTypes.length);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\n\t\tfor (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {\n\t\t\tClass<?> paramType = paramTypes[paramIndex];\n\t\t\tString paramName = (paramNames != null ? paramNames[paramIndex] : \"\");\n\t\t\t// Try to find matching constructor argument value, either indexed or generic.\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder =\n\t\t\t\t\tresolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);\n\t\t\t// If we couldn't find a direct match and are not supposed to autowire,\n\t\t\t// let's try the next generic, untyped argument value as fallback:\n\t\t\t// it could match after type conversion (for example, String -> int).\n\t\t\tif (valueHolder == null && (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {\n\t\t\t\tvalueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t}\n\t\t\tif (valueHolder != null) {\n\t\t\t\t// We found a potential match - let's give it a try.\n\t\t\t\t// Do not consider the same value definition multiple times!\n\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\tObject originalValue = valueHolder.getValue();\n\t\t\t\tObject convertedValue;\n\t\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\t\tconvertedValue = valueHolder.getConvertedValue();\n\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConstructorArgumentValues.ValueHolder sourceHolder =\n\t\t\t\t\t\t\t(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();\n\t\t\t\t\tObject sourceValue = sourceHolder.getValue();\n\t\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconvertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);\n\t\t\t\t\t\t// TODO re-enable once race condition has been found (SPR-7423)\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {\n\t\t\t\t\t\t\t// Either a converted value or still the original one: store converted value.\n\t\t\t\t\t\t\tsourceHolder.setConvertedValue(convertedValue);\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = sourceValue;\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\t\"Could not convert argument value of type [\" +\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeClassName(valueHolder.getValue()) +\n\t\t\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.arguments[paramIndex] = convertedValue;\n\t\t\t\targs.rawArguments[paramIndex] = originalValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t// No explicit match found: we're either supposed to autowire or\n\t\t\t\t// have to fail creating an argument array for the given constructor.\n\t\t\t\tif (!autowiring) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\"Ambiguous argument values for parameter of type [\" + paramType.getName() +\n\t\t\t\t\t\t\t\"] - did you specify the correct bean references as arguments?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject autowiredArgument =\n\t\t\t\t\t\t\tresolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter);\n\t\t\t\t\targs.rawArguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.arguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.preparedArguments[paramIndex] = new AutowiredArgumentMarker();\n\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, beanName);\n\t\t\tif (this.beanFactory.logger.isDebugEnabled()) {\n\t\t\t\tthis.beanFactory.logger.debug(\"Autowiring by type from bean name '\" + beanName +\n\t\t\t\t\t\t\"' via \" + (executable instanceof Constructor ? \"constructor\" : \"factory method\") +\n\t\t\t\t\t\t\" to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}","id":3509,"modified_method":"/**\n\t * Create an array of arguments to invoke a constructor or factory method,\n\t * given the resolved constructor argument values.\n\t */\n\tprivate ArgumentsHolder createArgumentArray(\n\t\t\tString beanName, RootBeanDefinition mbd, ConstructorArgumentValues resolvedValues,\n\t\t\tBeanWrapper bw, Class<?>[] paramTypes, String[] paramNames, Executable executable,\n\t\t\tboolean autowiring) throws UnsatisfiedDependencyException {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\n\t\tArgumentsHolder args = new ArgumentsHolder(paramTypes.length);\n\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders =\n\t\t\t\tnew HashSet<>(paramTypes.length);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\n\t\tfor (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {\n\t\t\tClass<?> paramType = paramTypes[paramIndex];\n\t\t\tString paramName = (paramNames != null ? paramNames[paramIndex] : \"\");\n\t\t\t// Try to find matching constructor argument value, either indexed or generic.\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder =\n\t\t\t\t\tresolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);\n\t\t\t// If we couldn't find a direct match and are not supposed to autowire,\n\t\t\t// let's try the next generic, untyped argument value as fallback:\n\t\t\t// it could match after type conversion (for example, String -> int).\n\t\t\tif (valueHolder == null && (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {\n\t\t\t\tvalueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t}\n\t\t\tif (valueHolder != null) {\n\t\t\t\t// We found a potential match - let's give it a try.\n\t\t\t\t// Do not consider the same value definition multiple times!\n\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\tObject originalValue = valueHolder.getValue();\n\t\t\t\tObject convertedValue;\n\t\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\t\tconvertedValue = valueHolder.getConvertedValue();\n\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConstructorArgumentValues.ValueHolder sourceHolder =\n\t\t\t\t\t\t\t(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();\n\t\t\t\t\tObject sourceValue = sourceHolder.getValue();\n\t\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconvertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);\n\t\t\t\t\t\t// TODO re-enable once race condition has been found (SPR-7423)\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {\n\t\t\t\t\t\t\t// Either a converted value or still the original one: store converted value.\n\t\t\t\t\t\t\tsourceHolder.setConvertedValue(convertedValue);\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = sourceValue;\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\t\"Could not convert argument value of type [\" +\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeClassName(valueHolder.getValue()) +\n\t\t\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.arguments[paramIndex] = convertedValue;\n\t\t\t\targs.rawArguments[paramIndex] = originalValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t// No explicit match found: we're either supposed to autowire or\n\t\t\t\t// have to fail creating an argument array for the given constructor.\n\t\t\t\tif (!autowiring) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\"Ambiguous argument values for parameter of type [\" + paramType.getName() +\n\t\t\t\t\t\t\t\"] - did you specify the correct bean references as arguments?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject autowiredArgument =\n\t\t\t\t\t\t\tresolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter);\n\t\t\t\t\targs.rawArguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.arguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.preparedArguments[paramIndex] = new AutowiredArgumentMarker();\n\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, beanName);\n\t\t\tif (this.beanFactory.logger.isDebugEnabled()) {\n\t\t\t\tthis.beanFactory.logger.debug(\"Autowiring by type from bean name '\" + beanName +\n\t\t\t\t\t\t\"' via \" + (executable instanceof Constructor ? \"constructor\" : \"factory method\") +\n\t\t\t\t\t\t\" to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledgment\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack = new Acknowledgment(e);\n        m_ackService.processAck(ack);\n    }","id":3510,"modified_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledge\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack;\n        try {\n            ack = new Acknowledgment(e);\n            m_ackService.processAck(ack);\n        } catch (ParseException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\t}","id":3511,"modified_method":"public void afterPropertiesSet() throws Exception {\n\t    m_ackService.setEventForwarder(m_eventForwarder);\n\t}","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment() {\n        \n    }","id":3512,"modified_method":"public Acknowledgment() {\n        this(new Date(), \"admin\");\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment(Event e) {\n        m_event = e;\n    }","id":3513,"modified_method":"public Acknowledgment(final Event e) throws ParseException {\n        this(e, \"admin\");\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void processAck(Acknowledgment ack) {\n        Log events = new Log();\n        \n        boolean hasAcknowledged = false;\n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            hasAcknowledged = true;\n            EventBuilder builder = new EventBuilder(\"ue.opennms.org/internal/acd/acknowledment\", \"Ackd\");\n            builder.addParam(\"user\", ack.getAckUser());\n            builder.addParam(\"time\", ack.getAckTime().toString());\n            //TODO: need more stuffs\n\n        }\n        \n        if (hasAcknowledged) {\n            m_ackDao.save(ack);\n            \n        }\n    }","id":3514,"modified_method":"public void processAck(Acknowledgment ack) {\n        \n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        EventBuilder ebuilder;\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            m_ackDao.save(ack);\n            ebuilder = new EventBuilder(\"uei.opennms.org/internal/ackd/acknowledgment\", \"Ackd\");\n            m_eventForwarder.sendNow(ebuilder.getEvent());\n        }\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setEventBuilder(EventBuilder eventBuilder) {\n        m_eventBuilder = eventBuilder;\n    }","id":3515,"modified_method":"public void setEventForwarder(EventForwarder eventForwarder) {\n        m_eventForwarder = eventForwarder;\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void proccessAck(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","id":3516,"modified_method":"public void processAcks(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    if (hasNotifId(msg.getSubject())) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                }\n            }\n            \n        }\n        return acks;\n    }","id":3517,"modified_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    Integer notifyId = detectId(msg.getSubject(), m_config.getNotifyidMatchExpression());\n                    \n                    if (notifyId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                    Integer alarmId = detectId(msg.getSubject(), m_config.getAlarmidMatchExpression());\n                    \n                    if (alarmId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                    continue;\n                }\n            }\n        }\n        return acks;\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":3518,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.proccessAck(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        \n        \n    }","id":3519,"modified_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.processAcks(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\t}","id":3520,"modified_method":"public void afterPropertiesSet() throws Exception {\n\t    m_ackService.setEventForwarder(m_eventForwarder);\n\t}","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledgment\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack = new Acknowledgment(e);\n        m_ackService.processAck(ack);\n    }","id":3521,"modified_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledge\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack;\n        try {\n            ack = new Acknowledgment(e);\n            m_ackService.processAck(ack);\n        } catch (ParseException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment(Event e) {\n        m_event = e;\n    }","id":3522,"modified_method":"public Acknowledgment(final Event e) throws ParseException {\n        this(e, \"admin\");\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment() {\n        \n    }","id":3523,"modified_method":"public Acknowledgment() {\n        this(new Date(), \"admin\");\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void processAck(Acknowledgment ack) {\n        Log events = new Log();\n        \n        boolean hasAcknowledged = false;\n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            hasAcknowledged = true;\n            EventBuilder builder = new EventBuilder(\"ue.opennms.org/internal/acd/acknowledment\", \"Ackd\");\n            builder.addParam(\"user\", ack.getAckUser());\n            builder.addParam(\"time\", ack.getAckTime().toString());\n            //TODO: need more stuffs\n\n        }\n        \n        if (hasAcknowledged) {\n            m_ackDao.save(ack);\n            \n        }\n    }","id":3524,"modified_method":"public void processAck(Acknowledgment ack) {\n        \n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        EventBuilder ebuilder;\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            m_ackDao.save(ack);\n            ebuilder = new EventBuilder(\"uei.opennms.org/internal/ackd/acknowledgment\", \"Ackd\");\n            m_eventForwarder.sendNow(ebuilder.getEvent());\n        }\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void proccessAck(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","id":3525,"modified_method":"public void processAcks(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setEventBuilder(EventBuilder eventBuilder) {\n        m_eventBuilder = eventBuilder;\n    }","id":3526,"modified_method":"public void setEventForwarder(EventForwarder eventForwarder) {\n        m_eventForwarder = eventForwarder;\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    if (hasNotifId(msg.getSubject())) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                }\n            }\n            \n        }\n        return acks;\n    }","id":3527,"modified_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    Integer notifyId = detectId(msg.getSubject(), m_config.getNotifyidMatchExpression());\n                    \n                    if (notifyId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                    Integer alarmId = detectId(msg.getSubject(), m_config.getAlarmidMatchExpression());\n                    \n                    if (alarmId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                    continue;\n                }\n            }\n        }\n        return acks;\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":3528,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.proccessAck(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        \n        \n    }","id":3529,"modified_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.processAcks(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledgment\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack = new Acknowledgment(e);\n        m_ackService.processAck(ack);\n    }","id":3530,"modified_method":"@EventHandler(uei=\"uei.opennms.org/internal/ackd/Acknowledge\")\n    public void handleAckEvent(Event e) {\n        Acknowledgment ack;\n        try {\n            ack = new Acknowledgment(e);\n            m_ackService.processAck(ack);\n        } catch (ParseException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\t}","id":3531,"modified_method":"public void afterPropertiesSet() throws Exception {\n\t    m_ackService.setEventForwarder(m_eventForwarder);\n\t}","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment() {\n        \n    }","id":3532,"modified_method":"public Acknowledgment() {\n        this(new Date(), \"admin\");\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment(Event e) {\n        m_event = e;\n    }","id":3533,"modified_method":"public Acknowledgment(final Event e) throws ParseException {\n        this(e, \"admin\");\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setEventBuilder(EventBuilder eventBuilder) {\n        m_eventBuilder = eventBuilder;\n    }","id":3534,"modified_method":"public void setEventForwarder(EventForwarder eventForwarder) {\n        m_eventForwarder = eventForwarder;\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void processAck(Acknowledgment ack) {\n        Log events = new Log();\n        \n        boolean hasAcknowledged = false;\n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            hasAcknowledged = true;\n            EventBuilder builder = new EventBuilder(\"ue.opennms.org/internal/acd/acknowledment\", \"Ackd\");\n            builder.addParam(\"user\", ack.getAckUser());\n            builder.addParam(\"time\", ack.getAckTime().toString());\n            //TODO: need more stuffs\n\n        }\n        \n        if (hasAcknowledged) {\n            m_ackDao.save(ack);\n            \n        }\n    }","id":3535,"modified_method":"public void processAck(Acknowledgment ack) {\n        \n        List<Acknowledgeable> ackables = m_ackDao.findAcknowledgable(ack);\n        EventBuilder ebuilder;\n        for (Acknowledgeable ackable : ackables) {\n            ackable.acknowledge(ack.getAckTime(), ack.getAckUser());\n            m_ackDao.updateAckable(ackable);\n            m_ackDao.save(ack);\n            ebuilder = new EventBuilder(\"uei.opennms.org/internal/ackd/acknowledgment\", \"Ackd\");\n            m_eventForwarder.sendNow(ebuilder.getEvent());\n        }\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void proccessAck(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","id":3536,"modified_method":"public void processAcks(Collection<Acknowledgment> acks) {\n        for (Acknowledgment ack : acks) {\n            processAck(ack);\n        }\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.proccessAck(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        \n        \n    }","id":3537,"modified_method":"private void findAndProcessAcks() {\n        \n        Collection<Acknowledgment> acks;\n\n        try {\n            List<Message> msgs = readMessages();\n            acks = detectAcks(msgs);\n            m_ackService.processAcks(acks);\n        } catch (JavaMailerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    if (hasNotifId(msg.getSubject())) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                }\n            }\n            \n        }\n        return acks;\n    }","id":3538,"modified_method":"private Collection<Acknowledgment> detectAcks(List<Message> msgs) {\n        Collection<Acknowledgment> acks = null;\n        \n        if (msgs != null) {\n            acks = new ArrayList<Acknowledgment>();\n            for (Message msg : msgs) {\n                try {\n                    Integer notifyId = detectId(msg.getSubject(), m_config.getNotifyidMatchExpression());\n                    \n                    if (notifyId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                    Integer alarmId = detectId(msg.getSubject(), m_config.getAlarmidMatchExpression());\n                    \n                    if (alarmId.intValue() > 0) {\n                        acks.add(createAcknowledgment(msg));\n                    }\n                    \n                } catch (MessagingException e) {\n                    //FIXME: do something audit like here\n                    continue;\n                }\n            }\n        }\n        return acks;\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":3539,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Processes {@link ChangeSetState#removedResourceMappings},\n     * {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#modifiedResourceMappings} of <code>changeSetState<\/code>\n     * and apply them to {@link #kbase}.\n     * The way the lists are processed is:\n     * <ol>\n     * <li>\n     * Each element of {@link ChangeSetState#removedResourceMappings} is removed\n     * from {@link #kbase} using {@link #removeKnowledgeDefinitionFromBase(org.drools.definition.KnowledgeDefinition) }.\n     * <\/li>\n     * <li>\n     * Each element of {@link ChangeSetState#modifiedResourceMappings} is compiled\n     * using {@link #createPackageFromResource(org.drools.io.Resource) } and\n     * diffed against the previous version of the resource. The diff dictates\n     * wich definitions should be removed and what should be updated. The\n     * ones that should be removed are deleted using\n     * {@link #removeKnowledgeDefinitionFromBase(org.drools.definition.KnowledgeDefinition) },\n     * the ones that should be update/added are put into\n     * {@link ChangeSetState#createdPackages} of <code>changeSetState<\/code>.\n     * <\/li>\n     * <li>\n     * Each element of {@link ChangeSetState#addedResources} is compiled\n     * using {@link #createPackageFromResource(org.drools.io.Resource) }\n     * and added to {@link ChangeSetState#createdPackages} of\n     * <code>changeSetState<\/code>.\n     * <\/li>\n     * <\/ol>\n     * Because the elements of {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#modifiedResourceMappings} were already processed and\n     * added as elements of {@link ChangeSetState#createdPackages}, these two lists\n     * are emtpied.\n     * The <code>changeSetState<\/code> is then passed to\n     * {@link #addResourcesToKnowledgeBase(org.drools.agent.impl.KnowledgeAgentImpl.ChangeSetState) }\n     * in order to process {@link ChangeSetState#createdPackages}.\n     * @param changeSetState the ChangeSetState\n     */\n    private void incrementalBuildResources(ChangeSetState changeSetState) {\n        if ( this.newInstance ) {\n            this.listener.warning( \"KnowledgeAgent incremental build of KnowledgeBase when newInstance is true\" );\n        }\n        // Incrementally rebuild the resources\n        synchronized ( this.registeredResources ) {\n            this.listener.info( \"KnowledgeAgent performing an incremental build of the ChangeSet\" );\n\n            // Create the knowledge base if one does not exist\n            if ( this.kbase == null ) {\n                this.kbase = KnowledgeBaseFactory.newKnowledgeBase();\n            }\n\n            // Remove all rules from the resources removed and also those\n            // modified\n            for ( Map.Entry<Resource, Set<KnowledgeDefinition>> entry : changeSetState.removedResourceMappings.entrySet() ) {\n                for ( KnowledgeDefinition kd : entry.getValue() ) {\n                    removeKnowledgeDefinitionFromBase( kd );\n                }\n            }\n\n            for ( Map.Entry<Resource, Set<KnowledgeDefinition>> entry : changeSetState.modifiedResourceMappings.entrySet() ) {\n\n                Collection<KnowledgePackage> newPackages = createPackageFromResource( entry.getKey() );\n\n                if ( newPackages == null || newPackages.size() == 0 ) {\n                    this.listener.warning( \"KnowledgeAgent: The resource didn't create any package: \" + entry.getKey()+\". Removing any existing knowledge definition of \"+entry.getKey() );\n\n                    for ( KnowledgeDefinition kd : entry.getValue() ) {\n                        this.listener.debug( \"KnowledgeAgent: Removing: \" + kd );\n                        removeKnowledgeDefinitionFromBase( kd );\n                    }\n                    continue;\n                }\n\n\n                for ( KnowledgePackage pkage : newPackages ) {\n\n                KnowledgePackageImp newPackage = (KnowledgePackageImp) pkage;\n\n                KnowledgePackageImp oldPackage = (KnowledgePackageImp) this.kbase.getKnowledgePackage( newPackage.getName() );\n                AbstractRuleBase abstractRuleBase = (AbstractRuleBase)((KnowledgeBaseImpl)this.kbase).ruleBase;\n                CompositeClassLoader rootClassLoader = abstractRuleBase.getRootClassLoader();\n\n                newPackage.pkg.getDialectRuntimeRegistry().onAdd( rootClassLoader );\n                newPackage.pkg.getDialectRuntimeRegistry().onBeforeExecute();\n                newPackage.pkg.getClassFieldAccessorStore().setClassFieldAccessorCache( abstractRuleBase.getClassFieldAccessorCache());\n                newPackage.pkg.getClassFieldAccessorStore().wire();\n\n                this.listener.debug( \"KnowledgeAgent: Diffing: \" + entry.getKey() );\n\n                ResourceDiffProducer rdp = new BinaryResourceDiffProducerImpl();\n\n                //we suppose that the package definition didn't change in the resource.\n                //That's why we are serching the current package as\n                //this.kbase.getKnowledgePackage(kpkg.getName())\n                ResourceDiffResult diff = rdp.diff( entry.getValue(),\n                                                    newPackage,\n                                                    oldPackage );\n\n                for ( KnowledgeDefinition kd : diff.getRemovedDefinitions() ) {\n                    this.listener.debug( \"KnowledgeAgent: Removing: \" + kd );\n                    removeKnowledgeDefinitionFromBase( kd );\n                }\n\n                //because all the mappings for \"resource\" were removed, we\n                //need to map again the definitions that didn't change.\n                //Those modified or added will be mapped in addResourcesToKnowledgeBase()\n                for ( KnowledgeDefinition knowledgeDefinition : diff.getUnmodifiedDefinitions() ) {\n                    this.addDefinitionMapping( entry.getKey(),\n                                               knowledgeDefinition,\n                                               false );\n                }\n\n                Set<KnowledgePackage> set = new HashSet<KnowledgePackage>();\n                        set.add(diff.getPkg());\n                changeSetState.createdPackages.put( entry.getKey(),\n                                                    set );\n\n                }\n            }\n\n            /*\n             * Compile the newly added resources\n             */\n            KnowledgeBuilder kBuilder = createKBuilder();\n            for ( Resource resource : changeSetState.addedResources ) {\n                ///compile the new resource\n                Collection<KnowledgePackage> kpkgs = createPackageFromResource( resource, kBuilder );\n                if ( kpkgs == null || kpkgs.size() == 0 ) {\n                    this.listener.warning( \"KnowledgeAgent: The resource didn't create any package: \" + resource );\n                    continue;\n                }\n\n                changeSetState.createdPackages.put( resource,\n                                                    new HashSet<KnowledgePackage>(kpkgs) );\n\n            }\n\n            //the added and modified resources were already processed and\n            //converted to createdPackages. We must clear the lists.\n            changeSetState.addedResources.clear();\n            changeSetState.modifiedResourceMappings.clear();\n\n            addResourcesToKnowledgeBase( changeSetState );\n\n        }\n        this.listener.info( \"KnowledgeAgent incremental build of KnowledgeBase finished and in use\" );\n    }","id":3540,"modified_method":"/**\n     * Processes {@link ChangeSetState#removedResourceMappings},\n     * {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#modifiedResourceMappings} of <code>changeSetState<\/code>\n     * and apply them to {@link #kbase}.\n     * The way the lists are processed is:\n     * <ol>\n     * <li>\n     * Each element of {@link ChangeSetState#removedResourceMappings} is removed\n     * from {@link #kbase} using {@link #removeKnowledgeDefinitionFromBase(org.drools.definition.KnowledgeDefinition) }.\n     * <\/li>\n     * <li>\n     * Each element of {@link ChangeSetState#modifiedResourceMappings} is compiled\n     * using {@link #createPackageFromResource(org.drools.io.Resource) } and\n     * diffed against the previous version of the resource. The diff dictates\n     * wich definitions should be removed and what should be updated. The\n     * ones that should be removed are deleted using\n     * {@link #removeKnowledgeDefinitionFromBase(org.drools.definition.KnowledgeDefinition) },\n     * the ones that should be update/added are put into\n     * {@link ChangeSetState#createdPackages} of <code>changeSetState<\/code>.\n     * <\/li>\n     * <li>\n     * Each element of {@link ChangeSetState#addedResources} is compiled\n     * using {@link #createPackageFromResource(org.drools.io.Resource) }\n     * and added to {@link ChangeSetState#createdPackages} of\n     * <code>changeSetState<\/code>.\n     * <\/li>\n     * <\/ol>\n     * Because the elements of {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#modifiedResourceMappings} were already processed and\n     * added as elements of {@link ChangeSetState#createdPackages}, these two lists\n     * are emtpied.\n     * The <code>changeSetState<\/code> is then passed to\n     * {@link #addResourcesToKnowledgeBase(org.drools.agent.impl.KnowledgeAgentImpl.ChangeSetState) }\n     * in order to process {@link ChangeSetState#createdPackages}.\n     * @param changeSetState the ChangeSetState\n     */\n    private void incrementalBuildResources(ChangeSetState changeSetState) {\n        if ( this.newInstance ) {\n            this.listener.warning( \"KnowledgeAgent incremental build of KnowledgeBase when newInstance is true\" );\n        }\n\n         KnowledgeBuilder kBuilder = createKBuilder();\n\n        // Incrementally rebuild the resources\n        synchronized ( this.registeredResources ) {\n            this.listener.info( \"KnowledgeAgent performing an incremental build of the ChangeSet\" );\n\n            // Create the knowledge base if one does not exist\n            if ( this.kbase == null ) {\n                this.kbase = KnowledgeBaseFactory.newKnowledgeBase();\n            }\n\n            // Remove all rules from the resources removed and also those\n            // modified\n            for ( Map.Entry<Resource, Set<KnowledgeDefinition>> entry : changeSetState.removedResourceMappings.entrySet() ) {\n                for ( KnowledgeDefinition kd : entry.getValue() ) {\n                    removeKnowledgeDefinitionFromBase( kd );\n                }\n            }\n\n            for ( Map.Entry<Resource, Set<KnowledgeDefinition>> entry : changeSetState.modifiedResourceMappings.entrySet() ) {\n\n                Collection<KnowledgePackage> newPackages = createPackageFromResource( entry.getKey() );\n\n                if ( newPackages == null || newPackages.size() == 0 ) {\n                    this.listener.warning( \"KnowledgeAgent: The resource didn't create any package: \" + entry.getKey()+\". Removing any existing knowledge definition of \"+entry.getKey() );\n\n                    for ( KnowledgeDefinition kd : entry.getValue() ) {\n                        this.listener.debug( \"KnowledgeAgent: Removing: \" + kd );\n                        removeKnowledgeDefinitionFromBase( kd );\n                    }\n                    continue;\n                }\n\n\n                for ( KnowledgePackage pkage : newPackages ) {\n\n                KnowledgePackageImp newPackage = (KnowledgePackageImp) pkage;\n\n                KnowledgePackageImp oldPackage = (KnowledgePackageImp) this.kbase.getKnowledgePackage( newPackage.getName() );\n                AbstractRuleBase abstractRuleBase = (AbstractRuleBase)((KnowledgeBaseImpl)this.kbase).ruleBase;\n                CompositeClassLoader rootClassLoader = abstractRuleBase.getRootClassLoader();\n\n                newPackage.pkg.getDialectRuntimeRegistry().onAdd( rootClassLoader );\n                newPackage.pkg.getDialectRuntimeRegistry().onBeforeExecute();\n                newPackage.pkg.getClassFieldAccessorStore().setClassFieldAccessorCache( abstractRuleBase.getClassFieldAccessorCache());\n                newPackage.pkg.getClassFieldAccessorStore().wire();\n\n                this.listener.debug( \"KnowledgeAgent: Diffing: \" + entry.getKey() );\n\n                ResourceDiffProducer rdp = new BinaryResourceDiffProducerImpl();\n\n                //we suppose that the package definition didn't change in the resource.\n                //That's why we are serching the current package as\n                //this.kbase.getKnowledgePackage(kpkg.getName())\n                ResourceDiffResult diff = rdp.diff( entry.getValue(),\n                                                    newPackage,\n                                                    oldPackage );\n\n                for ( KnowledgeDefinition kd : diff.getRemovedDefinitions() ) {\n                    this.listener.debug( \"KnowledgeAgent: Removing: \" + kd );\n                    removeKnowledgeDefinitionFromBase( kd );\n                }\n\n                //because all the mappings for \"resource\" were removed, we\n                //need to map again the definitions that didn't change.\n                //Those modified or added will be mapped in addResourcesToKnowledgeBase()\n                for ( KnowledgeDefinition knowledgeDefinition : diff.getUnmodifiedDefinitions() ) {\n                    this.addDefinitionMapping( entry.getKey(),\n                                               knowledgeDefinition,\n                                               false );\n                }\n\n                Set<KnowledgePackage> set = new HashSet<KnowledgePackage>();\n                        set.add(diff.getPkg());\n                changeSetState.createdPackages.put( entry.getKey(),\n                                                    set );\n\n                }\n            }\n\n            /*\n             * Compile the newly added resources\n             */\n            for ( Resource resource : changeSetState.addedResources ) {\n                ///compile the new resource\n                Collection<KnowledgePackage> kpkgs = createPackageFromResource( resource, kBuilder );\n                if ( kpkgs == null || kpkgs.size() == 0 ) {\n                    this.listener.warning( \"KnowledgeAgent: The resource didn't create any package: \" + resource );\n                    continue;\n                }\n\n                changeSetState.createdPackages.put( resource,\n                                                    new HashSet<KnowledgePackage>(kpkgs) );\n\n            }\n\n            //the added and modified resources were already processed and\n            //converted to createdPackages. We must clear the lists.\n            changeSetState.addedResources.clear();\n            changeSetState.modifiedResourceMappings.clear();\n\n            addResourcesToKnowledgeBase( changeSetState );\n\n        }\n        this.listener.info( \"KnowledgeAgent incremental build of KnowledgeBase finished and in use\" );\n    }","commit_id":"a7f310ced43dc9bdc08d27c5c412908207d4fa1b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Add an resource/definition entry to registeredResources. Optionaly it\n     * adds a listener to the resource added.\n     * @param resource\n     * @param definition\n     * @param notify\n     * @return if the resource/definition didn't exist in registeredResources.\n     */\n    public boolean addDefinitionMapping(Resource resource,\n                                        KnowledgeDefinition definition,\n                                        boolean notify) {\n\n        if ( resource == null ) {\n            listener.warning( \"KnowledgeAgent: impossible to add a map for a null resource! skiping.\" );\n            return false;\n        }\n\n        this.listener.debug( \"KnowledgeAgent mapping resource=\"\n                             + resource + \" to KnowledgeDefinition=\" + definition );\n\n        boolean isNewResource = this.registeredResources.isResourceMapped( resource );\n\n        boolean isNewDefinition = true;\n\n        if ( definition != null ) {\n            isNewDefinition = this.registeredResources.putDefinition( resource,\n                                                                      definition );\n        }\n\n        if ( notify && isNewResource ) {\n            this.listener.debug( \"KnowledgeAgent notifier subscribing to resource=\"\n                                 + resource );\n\n            this.notifier.subscribeResourceChangeListener( this,\n                                                           resource );\n        }\n\n        return isNewDefinition;\n    }","id":3541,"modified_method":"/**\n     * Add an resource/definition entry to registeredResources. Optionaly it\n     * adds a listener to the resource added.\n     * @param resource\n     * @param definition\n     * @param notify\n     * @return if the resource/definition didn't exist in registeredResources.\n     */\n    public boolean addDefinitionMapping(Resource resource,\n                                        KnowledgeDefinition definition,\n                                        boolean notify) {\n\n        if ( resource == null ) {\n            listener.warning( \"KnowledgeAgent: impossible to add a map for a null resource! skiping.\" );\n            return false;\n        }\n\n        this.listener.debug( \"KnowledgeAgent mapping resource=\"\n                             + resource + \" to KnowledgeDefinition=\" + definition );\n\n        boolean isNewResource = ! this.registeredResources.isResourceMapped( resource );\n\n        boolean isNewDefinition = true;\n\n        if ( definition != null ) {\n            isNewDefinition = this.registeredResources.putDefinition( resource,\n                                                                      definition );\n        }\n\n        if ( notify && isNewResource ) {\n            this.listener.debug( \"KnowledgeAgent notifier subscribing to resource=\"\n                                 + resource );\n\n            this.notifier.subscribeResourceChangeListener( this,\n                                                           resource );\n        }\n\n        return isNewDefinition;\n    }","commit_id":"a7f310ced43dc9bdc08d27c5c412908207d4fa1b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Adds the resources to the current KnowledgeBase on this KnowledgeAgent.\n     * This method processes {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#createdPackages} lists in two different ways:\n     * <ul>\n     * <li>\n     * The elments of {@link ChangeSetState#addedResources} are compiled using\n     * {@link #createPackageFromResource(org.drools.io.Resource, org.drools.builder.KnowledgeBuilder)}\n     * and added to {@link ChangeSetState#createdPackages}. The same kbuilder\n     * is used for all the elements.\n     * <\/li>\n     * <li>\n     * The elments of {@link ChangeSetState#createdPackages} are added to\n     * {@link #kbase}. Each package is mapped to the original resource\n     * using {@link #buildResourceMapping(org.drools.rule.Package, org.drools.io.Resource)}.\n     * <\/li>\n     * <\/ul>\n     *\n     *\n     * @param changeSetState the object containing the added resources list and\n     * created pacages list.\n     */\n    private void addResourcesToKnowledgeBase(ChangeSetState changeSetState) {\n\n        if (changeSetState.addedResources.size() > 0) {\n            KnowledgeBuilder builder = createKBuilder();\n            for ( Resource resource : changeSetState.addedResources ) {\n                Collection<KnowledgePackage> createdPackages = this.createPackageFromResource( resource, builder );\n                Set<KnowledgePackage> packs = changeSetState.createdPackages.get(resource);\n                if ( packs == null ) {\n                    packs = new HashSet<KnowledgePackage>();\n                    changeSetState.createdPackages.put( resource, packs );\n                }\n                packs.addAll(createdPackages);\n            }\n        }\n\n        for ( Resource resource : changeSetState.createdPackages.keySet() ) {\n            this.kbase.addKnowledgePackages(changeSetState.createdPackages.get(resource));\n        }\n\n        autoBuildResourceMapping();\n\n    }","id":3542,"modified_method":"/**\n     * Adds the resources to the current KnowledgeBase on this KnowledgeAgent.\n     * This method processes {@link ChangeSetState#addedResources} and\n     * {@link ChangeSetState#createdPackages} lists in two different ways:\n     * <ul>\n     * <li>\n     * The elments of {@link ChangeSetState#addedResources} are compiled using\n     * {@link #createPackageFromResource(org.drools.io.Resource, org.drools.builder.KnowledgeBuilder)}\n     * and added to {@link ChangeSetState#createdPackages}. The same kbuilder\n     * is used for all the elements.\n     * <\/li>\n     * <li>\n     * The elments of {@link ChangeSetState#createdPackages} are added to\n     * {@link #kbase}. Each package is mapped to the original resource\n     * using {@link #buildResourceMapping(org.drools.rule.Package, org.drools.io.Resource)}.\n     * <\/li>\n     * <\/ul>\n     *\n     *\n     * @param changeSetState the object containing the added resources list and\n     * created pacages list.\n     */\n    private void addResourcesToKnowledgeBase(ChangeSetState changeSetState) {\n\n        if (changeSetState.addedResources.size() > 0) {\n            KnowledgeBuilder builder = createKBuilder();\n            for ( Resource resource : changeSetState.addedResources ) {\n                Collection<KnowledgePackage> createdPackages = this.createPackageFromResource( resource, builder );\n                Set<KnowledgePackage> packs = changeSetState.createdPackages.get(resource);\n                if ( packs == null ) {\n                    packs = new HashSet<KnowledgePackage>();\n                    changeSetState.createdPackages.put( resource, packs );\n                }\n                packs.addAll(createdPackages);\n            }\n        }\n\n        Set<KnowledgePackage> createdDistinctPackages = new HashSet<KnowledgePackage>();\n        for ( Resource resource : changeSetState.createdPackages.keySet() ) {\n            createdDistinctPackages.addAll(changeSetState.createdPackages.get(resource));\n        }\n        this.kbase.addKnowledgePackages(createdDistinctPackages);\n\n        autoBuildResourceMapping();\n\n    }","commit_id":"a7f310ced43dc9bdc08d27c5c412908207d4fa1b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Iterates over the pkg's definitions and maps it to resource.\n     * If autoDiscoverResource is set to true, the resource used in the mapping\n     * will be taken from each definition. In this case, the parameter <code>\n     * resource<\/code> is not used and should be null. This is useful for packages\n     * that contains definitions from more than one resource.\n     * If <code>autoDiscoverResource<\/code> is false and <code>resource<\/code>\n     * is null, this method does nothig.\n     * @param pkg the definitions present in this package will be iterated and\n     * mapped to <code>resource<\/code>\n     * @param resource The resouce where the pkg's definition will be mapped. If\n     * <code>autoDiscoverResource<\/code> is true, this parameter should be null;\n     * it will not be used.\n     * @param autoDiscoverResource if set to true, the resource to do the mapping\n     * will be taken from each definition. If that is the case, the parameter\n     * <code>resource<\/code> is not used.\n     */\n    private void buildResourceMapping(Package pkg,\n                                      Resource resource,\n                                      boolean autoDiscoverResource) {\n\n        synchronized ( this.registeredResources ) {\n            if ( !autoDiscoverResource && resource == null ) {\n                this.listener.warning( \"KnowledgeAgent: Impossible to map to a null resource! Use autoDiscoverResource = true \" );\n                return;\n            }\n\n            if ( autoDiscoverResource && resource != null ) {\n                this.listener.warning( \"KnowledgeAgent: building resource map with resource set and autoDiscoverResource=true. Resource value wil be overwritten!\" );\n            }\n\n            for ( Rule rule : pkg.getRules() ) {\n                if ( resource != null && !((InternalResource) resource).hasURL() ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for rule=\"\n                                         + rule );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = rule.getResource();\n                }\n\n                this.addDefinitionMapping( resource,\n                                           rule,\n                                           true );\n            }\n\n            for ( Process process : pkg.getRuleFlows().values() ) {\n                if ( resource != null && !((InternalResource) resource).hasURL() ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for process=\"\n                                         + process );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = ((ResourcedObject) process).getResource();\n                }\n\n                this.addDefinitionMapping( resource,\n                                           process,\n                                           true );\n            }\n\n            for ( TypeDeclaration typeDeclaration : pkg.getTypeDeclarations().values() ) {\n                if ( resource != null && !((InternalResource) resource).hasURL() ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for type=\"\n                                         + typeDeclaration );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = typeDeclaration.getResource();\n                }\n\n                this.addDefinitionMapping( resource,\n                                           typeDeclaration,\n                                           true );\n            }\n\n            for ( Function function : pkg.getFunctions().values() ) {\n                if ( resource != null && !((InternalResource) resource).hasURL() ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for function=\"\n                                         + function );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = function.getResource();\n                }\n                this.addDefinitionMapping( resource,\n                                           function,\n                                           true );\n            }\n        }\n    }","id":3543,"modified_method":"/**\n     * Iterates over the pkg's definitions and maps it to resource.\n     * If autoDiscoverResource is set to true, the resource used in the mapping\n     * will be taken from each definition. In this case, the parameter <code>\n     * resource<\/code> is not used and should be null. This is useful for packages\n     * that contains definitions from more than one resource.\n     * If <code>autoDiscoverResource<\/code> is false and <code>resource<\/code>\n     * is null, this method does nothig.\n     * @param pkg the definitions present in this package will be iterated and\n     * mapped to <code>resource<\/code>\n     * @param resource The resouce where the pkg's definition will be mapped. If\n     * <code>autoDiscoverResource<\/code> is true, this parameter should be null;\n     * it will not be used.\n     * @param autoDiscoverResource if set to true, the resource to do the mapping\n     * will be taken from each definition. If that is the case, the parameter\n     * <code>resource<\/code> is not used.\n     */\n    private void buildResourceMapping(Package pkg,\n                                      Resource resource,\n                                      boolean autoDiscoverResource) {\n\n        synchronized ( this.registeredResources ) {\n            if ( !autoDiscoverResource && resource == null ) {\n                this.listener.warning( \"KnowledgeAgent: Impossible to map to a null resource! Use autoDiscoverResource = true \" );\n                return;\n            }\n\n            if ( autoDiscoverResource && resource != null ) {\n                this.listener.warning( \"KnowledgeAgent: building resource map with resource set and autoDiscoverResource=true. Resource value wil be overwritten!\" );\n            }\n\n            for ( Rule rule : pkg.getRules() ) {\n                if ( resource == null ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for rule=\"\n                                         + rule );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = rule.getResource();\n                }\n\n                if ( isNewDefinition( resource, rule ) ) {\n                    this.addDefinitionMapping( resource,\n                                               rule,\n                                               true );\n                }\n            }\n\n            for ( Process process : pkg.getRuleFlows().values() ) {\n                if ( resource == null ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for process=\"\n                                         + process );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = ((ResourcedObject) process).getResource();\n                }\n\n                if ( isNewDefinition( resource, process ) ) {\n                    this.addDefinitionMapping( resource,\n                                               process,\n                                               true );\n                }\n            }\n\n            for ( TypeDeclaration typeDeclaration : pkg.getTypeDeclarations().values() ) {\n                if ( resource == null ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for type=\"\n                                         + typeDeclaration );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = typeDeclaration.getResource();\n                }\n\n                if ( isNewDefinition( resource, typeDeclaration ) ) {\n                    this.addDefinitionMapping( resource,\n                                               typeDeclaration,\n                                               true );\n                }\n            }\n\n            for ( Function function : pkg.getFunctions().values() ) {\n                if ( resource != null && !((InternalResource) resource).hasURL() ) {\n                    this.listener.debug( \"KnowledgeAgent no resource mapped for function=\"\n                                         + function );\n                }\n                if ( autoDiscoverResource ) {\n                    resource = function.getResource();\n                }\n                if ( isNewDefinition( resource, function ) ) {\n                    this.addDefinitionMapping( resource,\n                                               function,\n                                               true );\n                }\n            }\n        }\n    }","commit_id":"a7f310ced43dc9bdc08d27c5c412908207d4fa1b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                firstEntryPosition );\n        return firstEntryPosition;\n    }","id":3544,"modified_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        return firstEntryPosition;\n    }","commit_id":"8a9ffd2a076bcbc7b4d05a20e609b3f5421747ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":3545,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"8a9ffd2a076bcbc7b4d05a20e609b3f5421747ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":3546,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"9c20936d3903fbb51c7fe811e9ce178f6fe74121","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                firstEntryPosition );\n        return firstEntryPosition;\n    }","id":3547,"modified_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        return firstEntryPosition;\n    }","commit_id":"9c20936d3903fbb51c7fe811e9ce178f6fe74121","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                firstEntryPosition );\n        return firstEntryPosition;\n    }","id":3548,"modified_method":"private long getFirstStartEntry( long endPosition )\n    {\n        long firstEntryPosition = endPosition;\n        for ( LogEntry.Start entry : xidIdentMap.values() )\n        {\n            if ( entry.getStartPosition() < firstEntryPosition )\n            {\n                assert entry.getStartPosition() > 0; \n                firstEntryPosition = entry.getStartPosition();\n            }\n        }\n        return firstEntryPosition;\n    }","commit_id":"ab85710f461d9f24be6433b55b65dca2b921110b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":3549,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"ab85710f461d9f24be6433b55b65dca2b921110b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Get a listing of all the snapshots of a snapshottable directory\n   */\n  private static DirectoryListing getSnapshotsListing(\n      FSDirectory fsd, String src, byte[] startAfter)\n      throws IOException {\n    Preconditions.checkState(fsd.hasReadLock());\n    Preconditions.checkArgument(\n        src.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR),\n        \"%s does not end with %s\", src, HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR);\n\n    final String dirPath = FSDirectory.normalizePath(src.substring(0,\n        src.length() - HdfsConstants.DOT_SNAPSHOT_DIR.length()));\n\n    final INode node = fsd.getINode(dirPath);\n    final INodeDirectory dirNode = INodeDirectory.valueOf(node, dirPath);\n    final DirectorySnapshottableFeature sf = dirNode.getDirectorySnapshottableFeature();\n    if (sf == null) {\n      throw new SnapshotException(\n          \"Directory is not a snapshottable directory: \" + dirPath);\n    }\n    final ReadOnlyList<Snapshot> snapshots = sf.getSnapshotList();\n    int skipSize = ReadOnlyList.Util.binarySearch(snapshots, startAfter);\n    skipSize = skipSize < 0 ? -skipSize - 1 : skipSize + 1;\n    int numOfListing = Math.min(snapshots.size() - skipSize, fsd.getLsLimit());\n    final HdfsFileStatus listing[] = new HdfsFileStatus[numOfListing];\n    for (int i = 0; i < numOfListing; i++) {\n      Snapshot.Root sRoot = snapshots.get(i + skipSize).getRoot();\n      listing[i] = createFileStatus(fsd, src, sRoot.getLocalNameBytes(), sRoot,\n          HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED, Snapshot.CURRENT_STATE_ID,\n          false, INodesInPath.fromINode(sRoot));\n    }\n    return new DirectoryListing(\n        listing, snapshots.size() - skipSize - numOfListing);\n  }","id":3550,"modified_method":"/**\n   * Get a listing of all the snapshots of a snapshottable directory\n   */\n  private static DirectoryListing getSnapshotsListing(\n      FSDirectory fsd, String src, byte[] startAfter)\n      throws IOException {\n    Preconditions.checkState(fsd.hasReadLock());\n    Preconditions.checkArgument(\n        src.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR),\n        \"%s does not end with %s\", src, HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR);\n\n    final String dirPath = FSDirectory.normalizePath(src.substring(0,\n        src.length() - HdfsConstants.DOT_SNAPSHOT_DIR.length()));\n\n    final INode node = fsd.getINode(dirPath);\n    final INodeDirectory dirNode = INodeDirectory.valueOf(node, dirPath);\n    final DirectorySnapshottableFeature sf = dirNode.getDirectorySnapshottableFeature();\n    if (sf == null) {\n      throw new SnapshotException(\n          \"Directory is not a snapshottable directory: \" + dirPath);\n    }\n    final ReadOnlyList<Snapshot> snapshots = sf.getSnapshotList();\n    int skipSize = ReadOnlyList.Util.binarySearch(snapshots, startAfter);\n    skipSize = skipSize < 0 ? -skipSize - 1 : skipSize + 1;\n    int numOfListing = Math.min(snapshots.size() - skipSize, fsd.getLsLimit());\n    final HdfsFileStatus listing[] = new HdfsFileStatus[numOfListing];\n    for (int i = 0; i < numOfListing; i++) {\n      Snapshot.Root sRoot = snapshots.get(i + skipSize).getRoot();\n      INodeAttributes nodeAttrs = getINodeAttributes(\n          fsd, src, sRoot.getLocalNameBytes(),\n          node, Snapshot.CURRENT_STATE_ID);\n      listing[i] = createFileStatus(\n          fsd, sRoot.getLocalNameBytes(),\n          sRoot, nodeAttrs,\n          HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,\n          Snapshot.CURRENT_STATE_ID, false,\n          INodesInPath.fromINode(sRoot));\n    }\n    return new DirectoryListing(\n        listing, snapshots.size() - skipSize - numOfListing);\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * create an hdfs file status from an inode\n   *\n   * @param fsd FSDirectory\n   * @param path the local name\n   * @param node inode\n   * @param needLocation if block locations need to be included or not\n   * @param isRawPath true if this is being called on behalf of a path in\n   *                  /.reserved/raw\n   * @return a file status\n   * @throws java.io.IOException if any error occurs\n   */\n  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, String fullPath, byte[] path, INode node,\n      boolean needLocation, byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip)\n      throws IOException {\n    if (needLocation) {\n      return createLocatedFileStatus(fsd, fullPath, path, node, storagePolicy,\n          snapshot, isRawPath, iip);\n    } else {\n      return createFileStatus(fsd, fullPath, path, node, storagePolicy, snapshot,\n          isRawPath, iip);\n    }\n  }","id":3551,"modified_method":"/**\n   * Create FileStatus by file INode\n   */\n  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size = 0;     // length is zero for directories\n    short replication = 0;\n    long blocksize = 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo = isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode = node.asFile();\n      size = fileNode.computeFileSize(snapshot);\n      replication = fileNode.getFileReplication(snapshot);\n      blocksize = fileNode.getPreferredBlockSize();\n      isEncrypted = (feInfo != null) ||\n          (isRawPath && fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted = fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum = node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Create FileStatus with location info by file INode\n   */\n  private static HdfsLocatedFileStatus createLocatedFileStatus(\n      FSDirectory fsd, String fullPath, byte[] path, INode node,\n      byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip) throws IOException {\n    assert fsd.hasReadLock();\n    long size = 0; // length is zero for directories\n    short replication = 0;\n    long blocksize = 0;\n    LocatedBlocks loc = null;\n    final boolean isEncrypted;\n    final FileEncryptionInfo feInfo = isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n    if (node.isFile()) {\n      final INodeFile fileNode = node.asFile();\n      size = fileNode.computeFileSize(snapshot);\n      replication = fileNode.getFileReplication(snapshot);\n      blocksize = fileNode.getPreferredBlockSize();\n\n      final boolean inSnapshot = snapshot != Snapshot.CURRENT_STATE_ID;\n      final boolean isUc = !inSnapshot && fileNode.isUnderConstruction();\n      final long fileSize = !inSnapshot && isUc ?\n          fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n\n      loc = fsd.getFSNamesystem().getBlockManager().createLocatedBlocks(\n          fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n          inSnapshot, feInfo);\n      if (loc == null) {\n        loc = new LocatedBlocks();\n      }\n      isEncrypted = (feInfo != null) ||\n          (isRawPath && fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted = fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n    int childrenNum = node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs =\n        fsd.getAttributes(fullPath, path, node, snapshot);\n    HdfsLocatedFileStatus status =\n        new HdfsLocatedFileStatus(size, node.isDirectory(), replication,\n          blocksize, node.getModificationTime(snapshot),\n          node.getAccessTime(snapshot),\n          getPermissionForFileStatus(nodeAttrs, isEncrypted),\n          nodeAttrs.getUserName(), nodeAttrs.getGroupName(),\n          node.isSymlink() ? node.asSymlink().getSymlink() : null, path,\n          node.getId(), loc, childrenNum, feInfo, storagePolicy);\n    // Set caching information for the located blocks.\n    if (loc != null) {\n      CacheManager cacheManager = fsd.getFSNamesystem().getCacheManager();\n      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n        cacheManager.setCachedLocations(lb);\n      }\n    }\n    return status;\n  }","id":3552,"modified_method":"/**\n   * Create FileStatus with location info by file INode\n   */\n  private static HdfsLocatedFileStatus createLocatedFileStatus(\n      FSDirectory fsd, byte[] path, INode node, INodeAttributes nodeAttrs,\n      byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    assert fsd.hasReadLock();\n    long size = 0; // length is zero for directories\n    short replication = 0;\n    long blocksize = 0;\n    LocatedBlocks loc = null;\n    final boolean isEncrypted;\n    final FileEncryptionInfo feInfo = isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n    if (node.isFile()) {\n      final INodeFile fileNode = node.asFile();\n      size = fileNode.computeFileSize(snapshot);\n      replication = fileNode.getFileReplication(snapshot);\n      blocksize = fileNode.getPreferredBlockSize();\n\n      final boolean inSnapshot = snapshot != Snapshot.CURRENT_STATE_ID;\n      final boolean isUc = !inSnapshot && fileNode.isUnderConstruction();\n      final long fileSize = !inSnapshot && isUc ?\n          fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n\n      loc = fsd.getFSNamesystem().getBlockManager().createLocatedBlocks(\n          fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n          inSnapshot, feInfo);\n      if (loc == null) {\n        loc = new LocatedBlocks();\n      }\n      isEncrypted = (feInfo != null) ||\n          (isRawPath && fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted = fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n    int childrenNum = node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    HdfsLocatedFileStatus status =\n        new HdfsLocatedFileStatus(size, node.isDirectory(), replication,\n          blocksize, node.getModificationTime(snapshot),\n          node.getAccessTime(snapshot),\n          getPermissionForFileStatus(nodeAttrs, isEncrypted),\n          nodeAttrs.getUserName(), nodeAttrs.getGroupName(),\n          node.isSymlink() ? node.asSymlink().getSymlink() : null, path,\n          node.getId(), loc, childrenNum, feInfo, storagePolicy);\n    // Set caching information for the located blocks.\n    if (loc != null) {\n      CacheManager cacheManager = fsd.getFSNamesystem().getCacheManager();\n      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n        cacheManager.setCachedLocations(lb);\n      }\n    }\n    return status;\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Create FileStatus by file INode\n   */\n  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, String fullPath, byte[] path, INode node,\n      byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip) throws IOException {\n     long size = 0;     // length is zero for directories\n     short replication = 0;\n     long blocksize = 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo = isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode = node.asFile();\n       size = fileNode.computeFileSize(snapshot);\n       replication = fileNode.getFileReplication(snapshot);\n       blocksize = fileNode.getPreferredBlockSize();\n       isEncrypted = (feInfo != null) ||\n           (isRawPath && fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted = fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum = node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     INodeAttributes nodeAttrs =\n         fsd.getAttributes(fullPath, path, node, snapshot);\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }","id":3553,"modified_method":"/**\n   * create an hdfs file status from an inode\n   *\n   * @param fsd FSDirectory\n   * @param path the local name\n   * @param node inode\n   * @param needLocation if block locations need to be included or not\n   * @param isRawPath true if this is being called on behalf of a path in\n   *                  /.reserved/raw\n   * @return a file status\n   * @throws java.io.IOException if any error occurs\n   */\n  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node, INodeAttributes nodeAttrs,\n      boolean needLocation, byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip)\n      throws IOException {\n    if (needLocation) {\n      return createLocatedFileStatus(fsd, path, node, nodeAttrs, storagePolicy,\n                                     snapshot, isRawPath, iip);\n    } else {\n      return createFileStatus(fsd, path, node, nodeAttrs, storagePolicy,\n                              snapshot, isRawPath, iip);\n    }\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Get a partial listing of the indicated directory\n   *\n   * We will stop when any of the following conditions is met:\n   * 1) this.lsLimit files have been added\n   * 2) needLocation is true AND enough files have been added such\n   * that at least this.lsLimit block locations are in the response\n   *\n   * @param fsd FSDirectory\n   * @param iip the INodesInPath instance containing all the INodes along the\n   *            path\n   * @param src the directory name\n   * @param startAfter the name to start listing after\n   * @param needLocation if block locations are returned\n   * @return a partial listing starting after startAfter\n   */\n  private static DirectoryListing getListing(FSDirectory fsd, INodesInPath iip,\n      String src, byte[] startAfter, boolean needLocation, boolean isSuperUser)\n      throws IOException {\n    String srcs = FSDirectory.normalizePath(src);\n    final boolean isRawPath = FSDirectory.isReservedRawName(src);\n\n    fsd.readLock();\n    try {\n      if (srcs.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR)) {\n        return getSnapshotsListing(fsd, srcs, startAfter);\n      }\n      final int snapshot = iip.getPathSnapshotId();\n      final INode targetNode = iip.getLastINode();\n      if (targetNode == null)\n        return null;\n      byte parentStoragePolicy = isSuperUser ?\n          targetNode.getStoragePolicyID() : HdfsConstantsClient\n          .BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n\n      if (!targetNode.isDirectory()) {\n        return new DirectoryListing(\n            new HdfsFileStatus[]{createFileStatus(fsd, src,\n                HdfsFileStatus.EMPTY_NAME, targetNode, needLocation,\n                parentStoragePolicy, snapshot, isRawPath, iip)}, 0);\n      }\n\n      final INodeDirectory dirInode = targetNode.asDirectory();\n      final ReadOnlyList<INode> contents = dirInode.getChildrenList(snapshot);\n      int startChild = INodeDirectory.nextChild(contents, startAfter);\n      int totalNumChildren = contents.size();\n      int numOfListing = Math.min(totalNumChildren - startChild,\n          fsd.getLsLimit());\n      int locationBudget = fsd.getLsLimit();\n      int listingCnt = 0;\n      HdfsFileStatus listing[] = new HdfsFileStatus[numOfListing];\n      for (int i=0; i<numOfListing && locationBudget>0; i++) {\n        INode cur = contents.get(startChild+i);\n        byte curPolicy = isSuperUser && !cur.isSymlink()?\n            cur.getLocalStoragePolicyID():\n            HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n        listing[i] = createFileStatus(fsd, src, cur.getLocalNameBytes(), cur,\n            needLocation, getStoragePolicyID(curPolicy,\n                parentStoragePolicy), snapshot, isRawPath, iip);\n        listingCnt++;\n        if (needLocation) {\n            // Once we  hit lsLimit locations, stop.\n            // This helps to prevent excessively large response payloads.\n            // Approximate #locations with locatedBlockCount() * repl_factor\n            LocatedBlocks blks =\n                ((HdfsLocatedFileStatus)listing[i]).getBlockLocations();\n            locationBudget -= (blks == null) ? 0 :\n               blks.locatedBlockCount() * listing[i].getReplication();\n        }\n      }\n      // truncate return array if necessary\n      if (listingCnt < numOfListing) {\n          listing = Arrays.copyOf(listing, listingCnt);\n      }\n      return new DirectoryListing(\n          listing, totalNumChildren-startChild-listingCnt);\n    } finally {\n      fsd.readUnlock();\n    }\n  }","id":3554,"modified_method":"/**\n   * Get a partial listing of the indicated directory\n   *\n   * We will stop when any of the following conditions is met:\n   * 1) this.lsLimit files have been added\n   * 2) needLocation is true AND enough files have been added such\n   * that at least this.lsLimit block locations are in the response\n   *\n   * @param fsd FSDirectory\n   * @param iip the INodesInPath instance containing all the INodes along the\n   *            path\n   * @param src the directory name\n   * @param startAfter the name to start listing after\n   * @param needLocation if block locations are returned\n   * @return a partial listing starting after startAfter\n   */\n  private static DirectoryListing getListing(FSDirectory fsd, INodesInPath iip,\n      String src, byte[] startAfter, boolean needLocation, boolean isSuperUser)\n      throws IOException {\n    String srcs = FSDirectory.normalizePath(src);\n    final boolean isRawPath = FSDirectory.isReservedRawName(src);\n\n    fsd.readLock();\n    try {\n      if (srcs.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR)) {\n        return getSnapshotsListing(fsd, srcs, startAfter);\n      }\n      final int snapshot = iip.getPathSnapshotId();\n      final INode targetNode = iip.getLastINode();\n      if (targetNode == null)\n        return null;\n      byte parentStoragePolicy = isSuperUser ?\n          targetNode.getStoragePolicyID() : HdfsConstantsClient\n          .BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n\n      if (!targetNode.isDirectory()) {\n        INodeAttributes nodeAttrs = getINodeAttributes(\n            fsd, src, HdfsFileStatus.EMPTY_NAME, targetNode,\n            snapshot);\n        return new DirectoryListing(\n            new HdfsFileStatus[]{ createFileStatus(\n                fsd, HdfsFileStatus.EMPTY_NAME, targetNode, nodeAttrs,\n                needLocation, parentStoragePolicy, snapshot, isRawPath, iip)\n            }, 0);\n      }\n\n      final INodeDirectory dirInode = targetNode.asDirectory();\n      final ReadOnlyList<INode> contents = dirInode.getChildrenList(snapshot);\n      int startChild = INodeDirectory.nextChild(contents, startAfter);\n      int totalNumChildren = contents.size();\n      int numOfListing = Math.min(totalNumChildren - startChild,\n          fsd.getLsLimit());\n      int locationBudget = fsd.getLsLimit();\n      int listingCnt = 0;\n      HdfsFileStatus listing[] = new HdfsFileStatus[numOfListing];\n      for (int i=0; i<numOfListing && locationBudget>0; i++) {\n        INode cur = contents.get(startChild+i);\n        byte curPolicy = isSuperUser && !cur.isSymlink()?\n            cur.getLocalStoragePolicyID():\n            HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n        INodeAttributes nodeAttrs = getINodeAttributes(\n            fsd, src, cur.getLocalNameBytes(), cur,\n            snapshot);\n        listing[i] = createFileStatus(fsd, cur.getLocalNameBytes(),\n            cur, nodeAttrs, needLocation, getStoragePolicyID(curPolicy,\n                parentStoragePolicy), snapshot, isRawPath, iip);\n        listingCnt++;\n        if (needLocation) {\n            // Once we  hit lsLimit locations, stop.\n            // This helps to prevent excessively large response payloads.\n            // Approximate #locations with locatedBlockCount() * repl_factor\n            LocatedBlocks blks =\n                ((HdfsLocatedFileStatus)listing[i]).getBlockLocations();\n            locationBudget -= (blks == null) ? 0 :\n               blks.locatedBlockCount() * listing[i].getReplication();\n        }\n      }\n      // truncate return array if necessary\n      if (listingCnt < numOfListing) {\n          listing = Arrays.copyOf(listing, listingCnt);\n      }\n      return new DirectoryListing(\n          listing, totalNumChildren-startChild-listingCnt);\n    } finally {\n      fsd.readUnlock();\n    }\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Returns an inode's FsPermission for use in an outbound FileStatus.  If the\n   * inode has an ACL or is for an encrypted file/dir, then this method will\n   * return an FsPermissionExtension.\n   *\n   * @param node INode to check\n   * @param snapshot int snapshot ID\n   * @param isEncrypted boolean true if the file/dir is encrypted\n   * @return FsPermission from inode, with ACL bit on if the inode has an ACL\n   * and encrypted bit on if it represents an encrypted file/dir.\n   */\n  private static FsPermission getPermissionForFileStatus(\n      INodeAttributes node, boolean isEncrypted) {\n    FsPermission perm = node.getFsPermission();\n    boolean hasAcl = node.getAclFeature() != null;\n    if (hasAcl || isEncrypted) {\n      perm = new FsPermissionExtension(perm, hasAcl, isEncrypted);\n    }\n    return perm;\n  }","id":3555,"modified_method":"/**\n   * Returns an inode's FsPermission for use in an outbound FileStatus.  If the\n   * inode has an ACL or is for an encrypted file/dir, then this method will\n   * return an FsPermissionExtension.\n   *\n   * @param node INode to check\n   * @param isEncrypted boolean true if the file/dir is encrypted\n   * @return FsPermission from inode, with ACL bit on if the inode has an ACL\n   * and encrypted bit on if it represents an encrypted file/dir.\n   */\n  private static FsPermission getPermissionForFileStatus(\n      INodeAttributes node, boolean isEncrypted) {\n    FsPermission perm = node.getFsPermission();\n    boolean hasAcl = node.getAclFeature() != null;\n    if (hasAcl || isEncrypted) {\n      perm = new FsPermissionExtension(perm, hasAcl, isEncrypted);\n    }\n    return perm;\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/** Get the file info for a specific file.\n   * @param fsd FSDirectory\n   * @param src The string representation of the path to the file\n   * @param isRawPath true if a /.reserved/raw pathname was passed by the user\n   * @param includeStoragePolicy whether to include storage policy\n   * @return object containing information regarding the file\n   *         or null if file not found\n   */\n  static HdfsFileStatus getFileInfo(\n      FSDirectory fsd, String path, INodesInPath src, boolean isRawPath,\n      boolean includeStoragePolicy)\n      throws IOException {\n    fsd.readLock();\n    try {\n      final INode i = src.getLastINode();\n      byte policyId = includeStoragePolicy && i != null && !i.isSymlink() ?\n          i.getStoragePolicyID() : HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n      return i == null ? null : createFileStatus(\n          fsd, path, HdfsFileStatus.EMPTY_NAME, i, policyId,\n          src.getPathSnapshotId(), isRawPath, src);\n    } finally {\n      fsd.readUnlock();\n    }\n  }","id":3556,"modified_method":"/** Get the file info for a specific file.\n   * @param fsd FSDirectory\n   * @param src The string representation of the path to the file\n   * @param isRawPath true if a /.reserved/raw pathname was passed by the user\n   * @param includeStoragePolicy whether to include storage policy\n   * @return object containing information regarding the file\n   *         or null if file not found\n   */\n  static HdfsFileStatus getFileInfo(\n      FSDirectory fsd, String path, INodesInPath src, boolean isRawPath,\n      boolean includeStoragePolicy)\n      throws IOException {\n    fsd.readLock();\n    try {\n      final INode i = src.getLastINode();\n      if (i == null) {\n        return null;\n      }\n\n      byte policyId = includeStoragePolicy && !i.isSymlink() ?\n          i.getStoragePolicyID() : HdfsConstantsClient\n          .BLOCK_STORAGE_POLICY_ID_UNSPECIFIED;\n      INodeAttributes nodeAttrs = getINodeAttributes(\n          fsd, path, HdfsFileStatus.EMPTY_NAME, i, src.getPathSnapshotId());\n      return createFileStatus(\n          fsd, HdfsFileStatus.EMPTY_NAME,\n          i, nodeAttrs, policyId,\n          src.getPathSnapshotId(),\n          isRawPath, src);\n    } finally {\n      fsd.readUnlock();\n    }\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"@SuppressWarnings(\"deprecation\")\n  private long applyEditLogOp(FSEditLogOp op, FSDirectory fsDir,\n      StartupOption startOpt, int logVersion, long lastInodeId) throws IOException {\n    long inodeId = HdfsConstantsClient.GRANDFATHER_INODE_ID;\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"replaying edit log: \" + op);\n    }\n    final boolean toAddRetryCache = fsNamesys.hasRetryCache() && op.hasRpcIds();\n\n    switch (op.opCode) {\n    case OP_ADD: {\n      AddCloseOp addCloseOp = (AddCloseOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(addCloseOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + addCloseOp.blocks.length +\n            \" clientHolder \" + addCloseOp.clientName +\n            \" clientMachine \" + addCloseOp.clientMachine);\n      }\n      // There are 3 cases here:\n      // 1. OP_ADD to create a new file\n      // 2. OP_ADD to update file blocks\n      // 3. OP_ADD to open file for append (old append)\n\n      // See if the file already exists (persistBlocks call)\n      INodesInPath iip = fsDir.getINodesInPath(path, true);\n      INodeFile oldFile = INodeFile.valueOf(iip.getLastINode(), path, true);\n      if (oldFile != null && addCloseOp.overwrite) {\n        // This is OP_ADD with overwrite\n        FSDirDeleteOp.deleteForEditLog(fsDir, path, addCloseOp.mtime);\n        iip = INodesInPath.replace(iip, iip.length() - 1, null);\n        oldFile = null;\n      }\n      INodeFile newFile = oldFile;\n      if (oldFile == null) { // this is OP_ADD on a new file (case 1)\n        // versions > 0 support per file replication\n        // get name and replication\n        final short replication = fsNamesys.getBlockManager()\n            .adjustReplication(addCloseOp.replication);\n        assert addCloseOp.blocks.length == 0;\n\n        // add to the file tree\n        inodeId = getAndUpdateLastInodeId(addCloseOp.inodeId, logVersion, lastInodeId);\n        newFile = fsDir.addFileForEditLog(inodeId, iip.getExistingINodes(),\n            iip.getLastLocalName(),\n            addCloseOp.permissions,\n            addCloseOp.aclEntries,\n            addCloseOp.xAttrs, replication,\n            addCloseOp.mtime, addCloseOp.atime,\n            addCloseOp.blockSize, true,\n            addCloseOp.clientName,\n            addCloseOp.clientMachine,\n            addCloseOp.storagePolicyId);\n        iip = INodesInPath.replace(iip, iip.length() - 1, newFile);\n        fsNamesys.leaseManager.addLease(addCloseOp.clientName, path);\n\n        // add the op into retry cache if necessary\n        if (toAddRetryCache) {\n          HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatus(\n              fsNamesys.dir, path, HdfsFileStatus.EMPTY_NAME, newFile,\n              HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED, Snapshot.CURRENT_STATE_ID,\n              false, iip);\n          fsNamesys.addCacheEntryWithPayload(addCloseOp.rpcClientId,\n              addCloseOp.rpcCallId, stat);\n        }\n      } else { // This is OP_ADD on an existing file (old append)\n        if (!oldFile.isUnderConstruction()) {\n          // This is case 3: a call to append() on an already-closed file.\n          if (FSNamesystem.LOG.isDebugEnabled()) {\n            FSNamesystem.LOG.debug(\"Reopening an already-closed file \" +\n                \"for append\");\n          }\n          LocatedBlock lb = fsNamesys.prepareFileForAppend(path, iip,\n              addCloseOp.clientName, addCloseOp.clientMachine, false, false,\n              false);\n          // add the op into retry cache if necessary\n          if (toAddRetryCache) {\n            HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatus(\n                fsNamesys.dir, path,\n                HdfsFileStatus.EMPTY_NAME, newFile,\n                HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,\n                Snapshot.CURRENT_STATE_ID, false, iip);\n            fsNamesys.addCacheEntryWithPayload(addCloseOp.rpcClientId,\n                addCloseOp.rpcCallId, new LastBlockWithStatus(lb, stat));\n          }\n        }\n      }\n      // Fall-through for case 2.\n      // Regardless of whether it's a new file or an updated file,\n      // update the block list.\n      \n      // Update the salient file attributes.\n      newFile.setAccessTime(addCloseOp.atime, Snapshot.CURRENT_STATE_ID);\n      newFile.setModificationTime(addCloseOp.mtime, Snapshot.CURRENT_STATE_ID);\n      updateBlocks(fsDir, addCloseOp, iip, newFile);\n      break;\n    }\n    case OP_CLOSE: {\n      AddCloseOp addCloseOp = (AddCloseOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(addCloseOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + addCloseOp.blocks.length +\n            \" clientHolder \" + addCloseOp.clientName +\n            \" clientMachine \" + addCloseOp.clientMachine);\n      }\n\n      final INodesInPath iip = fsDir.getINodesInPath(path, true);\n      final INodeFile file = INodeFile.valueOf(iip.getLastINode(), path);\n\n      // Update the salient file attributes.\n      file.setAccessTime(addCloseOp.atime, Snapshot.CURRENT_STATE_ID);\n      file.setModificationTime(addCloseOp.mtime, Snapshot.CURRENT_STATE_ID);\n      updateBlocks(fsDir, addCloseOp, iip, file);\n\n      // Now close the file\n      if (!file.isUnderConstruction() &&\n          logVersion <= LayoutVersion.BUGFIX_HDFS_2991_VERSION) {\n        // There was a bug (HDFS-2991) in hadoop < 0.23.1 where OP_CLOSE\n        // could show up twice in a row. But after that version, this\n        // should be fixed, so we should treat it as an error.\n        throw new IOException(\n            \"File is not under construction: \" + path);\n      }\n      // One might expect that you could use removeLease(holder, path) here,\n      // but OP_CLOSE doesn't serialize the holder. So, remove by path.\n      if (file.isUnderConstruction()) {\n        fsNamesys.leaseManager.removeLeaseWithPrefixPath(path);\n        file.toCompleteFile(file.getModificationTime());\n      }\n      break;\n    }\n    case OP_APPEND: {\n      AppendOp appendOp = (AppendOp) op;\n      final String path = renameReservedPathsOnUpgrade(appendOp.path,\n          logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" clientName \" + appendOp.clientName +\n            \" clientMachine \" + appendOp.clientMachine +\n            \" newBlock \" + appendOp.newBlock);\n      }\n      INodesInPath iip = fsDir.getINodesInPath4Write(path);\n      INodeFile file = INodeFile.valueOf(iip.getLastINode(), path);\n      if (!file.isUnderConstruction()) {\n        LocatedBlock lb = fsNamesys.prepareFileForAppend(path, iip,\n            appendOp.clientName, appendOp.clientMachine, appendOp.newBlock,\n            false, false);\n        // add the op into retry cache if necessary\n        if (toAddRetryCache) {\n          HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatus(\n              fsNamesys.dir, path, HdfsFileStatus.EMPTY_NAME, file,\n              HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,\n              Snapshot.CURRENT_STATE_ID, false, iip);\n          fsNamesys.addCacheEntryWithPayload(appendOp.rpcClientId,\n              appendOp.rpcCallId, new LastBlockWithStatus(lb, stat));\n        }\n      }\n      break;\n    }\n    case OP_UPDATE_BLOCKS: {\n      UpdateBlocksOp updateOp = (UpdateBlocksOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(updateOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + updateOp.blocks.length);\n      }\n      INodesInPath iip = fsDir.getINodesInPath(path, true);\n      INodeFile oldFile = INodeFile.valueOf(iip.getLastINode(), path);\n      // Update in-memory data structures\n      updateBlocks(fsDir, updateOp, iip, oldFile);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(updateOp.rpcClientId, updateOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_ADD_BLOCK: {\n      AddBlockOp addBlockOp = (AddBlockOp) op;\n      String path = renameReservedPathsOnUpgrade(addBlockOp.getPath(), logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" new block id : \" + addBlockOp.getLastBlock().getBlockId());\n      }\n      INodeFile oldFile = INodeFile.valueOf(fsDir.getINode(path), path);\n      // add the new block to the INodeFile\n      addNewBlock(fsDir, addBlockOp, oldFile);\n      break;\n    }\n    case OP_SET_REPLICATION: {\n      SetReplicationOp setReplicationOp = (SetReplicationOp)op;\n      short replication = fsNamesys.getBlockManager().adjustReplication(\n          setReplicationOp.replication);\n      FSDirAttrOp.unprotectedSetReplication(fsDir, renameReservedPathsOnUpgrade(\n          setReplicationOp.path, logVersion), replication, null);\n      break;\n    }\n    case OP_CONCAT_DELETE: {\n      ConcatDeleteOp concatDeleteOp = (ConcatDeleteOp)op;\n      String trg = renameReservedPathsOnUpgrade(concatDeleteOp.trg, logVersion);\n      String[] srcs = new String[concatDeleteOp.srcs.length];\n      for (int i=0; i<srcs.length; i++) {\n        srcs[i] =\n            renameReservedPathsOnUpgrade(concatDeleteOp.srcs[i], logVersion);\n      }\n      INodesInPath targetIIP = fsDir.getINodesInPath4Write(trg);\n      INodeFile[] srcFiles = new INodeFile[srcs.length];\n      for (int i = 0; i < srcs.length; i++) {\n        INodesInPath srcIIP = fsDir.getINodesInPath4Write(srcs[i]);\n        srcFiles[i] = srcIIP.getLastINode().asFile();\n      }\n      FSDirConcatOp.unprotectedConcat(fsDir, targetIIP, srcFiles,\n          concatDeleteOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(concatDeleteOp.rpcClientId,\n            concatDeleteOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME_OLD: {\n      RenameOldOp renameOp = (RenameOldOp)op;\n      final String src = renameReservedPathsOnUpgrade(renameOp.src, logVersion);\n      final String dst = renameReservedPathsOnUpgrade(renameOp.dst, logVersion);\n      FSDirRenameOp.renameForEditLog(fsDir, src, dst, renameOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameOp.rpcClientId, renameOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_DELETE: {\n      DeleteOp deleteOp = (DeleteOp)op;\n      FSDirDeleteOp.deleteForEditLog(\n          fsDir, renameReservedPathsOnUpgrade(deleteOp.path, logVersion),\n          deleteOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(deleteOp.rpcClientId, deleteOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_MKDIR: {\n      MkdirOp mkdirOp = (MkdirOp)op;\n      inodeId = getAndUpdateLastInodeId(mkdirOp.inodeId, logVersion,\n          lastInodeId);\n      FSDirMkdirOp.mkdirForEditLog(fsDir, inodeId,\n          renameReservedPathsOnUpgrade(mkdirOp.path, logVersion),\n          mkdirOp.permissions, mkdirOp.aclEntries, mkdirOp.timestamp);\n      break;\n    }\n    case OP_SET_GENSTAMP_V1: {\n      SetGenstampV1Op setGenstampV1Op = (SetGenstampV1Op)op;\n      fsNamesys.getBlockIdManager().setGenerationStampV1(\n          setGenstampV1Op.genStampV1);\n      break;\n    }\n    case OP_SET_PERMISSIONS: {\n      SetPermissionsOp setPermissionsOp = (SetPermissionsOp)op;\n      FSDirAttrOp.unprotectedSetPermission(fsDir, renameReservedPathsOnUpgrade(\n          setPermissionsOp.src, logVersion), setPermissionsOp.permissions);\n      break;\n    }\n    case OP_SET_OWNER: {\n      SetOwnerOp setOwnerOp = (SetOwnerOp)op;\n      FSDirAttrOp.unprotectedSetOwner(\n          fsDir, renameReservedPathsOnUpgrade(setOwnerOp.src, logVersion),\n          setOwnerOp.username, setOwnerOp.groupname);\n      break;\n    }\n    case OP_SET_NS_QUOTA: {\n      SetNSQuotaOp setNSQuotaOp = (SetNSQuotaOp)op;\n      FSDirAttrOp.unprotectedSetQuota(\n          fsDir, renameReservedPathsOnUpgrade(setNSQuotaOp.src, logVersion),\n          setNSQuotaOp.nsQuota, HdfsConstants.QUOTA_DONT_SET, null);\n      break;\n    }\n    case OP_CLEAR_NS_QUOTA: {\n      ClearNSQuotaOp clearNSQuotaOp = (ClearNSQuotaOp)op;\n      FSDirAttrOp.unprotectedSetQuota(\n          fsDir, renameReservedPathsOnUpgrade(clearNSQuotaOp.src, logVersion),\n          HdfsConstants.QUOTA_RESET, HdfsConstants.QUOTA_DONT_SET, null);\n      break;\n    }\n\n    case OP_SET_QUOTA:\n      SetQuotaOp setQuotaOp = (SetQuotaOp) op;\n      FSDirAttrOp.unprotectedSetQuota(fsDir,\n          renameReservedPathsOnUpgrade(setQuotaOp.src, logVersion),\n          setQuotaOp.nsQuota, setQuotaOp.dsQuota, null);\n      break;\n\n    case OP_SET_QUOTA_BY_STORAGETYPE:\n        FSEditLogOp.SetQuotaByStorageTypeOp setQuotaByStorageTypeOp =\n          (FSEditLogOp.SetQuotaByStorageTypeOp) op;\n        FSDirAttrOp.unprotectedSetQuota(fsDir,\n          renameReservedPathsOnUpgrade(setQuotaByStorageTypeOp.src, logVersion),\n          HdfsConstants.QUOTA_DONT_SET, setQuotaByStorageTypeOp.dsQuota,\n          setQuotaByStorageTypeOp.type);\n        break;\n\n    case OP_TIMES: {\n      TimesOp timesOp = (TimesOp)op;\n      FSDirAttrOp.unprotectedSetTimes(\n          fsDir, renameReservedPathsOnUpgrade(timesOp.path, logVersion),\n          timesOp.mtime, timesOp.atime, true);\n      break;\n    }\n    case OP_SYMLINK: {\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n      SymlinkOp symlinkOp = (SymlinkOp)op;\n      inodeId = getAndUpdateLastInodeId(symlinkOp.inodeId, logVersion,\n          lastInodeId);\n      final String path = renameReservedPathsOnUpgrade(symlinkOp.path,\n          logVersion);\n      final INodesInPath iip = fsDir.getINodesInPath(path, false);\n      FSDirSymlinkOp.unprotectedAddSymlink(fsDir, iip.getExistingINodes(),\n          iip.getLastLocalName(), inodeId, symlinkOp.value, symlinkOp.mtime,\n          symlinkOp.atime, symlinkOp.permissionStatus);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(symlinkOp.rpcClientId, symlinkOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME: {\n      RenameOp renameOp = (RenameOp)op;\n      FSDirRenameOp.renameForEditLog(fsDir,\n          renameReservedPathsOnUpgrade(renameOp.src, logVersion),\n          renameReservedPathsOnUpgrade(renameOp.dst, logVersion),\n          renameOp.timestamp, renameOp.options);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameOp.rpcClientId, renameOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_GET_DELEGATION_TOKEN: {\n      GetDelegationTokenOp getDelegationTokenOp\n        = (GetDelegationTokenOp)op;\n\n      fsNamesys.getDelegationTokenSecretManager()\n        .addPersistedDelegationToken(getDelegationTokenOp.token,\n                                     getDelegationTokenOp.expiryTime);\n      break;\n    }\n    case OP_RENEW_DELEGATION_TOKEN: {\n      RenewDelegationTokenOp renewDelegationTokenOp\n        = (RenewDelegationTokenOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n        .updatePersistedTokenRenewal(renewDelegationTokenOp.token,\n                                     renewDelegationTokenOp.expiryTime);\n      break;\n    }\n    case OP_CANCEL_DELEGATION_TOKEN: {\n      CancelDelegationTokenOp cancelDelegationTokenOp\n        = (CancelDelegationTokenOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n          .updatePersistedTokenCancellation(\n              cancelDelegationTokenOp.token);\n      break;\n    }\n    case OP_UPDATE_MASTER_KEY: {\n      UpdateMasterKeyOp updateMasterKeyOp = (UpdateMasterKeyOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n        .updatePersistedMasterKey(updateMasterKeyOp.key);\n      break;\n    }\n    case OP_REASSIGN_LEASE: {\n      ReassignLeaseOp reassignLeaseOp = (ReassignLeaseOp)op;\n\n      Lease lease = fsNamesys.leaseManager.getLease(\n          reassignLeaseOp.leaseHolder);\n      final String path =\n          renameReservedPathsOnUpgrade(reassignLeaseOp.path, logVersion);\n      INodeFile pendingFile = fsDir.getINode(path).asFile();\n      Preconditions.checkState(pendingFile.isUnderConstruction());\n      fsNamesys.reassignLeaseInternal(lease,\n          path, reassignLeaseOp.newHolder, pendingFile);\n      break;\n    }\n    case OP_START_LOG_SEGMENT:\n    case OP_END_LOG_SEGMENT: {\n      // no data in here currently.\n      break;\n    }\n    case OP_CREATE_SNAPSHOT: {\n      CreateSnapshotOp createSnapshotOp = (CreateSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(createSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      String path = fsNamesys.getSnapshotManager().createSnapshot(iip,\n          snapshotRoot, createSnapshotOp.snapshotName);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntryWithPayload(createSnapshotOp.rpcClientId,\n            createSnapshotOp.rpcCallId, path);\n      }\n      break;\n    }\n    case OP_DELETE_SNAPSHOT: {\n      DeleteSnapshotOp deleteSnapshotOp = (DeleteSnapshotOp) op;\n      BlocksMapUpdateInfo collectedBlocks = new BlocksMapUpdateInfo();\n      List<INode> removedINodes = new ChunkedArrayList<INode>();\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(deleteSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      fsNamesys.getSnapshotManager().deleteSnapshot(\n          iip, deleteSnapshotOp.snapshotName,\n          collectedBlocks, removedINodes);\n      fsNamesys.removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n      collectedBlocks.clear();\n      fsNamesys.dir.removeFromInodeMap(removedINodes);\n      removedINodes.clear();\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(deleteSnapshotOp.rpcClientId,\n            deleteSnapshotOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME_SNAPSHOT: {\n      RenameSnapshotOp renameSnapshotOp = (RenameSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(renameSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      fsNamesys.getSnapshotManager().renameSnapshot(iip,\n          snapshotRoot, renameSnapshotOp.snapshotOldName,\n          renameSnapshotOp.snapshotNewName);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameSnapshotOp.rpcClientId,\n            renameSnapshotOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_ALLOW_SNAPSHOT: {\n      AllowSnapshotOp allowSnapshotOp = (AllowSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(allowSnapshotOp.snapshotRoot, logVersion);\n      fsNamesys.getSnapshotManager().setSnapshottable(\n          snapshotRoot, false);\n      break;\n    }\n    case OP_DISALLOW_SNAPSHOT: {\n      DisallowSnapshotOp disallowSnapshotOp = (DisallowSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(disallowSnapshotOp.snapshotRoot,\n              logVersion);\n      fsNamesys.getSnapshotManager().resetSnapshottable(\n          snapshotRoot);\n      break;\n    }\n    case OP_SET_GENSTAMP_V2: {\n      SetGenstampV2Op setGenstampV2Op = (SetGenstampV2Op) op;\n      fsNamesys.getBlockIdManager().setGenerationStampV2(\n          setGenstampV2Op.genStampV2);\n      break;\n    }\n    case OP_ALLOCATE_BLOCK_ID: {\n      AllocateBlockIdOp allocateBlockIdOp = (AllocateBlockIdOp) op;\n      fsNamesys.getBlockIdManager().setLastAllocatedBlockId(\n          allocateBlockIdOp.blockId);\n      break;\n    }\n    case OP_ROLLING_UPGRADE_START: {\n      if (startOpt == StartupOption.ROLLINGUPGRADE) {\n        final RollingUpgradeStartupOption rollingUpgradeOpt\n            = startOpt.getRollingUpgradeStartupOption(); \n        if (rollingUpgradeOpt == RollingUpgradeStartupOption.ROLLBACK) {\n          throw new RollingUpgradeOp.RollbackException();\n        }\n      }\n      // start rolling upgrade\n      final long startTime = ((RollingUpgradeOp) op).getTime();\n      fsNamesys.startRollingUpgradeInternal(startTime);\n      fsNamesys.triggerRollbackCheckpoint();\n      break;\n    }\n    case OP_ROLLING_UPGRADE_FINALIZE: {\n      final long finalizeTime = ((RollingUpgradeOp) op).getTime();\n      if (fsNamesys.isRollingUpgrade()) {\n        // Only do it when NN is actually doing rolling upgrade.\n        // We can get FINALIZE without corresponding START, if NN is restarted\n        // before this op is consumed and a new checkpoint is created.\n        fsNamesys.finalizeRollingUpgradeInternal(finalizeTime);\n      }\n      fsNamesys.getFSImage().updateStorageVersion();\n      fsNamesys.getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n      break;\n    }\n    case OP_ADD_CACHE_DIRECTIVE: {\n      AddCacheDirectiveInfoOp addOp = (AddCacheDirectiveInfoOp) op;\n      CacheDirectiveInfo result = fsNamesys.\n          getCacheManager().addDirectiveFromEditLog(addOp.directive);\n      if (toAddRetryCache) {\n        Long id = result.getId();\n        fsNamesys.addCacheEntryWithPayload(op.rpcClientId, op.rpcCallId, id);\n      }\n      break;\n    }\n    case OP_MODIFY_CACHE_DIRECTIVE: {\n      ModifyCacheDirectiveInfoOp modifyOp =\n          (ModifyCacheDirectiveInfoOp) op;\n      fsNamesys.getCacheManager().modifyDirectiveFromEditLog(\n          modifyOp.directive);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_CACHE_DIRECTIVE: {\n      RemoveCacheDirectiveInfoOp removeOp =\n          (RemoveCacheDirectiveInfoOp) op;\n      fsNamesys.getCacheManager().removeDirective(removeOp.id, null);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_ADD_CACHE_POOL: {\n      AddCachePoolOp addOp = (AddCachePoolOp) op;\n      fsNamesys.getCacheManager().addCachePool(addOp.info);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_MODIFY_CACHE_POOL: {\n      ModifyCachePoolOp modifyOp = (ModifyCachePoolOp) op;\n      fsNamesys.getCacheManager().modifyCachePool(modifyOp.info);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_CACHE_POOL: {\n      RemoveCachePoolOp removeOp = (RemoveCachePoolOp) op;\n      fsNamesys.getCacheManager().removeCachePool(removeOp.poolName);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_SET_ACL: {\n      SetAclOp setAclOp = (SetAclOp) op;\n      FSDirAclOp.unprotectedSetAcl(fsDir, setAclOp.src, setAclOp.aclEntries,\n          true);\n      break;\n    }\n    case OP_SET_XATTR: {\n      SetXAttrOp setXAttrOp = (SetXAttrOp) op;\n      FSDirXAttrOp.unprotectedSetXAttrs(fsDir, setXAttrOp.src,\n                                        setXAttrOp.xAttrs,\n                                        EnumSet.of(XAttrSetFlag.CREATE,\n                                                   XAttrSetFlag.REPLACE));\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(setXAttrOp.rpcClientId, setXAttrOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_XATTR: {\n      RemoveXAttrOp removeXAttrOp = (RemoveXAttrOp) op;\n      FSDirXAttrOp.unprotectedRemoveXAttrs(fsDir, removeXAttrOp.src,\n                                           removeXAttrOp.xAttrs);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(removeXAttrOp.rpcClientId,\n            removeXAttrOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_TRUNCATE: {\n      TruncateOp truncateOp = (TruncateOp) op;\n      fsDir.unprotectedTruncate(truncateOp.src, truncateOp.clientName,\n          truncateOp.clientMachine, truncateOp.newLength, truncateOp.timestamp,\n          truncateOp.truncateBlock);\n      break;\n    }\n    case OP_SET_STORAGE_POLICY: {\n      SetStoragePolicyOp setStoragePolicyOp = (SetStoragePolicyOp) op;\n      final String path = renameReservedPathsOnUpgrade(setStoragePolicyOp.path,\n          logVersion);\n      final INodesInPath iip = fsDir.getINodesInPath4Write(path);\n      FSDirAttrOp.unprotectedSetStoragePolicy(\n          fsDir, fsNamesys.getBlockManager(), iip,\n          setStoragePolicyOp.policyId);\n      break;\n    }\n    default:\n      throw new IOException(\"Invalid operation read \" + op.opCode);\n    }\n    return inodeId;\n  }","id":3557,"modified_method":"@SuppressWarnings(\"deprecation\")\n  private long applyEditLogOp(FSEditLogOp op, FSDirectory fsDir,\n      StartupOption startOpt, int logVersion, long lastInodeId) throws IOException {\n    long inodeId = HdfsConstantsClient.GRANDFATHER_INODE_ID;\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"replaying edit log: \" + op);\n    }\n    final boolean toAddRetryCache = fsNamesys.hasRetryCache() && op.hasRpcIds();\n\n    switch (op.opCode) {\n    case OP_ADD: {\n      AddCloseOp addCloseOp = (AddCloseOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(addCloseOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + addCloseOp.blocks.length +\n            \" clientHolder \" + addCloseOp.clientName +\n            \" clientMachine \" + addCloseOp.clientMachine);\n      }\n      // There are 3 cases here:\n      // 1. OP_ADD to create a new file\n      // 2. OP_ADD to update file blocks\n      // 3. OP_ADD to open file for append (old append)\n\n      // See if the file already exists (persistBlocks call)\n      INodesInPath iip = fsDir.getINodesInPath(path, true);\n      INodeFile oldFile = INodeFile.valueOf(iip.getLastINode(), path, true);\n      if (oldFile != null && addCloseOp.overwrite) {\n        // This is OP_ADD with overwrite\n        FSDirDeleteOp.deleteForEditLog(fsDir, path, addCloseOp.mtime);\n        iip = INodesInPath.replace(iip, iip.length() - 1, null);\n        oldFile = null;\n      }\n      INodeFile newFile = oldFile;\n      if (oldFile == null) { // this is OP_ADD on a new file (case 1)\n        // versions > 0 support per file replication\n        // get name and replication\n        final short replication = fsNamesys.getBlockManager()\n            .adjustReplication(addCloseOp.replication);\n        assert addCloseOp.blocks.length == 0;\n\n        // add to the file tree\n        inodeId = getAndUpdateLastInodeId(addCloseOp.inodeId, logVersion, lastInodeId);\n        newFile = fsDir.addFileForEditLog(inodeId, iip.getExistingINodes(),\n            iip.getLastLocalName(),\n            addCloseOp.permissions,\n            addCloseOp.aclEntries,\n            addCloseOp.xAttrs, replication,\n            addCloseOp.mtime, addCloseOp.atime,\n            addCloseOp.blockSize, true,\n            addCloseOp.clientName,\n            addCloseOp.clientMachine,\n            addCloseOp.storagePolicyId);\n        iip = INodesInPath.replace(iip, iip.length() - 1, newFile);\n        fsNamesys.leaseManager.addLease(addCloseOp.clientName, path);\n\n        // add the op into retry cache if necessary\n        if (toAddRetryCache) {\n          HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatusForEditLog(\n              fsNamesys.dir, path, HdfsFileStatus.EMPTY_NAME, newFile,\n              HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED, Snapshot.CURRENT_STATE_ID,\n              false, iip);\n          fsNamesys.addCacheEntryWithPayload(addCloseOp.rpcClientId,\n              addCloseOp.rpcCallId, stat);\n        }\n      } else { // This is OP_ADD on an existing file (old append)\n        if (!oldFile.isUnderConstruction()) {\n          // This is case 3: a call to append() on an already-closed file.\n          if (FSNamesystem.LOG.isDebugEnabled()) {\n            FSNamesystem.LOG.debug(\"Reopening an already-closed file \" +\n                \"for append\");\n          }\n          LocatedBlock lb = fsNamesys.prepareFileForAppend(path, iip,\n              addCloseOp.clientName, addCloseOp.clientMachine, false, false,\n              false);\n          // add the op into retry cache if necessary\n          if (toAddRetryCache) {\n            HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatusForEditLog(\n                fsNamesys.dir, path,\n                HdfsFileStatus.EMPTY_NAME, newFile,\n                HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,\n                Snapshot.CURRENT_STATE_ID, false, iip);\n            fsNamesys.addCacheEntryWithPayload(addCloseOp.rpcClientId,\n                addCloseOp.rpcCallId, new LastBlockWithStatus(lb, stat));\n          }\n        }\n      }\n      // Fall-through for case 2.\n      // Regardless of whether it's a new file or an updated file,\n      // update the block list.\n      \n      // Update the salient file attributes.\n      newFile.setAccessTime(addCloseOp.atime, Snapshot.CURRENT_STATE_ID);\n      newFile.setModificationTime(addCloseOp.mtime, Snapshot.CURRENT_STATE_ID);\n      updateBlocks(fsDir, addCloseOp, iip, newFile);\n      break;\n    }\n    case OP_CLOSE: {\n      AddCloseOp addCloseOp = (AddCloseOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(addCloseOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + addCloseOp.blocks.length +\n            \" clientHolder \" + addCloseOp.clientName +\n            \" clientMachine \" + addCloseOp.clientMachine);\n      }\n\n      final INodesInPath iip = fsDir.getINodesInPath(path, true);\n      final INodeFile file = INodeFile.valueOf(iip.getLastINode(), path);\n\n      // Update the salient file attributes.\n      file.setAccessTime(addCloseOp.atime, Snapshot.CURRENT_STATE_ID);\n      file.setModificationTime(addCloseOp.mtime, Snapshot.CURRENT_STATE_ID);\n      updateBlocks(fsDir, addCloseOp, iip, file);\n\n      // Now close the file\n      if (!file.isUnderConstruction() &&\n          logVersion <= LayoutVersion.BUGFIX_HDFS_2991_VERSION) {\n        // There was a bug (HDFS-2991) in hadoop < 0.23.1 where OP_CLOSE\n        // could show up twice in a row. But after that version, this\n        // should be fixed, so we should treat it as an error.\n        throw new IOException(\n            \"File is not under construction: \" + path);\n      }\n      // One might expect that you could use removeLease(holder, path) here,\n      // but OP_CLOSE doesn't serialize the holder. So, remove by path.\n      if (file.isUnderConstruction()) {\n        fsNamesys.leaseManager.removeLeaseWithPrefixPath(path);\n        file.toCompleteFile(file.getModificationTime());\n      }\n      break;\n    }\n    case OP_APPEND: {\n      AppendOp appendOp = (AppendOp) op;\n      final String path = renameReservedPathsOnUpgrade(appendOp.path,\n          logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" clientName \" + appendOp.clientName +\n            \" clientMachine \" + appendOp.clientMachine +\n            \" newBlock \" + appendOp.newBlock);\n      }\n      INodesInPath iip = fsDir.getINodesInPath4Write(path);\n      INodeFile file = INodeFile.valueOf(iip.getLastINode(), path);\n      if (!file.isUnderConstruction()) {\n        LocatedBlock lb = fsNamesys.prepareFileForAppend(path, iip,\n            appendOp.clientName, appendOp.clientMachine, appendOp.newBlock,\n            false, false);\n        // add the op into retry cache if necessary\n        if (toAddRetryCache) {\n          HdfsFileStatus stat = FSDirStatAndListingOp.createFileStatusForEditLog(\n              fsNamesys.dir, path, HdfsFileStatus.EMPTY_NAME, file,\n              HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,\n              Snapshot.CURRENT_STATE_ID, false, iip);\n          fsNamesys.addCacheEntryWithPayload(appendOp.rpcClientId,\n              appendOp.rpcCallId, new LastBlockWithStatus(lb, stat));\n        }\n      }\n      break;\n    }\n    case OP_UPDATE_BLOCKS: {\n      UpdateBlocksOp updateOp = (UpdateBlocksOp)op;\n      final String path =\n          renameReservedPathsOnUpgrade(updateOp.path, logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" numblocks : \" + updateOp.blocks.length);\n      }\n      INodesInPath iip = fsDir.getINodesInPath(path, true);\n      INodeFile oldFile = INodeFile.valueOf(iip.getLastINode(), path);\n      // Update in-memory data structures\n      updateBlocks(fsDir, updateOp, iip, oldFile);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(updateOp.rpcClientId, updateOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_ADD_BLOCK: {\n      AddBlockOp addBlockOp = (AddBlockOp) op;\n      String path = renameReservedPathsOnUpgrade(addBlockOp.getPath(), logVersion);\n      if (FSNamesystem.LOG.isDebugEnabled()) {\n        FSNamesystem.LOG.debug(op.opCode + \": \" + path +\n            \" new block id : \" + addBlockOp.getLastBlock().getBlockId());\n      }\n      INodeFile oldFile = INodeFile.valueOf(fsDir.getINode(path), path);\n      // add the new block to the INodeFile\n      addNewBlock(fsDir, addBlockOp, oldFile);\n      break;\n    }\n    case OP_SET_REPLICATION: {\n      SetReplicationOp setReplicationOp = (SetReplicationOp)op;\n      short replication = fsNamesys.getBlockManager().adjustReplication(\n          setReplicationOp.replication);\n      FSDirAttrOp.unprotectedSetReplication(fsDir, renameReservedPathsOnUpgrade(\n          setReplicationOp.path, logVersion), replication, null);\n      break;\n    }\n    case OP_CONCAT_DELETE: {\n      ConcatDeleteOp concatDeleteOp = (ConcatDeleteOp)op;\n      String trg = renameReservedPathsOnUpgrade(concatDeleteOp.trg, logVersion);\n      String[] srcs = new String[concatDeleteOp.srcs.length];\n      for (int i=0; i<srcs.length; i++) {\n        srcs[i] =\n            renameReservedPathsOnUpgrade(concatDeleteOp.srcs[i], logVersion);\n      }\n      INodesInPath targetIIP = fsDir.getINodesInPath4Write(trg);\n      INodeFile[] srcFiles = new INodeFile[srcs.length];\n      for (int i = 0; i < srcs.length; i++) {\n        INodesInPath srcIIP = fsDir.getINodesInPath4Write(srcs[i]);\n        srcFiles[i] = srcIIP.getLastINode().asFile();\n      }\n      FSDirConcatOp.unprotectedConcat(fsDir, targetIIP, srcFiles,\n          concatDeleteOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(concatDeleteOp.rpcClientId,\n            concatDeleteOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME_OLD: {\n      RenameOldOp renameOp = (RenameOldOp)op;\n      final String src = renameReservedPathsOnUpgrade(renameOp.src, logVersion);\n      final String dst = renameReservedPathsOnUpgrade(renameOp.dst, logVersion);\n      FSDirRenameOp.renameForEditLog(fsDir, src, dst, renameOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameOp.rpcClientId, renameOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_DELETE: {\n      DeleteOp deleteOp = (DeleteOp)op;\n      FSDirDeleteOp.deleteForEditLog(\n          fsDir, renameReservedPathsOnUpgrade(deleteOp.path, logVersion),\n          deleteOp.timestamp);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(deleteOp.rpcClientId, deleteOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_MKDIR: {\n      MkdirOp mkdirOp = (MkdirOp)op;\n      inodeId = getAndUpdateLastInodeId(mkdirOp.inodeId, logVersion,\n          lastInodeId);\n      FSDirMkdirOp.mkdirForEditLog(fsDir, inodeId,\n          renameReservedPathsOnUpgrade(mkdirOp.path, logVersion),\n          mkdirOp.permissions, mkdirOp.aclEntries, mkdirOp.timestamp);\n      break;\n    }\n    case OP_SET_GENSTAMP_V1: {\n      SetGenstampV1Op setGenstampV1Op = (SetGenstampV1Op)op;\n      fsNamesys.getBlockIdManager().setGenerationStampV1(\n          setGenstampV1Op.genStampV1);\n      break;\n    }\n    case OP_SET_PERMISSIONS: {\n      SetPermissionsOp setPermissionsOp = (SetPermissionsOp)op;\n      FSDirAttrOp.unprotectedSetPermission(fsDir, renameReservedPathsOnUpgrade(\n          setPermissionsOp.src, logVersion), setPermissionsOp.permissions);\n      break;\n    }\n    case OP_SET_OWNER: {\n      SetOwnerOp setOwnerOp = (SetOwnerOp)op;\n      FSDirAttrOp.unprotectedSetOwner(\n          fsDir, renameReservedPathsOnUpgrade(setOwnerOp.src, logVersion),\n          setOwnerOp.username, setOwnerOp.groupname);\n      break;\n    }\n    case OP_SET_NS_QUOTA: {\n      SetNSQuotaOp setNSQuotaOp = (SetNSQuotaOp)op;\n      FSDirAttrOp.unprotectedSetQuota(\n          fsDir, renameReservedPathsOnUpgrade(setNSQuotaOp.src, logVersion),\n          setNSQuotaOp.nsQuota, HdfsConstants.QUOTA_DONT_SET, null);\n      break;\n    }\n    case OP_CLEAR_NS_QUOTA: {\n      ClearNSQuotaOp clearNSQuotaOp = (ClearNSQuotaOp)op;\n      FSDirAttrOp.unprotectedSetQuota(\n          fsDir, renameReservedPathsOnUpgrade(clearNSQuotaOp.src, logVersion),\n          HdfsConstants.QUOTA_RESET, HdfsConstants.QUOTA_DONT_SET, null);\n      break;\n    }\n\n    case OP_SET_QUOTA:\n      SetQuotaOp setQuotaOp = (SetQuotaOp) op;\n      FSDirAttrOp.unprotectedSetQuota(fsDir,\n          renameReservedPathsOnUpgrade(setQuotaOp.src, logVersion),\n          setQuotaOp.nsQuota, setQuotaOp.dsQuota, null);\n      break;\n\n    case OP_SET_QUOTA_BY_STORAGETYPE:\n        FSEditLogOp.SetQuotaByStorageTypeOp setQuotaByStorageTypeOp =\n          (FSEditLogOp.SetQuotaByStorageTypeOp) op;\n        FSDirAttrOp.unprotectedSetQuota(fsDir,\n          renameReservedPathsOnUpgrade(setQuotaByStorageTypeOp.src, logVersion),\n          HdfsConstants.QUOTA_DONT_SET, setQuotaByStorageTypeOp.dsQuota,\n          setQuotaByStorageTypeOp.type);\n        break;\n\n    case OP_TIMES: {\n      TimesOp timesOp = (TimesOp)op;\n      FSDirAttrOp.unprotectedSetTimes(\n          fsDir, renameReservedPathsOnUpgrade(timesOp.path, logVersion),\n          timesOp.mtime, timesOp.atime, true);\n      break;\n    }\n    case OP_SYMLINK: {\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n      SymlinkOp symlinkOp = (SymlinkOp)op;\n      inodeId = getAndUpdateLastInodeId(symlinkOp.inodeId, logVersion,\n          lastInodeId);\n      final String path = renameReservedPathsOnUpgrade(symlinkOp.path,\n          logVersion);\n      final INodesInPath iip = fsDir.getINodesInPath(path, false);\n      FSDirSymlinkOp.unprotectedAddSymlink(fsDir, iip.getExistingINodes(),\n          iip.getLastLocalName(), inodeId, symlinkOp.value, symlinkOp.mtime,\n          symlinkOp.atime, symlinkOp.permissionStatus);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(symlinkOp.rpcClientId, symlinkOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME: {\n      RenameOp renameOp = (RenameOp)op;\n      FSDirRenameOp.renameForEditLog(fsDir,\n          renameReservedPathsOnUpgrade(renameOp.src, logVersion),\n          renameReservedPathsOnUpgrade(renameOp.dst, logVersion),\n          renameOp.timestamp, renameOp.options);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameOp.rpcClientId, renameOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_GET_DELEGATION_TOKEN: {\n      GetDelegationTokenOp getDelegationTokenOp\n        = (GetDelegationTokenOp)op;\n\n      fsNamesys.getDelegationTokenSecretManager()\n        .addPersistedDelegationToken(getDelegationTokenOp.token,\n                                     getDelegationTokenOp.expiryTime);\n      break;\n    }\n    case OP_RENEW_DELEGATION_TOKEN: {\n      RenewDelegationTokenOp renewDelegationTokenOp\n        = (RenewDelegationTokenOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n        .updatePersistedTokenRenewal(renewDelegationTokenOp.token,\n                                     renewDelegationTokenOp.expiryTime);\n      break;\n    }\n    case OP_CANCEL_DELEGATION_TOKEN: {\n      CancelDelegationTokenOp cancelDelegationTokenOp\n        = (CancelDelegationTokenOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n          .updatePersistedTokenCancellation(\n              cancelDelegationTokenOp.token);\n      break;\n    }\n    case OP_UPDATE_MASTER_KEY: {\n      UpdateMasterKeyOp updateMasterKeyOp = (UpdateMasterKeyOp)op;\n      fsNamesys.getDelegationTokenSecretManager()\n        .updatePersistedMasterKey(updateMasterKeyOp.key);\n      break;\n    }\n    case OP_REASSIGN_LEASE: {\n      ReassignLeaseOp reassignLeaseOp = (ReassignLeaseOp)op;\n\n      Lease lease = fsNamesys.leaseManager.getLease(\n          reassignLeaseOp.leaseHolder);\n      final String path =\n          renameReservedPathsOnUpgrade(reassignLeaseOp.path, logVersion);\n      INodeFile pendingFile = fsDir.getINode(path).asFile();\n      Preconditions.checkState(pendingFile.isUnderConstruction());\n      fsNamesys.reassignLeaseInternal(lease,\n          path, reassignLeaseOp.newHolder, pendingFile);\n      break;\n    }\n    case OP_START_LOG_SEGMENT:\n    case OP_END_LOG_SEGMENT: {\n      // no data in here currently.\n      break;\n    }\n    case OP_CREATE_SNAPSHOT: {\n      CreateSnapshotOp createSnapshotOp = (CreateSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(createSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      String path = fsNamesys.getSnapshotManager().createSnapshot(iip,\n          snapshotRoot, createSnapshotOp.snapshotName);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntryWithPayload(createSnapshotOp.rpcClientId,\n            createSnapshotOp.rpcCallId, path);\n      }\n      break;\n    }\n    case OP_DELETE_SNAPSHOT: {\n      DeleteSnapshotOp deleteSnapshotOp = (DeleteSnapshotOp) op;\n      BlocksMapUpdateInfo collectedBlocks = new BlocksMapUpdateInfo();\n      List<INode> removedINodes = new ChunkedArrayList<INode>();\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(deleteSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      fsNamesys.getSnapshotManager().deleteSnapshot(\n          iip, deleteSnapshotOp.snapshotName,\n          collectedBlocks, removedINodes);\n      fsNamesys.removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n      collectedBlocks.clear();\n      fsNamesys.dir.removeFromInodeMap(removedINodes);\n      removedINodes.clear();\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(deleteSnapshotOp.rpcClientId,\n            deleteSnapshotOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_RENAME_SNAPSHOT: {\n      RenameSnapshotOp renameSnapshotOp = (RenameSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(renameSnapshotOp.snapshotRoot,\n              logVersion);\n      INodesInPath iip = fsDir.getINodesInPath4Write(snapshotRoot);\n      fsNamesys.getSnapshotManager().renameSnapshot(iip,\n          snapshotRoot, renameSnapshotOp.snapshotOldName,\n          renameSnapshotOp.snapshotNewName);\n      \n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(renameSnapshotOp.rpcClientId,\n            renameSnapshotOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_ALLOW_SNAPSHOT: {\n      AllowSnapshotOp allowSnapshotOp = (AllowSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(allowSnapshotOp.snapshotRoot, logVersion);\n      fsNamesys.getSnapshotManager().setSnapshottable(\n          snapshotRoot, false);\n      break;\n    }\n    case OP_DISALLOW_SNAPSHOT: {\n      DisallowSnapshotOp disallowSnapshotOp = (DisallowSnapshotOp) op;\n      final String snapshotRoot =\n          renameReservedPathsOnUpgrade(disallowSnapshotOp.snapshotRoot,\n              logVersion);\n      fsNamesys.getSnapshotManager().resetSnapshottable(\n          snapshotRoot);\n      break;\n    }\n    case OP_SET_GENSTAMP_V2: {\n      SetGenstampV2Op setGenstampV2Op = (SetGenstampV2Op) op;\n      fsNamesys.getBlockIdManager().setGenerationStampV2(\n          setGenstampV2Op.genStampV2);\n      break;\n    }\n    case OP_ALLOCATE_BLOCK_ID: {\n      AllocateBlockIdOp allocateBlockIdOp = (AllocateBlockIdOp) op;\n      fsNamesys.getBlockIdManager().setLastAllocatedBlockId(\n          allocateBlockIdOp.blockId);\n      break;\n    }\n    case OP_ROLLING_UPGRADE_START: {\n      if (startOpt == StartupOption.ROLLINGUPGRADE) {\n        final RollingUpgradeStartupOption rollingUpgradeOpt\n            = startOpt.getRollingUpgradeStartupOption(); \n        if (rollingUpgradeOpt == RollingUpgradeStartupOption.ROLLBACK) {\n          throw new RollingUpgradeOp.RollbackException();\n        }\n      }\n      // start rolling upgrade\n      final long startTime = ((RollingUpgradeOp) op).getTime();\n      fsNamesys.startRollingUpgradeInternal(startTime);\n      fsNamesys.triggerRollbackCheckpoint();\n      break;\n    }\n    case OP_ROLLING_UPGRADE_FINALIZE: {\n      final long finalizeTime = ((RollingUpgradeOp) op).getTime();\n      if (fsNamesys.isRollingUpgrade()) {\n        // Only do it when NN is actually doing rolling upgrade.\n        // We can get FINALIZE without corresponding START, if NN is restarted\n        // before this op is consumed and a new checkpoint is created.\n        fsNamesys.finalizeRollingUpgradeInternal(finalizeTime);\n      }\n      fsNamesys.getFSImage().updateStorageVersion();\n      fsNamesys.getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n      break;\n    }\n    case OP_ADD_CACHE_DIRECTIVE: {\n      AddCacheDirectiveInfoOp addOp = (AddCacheDirectiveInfoOp) op;\n      CacheDirectiveInfo result = fsNamesys.\n          getCacheManager().addDirectiveFromEditLog(addOp.directive);\n      if (toAddRetryCache) {\n        Long id = result.getId();\n        fsNamesys.addCacheEntryWithPayload(op.rpcClientId, op.rpcCallId, id);\n      }\n      break;\n    }\n    case OP_MODIFY_CACHE_DIRECTIVE: {\n      ModifyCacheDirectiveInfoOp modifyOp =\n          (ModifyCacheDirectiveInfoOp) op;\n      fsNamesys.getCacheManager().modifyDirectiveFromEditLog(\n          modifyOp.directive);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_CACHE_DIRECTIVE: {\n      RemoveCacheDirectiveInfoOp removeOp =\n          (RemoveCacheDirectiveInfoOp) op;\n      fsNamesys.getCacheManager().removeDirective(removeOp.id, null);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_ADD_CACHE_POOL: {\n      AddCachePoolOp addOp = (AddCachePoolOp) op;\n      fsNamesys.getCacheManager().addCachePool(addOp.info);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_MODIFY_CACHE_POOL: {\n      ModifyCachePoolOp modifyOp = (ModifyCachePoolOp) op;\n      fsNamesys.getCacheManager().modifyCachePool(modifyOp.info);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_CACHE_POOL: {\n      RemoveCachePoolOp removeOp = (RemoveCachePoolOp) op;\n      fsNamesys.getCacheManager().removeCachePool(removeOp.poolName);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(op.rpcClientId, op.rpcCallId);\n      }\n      break;\n    }\n    case OP_SET_ACL: {\n      SetAclOp setAclOp = (SetAclOp) op;\n      FSDirAclOp.unprotectedSetAcl(fsDir, setAclOp.src, setAclOp.aclEntries,\n          true);\n      break;\n    }\n    case OP_SET_XATTR: {\n      SetXAttrOp setXAttrOp = (SetXAttrOp) op;\n      FSDirXAttrOp.unprotectedSetXAttrs(fsDir, setXAttrOp.src,\n                                        setXAttrOp.xAttrs,\n                                        EnumSet.of(XAttrSetFlag.CREATE,\n                                                   XAttrSetFlag.REPLACE));\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(setXAttrOp.rpcClientId, setXAttrOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_REMOVE_XATTR: {\n      RemoveXAttrOp removeXAttrOp = (RemoveXAttrOp) op;\n      FSDirXAttrOp.unprotectedRemoveXAttrs(fsDir, removeXAttrOp.src,\n                                           removeXAttrOp.xAttrs);\n      if (toAddRetryCache) {\n        fsNamesys.addCacheEntry(removeXAttrOp.rpcClientId,\n            removeXAttrOp.rpcCallId);\n      }\n      break;\n    }\n    case OP_TRUNCATE: {\n      TruncateOp truncateOp = (TruncateOp) op;\n      fsDir.unprotectedTruncate(truncateOp.src, truncateOp.clientName,\n          truncateOp.clientMachine, truncateOp.newLength, truncateOp.timestamp,\n          truncateOp.truncateBlock);\n      break;\n    }\n    case OP_SET_STORAGE_POLICY: {\n      SetStoragePolicyOp setStoragePolicyOp = (SetStoragePolicyOp) op;\n      final String path = renameReservedPathsOnUpgrade(setStoragePolicyOp.path,\n          logVersion);\n      final INodesInPath iip = fsDir.getINodesInPath4Write(path);\n      FSDirAttrOp.unprotectedSetStoragePolicy(\n          fsDir, fsNamesys.getBlockManager(), iip,\n          setStoragePolicyOp.policyId);\n      break;\n    }\n    default:\n      throw new IOException(\"Invalid operation read \" + op.opCode);\n    }\n    return inodeId;\n  }","commit_id":"c55d609053fe24b3a50fbe17dc1b47717b453ed6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Return int[0]: Words translated, int[1]: Messages translated, int[2]:\n     * Documents translated\n     *\n     * @param personId\n     * @param startDate\n     * @param endDate\n     * @return\n     */\n    public int[]\n            getTranslatedStats(Long personId, Date startDate, Date endDate) {\n        StringBuilder queryBuilder = new StringBuilder();\n        queryBuilder\n                .append(\"select sum(tf.wordCount),count(tf),count(distinct doc) from HTextFlow tf, HTextFlowTarget tft, HDocument doc \");\n        queryBuilder.append(\"where tft.translator.id = :personId \");\n        queryBuilder\n                .append(\"and tft.lastChanged BETWEEN :startDate AND :endDate \");\n        queryBuilder.append(\"and tf.id = tft.textFlow.id \");\n        queryBuilder.append(\"and tf.document.id = doc.id \");\n\n        Query q = getSession().createQuery(queryBuilder.toString());\n        q.setParameter(\"personId\", personId);\n        q.setParameter(\"startDate\", startDate);\n        q.setParameter(\"endDate\", endDate);\n        q.setCacheable(true);\n        q.setComment(\"activityDAO.getTranslatedStats\");\n\n        Object[] objects = (Object[]) q.uniqueResult();\n\n        int[] results = new int[] { 0, 0, 0 };\n        if (objects.length < 1) {\n            return results;\n        }\n\n        for (int i = 0; i < 3; i++) {\n            if (objects.length >= i) {\n                Long count = (Long) objects[i];\n                results[i] = count == null ? 0 : count.intValue();\n            }\n        }\n        return results;\n    }","id":3558,"modified_method":"/**\n     * Return int[0]: Words translated, int[1]: Messages translated, int[2]:\n     * Documents translated\n     *\n     * @param personId\n     * @param startDate\n     * @param endDate\n     * @return\n     */\n    public int[]\n            getTranslatedStats(Long personId, Date startDate, Date endDate) {\n        StringBuilder queryBuilder = new StringBuilder();\n        queryBuilder\n                .append(\"select sum(tf.wordCount),count(tf),count(distinct doc) from HTextFlow tf, HTextFlowTarget tft, HDocument doc \");\n        queryBuilder.append(\"where tft.translator.id = :personId \");\n        queryBuilder\n                .append(\"and tft.lastChanged BETWEEN :startDate AND :endDate \");\n        queryBuilder.append(\"and tf.id = tft.textFlow.id \");\n        queryBuilder.append(\"and tf.document.id = doc.id \");\n\n        Query q = getSession().createQuery(queryBuilder.toString());\n        q.setParameter(\"personId\", personId);\n        q.setParameter(\"startDate\", startDate);\n        q.setParameter(\"endDate\", endDate);\n        q.setCacheable(true);\n        q.setComment(\"activityDAO.getTranslatedStats\");\n\n        Object[] objects = (Object[]) q.uniqueResult();\n\n        int[] results = new int[] { 0, 0, 0 };\n        if (objects.length < 1) {\n            return results;\n        }\n\n        for (int i = 0; i < results.length; i++) {\n            if (objects.length >= i) {\n                Long count = (Long) objects[i];\n                results[i] = count == null ? 0 : count.intValue();\n            }\n        }\n        return results;\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getLastTranslatorMessage(HProject project) {\n        String lastTranslatorMessage = \"Last translated by \";\n        HPerson lastTrans = projectDAO.getLastTranslator(project);\n        if( lastTrans != null ) {\n            String username = lastTrans.getName();\n            if(username == null || username.trim().isEmpty()) {\n                if( lastTrans.getAccount() != null ) {\n                    return lastTranslatorMessage + lastTrans.getAccount()\n                            .getUsername();\n                }\n            }\n            else {\n                return lastTranslatorMessage + lastTrans.getName();\n            }\n        }\n        return \"\";\n    }","id":3559,"modified_method":"public String getLastTranslatorMessage(HProject project) {\n        HPerson lastTrans = projectDAO.getLastTranslator(project);\n        if( lastTrans != null ) {\n            String username = lastTrans.getName();\n            if(username == null || username.trim().isEmpty()) {\n                if( lastTrans.getAccount() != null ) {\n                    username = lastTrans.getAccount().getUsername();\n                }\n            }\n            else {\n                username = lastTrans.getName();\n            }\n            return zanataMessages.getMessage(\n                    \"jsf.dashboard.activity.lastTranslatedBy.message\",\n                    username);\n        }\n        return \"\";\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","id":3560,"modified_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","id":3561,"modified_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getUserLanguageTeams() {\n        HAccount account = accountDAO.findById(authenticatedAccount.getId());\n        return StringUtil.concat(account.getPerson().getLanguageMemberships(),\n                ',', new Function<HLocale, String>() {\n                    @Nullable\n                    @Override\n                    public String apply(@Nullable HLocale locale) {\n                        return locale.retrieveDisplayName();\n                    }\n                });\n    }","id":3562,"modified_method":"public String getUserLanguageTeams() {\n        HAccount account = accountDAO.findById(authenticatedAccount.getId());\n        return StringUtil.concat(account.getPerson().getLanguageMemberships(),\n                ',', new Function<HLocale, String>() {\n                    @Nullable\n                    @Override\n                    public String apply(@NonNull HLocale locale) {\n                        return locale.retrieveDisplayName();\n                    }\n                });\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<WebElement> getMyActivityList() {\n        WebElement listWrapper =\n                getDriver().findElement(By.id(\"activityList\"));\n\n        if (listWrapper != null) {\n            return listWrapper.findElements(By.xpath(\"./li\"));\n        }\n        return new ArrayList<WebElement>();\n    }","id":3563,"modified_method":"public List<WebElement> getMyActivityList() {\n        WebElement listWrapper =\n                getDriver().findElement(By.id(\"activity-list\"));\n\n        if (listWrapper != null) {\n            return listWrapper.findElements(By.xpath(\"./li\"));\n        }\n        return new ArrayList<WebElement>();\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<HLocale> getUserLanguageTeams() {\n        List<HLocale> localeList =\n                languageTeamServiceImpl.getLanguageMemberships(\n                    authenticatedAccount.getUsername());\n        // TODO Sort this using ComparatorUtil's HLocale comparator\n        Collections.sort(localeList,\n                new Comparator<HLocale>() {\n                    @Override\n                    public int compare(HLocale hLocale, HLocale hLocale2) {\n                        return hLocale.retrieveDisplayName().compareTo(\n                                hLocale2.retrieveDisplayName());\n                    }\n                });\n        return localeList;\n    }","id":3564,"modified_method":"public List<HLocale> getUserLanguageTeams() {\n        List<HLocale> localeList =\n                languageTeamServiceImpl.getLanguageMemberships(\n                    authenticatedAccount.getUsername());\n        Collections.sort(localeList, ComparatorUtil.LOCALE_COMPARATOR);\n        return localeList;\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n    public void leaveLanguageTeam(String localeId) {\n        languageTeamServiceImpl.leaveLanguageTeam(localeId,\n                authenticatedAccount.getPerson().getId());\n        // FIXME use localizable string\n        FacesMessages.instance().add(\"You have left the {0} language team\",\n                localeId);\n    }","id":3565,"modified_method":"@Transactional\n    public void leaveLanguageTeam(String localeId) {\n        languageTeamServiceImpl.leaveLanguageTeam(localeId,\n                authenticatedAccount.getPerson().getId());\n        FacesMessages.instance().add(\n                zanataMessages.getMessage(\n                        \"jsf.dashboard.settings.leaveLangTeam.message\",\n                        localeId));\n    }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Return int[0]: Words translated, int[1]: Messages translated, int[2]:\n     * Documents translated\n     *\n     * @param personId\n     * @param startDate\n     * @param endDate\n     * @return\n     */\n    public int[]\n            getTranslatedStats(Long personId, Date startDate, Date endDate) {\n        StringBuilder queryBuilder = new StringBuilder();\n        queryBuilder\n                .append(\"select sum(tf.wordCount),count(tf),count(distinct doc) from HTextFlow tf, HTextFlowTarget tft, HDocument doc \");\n        queryBuilder.append(\"where tft.translator.id = :personId \");\n        queryBuilder\n                .append(\"and tft.lastChanged BETWEEN :startDate AND :endDate \");\n        queryBuilder.append(\"and tf.id = tft.textFlow.id \");\n        queryBuilder.append(\"and tf.document.id = doc.id \");\n\n        Query q = getSession().createQuery(queryBuilder.toString());\n        q.setParameter(\"personId\", personId);\n        q.setParameter(\"startDate\", startDate);\n        q.setParameter(\"endDate\", endDate);\n        q.setCacheable(true);\n        q.setComment(\"activityDAO.getTranslatedStats\");\n\n        Object[] objects = (Object[]) q.uniqueResult();\n\n        int[] results = new int[] { 0, 0, 0 };\n        if (objects.length < 1) {\n            return results;\n        }\n\n        for (int i = 0; i < 3; i++) {\n            if (objects.length >= i) {\n                Long count = (Long) objects[i];\n                results[i] = count == null ? 0 : count.intValue();\n            }\n        }\n        return results;\n    }","id":3566,"modified_method":"/**\n     * Return int[0]: Words translated, int[1]: Messages translated, int[2]:\n     * Documents translated\n     *\n     * @param personId\n     * @param startDate\n     * @param endDate\n     * @return\n     */\n    public int[]\n            getTranslatedStats(Long personId, Date startDate, Date endDate) {\n        StringBuilder queryBuilder = new StringBuilder();\n        queryBuilder\n                .append(\"select sum(tf.wordCount),count(tf),count(distinct doc) from HTextFlow tf, HTextFlowTarget tft, HDocument doc \");\n        queryBuilder.append(\"where tft.translator.id = :personId \");\n        queryBuilder\n                .append(\"and tft.lastChanged BETWEEN :startDate AND :endDate \");\n        queryBuilder.append(\"and tf.id = tft.textFlow.id \");\n        queryBuilder.append(\"and tf.document.id = doc.id \");\n\n        Query q = getSession().createQuery(queryBuilder.toString());\n        q.setParameter(\"personId\", personId);\n        q.setParameter(\"startDate\", startDate);\n        q.setParameter(\"endDate\", endDate);\n        q.setCacheable(true);\n        q.setComment(\"activityDAO.getTranslatedStats\");\n\n        Object[] objects = (Object[]) q.uniqueResult();\n\n        int[] results = new int[] { 0, 0, 0 };\n        if (objects.length < 1) {\n            return results;\n        }\n\n        for (int i = 0; i < results.length; i++) {\n            if (objects.length >= i) {\n                Long count = (Long) objects[i];\n                results[i] = count == null ? 0 : count.intValue();\n            }\n        }\n        return results;\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","id":3567,"modified_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getLastTranslatorMessage(HProject project) {\n        String lastTranslatorMessage = \"Last translated by \";\n        HPerson lastTrans = projectDAO.getLastTranslator(project);\n        if( lastTrans != null ) {\n            String username = lastTrans.getName();\n            if(username == null || username.trim().isEmpty()) {\n                if( lastTrans.getAccount() != null ) {\n                    return lastTranslatorMessage + lastTrans.getAccount()\n                            .getUsername();\n                }\n            }\n            else {\n                return lastTranslatorMessage + lastTrans.getName();\n            }\n        }\n        return \"\";\n    }","id":3568,"modified_method":"public String getLastTranslatorMessage(HProject project) {\n        HPerson lastTrans = projectDAO.getLastTranslator(project);\n        if( lastTrans != null ) {\n            String username = lastTrans.getName();\n            if(username == null || username.trim().isEmpty()) {\n                if( lastTrans.getAccount() != null ) {\n                    username = lastTrans.getAccount().getUsername();\n                }\n            }\n            else {\n                username = lastTrans.getName();\n            }\n            return zanataMessages.getMessage(\n                    \"jsf.dashboard.activity.lastTranslatedBy.message\",\n                    username);\n        }\n        return \"\";\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getUserLanguageTeams() {\n        HAccount account = accountDAO.findById(authenticatedAccount.getId());\n        return StringUtil.concat(account.getPerson().getLanguageMemberships(),\n                ',', new Function<HLocale, String>() {\n                    @Nullable\n                    @Override\n                    public String apply(@Nullable HLocale locale) {\n                        return locale.retrieveDisplayName();\n                    }\n                });\n    }","id":3569,"modified_method":"public String getUserLanguageTeams() {\n        HAccount account = accountDAO.findById(authenticatedAccount.getId());\n        return StringUtil.concat(account.getPerson().getLanguageMemberships(),\n                ',', new Function<HLocale, String>() {\n                    @Nullable\n                    @Override\n                    public String apply(@NonNull HLocale locale) {\n                        return locale.retrieveDisplayName();\n                    }\n                });\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","id":3570,"modified_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<WebElement> getMyActivityList() {\n        WebElement listWrapper =\n                getDriver().findElement(By.id(\"activityList\"));\n\n        if (listWrapper != null) {\n            return listWrapper.findElements(By.xpath(\"./li\"));\n        }\n        return new ArrayList<WebElement>();\n    }","id":3571,"modified_method":"public List<WebElement> getMyActivityList() {\n        WebElement listWrapper =\n                getDriver().findElement(By.id(\"activity-list\"));\n\n        if (listWrapper != null) {\n            return listWrapper.findElements(By.xpath(\"./li\"));\n        }\n        return new ArrayList<WebElement>();\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<HLocale> getUserLanguageTeams() {\n        List<HLocale> localeList =\n                languageTeamServiceImpl.getLanguageMemberships(\n                    authenticatedAccount.getUsername());\n        // TODO Sort this using ComparatorUtil's HLocale comparator\n        Collections.sort(localeList,\n                new Comparator<HLocale>() {\n                    @Override\n                    public int compare(HLocale hLocale, HLocale hLocale2) {\n                        return hLocale.retrieveDisplayName().compareTo(\n                                hLocale2.retrieveDisplayName());\n                    }\n                });\n        return localeList;\n    }","id":3572,"modified_method":"public List<HLocale> getUserLanguageTeams() {\n        List<HLocale> localeList =\n                languageTeamServiceImpl.getLanguageMemberships(\n                    authenticatedAccount.getUsername());\n        Collections.sort(localeList, ComparatorUtil.LOCALE_COMPARATOR);\n        return localeList;\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n    public void leaveLanguageTeam(String localeId) {\n        languageTeamServiceImpl.leaveLanguageTeam(localeId,\n                authenticatedAccount.getPerson().getId());\n        // FIXME use localizable string\n        FacesMessages.instance().add(\"You have left the {0} language team\",\n                localeId);\n    }","id":3573,"modified_method":"@Transactional\n    public void leaveLanguageTeam(String localeId) {\n        languageTeamServiceImpl.leaveLanguageTeam(localeId,\n                authenticatedAccount.getPerson().getId());\n        FacesMessages.instance().add(\n                zanataMessages.getMessage(\n                        \"jsf.dashboard.settings.leaveLangTeam.message\",\n                        localeId));\n    }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n  public InMemoryNotificationService(DatasetFramework dsFramework, TransactionSystemClient transactionSystemClient) {\n    this.dsFramework = dsFramework;\n    this.transactionSystemClient = transactionSystemClient;\n    this.feedsToSubscribers = HashMultimap.create();\n    this.lock = new ReentrantReadWriteLock();\n  }","id":3574,"modified_method":"@Inject\n  public InMemoryNotificationService(DatasetFramework dsFramework, TransactionSystemClient transactionSystemClient,\n                                     NotificationFeedClient feedClient) {\n    this.dsFramework = dsFramework;\n    this.transactionSystemClient = transactionSystemClient;\n    this.feedClient = feedClient;\n    this.feedsToHandlers = HashMultimap.create();\n    this.handlersToExecutors = Maps.newHashMap();\n    this.lock = new ReentrantReadWriteLock();\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    executor = MoreExecutors.listeningDecorator(\n      Executors.newFixedThreadPool(EXECUTOR_POOL_SIZE, Threads.createDaemonThreadFactory(\"notification-service-%d\")));\n  }","id":3575,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    defaultExecutor = MoreExecutors.listeningDecorator(\n      Executors.newFixedThreadPool(EXECUTOR_POOL_SIZE, Threads.createDaemonThreadFactory(\"notification-service-%d\")));\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void shutDown() throws Exception {\n    executor.shutdownNow();\n  }","id":3576,"modified_method":"@Override\n  protected void shutDown() throws Exception {\n    defaultExecutor.shutdownNow();\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Make an {@link AbstractNotificationSubscriber} subscribe to the Notifications sent to a {@link NotificationFeed}.\n   *\n   * @param subscriber Notification subscriber\n   * @param feed {@link NotificationFeed} to subscribe to.\n   */\n  public void subscribe(AbstractNotificationSubscriber subscriber, NotificationFeed feed) {\n    lock.writeLock().lock();\n    try {\n      feedsToSubscribers.put(feed, subscriber);\n    } finally {\n      lock.writeLock().unlock();\n    }\n  }","id":3577,"modified_method":"@Override\n  public <N> Cancellable subscribe(NotificationFeed feed, NotificationHandler<N> handler)\n    throws NotificationFeedException {\n    return subscribe(feed, handler, defaultExecutor);\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Publish a {@code notification} on a {@code feed}. Internally pushes the notification to all subscribers of the\n   * feed.\n   *\n   * @param feed {@link co.cask.cdap.notifications.NotificationFeed} on which to publish the {@code notification}.\n   * @param notification Notification to publish.\n   * @param <N> Type of the notification to publish.\n   * @return A {@link ListenableFuture} describing the pushing of the notification.\n   */\n  public <N> ListenableFuture<Void> publish(final NotificationFeed feed, final N notification) {\n    lock.readLock().lock();\n    try {\n      Set<AbstractNotificationSubscriber> subscribers = feedsToSubscribers.get(feed);\n      if (subscribers == null) {\n        return Futures.immediateFuture(null);\n      }\n\n      for (final AbstractNotificationSubscriber subscriber : subscribers) {\n        if (!subscriber.isConsuming()) {\n          continue;\n        }\n\n        final NotificationHandler handler = subscriber.getFeedMap().get(feed);\n        executor.submit(new Runnable() {\n          @Override\n          public void run() {\n            try {\n              handler.processNotification(notification,\n                                          new BasicNotificationContext(dsFramework, transactionSystemClient));\n            } catch (Throwable t) {\n              LOG.warn(\"Notification {} on feed {} could not be processed successfully by subscriber {}\",\n                       notification, feed, subscriber, t);\n            }\n          }\n        });\n      }\n    } finally {\n      lock.readLock().unlock();\n    }\n    return Futures.immediateFuture(null);\n  }","id":3578,"modified_method":"@Override\n  public <N> ListenableFuture<N> publish(NotificationFeed feed, N notification)\n    throws NotificationException, NotificationFeedException {\n    return publish(feed, notification, notification.getClass());\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void start() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    Injector injector = createInjector(\n      cConf,\n      new NotificationClientRuntimeModule().getInMemoryModules()\n    );\n    startServices(injector);\n\n    inMemoryNotificationService = injector.getInstance(InMemoryNotificationService.class);\n    inMemoryNotificationService.startAndWait();\n  }","id":3579,"modified_method":"@BeforeClass\n  public static void start() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    Injector injector = createInjector(\n      cConf,\n      new NotificationServiceRuntimeModule().getInMemoryModules()\n    );\n    startServices(injector);\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@AfterClass\n  public static void shutDown() throws Exception {\n    stopServices();\n    inMemoryNotificationService.stopAndWait();\n  }","id":3580,"modified_method":"@AfterClass\n  public static void shutDown() throws Exception {\n    stopServices();\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"public static KafkaMessage decode(ByteBuffer byteBuffer)\n    throws IOException {\n    BinaryDecoder decoder = new BinaryDecoder(new ByteBufferInputStream(byteBuffer));\n    try {\n      return GSON.fromJson(decoder.readString(), KafkaMessage.class);\n    } catch (JsonSyntaxException e) {\n      return null;\n    }\n  }","id":3581,"modified_method":"public static KafkaMessage decode(ByteBuffer byteBuffer)\n    throws IOException {\n    BinaryDecoder decoder = new BinaryDecoder(new ByteBufferInputStream(byteBuffer));\n    try {\n      return GSON.fromJson(decoder.readString(), KafkaMessage.class);\n    } catch (JsonSyntaxException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void start() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.unset(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n    cConf.set(Constants.Notification.TRANSPORT_SYSTEM, \"kafka\");\n\n    Injector injector = createInjector(\n      cConf,\n      new KafkaClientModule(),\n      new NotificationClientRuntimeModule().getDistributedModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          InMemoryZKServer zkServer = InMemoryZKServer.builder().build();\n          bind(InMemoryZKServer.class).toInstance(zkServer);\n          bind(ZKClient.class).to(ZKClientService.class);\n        }\n\n        @Provides\n        @Singleton\n        @SuppressWarnings(\"unused\")\n        private ZKClientService providesZkClientService(InMemoryZKServer zkServer) {\n          zkServer.startAndWait();\n          ZKClientService clientService = ZKClientService.Builder.of(zkServer.getConnectionStr()).build();\n          return clientService;\n        }\n      }\n    );\n    startServices(injector);\n\n    zkServer = injector.getInstance(InMemoryZKServer.class);\n\n    zkClient = injector.getInstance(ZKClientService.class);\n    zkClient.startAndWait();\n\n    kafkaClient = injector.getInstance(KafkaClientService.class);\n    kafkaClient.startAndWait();\n\n    Properties kafkaConfig = generateKafkaConfig(zkServer, TEMP_FOLDER.newFolder(\"kafka-notifications-test\"));\n\n    kafkaServer = new EmbeddedKafkaServer(kafkaConfig);\n    kafkaServer.startAndWait();\n\n    // TODO remove once Twill addLatest bug is fixed\n    feedClient.createFeed(FEED1);\n    feedClient.createFeed(FEED2);\n    getNotificationClient().createPublisher(FEED1).publish(\"test\").get();\n    getNotificationClient().createPublisher(FEED2).publish(\"test\").get();\n    feedClient.deleteFeed(FEED1);\n    feedClient.deleteFeed(FEED2);\n  }","id":3582,"modified_method":"@BeforeClass\n  public static void start() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    cConf.unset(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n    cConf.set(Constants.Notification.TRANSPORT_SYSTEM, \"kafka\");\n\n    Injector injector = createInjector(\n      cConf,\n      new KafkaClientModule(),\n      new NotificationServiceRuntimeModule().getDistributedModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          InMemoryZKServer zkServer = InMemoryZKServer.builder().build();\n          bind(InMemoryZKServer.class).toInstance(zkServer);\n          bind(ZKClient.class).to(ZKClientService.class);\n        }\n\n        @Provides\n        @Singleton\n        @SuppressWarnings(\"unused\")\n        private ZKClientService providesZkClientService(InMemoryZKServer zkServer) {\n          zkServer.startAndWait();\n          ZKClientService clientService = ZKClientService.Builder.of(zkServer.getConnectionStr()).build();\n          return clientService;\n        }\n      }\n    );\n    startServices(injector);\n\n    zkServer = injector.getInstance(InMemoryZKServer.class);\n\n    zkClient = injector.getInstance(ZKClientService.class);\n    zkClient.startAndWait();\n\n    kafkaClient = injector.getInstance(KafkaClientService.class);\n    kafkaClient.startAndWait();\n\n    Properties kafkaConfig = generateKafkaConfig(zkServer, TEMP_FOLDER.newFolder(\"kafka-notifications-test\"));\n\n    kafkaServer = new EmbeddedKafkaServer(kafkaConfig);\n    kafkaServer.startAndWait();\n\n    // TODO remove once Twill addLatest bug is fixed\n    feedClient.createFeed(FEED1);\n    feedClient.createFeed(FEED2);\n    getNotificationService().publish(FEED1, \"test\").get();\n    getNotificationService().publish(FEED2, \"test\").get();\n    feedClient.deleteFeed(FEED1);\n    feedClient.deleteFeed(FEED2);\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Map a {@link NotificationFeed} to a Kafka topic.\n   *\n   * @param feed {@link NotificationFeed} object.\n   * @return Kafka topic that should contain the Notifications published on the {@code feed}.\n   */\n  public static String getKafkaTopic(NotificationFeed feed) {\n    // For now, we only have a topic per feed Category.\n    // Later, we may want to have multiple topics per categories, defined in cdap-site.\n    // For example, we may have 10 topics for the category streams, which names would be\n    // notifications-streams-1 .. notifications-streams-10.\n    return String.format(\"notifications-%s\", feed.getCategory());\n  }","id":3583,"modified_method":"/**\n   * Map a {@link NotificationFeed} to a Kafka topic partition.\n   *\n   * @param feed {@link NotificationFeed} object.\n   * @return Kafka topic that should contain the Notifications published on the {@code feed}.\n   */\n  public static TopicPartition getKafkaTopicPartition(NotificationFeed feed) {\n    // For now, we only have a topic per feed Category.\n    // Later, we may want to have multiple topics per categories, defined in cdap-site.\n    // For example, we may have 10 topics for the category streams, which names would be\n    // notifications-streams-1 .. notifications-streams-10.\n    return new TopicPartition(String.format(\"notifications-%s\", feed.getCategory()), 0);\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void startServices(Injector injector) throws Exception {\n    notificationClient = injector.getInstance(NotificationClient.class);\n\n    feedClient = injector.getInstance(NotificationFeedClient.class);\n    dsFramework = injector.getInstance(DatasetFramework.class);\n\n    txManager = injector.getInstance(TransactionManager.class);\n    txManager.startAndWait();\n    dsOpService = injector.getInstance(DatasetOpExecutor.class);\n    dsOpService.startAndWait();\n    datasetService = injector.getInstance(DatasetService.class);\n    datasetService.startAndWait();\n  }","id":3584,"modified_method":"public static void startServices(Injector injector) throws Exception {\n    notificationService = injector.getInstance(NotificationService.class);\n    notificationService.startAndWait();\n\n    feedClient = injector.getInstance(NotificationFeedClient.class);\n    dsFramework = injector.getInstance(DatasetFramework.class);\n\n    txManager = injector.getInstance(TransactionManager.class);\n    txManager.startAndWait();\n    dsOpService = injector.getInstance(DatasetOpExecutor.class);\n    dsOpService.startAndWait();\n    datasetService = injector.getInstance(DatasetService.class);\n    datasetService.startAndWait();\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void feedNotCreatedTest() throws Exception {\n    try {\n      // Try subscribing to a feed before creating it\n      NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n      subscriber.add(FEED1, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          // No-op\n        }\n      });\n      Assert.fail(\"Should throw NotificationFeedNotFoundException.\");\n    } catch (NotificationFeedNotFoundException e) {\n      // Expected\n    }\n\n    try {\n      // Try publishing to a feed before creating it\n      getNotificationClient().createPublisher(FEED1);\n      Assert.fail(\"Should throw NotificationFeedNotFoundException.\");\n    } catch (NotificationFeedNotFoundException e) {\n      // Expected\n    }\n  }","id":3585,"modified_method":"@Test\n  public void feedNotCreatedTest() throws Exception {\n    try {\n      // Try subscribing to a feed before creating it\n      notificationService.subscribe(FEED1, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          // No-op\n        }\n      });\n      Assert.fail(\"Should throw NotificationFeedNotFoundException.\");\n    } catch (NotificationFeedNotFoundException e) {\n      // Expected\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void onePublisherMultipleSubscribersTest() throws Exception {\n    final int messagesCount = 20;\n    int subscribersCount = 10;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      final NotificationClient.Publisher<String> publisher = getNotificationClient().createPublisher(FEED1);\n      Runnable publisherRunnable = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            for (int i = 0; i < messagesCount; i++) {\n              publisher.publish(String.format(\"fake-payload-%d\", i));\n              TimeUnit.MILLISECONDS.sleep(100);\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          } finally {\n            publisher.shutdownNow();\n          }\n        }\n      };\n      Thread publisherThread = new Thread(publisherRunnable);\n\n      final int[] receiveCounts = new int[subscribersCount];\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      List<Cancellable> cancellables = Lists.newArrayList();\n      for (int i = 0; i < subscribersCount; i++) {\n        final int j = i;\n\n        NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n\n        subscriber.add(FEED1, new NotificationHandler<String>() {\n          @Override\n          public Type getNotificationFeedType() {\n            return String.class;\n          }\n\n          @Override\n          public void processNotification(String notification, NotificationContext notificationContext) {\n            LOG.debug(\"Received notification payload: {}\", notification);\n            try {\n              Assert.assertEquals(\"fake-payload-\" + receiveCounts[j], notification);\n              receiveCounts[j]++;\n            } catch (Throwable t) {\n              assertionOk.set(false);\n              Throwables.propagate(t);\n            }\n          }\n        });\n\n        cancellables.add(subscriber.consume());\n      }\n\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n      publisherThread.start();\n      publisherThread.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      for (Cancellable cancellable : cancellables) {\n        cancellable.cancel();\n      }\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n    }\n  }","id":3586,"modified_method":"@Test\n  public void onePublisherMultipleSubscribersTest() throws Exception {\n    final int messagesCount = 20;\n    int subscribersCount = 10;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      Runnable publisherRunnable = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            for (int i = 0; i < messagesCount; i++) {\n              notificationService.publish(FEED1, String.format(\"fake-payload-%d\", i));\n              TimeUnit.MILLISECONDS.sleep(100);\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread = new Thread(publisherRunnable);\n\n      final int[] receiveCounts = new int[subscribersCount];\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      List<Cancellable> cancellables = Lists.newArrayList();\n      for (int i = 0; i < subscribersCount; i++) {\n        final int j = i;\n\n        Cancellable cancellable = notificationService.subscribe(FEED1, new NotificationHandler<String>() {\n          @Override\n          public Type getNotificationFeedType() {\n            return String.class;\n          }\n\n          @Override\n          public void processNotification(String notification, NotificationContext notificationContext) {\n            LOG.debug(\"Received notification payload: {}\", notification);\n            try {\n              Assert.assertEquals(\"fake-payload-\" + receiveCounts[j], notification);\n              receiveCounts[j]++;\n            } catch (Throwable t) {\n              assertionOk.set(false);\n              Throwables.propagate(t);\n            }\n          }\n        });\n        cancellables.add(cancellable);\n      }\n\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n      publisherThread.start();\n      publisherThread.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      for (Cancellable cancellable : cancellables) {\n        cancellable.cancel();\n      }\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void multiplePublishersOneSubscriberTest() throws Exception {\n    /*\n      This configuration should not happen, as, by design, we want only one publisher to publisher the changes attached\n      to a resource. But since the low level APIs allow it, this should still be tested.\n     */\n\n    final int messagesCount = 15;\n    int publishersCount = 5;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      // Create a subscribing process\n      NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      final int[] receiveCounts = new int[publishersCount];\n\n      subscriber.add(FEED1, new NotificationHandler<SimpleNotification>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return SimpleNotification.class;\n        }\n\n        @Override\n        public void processNotification(SimpleNotification notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[notification.getPublisherId()],\n                                notification.getPayload());\n            receiveCounts[notification.getPublisherId()]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n\n      Cancellable cancellable = subscriber.consume();\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      List<Thread> publisherThreads = Lists.newArrayList();\n      for (int i = 0; i < publishersCount; i++) {\n        final NotificationClient.Publisher<SimpleNotification> publisher =\n          getNotificationClient().createPublisher(FEED1);\n        final int k = i;\n        Runnable publisherRunnable = new Runnable() {\n          @Override\n          public void run() {\n            try {\n              Random r = new Random();\n              for (int j = 0; j < messagesCount; j++) {\n                publisher.publish(new SimpleNotification(k, String.format(\"fake-payload-%d\", j)));\n                TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n              }\n            } catch (Throwable e) {\n              Throwables.propagate(e);\n            } finally {\n              publisher.shutdownNow();\n            }\n          }\n        };\n        Thread publisherThread = new Thread(publisherRunnable);\n        publisherThread.start();\n        publisherThreads.add(publisherThread);\n      }\n\n      for (Thread t : publisherThreads) {\n        t.join();\n      }\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n    }\n  }","id":3587,"modified_method":"@Test\n  public void multiplePublishersOneSubscriberTest() throws Exception {\n    /*\n      This configuration should not happen, as, by design, we want only one publisher to publisher the changes attached\n      to a resource. But since the low level APIs allow it, this should still be tested.\n     */\n\n    final int messagesCount = 15;\n    int publishersCount = 5;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      // Create a subscribing process\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      final int[] receiveCounts = new int[publishersCount];\n\n      Cancellable cancellable = notificationService.subscribe(FEED1, new NotificationHandler<SimpleNotification>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return SimpleNotification.class;\n        }\n\n        @Override\n        public void processNotification(SimpleNotification notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[notification.getPublisherId()], notification.getPayload());\n            receiveCounts[notification.getPublisherId()]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      List<Thread> publisherThreads = Lists.newArrayList();\n      for (int i = 0; i < publishersCount; i++) {\n        final int k = i;\n        Runnable publisherRunnable = new Runnable() {\n          @Override\n          public void run() {\n            try {\n              Random r = new Random();\n              for (int j = 0; j < messagesCount; j++) {\n                notificationService.publish(FEED1, new SimpleNotification(k, String.format(\"fake-payload-%d\", j)));\n                TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n              }\n            } catch (Throwable e) {\n              Throwables.propagate(e);\n            }\n          }\n        };\n        Thread publisherThread = new Thread(publisherRunnable);\n        publisherThread.start();\n        publisherThreads.add(publisherThread);\n      }\n\n      for (Thread t : publisherThreads) {\n        t.join();\n      }\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void multipleFeedsOneSubscriber() throws Exception {\n    // One subscriber subscribes to two feeds\n    final int messagesCount = 15;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    Assert.assertTrue(feedClient.createFeed(FEED2));\n    try {\n      // Create a subscribing process\n      NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      final int[] receiveCounts = new int[2];\n\n      subscriber.add(FEED1, new NotificationHandler<SimpleNotification>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return SimpleNotification.class;\n        }\n\n        @Override\n        public void processNotification(SimpleNotification notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[0],\n                                notification.getPayload());\n            receiveCounts[0]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n\n      subscriber.add(FEED2, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[1], notification);\n            receiveCounts[1]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n\n      Cancellable cancellable = subscriber.consume();\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      final NotificationClient.Publisher<SimpleNotification> publisher1 =\n        getNotificationClient().createPublisher(FEED1);\n      Runnable publisherRunnable1 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              publisher1.publish(new SimpleNotification(0, String.format(\"fake-payload-%d\", j)));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          } finally {\n            publisher1.shutdownNow();\n          }\n        }\n      };\n      Thread publisherThread1 = new Thread(publisherRunnable1);\n      publisherThread1.start();\n\n      final NotificationClient.Publisher<String> publisher2 = getNotificationClient().createPublisher(FEED2);\n      Runnable publisherRunnable2 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              publisher2.publish(String.format(\"fake-payload-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          } finally {\n            publisher2.shutdownNow();\n          }\n        }\n      };\n      Thread publisherThread2 = new Thread(publisherRunnable2);\n      publisherThread2.start();\n\n      publisherThread1.join();\n      publisherThread2.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      feedClient.deleteFeed(FEED2);\n    }\n  }","id":3588,"modified_method":"@Test\n  public void multipleFeedsOneSubscriber() throws Exception {\n    // One subscriber subscribes to two feeds\n    final int messagesCount = 15;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    Assert.assertTrue(feedClient.createFeed(FEED2));\n    try {\n      // Create a subscribing process\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n      final int[] receiveCounts = new int[2];\n\n      List<Cancellable> cancellables = Lists.newArrayList();\n      cancellables.add(notificationService.subscribe(FEED1, new NotificationHandler<SimpleNotification>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return SimpleNotification.class;\n        }\n\n        @Override\n        public void processNotification(SimpleNotification notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[0], notification.getPayload());\n            receiveCounts[0]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      }));\n\n      cancellables.add(notificationService.subscribe(FEED2, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCounts[1], notification);\n            receiveCounts[1]++;\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      }));\n\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      Runnable publisherRunnable1 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              notificationService.publish(FEED1, new SimpleNotification(0, String.format(\"fake-payload-%d\", j)));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread1 = new Thread(publisherRunnable1);\n      publisherThread1.start();\n\n      Runnable publisherRunnable2 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              notificationService.publish(FEED2, String.format(\"fake-payload-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread2 = new Thread(publisherRunnable2);\n      publisherThread2.start();\n\n      publisherThread1.join();\n      publisherThread2.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      for (Cancellable cancellable : cancellables) {\n        cancellable.cancel();\n      }\n\n      Assert.assertTrue(assertionOk.get());\n      for (int i : receiveCounts) {\n        Assert.assertEquals(messagesCount, i);\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      feedClient.deleteFeed(FEED2);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void useTransactionTest() throws Exception {\n    // Performing admin operations to create dataset instance\n    // keyValueTable is a system dataset module\n    dsFramework.addInstance(\"keyValueTable\", \"myTable\", DatasetProperties.EMPTY);\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n      subscriber.add(FEED1, new NotificationHandler<String>() {\n        private int received = 0;\n\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(final String notification, NotificationContext notificationContext) {\n          notificationContext.execute(new TxRunnable() {\n            @Override\n            public void run(DatasetContext context) throws Exception {\n              KeyValueTable table = context.getDataset(\"myTable\");\n              table.write(\"foo\", String.format(\"%s-%d\", notification, received++));\n            }\n          }, TxRetryPolicy.maxRetries(5));\n        }\n      });\n      Cancellable cancellable = subscriber.consume();\n      TimeUnit.SECONDS.sleep(2);\n\n      NotificationClient.Publisher<String> publisher = getNotificationClient().createPublisher(FEED1);\n      try {\n        publisher.publish(\"foobar\");\n        // Waiting for the subscriber to receive that notification\n        TimeUnit.SECONDS.sleep(2);\n\n        KeyValueTable table = dsFramework.getDataset(\"myTable\", DatasetDefinition.NO_ARGUMENTS, null);\n        Assert.assertNotNull(table);\n        Transaction tx1 = txManager.startShort(100);\n        table.startTx(tx1);\n        Assert.assertEquals(\"foobar-0\", Bytes.toString(table.read(\"foo\")));\n        Assert.assertTrue(table.commitTx());\n        txManager.canCommit(tx1, table.getTxChanges());\n        txManager.commit(tx1);\n        table.postTxCommit();\n      } finally {\n        publisher.shutdownNow();\n        cancellable.cancel();\n      }\n    } finally {\n      dsFramework.deleteInstance(\"myTable\");\n      feedClient.deleteFeed(FEED1);\n    }\n  }","id":3589,"modified_method":"@Test\n  public void useTransactionTest() throws Exception {\n    // Performing admin operations to create dataset instance\n    // keyValueTable is a system dataset module\n    dsFramework.addInstance(\"keyValueTable\", \"myTable\", DatasetProperties.EMPTY);\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      Cancellable cancellable = notificationService.subscribe(FEED1, new NotificationHandler<String>() {\n        private int received = 0;\n\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(final String notification, NotificationContext notificationContext) {\n          notificationContext.execute(new TxRunnable() {\n            @Override\n            public void run(DatasetContext context) throws Exception {\n              KeyValueTable table = context.getDataset(\"myTable\");\n              table.write(\"foo\", String.format(\"%s-%d\", notification, received++));\n            }\n          }, TxRetryPolicy.maxRetries(5));\n        }\n      });\n      TimeUnit.SECONDS.sleep(2);\n\n      try {\n        notificationService.publish(FEED1, \"foobar\");\n        // Waiting for the subscriber to receive that notification\n        TimeUnit.SECONDS.sleep(2);\n\n        KeyValueTable table = dsFramework.getDataset(\"myTable\", DatasetDefinition.NO_ARGUMENTS, null);\n        Assert.assertNotNull(table);\n        Transaction tx1 = txManager.startShort(100);\n        table.startTx(tx1);\n        Assert.assertEquals(\"foobar-0\", Bytes.toString(table.read(\"foo\")));\n        Assert.assertTrue(table.commitTx());\n        txManager.canCommit(tx1, table.getTxChanges());\n        txManager.commit(tx1);\n        table.postTxCommit();\n      } finally {\n        cancellable.cancel();\n      }\n    } finally {\n      dsFramework.deleteInstance(\"myTable\");\n      feedClient.deleteFeed(FEED1);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"protected static NotificationClient getNotificationClient() {\n    return notificationClient;\n  }","id":3590,"modified_method":"protected static NotificationService getNotificationService() {\n    return notificationService;\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void twoFeedsPublishOneFeedSubscribeTest() throws Exception {\n    // Test two publishers on two different feeds, but only one subscriber subscribing to one of the feeds\n\n    final int messagesCount = 15;\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    Assert.assertTrue(feedClient.createFeed(FEED2));\n    try {\n\n      // Create a subscribing process\n      final AtomicInteger receiveCount = new AtomicInteger(0);\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n\n      NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n\n      subscriber.add(FEED1, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCount.get(), notification);\n            receiveCount.incrementAndGet();\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n      Cancellable cancellable = subscriber.consume();\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      final NotificationClient.Publisher<String> publisher1 = getNotificationClient().createPublisher(FEED1);\n      Runnable publisherRunnable1 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              publisher1.publish(String.format(\"fake-payload-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          } finally {\n            publisher1.shutdownNow();\n          }\n        }\n      };\n      Thread publisherThread1 = new Thread(publisherRunnable1);\n      publisherThread1.start();\n\n      final NotificationClient.Publisher<String> publisher2 = getNotificationClient().createPublisher(FEED2);\n      Runnable publisherRunnable2 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              publisher2.publish(String.format(\"fake-payload2-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          } finally {\n            publisher2.shutdownNow();\n          }\n        }\n      };\n      Thread publisherThread2 = new Thread(publisherRunnable2);\n      publisherThread2.start();\n\n      publisherThread1.join();\n      publisherThread2.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      Assert.assertEquals(messagesCount, receiveCount.get());\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      feedClient.deleteFeed(FEED2);\n    }\n  }","id":3591,"modified_method":"@Test\n  public void twoFeedsPublishOneFeedSubscribeTest() throws Exception {\n    // Test two publishers on two different feeds, but only one subscriber subscribing to one of the feeds\n\n    final int messagesCount = 15;\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    Assert.assertTrue(feedClient.createFeed(FEED2));\n    try {\n\n      // Create a subscribing process\n      final AtomicInteger receiveCount = new AtomicInteger(0);\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n\n      Cancellable cancellable = notificationService.subscribe(FEED1, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCount.get(), notification);\n            receiveCount.incrementAndGet();\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n\n      Runnable publisherRunnable1 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              notificationService.publish(FEED1, String.format(\"fake-payload-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread1 = new Thread(publisherRunnable1);\n      publisherThread1.start();\n\n      Runnable publisherRunnable2 = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Random r = new Random();\n            for (int j = 0; j < messagesCount; j++) {\n              notificationService.publish(FEED2, String.format(\"fake-payload2-%d\", j));\n              TimeUnit.MILLISECONDS.sleep(r.nextInt(200));\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread2 = new Thread(publisherRunnable2);\n      publisherThread2.start();\n\n      publisherThread1.join();\n      publisherThread2.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      Assert.assertEquals(messagesCount, receiveCount.get());\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      feedClient.deleteFeed(FEED2);\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void onePublisherOneSubscriberTest() throws Exception {\n    final int messagesCount = 20;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      final NotificationClient.Publisher<String> publisher = getNotificationClient().createPublisher(FEED1);\n\n      try {\n        // Create a subscribing process\n        NotificationClient.Subscriber subscriber = getNotificationClient().createSubscriber();\n\n        final AtomicInteger receiveCount = new AtomicInteger(0);\n        final AtomicBoolean assertionOk = new AtomicBoolean(true);\n\n        subscriber.add(FEED1, new NotificationHandler<String>() {\n          @Override\n          public Type getNotificationFeedType() {\n            return String.class;\n          }\n\n          @Override\n          public void processNotification(String notification, NotificationContext notificationContext) {\n            LOG.debug(\"Received notification payload: {}\", notification);\n            try {\n              Assert.assertEquals(\"fake-payload-\" + receiveCount.get(), notification);\n              receiveCount.incrementAndGet();\n            } catch (Throwable t) {\n              assertionOk.set(false);\n              Throwables.propagate(t);\n            }\n          }\n        });\n\n        Cancellable cancellable = subscriber.consume();\n\n        // Runnable to publish notifications on behalf of the publisher entity\n        Runnable publisherRunnable = new Runnable() {\n          @Override\n          public void run() {\n            try {\n              for (int i = 0; i < messagesCount; i++) {\n                publisher.publish(String.format(\"fake-payload-%d\", i));\n                TimeUnit.MILLISECONDS.sleep(100);\n              }\n            } catch (Throwable e) {\n              Throwables.propagate(e);\n            }\n          }\n        };\n        Thread publisherThread = new Thread(publisherRunnable);\n\n        // Give the subscriber some time to prepare for published messages before starting the publisher\n        TimeUnit.MILLISECONDS.sleep(500);\n        publisherThread.start();\n        publisherThread.join();\n        TimeUnit.MILLISECONDS.sleep(2000);\n        cancellable.cancel();\n\n        Assert.assertTrue(assertionOk.get());\n        Assert.assertEquals(messagesCount, receiveCount.get());\n      } finally {\n        publisher.shutdownNow();\n        try {\n          publisher.publish(\"foo\");\n          Assert.fail();\n        } catch (IllegalStateException e) {\n          // Expected.\n        }\n      }\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      try {\n        feedClient.getFeed(FEED1);\n        Assert.fail(\"Should throw NotificationFeedNotFoundException.\");\n      } catch (NotificationFeedNotFoundException e) {\n        // Expected\n      }\n    }\n  }","id":3592,"modified_method":"@Test\n  public void onePublisherOneSubscriberTest() throws Exception {\n    final int messagesCount = 20;\n\n    Assert.assertTrue(feedClient.createFeed(FEED1));\n    try {\n      // Create a subscribing process\n      final AtomicInteger receiveCount = new AtomicInteger(0);\n      final AtomicBoolean assertionOk = new AtomicBoolean(true);\n\n      Cancellable cancellable = notificationService.subscribe(FEED1, new NotificationHandler<String>() {\n        @Override\n        public Type getNotificationFeedType() {\n          return String.class;\n        }\n\n        @Override\n        public void processNotification(String notification, NotificationContext notificationContext) {\n          LOG.debug(\"Received notification payload: {}\", notification);\n          try {\n            Assert.assertEquals(\"fake-payload-\" + receiveCount.get(), notification);\n            receiveCount.incrementAndGet();\n          } catch (Throwable t) {\n            assertionOk.set(false);\n            Throwables.propagate(t);\n          }\n        }\n      });\n\n      // Runnable to publish notifications on behalf of the publisher entity\n      Runnable publisherRunnable = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            for (int i = 0; i < messagesCount; i++) {\n              notificationService.publish(FEED1, String.format(\"fake-payload-%d\", i));\n              TimeUnit.MILLISECONDS.sleep(100);\n            }\n          } catch (Throwable e) {\n            Throwables.propagate(e);\n          }\n        }\n      };\n      Thread publisherThread = new Thread(publisherRunnable);\n\n      // Give the subscriber some time to prepare for published messages before starting the publisher\n      TimeUnit.MILLISECONDS.sleep(500);\n      publisherThread.start();\n      publisherThread.join();\n      TimeUnit.MILLISECONDS.sleep(2000);\n      cancellable.cancel();\n\n      Assert.assertTrue(assertionOk.get());\n      Assert.assertEquals(messagesCount, receiveCount.get());\n    } finally {\n      feedClient.deleteFeed(FEED1);\n      try {\n        feedClient.getFeed(FEED1);\n        Assert.fail(\"Should throw NotificationFeedNotFoundException.\");\n      } catch (NotificationFeedNotFoundException e) {\n        // Expected\n      }\n    }\n  }","commit_id":"e073db33184a7c7b5dc5af117e917ac03f09780b","url":"https://github.com/caskdata/cdap"},{"original_method":"private void printMapDetailInfo(BinaryMapIndexReader index, MapIndex mapIndex) throws IOException {\n\t\tfinal StringBuilder b = new StringBuilder();\n\t\tfinal DamnCounter mapObjectsCounter = new DamnCounter();\n\t\tfinal MapStats mapObjectStats = new MapStats();\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n\t\t\t\t\t\"<osm version='0.6'>\\n\");\n\t\t}\n\t\tif (vInfo.isVStats()) {\n\t\t\tBinaryMapIndexReader.READ_STATS = true;\n\t\t}\n\t\tfinal SearchRequest<BinaryMapDataObject> req = BinaryMapIndexReader.buildSearchRequest(\n\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonleft),\n\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonright),\n\t\t\t\tMapUtils.get31TileNumberY(vInfo.lattop),\n\t\t\t\tMapUtils.get31TileNumberY(vInfo.latbottom),\n\t\t\t\tvInfo.getZoom(),\n\t\t\t\tnew SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnew ResultMatcher<BinaryMapDataObject>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject obj) {\n\t\t\t\t\t\tmapObjectsCounter.value++;\n\t\t\t\t\t\tif (vInfo.isVStats()) {\n\t\t\t\t\t\t\tmapObjectStats.process(obj);\n\t\t\t\t\t\t} else if (vInfo.vmapObjects) {\n\t\t\t\t\t\t\tb.setLength(0);\n\t\t\t\t\t\t\tif (vInfo.osm) {\n\t\t\t\t\t\t\t\tprintOsmMapDetails(obj, b, null);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprintToFile(b.toString());\n\t\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t} else if(obj.getId() >> 1 == 205743436l) {\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprintMapDetails(obj, b, vInfo.vmapCoordinates);\n\t\t\t\t\t\t\t\tprintln(b.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tif (vInfo.vstats) {\n\t\t\tmapObjectStats.setReq(req);\n\t\t}\n\t\tindex.searchMapIndex(req, mapIndex);\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<\/osm >\\n\");\n\t\t}\n\t\tif (vInfo.vstats) {\n\t\t\tmapObjectStats.print();\n\t\t}\n\t\tprintln(\"\\tTotal map objects: \" + mapObjectsCounter.value);\n\t}","id":3593,"modified_method":"private void printMapDetailInfo(BinaryMapIndexReader index, MapIndex mapIndex) throws IOException {\n\t\tfinal StringBuilder b = new StringBuilder();\n\t\tfinal DamnCounter mapObjectsCounter = new DamnCounter();\n\t\tfinal MapStats mapObjectStats = new MapStats();\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n\t\t\t\t\t\"<osm version='0.6'>\\n\");\n\t\t}\n\t\tif (vInfo.isVStats()) {\n\t\t\tBinaryMapIndexReader.READ_STATS = true;\n\t\t}\n\t\tfinal SearchRequest<BinaryMapDataObject> req = BinaryMapIndexReader.buildSearchRequest(\n\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonleft),\n\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonright),\n\t\t\t\tMapUtils.get31TileNumberY(vInfo.lattop),\n\t\t\t\tMapUtils.get31TileNumberY(vInfo.latbottom),\n\t\t\t\tvInfo.getZoom(),\n\t\t\t\tnew SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnew ResultMatcher<BinaryMapDataObject>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject obj) {\n\t\t\t\t\t\tmapObjectsCounter.value++;\n\t\t\t\t\t\tif (vInfo.isVStats()) {\n\t\t\t\t\t\t\tmapObjectStats.process(obj);\n\t\t\t\t\t\t} else if (vInfo.vmapObjects) {\n\t\t\t\t\t\t\tb.setLength(0);\n\t\t\t\t\t\t\tif (vInfo.osm) {\n\t\t\t\t\t\t\t\tprintOsmMapDetails(obj, b);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprintToFile(b.toString());\n\t\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t} else if(obj.getId() >> 1 == 205743436l) {\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprintMapDetails(obj, b, vInfo.vmapCoordinates);\n\t\t\t\t\t\t\t\tprintln(b.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tif (vInfo.vstats) {\n\t\t\tmapObjectStats.setReq(req);\n\t\t}\n\t\tindex.searchMapIndex(req, mapIndex);\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<\/osm >\\n\");\n\t\t}\n\t\tif (vInfo.vstats) {\n\t\t\tmapObjectStats.print();\n\t\t}\n\t\tprintln(\"\\tTotal map objects: \" + mapObjectsCounter.value);\n\t}","commit_id":"38a431bda931f22b9216c7929bdb598dae889a8c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void printRouteDetailInfo(BinaryMapIndexReader index, RouteRegion p) throws IOException {\n\t\tfinal DamnCounter mapObjectsCounter = new DamnCounter();\n\t\tfinal StringBuilder b = new StringBuilder();\n\t\tList<RouteSubregion> regions = index.searchRouteIndexTree(\n\t\t\t\tBinaryMapIndexReader.buildSearchRequest(MapUtils.get31TileNumberX(vInfo.lonleft),\n\t\t\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonright), MapUtils.get31TileNumberY(vInfo.lattop),\n\t\t\t\t\t\tMapUtils.get31TileNumberY(vInfo.latbottom), vInfo.getZoom(), null),\n\t\t\t\tp.getSubregions());\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n\t\t\t\t\t\"<osm version='0.6'>\\n\");\n\t\t}\n\t\tindex.loadRouteIndexData(regions, new ResultMatcher<RouteDataObject>() {\n\t\t\t@Override\n\t\t\tpublic boolean publish(RouteDataObject obj) {\n\t\t\t\tmapObjectsCounter.value++;\n\t\t\t\tif (vInfo.osm) {\n\t\t\t\t\tb.setLength(0);\n\t\t\t\t\tBinaryMapDataObject bobj = new BinaryMapDataObject();\n\t\t\t\t\tbobj.setArea(false);\n\t\t\t\t\tbobj.coordinates = new int[obj.pointsX.length * 2];\n\t\t\t\t\tfor(int i = 0; i < obj.pointsX.length; i++) {\n\t\t\t\t\t\tbobj.coordinates[2*i] = obj.pointsX[i];\n\t\t\t\t\t\tbobj.coordinates[2*i +1] = obj.pointsY[i];\n\t\t\t\t\t}\n\t\t\t\t\tbobj.types = obj.types;\n\t\t\t\t\tbobj.setId(obj.getId() << 1);\n\t\t\t\t\tbobj.objectNames = obj.getNames();\n\t\t\t\t\tprintOsmMapDetails(bobj, b, obj.region);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprintToFile(b.toString());\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tb.setLength(0);\n\t\t\t\tb.append(\"Road \");\n\t\t\t\tb.append(obj.id);\n\t\t\t\tb.append(\" osmid \").append(obj.getId() >> (SHIFT_ID));\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < obj.getTypes().length; i++) {\n\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(obj.getTypes()[i]);\n\t\t\t\t\tb.append(\" \").append(rr.getTag()).append(\"='\").append(rr.getValue()).append(\"'\");\n\t\t\t\t}\n\t\t\t\tint[] nameIds = obj.getNameIds();\n\t\t\t\tif (nameIds != null) {\n\t\t\t\t\tfor (int key : nameIds) {\n\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(key);\n\t\t\t\t\t\tb.append(\" \").append(rr.getTag()).append(\"='\").append(obj.getNames().get(key)).append(\"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint pointsLength = obj.getPointsLength();\n\t\t\t\tif(obj.hasPointNames() || obj.hasPointTypes()) {\n\t\t\t\t\tb.append(\" pointtypes [\");\n\t\t\t\t\tfor (int i = 0; i < pointsLength; i++) {\n\t\t\t\t\t\tString[] names = obj.getPointNames(i);\n\t\t\t\t\t\tint[] nametypes = obj.getPointNameTypes(i);\n\t\t\t\t\t\tint[] types = obj.getPointTypes(i);\n\t\t\t\t\t\tif (types != null || names != null) {\n\t\t\t\t\t\t\tb.append(\"[\" + (i + 1) + \". \");\n\t\t\t\t\t\t\tif (names != null) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < names.length; k++) {\n\t\t\t\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(nametypes[k]);\n\t\t\t\t\t\t\t\t\tb.append(rr.getTag()).append(\"='\").append(names[k]).append(\"' \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (types != null) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < types.length; k++) {\n\t\t\t\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(types[k]);\n\t\t\t\t\t\t\t\t\tb.append(rr.getTag()).append(\"='\").append(rr.getValue()).append(\"' \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (vInfo.vmapCoordinates) {\n\t\t\t\t\t\t\t\tfloat x = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\t\t\t\t\tfloat y = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\t\t\t\t\tb.append(y).append(\" / \").append(x).append(\" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tb.append(\"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"]\");\n\t\t\t\t}\n\t\t\t\tif (obj.restrictions != null) {\n\t\t\t\t\tb.append(\" restrictions [\");\n\t\t\t\t\tfor (int i = 0; i < obj.restrictions.length; i++) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tb.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb.append(obj.getRestrictionId(i)).append(\" (\").append(obj.getRestrictionType(i)).append(\") \");\n\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"] \");\n\t\t\t\t}\n\t\t\t\tif (vInfo.vmapCoordinates) {\n\t\t\t\t\tb.append(\" lat/lon : \");\n\t\t\t\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\n\t\t\t\t\t\tfloat x = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\t\t\tfloat y = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\t\t\tb.append(y).append(\" / \").append(x).append(\" , \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintln(b.toString());\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isCancelled() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tprintln(\"\\tTotal map objects: \" + mapObjectsCounter.value);\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<\/osm >\\n\");\n\t\t}\n\t}","id":3594,"modified_method":"private void printRouteDetailInfo(BinaryMapIndexReader index, RouteRegion p) throws IOException {\n\t\tfinal DamnCounter mapObjectsCounter = new DamnCounter();\n\t\tfinal StringBuilder b = new StringBuilder();\n\t\tList<RouteSubregion> regions = index.searchRouteIndexTree(\n\t\t\t\tBinaryMapIndexReader.buildSearchRequest(MapUtils.get31TileNumberX(vInfo.lonleft),\n\t\t\t\t\t\tMapUtils.get31TileNumberX(vInfo.lonright), MapUtils.get31TileNumberY(vInfo.lattop),\n\t\t\t\t\t\tMapUtils.get31TileNumberY(vInfo.latbottom), vInfo.getZoom(), null),\n\t\t\t\tp.getSubregions());\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n\t\t\t\t\t\"<osm version='0.6'>\\n\");\n\t\t}\n\t\tindex.loadRouteIndexData(regions, new ResultMatcher<RouteDataObject>() {\n\t\t\t@Override\n\t\t\tpublic boolean publish(RouteDataObject obj) {\n\t\t\t\tmapObjectsCounter.value++;\n\t\t\t\tif (vInfo.osm) {\n\t\t\t\t\tb.setLength(0);\n\t\t\t\t\tprintOsmRouteDetails(obj, b);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprintToFile(b.toString());\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tb.setLength(0);\n\t\t\t\tb.append(\"Road \");\n\t\t\t\tb.append(obj.id);\n\t\t\t\tb.append(\" osmid \").append(obj.getId() >> (SHIFT_ID));\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < obj.getTypes().length; i++) {\n\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(obj.getTypes()[i]);\n\t\t\t\t\tb.append(\" \").append(rr.getTag()).append(\"='\").append(rr.getValue()).append(\"'\");\n\t\t\t\t}\n\t\t\t\tint[] nameIds = obj.getNameIds();\n\t\t\t\tif (nameIds != null) {\n\t\t\t\t\tfor (int key : nameIds) {\n\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(key);\n\t\t\t\t\t\tb.append(\" \").append(rr.getTag()).append(\"='\").append(obj.getNames().get(key)).append(\"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint pointsLength = obj.getPointsLength();\n\t\t\t\tif(obj.hasPointNames() || obj.hasPointTypes()) {\n\t\t\t\t\tb.append(\" pointtypes [\");\n\t\t\t\t\tfor (int i = 0; i < pointsLength; i++) {\n\t\t\t\t\t\tString[] names = obj.getPointNames(i);\n\t\t\t\t\t\tint[] nametypes = obj.getPointNameTypes(i);\n\t\t\t\t\t\tint[] types = obj.getPointTypes(i);\n\t\t\t\t\t\tif (types != null || names != null) {\n\t\t\t\t\t\t\tb.append(\"[\" + (i + 1) + \". \");\n\t\t\t\t\t\t\tif (names != null) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < names.length; k++) {\n\t\t\t\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(nametypes[k]);\n\t\t\t\t\t\t\t\t\tb.append(rr.getTag()).append(\"='\").append(names[k]).append(\"' \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (types != null) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < types.length; k++) {\n\t\t\t\t\t\t\t\t\tRouteTypeRule rr = obj.region.quickGetEncodingRule(types[k]);\n\t\t\t\t\t\t\t\t\tb.append(rr.getTag()).append(\"='\").append(rr.getValue()).append(\"' \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (vInfo.vmapCoordinates) {\n\t\t\t\t\t\t\t\tfloat x = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\t\t\t\t\tfloat y = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\t\t\t\t\tb.append(y).append(\" / \").append(x).append(\" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tb.append(\"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"]\");\n\t\t\t\t}\n\t\t\t\tif (obj.restrictions != null) {\n\t\t\t\t\tb.append(\" restrictions [\");\n\t\t\t\t\tfor (int i = 0; i < obj.restrictions.length; i++) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tb.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb.append(obj.getRestrictionId(i)).append(\" (\").append(\n\t\t\t\t\t\t\t\tMapRenderingTypes.getRestrictionValue(\n\t\t\t\t\t\t\t\tobj.getRestrictionType(i))).append(\") \");\n\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"] \");\n\t\t\t\t}\n\t\t\t\tif (vInfo.vmapCoordinates) {\n\t\t\t\t\tb.append(\" lat/lon : \");\n\t\t\t\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\n\t\t\t\t\t\tfloat x = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\t\t\tfloat y = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\t\t\tb.append(y).append(\" / \").append(x).append(\" , \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintln(b.toString());\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isCancelled() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tprintln(\"\\tTotal map objects: \" + mapObjectsCounter.value);\n\t\tif (vInfo.osm) {\n\t\t\tprintToFile(\"<\/osm >\\n\");\n\t\t}\n\t}","commit_id":"38a431bda931f22b9216c7929bdb598dae889a8c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void printOsmMapDetails(BinaryMapDataObject obj, StringBuilder b, RouteRegion reg) {\n\t\tboolean multipolygon = obj.getPolygonInnerCoordinates() != null && obj.getPolygonInnerCoordinates().length > 0;\n\t\tboolean point = obj.getPointsLength() == 1;\n\t\tStringBuilder tags = new StringBuilder();\n\t\tint[] types = obj.getTypes();\n\t\tfor (int j = 0; j < types.length; j++) {\n\t\t\tTagValuePair pair = reg != null ? convert(reg.quickGetEncodingRule(types[j])): obj.getMapIndex().decodeType(types[j]);\n\t\t\tif (pair == null) {\n\t\t\t\tthrow new NullPointerException(\"Type \" + types[j] + \"was not found\");\n\t\t\t}\n\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(pair.value).append(\"' />\\n\");\n\t\t}\n\t\tif (obj.getAdditionalTypes() != null && obj.getAdditionalTypes().length > 0) {\n\t\t\tfor (int j = 0; j < obj.getAdditionalTypes().length; j++) {\n\t\t\t\tint addtype = obj.getAdditionalTypes()[j];\n\t\t\t\tTagValuePair pair = reg != null ? convert(reg.quickGetEncodingRule(addtype)): \n\t\t\t\t\t\tobj.getMapIndex().decodeType(addtype);\n\t\t\t\tif (pair == null) {\n\t\t\t\t\tthrow new NullPointerException(\"Type \" + obj.getAdditionalTypes()[j] + \"was not found\");\n\t\t\t\t}\n\t\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(pair.value).append(\"' />\\n\");\n\t\t\t}\n\t\t}\n\t\tTIntObjectHashMap<String> names = obj.getObjectNames();\n\t\tif (names != null && !names.isEmpty()) {\n\t\t\tint[] keys = names.keys();\n\t\t\tfor (int j = 0; j < keys.length; j++) {\n\t\t\t\tTagValuePair pair = reg != null ? convert(reg.quickGetEncodingRule(keys[j])): obj.getMapIndex().decodeType(keys[j]);\n\t\t\t\tif (pair == null) {\n\t\t\t\t\tthrow new NullPointerException(\"Type \" + keys[j] + \"was not found\");\n\t\t\t\t}\n\t\t\t\tString name = names.get(keys[j]);\n\t\t\t\tname = name.replace(\"'\", \"&apos;\");\n\t\t\t\tname = name.replace(\"&\", \"&amp;\");\n\t\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(name).append(\"' />\\n\");\n\t\t\t}\n\t\t}\n\n\t\ttags.append(\"\\t<tag k=\\'\").append(\"original_id\").append(\"' v='\").append(obj.getId() >> (SHIFT_ID + 1)).append(\"'/>\\n\");\n\t\ttags.append(\"\\t<tag k=\\'\").append(\"osmand_id\").append(\"' v='\").append(obj.getId()).append(\"'/>\\n\");\n\n\t\tif(point) {\n\t\t\tfloat lon= (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(0));\n\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(0));\n\t\t\tb.append(\"<node id = '\" + OSM_ID++ + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' >\\n\");\n\t\t\tb.append(tags);\n\t\t\tb.append(\"<\/node>\\n\");\n\t\t} else {\n\t\t\tTLongArrayList innerIds = new TLongArrayList();\n\t\t\tTLongArrayList ids = new TLongArrayList();\n\t\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\n\t\t\t\tfloat lon = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\tint id = OSM_ID++;\n\t\t\t\tb.append(\"\\t<node id = '\" + id + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' />\\n\");\n\t\t\t\tids.add(id);\n\t\t\t}\n\t\t\tlong outerId = printWay(ids, b, multipolygon ? null : tags);\n\t\t\tif (multipolygon) {\n\t\t\t\tint[][] polygonInnerCoordinates = obj.getPolygonInnerCoordinates();\n\t\t\t\tfor (int j = 0; j < polygonInnerCoordinates.length; j++) {\n\t\t\t\t\tids.clear();\n\t\t\t\t\tfor (int i = 0; i < polygonInnerCoordinates[j].length; i += 2) {\n\t\t\t\t\t\tfloat lon = (float) MapUtils.get31LongitudeX(polygonInnerCoordinates[j][i]);\n\t\t\t\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(polygonInnerCoordinates[j][i + 1]);\n\t\t\t\t\t\tint id = OSM_ID++;\n\t\t\t\t\t\tb.append(\"<node id = '\" + id + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' />\\n\");\n\t\t\t\t\t\tids.add(id);\n\t\t\t\t\t}\n\t\t\t\t\tinnerIds.add(printWay(ids, b, null));\n\t\t\t\t}\n\t\t\t\tint id = OSM_ID++;\n\t\t\t\tb.append(\"<relation id = '\" + id + \"' version='1'>\\n\");\n\t\t\t\tb.append(tags);\n\t\t\t\tb.append(\"\\t<member type='way' role='outer' ref= '\" + outerId + \"'/>\\n\");\n\t\t\t\tTLongIterator it = innerIds.iterator();\n\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t\tlong ref = it.next();\n\t\t\t\t\tb.append(\"<member type='way' role='inner' ref= '\" + ref + \"'/>\\n\");\n\t\t\t\t}\n\t\t\t\tb.append(\"<\/relation>\\n\");\n\t\t\t}\n\t\t}\n\t}","id":3595,"modified_method":"private void printOsmMapDetails(BinaryMapDataObject obj, StringBuilder b) {\n\t\tboolean multipolygon = obj.getPolygonInnerCoordinates() != null && obj.getPolygonInnerCoordinates().length > 0;\n\t\tboolean point = obj.getPointsLength() == 1;\n\t\tStringBuilder tags = new StringBuilder();\n\t\tint[] types = obj.getTypes();\n\t\tfor (int j = 0; j < types.length; j++) {\n\t\t\tTagValuePair pair = obj.getMapIndex().decodeType(types[j]);\n\t\t\tif (pair == null) {\n\t\t\t\tthrow new NullPointerException(\"Type \" + types[j] + \"was not found\");\n\t\t\t}\n\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(pair.value).append(\"' />\\n\");\n\t\t}\n\t\tif (obj.getAdditionalTypes() != null && obj.getAdditionalTypes().length > 0) {\n\t\t\tfor (int j = 0; j < obj.getAdditionalTypes().length; j++) {\n\t\t\t\tint addtype = obj.getAdditionalTypes()[j];\n\t\t\t\tTagValuePair pair = obj.getMapIndex().decodeType(addtype);\n\t\t\t\tif (pair == null) {\n\t\t\t\t\tthrow new NullPointerException(\"Type \" + obj.getAdditionalTypes()[j] + \"was not found\");\n\t\t\t\t}\n\t\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(pair.value).append(\"' />\\n\");\n\t\t\t}\n\t\t}\n\t\tTIntObjectHashMap<String> names = obj.getObjectNames();\n\t\tif (names != null && !names.isEmpty()) {\n\t\t\tint[] keys = names.keys();\n\t\t\tfor (int j = 0; j < keys.length; j++) {\n\t\t\t\tTagValuePair pair = obj.getMapIndex().decodeType(keys[j]);\n\t\t\t\tif (pair == null) {\n\t\t\t\t\tthrow new NullPointerException(\"Type \" + keys[j] + \"was not found\");\n\t\t\t\t}\n\t\t\t\tString name = names.get(keys[j]);\n\t\t\t\tname = quoteName(name);\n\t\t\t\ttags.append(\"\\t<tag k='\").append(pair.tag).append(\"' v='\").append(name).append(\"' />\\n\");\n\t\t\t}\n\t\t}\n\n\t\ttags.append(\"\\t<tag k=\\'\").append(\"original_id\").append(\"' v='\").append(obj.getId() >> (SHIFT_ID + 1)).append(\"'/>\\n\");\n\t\ttags.append(\"\\t<tag k=\\'\").append(\"osmand_id\").append(\"' v='\").append(obj.getId()).append(\"'/>\\n\");\n\n\t\tif(point) {\n\t\t\tfloat lon= (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(0));\n\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(0));\n\t\t\tb.append(\"<node id = '\" + OSM_ID++ + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' >\\n\");\n\t\t\tb.append(tags);\n\t\t\tb.append(\"<\/node>\\n\");\n\t\t} else {\n\t\t\tTLongArrayList innerIds = new TLongArrayList();\n\t\t\tTLongArrayList ids = new TLongArrayList();\n\t\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\n\t\t\t\tfloat lon = (float) MapUtils.get31LongitudeX(obj.getPoint31XTile(i));\n\t\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(obj.getPoint31YTile(i));\n\t\t\t\tint id = OSM_ID++;\n\t\t\t\tb.append(\"\\t<node id = '\" + id + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' />\\n\");\n\t\t\t\tids.add(id);\n\t\t\t}\n\t\t\tlong outerId = printWay(ids, b, multipolygon ? null : tags);\n\t\t\tif (multipolygon) {\n\t\t\t\tint[][] polygonInnerCoordinates = obj.getPolygonInnerCoordinates();\n\t\t\t\tfor (int j = 0; j < polygonInnerCoordinates.length; j++) {\n\t\t\t\t\tids.clear();\n\t\t\t\t\tfor (int i = 0; i < polygonInnerCoordinates[j].length; i += 2) {\n\t\t\t\t\t\tfloat lon = (float) MapUtils.get31LongitudeX(polygonInnerCoordinates[j][i]);\n\t\t\t\t\t\tfloat lat = (float) MapUtils.get31LatitudeY(polygonInnerCoordinates[j][i + 1]);\n\t\t\t\t\t\tint id = OSM_ID++;\n\t\t\t\t\t\tb.append(\"<node id = '\" + id + \"' version='1' lat='\" + lat + \"' lon='\" + lon + \"' />\\n\");\n\t\t\t\t\t\tids.add(id);\n\t\t\t\t\t}\n\t\t\t\t\tinnerIds.add(printWay(ids, b, null));\n\t\t\t\t}\n\t\t\t\tint id = OSM_ID++;\n\t\t\t\tb.append(\"<relation id = '\" + id + \"' version='1'>\\n\");\n\t\t\t\tb.append(tags);\n\t\t\t\tb.append(\"\\t<member type='way' role='outer' ref= '\" + outerId + \"'/>\\n\");\n\t\t\t\tTLongIterator it = innerIds.iterator();\n\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t\tlong ref = it.next();\n\t\t\t\t\tb.append(\"<member type='way' role='inner' ref= '\" + ref + \"'/>\\n\");\n\t\t\t\t}\n\t\t\t\tb.append(\"<\/relation>\\n\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"38a431bda931f22b9216c7929bdb598dae889a8c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", null);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", ManagementConstants.DEFAULT_DOMAIN_NAME);\n            usePlatformMBeanServer = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", null));\n            createMBServerConnectorFactory = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", null));\n            daemon = Boolean.valueOf(getBusProperty(b, \"bus.jmx.daemon\", null));\n            threaded = Boolean.valueOf(getBusProperty(b, \"bus.jmx.threaded\", null));\n            enabled = Boolean.valueOf(getBusProperty(b, \"bus.jmx.enabled\", null));\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", null);\n        }\n    }","id":3596,"modified_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", persistentBusId);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", mbeanServerName);\n            usePlatformMBeanServer = \n                getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", usePlatformMBeanServer);\n            createMBServerConnectorFactory = \n                getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", createMBServerConnectorFactory);\n            daemon = getBusProperty(b, \"bus.jmx.daemon\", daemon);\n            threaded = getBusProperty(b, \"bus.jmx.threaded\", threaded);\n            enabled = getBusProperty(b, \"bus.jmx.enabled\", enabled);\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", jmxServiceURL);\n        }\n    }","commit_id":"40083b6612cd9c6bef05fe0b42f8816bbcbe2acb","url":"https://github.com/apache/cxf"},{"original_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", null);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", ManagementConstants.DEFAULT_DOMAIN_NAME);\n            usePlatformMBeanServer = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", null));\n            createMBServerConnectorFactory = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", null));\n            daemon = Boolean.valueOf(getBusProperty(b, \"bus.jmx.daemon\", null));\n            threaded = Boolean.valueOf(getBusProperty(b, \"bus.jmx.threaded\", null));\n            enabled = Boolean.valueOf(getBusProperty(b, \"bus.jmx.enabled\", null));\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", null);\n        }\n    }","id":3597,"modified_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", persistentBusId);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", mbeanServerName);\n            usePlatformMBeanServer = \n                getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", usePlatformMBeanServer);\n            createMBServerConnectorFactory = \n                getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", createMBServerConnectorFactory);\n            daemon = getBusProperty(b, \"bus.jmx.daemon\", daemon);\n            threaded = getBusProperty(b, \"bus.jmx.threaded\", threaded);\n            enabled = getBusProperty(b, \"bus.jmx.enabled\", enabled);\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", jmxServiceURL);\n        }\n    }","commit_id":"db82d889523ce1627ea748353f501d1dad11e6ca","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Returns the {@code TransparentColor} defined in image reader metadata.\n     * @param reader The image reader\n     * @return the {@code TransparentColor} defined in image reader metadata, or {@code null}\n     * @throws IOException if an error occurs during reading\n     * @since 7132\n     * @see <a href=\"http://docs.oracle.com/javase/7/docs/api/javax/imageio/metadata/doc-files/standard_metadata.html\">javax_imageio_1.0 metadata<\/a>\n     */\n    public static Color getTransparentColor(ImageReader reader) throws IOException {\n        IIOMetadata metadata = reader.getImageMetadata(0);\n        if (metadata != null) {\n            String[] formats = metadata.getMetadataFormatNames();\n            if (formats != null) {\n                for (String f : formats) {\n                    if (\"javax_imageio_1.0\".equals(f)) {\n                        Node root = metadata.getAsTree(f);\n                        if (root instanceof Element) {\n                            Node item = ((Element)root).getElementsByTagName(\"TransparentColor\").item(0);\n                            if (item instanceof Element) {\n                                String value = ((Element)item).getAttribute(\"value\");\n                                String[] s = value.split(\" \");\n                                if (s.length == 3) {\n                                    int[] rgb = new int[3];\n                                    try {\n                                        for (int i = 0; i<3; i++) {\n                                            rgb[i] = Integer.parseInt(s[i]);\n                                        }\n                                        return new Color(rgb[0], rgb[1], rgb[2]);\n                                    } catch (IllegalArgumentException e) {\n                                        Main.error(e);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return null;\n    }","id":3598,"modified_method":"/**\n     * Returns the {@code TransparentColor} defined in image reader metadata.\n     * @param reader The image reader\n     * @return the {@code TransparentColor} defined in image reader metadata, or {@code null}\n     * @throws IOException if an error occurs during reading\n     * @since 7132\n     * @see <a href=\"http://docs.oracle.com/javase/7/docs/api/javax/imageio/metadata/doc-files/standard_metadata.html\">javax_imageio_1.0 metadata<\/a>\n     */\n    public static Color getTransparentColor(ImageReader reader) throws IOException {\n        IIOMetadata metadata = reader.getImageMetadata(0);\n        if (metadata != null) {\n            String[] formats = metadata.getMetadataFormatNames();\n            if (formats != null) {\n                for (String f : formats) {\n                    if (\"javax_imageio_1.0\".equals(f)) {\n                        Node root = metadata.getAsTree(f);\n                        if (root instanceof Element) {\n                            NodeList list = ((Element)root).getElementsByTagName(\"TransparentColor\");\n                            if (list.getLength() > 0) {\n                                Node item = list.item(0);\n                                if (item instanceof Element) {\n                                    String value = ((Element)item).getAttribute(\"value\");\n                                    String[] s = value.split(\" \");\n                                    if (s.length == 3) {\n                                        int[] rgb = new int[3];\n                                        try {\n                                            for (int i = 0; i<3; i++) {\n                                                rgb[i] = Integer.parseInt(s[i]);\n                                            }\n                                            return new Color(rgb[0], rgb[1], rgb[2]);\n                                        } catch (IllegalArgumentException e) {\n                                            Main.error(e);\n                                        }\n                                    }\n                            }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return null;\n    }","commit_id":"04e77ceaa2cc1a5b3112ade9cd251dce79d58072","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void writeFile(Document doc) throws CaseMetadataException {\n        if (doc == null || getCaseName().equals(\"\")) {\n            throw new CaseMetadataException(\n                    Bundle.CaseMetadata_writeFile_exception_noCase_msg());\n        }\n\n        // Prepare the DOM document for writing\n        Source source = new DOMSource(doc);\n\n        // Prepare the data for the output file\n        StringWriter sw = new StringWriter();\n        Result result = new StreamResult(sw);\n\n        // Write the DOM document to the file\n        Transformer xformer;// = TransformerFactory.newInstance().newTransformer();\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n\n        try {\n            xformer = tfactory.newTransformer();\n        } catch (TransformerConfigurationException ex) {\n            throw new CaseMetadataException(\n                    Bundle.CaseMetadata_writeFile_exception_errWriteToFile_msg(), ex);\n        }\n\n        //Setup indenting to \"pretty print\"\n        xformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //NON-NLS\n        xformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\"); //NON-NLS\n\n        try {\n            xformer.transform(source, result);\n        } catch (TransformerException ex) {\n            throw new CaseMetadataException(\n                    Bundle.CaseMetadata_writeFile_exception_errWriteToFile_msg(), ex);\n        }\n\n        // preparing the output file\n        String xmlString = sw.toString();\n        File file = new File(Paths.get(this.getCaseDirectory(), this.fileName + \".aut\").toString());\n\n        // write the file\n        try {\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));\n            bw.write(xmlString);\n            bw.flush();\n            bw.close();\n        } catch (IOException ex) {\n            throw new CaseMetadataException(\n                    Bundle.CaseMetadata_writeFile_exception_errWriteToFile_msg(), ex);\n        }\n    }","id":3599,"modified_method":"private void writeFile(Document doc) throws CaseMetadataException {\n        if (doc == null || getCaseName().equals(\"\")) {\n            throw new CaseMetadataException(\n                    \"No set case to write management file for.\"\n            );\n        }\n\n        // Prepare the DOM document for writing\n        Source source = new DOMSource(doc);\n\n        // Prepare the data for the output file\n        StringWriter sw = new StringWriter();\n        Result result = new StreamResult(sw);\n\n        // Write the DOM document to the file\n        Transformer xformer;// = TransformerFactory.newInstance().newTransformer();\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n\n        try {\n            xformer = tfactory.newTransformer();\n        } catch (TransformerConfigurationException ex) {\n            throw new CaseMetadataException(\n                    \"Error writing to case file\", ex);\n        }\n\n        //Setup indenting to \"pretty print\"\n        xformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //NON-NLS\n        xformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\"); //NON-NLS\n\n        try {\n            xformer.transform(source, result);\n        } catch (TransformerException ex) {\n            throw new CaseMetadataException(\n                    \"Error writing to case file\", ex);\n        }\n\n        // preparing the output file\n        String xmlString = sw.toString();\n        File file = new File(Paths.get(this.getCaseDirectory(), this.fileName + \".aut\").toString());\n\n        // write the file\n        try {\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));\n            bw.write(xmlString);\n            bw.flush();\n            bw.close();\n        } catch (IOException ex) {\n            throw new CaseMetadataException(\n                    \"Error writing to case file\", ex);\n        }\n    }","commit_id":"3359f94e93c283f610b28a63a05a8c86e3a39f35","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Used to open a case at the given file path\n     *\n     * @param metadataFilePath the string file path for the case\n     *\n     * @throws\n     * org.sleuthkit.autopsy.casemodule.CaseMetadata.CaseMetadataException\n     */\n    private CaseMetadata(String metadataFilePath) throws CaseMetadataException {\n        this.open(metadataFilePath);\n    }","id":3600,"modified_method":"/**\n     * Used to read a case at the given file path\n     *\n     * @param metadataFilePath the string file path for the case\n     *\n     * @throws\n     * org.sleuthkit.autopsy.casemodule.CaseMetadata.CaseMetadataException\n     */\n    private CaseMetadata(String metadataFilePath) throws CaseMetadataException {\n        this.read(metadataFilePath);\n    }","commit_id":"3359f94e93c283f610b28a63a05a8c86e3a39f35","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Opens the configuration file and load the document handler Note: this is\n     * for the schema version 1.0\n     *\n     * @param conFilePath the path of the XML case configuration file path\n     */\n    private void open(String conFilePath) throws CaseMetadataException {\n        File file = new File(conFilePath);\n        Document doc;\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db;\n        try {\n            db = dbf.newDocumentBuilder();\n            doc = db.parse(file);\n        } catch (ParserConfigurationException | SAXException | IOException ex) {\n            throw new CaseMetadataException(\n                    Bundle.CaseMetadata_open_exception_errReadXMLFile_msg(conFilePath), ex);\n        }\n\n        doc.getDocumentElement().normalize();\n        doc.getDocumentElement().normalize();\n\n        Element rootEl = doc.getDocumentElement();\n        String rootName = rootEl.getNodeName();\n\n        // check if it's the autopsy case, if not, throws an error\n        if (!rootName.equals(TOP_ROOT_NAME)) {\n            // throw an error ...\n            if (RuntimeProperties.coreComponentsAreActive()) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_msgDlg_noCaseHeaderTag_msg());\n            }\n        } else {\n            /*\n             * Autopsy Created Version\n             */\n            Element rootElement = doc.getDocumentElement();\n\n            String createdVersion = ((Element) rootElement.getElementsByTagName(AUTOPSY_CRVERSION_NAME).item(0)).getTextContent(); // get the created version\n\n            // check if it has the same autopsy version as the current one\n            if (!createdVersion.equals(System.getProperty(\"netbeans.buildnumber\"))) {\n                // if not the same version, update the saved version in the xml to the current version\n                rootElement.getElementsByTagName(AUTOPSY_MVERSION_NAME).item(0).setTextContent(System.getProperty(\"netbeans.buildnumber\"));\n            }\n            String fullFileName = file.getName();\n            String fileName = fullFileName.substring(0, fullFileName.lastIndexOf(\".\")); // remove the extension\n            this.fileName = fileName;\n            NodeList rootNameList = doc.getElementsByTagName(CASE_ROOT_NAME);\n            if (rootNameList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_caseRootError());\n            }\n            Element caseElement = (Element) rootNameList.item(0);\n            NodeList caseTypeList = caseElement.getElementsByTagName(CASE_TYPE);\n            if (caseTypeList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_caseTypeError());\n            }\n            String caseTypeString = ((Element) caseTypeList.item(0)).getTextContent();\n            this.caseType = caseTypeString.equals(\"\") ? Case.CaseType.SINGLE_USER_CASE : Case.CaseType.fromString(caseTypeString);\n            NodeList caseNameList = caseElement.getElementsByTagName(NAME);\n            if (caseNameList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_caseTypeError());\n            }\n            this.caseName = ((Element) caseNameList.item(0)).getTextContent();\n            Element numberElement = caseElement.getElementsByTagName(NUMBER).getLength() > 0 ? (Element) caseElement.getElementsByTagName(NUMBER).item(0) : null;\n            this.caseNumber = numberElement != null ? numberElement.getTextContent() : \"\";\n            Element examinerElement = caseElement.getElementsByTagName(EXAMINER).getLength() > 0 ? (Element) caseElement.getElementsByTagName(EXAMINER).item(0) : null;\n            this.examiner = examinerElement != null ? examinerElement.getTextContent() : \"\";\n            this.caseDirectory = conFilePath.substring(0, conFilePath.lastIndexOf(\"\\\\\"));\n            if (this.caseDirectory.isEmpty()) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_exception_errReadXMLFile_msg(conFilePath));\n            }\n            NodeList databaseNameList = caseElement.getElementsByTagName(DATABASE_NAME);\n            if (databaseNameList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_caseDatabaseNameError());\n            }\n            Element databaseNameElement = (Element) databaseNameList.item(0);\n            this.caseDatabaseName = databaseNameElement.getTextContent();\n            NodeList textIndexList = caseElement.getElementsByTagName(CASE_TEXT_INDEX_NAME);\n            if(textIndexList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_caseIndexError());\n            }\n            Element caseTextIndexNameElement = (Element)textIndexList.item(0);\n            this.caseTextIndexName = caseTextIndexNameElement.getTextContent();\n            if (Case.CaseType.MULTI_USER_CASE == caseType && caseDatabaseName.isEmpty()) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_exception_errReadXMLFile_msg(conFilePath));\n            }\n            NodeList createdDateList = rootElement.getElementsByTagName(CREATED_DATE_NAME);\n            if(createdDateList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_createdDateError());\n            }\n            this.setCreatedDate(((Element)createdDateList.item(0)).getTextContent());\n            NodeList createdVersionList = rootElement.getElementsByTagName(AUTOPSY_CRVERSION_NAME);\n            if(createdVersionList.getLength() == 0) {\n                throw new CaseMetadataException(Bundle.CaseMetadata_open_createdVersionError());\n            }\n            this.setCreatedVersion((((Element)createdVersionList.item(0))).getTextContent());\n        }\n    }","id":3601,"modified_method":"/**\n     * Opens the configuration file and load the document handler Note: this is\n     * for the schema version 1.0\n     *\n     * @param conFilePath the path of the XML case configuration file path\n     */\n    private void read(String conFilePath) throws CaseMetadataException {\n        File file = new File(conFilePath);\n        Document doc;\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db;\n        try {\n            db = dbf.newDocumentBuilder();\n            doc = db.parse(file);\n        } catch (ParserConfigurationException | SAXException | IOException ex) {\n            throw new CaseMetadataException(\n                    \"Error reading case XML file\\\\:\" + conFilePath, ex);\n        }\n\n        doc.getDocumentElement().normalize();\n\n        Element rootEl = doc.getDocumentElement();\n        String rootName = rootEl.getNodeName();\n\n        if (!rootName.equals(TOP_ROOT_NAME)) {\n            // throw an error because the xml is malformed\n            if (RuntimeProperties.coreComponentsAreActive()) {\n                throw new CaseMetadataException(\"Root element not recognized as autopsy case tag\");\n            }\n        } else {\n            /*\n             * Autopsy Created Version\n             */\n            Element rootElement = doc.getDocumentElement();\n\n            NodeList cversionList = rootElement.getElementsByTagName(AUTOPSY_CRVERSION_NAME);\n            if(cversionList.getLength() == 0) {\n                throw new CaseMetadataException(\"Could not find created version in metadata\");\n            }\n            String createdVersion = cversionList.item(0).getTextContent(); // get the created version\n            // check if it has the same autopsy version as the current one\n            if (!createdVersion.equals(System.getProperty(\"netbeans.buildnumber\"))) {\n                // if not the same version, update the saved version in the xml to the current version\n                rootElement.getElementsByTagName(AUTOPSY_MVERSION_NAME).item(0).setTextContent(System.getProperty(\"netbeans.buildnumber\"));\n            }\n            \n            String fullFileName = file.getName();\n            String fileName = fullFileName.substring(0, fullFileName.lastIndexOf(\".\")); // remove the extension\n            this.fileName = fileName;\n            \n            NodeList rootNameList = doc.getElementsByTagName(CASE_ROOT_NAME);\n            if (rootNameList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get case root\");\n            }\n            Element caseElement = (Element) rootNameList.item(0);\n            \n            NodeList caseTypeList = caseElement.getElementsByTagName(CASE_TYPE);\n            if (caseTypeList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get case type\");\n            }\n            String caseTypeString = caseTypeList.item(0).getTextContent();\n            this.caseType = Case.CaseType.fromString(caseTypeString);\n            if(this.caseType == null) {\n                throw new CaseMetadataException(\"Invalid case type\");\n            }\n            \n            NodeList caseNameList = caseElement.getElementsByTagName(NAME);\n            if (caseNameList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get case name\");\n            }\n            this.caseName = caseNameList.item(0).getTextContent();\n            if(this.caseName.isEmpty()) {\n                throw new CaseMetadataException(\"Invalid case name, cannot be empty\");\n            }\n            \n            Element numberElement = caseElement.getElementsByTagName(NUMBER).getLength() > 0 ? (Element) caseElement.getElementsByTagName(NUMBER).item(0) : null;\n            this.caseNumber = numberElement != null ? numberElement.getTextContent() : \"\";\n            \n            Element examinerElement = caseElement.getElementsByTagName(EXAMINER).getLength() > 0 ? (Element) caseElement.getElementsByTagName(EXAMINER).item(0) : null;\n            this.examiner = examinerElement != null ? examinerElement.getTextContent() : \"\";\n            \n            this.caseDirectory = conFilePath.substring(0, conFilePath.lastIndexOf(\"\\\\\"));\n            if (this.caseDirectory.isEmpty()) {\n                throw new CaseMetadataException(\"Could not get a valid case directory\");\n            }\n            \n            NodeList databaseNameList = caseElement.getElementsByTagName(DATABASE_NAME);\n            if (databaseNameList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get database name\");\n            }\n            Element databaseNameElement = (Element) databaseNameList.item(0);\n            this.caseDatabaseName = databaseNameElement.getTextContent();\n            if (Case.CaseType.MULTI_USER_CASE == caseType && caseDatabaseName.isEmpty()) {\n                throw new CaseMetadataException(\"Case database name cannot be empty in multi user case.\");\n            }\n            \n            NodeList textIndexList = caseElement.getElementsByTagName(CASE_TEXT_INDEX_NAME);\n            if (textIndexList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get text index\");\n            }\n            Element caseTextIndexNameElement = (Element) textIndexList.item(0);\n            this.caseTextIndexName = caseTextIndexNameElement.getTextContent();\n            \n            NodeList createdDateList = rootElement.getElementsByTagName(CREATED_DATE_NAME);\n            if (createdDateList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get created date\");\n            }\n            this.createdDate = createdDateList.item(0).getTextContent();\n            \n            NodeList createdVersionList = rootElement.getElementsByTagName(AUTOPSY_CRVERSION_NAME);\n            if (createdVersionList.getLength() == 0) {\n                throw new CaseMetadataException(\"Couldn't get created version\");\n            }\n            this.createdVersion = createdVersionList.item(0).getTextContent();\n        }\n    }","commit_id":"3359f94e93c283f610b28a63a05a8c86e3a39f35","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static String getTagValue(String tag, Element eElement){\n\t        NodeList nlList= eElement.getElementsByTagName(tag).item(0).getChildNodes();\n\t        Node nValue = (Node) nlList.item(0); \n\t     \n\t        return nValue.getNodeValue();    \n\t     }","id":3602,"modified_method":"private static String getTagValue(String tag, Element eElement){\n\t    NodeList tagNodeList = eElement.getElementsByTagName(tag);\n\t    if (tagNodeList == null || tagNodeList.getLength() == 0) {\n\t        return null;\n\t    }\n\t    \n\t    NodeList nlList= tagNodeList.item(0).getChildNodes();\n\n\t    Node nValue = (Node) nlList.item(0); \n\n\t    return nValue.getNodeValue();    \n\t}","commit_id":"954dacdbda8ab41bcd5dca12f2b19fbc55c11ec9","url":"https://github.com/apache/cloudstack"},{"original_method":"public XmldbURI createFile(String newName, InputStream is, Long length, String contentType)\n            throws IOException, PermissionDeniedException, CollectionDoesNotExistException {\n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"Create '\" + newName + \"' in '\" + xmldbUri + \"'\");\n\n        XmldbURI newNameUri = XmldbURI.create(newName);\n\n        // Get mime, or NULL when not available\n        MimeType mime = MimeTable.getInstance().getContentTypeFor(newName);\n        if (mime == null) {\n            mime = MimeType.BINARY_TYPE;\n        }\n\n        // References to the database\n        DBBroker broker = null;\n        Collection collection = null;\n\n        // create temp file and store. Existdb needs to read twice from a stream.\n        BufferedInputStream bis = new BufferedInputStream(is);\n\n        VirtualTempFile vtf = new VirtualTempFile();\n\n        BufferedOutputStream bos = new BufferedOutputStream(vtf);\n\n        // Perform actual copy\n        IOUtils.copy(bis, bos);\n        bis.close();\n        bos.close();\n        vtf.close();\n\n        // To support LockNullResource, a 0-byte XML document can received. Since 0-byte\n        // XML documents are not supported a small file will be created.\n        if (mime.isXMLType() && vtf.length() == 0L) {\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Creating dummy XML file for null resource lock '\" + newNameUri + \"'\");\n\n            vtf = new VirtualTempFile();\n            IOUtils.write(\"<null_resource/>\", vtf);\n            vtf.close();\n        }\n\n        // Start transaction\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn txn = transact.beginTransaction();\n\n        try {\n            broker = brokerPool.get(subject);\n\n            // Check if collection exists. not likely to happen since availability is checked\n            // by ResourceFactory\n            collection = broker.openCollection(xmldbUri, Lock.WRITE_LOCK);\n            if (collection == null) {\n                LOG.debug(\"Collection \" + xmldbUri + \" does not exist\");\n                transact.abort(txn);\n                throw new CollectionDoesNotExistException(xmldbUri + \"\");\n            }\n\n\n            if (mime.isXMLType()) {\n\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Inserting XML document '\" + mime.getName() + \"'\");\n\n                // Stream into database\n                VirtualTempFileInputSource vtfis = new VirtualTempFileInputSource(vtf);\n                IndexInfo info = collection.validateXMLResource(txn, broker, newNameUri, vtfis);\n                DocumentImpl doc = info.getDocument();\n                doc.getMetadata().setMimeType(mime.getName());\n                collection.store(txn, broker, info, vtfis, false);\n\n            } else {\n\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Inserting BINARY document '\" + mime.getName() + \"'\");\n\n                // Stream into database\n                InputStream fis = vtf.getByteStream();\n                bis = new BufferedInputStream(fis);\n                DocumentImpl doc = collection.addBinaryResource(txn, broker, newNameUri, bis,\n                        mime.getName(), length.longValue());\n                bis.close();\n            }\n\n            // Commit change\n            transact.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Document created sucessfully\");\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (TriggerException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (SAXException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (LockException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new PermissionDeniedException(xmldbUri + \"\");\n\n        } catch (IOException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw e;\n\n        } finally {\n\n            if (vtf != null) {\n                vtf.delete();\n            }\n\n            // TODO: check if can be done earlier\n            if (collection != null) {\n                collection.release(Lock.WRITE_LOCK);\n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished creation\");\n        }\n\n        // Send the result back to the client\n        XmldbURI newResource = xmldbUri.append(newName);\n\n        return newResource;\n    }","id":3603,"modified_method":"public XmldbURI createFile(String newName, InputStream is, Long length, String contentType)\n            throws IOException, PermissionDeniedException, CollectionDoesNotExistException {\n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"Create '\" + newName + \"' in '\" + xmldbUri + \"'\");\n\n        XmldbURI newNameUri = XmldbURI.create(newName);\n\n        // Get mime, or NULL when not available\n        MimeType mime = MimeTable.getInstance().getContentTypeFor(newName);\n        if (mime == null) {\n            mime = MimeType.BINARY_TYPE;\n        }\n\n        // References to the database\n        DBBroker broker = null;\n        Collection collection = null;\n\n        // create temp file and store. Existdb needs to read twice from a stream.\n        BufferedInputStream bis = new BufferedInputStream(is);\n\n        VirtualTempFile vtf = new VirtualTempFile();\n\n        BufferedOutputStream bos = new BufferedOutputStream(vtf);\n\n        // Perform actual copy\n        IOUtils.copy(bis, bos);\n        bis.close();\n        bos.close();\n        vtf.close();\n\n        // To support LockNullResource, a 0-byte XML document can received. Since 0-byte\n        // XML documents are not supported a small file will be created.\n        if (mime.isXMLType() && vtf.length() == 0L) {\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Creating dummy XML file for null resource lock '\" + newNameUri + \"'\");\n\n            vtf = new VirtualTempFile();\n            IOUtils.write(\"<null_resource/>\", vtf);\n            vtf.close();\n        }\n\n        // Start transaction\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn txn = transact.beginTransaction();\n\n        try {\n            broker = brokerPool.get(subject);\n\n            // Check if collection exists. not likely to happen since availability is checked\n            // by ResourceFactory\n            collection = broker.openCollection(xmldbUri, Lock.WRITE_LOCK);\n            if (collection == null) {\n                LOG.debug(\"Collection \" + xmldbUri + \" does not exist\");\n                transact.abort(txn);\n                throw new CollectionDoesNotExistException(xmldbUri + \"\");\n            }\n\n\n            if (mime.isXMLType()) {\n\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Inserting XML document '\" + mime.getName() + \"'\");\n\n                // Stream into database\n                VirtualTempFileInputSource vtfis = new VirtualTempFileInputSource(vtf);\n                IndexInfo info = collection.validateXMLResource(txn, broker, newNameUri, vtfis);\n                DocumentImpl doc = info.getDocument();\n                doc.getMetadata().setMimeType(mime.getName());\n                collection.store(txn, broker, info, vtfis, false);\n\n            } else {\n\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Inserting BINARY document '\" + mime.getName() + \"'\");\n\n                // Stream into database\n                InputStream fis = vtf.getByteStream();\n                bis = new BufferedInputStream(fis);\n                collection.addBinaryResource(txn, broker, newNameUri, bis, mime.getName(), length.longValue());\n                bis.close();\n            }\n\n            // Commit change\n            transact.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Document created sucessfully\");\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (TriggerException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (SAXException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new IOException(e);\n\n        } catch (LockException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw new PermissionDeniedException(xmldbUri + \"\");\n\n        } catch (IOException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            transact.abort(txn);\n            throw e;\n\n        } finally {\n\n            if (vtf != null) {\n                vtf.delete();\n            }\n\n            // TODO: check if can be done earlier\n            if (collection != null) {\n                collection.release(Lock.WRITE_LOCK);\n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished creation\");\n        }\n\n        // Send the result back to the client\n        XmldbURI newResource = xmldbUri.append(newName);\n\n        return newResource;\n    }","commit_id":"27aab1190b2500e9bf8dc9dc2c8fc861c5a55799","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Retrieve full URIs of all Collections in this collection.\n     */\n    public List<XmldbURI> getCollectionURIs() {\n\n\n        List<XmldbURI> collectionURIs = new ArrayList<XmldbURI>();\n\n        DBBroker broker = null;\n        Collection collection = null;\n        try {\n            // Try to read as specified subject\n            broker = brokerPool.get(subject);\n            collection = broker.openCollection(xmldbUri, Lock.READ_LOCK);\n\n            // Get all collections\n            Iterator<XmldbURI> collections = collection.collectionIteratorNoLock(broker); // QQ: use collectionIterator ?\n            while (collections.hasNext()) {\n                collectionURIs.add(xmldbUri.append(collections.next()));\n\n            }\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            collectionURIs = null;\n        } catch (PermissionDeniedException pde) {\n            LOG.error(pde);\n            collectionURIs = null;            \n        } finally {\n\n            if (collection != null) {\n                collection.release(Lock.READ_LOCK);\n            }\n\n            brokerPool.release(broker);\n        }\n\n        return collectionURIs;\n    }","id":3604,"modified_method":"/**\n     * Retrieve full URIs of all Collections in this collection.\n     */\n    public List<XmldbURI> getCollectionURIs() {\n\n\n        List<XmldbURI> collectionURIs = new ArrayList<XmldbURI>();\n\n        DBBroker broker = null;\n        Collection collection = null;\n        try {\n            // Try to read as specified subject\n            broker = brokerPool.get(subject);\n            collection = broker.openCollection(xmldbUri, Lock.READ_LOCK);\n\n            // Get all collections\n            Iterator<XmldbURI> collections = collection.collectionIteratorNoLock(broker); // QQ: use collectionIterator ?\n            while (collections.hasNext()) {\n                collectionURIs.add(xmldbUri.append(collections.next()));\n\n            }\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            //return empty list\n            return new ArrayList<XmldbURI>();\n        } catch (PermissionDeniedException pde) {\n            LOG.error(pde);\n            //return empty list\n            return new ArrayList<XmldbURI>();            \n        } finally {\n\n            if (collection != null) {\n                collection.release(Lock.READ_LOCK);\n            }\n\n            brokerPool.release(broker);\n        }\n\n        return collectionURIs;\n    }","commit_id":"27aab1190b2500e9bf8dc9dc2c8fc861c5a55799","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Retrieve full URIs of all Documents in the collection.\n     */\n    public List<XmldbURI> getDocumentURIs() {\n\n        List<XmldbURI> documentURIs = new ArrayList<XmldbURI>();\n\n        DBBroker broker = null;\n        Collection collection = null;\n        try {\n            // Try to read as specified subject\n            broker = brokerPool.get(subject);\n            collection = broker.openCollection(xmldbUri, Lock.READ_LOCK);\n\n            // Get all documents\n            Iterator<DocumentImpl> documents = collection.iteratorNoLock(broker); // QQ: use 'iterator'\n            while (documents.hasNext()) {\n                documentURIs.add(documents.next().getURI());\n            }\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            documentURIs = null;\n        } catch (EXistException e) {\n            LOG.error(e);\n            documentURIs = null;\n\n        } finally {\n            // Clean up resources\n            if (collection != null) {\n                collection.release(Lock.READ_LOCK);\n            }\n\n            brokerPool.release(broker);\n        }\n\n        return documentURIs;\n    }","id":3605,"modified_method":"/**\n     * Retrieve full URIs of all Documents in the collection.\n     */\n    public List<XmldbURI> getDocumentURIs() {\n\n        List<XmldbURI> documentURIs = new ArrayList<XmldbURI>();\n\n        DBBroker broker = null;\n        Collection collection = null;\n        try {\n            // Try to read as specified subject\n            broker = brokerPool.get(subject);\n            collection = broker.openCollection(xmldbUri, Lock.READ_LOCK);\n\n            // Get all documents\n            Iterator<DocumentImpl> documents = collection.iteratorNoLock(broker); // QQ: use 'iterator'\n            while (documents.hasNext()) {\n                documentURIs.add(documents.next().getURI());\n            }\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            //return empty list\n            return new ArrayList<XmldbURI>();\n        } catch (EXistException e) {\n            LOG.error(e);\n            //return empty list\n            return new ArrayList<XmldbURI>();\n        } finally {\n            // Clean up resources\n            if (collection != null) {\n                collection.release(Lock.READ_LOCK);\n            }\n\n            brokerPool.release(broker);\n        }\n\n        return documentURIs;\n    }","commit_id":"27aab1190b2500e9bf8dc9dc2c8fc861c5a55799","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Lock document.\n     */\n    public LockToken lock(LockToken inputToken) throws PermissionDeniedException,\n                                            DocumentAlreadyLockedException, EXistException {\n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"create lock \" + xmldbUri);\n\n        DBBroker broker = null;\n\n        DocumentImpl document = null;\n        \n        TransactionManager txnManager = null;\n        Txn txn = null;\n\n        try {\n            broker = brokerPool.get(subject);\n\n            // Try to get document (add catch?)\n            document = broker.getXMLResource(xmldbUri, Lock.WRITE_LOCK); \n\n            if (document == null) {\n                \n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"No resource found for path: \" + xmldbUri);\n                return null; // throw exception?\n            }\n\n            // Get current userlock\n            Account userLock = document.getUserLock();\n\n            // Check if Resource is already locked. @@ToDo\n            if (userLock != null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource was already locked locked.\");\n            }\n\n            if (userLock != null && userLock.getName()!=null && !userLock.getName().equals(subject.getName())) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource is locked by user \" + userLock.getName() + \".\");\n                throw new PermissionDeniedException(userLock.getName());\n            }\n\n            // Check for request fo shared lock. @@TODO\n            if (inputToken.getScope() == LockToken.LOCK_SCOPE_SHARED) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Shared locks are not implemented.\");\n                throw new EXistException(\"Shared locks are not implemented.\");\n            }\n\n            // Update locktoken\n            inputToken.setOwner(subject.getName());\n            inputToken.createOpaqueLockToken();\n            //inputToken.setTimeOut(inputToken.getTimeOut());\n            inputToken.setTimeOut(LockToken.LOCK_TIMEOUT_INFINITE);\n\n            // Update document\n            document.getMetadata().setLockToken(inputToken);\n            document.setUserLock(subject);\n\n            // Make token persistant\n            txnManager = brokerPool.getTransactionManager();\n            txn = txnManager.beginTransaction();\n            broker.storeXMLResource(txn, document);\n            txnManager.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Successfully retrieved token\");\n            return inputToken;\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            txnManager.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            txnManager.abort(txn);\n            throw e;\n\n        } finally {\n\n            // TODO: check if can be done earlier\n            if (document != null) {\n                document.getUpdateLock().release(Lock.WRITE_LOCK); \n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished create lock\");\n        }\n    }","id":3606,"modified_method":"/**\n     * Lock document.\n     */\n    public LockToken lock(LockToken inputToken) throws PermissionDeniedException,\n                                            DocumentAlreadyLockedException, EXistException {\n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"create lock \" + xmldbUri);\n\n        DBBroker broker = null;\n\n        DocumentImpl document = null;\n        \n        TransactionManager txnManager = null;\n        Txn txn = null;\n\n        try {\n            broker = brokerPool.get(subject);\n\n            // Try to get document (add catch?)\n            document = broker.getXMLResource(xmldbUri, Lock.WRITE_LOCK); \n\n            if (document == null) {\n                \n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"No resource found for path: \" + xmldbUri);\n                //return null; // throw exception?\n                throw new EXistException(\"No resource found.\");\n            }\n\n            // Get current userlock\n            Account userLock = document.getUserLock();\n\n            // Check if Resource is already locked. @@ToDo\n            if (userLock != null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource was already locked locked.\");\n            }\n\n            if (userLock != null && userLock.getName()!=null && !userLock.getName().equals(subject.getName())) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource is locked by user \" + userLock.getName() + \".\");\n                throw new PermissionDeniedException(userLock.getName());\n            }\n\n            // Check for request fo shared lock. @@TODO\n            if (inputToken.getScope() == LockToken.LOCK_SCOPE_SHARED) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Shared locks are not implemented.\");\n                throw new EXistException(\"Shared locks are not implemented.\");\n            }\n\n            // Update locktoken\n            inputToken.setOwner(subject.getName());\n            inputToken.createOpaqueLockToken();\n            //inputToken.setTimeOut(inputToken.getTimeOut());\n            inputToken.setTimeOut(LockToken.LOCK_TIMEOUT_INFINITE);\n\n            // Update document\n            document.getMetadata().setLockToken(inputToken);\n            document.setUserLock(subject);\n\n            // Make token persistant\n            txnManager = brokerPool.getTransactionManager();\n            txn = txnManager.beginTransaction();\n            broker.storeXMLResource(txn, document);\n            txnManager.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Successfully retrieved token\");\n            return inputToken;\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            if (txnManager != null)\n            \ttxnManager.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            //dead code, remove?\n            if (txnManager != null)\n            \ttxnManager.abort(txn);\n            //-----------------------\n            throw e;\n\n        } finally {\n\n            // TODO: check if can be done earlier\n            if (document != null) {\n                document.getUpdateLock().release(Lock.WRITE_LOCK); \n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished create lock\");\n        }\n    }","commit_id":"27aab1190b2500e9bf8dc9dc2c8fc861c5a55799","url":"https://github.com/eXist-db/exist"},{"original_method":"public LockToken refreshLock(String token) throws PermissionDeniedException,\n            DocumentAlreadyLockedException, EXistException, DocumentNotLockedException  {\n       \n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"refresh lock \" + xmldbUri + \"  lock=\"+token);\n\n        DBBroker broker = null;\n        DocumentImpl document = null;\n\n        if (token == null) {\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"token is null\");\n            throw new EXistException(\"token is null\");\n        }\n\n        // Prepare transaction\n        TransactionManager txnManager = null;\n        Txn txn = null;\n            \n        try {\n            broker = brokerPool.get(subject);\n\n            // Try to get document (add catch?)\n            document = broker.getXMLResource(xmldbUri, Lock.WRITE_LOCK); \n\n            if (document == null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"No resource found for path: \" + xmldbUri);\n                return null; // throw exception?\n            }\n\n            // Get current userlock\n            Account userLock = document.getUserLock();\n\n            // Check if Resource is already locked. \n            if (userLock == null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource was not locked.\");\n                throw new DocumentNotLockedException(\"Resource was not locked.\");\n            }\n            \n            if (userLock.getName()!=null && !userLock.getName().equals(subject.getName())) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource is locked by \"+userLock.getName());\n                throw new PermissionDeniedException(userLock.getName());\n            }\n\n            LockToken lockToken = document.getMetadata().getLockToken();\n\n            if(!token.equals(lockToken.getOpaqueLockToken())){\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Token does not match\");\n                throw new PermissionDeniedException(\"Token \"+token+\" does not match \"+lockToken.getOpaqueLockToken());\n            }\n  \n            lockToken.setTimeOut(LockToken.LOCK_TIMEOUT_INFINITE);\n\n            // Make token persistant\n            txnManager = brokerPool.getTransactionManager();\n            txn = txnManager.beginTransaction();\n            broker.storeXMLResource(txn, document);\n            txnManager.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Successfully retrieved token\");\n            return lockToken;\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            txnManager.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            txnManager.abort(txn);\n            throw e;\n\n        } finally {\n\n            // TODO: check if can be done earlier\n            if (document != null) {\n                document.getUpdateLock().release(Lock.WRITE_LOCK); \n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished create lock\");\n        }\n    }","id":3607,"modified_method":"public LockToken refreshLock(String token) throws PermissionDeniedException,\n            DocumentAlreadyLockedException, EXistException, DocumentNotLockedException  {\n       \n\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"refresh lock \" + xmldbUri + \"  lock=\"+token);\n\n        DBBroker broker = null;\n        DocumentImpl document = null;\n\n        if (token == null) {\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"token is null\");\n            throw new EXistException(\"token is null\");\n        }\n\n        // Prepare transaction\n        TransactionManager txnManager = null;\n        Txn txn = null;\n            \n        try {\n            broker = brokerPool.get(subject);\n\n            // Try to get document (add catch?)\n            document = broker.getXMLResource(xmldbUri, Lock.WRITE_LOCK); \n\n            if (document == null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"No resource found for path: \" + xmldbUri);\n                //return null; // throw exception?\n                throw new EXistException(\"No resource found.\");\n            }\n\n            // Get current userlock\n            Account userLock = document.getUserLock();\n\n            // Check if Resource is already locked. \n            if (userLock == null) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource was not locked.\");\n                throw new DocumentNotLockedException(\"Resource was not locked.\");\n            }\n            \n            if (userLock.getName()!=null && !userLock.getName().equals(subject.getName())) {\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Resource is locked by \"+userLock.getName());\n                throw new PermissionDeniedException(userLock.getName());\n            }\n\n            LockToken lockToken = document.getMetadata().getLockToken();\n\n            if(!token.equals(lockToken.getOpaqueLockToken())){\n                if(LOG.isDebugEnabled())\n                    LOG.debug(\"Token does not match\");\n                throw new PermissionDeniedException(\"Token \"+token+\" does not match \"+lockToken.getOpaqueLockToken());\n            }\n  \n            lockToken.setTimeOut(LockToken.LOCK_TIMEOUT_INFINITE);\n\n            // Make token persistant\n            txnManager = brokerPool.getTransactionManager();\n            txn = txnManager.beginTransaction();\n            broker.storeXMLResource(txn, document);\n            txnManager.commit(txn);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Successfully retrieved token\");\n            return lockToken;\n\n\n        } catch (EXistException e) {\n            LOG.error(e);\n            if (txnManager != null)\n            \ttxnManager.abort(txn);\n            throw e;\n\n        } catch (PermissionDeniedException e) {\n            LOG.error(e);\n            //dead code, remove?\n            if (txnManager != null)\n            \ttxnManager.abort(txn);\n            //------------------------\n            throw e;\n\n        } finally {\n\n            // TODO: check if can be done earlier\n            if (document != null) {\n                document.getUpdateLock().release(Lock.WRITE_LOCK); \n            }\n\n            brokerPool.release(broker);\n\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Finished create lock\");\n        }\n    }","commit_id":"27aab1190b2500e9bf8dc9dc2c8fc861c5a55799","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\r\n     *  Read document and write data to database.\r\n     *\r\n     * @param user  Effective user for operation. If NULL the user information\r\n     * is distilled from the URL.\r\n     * @param xmldbURL Location in database.\r\n     * @param tmp Document that is inserted.\r\n     * @throws IOException\r\n     */\r\n    public void stream(XmldbURL xmldbURL, File tmp, Subject user) throws IOException {\r\n        LOG.debug(\"Begin document upload\");\r\n        \r\n        Collection collection = null;\r\n        BrokerPool pool =null;\r\n        DBBroker broker =null;\r\n        TransactionManager transact = null;\r\n        Txn txn = null;\r\n        \r\n        boolean collectionLocked = true;\r\n        \r\n        \r\n        try {\r\n            pool = BrokerPool.getInstance();\r\n            \r\n            if(user==null) {\r\n                if(xmldbURL.hasUserInfo()){\r\n                    user=EmbeddedUser.authenticate(xmldbURL, pool);\r\n                    if(user==null){\r\n                        LOG.debug(\"Unauthorized user \"+xmldbURL.getUsername());\r\n                        throw new ExistIOException(\"Unauthorized user \"+xmldbURL.getUsername());\r\n                    }\r\n                } else {\r\n                    user=EmbeddedUser.getUserGuest(pool);\r\n                }\r\n            }\r\n            \r\n            broker = pool.get(user);\r\n            \r\n            transact = pool.getTransactionManager();\r\n            txn = transact.beginTransaction();\r\n            \r\n            XmldbURI collectionUri = XmldbURI.create(xmldbURL.getCollection());\r\n            XmldbURI documentUri = XmldbURI.create(xmldbURL.getDocumentName());\r\n            \r\n            collection = broker.openCollection(collectionUri, Lock.READ_LOCK);\r\n            \r\n            if(collection == null) {\r\n                transact.abort(txn);\r\n                throw new ExistIOException(\"Resource \"+collectionUri.toString()+\" is not a collection.\");\r\n            }\r\n            \r\n            if(collection.hasChildCollection(documentUri)) {\r\n                transact.abort(txn);\r\n                throw new ExistIOException(\"Resource \"+documentUri.toString()+\" is a collection.\");\r\n            }\r\n            \r\n            MimeType mime = MimeTable.getInstance().getContentTypeFor(documentUri);\r\n            String contentType=null;\r\n            if (mime != null){\r\n                contentType = mime.getName();\r\n            } else {\r\n                mime = MimeType.BINARY_TYPE;\r\n            }\r\n            \r\n            if(mime.isXMLType()) {\r\n                LOG.debug(\"storing XML resource\");\r\n                InputSource inputsource = new InputSource(tmp.toURI().toASCIIString());\r\n                IndexInfo info = collection.validateXMLResource(txn, broker, documentUri, inputsource);\r\n                DocumentImpl doc = info.getDocument();\r\n                doc.getMetadata().setMimeType(contentType);\r\n                collection.release(Lock.READ_LOCK);\r\n                collectionLocked = false;\r\n                collection.store(txn, broker, info, inputsource, false);\r\n                LOG.debug(\"done\");\r\n                \r\n            } else {\r\n                LOG.debug(\"storing Binary resource\");\r\n                InputStream is = new FileInputStream(tmp);\r\n                @SuppressWarnings(\"unused\")\r\n\t\t\t\tDocumentImpl doc = collection.addBinaryResource(txn, broker, documentUri, is, contentType, tmp.length());\r\n                is.close();\r\n                LOG.debug(\"done\");\r\n            }\r\n            \r\n            LOG.debug(\"commit\");\r\n            transact.commit(txn);\r\n            \r\n        } catch (IOException ex) {\r\n            try { \r\n                // Throws an exception when the user is unknown!\r\n                transact.abort(txn);\r\n            } catch (Exception abex) {\r\n                LOG.debug(abex);\r\n            }\r\n            //ex.printStackTrace();\r\n            LOG.debug(ex);\r\n            throw ex;\r\n            \r\n        } catch (Exception ex) {\r\n            try { \r\n                // Throws an exception when the user is unknown!\r\n                transact.abort(txn);\r\n            } catch (Exception abex) {\r\n                LOG.debug(abex);\r\n            }\r\n            //ex.printStackTrace();\r\n            LOG.debug(ex);\r\n            throw new ExistIOException(ex.getMessage(), ex);\r\n            \r\n        } finally {\r\n            LOG.debug(\"Done.\");\r\n            if(collectionLocked && collection != null){\r\n                collection.release(Lock.READ_LOCK);\r\n            }\r\n            \r\n            pool.release(broker);\r\n        }\r\n        \r\n    }","id":3608,"modified_method":"/**\r\n     *  Read document and write data to database.\r\n     *\r\n     * @param user  Effective user for operation. If NULL the user information\r\n     * is distilled from the URL.\r\n     * @param xmldbURL Location in database.\r\n     * @param tmp Document that is inserted.\r\n     * @throws IOException\r\n     */\r\n    public void stream(XmldbURL xmldbURL, File tmp, Subject user) throws IOException {\r\n        LOG.debug(\"Begin document upload\");\r\n        \r\n        Collection collection = null;\r\n        BrokerPool pool =null;\r\n        DBBroker broker =null;\r\n        TransactionManager transact = null;\r\n        Txn txn = null;\r\n        \r\n        boolean collectionLocked = true;\r\n        \r\n        \r\n        try {\r\n            pool = BrokerPool.getInstance();\r\n            \r\n            if(user==null) {\r\n                if(xmldbURL.hasUserInfo()){\r\n                    user=EmbeddedUser.authenticate(xmldbURL, pool);\r\n                    if(user==null){\r\n                        LOG.debug(\"Unauthorized user \"+xmldbURL.getUsername());\r\n                        throw new ExistIOException(\"Unauthorized user \"+xmldbURL.getUsername());\r\n                    }\r\n                } else {\r\n                    user=EmbeddedUser.getUserGuest(pool);\r\n                }\r\n            }\r\n            \r\n            broker = pool.get(user);\r\n            \r\n            XmldbURI collectionUri = XmldbURI.create(xmldbURL.getCollection());\r\n            XmldbURI documentUri = XmldbURI.create(xmldbURL.getDocumentName());\r\n            \r\n            collection = broker.openCollection(collectionUri, Lock.READ_LOCK);\r\n            \r\n            if(collection == null)\r\n                throw new ExistIOException(\"Resource \"+collectionUri.toString()+\" is not a collection.\");\r\n            \r\n            if(collection.hasChildCollection(documentUri))\r\n                throw new ExistIOException(\"Resource \"+documentUri.toString()+\" is a collection.\");\r\n            \r\n            MimeType mime = MimeTable.getInstance().getContentTypeFor(documentUri);\r\n            String contentType=null;\r\n            if (mime != null){\r\n                contentType = mime.getName();\r\n            } else {\r\n                mime = MimeType.BINARY_TYPE;\r\n            }\r\n            \r\n            transact = pool.getTransactionManager();\r\n            txn = transact.beginTransaction();\r\n            \r\n            if(mime.isXMLType()) {\r\n                LOG.debug(\"storing XML resource\");\r\n                InputSource inputsource = new InputSource(tmp.toURI().toASCIIString());\r\n                IndexInfo info = collection.validateXMLResource(txn, broker, documentUri, inputsource);\r\n                DocumentImpl doc = info.getDocument();\r\n                doc.getMetadata().setMimeType(contentType);\r\n                collection.release(Lock.READ_LOCK);\r\n                collectionLocked = false;\r\n                collection.store(txn, broker, info, inputsource, false);\r\n                LOG.debug(\"done\");\r\n                \r\n            } else {\r\n                LOG.debug(\"storing Binary resource\");\r\n                InputStream is = new FileInputStream(tmp);\r\n                try {\r\n                \tcollection.addBinaryResource(txn, broker, documentUri, is, contentType, tmp.length());\r\n                } finally {\r\n                \tis.close();\r\n                }\r\n                LOG.debug(\"done\");\r\n            }\r\n            \r\n            LOG.debug(\"commit\");\r\n            transact.commit(txn);\r\n            \r\n        } catch (IOException ex) {\r\n            try { \r\n            \t// is it still actual? -shabanovd\r\n                // Throws an exception when the user is unknown!\r\n            \tif (transact != null)\r\n            \t\ttransact.abort(txn);\r\n            } catch (Exception abex) {\r\n                LOG.debug(abex);\r\n            }\r\n            //ex.printStackTrace();\r\n            LOG.debug(ex);\r\n            throw ex;\r\n            \r\n        } catch (Exception ex) {\r\n            try { \r\n            \t// is it still actual? -shabanovd\r\n                // Throws an exception when the user is unknown!\r\n            \tif (transact != null)\r\n            \t\ttransact.abort(txn);\r\n            } catch (Exception abex) {\r\n                LOG.debug(abex);\r\n            }\r\n            //ex.printStackTrace();\r\n            LOG.debug(ex);\r\n            throw new ExistIOException(ex.getMessage(), ex);\r\n            \r\n        } finally {\r\n            LOG.debug(\"Done.\");\r\n            if(collectionLocked && collection != null){\r\n                collection.release(Lock.READ_LOCK);\r\n            }\r\n            \r\n            pool.release(broker);\r\n        }\r\n        \r\n    }","commit_id":"484fc71da609a7b4cec791ccfbb0c29ff67d294d","url":"https://github.com/eXist-db/exist"},{"original_method":"protected String getTitle(String extraData, String defaultValue) {\n\t\ttry {\n\t\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\textraData);\n\n\t\t\tString title = extraDataJSONObject.getString(\"title\");\n\n\t\t\tif (Validator.isNotNull(title)) {\n\t\t\t\treturn HtmlUtil.escape(title);\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException jsone) {\n\t\t\t_log.error(\"Unable to create JSON object from \" + extraData);\n\t\t}\n\n\t\treturn HtmlUtil.escape(defaultValue);\n\t}","id":3609,"modified_method":"protected String getValue(\n\t\tString extraData, String key, String defaultValue) {\n\n\t\tif (Validator.isNull(extraData)) {\n\t\t\treturn HtmlUtil.escape(defaultValue);\n\t\t}\n\n\t\ttry {\n\t\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\textraData);\n\n\t\t\tString value = extraDataJSONObject.getString(key);\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\treturn HtmlUtil.escape(value);\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException jsone) {\n\t\t\t_log.error(\"Unable to create JSON object from \" + extraData);\n\t\t}\n\n\t\treturn HtmlUtil.escape(defaultValue);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString entryTitle = getTitle(activity.getExtraData(), entry.getTitle());\n\n\t\tString displayTitle = wrapLink(link, entryTitle);\n\t\tString displayDate = StringPool.BLANK;\n\n\t\tString titlePattern = null;\n\n\t\tif ((activityType == BlogsActivityKeys.ADD_COMMENT) ||\n\t\t\t(activityType == SocialActivityConstants.TYPE_ADD_COMMENT)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-blogs-add-comment-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tif (entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\t\tdisplayTitle = entryTitle;\n\n\t\t\t\tFormat dateFormatDate =\n\t\t\t\t\tFastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\t\t\t\t\"MMMM d\", themeDisplay.getLocale(),\n\t\t\t\t\t\tthemeDisplay.getTimeZone());\n\n\t\t\t\tdisplayDate = dateFormatDate.format(entry.getDisplayDate());\n\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-blogs-scheduled-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-blogs-scheduled-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-blogs-add-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-blogs-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-blogs-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, displayTitle,\n\t\t\tdisplayDate\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":3610,"modified_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString entryTitle = getValue(\n\t\t\tactivity.getExtraData(), \"title\", entry.getTitle());\n\n\t\tString displayTitle = wrapLink(link, entryTitle);\n\t\tString displayDate = StringPool.BLANK;\n\n\t\tString titlePattern = null;\n\n\t\tif ((activityType == BlogsActivityKeys.ADD_COMMENT) ||\n\t\t\t(activityType == SocialActivityConstants.TYPE_ADD_COMMENT)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-blogs-add-comment-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tif (entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\t\tdisplayTitle = entryTitle;\n\n\t\t\t\tFormat dateFormatDate =\n\t\t\t\t\tFastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\t\t\t\t\"MMMM d\", themeDisplay.getLocale(),\n\t\t\t\t\t\tthemeDisplay.getTimeZone());\n\n\t\t\t\tdisplayDate = dateFormatDate.format(entry.getDisplayDate());\n\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-blogs-scheduled-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-blogs-scheduled-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-blogs-add-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-blogs-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-blogs-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, displayTitle,\n\t\t\tdisplayDate\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BookmarksEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tBookmarksEntry entry = BookmarksEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/bookmarks/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == BookmarksActivityKeys.ADD_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-bookmarks-add-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-bookmarks-add-entry-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BookmarksActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-bookmarks-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-bookmarks-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\tString entryTitle = wrapLink(\n\t\t\tlink, getTitle(activity.getExtraData(), entry.getName()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, entryTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":3611,"modified_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BookmarksEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tBookmarksEntry entry = BookmarksEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/bookmarks/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == BookmarksActivityKeys.ADD_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-bookmarks-add-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-bookmarks-add-entry-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BookmarksActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-bookmarks-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-bookmarks-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\tString entryTitle = getValue(\n\t\t\tactivity.getExtraData(), \"title\", entry.getName());\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName,\n\t\t\twrapLink(link, entryTitle)\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?redirect=\" +\n\t\t\t\t\tHtmlUtil.escapeURL(themeDisplay.getURLCurrent()) +\n\t\t\t\t\t\t\"&eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-calendar-add-event-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-calendar-update-event-in\";\n\t\t\t}\n\t\t}\n\n\t\tString eventTitle = wrapLink(\n\t\t\tlink, getTitle(activity.getExtraData(), event.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, eventTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":3612,"modified_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?redirect=\" +\n\t\t\t\t\tHtmlUtil.escapeURL(themeDisplay.getURLCurrent()) +\n\t\t\t\t\t\t\"&eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-calendar-add-event-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-calendar-update-event-in\";\n\t\t\t}\n\t\t}\n\n\t\tString eventTitle = getValue(\n\t\t\tactivity.getExtraData(), \"title\", event.getTitle());\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, wrapLink(link, eventTitle)\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry.getFileEntryId(),\n\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?groupId=\" +\n\t\t\t\t\tfileEntry.getRepositoryId() + \"&folderId=\" +\n\t\t\t\t\t\tfileEntry.getFolderId() + \"&title=\" +\n\t\t\t\t\t\t\tHttpUtil.encodeURL(fileEntry.getTitle());\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-document-library-add-file-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-document-library-update-file-in\";\n\t\t\t}\n\t\t}\n\n\t\tString fileTitle = wrapLink(\n\t\t\tlink, getTitle(activity.getExtraData(), fileEntry.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, fileTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBundler sb = new StringBundler(3);\n\n\t\tString fileEntryLink =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_file_entry?fileEntryId=\" +\n\t\t\t\t\tfileEntry.getFileEntryId();\n\n\t\tsb.append(wrapLink(fileEntryLink, \"view-document\", themeDisplay));\n\t\tsb.append(StringPool.SPACE);\n\n\t\tString folderLink =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_folder?groupId=\" +\n\t\t\t\t\tfileEntry.getRepositoryId() + \"&folderId=\" +\n\t\t\t\t\t\tfileEntry.getFolderId();\n\n\t\tsb.append(wrapLink(folderLink, \"go-to-folder\", themeDisplay));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":3613,"modified_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry.getFileEntryId(),\n\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?groupId=\" +\n\t\t\t\t\tfileEntry.getRepositoryId() + \"&folderId=\" +\n\t\t\t\t\t\tfileEntry.getFolderId() + \"&title=\" +\n\t\t\t\t\t\t\tHttpUtil.encodeURL(fileEntry.getTitle());\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-document-library-add-file-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-document-library-update-file-in\";\n\t\t\t}\n\t\t}\n\n\t\tString fileTitle = getValue(\n\t\t\tactivity.getExtraData(), \"title\", fileEntry.getTitle());\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, wrapLink(link, fileTitle)\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBundler sb = new StringBundler(3);\n\n\t\tString fileEntryLink =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_file_entry?fileEntryId=\" +\n\t\t\t\t\tfileEntry.getFileEntryId();\n\n\t\tsb.append(wrapLink(fileEntryLink, \"view-document\", themeDisplay));\n\t\tsb.append(StringPool.SPACE);\n\n\t\tString folderLink =\n\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_folder?groupId=\" +\n\t\t\t\t\tfileEntry.getRepositoryId() + \"&folderId=\" +\n\t\t\t\t\t\tfileEntry.getFolderId();\n\n\t\tsb.append(wrapLink(folderLink, \"go-to-folder\", themeDisplay));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathMain());\n\t\tsb.append(\"/message_boards/find_message?messageId=\");\n\t\tsb.append(message.getMessageId());\n\n\t\tString link = sb.toString();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\tif (activity.getReceiverUserId() == 0) {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-add-message-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-reply-message-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((activityType == MBActivityKeys.REPLY_MESSAGE) &&\n\t\t\t\t (activity.getReceiverUserId() > 0)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-message-boards-reply-message-in\";\n\t\t\t}\n\t\t}\n\n\t\tString messageSubject = wrapLink(\n\t\t\tlink, getTitle(activity.getExtraData(), message.getSubject()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, messageSubject\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\tif (message.getCategoryId() > 0) {\n\t\t\tsb.setIndex(0);\n\n\t\t\tsb.append(themeDisplay.getPortalURL());\n\t\t\tsb.append(themeDisplay.getPathMain());\n\t\t\tsb.append(\"/message_boards/find_category?mbCategoryId=\");\n\t\t\tsb.append(message.getCategoryId());\n\n\t\t\tString categoryLink = sb.toString();\n\n\t\t\tbody = wrapLink(categoryLink, \"go-to-category\", themeDisplay);\n\t\t}\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":3614,"modified_method":"@Override\n\tprotected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathMain());\n\t\tsb.append(\"/message_boards/find_message?messageId=\");\n\t\tsb.append(message.getMessageId());\n\n\t\tString link = sb.toString();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\tif (activity.getReceiverUserId() == 0) {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-add-message-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitlePattern = \"activity-message-boards-reply-message-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((activityType == MBActivityKeys.REPLY_MESSAGE) &&\n\t\t\t\t (activity.getReceiverUserId() > 0)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitlePattern = \"activity-message-boards-reply-message-in\";\n\t\t\t}\n\t\t}\n\n\t\tString messageSubject = getValue(\n\t\t\tactivity.getExtraData(), \"title\", message.getSubject());\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName,\n\t\t\twrapLink(link, messageSubject)\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\tif (message.getCategoryId() > 0) {\n\t\t\tsb.setIndex(0);\n\n\t\t\tsb.append(themeDisplay.getPortalURL());\n\t\t\tsb.append(themeDisplay.getPathMain());\n\t\t\tsb.append(\"/message_boards/find_category?mbCategoryId=\");\n\t\t\tsb.append(message.getCategoryId());\n\n\t\t\tString categoryLink = sb.toString();\n\n\t\t\tbody = wrapLink(categoryLink, \"go-to-category\", themeDisplay);\n\t\t}\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"c2d9d412a43426c6b182c0232db2d2b283fb44bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doTestSlowAndFastMachine(boolean withFailingScheduler) throws Throwable {\n        logger.info(\"doTestSlowAndFastMachine: creating slowMachine... (w/o heartbeat runner)\");\n        FullJR2VirtualInstanceBuilder slowBuilder = newBuilder();\n        slowBuilder.setDebugName(\"slow\")\n                .newRepository(\"/var/discovery/impl/\", true)\n                .setConnectorPingTimeout(5 /*5 sec timeout */)\n                .setConnectorPingInterval(999 /* 999sec interval: to disable it */)\n                .setMinEventDelay(0)\n                .withFailingScheduler(withFailingScheduler);\n        FullJR2VirtualInstance slowMachine = slowBuilder.fullBuild();\n        instances.add(slowMachine);\n        SimpleTopologyEventListener slowListener = new SimpleTopologyEventListener(\"slow\");\n        slowMachine.bindTopologyEventListener(slowListener);\n        logger.info(\"doTestSlowAndFastMachine: creating fastMachine... (w/o heartbeat runner)\");\n        FullJR2VirtualInstanceBuilder fastBuilder = newBuilder();\n        fastBuilder.setDebugName(\"fast\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(5)\n                .setConnectorPingInterval(999)\n                .setMinEventDelay(0)\n                .withFailingScheduler(withFailingScheduler);\n        FullJR2VirtualInstance fastMachine = fastBuilder.fullBuild();\n        instances.add(fastMachine);\n        SimpleTopologyEventListener fastListener = new SimpleTopologyEventListener(\"fast\");\n        fastMachine.bindTopologyEventListener(fastListener);\n        HeartbeatHandler hhSlow = slowMachine.getHeartbeatHandler();\n        HeartbeatHandler hhFast = fastMachine.getHeartbeatHandler();\n        \n        Thread.sleep(1000);\n        logger.info(\"doTestSlowAndFastMachine: no event should have been triggered yet\");\n        assertFalse(fastMachine.getDiscoveryService().getTopology().isCurrent());\n        assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertNull(fastListener.getLastEvent());\n        assertNull(slowListener.getLastEvent());\n\n        // make few rounds of heartbeats so that the two instances see each other\n        logger.info(\"doTestSlowAndFastMachine: send a couple of heartbeats to connect the two..\");\n        for(int i=0; i<5; i++) {\n            hhSlow.issueHeartbeat();\n            hhSlow.doCheckView();\n            hhFast.issueHeartbeat();\n            hhFast.doCheckView();\n            Thread.sleep(100);\n        }\n        logger.info(\"doTestSlowAndFastMachine: now the two instances should be connected.\");\n        slowMachine.dumpRepo();\n        \n        assertEquals(2, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(2, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener.getLastEvent().getType());\n        assertEquals(1, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n        assertEquals(1, slowListener.getEventCount());\n        \n        // now let the slow machine be slow while the fast one updates as expected\n        logger.info(\"doTestSlowAndFastMachine: last heartbeat of slowMachine.\");\n        hhSlow.issueHeartbeat();\n        logger.info(\"doTestSlowAndFastMachine: while the fastMachine still sends heartbeats...\");\n        for(int i=0; i<6; i++) {\n            Thread.sleep(1500);\n            hhFast.issueHeartbeat();\n            hhFast.doCheckView();\n        }\n        logger.info(\"doTestSlowAndFastMachine: now the fastMachine should have decoupled the slow one\");\n        fastMachine.dumpRepo();\n        hhFast.doCheckView(); // one more for the start of the vote\n        fastMachine.dumpRepo();\n        hhFast.doCheckView(); // and one for the promotion\n\n        // after 9 sec hhSlow's heartbeat will have timed out, so hhFast will not see hhSlow anymore\n        fastMachine.dumpRepo();\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(3, fastListener.getEventCount());\n        assertEquals(1, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        \n        TopologyView topo = slowMachine.getDiscoveryService().getTopology();\n        assertFalse(topo.isCurrent());\n        \n        // after those 6 sec, hhSlow does the check (6sec between heartbeat and check)\n        logger.info(\"doTestSlowAndFastMachine: slowMachine is going to do a checkView next - and will detect being decoupled\");\n        hhSlow.doCheckView();\n        slowMachine.dumpRepo();\n        logger.info(\"doTestSlowAndFastMachine: slowMachine is going to also do a heartbeat next\");\n        hhSlow.issueHeartbeat();\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(3, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n        assertEquals(2, slowListener.getEventCount());\n        Thread.sleep(8000);\n        // even after 8 sec the slow lsitener did not send a TOPOLOGY_CHANGED yet\n        logger.info(\"doTestSlowAndFastMachine: after another 8 sec of silence from slowMachine, it should still remain in CHANGING state\");\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n        assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, slowListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(1, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(3, fastListener.getEventCount());\n        \n        // make few rounds of heartbeats so that the two instances see each other again\n        logger.info(\"doTestSlowAndFastMachine: now let both fast and slow issue heartbeats...\");\n        for(int i=0; i<4; i++) {\n            hhFast.issueHeartbeat();\n            hhFast.doCheckView();\n            hhSlow.issueHeartbeat();\n            hhSlow.doCheckView();\n            Thread.sleep(1000);\n        }\n        logger.info(\"doTestSlowAndFastMachine: by now the two should have joined\");\n        \n        // this should have put the two together again\n        // even after 8 sec the slow lsitener did not send a TOPOLOGY_CHANGED yet\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertTrue(fastMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(5, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, slowListener.getLastEvent().getType());\n        assertTrue(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(3, slowListener.getEventCount());\n    }","id":3615,"modified_method":"public void doTestSlowAndFastMachine(boolean withFailingScheduler) throws Throwable {\n        logger.info(\"doTestSlowAndFastMachine: creating slowMachine... (w/o heartbeat runner)\");\n        FullJR2VirtualInstanceBuilder slowBuilder = newBuilder();\n        slowBuilder.setDebugName(\"slow\")\n                .newRepository(\"/var/discovery/impl/\", true)\n                .setConnectorPingTimeout(5 /*5 sec timeout */)\n                .setConnectorPingInterval(999 /* 999sec interval: to disable it */)\n                .setMinEventDelay(0)\n                .withFailingScheduler(withFailingScheduler);\n        FullJR2VirtualInstance slowMachine = slowBuilder.fullBuild();\n        instances.add(slowMachine);\n        SimpleTopologyEventListener slowListener = new SimpleTopologyEventListener(\"slow\");\n        slowMachine.bindTopologyEventListener(slowListener);\n        logger.info(\"doTestSlowAndFastMachine: creating fastMachine... (w/o heartbeat runner)\");\n        FullJR2VirtualInstanceBuilder fastBuilder = newBuilder();\n        fastBuilder.setDebugName(\"fast\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(5)\n                .setConnectorPingInterval(999)\n                .setMinEventDelay(0)\n                .withFailingScheduler(withFailingScheduler);\n        FullJR2VirtualInstance fastMachine = fastBuilder.fullBuild();\n        instances.add(fastMachine);\n        SimpleTopologyEventListener fastListener = new SimpleTopologyEventListener(\"fast\");\n        fastMachine.bindTopologyEventListener(fastListener);\n        HeartbeatHandler hhSlow = slowMachine.getHeartbeatHandler();\n        HeartbeatHandler hhFast = fastMachine.getHeartbeatHandler();\n        \n        Thread.sleep(1000);\n        logger.info(\"doTestSlowAndFastMachine: no event should have been triggered yet\");\n        assertFalse(fastMachine.getDiscoveryService().getTopology().isCurrent());\n        assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertNull(fastListener.getLastEvent());\n        assertNull(slowListener.getLastEvent());\n\n        // make few rounds of heartbeats so that the two instances see each other\n        logger.info(\"doTestSlowAndFastMachine: send a couple of heartbeats to connect the two..\");\n        for(int i=0; i<5; i++) {\n            synchronized(lock(hhSlow)) {\n                hhSlow.issueHeartbeat();\n                hhSlow.doCheckView();\n            }\n            synchronized(lock(hhFast)) {\n                hhFast.issueHeartbeat();\n                hhFast.doCheckView();\n            }\n            Thread.sleep(100);\n        }\n        logger.info(\"doTestSlowAndFastMachine: now the two instances should be connected.\");\n        slowMachine.dumpRepo();\n        \n        assertEquals(2, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(2, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener.getLastEvent().getType());\n        assertEquals(1, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n        assertEquals(1, slowListener.getEventCount());\n        \n        // now let the slow machine be slow while the fast one updates as expected\n        logger.info(\"doTestSlowAndFastMachine: last heartbeat of slowMachine.\");\n        synchronized(lock(hhSlow)) {\n            hhSlow.issueHeartbeat();\n        }\n        logger.info(\"doTestSlowAndFastMachine: while the fastMachine still sends heartbeats...\");\n        for(int i=0; i<6; i++) {\n            Thread.sleep(1500);\n            synchronized(lock(hhFast)) {\n                hhFast.issueHeartbeat();\n                hhFast.doCheckView();\n            }\n        }\n        logger.info(\"doTestSlowAndFastMachine: now the fastMachine should have decoupled the slow one\");\n        fastMachine.dumpRepo();\n        hhFast.doCheckView(); // one more for the start of the vote\n        fastMachine.dumpRepo();\n        hhFast.doCheckView(); // and one for the promotion\n\n        // after 9 sec hhSlow's heartbeat will have timed out, so hhFast will not see hhSlow anymore\n        fastMachine.dumpRepo();\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(3, fastListener.getEventCount());\n        assertEquals(1, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        \n        TopologyView topo = slowMachine.getDiscoveryService().getTopology();\n        assertFalse(topo.isCurrent());\n        \n        // after those 6 sec, hhSlow does the check (6sec between heartbeat and check)\n        logger.info(\"doTestSlowAndFastMachine: slowMachine is going to do a checkView next - and will detect being decoupled\");\n        hhSlow.doCheckView();\n        slowMachine.dumpRepo();\n        logger.info(\"doTestSlowAndFastMachine: slowMachine is going to also do a heartbeat next\");\n        synchronized(lock(hhSlow)) {\n            hhSlow.issueHeartbeat();\n        }\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(3, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n        assertEquals(2, slowListener.getEventCount());\n        Thread.sleep(8000);\n        // even after 8 sec the slow lsitener did not send a TOPOLOGY_CHANGED yet\n        logger.info(\"doTestSlowAndFastMachine: after another 8 sec of silence from slowMachine, it should still remain in CHANGING state\");\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n        assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, slowListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertEquals(1, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(3, fastListener.getEventCount());\n        \n        // make few rounds of heartbeats so that the two instances see each other again\n        logger.info(\"doTestSlowAndFastMachine: now let both fast and slow issue heartbeats...\");\n        for(int i=0; i<4; i++) {\n            synchronized(lock(hhFast)) {\n                hhFast.issueHeartbeat();\n                hhFast.doCheckView();\n            }\n            synchronized(lock(hhSlow)) {\n                hhSlow.issueHeartbeat();\n                hhSlow.doCheckView();\n            }\n            Thread.sleep(1000);\n        }\n        logger.info(\"doTestSlowAndFastMachine: by now the two should have joined\");\n        \n        // this should have put the two together again\n        // even after 8 sec the slow lsitener did not send a TOPOLOGY_CHANGED yet\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener.getLastEvent().getType());\n        assertTrue(fastMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, fastMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(5, fastListener.getEventCount());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, slowListener.getLastEvent().getType());\n        assertTrue(slowMachine.getDiscoveryService().getTopology().isCurrent());\n        assertEquals(2, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(3, slowListener.getEventCount());\n    }","commit_id":"78b220a325437ee98c0c446273e5c9d072fe1e34","url":"https://github.com/apache/sling"},{"original_method":"public void doTestPartitioning(boolean scheduler) throws Throwable {\n        logger.info(\"doTestPartitioning: creating slowMachine...\");\n        FullJR2VirtualInstanceBuilder builder = newBuilder();\n        builder.setDebugName(\"slow\")\n                .newRepository(\"/var/discovery/impl/\", true)\n                .setConnectorPingTimeout(10 /* 10 sec timeout */)\n                .setConnectorPingInterval(999 /* 999 sec interval: to disable it */)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance slowMachine = builder.fullBuild();\n        assertEquals(1, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(slowMachine.getSlingId(), slowMachine.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(slowMachine);\n        Thread.sleep(10); // wait 10ms to ensure 'slowMachine' has the lowerst leaderElectionId (to become leader)\n        SimpleTopologyEventListener slowListener = new SimpleTopologyEventListener(\"slow\");\n        slowMachine.bindTopologyEventListener(slowListener);\n        \n        logger.info(\"doTestPartitioning: creating fastMachine1...\");\n        FullJR2VirtualInstanceBuilder fastBuilder1 = newBuilder();\n        fastBuilder1.setDebugName(\"fast1\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine1 = fastBuilder1.fullBuild();\n        assertEquals(1, fastMachine1.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine1.getSlingId(), fastMachine1.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine1);\n        Thread.sleep(10); // wait 10ms to ensure 'fastMachine1' has the 2nd lowerst leaderElectionId (to become leader during partitioning)\n        SimpleTopologyEventListener fastListener1 = new SimpleTopologyEventListener(\"fast1\");\n        fastMachine1.bindTopologyEventListener(fastListener1);\n\n        logger.info(\"doTestPartitioning: creating fastMachine2...\");\n        FullJR2VirtualInstanceBuilder fullBuilder2 = newBuilder();\n        fullBuilder2.setDebugName(\"fast2\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine2 = fullBuilder2.fullBuild();\n        assertEquals(1, fastMachine2.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine2.getSlingId(), fastMachine2.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine2);\n        SimpleTopologyEventListener fastListener2 = new SimpleTopologyEventListener(\"fast2\");\n        fastMachine2.bindTopologyEventListener(fastListener2);\n\n        logger.info(\"doTestPartitioning: creating fastMachine3...\");\n        FullJR2VirtualInstanceBuilder fullBuilder3 = newBuilder();\n        fullBuilder3.setDebugName(\"fast3\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine3 = fullBuilder3.fullBuild();\n        assertEquals(1, fastMachine3.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine3.getSlingId(), fastMachine3.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine3);\n        SimpleTopologyEventListener fastListener3 = new SimpleTopologyEventListener(\"fast3\");\n        fastMachine3.bindTopologyEventListener(fastListener3);\n\n        logger.info(\"doTestPartitioning: creating fastMachine4...\");\n        FullJR2VirtualInstanceBuilder fullBuilder4 = newBuilder();\n        fullBuilder4.setDebugName(\"fast4\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine4 = fullBuilder4.fullBuild();\n        assertEquals(1, fastMachine4.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine4.getSlingId(), fastMachine4.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine4);\n        SimpleTopologyEventListener fastListener4 = new SimpleTopologyEventListener(\"fast4\");\n        fastMachine4.bindTopologyEventListener(fastListener4);\n        \n        logger.info(\"doTestPartitioning: --------------------------------\");\n        logger.info(\"doTestPartitioning: letting heartbeats be sent by all instances for a few loops...\");\n        logger.info(\"doTestPartitioning: --------------------------------\");\n        HeartbeatHandler hhSlow = slowMachine.getHeartbeatHandler();\n        for(int i=0; i<5; i++) {\n            logger.info(\"doTestPartitioning: --------------------------------\");\n            logger.info(\"doTestPartitioning: doing pinging with hhSlow now...\");\n            logger.info(\"doTestPartitioning: --------------------------------\");\n            hhSlow.issueHeartbeat();\n            hhSlow.doCheckView();\n            if (!scheduler) {\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine1 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                fastMachine1.getHeartbeatHandler().doCheckView();\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine2 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                fastMachine2.getHeartbeatHandler().doCheckView();\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine3 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                fastMachine3.getHeartbeatHandler().doCheckView();\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine4 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                fastMachine4.getHeartbeatHandler().doCheckView();\n            }\n            Thread.sleep(1000);\n        }\n        \n        // at this stage the 4 fast plus the slow instance should all see each other\n        logger.info(\"doTestPartitioning: all 4 instances should have agreed on seeing each other\");\n        assertNotNull(fastListener1.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener1.getLastEvent().getType());\n        assertEquals(5, fastListener1.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener2.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener2.getLastEvent().getType());\n        assertEquals(5, fastListener2.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener3.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener3.getLastEvent().getType());\n        assertEquals(5, fastListener3.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener4.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener4.getLastEvent().getType());\n        assertEquals(5, fastListener4.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(slowListener.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n        assertEquals(5, slowListener.getLastEvent().getNewView().getInstances().size());\n        assertTrue(slowListener.getLastEvent().getNewView().getLocalInstance().isLeader());\n        \n        // after 12sec the slow instance' heartbeat should have timed out\n        logger.info(\"doTestPartitioning: letting slowMachine NOT send any heartbeats for 12sec, only the fast ones do...\");\n        for(int i=0; i<12; i++) {\n            if (!scheduler) {\n                fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                fastMachine1.getHeartbeatHandler().doCheckView();\n                fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                fastMachine2.getHeartbeatHandler().doCheckView();\n                fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                fastMachine3.getHeartbeatHandler().doCheckView();\n                fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                fastMachine4.getHeartbeatHandler().doCheckView();\n            }\n            Thread.sleep(1000);\n        }\n        logger.info(\"doTestPartitioning: this should now have decoupled slowMachine from the other 4...\");\n        \n        // so the fast listeners should only see 4 instances remaining\n        for(int i=0; i<7; i++) {\n            logger.info(\"doTestPartitioning: sleeping 2sec...\");\n            Thread.sleep(2000);\n            logger.info(\"doTestPartitioning: the 4 fast machines should all just see themselves...\");\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener1.getLastEvent().getType());\n            assertEquals(4, fastListener1.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener2.getLastEvent().getType());\n            assertEquals(4, fastListener2.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener3.getLastEvent().getType());\n            assertEquals(4, fastListener3.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener4.getLastEvent().getType());\n            assertEquals(4, fastListener4.getLastEvent().getNewView().getInstances().size());\n            \n            assertTrue(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n\n            // and the slow instance should be isolated\n            assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n            // however we can't really make any assertions on how many instances a non-current topology contains...\n            // assertEquals(5, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n            if (i==0) {\n                assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n            } else {\n                assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n            }\n            //TODO but only after 'handlePotentialTopologyChange' is called\n            // which either happens via handleTopologyChanged (via the TopologyChangeHandler)\n            // or via updateProperties\n            DiscoveryServiceImpl slowDisco = (DiscoveryServiceImpl) slowMachine.getDiscoveryService();\n            slowDisco.updateProperties();\n            // that should have triggered an async event - which takes a little moment\n            Thread.sleep(500);\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n            assertEquals(2, slowListener.getEventCount());\n            TopologyView slowTopo = slowMachine.getDiscoveryService().getTopology();\n            assertNotNull(slowTopo);\n            assertFalse(slowTopo.isCurrent());\n            // again, can't make any assertion on how many instances the slow non-current view contains...\n            //assertEquals(5, slowTopo.getInstances().size());\n            if (!scheduler) {\n                fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                fastMachine1.getHeartbeatHandler().doCheckView();\n                fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                fastMachine2.getHeartbeatHandler().doCheckView();\n                fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                fastMachine3.getHeartbeatHandler().doCheckView();\n                fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                fastMachine4.getHeartbeatHandler().doCheckView();\n            }\n        }\n\n        for(int i=0; i<4; i++) {\n            hhSlow.issueHeartbeat();\n            hhSlow.doCheckView();\n            if (!scheduler) {\n                fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                fastMachine1.getHeartbeatHandler().doCheckView();\n                fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                fastMachine2.getHeartbeatHandler().doCheckView();\n                fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                fastMachine3.getHeartbeatHandler().doCheckView();\n                fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                fastMachine4.getHeartbeatHandler().doCheckView();\n            }\n            Thread.sleep(1000);\n        }\n        \n        // now all should be in one cluster again\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener1.getLastEvent().getType());\n        assertEquals(5, fastListener1.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener2.getLastEvent().getType());\n        assertEquals(5, fastListener2.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener3.getLastEvent().getType());\n        assertEquals(5, fastListener3.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener4.getLastEvent().getType());\n        assertEquals(5, fastListener4.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, slowListener.getLastEvent().getType());\n        assertEquals(5, slowListener.getLastEvent().getNewView().getInstances().size());\n        \n        // SLING-5030 part 2 : after rejoin-after-partitioning the slowMachine1 should again be leader\n        slowMachine.dumpRepo();\n        assertFalse(slowListener.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertTrue(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n    }","id":3616,"modified_method":"public void doTestPartitioning(boolean scheduler) throws Throwable {\n        logger.info(\"doTestPartitioning: creating slowMachine...\");\n        FullJR2VirtualInstanceBuilder builder = newBuilder();\n        builder.setDebugName(\"slow\")\n                .newRepository(\"/var/discovery/impl/\", true)\n                .setConnectorPingTimeout(10 /* 10 sec timeout */)\n                .setConnectorPingInterval(999 /* 999 sec interval: to disable it */)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance slowMachine = builder.fullBuild();\n        assertEquals(1, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(slowMachine.getSlingId(), slowMachine.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(slowMachine);\n        Thread.sleep(10); // wait 10ms to ensure 'slowMachine' has the lowerst leaderElectionId (to become leader)\n        SimpleTopologyEventListener slowListener = new SimpleTopologyEventListener(\"slow\");\n        slowMachine.bindTopologyEventListener(slowListener);\n        \n        logger.info(\"doTestPartitioning: creating fastMachine1...\");\n        FullJR2VirtualInstanceBuilder fastBuilder1 = newBuilder();\n        fastBuilder1.setDebugName(\"fast1\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine1 = fastBuilder1.fullBuild();\n        assertEquals(1, fastMachine1.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine1.getSlingId(), fastMachine1.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine1);\n        Thread.sleep(10); // wait 10ms to ensure 'fastMachine1' has the 2nd lowerst leaderElectionId (to become leader during partitioning)\n        SimpleTopologyEventListener fastListener1 = new SimpleTopologyEventListener(\"fast1\");\n        fastMachine1.bindTopologyEventListener(fastListener1);\n\n        logger.info(\"doTestPartitioning: creating fastMachine2...\");\n        FullJR2VirtualInstanceBuilder fullBuilder2 = newBuilder();\n        fullBuilder2.setDebugName(\"fast2\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine2 = fullBuilder2.fullBuild();\n        assertEquals(1, fastMachine2.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine2.getSlingId(), fastMachine2.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine2);\n        SimpleTopologyEventListener fastListener2 = new SimpleTopologyEventListener(\"fast2\");\n        fastMachine2.bindTopologyEventListener(fastListener2);\n\n        logger.info(\"doTestPartitioning: creating fastMachine3...\");\n        FullJR2VirtualInstanceBuilder fullBuilder3 = newBuilder();\n        fullBuilder3.setDebugName(\"fast3\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine3 = fullBuilder3.fullBuild();\n        assertEquals(1, fastMachine3.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine3.getSlingId(), fastMachine3.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine3);\n        SimpleTopologyEventListener fastListener3 = new SimpleTopologyEventListener(\"fast3\");\n        fastMachine3.bindTopologyEventListener(fastListener3);\n\n        logger.info(\"doTestPartitioning: creating fastMachine4...\");\n        FullJR2VirtualInstanceBuilder fullBuilder4 = newBuilder();\n        fullBuilder4.setDebugName(\"fast4\")\n                .useRepositoryOf(slowMachine)\n                .setConnectorPingTimeout(10)\n                .setConnectorPingInterval(1)\n                .setMinEventDelay(0)\n                .withFailingScheduler(!scheduler);\n        FullJR2VirtualInstance fastMachine4 = fullBuilder4.fullBuild();\n        assertEquals(1, fastMachine4.getDiscoveryService().getTopology().getInstances().size());\n        assertEquals(fastMachine4.getSlingId(), fastMachine4.getDiscoveryService().getTopology().getInstances().iterator().next().getSlingId());\n        instances.add(fastMachine4);\n        SimpleTopologyEventListener fastListener4 = new SimpleTopologyEventListener(\"fast4\");\n        fastMachine4.bindTopologyEventListener(fastListener4);\n        \n        logger.info(\"doTestPartitioning: --------------------------------\");\n        logger.info(\"doTestPartitioning: letting heartbeats be sent by all instances for a few loops...\");\n        logger.info(\"doTestPartitioning: --------------------------------\");\n        HeartbeatHandler hhSlow = slowMachine.getHeartbeatHandler();\n        for(int i=0; i<5; i++) {\n            logger.info(\"doTestPartitioning: --------------------------------\");\n            logger.info(\"doTestPartitioning: doing pinging with hhSlow now...\");\n            logger.info(\"doTestPartitioning: --------------------------------\");\n            synchronized(lock(hhSlow)) {\n                hhSlow.issueHeartbeat();\n                hhSlow.doCheckView();\n            }\n            if (!scheduler) {\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine1 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                synchronized(lock(fastMachine1.getHeartbeatHandler())) {\n                    fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine1.getHeartbeatHandler().doCheckView();\n                }\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine2 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                synchronized(lock(fastMachine2.getHeartbeatHandler())) {\n                    fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine2.getHeartbeatHandler().doCheckView();\n                }\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine3 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                synchronized(lock(fastMachine3.getHeartbeatHandler())) {\n                    fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine3.getHeartbeatHandler().doCheckView();\n                }\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                logger.info(\"doTestPartitioning: doing pinging with fastMachine4 now...\");\n                logger.info(\"doTestPartitioning: --------------------------------\");\n                synchronized(lock(fastMachine4.getHeartbeatHandler())) {\n                    fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine4.getHeartbeatHandler().doCheckView();\n                }\n            }\n            Thread.sleep(1000);\n        }\n        \n        // at this stage the 4 fast plus the slow instance should all see each other\n        logger.info(\"doTestPartitioning: all 4 instances should have agreed on seeing each other\");\n        assertNotNull(fastListener1.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener1.getLastEvent().getType());\n        assertEquals(5, fastListener1.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener2.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener2.getLastEvent().getType());\n        assertEquals(5, fastListener2.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener3.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener3.getLastEvent().getType());\n        assertEquals(5, fastListener3.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(fastListener4.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, fastListener4.getLastEvent().getType());\n        assertEquals(5, fastListener4.getLastEvent().getNewView().getInstances().size());\n        assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertNotNull(slowListener.getLastEvent());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n        assertEquals(5, slowListener.getLastEvent().getNewView().getInstances().size());\n        assertTrue(slowListener.getLastEvent().getNewView().getLocalInstance().isLeader());\n        \n        // after 12sec the slow instance' heartbeat should have timed out\n        logger.info(\"doTestPartitioning: letting slowMachine NOT send any heartbeats for 12sec, only the fast ones do...\");\n        for(int i=0; i<12; i++) {\n            if (!scheduler) {\n                synchronized(lock(fastMachine1.getHeartbeatHandler())) {\n                    fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine1.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine2.getHeartbeatHandler())) {\n                    fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine2.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine3.getHeartbeatHandler())) {\n                    fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine3.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine4.getHeartbeatHandler())) {\n                    fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine4.getHeartbeatHandler().doCheckView();\n                }\n            }\n            Thread.sleep(1000);\n        }\n        logger.info(\"doTestPartitioning: this should now have decoupled slowMachine from the other 4...\");\n        \n        // so the fast listeners should only see 4 instances remaining\n        for(int i=0; i<7; i++) {\n            logger.info(\"doTestPartitioning: sleeping 2sec...\");\n            Thread.sleep(2000);\n            logger.info(\"doTestPartitioning: the 4 fast machines should all just see themselves...\");\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener1.getLastEvent().getType());\n            assertEquals(4, fastListener1.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener2.getLastEvent().getType());\n            assertEquals(4, fastListener2.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener3.getLastEvent().getType());\n            assertEquals(4, fastListener3.getLastEvent().getNewView().getInstances().size());\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener4.getLastEvent().getType());\n            assertEquals(4, fastListener4.getLastEvent().getNewView().getInstances().size());\n            \n            assertTrue(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n            assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n\n            // and the slow instance should be isolated\n            assertFalse(slowMachine.getDiscoveryService().getTopology().isCurrent());\n            // however we can't really make any assertions on how many instances a non-current topology contains...\n            // assertEquals(5, slowMachine.getDiscoveryService().getTopology().getInstances().size());\n            if (i==0) {\n                assertEquals(TopologyEvent.Type.TOPOLOGY_INIT, slowListener.getLastEvent().getType());\n            } else {\n                assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n            }\n            //TODO but only after 'handlePotentialTopologyChange' is called\n            // which either happens via handleTopologyChanged (via the TopologyChangeHandler)\n            // or via updateProperties\n            DiscoveryServiceImpl slowDisco = (DiscoveryServiceImpl) slowMachine.getDiscoveryService();\n            slowDisco.updateProperties();\n            // that should have triggered an async event - which takes a little moment\n            Thread.sleep(500);\n            assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGING, slowListener.getLastEvent().getType());\n            assertEquals(2, slowListener.getEventCount());\n            TopologyView slowTopo = slowMachine.getDiscoveryService().getTopology();\n            assertNotNull(slowTopo);\n            assertFalse(slowTopo.isCurrent());\n            // again, can't make any assertion on how many instances the slow non-current view contains...\n            //assertEquals(5, slowTopo.getInstances().size());\n            if (!scheduler) {\n                synchronized(lock(fastMachine1.getHeartbeatHandler())) {\n                    fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine1.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine2.getHeartbeatHandler())) {\n                    fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine2.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine3.getHeartbeatHandler())) {\n                    fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine3.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine4.getHeartbeatHandler())) {\n                    fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine4.getHeartbeatHandler().doCheckView();\n                }\n            }\n        }\n\n        for(int i=0; i<4; i++) {\n            hhSlow.issueHeartbeat();\n            hhSlow.doCheckView();\n            if (!scheduler) {\n                synchronized(lock(fastMachine1.getHeartbeatHandler())) {\n                    fastMachine1.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine1.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine2.getHeartbeatHandler())) {\n                    fastMachine2.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine2.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine3.getHeartbeatHandler())) {\n                    fastMachine3.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine3.getHeartbeatHandler().doCheckView();\n                }\n                synchronized(lock(fastMachine4.getHeartbeatHandler())) {\n                    fastMachine4.getHeartbeatHandler().issueHeartbeat();\n                    fastMachine4.getHeartbeatHandler().doCheckView();\n                }\n            }\n            Thread.sleep(1000);\n        }\n        \n        // now all should be in one cluster again\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener1.getLastEvent().getType());\n        assertEquals(5, fastListener1.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener2.getLastEvent().getType());\n        assertEquals(5, fastListener2.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener3.getLastEvent().getType());\n        assertEquals(5, fastListener3.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, fastListener4.getLastEvent().getType());\n        assertEquals(5, fastListener4.getLastEvent().getNewView().getInstances().size());\n        assertEquals(TopologyEvent.Type.TOPOLOGY_CHANGED, slowListener.getLastEvent().getType());\n        assertEquals(5, slowListener.getLastEvent().getNewView().getInstances().size());\n        \n        // SLING-5030 part 2 : after rejoin-after-partitioning the slowMachine1 should again be leader\n        slowMachine.dumpRepo();\n        assertFalse(slowListener.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertTrue(fastListener1.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener2.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener3.getLastEvent().getNewView().getLocalInstance().isLeader());\n        assertFalse(fastListener4.getLastEvent().getNewView().getLocalInstance().isLeader());\n    }","commit_id":"78b220a325437ee98c0c446273e5c9d072fe1e34","url":"https://github.com/apache/sling"},{"original_method":"public ClassDefinitionBuilder(CeylonTransformer gen, String name) {\r\n        super();\r\n        this.gen = gen;\r\n        this.name = name;\r\n        \r\n        annotations(gen.makeAtCeylon());\r\n    }","id":3617,"modified_method":"private ClassDefinitionBuilder(CeylonTransformer gen, String name) {\r\n        this.gen = gen;\r\n        this.name = name;\r\n        \r\n        annotations(gen.makeAtCeylon());\r\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCMethodDecl createConstructor() {\r\n        long mods = constructorModifiers;\r\n        if (mods == -1) {\r\n            // The modifiers were never explicitly set\r\n            // so we try to come up with some good defaults\r\n            mods = modifiers & (PUBLIC | PRIVATE | PROTECTED);\r\n        }\r\n        return gen.make().MethodDef(\r\n                gen.make().Modifiers(mods),\r\n                gen.names.init,\r\n                gen.make().TypeIdent(VOID),\r\n                List.<JCTypeParameter>nil(),\r\n                params.toList(),\r\n                List.<JCExpression>nil(),\r\n                gen.make().Block(0, init.toList()),\r\n                null);\r\n    }","id":3618,"modified_method":"private JCMethodDecl createConstructor() {\r\n        long mods = constructorModifiers;\r\n        if (mods == -1) {\r\n            // The modifiers were never explicitly set\r\n            // so we try to come up with some good defaults\r\n            mods = modifiers & (PUBLIC | PRIVATE | PROTECTED);\r\n        }\r\n        return MethodDefinitionBuilder\r\n            .constructor(gen)\r\n            .modifiers(mods)\r\n            .parameters(params.toList())\r\n            .body(init.toList())\r\n            .build();\r\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> transform(Tree.AnyMethod def) {\n        List<JCTree> result = List.<JCTree> nil();\n        final ListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();\n        final ListBuffer<JCAnnotation> langAnnotations = new ListBuffer<JCAnnotation>();\n        final ListBuffer<JCTypeParameter> typeParams = new ListBuffer<JCTypeParameter>();\n        JCExpression restype;\n\n        for (Tree.Parameter param : def.getParameterLists().get(0).getParameters()) {\n            params.append(transform(param));\n        }\n\n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                typeParams.append(transform(t));\n            }\n        }\n\n        if (def.getType() instanceof VoidModifier) {\n            restype = make().TypeIdent(VOID);\n        } else {\n            restype = gen.makeJavaType(gen.actualType(def), false);\n            langAnnotations.appendList(gen.makeJavaTypeAnnotations(def.getDeclarationModel(), gen.actualType(def)));\n        }\n        \n        // FIXME: Handle lots more flags here\n\n        if (isActual(def)) {\n            langAnnotations.appendList(gen.makeAtOverride());\n        }\n\n        JCBlock body = null;\n        if (def instanceof Tree.MethodDefinition) {\n            body = gen.statementGen.transform(((Tree.MethodDefinition)def).getBlock());\n        }\n                \n        String name = def.getIdentifier().getText();\n        int mods = transformMethodDeclFlags(def);\n        JCMethodDecl meth = at(def).MethodDef(make().Modifiers(mods, langAnnotations.toList()), \n                names().fromString(name), \n                restype, typeParams.toList(), \n                params.toList(), List.<JCExpression> nil(), body, null);\n        result = result.append(meth);\n        \n        return result;\n    }","id":3619,"modified_method":"private JCMethodDecl transform(Tree.AnyMethod def) {\n        String name = def.getIdentifier().getText();\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(gen, name);\n        \n        for (Tree.Parameter param : def.getParameterLists().get(0).getParameters()) {\n            methodBuilder.parameter(param);\n        }\n\n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n\n        if (!(def.getType() instanceof VoidModifier)) {\n            methodBuilder.resultType(gen.actualType(def));\n        }\n        \n        if (def instanceof Tree.MethodDefinition) {\n            JCBlock body = gen.statementGen.transform(((Tree.MethodDefinition)def).getBlock());\n            methodBuilder.block(body);\n        }\n                \n        return methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(isActual(def))\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCTree.JCMethodDecl transform(AttributeSetterDefinition decl) {\n        JCBlock body = gen.statementGen.transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        JCExpression type = gen.makeJavaType(gen.actualType(decl), false);\n        return make().MethodDef(make().Modifiers(transformAttributeGetSetDeclFlags(decl)), names().fromString(Util.getSetterName(name)), \n                make().TypeIdent(TypeTags.VOID),\n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>of(make().VarDef(make().Modifiers(0), names().fromString(name), type, null)), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","id":3620,"modified_method":"public JCTree.JCMethodDecl transform(AttributeSetterDefinition decl) {\n        JCBlock body = gen.statementGen.transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        return MethodDefinitionBuilder\n            .setter(gen, name, gen.actualType(decl))\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .block(body)\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCTree.JCMethodDecl transform(AttributeGetterDefinition decl) {\n        JCBlock body = gen.statementGen.transform(decl.getBlock());\n        List<JCAnnotation> annots = gen.makeJavaTypeAnnotations(decl.getDeclarationModel(), gen.actualType(decl));\n        return make().MethodDef(make().Modifiers(transformAttributeGetSetDeclFlags(decl), annots),\n                names().fromString(Util.getGetterName(decl.getIdentifier().getText())), \n                gen.makeJavaType(gen.actualType(decl), false), \n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>nil(), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","id":3621,"modified_method":"public JCTree.JCMethodDecl transform(AttributeGetterDefinition decl) {\n        String name = decl.getIdentifier().getText();\n        JCBlock body = gen.statementGen.transform(decl.getBlock());\n        return MethodDefinitionBuilder\n            .getter(gen, name, gen.actualType(decl))\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .block(body)\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCClassDecl methodClass(Tree.MethodDefinition def) {\n        Name name = generateClassName(def, isToplevel(def));\n        List<JCTree> meth = transform(def);\n        return (new ClassDefinitionBuilder(gen, name.toString()))\n            .annotations(gen.makeAtMethod())\n            .modifiers(FINAL, isShared(def) ? PUBLIC : 0)\n            .constructorModifiers(PRIVATE)\n            .body(meth)\n            .build();\n    }","id":3622,"modified_method":"public JCClassDecl methodClass(Tree.MethodDefinition def) {\n        String name = generateClassName(def, isToplevel(def));\n        JCMethodDecl meth = transform(def);\n        return ClassDefinitionBuilder.klass(gen, name)\n            .annotations(gen.makeAtMethod())\n            .modifiers(FINAL, isShared(def) ? PUBLIC : 0)\n            .constructorModifiers(PRIVATE)\n            .body(meth)\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.ExtendedType extendedType) {\n            if (extendedType.getInvocationExpression().getPositionalArgumentList() != null) {\n                List<JCExpression> args = List.<JCExpression> nil();\n\n                for (Tree.PositionalArgument arg : extendedType.getInvocationExpression().getPositionalArgumentList().getPositionalArguments())\n                    args = args.append(gen.expressionGen.transformArg(arg));\n\n                classBuilder.init(at(extendedType).Exec(at(extendedType).Apply(List.<JCExpression> nil(), at(extendedType).Ident(names()._super), args)));\n            }\n            classBuilder.extending(extendedType.getType().getTypeModel());\n        }","id":3623,"modified_method":"public void visit(Tree.ExtendedType extendedType) {\n            classBuilder.extending(extendedType);\n        }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree makeSetter(Tree.AttributeDeclaration decl) {\n        // FIXME: add at() calls?\n        String atrrName = decl.getIdentifier().getText();\n        JCBlock body = null;\n        if (!isFormal(decl)) {\n            body = make().Block(0, List.<JCTree.JCStatement>of(\n                    make().Exec(\n                            make().Assign(gen.makeSelect(\"this\", atrrName),\n                                    makeIdent(atrrName.toString())))));\n        }\n        \n        JCExpression type = gen.makeJavaType(gen.actualType(decl), false);\n        int mods = transformAttributeGetSetDeclFlags(decl);\n        List<JCAnnotation> annots = gen.makeJavaTypeAnnotations(decl.getDeclarationModel(), gen.actualType(decl));\n        final ListBuffer<JCAnnotation> langAnnotations = new ListBuffer<JCAnnotation>();\n        if (isActual(decl)) {\n            langAnnotations.appendList(gen.makeAtOverride());\n        }\n        \n        return make().MethodDef(make().Modifiers(mods, langAnnotations.toList()),\n                names().fromString(Util.getSetterName(atrrName.toString())), \n                make().TypeIdent(TypeTags.VOID), \n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>of(make().VarDef(make().Modifiers(0, annots), names().fromString(atrrName), type , null)), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","id":3624,"modified_method":"private JCTree makeSetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String atrrName = decl.getIdentifier().getText();\n        JCBlock body = null;\n        if (!isFormal(decl)) {\n            body = make().Block(0, List.<JCTree.JCStatement>of(\n                    make().Exec(\n                            make().Assign(gen.makeSelect(\"this\", atrrName),\n                                    makeIdent(atrrName.toString())))));\n        }\n        \n        return MethodDefinitionBuilder\n            .setter(gen, atrrName, gen.actualType(decl))\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(isActual(decl))\n            .block(body)\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCClassDecl objectClass(Tree.ObjectDefinition def, boolean topLevel) {\n        Name name = generateClassName(def, topLevel);\n        ClassDefinitionBuilder classBuilder = new ClassDefinitionBuilder(gen, name.toString());\n        \n        ClassVisitor visitor = new ClassVisitor(gen, classBuilder);\n        def.visitChildren(visitor);\n\n        TypeDeclaration decl = def.getDeclarationModel().getType().getDeclaration();\n\n        if (topLevel) {\n            classBuilder.body(makeObjectGlobal(def, make().Ident(name)).toList());\n        }\n\n        classBuilder\n            .annotations(gen.makeAtObject())\n            .modifiers(transformObjectDeclFlags(def))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init(visitor.getResult().toList())\n            .body(makeGettersAndSetters(visitor.attributeDecls).toList());\n    \n        return classBuilder.build();\n    }","id":3625,"modified_method":"public JCClassDecl objectClass(Tree.ObjectDefinition def, boolean topLevel) {\n        String name = generateClassName(def, topLevel);\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder.klass(gen, name);\n        \n        ClassVisitor visitor = new ClassVisitor(gen, classBuilder);\n        def.visitChildren(visitor);\n\n        TypeDeclaration decl = def.getDeclarationModel().getType().getDeclaration();\n\n        if (topLevel) {\n            classBuilder.body(makeObjectGlobal(def, make().Ident(names().fromString(name))).toList());\n        }\n\n        classBuilder\n            .annotations(gen.makeAtObject())\n            .modifiers(transformObjectDeclFlags(def))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init(visitor.getResult().toList())\n            .body(makeGettersAndSetters(visitor.attributeDecls).toList());\n    \n        return classBuilder.build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCClassDecl transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = new ClassDefinitionBuilder(gen, className);\n        \n        ClassVisitor visitor = new ClassVisitor(gen, classBuilder);\n        def.visitChildren(visitor);\n\n        classBuilder\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .init(visitor.getResult().toList())\n            .body(makeGettersAndSetters(visitor.attributeDecls).toList());\n    \n        return classBuilder.build();\n    }","id":3626,"modified_method":"public JCClassDecl transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder.klass(gen, className);\n        \n        ClassVisitor visitor = new ClassVisitor(gen, classBuilder);\n        def.visitChildren(visitor);\n\n        classBuilder\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .init(visitor.getResult().toList())\n            .body(makeGettersAndSetters(visitor.attributeDecls).toList());\n    \n        return classBuilder.build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates the class name for a method, object or attribute definition. If <tt>topLevel<\/tt> is <tt>true<\/tt>,\n     * uses the declaration name, otherwise uses a generated name.\n     *\n     * @param decl the Ceylon declaration (actually a definition) to generate the class name for.\n     * @param topLevel a boolean indicating whether the declaration is a top-level one.\n     * @return the generated name.\n     */\n    private Name generateClassName(Tree.Declaration decl, boolean topLevel) {\n        String name;\n        if (topLevel)\n            name = decl.getIdentifier().getText();\n        else\n            name = aliasName(decl.getIdentifier().getText() + \"$class\");\n        return names().fromString(name);\n    }","id":3627,"modified_method":"/**\n     * Generates the class name for a method, object or attribute definition. If <tt>topLevel<\/tt> is <tt>true<\/tt>,\n     * uses the declaration name, otherwise uses a generated name.\n     *\n     * @param decl the Ceylon declaration (actually a definition) to generate the class name for.\n     * @param topLevel a boolean indicating whether the declaration is a top-level one.\n     * @return the generated name.\n     */\n    private String generateClassName(Tree.Declaration decl, boolean topLevel) {\n        String name;\n        if (topLevel)\n            name = decl.getIdentifier().getText();\n        else\n            name = aliasName(decl.getIdentifier().getText() + \"$class\");\n        return name;\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree makeGetter(Tree.AttributeDeclaration decl) {\n        // FIXME: add at() calls?\n        String atrrName = decl.getIdentifier().getText();\n        JCBlock body = null;\n        if (!isFormal(decl)) {\n            body = make().Block(0, List.<JCTree.JCStatement>of(make().Return(gen.makeSelect(\"this\", atrrName))));\n        }\n        \n        JCExpression type = gen.makeJavaType(gen.actualType(decl), false);\n        int mods = transformAttributeGetSetDeclFlags(decl);\n        List<JCAnnotation> annots = gen.makeJavaTypeAnnotations(decl.getDeclarationModel(), gen.actualType(decl));\n        if (isActual(decl)) {\n            annots = annots.appendList(gen.makeAtOverride());\n        }\n        \n        return make().MethodDef(make().Modifiers(mods, annots),\n                names().fromString(Util.getGetterName(atrrName.toString())),\n                type,\n                List.<JCTree.JCTypeParameter>nil(),\n                List.<JCTree.JCVariableDecl>nil(),\n                List.<JCTree.JCExpression>nil(),\n                body, null);\n    }","id":3628,"modified_method":"private JCTree makeGetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String atrrName = decl.getIdentifier().getText();\n        JCBlock body = null;\n        if (!isFormal(decl)) {\n            body = make().Block(0, List.<JCTree.JCStatement>of(make().Return(gen.makeSelect(\"this\", atrrName))));\n        }\n        \n        return MethodDefinitionBuilder\n            .getter(gen, atrrName, gen.actualType(decl))\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(isActual(decl))\n            .block(body)\n            .build();\n    }","commit_id":"46e6a0bedc608eb50a3adaa6c35c343577183928","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n  public void messageReceived(ChannelHandlerContext context, MessageEvent e) throws Exception {\n    Object m = e.getMessage();\n    if (!(m instanceof ChannelBuffer)) {\n      context.sendUpstream(e);\n      return;\n    }\n\n    ChannelBuffer input = (ChannelBuffer)m;\n    if (!input.readable()) {\n      return;\n    }\n\n    if (cumulation == null) {\n      if (input.readableBytes() < 5) {\n        cumulation = context.getChannel().getConfig().getBufferFactory().getBuffer(8);\n        cumulation.writeBytes(input);\n      }\n      else {\n        decode(context, input, e.getRemoteAddress());\n      }\n    }\n    else {\n      if ((cumulation.readableBytes() + input.readableBytes()) < 5) {\n        cumulation.writeBytes(input);\n      }\n      else {\n        ChannelBuffer compositeBuffer = ChannelBuffers.wrappedBuffer(cumulation, input);\n        cumulation = null;\n        decode(context, compositeBuffer, e.getRemoteAddress());\n      }\n    }\n  }","id":3629,"modified_method":"@Override\n  public void messageReceived(ChannelHandlerContext context, MessageEvent e) throws Exception {\n    Object m = e.getMessage();\n    if (!(m instanceof ChannelBuffer)) {\n      context.sendUpstream(e);\n      return;\n    }\n\n    ChannelBuffer buffer = getBufferIfSufficient((ChannelBuffer)m, 5, context);\n    if (buffer != null) {\n      decode(context, buffer, e.getRemoteAddress());\n    }\n  }","commit_id":"98e75feeb8578f6404246ec24777044dca07c53f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Decode a query string of the form n1=v1&n2=v2&...\n     *\n     * @return a Map of String[] indexed by name, an empty Map if the query string was null\n     */\n    public static Map decodeQueryString(String query, boolean acceptAmp) {\n        final Map parameters = new HashMap();\n        if (query == null)\n            return parameters;\n        final StringTokenizer st = new StringTokenizer(query, \"&\");\n        try {\n            while (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                // Check if &amp; is also supported as delimiter\n                if (acceptAmp && token.startsWith(\"amp;\"))\n                    token = token.substring(4);\n                final int equalIndex = token.indexOf('=');\n                if (equalIndex == -1)\n                    throw new OXFException(\"Malformed URL: \" + query);\n                final String name = URLDecoder.decode(token.substring(0, equalIndex), NetUtils.DEFAULT_URL_ENCODING);\n                final String value = URLDecoder.decode(token.substring(equalIndex + 1), NetUtils.DEFAULT_URL_ENCODING);\n                NetUtils.addValueToStringArrayMap(parameters, name, value);\n            }\n        } catch (UnsupportedEncodingException e) {\n            // Should not happen as we are using a required encoding\n            throw new OXFException(e);\n        }\n        return parameters;\n    }","id":3630,"modified_method":"/**\n     * @param a query string of the form n1=v1&n2=v2&... to decode.  May be null.\n     * @param true if both &amp; and '&' should be accepted as delimiters and false if only & \n     *              should be considered as a delimiter.\n     * @return a Map of String[] indexed by name, an empty Map if the query string was null\n     */\n    public static java.util.Map decodeQueryString\n    ( final CharSequence qry, final boolean accptAmp ) {\n\n        final java.util.Map ret = new java.util.TreeMap();\n\n        if ( qry != null ) {\n\n            final Matcher m = accptAmp ? PATTERN_AMP.matcher( qry ) : PATTERN_NO_AMP.matcher( qry );\n            int mtchEnd = 0;\n            while ( m.find() )\n            {\n                if ( m.start() != mtchEnd ) {\n                    //  We have detected something like a=b=c=d.  That is we noticed that the last\n                    //  match ended on 'b' and that this match starts on 'c'.  Since we skipped\n                    //  something there must be a problem.\n                    throw new OXFException( \"Malformed URL: \" + qry );\n                }\n                mtchEnd = m.end();\n\n                try {\n                    // Group 0 is the whole match, e.g. a=b, while group 1 is the first group\n                    // denoted ( with parens ) in the expression.  Hence we start with group 1.\n                    String nam = m.group( 1 );\n                    nam = URLDecoder.decode( nam, NetUtils.DEFAULT_URL_ENCODING );\n\n                    String val = m.group( 2 );\n                    val= URLDecoder.decode( val, NetUtils.DEFAULT_URL_ENCODING );\n\n                    NetUtils.addValueToStringArrayMap( ret, nam, val );\n                } catch ( final java.io.UnsupportedEncodingException e ) {\n                    // Should not happen as we are using a required encoding\n                    throw new OXFException( e );\n                }\n            }\n            if ( qry.length() != mtchEnd ) {\n                // There was garbage at the end of the query.\n                throw new OXFException( \"Malformed URL: \" + qry );\n            }\n        }\n        return ret;\n    }","commit_id":"fe226625900f253edcea11329468e0eca099e761","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n  protected void setUpModule() {\n    super.setUpModule();\n\n    File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", getTestPath());\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    try {\n      VirtualFile baseDir = getProject().getBaseDir();\n      assert baseDir != null;\n      FileUtil.copyDir(currentTestRoot, new File(baseDir.getPath()));\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":3631,"modified_method":"@Override\n  protected void setUpModule() {\n    super.setUpModule();\n\n    File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", getTestPath());\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    VirtualFile baseDir = getProject().getBaseDir();\n    assert baseDir != null;\n\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"round\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":3632,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"round\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    final VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"eml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":3633,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"eml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData/iml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":3634,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData/iml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void copyTestData() throws IOException {\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"import\");\n    FileUtil.copyDir(testRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":3635,"modified_method":"private void copyTestData() throws IOException {\n    final File currentTestRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"import\");\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", getRelativeTestPath());\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    final String tempPath = getProject().getBaseDir().getPath();\n    final File tempDir = new File(tempPath);\n    FileUtil.copyDir(currentTestRoot, tempDir);\n    final VirtualFile virtualTestDir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDir);\n    assertNotNull(tempDir.getAbsolutePath(), virtualTestDir);\n    virtualTestDir.refresh(false, true);\n\n    PathMacros.getInstance().setMacro(VARIABLE, new File(tempPath, VARIABLE + \"idea\").getPath());\n    PathMacros.getInstance().setMacro(SRCVARIABLE, new File(tempPath, SRCVARIABLE + \"idea\").getPath());\n  }","id":3636,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", getRelativeTestPath());\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    final String tempPath = getProject().getBaseDir().getPath();\n    final File tempDir = new File(tempPath);\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n\n    final VirtualFile virtualTestDir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDir);\n    assertNotNull(tempDir.getAbsolutePath(), virtualTestDir);\n    virtualTestDir.refresh(false, true);\n\n    PathMacros.getInstance().setMacro(VARIABLE, new File(tempPath, VARIABLE + \"idea\").getPath());\n    PathMacros.getInstance().setMacro(SRCVARIABLE, new File(tempPath, SRCVARIABLE + \"idea\").getPath());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testUnicodeNames() throws Exception {\n    final File dirFile = createTempDirectory();\n    final String name = \"a-\\u00df-123123123.txt\";\n    final File childFile = new File(dirFile, name);\n    boolean created = childFile.createNewFile();\n    assertTrue(created || childFile.exists());\n\n    final VirtualFile dir = myFS.refreshAndFindFileByIoFile(dirFile);\n    assertNotNull(dir);\n\n    final VirtualFile child = myFS.refreshAndFindFileByIoFile(childFile);\n    assertNotNull(child);\n\n    assertTrue(childFile.delete());\n  }","id":3637,"modified_method":"public void testUnicodeNames() throws Exception {\n    final File dirFile = createTempDirectory();\n    final String name = \"a-\\u00df-123123123.txt\";\n    final File childFile = new File(dirFile, name);\n    boolean created = childFile.createNewFile();\n    assertTrue(created || childFile.exists());\n\n    final VirtualFile dir = myFS.refreshAndFindFileByIoFile(dirFile);\n    assertNotNull(dir);\n\n    final VirtualFile child = myFS.refreshAndFindFileByIoFile(childFile);\n    assertNotNull(Arrays.toString(dir.getChildren()), child);\n\n    assertTrue(childFile.delete());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindRoot() throws IOException {\n    VirtualFile root = myFS.findFileByPath(\"wrong_path\");\n    assertNull(root);\n\n    VirtualFile root2;\n    if (SystemInfo.isWindows) {\n      root = myFS.findFileByPath(\"\\\\\\\\unit-133\");\n      assertNotNull(root);\n      root2 = myFS.findFileByPath(\"//UNIT-133\");\n      assertNotNull(root2);\n      assertEquals(String.valueOf(root2), root, root2);\n      RefreshQueue.getInstance().processSingleEvent(new VFileDeleteEvent(this, root, false));\n\n      root = myFS.findFileByIoFile(new File(\"\\\\\\\\unit-133\"));\n      assertNotNull(root);\n      RefreshQueue.getInstance().processSingleEvent(new VFileDeleteEvent(this, root, false));\n\n      if (new File(\"c:\").exists()) {\n        root = myFS.findFileByPath(\"c:\");\n        assertNotNull(root);\n        assertEquals(\"C:/\", root.getPath());\n\n        root2 = myFS.findFileByPath(\"C:\\\\\");\n        assertSame(String.valueOf(root), root, root2);\n\n        VirtualFileManager fm = VirtualFileManager.getInstance();\n        root = fm.findFileByUrl(\"file://C:/\");\n        assertNotNull(root);\n        root2 = fm.findFileByUrl(\"file:///c:/\");\n        assertSame(String.valueOf(root), root, root2);\n      }\n    }\n    else if (SystemInfo.isUnix) {\n      root = myFS.findFileByPath(\"/\");\n      assertNotNull(root);\n      assertEquals(\"/\", root.getPath());\n    }\n\n    root = myFS.findFileByPath(\"\");\n    assertNotNull(root);\n\n    File jarFile = IoTestUtil.createTestJar();\n    root = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath() + \"!/\");\n    assertNotNull(root);\n\n    root2 = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath().replace(File.separator, \"//\") + \"!/\");\n    assertEquals(String.valueOf(root2), root, root2);\n\n    if (!SystemInfo.isFileSystemCaseSensitive) {\n      root2 = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath().toUpperCase(Locale.US) + \"!/\");\n      assertEquals(String.valueOf(root2), root, root2);\n    }\n  }","id":3638,"modified_method":"public void testFindRoot() throws IOException {\n    VirtualFile root = myFS.findFileByPath(\"wrong_path\");\n    assertNull(root);\n\n    VirtualFile root2;\n    if (SystemInfo.isWindows) {\n      root = myFS.findFileByPath(\"\\\\\\\\unit-133\");\n      assertNotNull(root);\n      root2 = myFS.findFileByPath(\"//UNIT-133\");\n      assertNotNull(root2);\n      assertEquals(String.valueOf(root2), root, root2);\n      RefreshQueue.getInstance().processSingleEvent(new VFileDeleteEvent(this, root, false));\n\n      root = myFS.findFileByIoFile(new File(\"\\\\\\\\unit-133\"));\n      assertNotNull(root);\n      RefreshQueue.getInstance().processSingleEvent(new VFileDeleteEvent(this, root, false));\n\n      if (new File(\"c:\").exists()) {\n        root = myFS.findFileByPath(\"c:\");\n        assertNotNull(root);\n        assertEquals(\"C:/\", root.getPath());\n\n        root2 = myFS.findFileByPath(\"C:\\\\\");\n        assertSame(String.valueOf(root), root, root2);\n\n        VirtualFileManager fm = VirtualFileManager.getInstance();\n        root = fm.findFileByUrl(\"file://C:/\");\n        assertNotNull(root);\n        root2 = fm.findFileByUrl(\"file:///c:/\");\n        assertSame(String.valueOf(root), root, root2);\n      }\n    }\n    else if (SystemInfo.isUnix) {\n      root = myFS.findFileByPath(\"/\");\n      assertNotNull(root);\n      assertEquals(\"/\", root.getPath());\n    }\n\n    root = myFS.findFileByPath(\"\");\n    assertNotNull(root);\n\n    File jarFile = IoTestUtil.createTestJar();\n    assertNotNull(getVirtualFile(jarFile));\n    root = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath() + \"!/\");\n    assertNotNull(root);\n\n    root2 = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath().replace(File.separator, \"//\") + \"!/\");\n    assertEquals(String.valueOf(root2), root, root2);\n\n    if (!SystemInfo.isFileSystemCaseSensitive) {\n      root2 = VirtualFileManager.getInstance().findFileByUrl(\"jar://\" + jarFile.getPath().toUpperCase(Locale.US) + \"!/\");\n      assertEquals(String.valueOf(root2), root, root2);\n    }\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testRefreshSeesLatestDirectoryContents() throws Exception {\n    File testDir = FileUtil.createTempDirectory(\"RefreshChildrenTest.\" + getName(), null);\n    String content = \"\";\n    FileUtil.writeToFile(new File(testDir, \"Foo.java\"), content);\n\n    VirtualFile virtualDir = myFS.findFileByIoFile(testDir);\n    assertNotNull(virtualDir);\n    virtualDir.getChildren();\n    virtualDir.refresh(false, true);\n    checkChildCount(virtualDir, 1);\n\n    FileUtil.writeToFile(new File(testDir, \"Bar.java\"), content);\n    virtualDir.refresh(false, true);\n    checkChildCount(virtualDir, 2);\n  }","id":3639,"modified_method":"public void testRefreshSeesLatestDirectoryContents() throws Exception {\n    File testDir = FileUtil.createTempDirectory(\"RefreshChildrenTest.\" + getName(), null);\n    String content = \"\";\n    FileUtil.writeToFile(new File(testDir, \"Foo.java\"), content);\n\n    VirtualFile virtualDir = getVirtualFile(testDir);\n    assertNotNull(virtualDir);\n    virtualDir.getChildren();\n    virtualDir.refresh(false, true);\n    checkChildCount(virtualDir, 1);\n\n    FileUtil.writeToFile(new File(testDir, \"Bar.java\"), content);\n    virtualDir.refresh(false, true);\n    checkChildCount(virtualDir, 2);\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testBrokenJarRoots() throws Exception {\n    final File jarFile = IoTestUtil.createTestFile(\"empty.jar\");\n\n    final int[] logCount = {0};\n    LoggedErrorProcessor.setNewInstance(new LoggedErrorProcessor() {\n      @Override\n      public void processWarn(String message, Throwable t, @NotNull Logger logger) {\n        super.processWarn(message, t, logger);\n        if (message.contains(jarFile.getName())) logCount[0]++;\n      }\n    });\n\n    try {\n      String rootUrl = \"jar://\" + FileUtil.toSystemIndependentName(jarFile.getPath()) + \"!/\";\n      String entryUrl = rootUrl + JarFile.MANIFEST_NAME;\n      VirtualFile jarRoot = VirtualFileManager.getInstance().findFileByUrl(rootUrl);\n      assertNotNull(jarRoot);\n      assertTrue(jarRoot.isValid());\n      assertEquals(0, jarRoot.getChildren().length);\n      assertNull(VirtualFileManager.getInstance().findFileByUrl(entryUrl));\n\n      VirtualFile local = JarFileSystem.getInstance().getVirtualFileForJar(jarRoot);\n      assertNotNull(local);\n      IoTestUtil.createTestJar(jarFile);\n      local.refresh(false, false);\n      assertTrue(jarRoot.isValid());\n      assertEquals(1, jarRoot.getChildren().length);\n      assertNotNull(VirtualFileManager.getInstance().findFileByUrl(entryUrl));\n    }\n    finally {\n      LoggedErrorProcessor.restoreDefaultProcessor();\n    }\n\n    assertEquals(1, logCount[0]);\n  }","id":3640,"modified_method":"public void testBrokenJarRoots() throws Exception {\n    final File jarFile = IoTestUtil.createTestFile(\"empty.jar\");\n\n    final int[] logCount = {0};\n    LoggedErrorProcessor.setNewInstance(new LoggedErrorProcessor() {\n      @Override\n      public void processWarn(String message, Throwable t, @NotNull Logger logger) {\n        super.processWarn(message, t, logger);\n        if (message.contains(jarFile.getName())) logCount[0]++;\n      }\n    });\n\n    try {\n      String rootUrl = \"jar://\" + FileUtil.toSystemIndependentName(jarFile.getPath()) + \"!/\";\n      String entryUrl = rootUrl + JarFile.MANIFEST_NAME;\n      assertNotNull(getVirtualFile(jarFile));\n      VirtualFile jarRoot = VirtualFileManager.getInstance().findFileByUrl(rootUrl);\n      assertNotNull(jarRoot);\n      assertTrue(jarRoot.isValid());\n      assertEquals(0, jarRoot.getChildren().length);\n      assertNull(VirtualFileManager.getInstance().findFileByUrl(entryUrl));\n\n      VirtualFile local = JarFileSystem.getInstance().getVirtualFileForJar(jarRoot);\n      assertNotNull(local);\n      IoTestUtil.createTestJar(jarFile);\n      local.refresh(false, false);\n      assertTrue(jarRoot.isValid());\n      assertEquals(1, jarRoot.getChildren().length);\n      assertNotNull(VirtualFileManager.getInstance().findFileByUrl(entryUrl));\n    }\n    finally {\n      LoggedErrorProcessor.restoreDefaultProcessor();\n    }\n\n    assertEquals(1, logCount[0]);\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void appendAdditionalActions(DefaultActionGroup actionGroup,\n                                         ExecutionEnvironment environment, JComponent parent) {\n    super.appendAdditionalActions(actionGroup, environment, parent);\n    actionGroup.addAction(createIncludeNonStartedInRerun()).setAsSecondary(true);\n  }","id":3641,"modified_method":"@Override\n  protected void appendAdditionalActions(DefaultActionGroup actionGroup,\n                                         ExecutionEnvironment environment, JComponent parent) {\n    super.appendAdditionalActions(actionGroup, environment, parent);\n    actionGroup.add(createIncludeNonStartedInRerun());\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ScrollToTestSourceAction(final TestConsoleProperties properties) {\n    super(ExecutionBundle.message(\"junit.auto.scroll.to.source.action.name\"),\n          ExecutionBundle.message(\"junit.open.text.in.editor.action.name\"),\n          AllIcons.General.AutoscrollToSource,\n          properties, TestConsoleProperties.SCROLL_TO_SOURCE);\n  }","id":3642,"modified_method":"public ScrollToTestSourceAction(final TestConsoleProperties properties) {\n    super(ExecutionBundle.message(\"junit.auto.scroll.to.source.action.name\"),\n          ExecutionBundle.message(\"junit.open.text.in.editor.action.name\"),\n          null, properties, TestConsoleProperties.SCROLL_TO_SOURCE);\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ShowStatisticsAction(TestConsoleProperties properties) {\n    super(\"Show Statistics\", \"Toggle the visibility of the test statistics panel\",\n          AllIcons.RunConfigurations.ShowStatistics, properties, TestConsoleProperties.SHOW_STATISTICS);\n  }","id":3643,"modified_method":"public ShowStatisticsAction(TestConsoleProperties properties) {\n    super(\"Show Statistics\", \"Toggle the visibility of the test statistics panel\",\n          null, properties, TestConsoleProperties.SHOW_STATISTICS);\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected ToggleBooleanProperty createIncludeNonStartedInRerun() {\n    String text = ExecutionBundle.message(\"junit.runing.info.include.non.started.in.rerun.failed.action.name\");\n    Icon icon = AllIcons.RunConfigurations.IncludeNonStartedTests_Rerun;\n    return new ToggleBooleanProperty(text, null, icon, this, INCLUDE_NON_STARTED_IN_RERUN_FAILED);\n  }","id":3644,"modified_method":"@NotNull\n  protected ToggleBooleanProperty createIncludeNonStartedInRerun() {\n    String text = ExecutionBundle.message(\"junit.runing.info.include.non.started.in.rerun.failed.action.name\");\n    return new ToggleBooleanProperty(text, null, null, this, INCLUDE_NON_STARTED_IN_RERUN_FAILED);\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void appendAdditionalActions(DefaultActionGroup actionGroup, ExecutionEnvironment environment, JComponent parent) {\n    super.appendAdditionalActions(actionGroup, environment, parent);\n    actionGroup.addAction(createIncludeNonStartedInRerun()).setAsSecondary(true);\n  }","id":3645,"modified_method":"@Override\n  protected void appendAdditionalActions(DefaultActionGroup actionGroup, ExecutionEnvironment environment, JComponent parent) {\n    super.appendAdditionalActions(actionGroup, environment, parent);\n    actionGroup.add(createIncludeNonStartedInRerun());\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ToolbarPanel(final TestConsoleProperties properties,\n                      ExecutionEnvironment environment, JComponent parent) {\n    super(new BorderLayout());\n    final DefaultActionGroup actionGroup = new DefaultActionGroup(null, false);\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.run.hide.passed.action.name\"),\n                                                    ExecutionBundle.message(\"junit.run.hide.passed.action.description\"),\n                                                    AllIcons.RunConfigurations.HidePassed,\n                                                    properties, TestConsoleProperties.HIDE_PASSED_TESTS));\n    actionGroup.addSeparator();\n\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.track.test.action.name\"),\n                                                    ExecutionBundle.message(\"junit.runing.info.track.test.action.description\"),\n                                                    AllIcons.RunConfigurations.TrackTests,\n                                                    properties, TestConsoleProperties.TRACK_RUNNING_TEST)).setAsSecondary(true);\n    actionGroup.addAction(new ToggleBooleanProperty(\"Hide Ignored\", null, AllIcons.RunConfigurations.HideIgnored, properties, TestConsoleProperties.HIDE_IGNORED_TEST)).setAsSecondary(true);\n\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.sort.alphabetically.action.name\"),\n                                                    ExecutionBundle.message(\"junit.runing.info.sort.alphabetically.action.description\"),\n                                                    AllIcons.ObjectBrowser.Sorted,\n                                                    properties, TestConsoleProperties.SORT_ALPHABETICALLY));\n    actionGroup.addSeparator();\n\n    AnAction action = CommonActionsManager.getInstance().createExpandAllAction(myTreeExpander, parent);\n    action.getTemplatePresentation().setDescription(ExecutionBundle.message(\"junit.runing.info.expand.test.action.name\"));\n    actionGroup.add(action);\n\n    action = CommonActionsManager.getInstance().createCollapseAllAction(myTreeExpander, parent);\n    action.getTemplatePresentation().setDescription(ExecutionBundle.message(\"junit.runing.info.collapse.test.action.name\"));\n    actionGroup.add(action);\n\n    actionGroup.addSeparator();\n    final CommonActionsManager actionsManager = CommonActionsManager.getInstance();\n    myOccurenceNavigator = new FailedTestsNavigator();\n    actionGroup.add(actionsManager.createPrevOccurenceAction(myOccurenceNavigator));\n    actionGroup.add(actionsManager.createNextOccurenceAction(myOccurenceNavigator));\n\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.select.first.failed.action.name\"),\n                                                    null,\n                                                    AllIcons.RunConfigurations.SelectFirstDefect,\n                                                    properties, TestConsoleProperties.SELECT_FIRST_DEFECT)).setAsSecondary(true);\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.scroll.to.stacktrace.action.name\"),\n                                                    ExecutionBundle.message(\"junit.runing.info.scroll.to.stacktrace.action.description\"),\n                                                    AllIcons.RunConfigurations.ScrollToStackTrace,\n                                                    properties, TestConsoleProperties.SCROLL_TO_STACK_TRACE)).setAsSecondary(true);\n    myScrollToSource = new ScrollToTestSourceAction(properties);\n    actionGroup.addAction(myScrollToSource).setAsSecondary(true);\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.open.source.at.exception.action.name\"),\n                                                    ExecutionBundle\n                                                      .message(\"junit.runing.info.open.source.at.exception.action.description\"),\n                                                    AllIcons.RunConfigurations.SourceAtException,\n                                                    properties, TestConsoleProperties.OPEN_FAILURE_LINE)).setAsSecondary(true);\n\n    actionGroup.addAction(new ShowStatisticsAction(properties)).setAsSecondary(true);\n    actionGroup.addAction(new AdjustAutotestDelayActionGroup(parent)).setAsSecondary(true);\n\n    for (ToggleModelActionProvider actionProvider : Extensions.getExtensions(ToggleModelActionProvider.EP_NAME)) {\n      final ToggleModelAction toggleModelAction = actionProvider.createToggleModelAction(properties);\n      myActions.add(toggleModelAction);\n      actionGroup.add(toggleModelAction);\n    }\n\n    myExportAction = ExportTestResultsAction.create(properties.getExecutor().getToolWindowId(), properties.getConfiguration());\n    actionGroup.addAction(myExportAction);\n\n    properties.appendAdditionalActions(actionGroup, environment, parent);\n\n    add(ActionManager.getInstance().\n      createActionToolbar(ActionPlaces.TESTTREE_VIEW_TOOLBAR, actionGroup, true).\n      getComponent(), BorderLayout.CENTER);\n  }","id":3646,"modified_method":"public ToolbarPanel(final TestConsoleProperties properties,\n                      ExecutionEnvironment environment, JComponent parent) {\n    super(new BorderLayout());\n    final DefaultActionGroup actionGroup = new DefaultActionGroup(null, false);\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.run.hide.passed.action.name\"),\n                                                    ExecutionBundle.message(\"junit.run.hide.passed.action.description\"),\n                                                    AllIcons.RunConfigurations.HidePassed,\n                                                    properties, TestConsoleProperties.HIDE_PASSED_TESTS));\n    actionGroup.addSeparator();\n\n   \n\n    actionGroup.addAction(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.sort.alphabetically.action.name\"),\n                                                    ExecutionBundle.message(\"junit.runing.info.sort.alphabetically.action.description\"),\n                                                    AllIcons.ObjectBrowser.Sorted,\n                                                    properties, TestConsoleProperties.SORT_ALPHABETICALLY));\n    actionGroup.addSeparator();\n\n    AnAction action = CommonActionsManager.getInstance().createExpandAllAction(myTreeExpander, parent);\n    action.getTemplatePresentation().setDescription(ExecutionBundle.message(\"junit.runing.info.expand.test.action.name\"));\n    actionGroup.add(action);\n\n    action = CommonActionsManager.getInstance().createCollapseAllAction(myTreeExpander, parent);\n    action.getTemplatePresentation().setDescription(ExecutionBundle.message(\"junit.runing.info.collapse.test.action.name\"));\n    actionGroup.add(action);\n\n    actionGroup.addSeparator();\n    final CommonActionsManager actionsManager = CommonActionsManager.getInstance();\n    myOccurenceNavigator = new FailedTestsNavigator();\n    actionGroup.add(actionsManager.createPrevOccurenceAction(myOccurenceNavigator));\n    actionGroup.add(actionsManager.createNextOccurenceAction(myOccurenceNavigator));\n\n    for (ToggleModelActionProvider actionProvider : Extensions.getExtensions(ToggleModelActionProvider.EP_NAME)) {\n      final ToggleModelAction toggleModelAction = actionProvider.createToggleModelAction(properties);\n      myActions.add(toggleModelAction);\n      actionGroup.add(toggleModelAction);\n    }\n\n    myExportAction = ExportTestResultsAction.create(properties.getExecutor().getToolWindowId(), properties.getConfiguration());\n    actionGroup.addAction(myExportAction);\n\n    final DefaultActionGroup secondaryGroup = new DefaultActionGroup();\n    secondaryGroup.setPopup(true);\n    secondaryGroup.getTemplatePresentation().setIcon(AllIcons.General.SecondaryGroup);\n    secondaryGroup.add(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.track.test.action.name\"),\n                                                 ExecutionBundle.message(\"junit.runing.info.track.test.action.description\"),\n                                                 null, properties, TestConsoleProperties.TRACK_RUNNING_TEST));\n    secondaryGroup.add(new ToggleBooleanProperty(\"Hide Ignored\", null, null, properties,\n                                                 TestConsoleProperties.HIDE_IGNORED_TEST));\n    secondaryGroup.add(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.select.first.failed.action.name\"),\n                                                 null, null, properties, TestConsoleProperties.SELECT_FIRST_DEFECT));\n    secondaryGroup.add(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.scroll.to.stacktrace.action.name\"),\n                                                 ExecutionBundle.message(\"junit.runing.info.scroll.to.stacktrace.action.description\"),\n                                                 null, properties, TestConsoleProperties.SCROLL_TO_STACK_TRACE));\n    myScrollToSource = new ScrollToTestSourceAction(properties);\n    secondaryGroup.add(myScrollToSource);\n    secondaryGroup.add(new ToggleBooleanProperty(ExecutionBundle.message(\"junit.runing.info.open.source.at.exception.action.name\"),\n                                                 ExecutionBundle.message(\"junit.runing.info.open.source.at.exception.action.description\"),\n                                                 null, properties, TestConsoleProperties.OPEN_FAILURE_LINE));\n    secondaryGroup.add(new ShowSettingsAction());\n    secondaryGroup.add(new AdjustAutotestDelayActionGroup(parent));\n    properties.appendAdditionalActions(secondaryGroup, environment, parent);\n    actionGroup.add(secondaryGroup);\n\n    add(ActionManager.getInstance().\n      createActionToolbar(ActionPlaces.TESTTREE_VIEW_TOOLBAR, actionGroup, true).\n      getComponent(), BorderLayout.CENTER);\n  }","commit_id":"127d173600b14aed67a11698dc67804e29006713","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void notifyExchangeSent(CamelContext context, Exchange exchange, Endpoint endpoint, long timeTaken) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSentEvent(exchange, endpoint, timeTaken);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3647,"modified_method":"public static void notifyExchangeSent(CamelContext context, Exchange exchange, Endpoint endpoint, long timeTaken) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSentEvent(exchange, endpoint, timeTaken);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStarting(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3648,"modified_method":"public static void notifyCamelContextStarting(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResumeFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumeFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3649,"modified_method":"public static void notifyCamelContextResumeFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumeFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStarted(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3650,"modified_method":"public static void notifyCamelContextStarted(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopping(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3651,"modified_method":"public static void notifyCamelContextStopping(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeCreated(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCreatedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCreatedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3652,"modified_method":"public static void notifyExchangeCreated(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCreatedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCreatedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeSending(CamelContext context, Exchange exchange, Endpoint endpoint) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSendingEvent(exchange, endpoint);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3653,"modified_method":"public static void notifyExchangeSending(CamelContext context, Exchange exchange, Endpoint endpoint) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSendingEvent(exchange, endpoint);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyRouteStopped(CamelContext context, Route route) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStoppedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3654,"modified_method":"public static void notifyRouteStopped(CamelContext context, Route route) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStoppedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextSuspending(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3655,"modified_method":"public static void notifyCamelContextSuspending(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextSuspended(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3656,"modified_method":"public static void notifyCamelContextSuspended(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeFailureHandled(CamelContext context, Exchange exchange, Processor failureHandler,\n                                                    boolean deadLetterChannel) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailureHandledEvent(exchange, failureHandler, deadLetterChannel);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3657,"modified_method":"public static void notifyExchangeFailureHandled(CamelContext context, Exchange exchange, Processor failureHandler,\n                                                    boolean deadLetterChannel) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailureHandledEvent(exchange, failureHandler, deadLetterChannel);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStartupFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartupFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3658,"modified_method":"public static void notifyCamelContextStartupFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartupFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyServiceStopFailure(CamelContext context, Object service, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStopFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3659,"modified_method":"public static void notifyServiceStopFailure(CamelContext context, Object service, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStopFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResumed(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3660,"modified_method":"public static void notifyCamelContextResumed(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeRedelivery(CamelContext context, Exchange exchange, int attempt) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeRedeliveryEvent(exchange, attempt);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3661,"modified_method":"public static void notifyExchangeRedelivery(CamelContext context, Exchange exchange, int attempt) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeRedeliveryEvent(exchange, attempt);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStopFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3662,"modified_method":"public static void notifyCamelContextStopFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStopFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeFailed(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3663,"modified_method":"public static void notifyExchangeFailed(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeDone(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCompletedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCompletedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3664,"modified_method":"public static void notifyExchangeDone(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCompletedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCompletedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResuming(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3665,"modified_method":"public static void notifyCamelContextResuming(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopped(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3666,"modified_method":"public static void notifyCamelContextStopped(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyRouteStarted(CamelContext context, Route route) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStartedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3667,"modified_method":"public static void notifyRouteStarted(CamelContext context, Route route) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStartedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyServiceStartupFailure(CamelContext context, Object service, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStartupFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":3668,"modified_method":"public static void notifyServiceStartupFailure(CamelContext context, Object service, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStartupFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  public int compareTo(ContentFolderBaseImpl folder) {\n    if (!(folder instanceof SourceFolderImpl)) return -1;\n\n    int i = super.compareTo(folder);\n    if (i!= 0) return i;\n\n    i = getPackagePrefix().compareTo(((SourceFolderImpl)folder).getPackagePrefix());\n    if (i!= 0) return i;\n    return Boolean.valueOf(isTestSource()).compareTo(((SourceFolderImpl)folder).isTestSource());\n  }","id":3669,"modified_method":"@Override\n  public int compareTo(ContentFolderBaseImpl folder) {\n    if (!(folder instanceof SourceFolderImpl)) return -1;\n\n    int i = super.compareTo(folder);\n    if (i!= 0) return i;\n\n    SourceFolderImpl sourceFolder = (SourceFolderImpl)folder;\n    i = getPackagePrefix().compareTo(sourceFolder.getPackagePrefix());\n    if (i!= 0) return i;\n    i = Boolean.valueOf(isTestSource()).compareTo(sourceFolder.isTestSource());\n    if (i != 0) return i;\n    //todo[nik] perhaps we should use LinkedSet instead of SortedSet and get rid of this method\n    return myJpsElement.getRootType().getClass().getName().compareTo(sourceFolder.getRootType().getClass().getName());\n  }","commit_id":"72c47261255d8430d9237e801e5d81cc1b918074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Compares this instance to the <code>other<\/code> PathBasedHolder\n     * instance. Comparison takes into account the {@link #path} first. If they\n     * are not equal the result is returned: If the <code>other<\/code> path is\n     * lexicographically sorted behind this {@link #path} a value larger than\n     * zero is returned; otherwise a value smaller than zero is returned.\n     * <p>\n     * If the paths are the same, a positive number is returned if the\n     * <code>other<\/code> service reference is ordered after this service\n     * reference. If the service reference is the same, zero is returned.\n     * <p>\n     * As a special case, zero is returned if <code>other<\/code> is the same\n     * object as this.\n     * <p>\n     * If this service reference is <code>null<\/code>, <code>-1<\/code> is always\n     * returned; if the <code>other<\/code> service reference is\n     * <code>null<\/code>, <code>+1<\/code> is returned.\n     */\n    @Override\n    public final int compareTo(PathBasedHolder other) {\n\n        // compare the path first, and return if not equal\n        final int pathResult = other.path.compareTo(path);\n        if (pathResult != 0) {\n            return pathResult;\n        }\n\n        // now compare the service references giving priority to\n        // to the higher priority service\n        if (serviceReference == null) {\n            if ( other.serviceReference == null ) {\n                return 0;\n            }\n            return -1;\n        } else if (other.serviceReference == null) {\n            return 1;\n        }\n\n        return other.serviceReference.compareTo(serviceReference);\n    }","id":3670,"modified_method":"/**\n     * Compares this instance to the <code>other<\/code> PathBasedHolder\n     * instance. Comparison takes into account the {@link #path} first. If they\n     * are not equal the result is returned: If the <code>other<\/code> path is\n     * lexicographically sorted behind this {@link #path} a value larger than\n     * zero is returned; otherwise a value smaller than zero is returned.\n     * <p>\n     * If the paths are the same, a positive number is returned if the\n     * <code>other<\/code> service reference is ordered after this service\n     * reference. If the service reference is the same, zero is returned.\n     * <p>\n     * As a special case, zero is returned if <code>other<\/code> is the same\n     * object as this.\n     * <p>\n     * If this service reference is <code>null<\/code>, <code>-1<\/code> is always\n     * returned; if the <code>other<\/code> service reference is\n     * <code>null<\/code>, <code>+1<\/code> is returned.\n     */\n    @Override\n    public int compareTo(PathBasedHolder other) {\n\n        // compare the path first, and return if not equal\n        final int pathResult = other.path.compareTo(path);\n        if (pathResult != 0) {\n            return pathResult;\n        }\n\n        // now compare the service references giving priority to\n        // to the higher priority service\n        if (serviceReference == null) {\n            if ( other.serviceReference == null ) {\n                return this.getClass().getName().compareTo(other.getClass().getName());\n            }\n            return -1;\n        } else if (other.serviceReference == null) {\n            return 1;\n        }\n\n        final int serviceResult = other.serviceReference.compareTo(serviceReference);\n        if ( serviceResult != 0 ) {\n            return serviceResult;\n        }\n        return this.getClass().getName().compareTo(other.getClass().getName());\n    }","commit_id":"a52d78da8db46007e5c78414a40d163c03b423c1","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\treturn Integer.valueOf(o1.getOriginal().getConvertedManaCost()).compareTo(Integer.valueOf(o2.getOriginal().getConvertedManaCost()));\n\t}","id":3671,"modified_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\tint val = Integer.valueOf(o1.getOriginal().getConvertedManaCost()).compareTo(Integer.valueOf(o2.getOriginal().getConvertedManaCost()));\n\t\tif (val == 0) {\n\t\t\treturn o1.getOriginal().getName().compareTo(o2.getOriginal().getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\treturn o1.getOriginal().getRarity().compareTo(o2.getOriginal().getRarity());\n\t}","id":3672,"modified_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\tint val = o1.getOriginal().getRarity().compareTo(o2.getOriginal().getRarity());\n\t\tif (val == 0) {\n\t\t\treturn o1.getOriginal().getName().compareTo(o2.getOriginal().getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\treturn o1.getOriginal().getColor().compareTo(o2.getOriginal().getColor());\n\t}","id":3673,"modified_method":"@Override\n\tpublic int compare(MageCard o1, MageCard o2) {\n\t\tint val = o1.getOriginal().getColor().compareTo(o2.getOriginal().getColor());\n\t\tif (val == 0) {\n\t\t\treturn o1.getOriginal().getName().compareTo(o2.getOriginal().getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\treturn o1.getColor().compareTo(o2.getColor());\n\t}","id":3674,"modified_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\tint val = o1.getColor().compareTo(o2.getColor());\n\t\tif (val == 0) {\n\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\treturn Integer.valueOf(o1.getConvertedManaCost()).compareTo(Integer.valueOf(o2.getConvertedManaCost()));\n\t}","id":3675,"modified_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\tint val = Integer.valueOf(o1.getConvertedManaCost()).compareTo(Integer.valueOf(o2.getConvertedManaCost()));\n\t\tif (val == 0) {\n\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\treturn o1.getRarity().compareTo(o2.getRarity());\n\t}","id":3676,"modified_method":"@Override\n\tpublic int compare(CardView o1, CardView o2) {\n\t\tint val = o1.getRarity().compareTo(o2.getRarity());\n\t\tif (val == 0) {\n\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}","commit_id":"f8a26d4e7e5a463f15a9307f370afd3df9bcd5c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3677,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"8bb71c04573179dbca6cb479bed0aa5d479148a4","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3678,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"8bb71c04573179dbca6cb479bed0aa5d479148a4","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3679,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"455b8a10b1790a53f8f6b0c9ba808769c885302c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3680,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"455b8a10b1790a53f8f6b0c9ba808769c885302c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3681,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"afb4882718642ae27ed187d4ae1016a6986ca840","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":3682,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"afb4882718642ae27ed187d4ae1016a6986ca840","url":"https://github.com/apache/groovy"},{"original_method":"private void prepareMongoNodes() {\n        for (MongoNode committingNode : nodes) {\n            logger.debug(String.format(\"Preparing children (added and removed) of %s\", committingNode.getPath()));\n            logger.debug(String.format(\"Committing node: %s\", committingNode));\n\n            List<String> children = committingNode.getChildren();\n            if (children == null) {\n                children = new LinkedList<String>();\n            }\n\n            List<String> addedChildren = committingNode.getAddedChildren();\n            if (addedChildren != null) {\n                children.addAll(addedChildren);\n            }\n\n            List<String> removedChildren = committingNode.getRemovedChildren();\n            if (removedChildren != null) {\n                children.removeAll(removedChildren);\n            }\n\n            if (!children.isEmpty()) {\n                Set<String> temp = new HashSet<String>(children); // remove all duplicates\n                committingNode.setChildren(new LinkedList<String>(temp));\n            } else {\n                committingNode.setChildren(null);\n            }\n\n            Map<String, Object> properties = committingNode.getProperties();\n\n            Map<String, Object> addedProperties = committingNode.getAddedProps();\n            if (addedProperties != null) {\n                properties.putAll(addedProperties);\n            }\n\n            Map<String, Object> removedProperties = committingNode.getRemovedProps();\n            if (removedProperties != null) {\n                for (Map.Entry<String, Object> entry : removedProperties.entrySet()) {\n                    properties.remove(entry.getKey());\n                }\n            }\n\n            if (!properties.isEmpty()) {\n                committingNode.setProperties(properties);\n            } else {\n                committingNode.setProperties(null);\n            }\n\n            committingNode.setRevisionId(revisionId);\n            if (branchId != null) {\n                committingNode.setBranchId(branchId);\n            }\n\n            logger.debug(String.format(\"Prepared committing node: %s\", committingNode));\n        }\n    }","id":3683,"modified_method":"private void prepareMongoNodes() {\n        for (MongoNode committingNode : nodes) {\n            logger.debug(\"Preparing children (added and removed) of {}\", committingNode.getPath());\n            logger.debug(\"Committing node: {}\", committingNode);\n\n            List<String> children = committingNode.getChildren();\n            if (children == null) {\n                children = new LinkedList<String>();\n            }\n\n            List<String> addedChildren = committingNode.getAddedChildren();\n            if (addedChildren != null) {\n                children.addAll(addedChildren);\n            }\n\n            List<String> removedChildren = committingNode.getRemovedChildren();\n            if (removedChildren != null) {\n                children.removeAll(removedChildren);\n            }\n\n            if (!children.isEmpty()) {\n                Set<String> temp = new HashSet<String>(children); // remove all duplicates\n                committingNode.setChildren(new LinkedList<String>(temp));\n            } else {\n                committingNode.setChildren(null);\n            }\n\n            Map<String, Object> properties = committingNode.getProperties();\n\n            Map<String, Object> addedProperties = committingNode.getAddedProps();\n            if (addedProperties != null) {\n                properties.putAll(addedProperties);\n            }\n\n            Map<String, Object> removedProperties = committingNode.getRemovedProps();\n            if (removedProperties != null) {\n                for (Map.Entry<String, Object> entry : removedProperties.entrySet()) {\n                    properties.remove(entry.getKey());\n                }\n            }\n\n            if (!properties.isEmpty()) {\n                committingNode.setProperties(properties);\n            } else {\n                committingNode.setProperties(null);\n            }\n\n            committingNode.setRevisionId(revisionId);\n            if (branchId != null) {\n                committingNode.setBranchId(branchId);\n            }\n\n            logger.debug(\"Prepared committing node: {}\", committingNode);\n        }\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void mergeNodes() {\n        for (MongoNode existingNode : existingNodes) {\n            for (MongoNode committingNode : nodes) {\n                if (existingNode.getPath().equals(committingNode.getPath())) {\n                    logger.debug(String.format(\"Found existing node to merge: %s\", existingNode.getPath()));\n                    logger.debug(String.format(\"Existing node: %s\", existingNode));\n                    logger.debug(String.format(\"Committing node: %s\", committingNode));\n\n                    Map<String, Object> existingProperties = existingNode.getProperties();\n                    if (!existingProperties.isEmpty()) {\n                        committingNode.setProperties(existingProperties);\n\n                        logger.debug(String.format(\"Merged properties for %s: %s\", existingNode.getPath(),\n                                existingProperties));\n                    }\n\n                    List<String> existingChildren = existingNode.getChildren();\n                    if (existingChildren != null) {\n                        committingNode.setChildren(existingChildren);\n\n                        logger.debug(String.format(\"Merged children for %s: %s\", existingNode.getPath(), existingChildren));\n                    }\n\n                    committingNode.setBaseRevisionId(existingNode.getRevisionId());\n\n                    logger.debug(String.format(\"Merged node for %s: %s\", existingNode.getPath(), committingNode));\n\n                    break;\n                }\n            }\n        }\n    }","id":3684,"modified_method":"private void mergeNodes() {\n        for (MongoNode existingNode : existingNodes) {\n            for (MongoNode committingNode : nodes) {\n                if (existingNode.getPath().equals(committingNode.getPath())) {\n                    if(logger.isDebugEnabled()){\n                        logger.debug(\"Found existing node to merge: {}\", existingNode.getPath());\n                        logger.debug(\"Existing node: {}\", existingNode);\n                        logger.debug(\"Committing node: {}\", committingNode);\n                    }\n                    Map<String, Object> existingProperties = existingNode.getProperties();\n                    if (!existingProperties.isEmpty()) {\n                        committingNode.setProperties(existingProperties);\n\n                        logger.debug(\"Merged properties for {}: {}\", existingNode.getPath(),\n                                existingProperties);\n                    }\n\n                    List<String> existingChildren = existingNode.getChildren();\n                    if (existingChildren != null) {\n                        committingNode.setChildren(existingChildren);\n\n                        logger.debug(\"Merged children for {}: {}\", existingNode.getPath(), existingChildren);\n                    }\n\n                    committingNode.setBaseRevisionId(existingNode.getRevisionId());\n\n                    logger.debug(\"Merged node for {}: {}\", existingNode.getPath(), committingNode);\n\n                    break;\n                }\n            }\n        }\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Long execute() throws Exception {\n        logger.debug(String.format(\"Trying to commit: %s\", commit.getDiff()));\n\n        boolean success = false;\n        do {\n            mongoSync = new ReadAndIncHeadRevisionAction(nodeStore).execute();\n            revisionId = mongoSync.getNextRevisionId() - 1;\n            readBranchIdFromBaseCommit();\n            createMongoNodes();\n            prepareCommit();\n            readExistingNodes();\n            mergeNodes();\n            prepareMongoNodes();\n            new SaveNodesAction(nodeStore, nodes).execute();\n            new SaveCommitAction(nodeStore, commit).execute();\n            success = saveAndSetHeadRevision();\n        } while (!success);\n\n        return revisionId;\n    }","id":3685,"modified_method":"@Override\n    public Long execute() throws Exception {\n        logger.debug(\"Trying to commit: {}\", commit.getDiff());\n\n        boolean success = false;\n        do {\n            mongoSync = new ReadAndIncHeadRevisionAction(nodeStore).execute();\n            revisionId = mongoSync.getNextRevisionId() - 1;\n            readBranchIdFromBaseCommit();\n            createMongoNodes();\n            prepareCommit();\n            readExistingNodes();\n            mergeNodes();\n            prepareMongoNodes();\n            new SaveNodesAction(nodeStore, nodes).execute();\n            new SaveCommitAction(nodeStore, commit).execute();\n            success = saveAndSetHeadRevision();\n        } while (!success);\n\n        return revisionId;\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public MongoCommit execute() throws Exception {\n        DBCollection commitCollection = nodeStore.getCommitCollection();\n        DBObject query = QueryBuilder.start(MongoCommit.KEY_FAILED).notEquals(Boolean.TRUE)\n                .and(MongoCommit.KEY_REVISION_ID).is(revisionId)\n                .get();\n\n        LOG.debug(String.format(\"Executing query: %s\", query));\n\n        DBObject dbObject = commitCollection.findOne(query);\n        if (dbObject == null) {\n            throw new Exception(String.format(\"Commit with revision %d could not be found\", revisionId));\n        }\n        return (MongoCommit)dbObject;\n    }","id":3686,"modified_method":"@Override\n    public MongoCommit execute() throws Exception {\n        DBCollection commitCollection = nodeStore.getCommitCollection();\n        DBObject query = QueryBuilder.start(MongoCommit.KEY_FAILED).notEquals(Boolean.TRUE)\n                .and(MongoCommit.KEY_REVISION_ID).is(revisionId)\n                .get();\n\n        LOG.debug(\"Executing query: {}\", query);\n\n        DBObject dbObject = commitCollection.findOne(query);\n        if (dbObject == null) {\n            throw new Exception(String.format(\"Commit with revision %d could not be found\", revisionId));\n        }\n        return (MongoCommit)dbObject;\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private List<MongoCommit> convertToCommits(DBCursor dbCursor) {\n        Map<Long, MongoCommit> commits = new HashMap<Long, MongoCommit>();\n        while (dbCursor.hasNext()) {\n            MongoCommit commitMongo = (MongoCommit) dbCursor.next();\n            commits.put(commitMongo.getRevisionId(), commitMongo);\n        }\n\n        List<MongoCommit> validCommits = new LinkedList<MongoCommit>();\n        if (commits.isEmpty()) {\n            return validCommits;\n        }\n\n        Set<Long> revisions = commits.keySet();\n        long currentRevision = (toRevisionId != -1 && revisions.contains(toRevisionId)) ?\n                toRevisionId : Collections.max(revisions);\n\n        while (true) {\n            MongoCommit commitMongo = commits.get(currentRevision);\n            if (commitMongo == null) {\n                break;\n            }\n            validCommits.add(commitMongo);\n            long baseRevision = commitMongo.getBaseRevisionId();\n            if (currentRevision == 0L || baseRevision < fromRevisionId) {\n                break;\n            }\n            currentRevision = baseRevision;\n        }\n\n        LOG.debug(String.format(\"Found list of valid revisions for max revision %s: %s\",\n                toRevisionId, validCommits));\n\n        return validCommits;\n    }","id":3687,"modified_method":"private List<MongoCommit> convertToCommits(DBCursor dbCursor) {\n        Map<Long, MongoCommit> commits = new HashMap<Long, MongoCommit>();\n        while (dbCursor.hasNext()) {\n            MongoCommit commitMongo = (MongoCommit) dbCursor.next();\n            commits.put(commitMongo.getRevisionId(), commitMongo);\n        }\n\n        List<MongoCommit> validCommits = new LinkedList<MongoCommit>();\n        if (commits.isEmpty()) {\n            return validCommits;\n        }\n\n        Set<Long> revisions = commits.keySet();\n        long currentRevision = (toRevisionId != -1 && revisions.contains(toRevisionId)) ?\n                toRevisionId : Collections.max(revisions);\n\n        while (true) {\n            MongoCommit commitMongo = commits.get(currentRevision);\n            if (commitMongo == null) {\n                break;\n            }\n            validCommits.add(commitMongo);\n            long baseRevision = commitMongo.getBaseRevisionId();\n            if (currentRevision == 0L || baseRevision < fromRevisionId) {\n                break;\n            }\n            currentRevision = baseRevision;\n        }\n\n        LOG.debug(\"Found list of valid revisions for max revision {}: {}\",\n                toRevisionId, validCommits);\n\n        return validCommits;\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private DBCursor fetchListOfValidCommits() {\n        DBCollection commitCollection = nodeStore.getCommitCollection();\n        QueryBuilder queryBuilder = QueryBuilder.start(MongoCommit.KEY_FAILED).notEquals(Boolean.TRUE);\n        if (toRevisionId > -1) {\n            queryBuilder = queryBuilder.and(MongoCommit.KEY_REVISION_ID).lessThanEquals(toRevisionId);\n        }\n\n        if (!includeBranchCommits) {\n            queryBuilder = queryBuilder.and(new BasicDBObject(MongoNode.KEY_BRANCH_ID,\n                    new BasicDBObject(\"$exists\", false)));\n        }\n\n        DBObject query = queryBuilder.get();\n\n        LOG.debug(String.format(\"Executing query: %s\", query));\n\n        return maxEntries > 0? commitCollection.find(query).limit(maxEntries) : commitCollection.find(query);\n    }","id":3688,"modified_method":"private DBCursor fetchListOfValidCommits() {\n        DBCollection commitCollection = nodeStore.getCommitCollection();\n        QueryBuilder queryBuilder = QueryBuilder.start(MongoCommit.KEY_FAILED).notEquals(Boolean.TRUE);\n        if (toRevisionId > -1) {\n            queryBuilder = queryBuilder.and(MongoCommit.KEY_REVISION_ID).lessThanEquals(toRevisionId);\n        }\n\n        if (!includeBranchCommits) {\n            queryBuilder = queryBuilder.and(new BasicDBObject(MongoNode.KEY_BRANCH_ID,\n                    new BasicDBObject(\"$exists\", false)));\n        }\n\n        DBObject query = queryBuilder.get();\n\n        LOG.debug(\"Executing query: {}\", query);\n\n        return maxEntries > 0? commitCollection.find(query).limit(maxEntries) : commitCollection.find(query);\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private List<MongoNode> getMostRecentValidNodes(DBCursor dbCursor,\n            List<MongoCommit> validCommits) {\n        List<Long> validRevisions = extractRevisionIds(validCommits);\n        Map<String, MongoNode> nodeMongos = new HashMap<String, MongoNode>();\n\n        while (dbCursor.hasNext()) {\n            MongoNode nodeMongo = (MongoNode) dbCursor.next();\n\n            String path = nodeMongo.getPath();\n            long revisionId = nodeMongo.getRevisionId();\n\n            LOG.debug(String.format(\"Converting node %s (%d)\", path, revisionId));\n\n            if (!validRevisions.contains(revisionId)) {\n                LOG.debug(String.format(\"Node will not be converted as it is not a valid commit %s (%d)\",\n                        path, revisionId));\n                continue;\n            }\n\n            MongoNode existingNodeMongo = nodeMongos.get(path);\n            if (existingNodeMongo != null) {\n                long existingRevId = existingNodeMongo.getRevisionId();\n\n                if (revisionId > existingRevId) {\n                    nodeMongos.put(path, nodeMongo);\n                    LOG.debug(String.format(\"Converted nodes was put into map and replaced %s (%d)\", path, revisionId));\n                } else {\n                    LOG.debug(String.format(\"Converted nodes was not put into map because a newer version\"\n                            + \" is available %s (%d)\", path, revisionId));\n                }\n            } else {\n                nodeMongos.put(path, nodeMongo);\n                LOG.debug(\"Converted node was put into map\");\n            }\n        }\n\n        return new ArrayList<MongoNode>(nodeMongos.values());\n    }","id":3689,"modified_method":"private List<MongoNode> getMostRecentValidNodes(DBCursor dbCursor,\n            List<MongoCommit> validCommits) {\n        List<Long> validRevisions = extractRevisionIds(validCommits);\n        Map<String, MongoNode> nodeMongos = new HashMap<String, MongoNode>();\n\n        while (dbCursor.hasNext()) {\n            MongoNode nodeMongo = (MongoNode) dbCursor.next();\n\n            String path = nodeMongo.getPath();\n            long revisionId = nodeMongo.getRevisionId();\n\n            LOG.debug(\"Converting node {} ({})\", path, revisionId);\n\n            if (!validRevisions.contains(revisionId)) {\n                LOG.debug(\"Node will not be converted as it is not a valid commit {} ({})\",\n                        path, revisionId);\n                continue;\n            }\n\n            MongoNode existingNodeMongo = nodeMongos.get(path);\n            if (existingNodeMongo != null) {\n                long existingRevId = existingNodeMongo.getRevisionId();\n\n                if (revisionId > existingRevId) {\n                    nodeMongos.put(path, nodeMongo);\n                    LOG.debug(\"Converted nodes was put into map and replaced {} ({})\", path, revisionId);\n                } else {\n                    LOG.debug(\"Converted nodes was not put into map because a newer version\"\n                            + \" is available {} ({})\", path, revisionId);\n                }\n            } else {\n                nodeMongos.put(path, nodeMongo);\n                LOG.debug(\"Converted node was put into map\");\n            }\n        }\n\n        return new ArrayList<MongoNode>(nodeMongos.values());\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private DBCursor performQuery() {\n        QueryBuilder queryBuilder = QueryBuilder.start(MongoNode.KEY_PATH);\n        if (paths.size() > 1) {\n            queryBuilder = queryBuilder.in(paths);\n        } else {\n            String path = paths.toArray(new String[0])[0];\n            if (fetchDescendants) {\n                Pattern pattern = createPrefixRegExp(path);\n                queryBuilder = queryBuilder.regex(pattern);\n            } else {\n                queryBuilder = queryBuilder.is(path);\n            }\n        }\n\n        if (revisionId > 0) {\n            queryBuilder = queryBuilder.and(MongoNode.KEY_REVISION_ID).lessThanEquals(revisionId);\n        }\n\n        if (branchId == null) {\n            DBObject query = new BasicDBObject(MongoNode.KEY_BRANCH_ID, new BasicDBObject(\"$exists\", false));\n            queryBuilder = queryBuilder.and(query);\n        } else {\n            // Not only return nodes in the branch but also nodes in the trunk\n            // before the branch was created.\n            FetchBranchBaseRevisionIdAction action = new FetchBranchBaseRevisionIdAction(nodeStore, branchId);\n            long headBranchRevisionId = action.execute();\n\n            DBObject branchQuery = QueryBuilder.start().or(\n                    QueryBuilder.start(MongoNode.KEY_BRANCH_ID).is(branchId).get(),\n                    QueryBuilder.start(MongoNode.KEY_REVISION_ID).lessThanEquals(headBranchRevisionId).get()\n            ).get();\n            queryBuilder = queryBuilder.and(branchQuery);\n        }\n\n        DBObject query = queryBuilder.get();\n        LOG.debug(String.format(\"Executing query: %s\", query));\n\n        return nodeStore.getNodeCollection().find(query);\n    }","id":3690,"modified_method":"private DBCursor performQuery() {\n        QueryBuilder queryBuilder = QueryBuilder.start(MongoNode.KEY_PATH);\n        if (paths.size() > 1) {\n            queryBuilder = queryBuilder.in(paths);\n        } else {\n            String path = paths.toArray(new String[0])[0];\n            if (fetchDescendants) {\n                Pattern pattern = createPrefixRegExp(path);\n                queryBuilder = queryBuilder.regex(pattern);\n            } else {\n                queryBuilder = queryBuilder.is(path);\n            }\n        }\n\n        if (revisionId > 0) {\n            queryBuilder = queryBuilder.and(MongoNode.KEY_REVISION_ID).lessThanEquals(revisionId);\n        }\n\n        if (branchId == null) {\n            DBObject query = new BasicDBObject(MongoNode.KEY_BRANCH_ID, new BasicDBObject(\"$exists\", false));\n            queryBuilder = queryBuilder.and(query);\n        } else {\n            // Not only return nodes in the branch but also nodes in the trunk\n            // before the branch was created.\n            FetchBranchBaseRevisionIdAction action = new FetchBranchBaseRevisionIdAction(nodeStore, branchId);\n            long headBranchRevisionId = action.execute();\n\n            DBObject branchQuery = QueryBuilder.start().or(\n                    QueryBuilder.start(MongoNode.KEY_BRANCH_ID).is(branchId).get(),\n                    QueryBuilder.start(MongoNode.KEY_REVISION_ID).lessThanEquals(headBranchRevisionId).get()\n            ).get();\n            queryBuilder = queryBuilder.and(branchQuery);\n        }\n\n        DBObject query = queryBuilder.get();\n        LOG.debug(\"Executing query: {}\", query);\n\n        return nodeStore.getNodeCollection().find(query);\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Pattern createPrefixRegExp(String path) {\n        StringBuilder sb = new StringBuilder();\n\n        if (depth < 0) {\n            sb.append(\"^\");\n            sb.append(path);\n        } else if (depth == 0) {\n            sb.append(\"^\");\n            sb.append(path);\n            sb.append(\"$\");\n        } else if (depth > 0) {\n            sb.append(\"^\");\n            if (!\"/\".equals(path)) {\n                sb.append(path);\n            }\n            sb.append(\"(/[^/]*)\");\n            sb.append(\"{0,\");\n            sb.append(depth);\n            sb.append(\"}$\");\n        }\n\n        return Pattern.compile(sb.toString());\n    }","id":3691,"modified_method":"private Pattern createPrefixRegExp(String path) {\n        StringBuilder sb = new StringBuilder();\n        path = Pattern.quote(path);\n\n        if (depth < 0) {\n            sb.append(\"^\");\n            sb.append(path);\n        } else if (depth == 0) {\n            sb.append(\"^\");\n            sb.append(path);\n            sb.append(\"$\");\n        } else if (depth > 0) {\n            sb.append(\"^\");\n            if (!\"/\".equals(path)) {\n                sb.append(path);\n            }\n            sb.append(\"(/[^/]*)\");\n            sb.append(\"{0,\");\n            sb.append(depth);\n            sb.append(\"}$\");\n        }\n\n        return Pattern.compile(sb.toString());\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Constructs a new {@code FetchNodesAction} to fetch nodes with the exact\n     * specified paths.\n     *\n     * @param nodeStore Node store.\n     * @param path The exact paths to fetch nodes for.\n     * @param revisionId The revision id.\n     */\n    public FetchNodesAction(MongoNodeStore nodeStore,  Set<String> paths,\n            long revisionId) {\n        super(nodeStore);\n        this.paths = paths;\n        this.revisionId = revisionId;\n    }","id":3692,"modified_method":"/**\n     * Constructs a new {@code FetchNodesAction} to fetch nodes with the exact\n     * specified paths.\n     *\n     * @param nodeStore Node store.\n     * @param paths The exact paths to fetch nodes for.\n     * @param revisionId The revision id.\n     */\n    public FetchNodesAction(MongoNodeStore nodeStore,  Set<String> paths,\n            long revisionId) {\n        super(nodeStore);\n        this.paths = paths;\n        this.revisionId = revisionId;\n    }","commit_id":"81d8f7f915cd5727ae00b82fbb64872e5f746ab6","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void mergeMatrices() {\n        Iterator<ConnectivityMatrix> i = matrices.iterator();\n        while(i.hasNext()){\n            ConnectivityMatrix matrix = i.next();\n            updateLabels(matrix.getLabels());\n            int matrixSize = matrix.getSize();\n            if(matrixSize > size) {\n                size = matrixSize;\n            }\n            Iterator i1 = matrix.getLabels().iterator();\n            while(i1.hasNext()){\n                String label1 = (String)i1.next();\n                Iterator i2 = matrix.getLabels().iterator();\n                while(i2.hasNext()){\n                    String label2 = (String)i2.next();\n                    int index1 = labels.indexOf(label1);\n                    int index2 = labels.indexOf(label2);\n                    c[index1][index2] += matrix.getConnection(label1,label2);\n//                    System.out.println(\"C:labe11:\"+label1+\" label2:\"+label2+\" c:\"+c[index1][index2]);\n                }\n            }\n        }\n    }","id":3693,"modified_method":"private void mergeMatrices() {\n        Iterator<ConnectivityMatrix> i = matrices.iterator();\n        while(i.hasNext()){\n            ConnectivityMatrix matrix = i.next();\n            updateLabels(matrix.getLabels());\n            int matrixSize = matrix.getSize();\n            if(matrixSize > size) {\n                size = matrixSize;\n            }\n            for(int index1 = 0;index1 < matrix.getLabels().size();index1++) {\n                for(int index2= index1+1; index2<matrix.getLabels().size();index2++) {\n                    c[index1][index2] += matrix.getConnection((String)matrix.getLabels().get(index1),(String)matrix.getLabels().get(index2));\n                }\n            }\n            /**\n            Iterator i1 = matrix.getLabels().iterator();\n            while(i1.hasNext()){\n                String label1 = (String)i1.next();\n                Iterator i2 = matrix.getLabels().iterator();\n                while(i2.hasNext()){\n                    String label2 = (String)i2.next();\n                    int index1 = labels.indexOf(label1);\n                    int index2 = labels.indexOf(label2);\n                    c[index1][index2] += matrix.getConnection(label1,label2);\n//                    System.out.println(\"C:labe11:\"+label1+\" label2:\"+label2+\" c:\"+c[index1][index2]);\n                }\n            }\n             */\n        }\n    }","commit_id":"30fc25b24d9178810783f91398fc8246adac51a6","url":"https://github.com/VUE/VUE"},{"original_method":"public synchronized void unmountBLOB(File location, boolean writeIDX) {\n        Iterator<blobItem> i = this.blobs.iterator();\n        blobItem b;\n        while (i.hasNext()) {\n            b = i.next();\n            if (b.location.equals(location)) {\n                i.remove();\n                b.blob.close(writeIDX);\n                b.blob = null;\n                b.location = null;\n                return;\n            }\n        }\n    }","id":3694,"modified_method":"public synchronized void unmountBLOB(File location, boolean writeIDX) {\n        blobItem b;\n        for (int i = 0; i < this.blobs.size(); i++) {\n            b = this.blobs.get(i);\n            if (b.location.equals(location)) {\n                this.blobs.remove(i);\n                b.blob.close(writeIDX);\n                b.blob = null;\n                b.location = null;\n                return;\n            }\n        }\n    }","commit_id":"568e8f174128ff37a969991cc6d859e9b0c96de3","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n        synchronized (lock) {\n            configuration = newConfig;\n\n            if (configuration.getXslEngine() == XSLEngine.SAXON_EE) {\n                updateTransformerPool(SAXON_EE_FACTORY_NAME);\n                /*\n                 * I found this through here: http://sourceforge.net/p/saxon/mailman/message/29737564/\n                 * A bit of deduction and stuff let me to assume that all dynamic loading is done with the DynamicLoader\n                 * object. The only way to get a hold of that is to typecast the TransformerFactory to the actual class,\n                 * get the DynamicLoader out of it, and set it's classloader to the one where the saxonica classes are located.\n                 */\n                //Now that we have a Saxon EE transformer factory, we need to configure it...\n                //We have to do casting to get the configuration object, to configure the DynamicLoader for our classloader\n                //This is only needed for saxon EE, because it generates bytecode.\n                EnterpriseTransformerFactory etf = (EnterpriseTransformerFactory) transformerFactory;\n                etf.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            } else {\n                updateTransformerPool(SAXON_HE_FACTORY_NAME);\n            }\n\n            xslListener.unsubscribe();\n            try {\n                xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n                buildProcessorPools();\n            } finally {\n                xslListener.listen();\n            }\n        }\n        isInitialized = true;\n    }","id":3695,"modified_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n        synchronized (lock) {\n            configuration = newConfig;\n\n            if (configuration.getXslEngine() == XSLEngine.SAXON_EE) {\n                updateTransformerPool(SAXON_EE_FACTORY_NAME);\n                /*\n                 * I found this through here: http://sourceforge.net/p/saxon/mailman/message/29737564/\n                 * A bit of deduction and stuff let me to assume that all dynamic loading is done with the DynamicLoader\n                 * object. The only way to get a hold of that is to typecast the TransformerFactory to the actual class,\n                 * get the DynamicLoader out of it, and set it's classloader to the one where the saxonica classes are located.\n                 */\n                //Now that we have a Saxon EE transformer factory, we need to configure it...\n                //We have to do casting to get the configuration object, to configure the DynamicLoader for our classloader\n                //This is only needed for saxon EE, because it generates bytecode.\n                EnterpriseTransformerFactory etf = (EnterpriseTransformerFactory) transformerFactory;\n                etf.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            } else {\n                updateTransformerPool(SAXON_HE_FACTORY_NAME);\n                TransformerFactoryImpl tfi = (TransformerFactoryImpl) transformerFactory;\n                tfi.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            }\n\n            xslListener.unsubscribe();\n            try {\n                xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n                buildProcessorPools();\n            } finally {\n                xslListener.listen();\n            }\n        }\n        isInitialized = true;\n    }","commit_id":"8d86b19bfb898df1620538aa4924de1bc2c5b0bf","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n      synchronized (lock) {\n        configuration = newConfig;\n\n        if (configuration.getXslEngine() == XSLEngine.SAXON_EE ) {\n           updateTransformerPool( SAXON_EE_FACTORY_NAME );\n        } else {\n            updateTransformerPool(SAXON_HE_FACTORY_NAME);\n        }\n\n        xslListener.unsubscribe();\n        try {\n          xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n          buildProcessorPools();\n        } finally {\n          xslListener.listen();\n        }\n      }\n      isInitialized = true;\n    }","id":3696,"modified_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n      synchronized (lock) {\n        configuration = newConfig;\n\n        if (configuration.getXslEngine() == XSLEngine.SAXON_EE ) {\n           updateTransformerPool( SAXON_EE_FACTORY_NAME );\n          //Now that we have a Saxon EE transformer factory, we need to configure it...\n          //We have to do casting to get the configuration object, to configure the DynamicLoader for our classloader\n          //This is only needed for saxon EE, because it generates bytecode.\n          EnterpriseTransformerFactory etf = (EnterpriseTransformerFactory)transformerFactory;\n          etf.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n        } else {\n            updateTransformerPool(SAXON_HE_FACTORY_NAME);\n        }\n\n        xslListener.unsubscribe();\n        try {\n          xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n          buildProcessorPools();\n        } finally {\n          xslListener.listen();\n        }\n      }\n      isInitialized = true;\n    }","commit_id":"6954e5652a7fa17b234d3c06ee26e8221cb8d5b0","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n        synchronized (lock) {\n            configuration = newConfig;\n\n            if (configuration.getXslEngine() == XSLEngine.SAXON_EE) {\n                updateTransformerPool(SAXON_EE_FACTORY_NAME);\n                /*\n                 * I found this through here: http://sourceforge.net/p/saxon/mailman/message/29737564/\n                 * A bit of deduction and stuff let me to assume that all dynamic loading is done with the DynamicLoader\n                 * object. The only way to get a hold of that is to typecast the TransformerFactory to the actual class,\n                 * get the DynamicLoader out of it, and set it's classloader to the one where the saxonica classes are located.\n                 */\n                //Now that we have a Saxon EE transformer factory, we need to configure it...\n                //We have to do casting to get the configuration object, to configure the DynamicLoader for our classloader\n                //This is only needed for saxon EE, because it generates bytecode.\n                EnterpriseTransformerFactory etf = (EnterpriseTransformerFactory) transformerFactory;\n                etf.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            } else {\n                updateTransformerPool(SAXON_HE_FACTORY_NAME);\n            }\n\n            xslListener.unsubscribe();\n            try {\n                xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n                buildProcessorPools();\n            } finally {\n                xslListener.listen();\n            }\n        }\n        isInitialized = true;\n    }","id":3697,"modified_method":"@Override\n    public void configurationUpdated(TranslationConfig newConfig) {\n        synchronized (lock) {\n            configuration = newConfig;\n\n            if (configuration.getXslEngine() == XSLEngine.SAXON_EE) {\n                updateTransformerPool(SAXON_EE_FACTORY_NAME);\n                /*\n                 * I found this through here: http://sourceforge.net/p/saxon/mailman/message/29737564/\n                 * A bit of deduction and stuff let me to assume that all dynamic loading is done with the DynamicLoader\n                 * object. The only way to get a hold of that is to typecast the TransformerFactory to the actual class,\n                 * get the DynamicLoader out of it, and set it's classloader to the one where the saxonica classes are located.\n                 */\n                //Now that we have a Saxon EE transformer factory, we need to configure it...\n                //We have to do casting to get the configuration object, to configure the DynamicLoader for our classloader\n                //This is only needed for saxon EE, because it generates bytecode.\n                EnterpriseTransformerFactory etf = (EnterpriseTransformerFactory) transformerFactory;\n                etf.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            } else {\n                updateTransformerPool(SAXON_HE_FACTORY_NAME);\n                TransformerFactoryImpl tfi = (TransformerFactoryImpl) transformerFactory;\n                tfi.getConfiguration().getDynamicLoader().setClassLoader(this.getClass().getClassLoader());\n            }\n\n            xslListener.unsubscribe();\n            try {\n                xsltChainBuilder = new XmlFilterChainBuilder(transformerFactory, false, configuration.isAllowDoctypeDecl());\n                buildProcessorPools();\n            } finally {\n                xslListener.listen();\n            }\n        }\n        isInitialized = true;\n    }","commit_id":"353ed208a7df17ee9f1034e0508568f466c54b03","url":"https://github.com/rackerlabs/repose"},{"original_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      tokens.add(token);\n    }\n  }","id":3698,"modified_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    text = text.replaceAll(\"[\\n\\r]\", \"\");\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      if (VERBOSE) {\n        log.info(\"Adding token \" + token.toShorterString());\n      }\n      tokens.add(token);\n    }\n  }","commit_id":"e026674a16aafeedbdd9112a30402f20ba2c4e50","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":3699,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"e026674a16aafeedbdd9112a30402f20ba2c4e50","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      tokens.add(token);\n    }\n  }","id":3700,"modified_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    text = text.replaceAll(\"[\\n\\r]\", \"\");\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      if (VERBOSE) {\n        log.info(\"Adding token \" + token.toShorterString());\n      }\n      tokens.add(token);\n    }\n  }","commit_id":"a8ba716be130eb80622b718a67411c4998958e54","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":3701,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"a8ba716be130eb80622b718a67411c4998958e54","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      tokens.add(token);\n    }\n  }","id":3702,"modified_method":"private void runSegmentation(CoreMap annotation) {\n    //0 2\n    // A BC D E\n    // 1 10 1 1\n    // 0 12 3 4\n    // 0, 0+1 ,\n\n    String text = annotation.get(CoreAnnotations.TextAnnotation.class);\n    List<CoreLabel> sentChars = annotation.get(SegmenterCoreAnnotations.CharactersAnnotation.class);\n    List<CoreLabel> tokens = new ArrayList<>();\n    annotation.set(CoreAnnotations.TokensAnnotation.class, tokens);\n\n    text = text.replaceAll(\"[\\n\\r]\", \"\");\n    List<String> words = segmenter.segmentString(text);\n    if (VERBOSE) {\n      log.info(text);\n      log.info(\"--->\");\n      log.info(words);\n    }\n\n    int pos = 0;\n    for (String w : words) {\n      CoreLabel fl = sentChars.get(pos);\n      fl.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n      if (w.isEmpty()) {\n        continue;\n      }\n      CoreLabel token = new CoreLabel();\n      token.setWord(w);\n      token.setValue(w);\n      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));\n      pos += w.length();\n      fl = sentChars.get(pos - 1);\n      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, fl.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));\n      if (VERBOSE) {\n        log.info(\"Adding token \" + token.toShorterString());\n      }\n      tokens.add(token);\n    }\n  }","commit_id":"7a45c28faa9f1d0bcc8f1142f811bb95110e297d","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":3703,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"7a45c28faa9f1d0bcc8f1142f811bb95110e297d","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void loadComponentDirectory(String directoryName) {\n        Debug.logInfo(\"Auto-Loading component directory : [\" + directoryName + \"]\", module);\n        File parentPath = new File(directoryName);\n        if (!parentPath.exists() || !parentPath.isDirectory()) {\n            Debug.logError(\"Auto-Load Component directory not found : \" + directoryName, module);\n        } else {\n            File componentLoadConfig = new File(parentPath, \"component-load.xml\");\n            if (componentLoadConfig != null && componentLoadConfig.exists()) {\n                URL configUrl = null;\n                try {\n                    configUrl = componentLoadConfig.toURI().toURL();\n                    List componentsToLoad = ComponentLoaderConfig.getComponentsFromConfig(configUrl);\n                    if (componentsToLoad != null) {\n                        Iterator i = componentsToLoad.iterator();\n                        while (i.hasNext()) {\n                            ComponentLoaderConfig.ComponentDef def = (ComponentLoaderConfig.ComponentDef) i.next();\n                            this.loadComponentFromConfig(parentPath.toString(), def);\n                        }\n                    }\n                } catch (MalformedURLException e) {\n                    Debug.logError(e, \"Unable to locate URL for component loading file: \" + componentLoadConfig.getAbsolutePath(), module);\n                } catch (ComponentException e) {\n                    Debug.logError(e, \"Unable to load components from URL: \" + configUrl.toExternalForm(), module);\n                }\n            } else {\n                String subs[] = parentPath.list();\n                for (int i = 0; i < subs.length; i++) {\n                    try {\n                        File componentPath = new File(parentPath.getCanonicalPath() + \"/\" + subs[i]);\n                        if (componentPath.isDirectory() && !subs[i].equals(\"CVS\")) {\n                            // make sure we have a component configuraton file\n                            String componentLocation = componentPath.getCanonicalPath();\n                            File configFile = new File(componentLocation + \"/ofbiz-component.xml\");\n                            if (configFile.exists()) {\n                                ComponentConfig config = null;\n                                try {\n                                    // pass null for the name, will default to the internal component name\n                                    config = ComponentConfig.getComponentConfig(null, componentLocation);\n                                } catch (ComponentException e) {\n                                    Debug.logError(e, \"Cannot load component : \" + componentPath.getName() + \" @ \" + componentLocation + \" : \" + e.getMessage(), module);\n                                }\n                                if (config == null) {\n                                    Debug.logError(\"Cannot load component : \" + componentPath.getName() + \" @ \" + componentLocation, module);\n                                } else {\n                                    loadComponent(config);\n                                }\n                            }\n                        }\n                    } catch (IOException ioe) {\n                        Debug.logError(ioe, module);\n                    }\n                }\n            }\n        }\n    }","id":3704,"modified_method":"private void loadComponentDirectory(String directoryName) {\n        Debug.logInfo(\"Auto-Loading component directory : [\" + directoryName + \"]\", module);\n        File parentPath = new File(directoryName);\n        if (!parentPath.exists() || !parentPath.isDirectory()) {\n            Debug.logError(\"Auto-Load Component directory not found : \" + directoryName, module);\n        } else {\n            File componentLoadConfig = new File(parentPath, \"component-load.xml\");\n            if (componentLoadConfig != null && componentLoadConfig.exists()) {\n                URL configUrl = null;\n                try {\n                    configUrl = componentLoadConfig.toURI().toURL();\n                    List<ComponentLoaderConfig.ComponentDef> componentsToLoad = ComponentLoaderConfig.getComponentsFromConfig(configUrl);\n                    if (componentsToLoad != null) {\n                        for (ComponentLoaderConfig.ComponentDef def: componentsToLoad) {\n                            this.loadComponentFromConfig(parentPath.toString(), def);\n                        }\n                    }\n                } catch (MalformedURLException e) {\n                    Debug.logError(e, \"Unable to locate URL for component loading file: \" + componentLoadConfig.getAbsolutePath(), module);\n                } catch (ComponentException e) {\n                    Debug.logError(e, \"Unable to load components from URL: \" + configUrl.toExternalForm(), module);\n                }\n            } else {\n                for (String sub: parentPath.list()) {\n                    try {\n                        File componentPath = new File(parentPath.getCanonicalPath() + \"/\" + sub);\n                        if (componentPath.isDirectory() && !sub.equals(\"CVS\")) {\n                            // make sure we have a component configuraton file\n                            String componentLocation = componentPath.getCanonicalPath();\n                            File configFile = new File(componentLocation + \"/ofbiz-component.xml\");\n                            if (configFile.exists()) {\n                                ComponentConfig config = null;\n                                try {\n                                    // pass null for the name, will default to the internal component name\n                                    config = ComponentConfig.getComponentConfig(null, componentLocation);\n                                } catch (ComponentException e) {\n                                    Debug.logError(e, \"Cannot load component : \" + componentPath.getName() + \" @ \" + componentLocation + \" : \" + e.getMessage(), module);\n                                }\n                                if (config == null) {\n                                    Debug.logError(\"Cannot load component : \" + componentPath.getName() + \" @ \" + componentLocation, module);\n                                } else {\n                                    loadComponent(config);\n                                }\n                            }\n                        }\n                    } catch (IOException ioe) {\n                        Debug.logError(ioe, module);\n                    }\n                }\n            }\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public synchronized void loadComponents(String loaderConfig, boolean updateClasspath) throws AlreadyLoadedException, ComponentException {\n        // set the loaded list; and fail if already loaded\n        //if (loadedComponents == null) {\n        //    loadedComponents = new LinkedList();\n        if (!loaded) {\n            loaded = true;\n        } else {\n            throw new AlreadyLoadedException(\"Components already loaded, cannot start\");\n        }\n\n        // get the components to load\n        List components = ComponentLoaderConfig.getRootComponents(loaderConfig);\n\n        String parentPath;\n        try {\n            parentPath = new File(System.getProperty(\"ofbiz.home\")).getCanonicalFile().toString().replaceAll(\"\\\\\\\\\", \"/\");\n        } catch (MalformedURLException e) {\n            throw new ComponentException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new ComponentException(e.getMessage(), e);\n        }\n        // load each component\n        if (components != null) {\n            Iterator ci = components.iterator();\n            while (ci.hasNext()) {\n                ComponentLoaderConfig.ComponentDef def = (ComponentLoaderConfig.ComponentDef) ci.next();\n                this.loadComponentFromConfig(parentPath, def);\n            }\n        }\n\n        // set the new classloader/classpath on the current thread\n        if (updateClasspath) {\n            System.setProperty(\"java.class.path\", classPath.toString());\n            ClassLoader cl = classPath.getClassLoader();\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n\n        Debug.logInfo(\"All components loaded\", module);\n    }","id":3705,"modified_method":"public synchronized void loadComponents(String loaderConfig, boolean updateClasspath) throws AlreadyLoadedException, ComponentException {\n        // set the loaded list; and fail if already loaded\n        //if (loadedComponents == null) {\n        //    loadedComponents = new LinkedList();\n        if (!loaded) {\n            loaded = true;\n        } else {\n            throw new AlreadyLoadedException(\"Components already loaded, cannot start\");\n        }\n\n        // get the components to load\n        List<ComponentLoaderConfig.ComponentDef> components = ComponentLoaderConfig.getRootComponents(loaderConfig);\n\n        String parentPath;\n        try {\n            parentPath = new File(System.getProperty(\"ofbiz.home\")).getCanonicalFile().toString().replaceAll(\"\\\\\\\\\", \"/\");\n        } catch (MalformedURLException e) {\n            throw new ComponentException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new ComponentException(e.getMessage(), e);\n        }\n        // load each component\n        if (components != null) {\n            for (ComponentLoaderConfig.ComponentDef def: components) {\n                this.loadComponentFromConfig(parentPath, def);\n            }\n        }\n\n        // set the new classloader/classpath on the current thread\n        if (updateClasspath) {\n            System.setProperty(\"java.class.path\", classPath.toString());\n            ClassLoader cl = classPath.getClassLoader();\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n\n        Debug.logInfo(\"All components loaded\", module);\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"private void loadComponent(ComponentConfig config) {\n        // make sure the component is enabled\n        if (!config.enabled()) {\n            Debug.logInfo(\"Not Loading component : [\" + config.getComponentName() + \"] (disabled)\", module);\n            return;\n        }\n\n        Debug.logInfo(\"Loading component : [\" + config.getComponentName() + \"]\", module);\n        List classpathInfos = config.getClasspathInfos();\n        String configRoot = config.getRootLocation();\n        configRoot = configRoot.replace('\\\\', '/');\n        // set the root to have a trailing slash\n        if (!configRoot.endsWith(\"/\")) {\n            configRoot = configRoot + \"/\";\n        }\n        if (classpathInfos != null) {\n            Iterator cpi = classpathInfos.iterator();\n            while (cpi.hasNext()) {\n                ComponentConfig.ClasspathInfo cp = (ComponentConfig.ClasspathInfo) cpi.next();\n                String location = cp.location.replace('\\\\', '/');\n                // set the location to not have a leading slash\n                if (location.startsWith(\"/\")) {\n                    location = location.substring(1);\n                }\n                if (\"dir\".equals(cp.type)) {\n                    classPath.addComponent(configRoot + location);\n                } else if (\"jar\".equals(cp.type)) {\n                    String dirLoc = location;\n                    if (dirLoc.endsWith(\"/*\")) {\n                        // strip off the slash splat\n                        dirLoc = location.substring(0, location.length() - 2);\n                    }\n                    File path = new File(configRoot + dirLoc);\n                    if (path.exists()) {\n                        if (path.isDirectory()) {\n                            // load all .jar and .zip files in this directory\n                            File files[] = path.listFiles();\n                            for (int i = 0; i < files.length; i++) {\n                                String file = files[i].getName();\n                                if (file.endsWith(\".jar\") || file.endsWith(\".zip\")) {\n                                    classPath.addComponent(files[i]);\n                                }\n                            }\n                        } else {\n                            // add a single file\n                            classPath.addComponent(configRoot + location);\n                        }\n                    } else {\n                        Debug.logWarning(\"Location '\" + configRoot + dirLoc + \"' does not exist\", module);\n                    }\n                } else {\n                    Debug.logError(\"Classpath type '\" + cp.type + \"' is not supported; '\" + location + \"' not loaded\", module);\n                }\n            }\n        }\n    }","id":3706,"modified_method":"private void loadComponent(ComponentConfig config) {\n        // make sure the component is enabled\n        if (!config.enabled()) {\n            Debug.logInfo(\"Not Loading component : [\" + config.getComponentName() + \"] (disabled)\", module);\n            return;\n        }\n\n        Debug.logInfo(\"Loading component : [\" + config.getComponentName() + \"]\", module);\n        List<ComponentConfig.ClasspathInfo> classpathInfos = config.getClasspathInfos();\n        String configRoot = config.getRootLocation();\n        configRoot = configRoot.replace('\\\\', '/');\n        // set the root to have a trailing slash\n        if (!configRoot.endsWith(\"/\")) {\n            configRoot = configRoot + \"/\";\n        }\n        if (classpathInfos != null) {\n            for (ComponentConfig.ClasspathInfo cp: classpathInfos) {\n                String location = cp.location.replace('\\\\', '/');\n                // set the location to not have a leading slash\n                if (location.startsWith(\"/\")) {\n                    location = location.substring(1);\n                }\n                if (\"dir\".equals(cp.type)) {\n                    classPath.addComponent(configRoot + location);\n                } else if (\"jar\".equals(cp.type)) {\n                    String dirLoc = location;\n                    if (dirLoc.endsWith(\"/*\")) {\n                        // strip off the slash splat\n                        dirLoc = location.substring(0, location.length() - 2);\n                    }\n                    File path = new File(configRoot + dirLoc);\n                    if (path.exists()) {\n                        if (path.isDirectory()) {\n                            // load all .jar and .zip files in this directory\n                            File files[] = path.listFiles();\n                            for (File file: path.listFiles()) {\n                                String fileName = file.getName();\n                                if (fileName.endsWith(\".jar\") || fileName.endsWith(\".zip\")) {\n                                    classPath.addComponent(file);\n                                }\n                            }\n                        } else {\n                            // add a single file\n                            classPath.addComponent(configRoot + location);\n                        }\n                    } else {\n                        Debug.logWarning(\"Location '\" + configRoot + dirLoc + \"' does not exist\", module);\n                    }\n                } else {\n                    Debug.logError(\"Classpath type '\" + cp.type + \"' is not supported; '\" + location + \"' not loaded\", module);\n                }\n            }\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public Property getProperty(String name) {\n            return (Property) properties.get(name);\n        }","id":3707,"modified_method":"public Property getProperty(String name) {\n            return properties.get(name);\n        }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public Property(Element element) {\n                this.name = element.getAttribute(\"name\");\n                this.value = element.getAttribute(\"value\");\n                if (UtilValidate.isEmpty(this.value)) {\n                    this.value = UtilXml.childElementValue(element, \"property-value\");                    \n                }\n\n                properties = new LinkedHashMap();\n                Iterator elementIter = UtilXml.childElementList(element, \"property\").iterator();\n                while (elementIter.hasNext()) {\n                    Element curElement = (Element) elementIter.next();\n                    Property property = new Property(curElement);\n                    properties.put(property.name, property);                    \n                }                    \n            }","id":3708,"modified_method":"public Property(Element element) {\n                this.name = element.getAttribute(\"name\");\n                this.value = element.getAttribute(\"value\");\n                if (UtilValidate.isEmpty(this.value)) {\n                    this.value = UtilXml.childElementValue(element, \"property-value\");                    \n                }\n\n                properties = new LinkedHashMap<String, Property>();\n                for (Element curElement: UtilXml.childElementList(element, \"property\")) {\n                    Property property = new Property(curElement);\n                    properties.put(property.name, property);                    \n                }                    \n            }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Container getContainer(String containerName, String configFile) throws ContainerException {\n        Container container = (Container) containers.get(containerName);\n        if (container == null) {            \n            synchronized (ContainerConfig.class) {\n                container = (Container) containers.get(containerName);\n                if (container == null) {\n                    if (configFile == null) {\n                        throw new ContainerException(\"Container config file cannot be null\");\n                    }\n                    new ContainerConfig(configFile);\n                    container = (Container) containers.get(containerName);\n                }                \n            }\n            if (container == null) {\n                throw new ContainerException(\"No container found with the name : \" + containerName);\n            }            \n        }\n        return container;\n    }","id":3709,"modified_method":"public static Container getContainer(String containerName, String configFile) throws ContainerException {\n        Container container = containers.get(containerName);\n        if (container == null) {            \n            synchronized (ContainerConfig.class) {\n                container = containers.get(containerName);\n                if (container == null) {\n                    if (configFile == null) {\n                        throw new ContainerException(\"Container config file cannot be null\");\n                    }\n                    new ContainerConfig(configFile);\n                    container = (Container) containers.get(containerName);\n                }                \n            }\n            if (container == null) {\n                throw new ContainerException(\"No container found with the name : \" + containerName);\n            }            \n        }\n        return container;\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public Property getProperty(String name) {\n                return (Property) properties.get(name);\n            }","id":3710,"modified_method":"public Property getProperty(String name) {\n                return properties.get(name);\n            }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public Container(Element element) {\n            this.name = element.getAttribute(\"name\");\n            this.className = element.getAttribute(\"class\");\n            \n            properties = new LinkedHashMap();\n            Iterator elementIter = UtilXml.childElementList(element, \"property\").iterator();\n            while (elementIter.hasNext()) {\n                Element curElement = (Element) elementIter.next();\n                Property property = new Property(curElement);\n                properties.put(property.name, property);\n            }                       \n        }","id":3711,"modified_method":"public Container(Element element) {\n            this.name = element.getAttribute(\"name\");\n            this.className = element.getAttribute(\"class\");\n            \n            properties = new LinkedHashMap<String, Property>();\n            for (Element curElement: UtilXml.childElementList(element, \"property\")) {\n                Property property = new Property(curElement);\n                properties.put(property.name, property);\n            }                       \n        }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public List getPropertiesWithValue(String value) {\n                List props = new LinkedList();\n                if (properties != null && properties.size() > 0) {\n                    Iterator i = properties.entrySet().iterator();\n                    while (i.hasNext()) {\n                        Map.Entry e = (Map.Entry) i.next();\n                        Property p = (Property) e.getValue();\n                        if (p != null && value.equals(p.value)) {\n                            props.add(p);\n                        }\n                    }\n                }\n                return props;\n            }","id":3712,"modified_method":"public List<Property> getPropertiesWithValue(String value) {\n                List<Property> props = new LinkedList<Property>();\n                if (properties != null && properties.size() > 0) {\n                    for (Property p: properties.values()) {\n                        if (p != null && value.equals(p.value)) {\n                            props.add(p);\n                        }\n                    }\n                }\n                return props;\n            }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public List getPropertiesWithValue(String value) {\n            List props = new LinkedList();\n            if (properties != null && properties.size() > 0) {\n                Iterator i = properties.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry e = (Map.Entry) i.next();\n                    Property p = (Property) e.getValue();\n                    if (p != null && value.equals(p.value)) {\n                        props.add(p);\n                    }\n                }\n            }\n            return props;\n        }","id":3713,"modified_method":"public List<Property> getPropertiesWithValue(String value) {\n            List<Property> props = new LinkedList<Property>();\n            if (properties != null && properties.size() > 0) {\n                for (Property p: properties.values()) {\n                    if (p != null && value.equals(p.value)) {\n                        props.add(p);\n                    }\n                }\n            }\n            return props;\n        }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"protected ContainerConfig(String configFileLocation) throws ContainerException {        \n        // load the config file\n        URL xmlUrl = UtilURL.fromResource(configFileLocation);\n        if (xmlUrl == null) {\n            throw new ContainerException(\"Could not find \" + configFileLocation + \" master OFBiz container configuration\");\n        }\n        \n        // read the document\n        Document containerDocument = null;\n        try {\n            containerDocument = UtilXml.readXmlDocument(xmlUrl, true);\n        } catch (SAXException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } catch (ParserConfigurationException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } catch (IOException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } \n        \n        // root element\n        Element root = containerDocument.getDocumentElement();        \n          \n        // containers\n        Iterator elementIter = UtilXml.childElementList(root, \"container\").iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            Container container = new Container(curElement);\n            containers.put(container.name, container);    \n        }                          \n    }","id":3714,"modified_method":"protected ContainerConfig(String configFileLocation) throws ContainerException {        \n        // load the config file\n        URL xmlUrl = UtilURL.fromResource(configFileLocation);\n        if (xmlUrl == null) {\n            throw new ContainerException(\"Could not find \" + configFileLocation + \" master OFBiz container configuration\");\n        }\n        \n        // read the document\n        Document containerDocument = null;\n        try {\n            containerDocument = UtilXml.readXmlDocument(xmlUrl, true);\n        } catch (SAXException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } catch (ParserConfigurationException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } catch (IOException e) {\n            throw new ContainerException(\"Error reading the container config file: \" + xmlUrl, e);\n        } \n        \n        // root element\n        Element root = containerDocument.getDocumentElement();        \n          \n        // containers\n        for (Element curElement: UtilXml.childElementList(root, \"container\")) {\n            Container container = new Container(curElement);\n            containers.put(container.name, container);    \n        }                          \n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"private void printThreadDump() {\n        Thread currentThread = Thread.currentThread();\n        ThreadGroup group = currentThread.getThreadGroup();\n        while (group.getParent() != null) {\n            group = group.getParent();\n        }\n        Thread threadArr[] = new Thread[1000];\n        group.enumerate(threadArr);\n\n        StringWriter writer = new StringWriter();\n        PrintWriter out = new PrintWriter(writer);\n        out.println(\"Thread dump:\");\n        for (int i = 0; i < threadArr.length; i++) {\n            if (threadArr[i] != null) {\n                ThreadGroup g = threadArr[i].getThreadGroup();\n                out.println(\"Thread: \" + threadArr[i].getName() + \" [\" + threadArr[i].getId() + \"] @ \" + (g != null ? g.getName() : \"[none]\") + \" : \" + threadArr[i].getPriority() + \" [\" + threadArr[i].getState().name() + \"]\");\n                out.println(\"--- Alive: \" + threadArr[i].isAlive() + \" Daemon: \" + threadArr[i].isDaemon());\n                StackTraceElement[] stacks = threadArr[i].getStackTrace();\n                for (int x = 0; x < stacks.length; x++) {\n                    out.println(\"### \" + stacks[x].toString());\n                }\n            }\n        }\n        Debug.log(writer.toString(), module);\n    }","id":3715,"modified_method":"private void printThreadDump() {\n        Thread currentThread = Thread.currentThread();\n        ThreadGroup group = currentThread.getThreadGroup();\n        while (group.getParent() != null) {\n            group = group.getParent();\n        }\n        Thread threadArr[] = new Thread[1000];\n        group.enumerate(threadArr);\n\n        StringWriter writer = new StringWriter();\n        PrintWriter out = new PrintWriter(writer);\n        out.println(\"Thread dump:\");\n        for (Thread t: threadArr) {\n            if (t != null) {\n                ThreadGroup g = t.getThreadGroup();\n                out.println(\"Thread: \" + t.getName() + \" [\" + t.getId() + \"] @ \" + (g != null ? g.getName() : \"[none]\") + \" : \" + t.getPriority() + \" [\" + t.getState().name() + \"]\");\n                out.println(\"--- Alive: \" + t.isAlive() + \" Daemon: \" + t.isDaemon());\n                StackTraceElement[] stacks = t.getStackTrace();\n                for (StackTraceElement stack: t.getStackTrace()) {\n                    out.println(\"### \" + stack.toString());\n                }\n            }\n        }\n        Debug.log(writer.toString(), module);\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#start()\n     */\n    public void start() throws StartupException {\n        Debug.logInfo(\"[Startup] Starting containers...\", module);\n\n        // start each container object\n        for (int i = 0; i < loadedContainers.size(); i++) {\n            Container container = (Container) loadedContainers.get(i);\n            try {\n                container.start();\n            } catch (ContainerException e) {\n                throw new StartupException(\"Cannot start() \" + container.getClass().getName(), e);\n            } catch (java.lang.AbstractMethodError e) {\n                throw new StartupException(\"Cannot start() \" + container.getClass().getName(), e);\n            }\n        }\n    }","id":3716,"modified_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#start()\n     */\n    public void start() throws StartupException {\n        Debug.logInfo(\"[Startup] Starting containers...\", module);\n\n        // start each container object\n        for (Container container: loadedContainers) {\n            try {\n                container.start();\n            } catch (ContainerException e) {\n                throw new StartupException(\"Cannot start() \" + container.getClass().getName(), e);\n            } catch (java.lang.AbstractMethodError e) {\n                throw new StartupException(\"Cannot start() \" + container.getClass().getName(), e);\n            }\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#load(Start.Config, String[])\n     */\n    public void load(Start.Config config, String args[]) throws StartupException {\n        Debug.logInfo(\"[Startup] Loading containers...\", module);\n        loaded = true;\n        \n        // get the master container configuration file\n        this.configFile = config.containerConfig;\n        \n        Collection containers = null;\n        try {\n            containers = ContainerConfig.getContainers(configFile);\n        } catch (ContainerException e) {            \n            throw new StartupException(e);\n        }\n\n        if (containers != null) {\n            Iterator i = containers.iterator();\n            while (i.hasNext()) {\n                ContainerConfig.Container containerCfg = (ContainerConfig.Container) i.next();                \n                loadedContainers.add(loadContainer(containerCfg, args));\n            }\n        }\n    }","id":3717,"modified_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#load(Start.Config, String[])\n     */\n    public void load(Start.Config config, String args[]) throws StartupException {\n        Debug.logInfo(\"[Startup] Loading containers...\", module);\n        loaded = true;\n        \n        // get the master container configuration file\n        this.configFile = config.containerConfig;\n        \n        Collection<ContainerConfig.Container> containers = null;\n        try {\n            containers = ContainerConfig.getContainers(configFile);\n        } catch (ContainerException e) {            \n            throw new StartupException(e);\n        }\n\n        if (containers != null) {\n            for (ContainerConfig.Container containerCfg: containers) {\n                loadedContainers.add(loadContainer(containerCfg, args));\n            }\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#unload()\n     */\n    public void unload() throws StartupException {\n        Debug.logInfo(\"Shutting down containers\", module);\n        if (Debug.verboseOn())\n            printThreadDump();\n        \n        // shutting down in reverse order\n        for (int i = loadedContainers.size(); i > 0; i--) {\n            Container container = (Container) loadedContainers.get(i-1);\n            try {\n                container.stop();\n            } catch (ContainerException e) {\n                Debug.logError(e, module);\n            }\n        }\n    }","id":3718,"modified_method":"/**\n     * @see org.ofbiz.base.start.StartupLoader#unload()\n     */\n    public void unload() throws StartupException {\n        Debug.logInfo(\"Shutting down containers\", module);\n        if (Debug.verboseOn())\n            printThreadDump();\n        \n        // shutting down in reverse order\n        for (int i = loadedContainers.size(); i > 0; i--) {\n            Container container = loadedContainers.get(i-1);\n            try {\n                container.stop();\n            } catch (ContainerException e) {\n                Debug.logError(e, module);\n            }\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public static JNDIConfigUtil.JndiServerInfo getJndiServerInfo(String name) {\n        return (JNDIConfigUtil.JndiServerInfo) jndiServerInfos.get(name);\n    }","id":3719,"modified_method":"public static JNDIConfigUtil.JndiServerInfo getJndiServerInfo(String name) {\n        return jndiServerInfos.get(name);\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void initialize(Element rootElement) throws GenericConfigException {\n        List childElements = null;\n        Iterator elementIter = null;\n\n        // jndi-server - jndiServerInfos\n        childElements = UtilXml.childElementList(rootElement, \"jndi-server\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            JNDIConfigUtil.JndiServerInfo jndiServerInfo = new JNDIConfigUtil.JndiServerInfo(curElement);\n\n            JNDIConfigUtil.jndiServerInfos.put(jndiServerInfo.name, jndiServerInfo);\n        }\n    }","id":3720,"modified_method":"public static void initialize(Element rootElement) throws GenericConfigException {\n        // jndi-server - jndiServerInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"jndi-server\")) {\n            JNDIConfigUtil.JndiServerInfo jndiServerInfo = new JNDIConfigUtil.JndiServerInfo(curElement);\n\n            JNDIConfigUtil.jndiServerInfos.put(jndiServerInfo.name, jndiServerInfo);\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"public boolean start() throws ContainerException {\n        ContainerConfig.Container jc = ContainerConfig.getContainer(\"junit-container\", configFile);\n\n        // get the tests to run\n        Iterator ti = jc.properties.values().iterator();\n        if (ti == null) {\n            Debug.log(\"No tests to load\", module);\n            return true;\n        }\n\n        // load the tests into the suite\n        TestSuite suite = new TestSuite();\n        while (ti.hasNext()) {\n            ContainerConfig.Container.Property prop = (ContainerConfig.Container.Property) ti.next();\n            Class clz = null;\n            try {\n                clz = ObjectType.loadClass(prop.value);\n                suite.addTestSuite(clz);\n            } catch (Exception e) {\n                Debug.logError(e, \"Unable to load test suite class : \" + prop.value, module);\n            }\n        }\n\n        // holder for the results\n        results = new TestResult();\n\n        // run the tests\n        suite.run(results);\n\n        // dispay the results\n        Debug.log(\"[JUNIT] Pass: \" + results.wasSuccessful() + \" | # Tests: \" + results.runCount() + \" | # Failed: \" +\n                results.failureCount() + \" # Errors: \" + results.errorCount(), module);\n        if (Debug.infoOn()) {\n            Debug.log(\"[JUNIT] ----------------------------- ERRORS ----------------------------- [JUNIT]\", module);\n            Enumeration err = results.errors();\n            if (!err.hasMoreElements()) {\n                Debug.log(\"None\");\n            } else {\n                while (err.hasMoreElements()) {\n                    Debug.log(\"--> \" + err.nextElement(), module);\n                }\n            }\n            Debug.log(\"[JUNIT] ------------------------------------------------------------------ [JUNIT]\", module);\n            Debug.log(\"[JUNIT] ---------------------------- FAILURES ---------------------------- [JUNIT]\", module);\n            Enumeration fail = results.failures();\n            if (!fail.hasMoreElements()) {\n                Debug.log(\"None\");\n            } else {\n                while (fail.hasMoreElements()) {\n                    Debug.log(\"--> \" + fail.nextElement(), module);\n                }\n            }\n            Debug.log(\"[JUNIT] ------------------------------------------------------------------ [JUNIT]\", module);\n        }\n\n        return true;\n    }","id":3721,"modified_method":"public boolean start() throws ContainerException {\n        ContainerConfig.Container jc = ContainerConfig.getContainer(\"junit-container\", configFile);\n\n        // get the tests to run\n        Iterator<ContainerConfig.Container.Property> ti = jc.properties.values().iterator();\n        if (ti == null) {\n            Debug.log(\"No tests to load\", module);\n            return true;\n        }\n\n        // load the tests into the suite\n        TestSuite suite = new TestSuite();\n        while (ti.hasNext()) {\n            ContainerConfig.Container.Property prop = ti.next();\n            Class clz = null;\n            try {\n                clz = ObjectType.loadClass(prop.value);\n                suite.addTestSuite(clz);\n            } catch (Exception e) {\n                Debug.logError(e, \"Unable to load test suite class : \" + prop.value, module);\n            }\n        }\n\n        // holder for the results\n        results = new TestResult();\n\n        // run the tests\n        suite.run(results);\n\n        // dispay the results\n        Debug.log(\"[JUNIT] Pass: \" + results.wasSuccessful() + \" | # Tests: \" + results.runCount() + \" | # Failed: \" +\n                results.failureCount() + \" # Errors: \" + results.errorCount(), module);\n        if (Debug.infoOn()) {\n            Debug.log(\"[JUNIT] ----------------------------- ERRORS ----------------------------- [JUNIT]\", module);\n            Enumeration err = results.errors();\n            if (!err.hasMoreElements()) {\n                Debug.log(\"None\");\n            } else {\n                while (err.hasMoreElements()) {\n                    Debug.log(\"--> \" + err.nextElement(), module);\n                }\n            }\n            Debug.log(\"[JUNIT] ------------------------------------------------------------------ [JUNIT]\", module);\n            Debug.log(\"[JUNIT] ---------------------------- FAILURES ---------------------------- [JUNIT]\", module);\n            Enumeration fail = results.failures();\n            if (!fail.hasMoreElements()) {\n                Debug.log(\"None\");\n            } else {\n                while (fail.hasMoreElements()) {\n                    Debug.log(\"--> \" + fail.nextElement(), module);\n                }\n            }\n            Debug.log(\"[JUNIT] ------------------------------------------------------------------ [JUNIT]\", module);\n        }\n\n        return true;\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Initializes the security configuration\n     *\n     * @param rootElement\n     * @throws GenericConfigException\n     */\n    public static void initialize(Element rootElement) throws GenericConfigException {\n        List childElements = null;\n        Iterator elementIter = null;\n\n        // security-config - securityInfos\n        childElements = UtilXml.childElementList(rootElement, \"security\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            SecurityConfigUtil.SecurityInfo securityInfo = new SecurityConfigUtil.SecurityInfo(curElement);\n\n            if (Debug.verboseOn()) Debug.logVerbose(\"LOADED SECURITY CONFIG FROM XML -  NAME: \" + securityInfo.name + \" ClassName: \" + securityInfo.className, module);\n            SecurityConfigUtil.securityInfos.put(securityInfo.name, securityInfo);\n        }\n    }","id":3722,"modified_method":"/**\n     * Initializes the security configuration\n     *\n     * @param rootElement\n     * @throws GenericConfigException\n     */\n    public static void initialize(Element rootElement) throws GenericConfigException {\n        // security-config - securityInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"security\")) {\n            SecurityConfigUtil.SecurityInfo securityInfo = new SecurityConfigUtil.SecurityInfo(curElement);\n\n            if (Debug.verboseOn()) Debug.logVerbose(\"LOADED SECURITY CONFIG FROM XML -  NAME: \" + securityInfo.name + \" ClassName: \" + securityInfo.className, module);\n            SecurityConfigUtil.securityInfos.put(securityInfo.name, securityInfo);\n        }\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Returns the security config for a given name\n     *\n     * @param name\n     * @return\n     */\n    public static SecurityConfigUtil.SecurityInfo getSecurityInfo(String name) {\n        return (SecurityConfigUtil.SecurityInfo) securityInfos.get(name);\n    }","id":3723,"modified_method":"/**\n     * Returns the security config for a given name\n     *\n     * @param name\n     * @return\n     */\n    public static SecurityConfigUtil.SecurityInfo getSecurityInfo(String name) {\n        return securityInfos.get(name);\n    }","commit_id":"5c59b356dbd750cbfb46b66e1fa721d2c2afbc06","url":"https://github.com/apache/ofbiz"},{"original_method":"protected NotificationGroup(Element e) {\n            name = e.getAttribute(\"name\");\n            notify = FastList.newInstance();\n            notification = new Notification(UtilXml.firstChildElement(e, \"notification\"));\n\n            List n = UtilXml.childElementList(e, \"notify\");\n            Iterator i = n.iterator();\n            while (i.hasNext()) {\n                Element e2 = (Element) i.next();\n                notify.add(new Notify(e2));\n            }\n        }","id":3724,"modified_method":"protected NotificationGroup(Element e) {\n            name = e.getAttribute(\"name\");\n            notify = FastList.newInstance();\n            notification = new Notification(UtilXml.firstChildElement(e, \"notification\"));\n\n            for (Element e2: UtilXml.childElementList(e, \"notify\")) {\n                notify.add(new Notify(e2));\n            }\n        }","commit_id":"c310ae97fbbc38de65391320a0f85c29d4a879a7","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void addEcaDefinitions(ResourceHandler handler) {\n        Element rootElement = null;\n        try {\n            rootElement = handler.getDocument().getDocumentElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, module);\n            return;\n        }\n\n        List ecaList = UtilXml.childElementList(rootElement, \"eca\");\n        Iterator ecaIt = ecaList.iterator();\n        int numDefs = 0;\n        while (ecaIt.hasNext()) {\n            Element e = (Element) ecaIt.next();\n            String serviceName = e.getAttribute(\"service\");\n            String eventName = e.getAttribute(\"event\");\n            Map eventMap = (Map) ecaCache.get(serviceName);\n            List rules = null;\n\n            if (eventMap == null) {\n                eventMap = FastMap.newInstance();\n                rules = new LinkedList();\n                ecaCache.put(serviceName, eventMap);\n                eventMap.put(eventName, rules);\n            } else {\n                rules = (List) eventMap.get(eventName);\n                if (rules == null) {\n                    rules = new LinkedList();\n                    eventMap.put(eventName, rules);\n                }\n            }\n            rules.add(new ServiceEcaRule(e));\n            numDefs++;\n        }\n        if (Debug.importantOn()) {\n            String resourceLocation = handler.getLocation();\n            try {\n                resourceLocation = handler.getURL().toExternalForm();\n            } catch (GenericConfigException e) {\n                Debug.logError(e, \"Could not get resource URL\", module);\n            }\n            Debug.logImportant(\"Loaded \" + numDefs + \" Service ECA definitions from \" + resourceLocation, module);\n        }\n    }","id":3725,"modified_method":"public static void addEcaDefinitions(ResourceHandler handler) {\n        Element rootElement = null;\n        try {\n            rootElement = handler.getDocument().getDocumentElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, module);\n            return;\n        }\n\n        int numDefs = 0;\n        for (Element e: UtilXml.childElementList(rootElement, \"eca\")) {\n            String serviceName = e.getAttribute(\"service\");\n            String eventName = e.getAttribute(\"event\");\n            Map eventMap = (Map) ecaCache.get(serviceName);\n            List rules = null;\n\n            if (eventMap == null) {\n                eventMap = FastMap.newInstance();\n                rules = new LinkedList();\n                ecaCache.put(serviceName, eventMap);\n                eventMap.put(eventName, rules);\n            } else {\n                rules = (List) eventMap.get(eventName);\n                if (rules == null) {\n                    rules = new LinkedList();\n                    eventMap.put(eventName, rules);\n                }\n            }\n            rules.add(new ServiceEcaRule(e));\n            numDefs++;\n        }\n        if (Debug.importantOn()) {\n            String resourceLocation = handler.getLocation();\n            try {\n                resourceLocation = handler.getURL().toExternalForm();\n            } catch (GenericConfigException e) {\n                Debug.logError(e, \"Could not get resource URL\", module);\n            }\n            Debug.logImportant(\"Loaded \" + numDefs + \" Service ECA definitions from \" + resourceLocation, module);\n        }\n    }","commit_id":"c310ae97fbbc38de65391320a0f85c29d4a879a7","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        List serviceEcasElements = UtilXml.childElementList(rootElement, \"service-ecas\");\n        Iterator secasIter = serviceEcasElements.iterator();\n        while (secasIter.hasNext()) {\n            Element serviceEcasElement = (Element) secasIter.next();\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"eca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":3726,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceEcasElement: UtilXml.childElementList(rootElement, \"service-ecas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"eca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"c310ae97fbbc38de65391320a0f85c29d4a879a7","url":"https://github.com/apache/ofbiz"},{"original_method":"public DelegatorInfo(Element element) {\n        super(element);\n        this.entityModelReader = element.getAttribute(\"entity-model-reader\");\n        this.entityGroupReader = element.getAttribute(\"entity-group-reader\");\n        this.entityEcaReader = element.getAttribute(\"entity-eca-reader\");\n\n        // this defaults to true, ie anything but false is true\n        this.useEntityEca = !\"false\".equalsIgnoreCase(element.getAttribute(\"entity-eca-enabled\"));\n        this.entityEcaHandlerClassName = element.getAttribute(\"entity-eca-handler-class-name\");\n\n        // this defaults to false, ie anything but true is false\n        this.useDistributedCacheClear = \"true\".equalsIgnoreCase(element.getAttribute(\"distributed-cache-clear-enabled\"));\n        this.distributedCacheClearClassName = element.getAttribute(\"distributed-cache-clear-class-name\");\n        if (UtilValidate.isEmpty(this.distributedCacheClearClassName)) this.distributedCacheClearClassName = \"org.ofbiz.entityext.cache.EntityCacheServices\";\n        \n        this.distributedCacheClearUserLoginId = element.getAttribute(\"distributed-cache-clear-user-login-id\");\n        if (UtilValidate.isEmpty(this.distributedCacheClearUserLoginId)) this.distributedCacheClearUserLoginId= \"admin\";\n\n        this.sequencedIdPrefix = element.getAttribute(\"sequenced-id-prefix\");\n        \n        List groupMapList = UtilXml.childElementList(element, \"group-map\");\n        Iterator groupMapIter = groupMapList.iterator();\n\n        while (groupMapIter.hasNext()) {\n            Element groupMapElement = (Element) groupMapIter.next();\n            groupMap.put(groupMapElement.getAttribute(\"group-name\"), groupMapElement.getAttribute(\"datasource-name\"));\n        }\n    }","id":3727,"modified_method":"public DelegatorInfo(Element element) {\n        super(element);\n        this.entityModelReader = element.getAttribute(\"entity-model-reader\");\n        this.entityGroupReader = element.getAttribute(\"entity-group-reader\");\n        this.entityEcaReader = element.getAttribute(\"entity-eca-reader\");\n\n        // this defaults to true, ie anything but false is true\n        this.useEntityEca = !\"false\".equalsIgnoreCase(element.getAttribute(\"entity-eca-enabled\"));\n        this.entityEcaHandlerClassName = element.getAttribute(\"entity-eca-handler-class-name\");\n\n        // this defaults to false, ie anything but true is false\n        this.useDistributedCacheClear = \"true\".equalsIgnoreCase(element.getAttribute(\"distributed-cache-clear-enabled\"));\n        this.distributedCacheClearClassName = element.getAttribute(\"distributed-cache-clear-class-name\");\n        if (UtilValidate.isEmpty(this.distributedCacheClearClassName)) this.distributedCacheClearClassName = \"org.ofbiz.entityext.cache.EntityCacheServices\";\n        \n        this.distributedCacheClearUserLoginId = element.getAttribute(\"distributed-cache-clear-user-login-id\");\n        if (UtilValidate.isEmpty(this.distributedCacheClearUserLoginId)) this.distributedCacheClearUserLoginId= \"admin\";\n\n        this.sequencedIdPrefix = element.getAttribute(\"sequenced-id-prefix\");\n        \n        for (Element groupMapElement: UtilXml.childElementList(element, \"group-map\")) {\n            groupMap.put(groupMapElement.getAttribute(\"group-name\"), groupMapElement.getAttribute(\"datasource-name\"));\n        }\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static FieldTypeInfo getFieldTypeInfo(String name) {\n        return (FieldTypeInfo) fieldTypeInfos.get(name);\n    }","id":3728,"modified_method":"public static FieldTypeInfo getFieldTypeInfo(String name) {\n        return fieldTypeInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static DelegatorInfo getDelegatorInfo(String name) {\n        return (DelegatorInfo) delegatorInfos.get(name);\n    }","id":3729,"modified_method":"public static DelegatorInfo getDelegatorInfo(String name) {\n        return delegatorInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static EntityGroupReaderInfo getEntityGroupReaderInfo(String name) {\n        return (EntityGroupReaderInfo) entityGroupReaderInfos.get(name);\n    }","id":3730,"modified_method":"public static EntityGroupReaderInfo getEntityGroupReaderInfo(String name) {\n        return entityGroupReaderInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static EntityEcaReaderInfo getEntityEcaReaderInfo(String name) {\n        return (EntityEcaReaderInfo) entityEcaReaderInfos.get(name);\n    }","id":3731,"modified_method":"public static EntityEcaReaderInfo getEntityEcaReaderInfo(String name) {\n        return entityEcaReaderInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static EntityDataReaderInfo getEntityDataReaderInfo(String name) {\n        return (EntityDataReaderInfo) entityDataReaderInfos.get(name);\n    }","id":3732,"modified_method":"public static EntityDataReaderInfo getEntityDataReaderInfo(String name) {\n        return entityDataReaderInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static DatasourceInfo getDatasourceInfo(String name) {\n        return (DatasourceInfo) datasourceInfos.get(name);\n    }","id":3733,"modified_method":"public static DatasourceInfo getDatasourceInfo(String name) {\n        return datasourceInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static ResourceLoaderInfo getResourceLoaderInfo(String name) {\n        return (ResourceLoaderInfo) resourceLoaderInfos.get(name);\n    }","id":3734,"modified_method":"public static ResourceLoaderInfo getResourceLoaderInfo(String name) {\n        return resourceLoaderInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void initialize(Element rootElement) throws GenericEntityException {\n        // load the transaction factory\n        Element transactionFactoryElement = UtilXml.firstChildElement(rootElement, \"transaction-factory\");\n        if (transactionFactoryElement == null) {\n            throw new GenericEntityConfException(\"ERROR: no transaction-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME);\n        }\n\n        txFactoryClass = transactionFactoryElement.getAttribute(\"class\");\n\n        Element userTxJndiElement = UtilXml.firstChildElement(transactionFactoryElement, \"user-transaction-jndi\");\n        if (userTxJndiElement != null) {\n            txFactoryUserTxJndiName = userTxJndiElement.getAttribute(\"jndi-name\");\n            txFactoryUserTxJndiServerName = userTxJndiElement.getAttribute(\"jndi-server-name\");\n        } else {\n            txFactoryUserTxJndiName = null;\n            txFactoryUserTxJndiServerName = null;\n        }\n\n        Element txMgrJndiElement = UtilXml.firstChildElement(transactionFactoryElement, \"transaction-manager-jndi\");\n        if (txMgrJndiElement != null) {\n            txFactoryTxMgrJndiName = txMgrJndiElement.getAttribute(\"jndi-name\");\n            txFactoryTxMgrJndiServerName = txMgrJndiElement.getAttribute(\"jndi-server-name\");\n        } else {\n            txFactoryTxMgrJndiName = null;\n            txFactoryTxMgrJndiServerName = null;\n        }\n\n        // load the connection factory\n        Element connectionFactoryElement = UtilXml.firstChildElement(rootElement, \"connection-factory\");\n        if (connectionFactoryElement == null) {\n            throw new GenericEntityConfException(\"ERROR: no connection-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME);\n        }\n\n        connFactoryClass = connectionFactoryElement.getAttribute(\"class\");\n\n        // not load all of the maps...\n        List childElements = null;\n        Iterator elementIter = null;\n\n        // resource-loader - resourceLoaderInfos\n        childElements = UtilXml.childElementList(rootElement, \"resource-loader\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            ResourceLoaderInfo resourceLoaderInfo = new ResourceLoaderInfo(curElement);\n            resourceLoaderInfos.put(resourceLoaderInfo.name, resourceLoaderInfo);\n        }\n\n        // delegator - delegatorInfos\n        childElements = UtilXml.childElementList(rootElement, \"delegator\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            DelegatorInfo delegatorInfo = new DelegatorInfo(curElement);\n            delegatorInfos.put(delegatorInfo.name, delegatorInfo);\n        }\n\n        // entity-model-reader - entityModelReaderInfos\n        childElements = UtilXml.childElementList(rootElement, \"entity-model-reader\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            EntityModelReaderInfo entityModelReaderInfo = new EntityModelReaderInfo(curElement);\n            entityModelReaderInfos.put(entityModelReaderInfo.name, entityModelReaderInfo);\n        }\n\n        // entity-group-reader - entityGroupReaderInfos\n        childElements = UtilXml.childElementList(rootElement, \"entity-group-reader\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            EntityGroupReaderInfo entityGroupReaderInfo = new EntityGroupReaderInfo(curElement);\n            entityGroupReaderInfos.put(entityGroupReaderInfo.name, entityGroupReaderInfo);\n        }\n\n        // entity-eca-reader - entityEcaReaderInfos\n        childElements = UtilXml.childElementList(rootElement, \"entity-eca-reader\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            EntityEcaReaderInfo entityEcaReaderInfo = new EntityEcaReaderInfo(curElement);\n            entityEcaReaderInfos.put(entityEcaReaderInfo.name, entityEcaReaderInfo);\n        }\n\n        // entity-data-reader - entityDataReaderInfos\n        childElements = UtilXml.childElementList(rootElement, \"entity-data-reader\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            EntityDataReaderInfo entityDataReaderInfo = new EntityDataReaderInfo(curElement);\n            entityDataReaderInfos.put(entityDataReaderInfo.name, entityDataReaderInfo);\n        }\n\n        // field-type - fieldTypeInfos\n        childElements = UtilXml.childElementList(rootElement, \"field-type\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            FieldTypeInfo fieldTypeInfo = new FieldTypeInfo(curElement);\n            fieldTypeInfos.put(fieldTypeInfo.name, fieldTypeInfo);\n        }\n\n        // datasource - datasourceInfos\n        childElements = UtilXml.childElementList(rootElement, \"datasource\");\n        elementIter = childElements.iterator();\n        while (elementIter.hasNext()) {\n            Element curElement = (Element) elementIter.next();\n            DatasourceInfo datasourceInfo = new DatasourceInfo(curElement);\n            datasourceInfos.put(datasourceInfo.name, datasourceInfo);\n        }\n    }","id":3735,"modified_method":"public static void initialize(Element rootElement) throws GenericEntityException {\n        // load the transaction factory\n        Element transactionFactoryElement = UtilXml.firstChildElement(rootElement, \"transaction-factory\");\n        if (transactionFactoryElement == null) {\n            throw new GenericEntityConfException(\"ERROR: no transaction-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME);\n        }\n\n        txFactoryClass = transactionFactoryElement.getAttribute(\"class\");\n\n        Element userTxJndiElement = UtilXml.firstChildElement(transactionFactoryElement, \"user-transaction-jndi\");\n        if (userTxJndiElement != null) {\n            txFactoryUserTxJndiName = userTxJndiElement.getAttribute(\"jndi-name\");\n            txFactoryUserTxJndiServerName = userTxJndiElement.getAttribute(\"jndi-server-name\");\n        } else {\n            txFactoryUserTxJndiName = null;\n            txFactoryUserTxJndiServerName = null;\n        }\n\n        Element txMgrJndiElement = UtilXml.firstChildElement(transactionFactoryElement, \"transaction-manager-jndi\");\n        if (txMgrJndiElement != null) {\n            txFactoryTxMgrJndiName = txMgrJndiElement.getAttribute(\"jndi-name\");\n            txFactoryTxMgrJndiServerName = txMgrJndiElement.getAttribute(\"jndi-server-name\");\n        } else {\n            txFactoryTxMgrJndiName = null;\n            txFactoryTxMgrJndiServerName = null;\n        }\n\n        // load the connection factory\n        Element connectionFactoryElement = UtilXml.firstChildElement(rootElement, \"connection-factory\");\n        if (connectionFactoryElement == null) {\n            throw new GenericEntityConfException(\"ERROR: no connection-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME);\n        }\n\n        connFactoryClass = connectionFactoryElement.getAttribute(\"class\");\n\n        // not load all of the maps...\n\n        // resource-loader - resourceLoaderInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"resource-loader\")) {\n            ResourceLoaderInfo resourceLoaderInfo = new ResourceLoaderInfo(curElement);\n            resourceLoaderInfos.put(resourceLoaderInfo.name, resourceLoaderInfo);\n        }\n\n        // delegator - delegatorInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"delegator\")) {\n            DelegatorInfo delegatorInfo = new DelegatorInfo(curElement);\n            delegatorInfos.put(delegatorInfo.name, delegatorInfo);\n        }\n\n        // entity-model-reader - entityModelReaderInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"entity-model-reader\")) {\n            EntityModelReaderInfo entityModelReaderInfo = new EntityModelReaderInfo(curElement);\n            entityModelReaderInfos.put(entityModelReaderInfo.name, entityModelReaderInfo);\n        }\n\n        // entity-group-reader - entityGroupReaderInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"entity-group-reader\")) {\n            EntityGroupReaderInfo entityGroupReaderInfo = new EntityGroupReaderInfo(curElement);\n            entityGroupReaderInfos.put(entityGroupReaderInfo.name, entityGroupReaderInfo);\n        }\n\n        // entity-eca-reader - entityEcaReaderInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"entity-eca-reader\")) {\n            EntityEcaReaderInfo entityEcaReaderInfo = new EntityEcaReaderInfo(curElement);\n            entityEcaReaderInfos.put(entityEcaReaderInfo.name, entityEcaReaderInfo);\n        }\n\n        // entity-data-reader - entityDataReaderInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"entity-data-reader\")) {\n            EntityDataReaderInfo entityDataReaderInfo = new EntityDataReaderInfo(curElement);\n            entityDataReaderInfos.put(entityDataReaderInfo.name, entityDataReaderInfo);\n        }\n\n        // field-type - fieldTypeInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"field-type\")) {\n            FieldTypeInfo fieldTypeInfo = new FieldTypeInfo(curElement);\n            fieldTypeInfos.put(fieldTypeInfo.name, fieldTypeInfo);\n        }\n\n        // datasource - datasourceInfos\n        for (Element curElement: UtilXml.childElementList(rootElement, \"datasource\")) {\n            DatasourceInfo datasourceInfo = new DatasourceInfo(curElement);\n            datasourceInfos.put(datasourceInfo.name, datasourceInfo);\n        }\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public static EntityModelReaderInfo getEntityModelReaderInfo(String name) {\n        return (EntityModelReaderInfo) entityModelReaderInfos.get(name);\n    }","id":3736,"modified_method":"public static EntityModelReaderInfo getEntityModelReaderInfo(String name) {\n        return entityModelReaderInfos.get(name);\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"public ResourceInfo(Element element) {\n        super(element);\n        resourceElements = UtilXml.childElementList(element, \"resource\");\n    }","id":3737,"modified_method":"public ResourceInfo(Element element) {\n        super(element);\n        resourceElements.addAll(UtilXml.childElementList(element, \"resource\"));\n    }","commit_id":"88cd1720d73f8be19651731cdff29890aad3a5fe","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override\n  public <T> T execute(String user, final Configuration conf, final FileSystemExecutor<T> executor)\n    throws FileSystemAccessException {\n    Check.notEmpty(user, \"user\");\n    Check.notNull(conf, \"conf\");\n    Check.notNull(executor, \"executor\");\n    if (conf.get(NAME_NODE_PROPERTY) == null || conf.getTrimmed(NAME_NODE_PROPERTY).length() == 0) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H06, NAME_NODE_PROPERTY);\n    }\n    try {\n      validateNamenode(new URI(conf.get(NAME_NODE_PROPERTY)).getAuthority());\n      UserGroupInformation ugi = getUGI(user);\n      return ugi.doAs(new PrivilegedExceptionAction<T>() {\n        public T run() throws Exception {\n          Configuration namenodeConf = createNameNodeConf(conf);\n          FileSystem fs = createFileSystem(namenodeConf);\n          Instrumentation instrumentation = getServer().get(Instrumentation.class);\n          Instrumentation.Cron cron = instrumentation.createCron();\n          try {\n            checkNameNodeHealth(fs);\n            cron.start();\n            return executor.execute(fs);\n          } finally {\n            cron.stop();\n            instrumentation.addCron(INSTRUMENTATION_GROUP, executor.getClass().getSimpleName(), cron);\n            closeFileSystem(fs);\n          }\n        }\n      });\n    } catch (FileSystemAccessException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H03, ex);\n    }\n  }","id":3738,"modified_method":"@Override\n  public <T> T execute(String user, final Configuration conf, final FileSystemExecutor<T> executor)\n    throws FileSystemAccessException {\n    Check.notEmpty(user, \"user\");\n    Check.notNull(conf, \"conf\");\n    Check.notNull(executor, \"executor\");\n    if (!conf.getBoolean(FILE_SYSTEM_SERVICE_CREATED, false)) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H04);\n    }\n    if (conf.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY) == null ||\n        conf.getTrimmed(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY).length() == 0) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H06,\n                                          CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY);\n    }\n    try {\n      validateNamenode(\n        new URI(conf.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY)).\n          getAuthority());\n      UserGroupInformation ugi = getUGI(user);\n      return ugi.doAs(new PrivilegedExceptionAction<T>() {\n        public T run() throws Exception {\n          FileSystem fs = createFileSystem(conf);\n          Instrumentation instrumentation = getServer().get(Instrumentation.class);\n          Instrumentation.Cron cron = instrumentation.createCron();\n          try {\n            checkNameNodeHealth(fs);\n            cron.start();\n            return executor.execute(fs);\n          } finally {\n            cron.stop();\n            instrumentation.addCron(INSTRUMENTATION_GROUP, executor.getClass().getSimpleName(), cron);\n            closeFileSystem(fs);\n          }\n        }\n      });\n    } catch (FileSystemAccessException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H03, ex);\n    }\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void init() throws ServiceException {\n    LOG.info(\"Using FileSystemAccess JARs version [{}]\", VersionInfo.getVersion());\n    String security = getServiceConfig().get(AUTHENTICATION_TYPE, \"simple\").trim();\n    if (security.equals(\"kerberos\")) {\n      String defaultName = getServer().getName();\n      String keytab = System.getProperty(\"user.home\") + \"/\" + defaultName + \".keytab\";\n      keytab = getServiceConfig().get(KERBEROS_KEYTAB, keytab).trim();\n      if (keytab.length() == 0) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H01, KERBEROS_KEYTAB);\n      }\n      String principal = defaultName + \"/localhost@LOCALHOST\";\n      principal = getServiceConfig().get(KERBEROS_PRINCIPAL, principal).trim();\n      if (principal.length() == 0) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H01, KERBEROS_PRINCIPAL);\n      }\n      Configuration conf = new Configuration();\n      conf.set(\"hadoop.security.authentication\", \"kerberos\");\n      UserGroupInformation.setConfiguration(conf);\n      try {\n        UserGroupInformation.loginUserFromKeytab(principal, keytab);\n      } catch (IOException ex) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H02, ex.getMessage(), ex);\n      }\n      LOG.info(\"Using FileSystemAccess Kerberos authentication, principal [{}] keytab [{}]\", principal, keytab);\n    } else if (security.equals(\"simple\")) {\n      Configuration conf = new Configuration();\n      conf.set(\"hadoop.security.authentication\", \"simple\");\n      UserGroupInformation.setConfiguration(conf);\n      LOG.info(\"Using FileSystemAccess simple/pseudo authentication, principal [{}]\", System.getProperty(\"user.name\"));\n    } else {\n      throw new ServiceException(FileSystemAccessException.ERROR.H09, security);\n    }\n\n    serviceHadoopConf = new Configuration(false);\n    for (Map.Entry entry : getServiceConfig()) {\n      String name = (String) entry.getKey();\n      if (name.startsWith(HADOOP_CONF_PREFIX)) {\n        name = name.substring(HADOOP_CONF_PREFIX.length());\n        String value = (String) entry.getValue();\n        serviceHadoopConf.set(name, value);\n\n      }\n    }\n    setRequiredServiceHadoopConf(serviceHadoopConf);\n\n    LOG.debug(\"FileSystemAccess default configuration:\");\n    for (Map.Entry entry : serviceHadoopConf) {\n      LOG.debug(\"  {} = {}\", entry.getKey(), entry.getValue());\n    }\n\n    nameNodeWhitelist = toLowerCase(getServiceConfig().getTrimmedStringCollection(NAME_NODE_WHITELIST));\n  }","id":3739,"modified_method":"@Override\n  protected void init() throws ServiceException {\n    LOG.info(\"Using FileSystemAccess JARs version [{}]\", VersionInfo.getVersion());\n    String security = getServiceConfig().get(AUTHENTICATION_TYPE, \"simple\").trim();\n    if (security.equals(\"kerberos\")) {\n      String defaultName = getServer().getName();\n      String keytab = System.getProperty(\"user.home\") + \"/\" + defaultName + \".keytab\";\n      keytab = getServiceConfig().get(KERBEROS_KEYTAB, keytab).trim();\n      if (keytab.length() == 0) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H01, KERBEROS_KEYTAB);\n      }\n      String principal = defaultName + \"/localhost@LOCALHOST\";\n      principal = getServiceConfig().get(KERBEROS_PRINCIPAL, principal).trim();\n      if (principal.length() == 0) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H01, KERBEROS_PRINCIPAL);\n      }\n      Configuration conf = new Configuration();\n      conf.set(\"hadoop.security.authentication\", \"kerberos\");\n      UserGroupInformation.setConfiguration(conf);\n      try {\n        UserGroupInformation.loginUserFromKeytab(principal, keytab);\n      } catch (IOException ex) {\n        throw new ServiceException(FileSystemAccessException.ERROR.H02, ex.getMessage(), ex);\n      }\n      LOG.info(\"Using FileSystemAccess Kerberos authentication, principal [{}] keytab [{}]\", principal, keytab);\n    } else if (security.equals(\"simple\")) {\n      Configuration conf = new Configuration();\n      conf.set(\"hadoop.security.authentication\", \"simple\");\n      UserGroupInformation.setConfiguration(conf);\n      LOG.info(\"Using FileSystemAccess simple/pseudo authentication, principal [{}]\", System.getProperty(\"user.name\"));\n    } else {\n      throw new ServiceException(FileSystemAccessException.ERROR.H09, security);\n    }\n\n    String hadoopConfDirProp = getServiceConfig().get(HADOOP_CONF_DIR, getServer().getConfigDir());\n    File hadoopConfDir = new File(hadoopConfDirProp).getAbsoluteFile();\n    if (hadoopConfDir == null) {\n      hadoopConfDir = new File(getServer().getConfigDir()).getAbsoluteFile();\n    }\n    if (!hadoopConfDir.exists()) {\n      throw new ServiceException(FileSystemAccessException.ERROR.H10, hadoopConfDir);\n    }\n    try {\n      serviceHadoopConf = loadHadoopConf(hadoopConfDir);\n    } catch (IOException ex) {\n      throw new ServiceException(FileSystemAccessException.ERROR.H11, ex.toString(), ex);\n    }\n\n    LOG.debug(\"FileSystemAccess FileSystem configuration:\");\n    for (Map.Entry entry : serviceHadoopConf) {\n      LOG.debug(\"  {} = {}\", entry.getKey(), entry.getValue());\n    }\n    setRequiredServiceHadoopConf(serviceHadoopConf);\n\n    nameNodeWhitelist = toLowerCase(getServiceConfig().getTrimmedStringCollection(NAME_NODE_WHITELIST));\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public Configuration getDefaultConfiguration() {\n    Configuration conf = new Configuration(false);\n    ConfigurationUtils.copy(serviceHadoopConf, conf);\n    return conf;\n  }","id":3740,"modified_method":"@Override\n  public Configuration getFileSystemConfiguration() {\n    Configuration conf = new Configuration(true);\n    ConfigurationUtils.copy(serviceHadoopConf, conf);\n    conf.setBoolean(FILE_SYSTEM_SERVICE_CREATED, true);\n    return conf;\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"public FileSystem createFileSystemInternal(String user, final Configuration conf)\n    throws IOException, FileSystemAccessException {\n    Check.notEmpty(user, \"user\");\n    Check.notNull(conf, \"conf\");\n    try {\n      validateNamenode(new URI(conf.get(NAME_NODE_PROPERTY)).getAuthority());\n      UserGroupInformation ugi = getUGI(user);\n      return ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {\n        public FileSystem run() throws Exception {\n          Configuration namenodeConf = createNameNodeConf(conf);\n          return createFileSystem(namenodeConf);\n        }\n      });\n    } catch (IOException ex) {\n      throw ex;\n    } catch (FileSystemAccessException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H08, ex.getMessage(), ex);\n    }\n  }","id":3741,"modified_method":"public FileSystem createFileSystemInternal(String user, final Configuration conf)\n    throws IOException, FileSystemAccessException {\n    Check.notEmpty(user, \"user\");\n    Check.notNull(conf, \"conf\");\n    if (!conf.getBoolean(FILE_SYSTEM_SERVICE_CREATED, false)) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H04);\n    }\n    try {\n      validateNamenode(\n        new URI(conf.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY)).getAuthority());\n      UserGroupInformation ugi = getUGI(user);\n      return ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {\n        public FileSystem run() throws Exception {\n          return createFileSystem(conf);\n        }\n      });\n    } catch (IOException ex) {\n      throw ex;\n    } catch (FileSystemAccessException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new FileSystemAccessException(FileSystemAccessException.ERROR.H08, ex.getMessage(), ex);\n    }\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Returns the groups a FileSystemAccess user belongs to during tests. These users/groups\n   * are defined in the <code>test.properties<\/code> file in properties of the\n   * form <code>test.hadoop.user.#USER#=#GROUP1#,#GROUP2#,...<\/code>.\n   * <p/>\n   * These properties are used to configure the FileSystemAccess minicluster user/group\n   * information.\n   * <p/>\n   * When using an external FileSystemAccess cluster these properties should match the\n   * user/groups settings in the cluster.\n   *\n   * @param user user name to get gropus.\n   *\n   * @return the groups of FileSystemAccess users used for testing.\n   */\n  public static String[] getHadoopUserGroups(String user) {\n    if (getHadoopUsers() == DEFAULT_USERS) {\n      return DEFAULT_USERS_GROUP;\n    } else {\n      String groups = System.getProperty(HADOOP_USER_PREFIX + user);\n      return (groups != null) ? groups.split(\",\") : new String[0];\n    }\n  }","id":3742,"modified_method":"/**\n   * Returns the groups a FileSystemAccess user belongs to during tests. These users/groups\n   * are defined in the <code>test.properties<\/code> file in properties of the\n   * form <code>test.hadoop.user.#USER#=#GROUP1#,#GROUP2#,...<\/code>.\n   * <p/>\n   * These properties are used to configure the FileSystemAccess minicluster user/group\n   * information.\n   * <p/>\n   * When using an external FileSystemAccess cluster these properties should match the\n   * user/groups settings in the cluster.\n   *\n   * @param user user name to get gropus.\n   *\n   * @return the groups of FileSystemAccess users used for testing.\n   */\n  public static String[] getHadoopUserGroups(String user) {\n    if (getHadoopUsers() == DEFAULT_USERS) {\n      for (String defaultUser : DEFAULT_USERS) {\n        if (defaultUser.equals(user)) {\n          return DEFAULT_USERS_GROUP;\n        }\n      }\n      return new String[0];\n    } else {\n      String groups = System.getProperty(HADOOP_USER_PREFIX + user);\n      return (groups != null) ? groups.split(\",\") : new String[0];\n    }\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Returns a filesystem instance. The fileystem instance is wired for release at the completion of\n   * the current Servlet request via the {@link FileSystemReleaseFilter}.\n   * <p/>\n   * If a do-as user is specified, the current user must be a valid proxyuser, otherwise an\n   * <code>AccessControlException<\/code> will be thrown.\n   *\n   * @param user principal for whom the filesystem instance is.\n   * @param doAs do-as user, if any.\n   *\n   * @return a filesystem for the specified user or do-as user.\n   *\n   * @throws IOException thrown if an IO error occurred. Thrown exceptions are\n   * handled by {@link HttpFSExceptionProvider}.\n   * @throws FileSystemAccessException thrown if a FileSystemAccess releated error occurred. Thrown\n   * exceptions are handled by {@link HttpFSExceptionProvider}.\n   */\n  private FileSystem createFileSystem(Principal user, String doAs) throws IOException, FileSystemAccessException {\n    String hadoopUser = getEffectiveUser(user, doAs);\n    FileSystemAccess fsAccess = HttpFSServerWebApp.get().get(FileSystemAccess.class);\n    Configuration conf = HttpFSServerWebApp.get().get(FileSystemAccess.class).getDefaultConfiguration();\n    FileSystem fs = fsAccess.createFileSystem(hadoopUser, conf);\n    FileSystemReleaseFilter.setFileSystem(fs);\n    return fs;\n  }","id":3743,"modified_method":"/**\n   * Returns a filesystem instance. The fileystem instance is wired for release at the completion of\n   * the current Servlet request via the {@link FileSystemReleaseFilter}.\n   * <p/>\n   * If a do-as user is specified, the current user must be a valid proxyuser, otherwise an\n   * <code>AccessControlException<\/code> will be thrown.\n   *\n   * @param user principal for whom the filesystem instance is.\n   * @param doAs do-as user, if any.\n   *\n   * @return a filesystem for the specified user or do-as user.\n   *\n   * @throws IOException thrown if an IO error occurred. Thrown exceptions are\n   * handled by {@link HttpFSExceptionProvider}.\n   * @throws FileSystemAccessException thrown if a FileSystemAccess releated error occurred. Thrown\n   * exceptions are handled by {@link HttpFSExceptionProvider}.\n   */\n  private FileSystem createFileSystem(Principal user, String doAs) throws IOException, FileSystemAccessException {\n    String hadoopUser = getEffectiveUser(user, doAs);\n    FileSystemAccess fsAccess = HttpFSServerWebApp.get().get(FileSystemAccess.class);\n    Configuration conf = HttpFSServerWebApp.get().get(FileSystemAccess.class).getFileSystemConfiguration();\n    FileSystem fs = fsAccess.createFileSystem(hadoopUser, conf);\n    FileSystemReleaseFilter.setFileSystem(fs);\n    return fs;\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Executes a {@link FileSystemAccess.FileSystemExecutor} using a filesystem for the effective\n   * user.\n   *\n   * @param user principal making the request.\n   * @param doAs do-as user, if any.\n   * @param executor FileSystemExecutor to execute.\n   *\n   * @return FileSystemExecutor response\n   *\n   * @throws IOException thrown if an IO error occurrs.\n   * @throws FileSystemAccessException thrown if a FileSystemAccess releated error occurred. Thrown\n   * exceptions are handled by {@link HttpFSExceptionProvider}.\n   */\n  private <T> T fsExecute(Principal user, String doAs, FileSystemAccess.FileSystemExecutor<T> executor)\n    throws IOException, FileSystemAccessException {\n    String hadoopUser = getEffectiveUser(user, doAs);\n    FileSystemAccess fsAccess = HttpFSServerWebApp.get().get(FileSystemAccess.class);\n    Configuration conf = HttpFSServerWebApp.get().get(FileSystemAccess.class).getDefaultConfiguration();\n    return fsAccess.execute(hadoopUser, conf, executor);\n  }","id":3744,"modified_method":"/**\n   * Executes a {@link FileSystemAccess.FileSystemExecutor} using a filesystem for the effective\n   * user.\n   *\n   * @param user principal making the request.\n   * @param doAs do-as user, if any.\n   * @param executor FileSystemExecutor to execute.\n   *\n   * @return FileSystemExecutor response\n   *\n   * @throws IOException thrown if an IO error occurrs.\n   * @throws FileSystemAccessException thrown if a FileSystemAccess releated error occurred. Thrown\n   * exceptions are handled by {@link HttpFSExceptionProvider}.\n   */\n  private <T> T fsExecute(Principal user, String doAs, FileSystemAccess.FileSystemExecutor<T> executor)\n    throws IOException, FileSystemAccessException {\n    String hadoopUser = getEffectiveUser(user, doAs);\n    FileSystemAccess fsAccess = HttpFSServerWebApp.get().get(FileSystemAccess.class);\n    Configuration conf = HttpFSServerWebApp.get().get(FileSystemAccess.class).getFileSystemConfiguration();\n    return fsAccess.execute(hadoopUser, conf, executor);\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Initializes the HttpFSServer server, loads configuration and required services.\n   *\n   * @throws ServerException thrown if HttpFSServer server could not be initialized.\n   */\n  @Override\n  public void init() throws ServerException {\n    super.init();\n    if (SERVER != null) {\n      throw new RuntimeException(\"HttpFSServer server already initialized\");\n    }\n    SERVER = this;\n    adminGroup = getConfig().get(getPrefixedName(CONF_ADMIN_GROUP), \"admin\");\n    LOG.info(\"Connects to Namenode [{}]\",\n             get().get(FileSystemAccess.class).getDefaultConfiguration().get(\"fs.default.name\"));\n  }","id":3745,"modified_method":"/**\n   * Initializes the HttpFSServer server, loads configuration and required\n   * services.\n   *\n   * @throws ServerException thrown if HttpFSServer server could not be\n   * initialized.\n   */\n  @Override\n  public void init() throws ServerException {\n    super.init();\n    if (SERVER != null) {\n      throw new RuntimeException(\"HttpFSServer server already initialized\");\n    }\n    SERVER = this;\n    adminGroup = getConfig().get(getPrefixedName(CONF_ADMIN_GROUP), \"admin\");\n    LOG.info(\"Connects to Namenode [{}]\",\n             get().get(FileSystemAccess.class).getFileSystemConfiguration().\n               get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  public void serviceHadoopConf() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    conf.set(\"server.hadoop.conf:foo\", \"FOO\");\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccessService fsAccess = (FileSystemAccessService) server.get(FileSystemAccess.class);\n    Assert.assertEquals(fsAccess.serviceHadoopConf.get(\"foo\"), \"FOO\");\n    server.destroy();\n  }","id":3746,"modified_method":"@Test\n  @TestDir\n  public void serviceHadoopConf() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccessService fsAccess = (FileSystemAccessService) server.get(FileSystemAccess.class);\n    Assert.assertEquals(fsAccess.serviceHadoopConf.get(\"foo\"), \"FOO\");\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorException() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n    try {\n      hadoop.execute(\"u\", TestHdfsHelper.getHdfsConf(), new FileSystemAccess.FileSystemExecutor<Void>() {\n        @Override\n        public Void execute(FileSystem fs) throws IOException {\n          fsa[0] = fs;\n          throw new IOException();\n        }\n      });\n      Assert.fail();\n    } catch (FileSystemAccessException ex) {\n      Assert.assertEquals(ex.getError(), FileSystemAccessException.ERROR.H03);\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":3747,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorException() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n    try {\n      hadoop.execute(\"u\", hadoop.getFileSystemConfiguration(), new FileSystemAccess.FileSystemExecutor<Void>() {\n        @Override\n        public Void execute(FileSystem fs) throws IOException {\n          fsa[0] = fs;\n          throw new IOException();\n        }\n      });\n      Assert.fail();\n    } catch (FileSystemAccessException ex) {\n      Assert.assertEquals(ex.getError(), FileSystemAccessException.ERROR.H03);\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void createFileSystem() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n    FileSystem fs = hadoop.createFileSystem(\"u\", TestHdfsHelper.getHdfsConf());\n    Assert.assertNotNull(fs);\n    fs.mkdirs(new Path(\"/tmp/foo\"));\n    hadoop.releaseFileSystem(fs);\n    try {\n      fs.mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":3748,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void createFileSystem() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n    FileSystem fs = hadoop.createFileSystem(\"u\", hadoop.getFileSystemConfiguration());\n    Assert.assertNotNull(fs);\n    fs.mkdirs(new Path(\"/tmp/foo\"));\n    hadoop.releaseFileSystem(fs);\n    try {\n      fs.mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutor() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n\n    hadoop.execute(\"u\", TestHdfsHelper.getHdfsConf(), new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        fs.mkdirs(new Path(\"/tmp/foo\"));\n        fsa[0] = fs;\n        return null;\n      }\n    });\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":3749,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutor() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n\n    hadoop.execute(\"u\", hadoop.getFileSystemConfiguration(), new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        fs.mkdirs(new Path(\"/tmp/foo\"));\n        fsa[0] = fs;\n        return null;\n      }\n    });\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestException(exception = FileSystemAccessException.class, msgRegExp = \"H06.*\")\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorNoNameNode() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess fsAccess = server.get(FileSystemAccess.class);\n\n    Configuration hdfsConf = TestHdfsHelper.getHdfsConf();\n    hdfsConf.set(\"fs.default.name\", \"\");\n    fsAccess.execute(\"u\", hdfsConf, new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        return null;\n      }\n    });\n  }","id":3750,"modified_method":"@Test\n  @TestException(exception = FileSystemAccessException.class, msgRegExp = \"H06.*\")\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorNoNameNode() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess fsAccess = server.get(FileSystemAccess.class);\n\n    Configuration hdfsConf = fsAccess.getFileSystemConfiguration();\n    hdfsConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, \"\");\n    fsAccess.execute(\"u\", hdfsConf, new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        return null;\n      }\n    });\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"private void createHttpFSServer() throws Exception {\n    File homeDir = TestDirHelper.getTestDir();\n    Assert.assertTrue(new File(homeDir, \"conf\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"log\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"temp\").mkdir());\n    HttpFSServerWebApp.setHomeDirForCurrentThread(homeDir.getAbsolutePath());\n\n    File secretFile = new File(new File(homeDir, \"conf\"), \"secret\");\n    Writer w = new FileWriter(secretFile);\n    w.write(\"secret\");\n    w.close();\n\n    String fsDefaultName = TestHdfsHelper.getHdfsConf().get(\"fs.default.name\");\n    Configuration conf = new Configuration(false);\n    conf.set(\"httpfs.hadoop.conf:fs.default.name\", fsDefaultName);\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".groups\", HadoopUsersConfTestHelper\n      .getHadoopProxyUserGroups());\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".hosts\", HadoopUsersConfTestHelper\n      .getHadoopProxyUserHosts());\n    conf.set(\"httpfs.authentication.signature.secret.file\", secretFile.getAbsolutePath());\n    File hoopSite = new File(new File(homeDir, \"conf\"), \"httpfs-site.xml\");\n    OutputStream os = new FileOutputStream(hoopSite);\n    conf.writeXml(os);\n    os.close();\n\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    URL url = cl.getResource(\"webapp\");\n    WebAppContext context = new WebAppContext(url.getPath(), \"/webhdfs\");\n    Server server = TestJettyHelper.getJettyServer();\n    server.addHandler(context);\n    server.start();\n  }","id":3751,"modified_method":"private void createHttpFSServer() throws Exception {\n    File homeDir = TestDirHelper.getTestDir();\n    Assert.assertTrue(new File(homeDir, \"conf\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"log\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"temp\").mkdir());\n    HttpFSServerWebApp.setHomeDirForCurrentThread(homeDir.getAbsolutePath());\n\n    File secretFile = new File(new File(homeDir, \"conf\"), \"secret\");\n    Writer w = new FileWriter(secretFile);\n    w.write(\"secret\");\n    w.close();\n\n    //HDFS configuration\n    String fsDefaultName = TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY);\n    Configuration conf = new Configuration(false);\n    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, fsDefaultName);\n    File hdfsSite = new File(new File(homeDir, \"conf\"), \"hdfs-site.xml\");\n    OutputStream os = new FileOutputStream(hdfsSite);\n    conf.writeXml(os);\n    os.close();\n\n    //HTTPFS configuration\n    conf = new Configuration(false);\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".groups\",\n             HadoopUsersConfTestHelper.getHadoopProxyUserGroups());\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".hosts\",\n             HadoopUsersConfTestHelper.getHadoopProxyUserHosts());\n    conf.set(\"httpfs.authentication.signature.secret.file\", secretFile.getAbsolutePath());\n    File httpfsSite = new File(new File(homeDir, \"conf\"), \"httpfs-site.xml\");\n    os = new FileOutputStream(httpfsSite);\n    conf.writeXml(os);\n    os.close();\n\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    URL url = cl.getResource(\"webapp\");\n    WebAppContext context = new WebAppContext(url.getPath(), \"/webhdfs\");\n    Server server = TestJettyHelper.getJettyServer();\n    server.addHandler(context);\n    server.start();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestJetty\n  @TestHdfs\n  public void instrumentation() throws Exception {\n    createHttpFSServer();\n\n    URL url = new URL(TestJettyHelper.getJettyURL(),\n                      MessageFormat.format(\"/webhdfs/v1?user.name={0}&op=instrumentation\", \"nobody\"));\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_UNAUTHORIZED);\n\n    url = new URL(TestJettyHelper.getJettyURL(),\n                  MessageFormat.format(\"/webhdfs/v1?user.name={0}&op=instrumentation\", \"root\"));\n    conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_OK);\n    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n    String line = reader.readLine();\n    reader.close();\n    Assert.assertTrue(line.contains(\"\\\"counters\\\":{\"));\n\n    url = new URL(TestJettyHelper.getJettyURL(),\n                  MessageFormat.format(\"/webhdfs/v1/foo?user.name={0}&op=instrumentation\", \"root\"));\n    conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_BAD_REQUEST);\n  }","id":3752,"modified_method":"@Test\n  @TestDir\n  @TestJetty\n  @TestHdfs\n  public void instrumentation() throws Exception {\n    createHttpFSServer();\n\n    URL url = new URL(TestJettyHelper.getJettyURL(),\n                      MessageFormat.format(\"/webhdfs/v1?user.name={0}&op=instrumentation\", \"nobody\"));\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_UNAUTHORIZED);\n\n    url = new URL(TestJettyHelper.getJettyURL(),\n                  MessageFormat.format(\"/webhdfs/v1?user.name={0}&op=instrumentation\",\n                                       HadoopUsersConfTestHelper.getHadoopUsers()[0]));\n    conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_OK);\n    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n    String line = reader.readLine();\n    reader.close();\n    Assert.assertTrue(line.contains(\"\\\"counters\\\":{\"));\n\n    url = new URL(TestJettyHelper.getJettyURL(),\n                  MessageFormat.format(\"/webhdfs/v1/foo?user.name={0}&op=instrumentation\",\n                                       HadoopUsersConfTestHelper.getHadoopUsers()[0]));\n    conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(conn.getResponseCode(), HttpURLConnection.HTTP_BAD_REQUEST);\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestJetty\n  public void server() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    Configuration hoopConf = new Configuration(false);\n    HttpFSServerWebApp server = new HttpFSServerWebApp(dir, dir, dir, dir, hoopConf);\n    server.init();\n    server.destroy();\n  }","id":3753,"modified_method":"@Test\n  @TestDir\n  @TestJetty\n  public void server() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n\n    Configuration httpfsConf = new Configuration(false);\n    HttpFSServerWebApp server = new HttpFSServerWebApp(dir, dir, dir, dir, httpfsConf);\n    server.init();\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"private void createHttpFSServer() throws Exception {\n    File homeDir = TestDirHelper.getTestDir();\n    Assert.assertTrue(new File(homeDir, \"conf\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"log\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"temp\").mkdir());\n    HttpFSServerWebApp.setHomeDirForCurrentThread(homeDir.getAbsolutePath());\n\n    File secretFile = new File(new File(homeDir, \"conf\"), \"secret\");\n    Writer w = new FileWriter(secretFile);\n    w.write(\"secret\");\n    w.close();\n\n    String fsDefaultName = TestHdfsHelper.getHdfsConf().get(\"fs.default.name\");\n    Configuration conf = new Configuration(false);\n    conf.set(\"httpfs.hadoop.conf:fs.default.name\", fsDefaultName);\n    conf.set(\"httpfs.groups.\" + CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING, DummyGroupMapping.class.getName());\n    conf.set(\"httpfs.authentication.signature.secret.file\", secretFile.getAbsolutePath());\n    File hoopSite = new File(new File(homeDir, \"conf\"), \"httpfs-site.xml\");\n    OutputStream os = new FileOutputStream(hoopSite);\n    conf.writeXml(os);\n    os.close();\n\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    URL url = cl.getResource(\"webapp\");\n    WebAppContext context = new WebAppContext(url.getPath(), \"/webhdfs\");\n    Server server = TestJettyHelper.getJettyServer();\n    server.addHandler(context);\n    server.start();\n  }","id":3754,"modified_method":"private void createHttpFSServer() throws Exception {\n    File homeDir = TestDirHelper.getTestDir();\n    Assert.assertTrue(new File(homeDir, \"conf\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"log\").mkdir());\n    Assert.assertTrue(new File(homeDir, \"temp\").mkdir());\n    HttpFSServerWebApp.setHomeDirForCurrentThread(homeDir.getAbsolutePath());\n\n    File secretFile = new File(new File(homeDir, \"conf\"), \"secret\");\n    Writer w = new FileWriter(secretFile);\n    w.write(\"secret\");\n    w.close();\n\n    //HDFS configuration\n    File hadoopConfDir = new File(new File(homeDir, \"conf\"), \"hadoop-conf\");\n    hadoopConfDir.mkdirs();\n    String fsDefaultName = TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY);\n    Configuration conf = new Configuration(false);\n    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, fsDefaultName);\n    File hdfsSite = new File(hadoopConfDir, \"hdfs-site.xml\");\n    OutputStream os = new FileOutputStream(hdfsSite);\n    conf.writeXml(os);\n    os.close();\n\n    //HTTPFS configuration\n    conf = new Configuration(false);\n    conf.set(\"httpfs.services.ext\", MockGroups.class.getName());\n    conf.set(\"httpfs.admin.group\", HadoopUsersConfTestHelper.\n      getHadoopUserGroups(HadoopUsersConfTestHelper.getHadoopUsers()[0])[0]);\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".groups\",\n             HadoopUsersConfTestHelper.getHadoopProxyUserGroups());\n    conf.set(\"httpfs.proxyuser.\" + HadoopUsersConfTestHelper.getHadoopProxyUser() + \".hosts\",\n             HadoopUsersConfTestHelper.getHadoopProxyUserHosts());\n    conf.set(\"httpfs.authentication.signature.secret.file\", secretFile.getAbsolutePath());\n    File httpfsSite = new File(new File(homeDir, \"conf\"), \"httpfs-site.xml\");\n    os = new FileOutputStream(httpfsSite);\n    conf.writeXml(os);\n    os.close();\n\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    URL url = cl.getResource(\"webapp\");\n    WebAppContext context = new WebAppContext(url.getPath(), \"/webhdfs\");\n    Server server = TestJettyHelper.getJettyServer();\n    server.addHandler(context);\n    server.start();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"protected void unscheduleStaging(Group group) {\n\t\ttry {\n\n\t\t\t// Remote publishing\n\n\t\t\tString groupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_REMOTE_PUBLISHER, group.getGroupId());\n\n\t\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\t\tSchedulerEngineUtil.getScheduledJobs(groupName);\n\n\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\tschedulerRequest.getJobName(),\n\t\t\t\t\tschedulerRequest.getGroupName());\n\t\t\t}\n\n\t\t\tlong liveGroupId = 0;\n\t\t\tlong stagingGroupId = 0;\n\n\t\t\tif (group.isStagingGroup()) {\n\t\t\t\tliveGroupId = group.getLiveGroupId();\n\n\t\t\t\tstagingGroupId = group.getGroupId();\n\t\t\t}\n\t\t\telse if (group.hasStagingGroup()) {\n\t\t\t\tliveGroupId = group.getGroupId();\n\n\t\t\t\tstagingGroupId = group.getStagingGroup().getGroupId();\n\t\t\t}\n\n\t\t\tif ((liveGroupId != 0) && (stagingGroupId != 0)) {\n\n\t\t\t\t// Publish to live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, liveGroupId);\n\n\t\t\t\tschedulerRequests = SchedulerEngineUtil.getScheduledJobs(\n\t\t\t\t\tgroupName);\n\n\t\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t\t\t}\n\n\t\t\t\t// Copy from live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, stagingGroupId);\n\n\t\t\t\tschedulerRequests = SchedulerEngineUtil.getScheduledJobs(\n\t\t\t\t\tgroupName);\n\n\t\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to unschedule events for group: \" + group.getGroupId());\n\t\t}\n\t}","id":3755,"modified_method":"protected void unscheduleStaging(Group group) {\n\t\ttry {\n\n\t\t\t// Remote publishing\n\n\t\t\tString groupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_REMOTE_PUBLISHER, group.getGroupId());\n\n\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\n\t\t\tlong liveGroupId = 0;\n\t\t\tlong stagingGroupId = 0;\n\n\t\t\tif (group.isStagingGroup()) {\n\t\t\t\tliveGroupId = group.getLiveGroupId();\n\n\t\t\t\tstagingGroupId = group.getGroupId();\n\t\t\t}\n\t\t\telse if (group.hasStagingGroup()) {\n\t\t\t\tliveGroupId = group.getGroupId();\n\n\t\t\t\tstagingGroupId = group.getStagingGroup().getGroupId();\n\t\t\t}\n\n\t\t\tif ((liveGroupId != 0) && (stagingGroupId != 0)) {\n\n\t\t\t\t// Publish to live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, liveGroupId);\n\n\t\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\n\t\t\t\t// Copy from live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, stagingGroupId);\n\n\t\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to unschedule events for group: \" + group.getGroupId());\n\t\t}\n\t}","commit_id":"e65ace830f7bab19e1880a60afaa01a2c225ba23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void unscheduleMailingList(MBMailingList mailingList)\n\t\tthrows PortalException {\n\n\t\tString groupName = getSchedulerGroupName(mailingList);\n\n\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\tSchedulerEngineUtil.getScheduledJobs(groupName);\n\n\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t}\n\t}","id":3756,"modified_method":"protected void unscheduleMailingList(MBMailingList mailingList)\n\t\tthrows PortalException {\n\n\t\tString groupName = getSchedulerGroupName(mailingList);\n\n\t\tSchedulerEngineUtil.unschedule(groupName);\n\t}","commit_id":"e65ace830f7bab19e1880a60afaa01a2c225ba23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":3757,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"4d2da8266cbbbc45dcb232eff4dbf3ec91f13d19","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n    }\n  }","id":3758,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","commit_id":"4d2da8266cbbbc45dcb232eff4dbf3ec91f13d19","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          int newIndex = index2Item.size();\n          item2Index.put(o, newIndex);\n          index2Item.put(newIndex, o);\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","id":3759,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","commit_id":"4d2da8266cbbbc45dcb232eff4dbf3ec91f13d19","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":3760,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"a5a24db34233df15a8e128a9636cec4eaabcdbad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          int newIndex = index2Item.size();\n          item2Index.put(o, newIndex);\n          index2Item.put(newIndex, o);\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","id":3761,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","commit_id":"a5a24db34233df15a8e128a9636cec4eaabcdbad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n    }\n  }","id":3762,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","commit_id":"a5a24db34233df15a8e128a9636cec4eaabcdbad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * default number of fragments of 5.\n     *\n     * @param name         The field to highlight\n     * @param fragmentSize The size of a fragment in characters\n     */\n    public HighlightBuilder field(String name, int fragmentSize) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize));\n        return this;\n    }","id":3763,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * default number of fragments of 5.\n     *\n     * @param name         The field to highlight\n     * @param fragmentSize The size of a fragment in characters\n     */\n    public HighlightBuilder field(String name, int fragmentSize) {\n        return field(new Field(name).fragmentSize(fragmentSize));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public HighlightBuilder field(Field field) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(field);\n        return this;\n    }","id":3764,"modified_method":"public HighlightBuilder field(Field field) {\n        fields.add(field);\n        return this;\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Set a tag scheme that encapsulates a built in pre and post tags. The allows schemes\n     * are <tt>styled<\/tt> and <tt>default<\/tt>.\n     *\n     * @param schemaName The tag scheme name\n     */\n    public HighlightBuilder tagsSchema(String schemaName) {\n        this.tagsSchema = schemaName;\n        return this;\n    }","id":3765,"modified_method":"/**\n     * Set a tag scheme that encapsulates a built in pre and post tags. The allowed schemes\n     * are <tt>styled<\/tt> and <tt>default<\/tt>.\n     *\n     * @param schemaName The tag scheme name\n     */\n    public HighlightBuilder tagsSchema(String schemaName) {\n        switch (schemaName) {\n        case \"default\":\n            preTags(HighlighterParseElement.DEFAULT_PRE_TAGS);\n            postTags(HighlighterParseElement.DEFAULT_POST_TAGS);\n            break;\n        case \"styled\":\n            preTags(HighlighterParseElement.STYLED_PRE_TAG);\n            postTags(HighlighterParseElement.STYLED_POST_TAGS);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown tag schema [\"+ schemaName +\"]\");\n        }\n        return this;\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(\"highlight\");\n        innerXContent(builder, params);\n        builder.endObject();\n        return builder;\n    }","id":3766,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(\"highlight\");\n        innerXContent(builder);\n        builder.endObject();\n        return builder;\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void innerXContent(XContentBuilder builder, Params params) throws IOException {\n        if (tagsSchema != null) {\n            builder.field(\"tags_schema\", tagsSchema);\n        }\n        if (preTags != null) {\n            builder.array(\"pre_tags\", preTags);\n        }\n        if (postTags != null) {\n            builder.array(\"post_tags\", postTags);\n        }\n        if (order != null) {\n            builder.field(\"order\", order);\n        }\n        if (highlightFilter != null) {\n            builder.field(\"highlight_filter\", highlightFilter);\n        }\n        if (fragmentSize != null) {\n            builder.field(\"fragment_size\", fragmentSize);\n        }\n        if (numOfFragments != null) {\n            builder.field(\"number_of_fragments\", numOfFragments);\n        }\n        if (encoder != null) {\n            builder.field(\"encoder\", encoder);\n        }\n        if (requireFieldMatch != null) {\n            builder.field(\"require_field_match\", requireFieldMatch);\n        }\n        if (boundaryMaxScan != null) {\n            builder.field(\"boundary_max_scan\", boundaryMaxScan);\n        }\n        if (boundaryChars != null) {\n            builder.field(\"boundary_chars\", boundaryChars);\n        }\n        if (highlighterType != null) {\n            builder.field(\"type\", highlighterType);\n        }\n        if (fragmenter != null) {\n            builder.field(\"fragmenter\", fragmenter);\n        }\n        if (highlightQuery != null) {\n            builder.field(\"highlight_query\", highlightQuery);\n        }\n        if (noMatchSize != null) {\n            builder.field(\"no_match_size\", noMatchSize);\n        }\n        if (phraseLimit != null) {\n            builder.field(\"phrase_limit\", phraseLimit);\n        }\n        if (options != null && options.size() > 0) {\n            builder.field(\"options\", options);\n        }\n        if (forceSource != null) {\n            builder.field(\"force_source\", forceSource);\n        }\n        if (fields != null) {\n            if (useExplicitFieldOrder) {\n                builder.startArray(\"fields\");\n            } else {\n                builder.startObject(\"fields\");\n            }\n            for (Field field : fields) {\n                if (useExplicitFieldOrder) {\n                    builder.startObject();\n                }\n                builder.startObject(field.name());\n                if (field.preTags != null) {\n                    builder.field(\"pre_tags\", field.preTags);\n                }\n                if (field.postTags != null) {\n                    builder.field(\"post_tags\", field.postTags);\n                }\n                if (field.fragmentSize != -1) {\n                    builder.field(\"fragment_size\", field.fragmentSize);\n                }\n                if (field.numOfFragments != -1) {\n                    builder.field(\"number_of_fragments\", field.numOfFragments);\n                }\n                if (field.fragmentOffset != -1) {\n                    builder.field(\"fragment_offset\", field.fragmentOffset);\n                }\n                if (field.highlightFilter != null) {\n                    builder.field(\"highlight_filter\", field.highlightFilter);\n                }\n                if (field.order != null) {\n                    builder.field(\"order\", field.order);\n                }\n                if (field.requireFieldMatch != null) {\n                    builder.field(\"require_field_match\", field.requireFieldMatch);\n                }\n                if (field.boundaryMaxScan != -1) {\n                    builder.field(\"boundary_max_scan\", field.boundaryMaxScan);\n                }\n                if (field.boundaryChars != null) {\n                    builder.field(\"boundary_chars\", field.boundaryChars);\n                }\n                if (field.highlighterType != null) {\n                    builder.field(\"type\", field.highlighterType);\n                }\n                if (field.fragmenter != null) {\n                    builder.field(\"fragmenter\", field.fragmenter);\n                }\n                if (field.highlightQuery != null) {\n                    builder.field(\"highlight_query\", field.highlightQuery);\n                }\n                if (field.noMatchSize != null) {\n                    builder.field(\"no_match_size\", field.noMatchSize);\n                }\n                if (field.matchedFields != null) {\n                    builder.field(\"matched_fields\", field.matchedFields);\n                }\n                if (field.phraseLimit != null) {\n                    builder.field(\"phrase_limit\", field.phraseLimit);\n                }\n                if (field.options != null && field.options.size() > 0) {\n                    builder.field(\"options\", field.options);\n                }\n                if (field.forceSource != null) {\n                    builder.field(\"force_source\", field.forceSource);\n                }\n\n                builder.endObject();\n                if (useExplicitFieldOrder) {\n                    builder.endObject();\n                }\n            }\n            if (useExplicitFieldOrder) {\n                builder.endArray();\n            } else {\n                builder.endObject();\n            }\n        }\n    }","id":3767,"modified_method":"public void innerXContent(XContentBuilder builder) throws IOException {\n        // first write common options\n        commonOptionsToXContent(builder);\n        // special options for top-level highlighter\n        if (encoder != null) {\n            builder.field(\"encoder\", encoder);\n        }\n        if (fields.size() > 0) {\n            if (useExplicitFieldOrder) {\n                builder.startArray(\"fields\");\n            } else {\n                builder.startObject(\"fields\");\n            }\n            for (Field field : fields) {\n                if (useExplicitFieldOrder) {\n                    builder.startObject();\n                }\n                field.innerXContent(builder);\n                if (useExplicitFieldOrder) {\n                    builder.endObject();\n                }\n            }\n            if (useExplicitFieldOrder) {\n                builder.endArray();\n            } else {\n                builder.endObject();\n            }\n        }\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with default fragment size of 100 characters, and\n     * default number of fragments of 5 using the default encoder\n     *\n     * @param name The field to highlight\n     */\n    public HighlightBuilder field(String name) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name));\n        return this;\n    }","id":3768,"modified_method":"/**\n     * Adds a field to be highlighted with default fragment size of 100 characters, and\n     * default number of fragments of 5 using the default encoder\n     *\n     * @param name The field to highlight\n     */\n    public HighlightBuilder field(String name) {\n        return field(new Field(name));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments)\n                .fragmentOffset(fragmentOffset));\n        return this;\n    }","id":3769,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset) {\n        return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments)\n                .fragmentOffset(fragmentOffset));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments));\n        return this;\n    }","id":3770,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments) {\n        return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SearchContextHighlight parse(XContentParser parser, QueryShardContext queryShardContext) throws IOException {\n        XContentParser.Token token;\n        String topLevelFieldName = null;\n        final List<Tuple<String, SearchContextHighlight.FieldOptions.Builder>> fieldsOptions = new ArrayList<>();\n\n        final SearchContextHighlight.FieldOptions.Builder globalOptionsBuilder = new SearchContextHighlight.FieldOptions.Builder()\n                .preTags(DEFAULT_PRE_TAGS).postTags(DEFAULT_POST_TAGS).scoreOrdered(false).highlightFilter(false)\n                .requireFieldMatch(true).forceSource(false).fragmentCharSize(100).numberOfFragments(5)\n                .encoder(\"default\").boundaryMaxScan(SimpleBoundaryScanner.DEFAULT_MAX_SCAN)\n                .boundaryChars(SimpleBoundaryScanner.DEFAULT_BOUNDARY_CHARS)\n                .noMatchSize(0).phraseLimit(256);\n\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                topLevelFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                if (\"pre_tags\".equals(topLevelFieldName) || \"preTags\".equals(topLevelFieldName)) {\n                    List<String> preTagsList = new ArrayList<>();\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        preTagsList.add(parser.text());\n                    }\n                    globalOptionsBuilder.preTags(preTagsList.toArray(new String[preTagsList.size()]));\n                } else if (\"post_tags\".equals(topLevelFieldName) || \"postTags\".equals(topLevelFieldName)) {\n                    List<String> postTagsList = new ArrayList<>();\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        postTagsList.add(parser.text());\n                    }\n                    globalOptionsBuilder.postTags(postTagsList.toArray(new String[postTagsList.size()]));\n                } else if (\"fields\".equals(topLevelFieldName)) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        if (token == XContentParser.Token.START_OBJECT) {\n                            String highlightFieldName = null;\n                            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                                if (token == XContentParser.Token.FIELD_NAME) {\n                                    if (highlightFieldName != null) {\n                                        throw new IllegalArgumentException(\"If highlighter fields is an array it must contain objects containing a single field\");\n                                    }\n                                    highlightFieldName = parser.currentName();\n                                } else if (token == XContentParser.Token.START_OBJECT) {\n                                    fieldsOptions.add(Tuple.tuple(highlightFieldName, parseFields(parser, queryShardContext)));\n                                }\n                            }\n                        } else {\n                            throw new IllegalArgumentException(\"If highlighter fields is an array it must contain objects containing a single field\");\n                        }\n                    }\n                }\n            } else if (token.isValue()) {\n                if (\"order\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.scoreOrdered(\"score\".equals(parser.text()));\n                } else if (\"tags_schema\".equals(topLevelFieldName) || \"tagsSchema\".equals(topLevelFieldName)) {\n                    String schema = parser.text();\n                    if (\"styled\".equals(schema)) {\n                        globalOptionsBuilder.preTags(STYLED_PRE_TAG);\n                        globalOptionsBuilder.postTags(STYLED_POST_TAGS);\n                    }\n                } else if (\"highlight_filter\".equals(topLevelFieldName) || \"highlightFilter\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlightFilter(parser.booleanValue());\n                } else if (\"fragment_size\".equals(topLevelFieldName) || \"fragmentSize\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.fragmentCharSize(parser.intValue());\n                } else if (\"number_of_fragments\".equals(topLevelFieldName) || \"numberOfFragments\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.numberOfFragments(parser.intValue());\n                } else if (\"encoder\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.encoder(parser.text());\n                } else if (\"require_field_match\".equals(topLevelFieldName) || \"requireFieldMatch\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.requireFieldMatch(parser.booleanValue());\n                } else if (\"boundary_max_scan\".equals(topLevelFieldName) || \"boundaryMaxScan\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.boundaryMaxScan(parser.intValue());\n                } else if (\"boundary_chars\".equals(topLevelFieldName) || \"boundaryChars\".equals(topLevelFieldName)) {\n                    char[] charsArr = parser.text().toCharArray();\n                    Character[] globalBoundaryChars = new Character[charsArr.length];\n                    for (int i = 0; i < charsArr.length; i++) {\n                        globalBoundaryChars[i] = charsArr[i];\n                    }\n                    globalOptionsBuilder.boundaryChars(globalBoundaryChars);\n                } else if (\"type\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlighterType(parser.text());\n                } else if (\"fragmenter\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.fragmenter(parser.text());\n                } else if (\"no_match_size\".equals(topLevelFieldName) || \"noMatchSize\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.noMatchSize(parser.intValue());\n                } else if (\"force_source\".equals(topLevelFieldName) || \"forceSource\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.forceSource(parser.booleanValue());\n                } else if (\"phrase_limit\".equals(topLevelFieldName) || \"phraseLimit\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.phraseLimit(parser.intValue());\n                }\n            } else if (token == XContentParser.Token.START_OBJECT && \"options\".equals(topLevelFieldName)) {\n                globalOptionsBuilder.options(parser.map());\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"fields\".equals(topLevelFieldName)) {\n                    String highlightFieldName = null;\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                        if (token == XContentParser.Token.FIELD_NAME) {\n                            highlightFieldName = parser.currentName();\n                        } else if (token == XContentParser.Token.START_OBJECT) {\n                            fieldsOptions.add(Tuple.tuple(highlightFieldName, parseFields(parser, queryShardContext)));\n                        }\n                    }\n                } else if (\"highlight_query\".equals(topLevelFieldName) || \"highlightQuery\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlightQuery(queryShardContext.parse(parser).query());\n                }\n            }\n        }\n\n        final SearchContextHighlight.FieldOptions globalOptions = globalOptionsBuilder.build();\n        if (globalOptions.preTags() != null && globalOptions.postTags() == null) {\n            throw new IllegalArgumentException(\"Highlighter global preTags are set, but global postTags are not set\");\n        }\n\n        final List<SearchContextHighlight.Field> fields = new ArrayList<>();\n        // now, go over and fill all fieldsOptions with default values from the global state\n        for (final Tuple<String, SearchContextHighlight.FieldOptions.Builder> tuple : fieldsOptions) {\n            fields.add(new SearchContextHighlight.Field(tuple.v1(), tuple.v2().merge(globalOptions).build()));\n        }\n        return new SearchContextHighlight(fields);\n    }","id":3771,"modified_method":"public SearchContextHighlight parse(XContentParser parser, QueryShardContext queryShardContext) throws IOException {\n        XContentParser.Token token;\n        String topLevelFieldName = null;\n        final List<Tuple<String, SearchContextHighlight.FieldOptions.Builder>> fieldsOptions = new ArrayList<>();\n\n        final SearchContextHighlight.FieldOptions.Builder globalOptionsBuilder = new SearchContextHighlight.FieldOptions.Builder()\n                .preTags(DEFAULT_PRE_TAGS).postTags(DEFAULT_POST_TAGS).scoreOrdered(DEFAULT_SCORE_ORDERED).highlightFilter(DEFAULT_HIGHLIGHT_FILTER)\n                .requireFieldMatch(DEFAULT_REQUIRE_FIELD_MATCH).forceSource(DEFAULT_FORCE_SOURCE).fragmentCharSize(DEFAULT_FRAGMENT_CHAR_SIZE).numberOfFragments(DEFAULT_NUMBER_OF_FRAGMENTS)\n                .encoder(DEFAULT_ENCODER).boundaryMaxScan(SimpleBoundaryScanner.DEFAULT_MAX_SCAN)\n                .boundaryChars(SimpleBoundaryScanner.DEFAULT_BOUNDARY_CHARS)\n                .noMatchSize(DEFAULT_NO_MATCH_SIZE).phraseLimit(DEFAULT_PHRASE_LIMIT);\n\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                topLevelFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                if (\"pre_tags\".equals(topLevelFieldName) || \"preTags\".equals(topLevelFieldName)) {\n                    List<String> preTagsList = new ArrayList<>();\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        preTagsList.add(parser.text());\n                    }\n                    globalOptionsBuilder.preTags(preTagsList.toArray(new String[preTagsList.size()]));\n                } else if (\"post_tags\".equals(topLevelFieldName) || \"postTags\".equals(topLevelFieldName)) {\n                    List<String> postTagsList = new ArrayList<>();\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        postTagsList.add(parser.text());\n                    }\n                    globalOptionsBuilder.postTags(postTagsList.toArray(new String[postTagsList.size()]));\n                } else if (\"fields\".equals(topLevelFieldName)) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        if (token == XContentParser.Token.START_OBJECT) {\n                            String highlightFieldName = null;\n                            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                                if (token == XContentParser.Token.FIELD_NAME) {\n                                    if (highlightFieldName != null) {\n                                        throw new IllegalArgumentException(\"If highlighter fields is an array it must contain objects containing a single field\");\n                                    }\n                                    highlightFieldName = parser.currentName();\n                                } else if (token == XContentParser.Token.START_OBJECT) {\n                                    fieldsOptions.add(Tuple.tuple(highlightFieldName, parseFields(parser, queryShardContext)));\n                                }\n                            }\n                        } else {\n                            throw new IllegalArgumentException(\"If highlighter fields is an array it must contain objects containing a single field\");\n                        }\n                    }\n                }\n            } else if (token.isValue()) {\n                if (\"order\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.scoreOrdered(\"score\".equals(parser.text()));\n                } else if (\"tags_schema\".equals(topLevelFieldName) || \"tagsSchema\".equals(topLevelFieldName)) {\n                    String schema = parser.text();\n                    if (\"styled\".equals(schema)) {\n                        globalOptionsBuilder.preTags(STYLED_PRE_TAG);\n                        globalOptionsBuilder.postTags(STYLED_POST_TAGS);\n                    }\n                } else if (\"highlight_filter\".equals(topLevelFieldName) || \"highlightFilter\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlightFilter(parser.booleanValue());\n                } else if (\"fragment_size\".equals(topLevelFieldName) || \"fragmentSize\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.fragmentCharSize(parser.intValue());\n                } else if (\"number_of_fragments\".equals(topLevelFieldName) || \"numberOfFragments\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.numberOfFragments(parser.intValue());\n                } else if (\"encoder\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.encoder(parser.text());\n                } else if (\"require_field_match\".equals(topLevelFieldName) || \"requireFieldMatch\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.requireFieldMatch(parser.booleanValue());\n                } else if (\"boundary_max_scan\".equals(topLevelFieldName) || \"boundaryMaxScan\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.boundaryMaxScan(parser.intValue());\n                } else if (\"boundary_chars\".equals(topLevelFieldName) || \"boundaryChars\".equals(topLevelFieldName)) {\n                    char[] charsArr = parser.text().toCharArray();\n                    Character[] globalBoundaryChars = new Character[charsArr.length];\n                    for (int i = 0; i < charsArr.length; i++) {\n                        globalBoundaryChars[i] = charsArr[i];\n                    }\n                    globalOptionsBuilder.boundaryChars(globalBoundaryChars);\n                } else if (\"type\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlighterType(parser.text());\n                } else if (\"fragmenter\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.fragmenter(parser.text());\n                } else if (\"no_match_size\".equals(topLevelFieldName) || \"noMatchSize\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.noMatchSize(parser.intValue());\n                } else if (\"force_source\".equals(topLevelFieldName) || \"forceSource\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.forceSource(parser.booleanValue());\n                } else if (\"phrase_limit\".equals(topLevelFieldName) || \"phraseLimit\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.phraseLimit(parser.intValue());\n                }\n            } else if (token == XContentParser.Token.START_OBJECT && \"options\".equals(topLevelFieldName)) {\n                globalOptionsBuilder.options(parser.map());\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"fields\".equals(topLevelFieldName)) {\n                    String highlightFieldName = null;\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                        if (token == XContentParser.Token.FIELD_NAME) {\n                            highlightFieldName = parser.currentName();\n                        } else if (token == XContentParser.Token.START_OBJECT) {\n                            fieldsOptions.add(Tuple.tuple(highlightFieldName, parseFields(parser, queryShardContext)));\n                        }\n                    }\n                } else if (\"highlight_query\".equals(topLevelFieldName) || \"highlightQuery\".equals(topLevelFieldName)) {\n                    globalOptionsBuilder.highlightQuery(queryShardContext.parse(parser).query());\n                }\n            }\n        }\n\n        final SearchContextHighlight.FieldOptions globalOptions = globalOptionsBuilder.build();\n        if (globalOptions.preTags() != null && globalOptions.postTags() == null) {\n            throw new IllegalArgumentException(\"Highlighter global preTags are set, but global postTags are not set\");\n        }\n\n        final List<SearchContextHighlight.Field> fields = new ArrayList<>();\n        // now, go over and fill all fieldsOptions with default values from the global state\n        for (final Tuple<String, SearchContextHighlight.FieldOptions.Builder> tuple : fieldsOptions) {\n            fields.add(new SearchContextHighlight.Field(tuple.v1(), tuple.v2().merge(globalOptions).build()));\n        }\n        return new SearchContextHighlight(fields);\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds highlight to perform as part of the search.\n     */\n    public SearchSourceBuilder highlighter(HighlightBuilder highlightBuilder) {\n        try {\n            XContentBuilder builder = XContentFactory.jsonBuilder();\n            builder.startObject();\n            highlightBuilder.innerXContent(builder, EMPTY_PARAMS);\n            builder.endObject();\n            this.highlightBuilder = builder.bytes();\n            return this;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":3772,"modified_method":"/**\n     * Adds highlight to perform as part of the search.\n     */\n    public SearchSourceBuilder highlighter(HighlightBuilder highlightBuilder) {\n        try {\n            XContentBuilder builder = XContentFactory.jsonBuilder();\n            builder.startObject();\n            highlightBuilder.innerXContent(builder);\n            builder.endObject();\n            this.highlightBuilder = builder.bytes();\n            return this;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SearchContainer(\n\t\tPortletRequest portletRequest, DisplayTerms displayTerms,\n\t\tDisplayTerms searchTerms, String curParam, int cur, int delta,\n\t\tPortletURL iteratorURL, List<String> headerNames,\n\t\tString emptyResultsMessage, String cssClass) {\n\n\t\t_portletRequest = portletRequest;\n\t\t_displayTerms = displayTerms;\n\t\t_searchTerms = searchTerms;\n\n\t\t_curParam = curParam;\n\n\t\tboolean resetCur = ParamUtil.getBoolean(portletRequest, \"resetCur\");\n\n\t\tif (resetCur) {\n\t\t\t_cur = DEFAULT_CUR;\n\t\t}\n\t\telse {\n\t\t\tif (cur < 1) {\n\t\t\t\t_cur = ParamUtil.getInteger(\n\t\t\t\t\tportletRequest, _curParam, DEFAULT_CUR);\n\n\t\t\t\tif (_cur < 1) {\n\t\t\t\t\t_cur = DEFAULT_CUR;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_cur = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (!_curParam.equals(DEFAULT_CUR_PARAM)) {\n\t\t\t_deltaParam =\n\t\t\t\tDEFAULT_DELTA_PARAM +\n\t\t\t\t\tStringUtil.replace(\n\t\t\t\t\t\t_curParam, DEFAULT_CUR_PARAM, StringPool.BLANK);\n\t\t}\n\n\t\tsetDelta(ParamUtil.getInteger(portletRequest, _deltaParam, delta));\n\n\t\t_iteratorURL = iteratorURL;\n\n\t\t_iteratorURL.setParameter(_curParam, String.valueOf(_cur));\n\t\t_iteratorURL.setParameter(_deltaParam, String.valueOf(_delta));\n\n\t\tString keywords = portletRequest.getParameter(DisplayTerms.KEYWORDS);\n\n\t\tif (keywords != null) {\n\t\t\t_iteratorURL.setParameter(DisplayTerms.KEYWORDS, keywords);\n\t\t}\n\n\t\tString advancedSearch =\n\t\t\tportletRequest.getParameter(DisplayTerms.ADVANCED_SEARCH);\n\n\t\tif (advancedSearch != null) {\n\t\t\t_iteratorURL.setParameter(\n\t\t\t\tDisplayTerms.ADVANCED_SEARCH, advancedSearch);\n\t\t}\n\n\t\tString andOperator = portletRequest.getParameter(\n\t\t\tDisplayTerms.AND_OPERATOR);\n\n\t\tif (andOperator != null) {\n\t\t\t_iteratorURL.setParameter(DisplayTerms.AND_OPERATOR, andOperator);\n\t\t}\n\n\t\tif (headerNames != null) {\n\t\t\t_headerNames = new ArrayList<>(headerNames.size());\n\n\t\t\t_headerNames.addAll(headerNames);\n\n\t\t\t_buildNormalizedHeaderNames(_headerNames);\n\t\t}\n\n\t\t_emptyResultsMessage = emptyResultsMessage;\n\n\t\tSearchContainerReference searchContainerReference =\n\t\t\t(SearchContainerReference)portletRequest.getAttribute(\n\t\t\t\tWebKeys.SEARCH_CONTAINER_REFERENCE);\n\n\t\tif (searchContainerReference != null) {\n\t\t\tsearchContainerReference.register(this);\n\t\t}\n\n\t\tif (Validator.isNotNull(cssClass)) {\n\t\t\t_cssClass = cssClass;\n\t\t}\n\t}","id":3773,"modified_method":"public SearchContainer(\n\t\tPortletRequest portletRequest, DisplayTerms displayTerms,\n\t\tDisplayTerms searchTerms, String curParam, int cur, int delta,\n\t\tPortletURL iteratorURL, List<String> headerNames,\n\t\tString emptyResultsMessage, String cssClass) {\n\n\t\t_portletRequest = portletRequest;\n\t\t_displayTerms = displayTerms;\n\t\t_searchTerms = searchTerms;\n\n\t\t_curParam = curParam;\n\n\t\tboolean resetCur = ParamUtil.getBoolean(portletRequest, \"resetCur\");\n\n\t\tif (resetCur) {\n\t\t\t_cur = DEFAULT_CUR;\n\t\t}\n\t\telse {\n\t\t\tif (cur < 1) {\n\t\t\t\t_cur = ParamUtil.getInteger(\n\t\t\t\t\tportletRequest, _curParam, DEFAULT_CUR);\n\n\t\t\t\tif (_cur < 1) {\n\t\t\t\t\t_cur = DEFAULT_CUR;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_cur = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (!_curParam.equals(DEFAULT_CUR_PARAM)) {\n\t\t\t_deltaParam =\n\t\t\t\tDEFAULT_DELTA_PARAM +\n\t\t\t\t\tStringUtil.replace(\n\t\t\t\t\t\t_curParam, DEFAULT_CUR_PARAM, StringPool.BLANK);\n\t\t}\n\n\t\tsetDelta(ParamUtil.getInteger(portletRequest, _deltaParam, delta));\n\n\t\t_iteratorURL = iteratorURL;\n\n\t\t_iteratorURL.setParameter(_curParam, String.valueOf(_cur));\n\t\t_iteratorURL.setParameter(_deltaParam, String.valueOf(_delta));\n\n\t\tsetNotNullParameter(DisplayTerms.KEYWORDS);\n\t\tsetNotNullParameter(DisplayTerms.ADVANCED_SEARCH);\n\t\tsetNotNullParameter(DisplayTerms.AND_OPERATOR);\n\n\t\tif (headerNames != null) {\n\t\t\t_headerNames = new ArrayList<>(headerNames.size());\n\n\t\t\t_headerNames.addAll(headerNames);\n\n\t\t\t_buildNormalizedHeaderNames(_headerNames);\n\t\t}\n\n\t\t_emptyResultsMessage = emptyResultsMessage;\n\n\t\tSearchContainerReference searchContainerReference =\n\t\t\t(SearchContainerReference)portletRequest.getAttribute(\n\t\t\t\tWebKeys.SEARCH_CONTAINER_REFERENCE);\n\n\t\tif (searchContainerReference != null) {\n\t\t\tsearchContainerReference.register(this);\n\t\t}\n\n\t\tif (Validator.isNotNull(cssClass)) {\n\t\t\t_cssClass = cssClass;\n\t\t}\n\t}","commit_id":"8b9bdfe12161e1e037164d97b17ddb549745dfb4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JRobinDataSource(long step, long[] timestamps, List<XPort> xports) {\n        m_step = step;\n        m_timestamps = Arrays.copyOf(timestamps, timestamps.length);\n        m_xports = xports;\n    }","id":3774,"modified_method":"public JRobinDataSource(long step, long[] timestamps, List<XPort> xports) {\n        m_step = step;\n        m_timestamps = Arrays.copyOf(timestamps, timestamps.length);\n        m_xports = xports;\n        moveFirst();\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public JRDataSource createDatasource() throws JRException {\n        try {\n            return new RrdXportCmd().executeCommand(getQueryString());\n        } catch (Throwable e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","id":3775,"modified_method":"@Override\n    public JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"abstract JRDataSource execute() throws RrdException, IOException;","id":3776,"modified_method":"abstract JRRewindableDataSource execute() throws RrdException, IOException;","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"JRDataSource executeCommand(String command) throws RrdException {\n        cmdScanner = new RrdCmdScanner(command);\n        try {\n        \treturn execute();\n        }catch(IOException e) {\n        \tLOG.debug(\"Error creating JRobinDatasource: The Following Exception Occured: {}\", e.getMessage());\n        \treturn new EmptyJRDataSource();\n        }\n        \n    }","id":3777,"modified_method":"JRRewindableDataSource executeCommand(String command) throws RrdException {\n        cmdScanner = new RrdCmdScanner(command);\n        try {\n        \treturn execute();\n        }catch(IOException e) {\n        \tLOG.debug(\"Error creating JRobinDatasource: The Following Exception Occured: {}\", e.getMessage());\n            return new EmptyJRDataSource();\n        }\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t\tpublic Object getFieldValue(JRField arg0) throws JRException {\n\t\t\treturn null;\n\t\t}","id":3778,"modified_method":"@Override\n        public Object getFieldValue(JRField jrField) throws JRException {\n            return null;\n        }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    JRDataSource execute() throws RrdException, IOException {\n        String startStr = getOptionValue(\"s\", \"start\", DEFAULT_START);\n        String endStr = getOptionValue(\"e\", \"end\", DEFAULT_END);\n        long[] span = Util.getTimestamps(startStr, endStr);\n        dproc = new DataProcessor(span[0], span[1]);\n        xports = new ArrayList<XPort>();\n        long step = parseLong(getOptionValue(null, \"step\", \"1\"));\n        int maxRows = parseInt(getOptionValue(\"m\", \"maxrows\", \"400\"));\n        long minStep = (long) Math.ceil((span[1] - span[0]) / (double) (maxRows - 1));\n        step = Math.max(step, minStep);\n        dproc.setFetchRequestResolution(step);\n        dproc.setStep(step);\n        String[] words = getRemainingWords();\n        if (words.length < 1) {\n            throw new RrdException(\"Incomplete XPORT command\");\n        }\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(\"DEF:\")) {\n                parseDef(words[i]);\n            }\n            else if (words[i].startsWith(\"CDEF:\")) {\n                parseCDef(words[i]);\n            }\n            else if (words[i].startsWith(\"XPORT:\")) {\n                parseXport(words[i]);\n            }\n            else {\n                throw new RrdException(\"Invalid XPORT syntax: \" + words[i]);\n            }\n        }\n        JRDataSource result = xports.size() == 0 ? null : xport();\n        println(xports.size() == 0 ? \"No XPORT statement found, nothing done\" : result.toString());\n        return result;\n    }","id":3779,"modified_method":"@Override\n    JRRewindableDataSource execute() throws RrdException, IOException {\n        String startStr = getOptionValue(\"s\", \"start\", DEFAULT_START);\n        String endStr = getOptionValue(\"e\", \"end\", DEFAULT_END);\n        long[] span = Util.getTimestamps(startStr, endStr);\n        dproc = new DataProcessor(span[0], span[1]);\n        xports = new ArrayList<XPort>();\n        long step = parseLong(getOptionValue(null, \"step\", \"1\"));\n        int maxRows = parseInt(getOptionValue(\"m\", \"maxrows\", \"400\"));\n        long minStep = (long) Math.ceil((span[1] - span[0]) / (double) (maxRows - 1));\n        step = Math.max(step, minStep);\n        dproc.setFetchRequestResolution(step);\n        dproc.setStep(step);\n        String[] words = getRemainingWords();\n        if (words.length < 1) {\n            throw new RrdException(\"Incomplete XPORT command\");\n        }\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(\"DEF:\")) {\n                parseDef(words[i]);\n            }\n            else if (words[i].startsWith(\"CDEF:\")) {\n                parseCDef(words[i]);\n            }\n            else if (words[i].startsWith(\"XPORT:\")) {\n                parseXport(words[i]);\n            }\n            else {\n                throw new RrdException(\"Invalid XPORT syntax: \" + words[i]);\n            }\n        }\n\n        JRRewindableDataSource result = null;\n        if (xports.size() == 0) {\n            LOG.warn(\"No XPORT statement found, nothing done.\");\n        } else {\n            result = xport();\n        }\n\n        return result;\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private JRDataSource xport() throws IOException, RrdException {\n        dproc.processData();\n        long[] timestamps = dproc.getTimestamps();\n        \n        for(int i = 0; i < timestamps.length; i++) {\n            timestamps[i] = timestamps[i] - dproc.getStep();\n        }\n        \n        for (XPort xport : xports) {\n            xport.values = dproc.getValues(xport.name);\n        }\n        return new JRobinDataSource(dproc.getStep(), timestamps, xports);\n    }","id":3780,"modified_method":"private JRRewindableDataSource xport() throws IOException, RrdException {\n        dproc.processData();\n        long[] timestamps = dproc.getTimestamps();\n        \n        for(int i = 0; i < timestamps.length; i++) {\n            timestamps[i] = timestamps[i] - dproc.getStep();\n        }\n        \n        for (XPort xport : xports) {\n            xport.values = dproc.getValues(xport.name);\n        }\n        return new JRobinDataSource(dproc.getStep(), timestamps, xports);\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RrdtoolDataSource(Xport data) {\n\t\tthis.m_data = data;\n\t}","id":3781,"modified_method":"public RrdtoolDataSource(Xport data) {\n\t\tthis.m_data = data;\n\t\tmoveFirst();\n\t}","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic JRDataSource createDatasource() throws JRException {\n\t\ttry {\n\t\t\treturn new RrdtoolXportCmd().executeCommand(getQueryString());\n\t\t} catch (Exception e) {\n\t\t\tthrow new JRException(\"Error creating RrdtoolDataSource\", e);\n\t\t}\n\t}","id":3782,"modified_method":"@Override\n\tpublic JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdtoolXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating RrdtoolDataSource with command: \" + getQueryString(), e);\n        }\n\t}","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public JRDataSource executeCommand(String queryString) throws JRException {\n\t\tXport data = getXportData(queryString);\n\t\treturn new RrdtoolDataSource(data);\n\t}","id":3783,"modified_method":"public JRRewindableDataSource executeCommand(String queryString) throws JRException {\n\t\tXport data = getXportData(queryString);\n\t\treturn new RrdtoolDataSource(data);\n\t}","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public JRobinDataSource(long step, long[] timestamps, List<XPort> xports) {\n        m_step = step;\n        m_timestamps = Arrays.copyOf(timestamps, timestamps.length);\n        m_xports = xports;\n    }","id":3784,"modified_method":"public JRobinDataSource(long step, long[] timestamps, List<XPort> xports) {\n        m_step = step;\n        m_timestamps = Arrays.copyOf(timestamps, timestamps.length);\n        m_xports = xports;\n        moveFirst();\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public JRDataSource createDatasource() throws JRException {\n        try {\n            return new RrdXportCmd().executeCommand(getQueryString());\n        } catch (Throwable e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","id":3785,"modified_method":"@Override\n    public JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t\tpublic Object getFieldValue(JRField arg0) throws JRException {\n\t\t\treturn null;\n\t\t}","id":3786,"modified_method":"@Override\n        public Object getFieldValue(JRField jrField) throws JRException {\n            return null;\n        }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"JRDataSource executeCommand(String command) throws RrdException {\n        cmdScanner = new RrdCmdScanner(command);\n        try {\n        \treturn execute();\n        }catch(IOException e) {\n        \tLOG.debug(\"Error creating JRobinDatasource: The Following Exception Occured: {}\", e.getMessage());\n        \treturn new EmptyJRDataSource();\n        }\n        \n    }","id":3787,"modified_method":"JRRewindableDataSource executeCommand(String command) throws RrdException {\n        cmdScanner = new RrdCmdScanner(command);\n        try {\n        \treturn execute();\n        }catch(IOException e) {\n        \tLOG.debug(\"Error creating JRobinDatasource: The Following Exception Occured: {}\", e.getMessage());\n            return new EmptyJRDataSource();\n        }\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"abstract JRDataSource execute() throws RrdException, IOException;","id":3788,"modified_method":"abstract JRRewindableDataSource execute() throws RrdException, IOException;","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    JRDataSource execute() throws RrdException, IOException {\n        String startStr = getOptionValue(\"s\", \"start\", DEFAULT_START);\n        String endStr = getOptionValue(\"e\", \"end\", DEFAULT_END);\n        long[] span = Util.getTimestamps(startStr, endStr);\n        dproc = new DataProcessor(span[0], span[1]);\n        xports = new ArrayList<XPort>();\n        long step = parseLong(getOptionValue(null, \"step\", \"1\"));\n        int maxRows = parseInt(getOptionValue(\"m\", \"maxrows\", \"400\"));\n        long minStep = (long) Math.ceil((span[1] - span[0]) / (double) (maxRows - 1));\n        step = Math.max(step, minStep);\n        dproc.setFetchRequestResolution(step);\n        dproc.setStep(step);\n        String[] words = getRemainingWords();\n        if (words.length < 1) {\n            throw new RrdException(\"Incomplete XPORT command\");\n        }\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(\"DEF:\")) {\n                parseDef(words[i]);\n            }\n            else if (words[i].startsWith(\"CDEF:\")) {\n                parseCDef(words[i]);\n            }\n            else if (words[i].startsWith(\"XPORT:\")) {\n                parseXport(words[i]);\n            }\n            else {\n                throw new RrdException(\"Invalid XPORT syntax: \" + words[i]);\n            }\n        }\n        JRDataSource result = xports.size() == 0 ? null : xport();\n        println(xports.size() == 0 ? \"No XPORT statement found, nothing done\" : result.toString());\n        return result;\n    }","id":3789,"modified_method":"@Override\n    JRRewindableDataSource execute() throws RrdException, IOException {\n        String startStr = getOptionValue(\"s\", \"start\", DEFAULT_START);\n        String endStr = getOptionValue(\"e\", \"end\", DEFAULT_END);\n        long[] span = Util.getTimestamps(startStr, endStr);\n        dproc = new DataProcessor(span[0], span[1]);\n        xports = new ArrayList<XPort>();\n        long step = parseLong(getOptionValue(null, \"step\", \"1\"));\n        int maxRows = parseInt(getOptionValue(\"m\", \"maxrows\", \"400\"));\n        long minStep = (long) Math.ceil((span[1] - span[0]) / (double) (maxRows - 1));\n        step = Math.max(step, minStep);\n        dproc.setFetchRequestResolution(step);\n        dproc.setStep(step);\n        String[] words = getRemainingWords();\n        if (words.length < 1) {\n            throw new RrdException(\"Incomplete XPORT command\");\n        }\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(\"DEF:\")) {\n                parseDef(words[i]);\n            }\n            else if (words[i].startsWith(\"CDEF:\")) {\n                parseCDef(words[i]);\n            }\n            else if (words[i].startsWith(\"XPORT:\")) {\n                parseXport(words[i]);\n            }\n            else {\n                throw new RrdException(\"Invalid XPORT syntax: \" + words[i]);\n            }\n        }\n\n        JRRewindableDataSource result = null;\n        if (xports.size() == 0) {\n            LOG.warn(\"No XPORT statement found, nothing done.\");\n        } else {\n            result = xport();\n        }\n\n        return result;\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private JRDataSource xport() throws IOException, RrdException {\n        dproc.processData();\n        long[] timestamps = dproc.getTimestamps();\n        \n        for(int i = 0; i < timestamps.length; i++) {\n            timestamps[i] = timestamps[i] - dproc.getStep();\n        }\n        \n        for (XPort xport : xports) {\n            xport.values = dproc.getValues(xport.name);\n        }\n        return new JRobinDataSource(dproc.getStep(), timestamps, xports);\n    }","id":3790,"modified_method":"private JRRewindableDataSource xport() throws IOException, RrdException {\n        dproc.processData();\n        long[] timestamps = dproc.getTimestamps();\n        \n        for(int i = 0; i < timestamps.length; i++) {\n            timestamps[i] = timestamps[i] - dproc.getStep();\n        }\n        \n        for (XPort xport : xports) {\n            xport.values = dproc.getValues(xport.name);\n        }\n        return new JRobinDataSource(dproc.getStep(), timestamps, xports);\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RrdtoolDataSource(Xport data) {\n\t\tthis.m_data = data;\n\t}","id":3791,"modified_method":"public RrdtoolDataSource(Xport data) {\n\t\tthis.m_data = data;\n\t\tmoveFirst();\n\t}","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic JRDataSource createDatasource() throws JRException {\n\t\ttry {\n\t\t\treturn new RrdtoolXportCmd().executeCommand(getQueryString());\n\t\t} catch (Exception e) {\n\t\t\tthrow new JRException(\"Error creating RrdtoolDataSource\", e);\n\t\t}\n\t}","id":3792,"modified_method":"@Override\n\tpublic JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdtoolXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating RrdtoolDataSource with command: \" + getQueryString(), e);\n        }\n\t}","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public JRDataSource executeCommand(String queryString) throws JRException {\n\t\tXport data = getXportData(queryString);\n\t\treturn new RrdtoolDataSource(data);\n\t}","id":3793,"modified_method":"public JRRewindableDataSource executeCommand(String queryString) throws JRException {\n\t\tXport data = getXportData(queryString);\n\t\treturn new RrdtoolDataSource(data);\n\t}","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n\n        this.arf = this.mockery.mock(AttachmentReferenceResolver.class);\n        DefaultComponentDescriptor<AttachmentReferenceResolver> descriptorARF =\n            new DefaultComponentDescriptor<AttachmentReferenceResolver>();\n        descriptorARF.setRole(AttachmentReferenceResolver.class);\n        descriptorARF.setRoleHint(\"current\");\n        getComponentManager().registerComponent(descriptorARF, this.arf);\n\n        this.dab = this.mockery.mock(DocumentAccessBridge.class);\n        DefaultComponentDescriptor<DocumentAccessBridge> descriptorDAB =\n            new DefaultComponentDescriptor<DocumentAccessBridge>();\n        descriptorDAB.setRole(DocumentAccessBridge.class);\n        getComponentManager().registerComponent(descriptorDAB, this.dab);\n\n\n\n        this.factory = getComponentManager().lookup(AttachmentClassLoaderFactory.class);\n    }","id":3794,"modified_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n\n        this.arf = registerMockComponent(AttachmentReferenceResolver.class, \"current\");\n        this.dab = registerMockComponent(DocumentAccessBridge.class);\n\n        this.factory = getComponentManager().lookup(AttachmentClassLoaderFactory.class);\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetMacroIdsWithSyntaxSpecificMacros() throws Exception\n    {\n        // Create a mock macro.\n        final Macro mockMacro = context.mock(Macro.class);\n        this.context.checking(new Expectations(){{\n            allowing(mockMacro).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro\")));\n        }});\n        \n        // Register this macro against CM as a xwiki/2.0 specific macro.\n        DefaultComponentDescriptor<Macro> descriptor = new DefaultComponentDescriptor<Macro>();\n        descriptor.setRole(Macro.class);\n        descriptor.setRoleHint(\"mytestmacro/xwiki/2.0\");\n        getComponentManager().registerComponent(descriptor, mockMacro);\n        \n        // Override the macro category for this macro. \n        DefaultRenderingConfiguration configuration =\n            (DefaultRenderingConfiguration) getComponentManager().lookup(RenderingConfiguration.class);\n        configuration.addMacroCategory(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0), \"Test\");\n                \n        // Make sure our macro is put into the correct category & registered under correct syntax.\n        Set<MacroId> macroIds = this.macroCategoryManager.getMacroIds(\"Test\");\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0)));\n        macroIds = this.macroCategoryManager.getMacroIds(\"Test\", Syntax.XWIKI_2_0);\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0)));\n        macroIds = this.macroCategoryManager.getMacroIds(\"Test\", Syntax.JSPWIKI_1_0);\n        Assert.assertFalse(macroIds.contains(new MacroId(\"mytestmacro\")));\n        \n        // Finally, unregister the test macro.\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro/xwiki/2.0\");\n    }","id":3795,"modified_method":"@Test\n    public void testGetMacroIdsWithSyntaxSpecificMacros() throws Exception\n    {\n        // Create a mock macro and register it against CM as a xwiki/2.0 specific macro.\n        final Macro mockMacro = registerMockComponent(Macro.class, \"mytestmacro/xwiki/2.0\");\n        getMockery().checking(new Expectations(){{\n            allowing(mockMacro).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro\")));\n        }});\n        \n        // Override the macro category for this macro. \n        DefaultRenderingConfiguration configuration =\n            (DefaultRenderingConfiguration) getComponentManager().lookup(RenderingConfiguration.class);\n        configuration.addMacroCategory(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0), \"Test\");\n                \n        // Make sure our macro is put into the correct category & registered under correct syntax.\n        Set<MacroId> macroIds = this.macroCategoryManager.getMacroIds(\"Test\");\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0)));\n        macroIds = this.macroCategoryManager.getMacroIds(\"Test\", Syntax.XWIKI_2_0);\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro\", Syntax.XWIKI_2_0)));\n        macroIds = this.macroCategoryManager.getMacroIds(\"Test\", Syntax.JSPWIKI_1_0);\n        Assert.assertFalse(macroIds.contains(new MacroId(\"mytestmacro\")));\n        \n        // Finally, unregister the test macro.\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro/xwiki/2.0\");\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetMacroNamesForCategory() throws Exception\n    {        \n        // Create two mock macros.\n        final Macro testMacro1 = context.mock(Macro.class, \"mock1\");\n        final Macro testMacro2 = context.mock(Macro.class, \"mock2\");\n        this.context.checking(new Expectations(){{\n            allowing(testMacro1).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro - 1\")));\n        }});\n        this.context.checking(new Expectations(){{\n            allowing(testMacro2).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro - 2\")));\n        }});\n        \n        // Register these macros against CM as macros registered for all syntaxes.\n        DefaultComponentDescriptor<Macro> descriptor = new DefaultComponentDescriptor<Macro>();\n        descriptor.setRole(Macro.class);\n        descriptor.setRoleHint(\"mytestmacro1\");\n        getComponentManager().registerComponent(descriptor, testMacro1);\n        descriptor = new DefaultComponentDescriptor<Macro>();\n        descriptor.setRole(Macro.class);\n        descriptor.setRoleHint(\"mytestmacro2\");\n        getComponentManager().registerComponent(descriptor, testMacro1);\n        \n        // Override default macro categories. \n        DefaultRenderingConfiguration configuration =\n            (DefaultRenderingConfiguration) getComponentManager().lookup(RenderingConfiguration.class);\n        configuration.addMacroCategory(new MacroId(\"mytestmacro1\"), \"Cat1\");\n        configuration.addMacroCategory(new MacroId(\"mytestmacro2\"), \"Cat2\");\n        \n        // Check whether our macros are registered under correct categories.\n        Set<MacroId> macroIds = this.macroCategoryManager.getMacroIds(\"Cat1\");\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro1\")));\n        Assert.assertFalse(macroIds.contains(new MacroId(\"mytestmacro2\")));\n        \n        // These macros should be registered for all syntaxes.\n        macroIds = this.macroCategoryManager.getMacroIds(\"Cat1\", Syntax.JSPWIKI_1_0);\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro1\")));\n        \n        // Finally, unregister test macros.\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro1\");\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro2\");\n    }","id":3796,"modified_method":"@Test\n    public void testGetMacroNamesForCategory() throws Exception\n    {        \n        // Create two mock macros.\n        final Macro testMacro1 = getMockery().mock(Macro.class, \"mock1\");\n        final Macro testMacro2 = getMockery().mock(Macro.class, \"mock2\");\n        getMockery().checking(new Expectations(){{\n            allowing(testMacro1).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro - 1\")));\n        }});\n        getMockery().checking(new Expectations(){{\n            allowing(testMacro2).getDescriptor();\n            will(returnValue(new DefaultMacroDescriptor(\"Test macro - 2\")));\n        }});\n        \n        // Register these macros against CM as macros registered for all syntaxes.\n        DefaultComponentDescriptor<Macro> descriptor = new DefaultComponentDescriptor<Macro>();\n        descriptor.setRole(Macro.class);\n        descriptor.setRoleHint(\"mytestmacro1\");\n        getComponentManager().registerComponent(descriptor, testMacro1);\n        descriptor = new DefaultComponentDescriptor<Macro>();\n        descriptor.setRole(Macro.class);\n        descriptor.setRoleHint(\"mytestmacro2\");\n        getComponentManager().registerComponent(descriptor, testMacro1);\n        \n        // Override default macro categories. \n        DefaultRenderingConfiguration configuration =\n            (DefaultRenderingConfiguration) getComponentManager().lookup(RenderingConfiguration.class);\n        configuration.addMacroCategory(new MacroId(\"mytestmacro1\"), \"Cat1\");\n        configuration.addMacroCategory(new MacroId(\"mytestmacro2\"), \"Cat2\");\n        \n        // Check whether our macros are registered under correct categories.\n        Set<MacroId> macroIds = this.macroCategoryManager.getMacroIds(\"Cat1\");\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro1\")));\n        Assert.assertFalse(macroIds.contains(new MacroId(\"mytestmacro2\")));\n        \n        // These macros should be registered for all syntaxes.\n        macroIds = this.macroCategoryManager.getMacroIds(\"Cat1\", Syntax.JSPWIKI_1_0);\n        Assert.assertTrue(macroIds.contains(new MacroId(\"mytestmacro1\")));\n        \n        // Finally, unregister test macros.\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro1\");\n        getComponentManager().unregisterComponent(Macro.class, \"mytestmacro2\");\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractComponentTestCase#setUp()\n     */\n    @Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        DocumentAccessBridge mockDocumentAccessBridge = this.context.mock(DocumentAccessBridge.class);\n        DefaultComponentDescriptor<DocumentAccessBridge> descriptorDAB =\n            new DefaultComponentDescriptor<DocumentAccessBridge>();\n        descriptorDAB.setRole(DocumentAccessBridge.class);\n        getComponentManager().registerComponent(descriptorDAB, mockDocumentAccessBridge);\n\n        EntityReferenceSerializer mockEntityReferenceSerializer = this.context.mock(EntityReferenceSerializer.class);\n        DefaultComponentDescriptor<EntityReferenceSerializer> descriptorERS =\n            new DefaultComponentDescriptor<EntityReferenceSerializer>();\n        descriptorERS.setRole(EntityReferenceSerializer.class);\n        getComponentManager().registerComponent(descriptorERS, mockEntityReferenceSerializer);\n    }","id":3797,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractComponentTestCase#setUp()\n     */\n    @Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        registerMockComponent(DocumentAccessBridge.class);\n        registerMockComponent(EntityReferenceSerializer.class);\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n        this.bridge = registerComponentMock(getComponentManager(), DocumentAccessBridge.class); \n    }","id":3798,"modified_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n        this.bridge = registerMockComponent(DocumentAccessBridge.class);\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetPropertyForStringWhenExists() throws Exception\n    {\n        ConfigurationSource source = getComponentManager().lookup(ConfigurationSource.class, \"space\");\n\n        final DocumentReference webPreferencesReference = new DocumentReference(\"wiki\", \"space\", \"WebPreferences\");\n        final DocumentReference currentDocument = new DocumentReference(\"wiki\", \"space\", \"page\");\n\n        mockery.checking(new Expectations() {{\n            allowing(bridge).getCurrentDocumentReference();\n                will(returnValue(currentDocument));\n            oneOf(bridge).getProperty(webPreferencesReference, webPreferencesReference, \"key\");\n                will(returnValue(\"value\"));\n        }});\n\n        String result = source.getProperty(\"key\", String.class);\n\n        Assert.assertEquals(\"value\", result);\n        // Check that the current document reference is not modified\n        Assert.assertEquals(currentDocument.getName(), currentDocument.getParent().getChild().getName());\n    }","id":3799,"modified_method":"@Test\n    public void testGetPropertyForStringWhenExists() throws Exception\n    {\n        ConfigurationSource source = getComponentManager().lookup(ConfigurationSource.class, \"space\");\n\n        final DocumentReference webPreferencesReference = new DocumentReference(\"wiki\", \"space\", \"WebPreferences\");\n        final DocumentReference currentDocument = new DocumentReference(\"wiki\", \"space\", \"page\");\n\n        getMockery().checking(new Expectations() {{\n            allowing(bridge).getCurrentDocumentReference();\n                will(returnValue(currentDocument));\n            oneOf(bridge).getProperty(webPreferencesReference, webPreferencesReference, \"key\");\n                will(returnValue(\"value\"));\n        }});\n\n        String result = source.getProperty(\"key\", String.class);\n\n        Assert.assertEquals(\"value\", result);\n        // Check that the current document reference is not modified\n        Assert.assertEquals(currentDocument.getName(), currentDocument.getParent().getChild().getName());\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private XWikiURL createURL(String url, final boolean isDomainBasedWikiFormat, final String expectedHost)\n        throws Exception\n    {\n        this.mockery.checking(new Expectations() {{\n            allowing(mockHostResolver).resolve(expectedHost);\n                will(returnValue(new WikiReference(\"Wiki\")));\n            allowing(mockConfiguration).isPathBasedMultiWikiFormat();\n                will(returnValue(!isDomainBasedWikiFormat));\n            allowing(mockConfiguration).getWikiPathPrefix();\n                will(returnValue(\"wiki\"));\n        }});\n\n        return this.factory.createURL(new URL(url), Collections.<String, Object>singletonMap(\"ignorePrefix\", \"/xwiki\"));\n    }","id":3800,"modified_method":"private XWikiURL createURL(String url, final boolean isDomainBasedWikiFormat, final String expectedHost)\n        throws Exception\n    {\n        getMockery().checking(new Expectations() {{\n            allowing(mockHostResolver).resolve(expectedHost);\n                will(returnValue(new WikiReference(\"Wiki\")));\n            allowing(mockConfiguration).isPathBasedMultiWikiFormat();\n                will(returnValue(!isDomainBasedWikiFormat));\n            allowing(mockConfiguration).getWikiPathPrefix();\n                will(returnValue(\"wiki\"));\n        }});\n\n        return this.factory.createURL(new URL(url), Collections.<String, Object>singletonMap(\"ignorePrefix\", \"/xwiki\"));\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override protected void registerComponents() throws Exception\n    {\n        this.mockConfiguration = this.mockery.mock(StandardURLConfiguration.class);\n        DefaultComponentDescriptor<StandardURLConfiguration> descriptorUC =\n            new DefaultComponentDescriptor<StandardURLConfiguration>();\n        descriptorUC.setRole(StandardURLConfiguration.class);\n        getComponentManager().registerComponent(descriptorUC, this.mockConfiguration);\n\n        this.mockHostResolver = this.mockery.mock(HostResolver.class);\n        DefaultComponentDescriptor<HostResolver> descriptorHR =\n            new DefaultComponentDescriptor<HostResolver>();\n        descriptorHR.setRole(HostResolver.class);\n        getComponentManager().registerComponent(descriptorHR, this.mockHostResolver);\n\n        this.factory = getComponentManager().lookup(XWikiURLFactory.class, \"standard\");\n    }","id":3801,"modified_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        this.mockConfiguration = registerMockComponent(StandardURLConfiguration.class);\n        this.mockHostResolver = registerMockComponent(HostResolver.class);\n\n        this.factory = getComponentManager().lookup(XWikiURLFactory.class, \"standard\");\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        // Create a Mock WikiModel implementation so that the link parser works in wiki mode\n        WikiModel mockWikiModel = this.mockery.mock(WikiModel.class); \n\n        DefaultComponentDescriptor<WikiModel> componentDescriptor = new DefaultComponentDescriptor<WikiModel>();\n        componentDescriptor.setRole(WikiModel.class);\n        componentDescriptor.setInstantiationStrategy(ComponentInstantiationStrategy.SINGLETON);\n        componentDescriptor.setImplementation(null);\n\n        getComponentManager().registerComponent(componentDescriptor, mockWikiModel);\n        this.parser = getComponentManager().lookup(LinkParser.class, \"xwiki/2.0\");\n    }","id":3802,"modified_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        // Create a Mock WikiModel implementation so that the link parser works in wiki mode\n        registerMockComponent(WikiModel.class);\n        \n        this.parser = getComponentManager().lookup(LinkParser.class, \"xwiki/2.0\");\n    }","commit_id":"920e945164c506a8340fd4319e8675bb5622ef9e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeReplace\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":3803,"modified_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeReplace\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObjectNoData\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":3804,"modified_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObjectNoData\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readResolve\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":3805,"modified_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readResolve\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeObject\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":3806,"modified_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeObject\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObject\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":3807,"modified_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObject\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean showAddImportHint(Editor editor, PsiJavaCodeReferenceElement ref) {\n    if (HintManager.getInstance().hasShownHintsThatWillHideByOtherHint()) return false;\n\n    PsiManager manager = ref.getManager();\n    if (manager == null) return false;\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    PsiShortNamesCache cache = manager.getShortNamesCache();\n    PsiElement refname = ref.getReferenceNameElement();\n    if (!(refname instanceof PsiIdentifier)) {\n      return false;\n    }\n    PsiElement refElement = ref.resolve();\n    if (refElement != null) {\n      return false;\n    }\n    String name = ref.getQualifiedName();\n    if (manager.getResolveHelper().resolveReferencedClass(name, ref) != null) return false;\n\n    GlobalSearchScope scope = ref.getResolveScope();\n    PsiClass[] classes = cache.getClassesByName(name, scope);\n    if (classes.length == 0) return false;\n\n    try {\n      Pattern pattern = Pattern.compile(DaemonCodeAnalyzerSettings.getInstance().NO_AUTO_IMPORT_PATTERN);\n      Matcher matcher = pattern.matcher(name);\n      if (matcher.matches()) return false;\n    }\n    catch (PatternSyntaxException e) {\n    }\n\n    List<PsiClass> availableClasses = new ArrayList<PsiClass>();\n    boolean isAnnotationReference = ref.getParent() instanceof PsiAnnotation;\n    for (PsiClass aClass : classes) {\n      if (aClass.getParent() instanceof PsiDeclarationStatement) continue;\n      PsiFile file = aClass.getContainingFile();\n      if (!(file instanceof PsiJavaFile) || ((PsiJavaFile)file).getPackageName().length() == 0) continue;\n      if (isAnnotationReference && !aClass.isAnnotationType()) continue;\n      if (!aClass.hasModifierProperty(PsiModifier.PUBLIC)) continue;\n      availableClasses.add(aClass);\n    }\n    if (availableClasses.size() == 0) return false;\n\n    int refTypeArgsLength = ref.getParameterList().getTypeArguments().length;\n    if (availableClasses.size() > 0 && refTypeArgsLength != 0) {\n      List<PsiClass> typeArgMatched = new ArrayList<PsiClass>(availableClasses);\n      // try to reduce suggestions based on type argument list\n      for (int i = typeArgMatched.size() - 1; i >= 0; i--) {\n        PsiClass aClass = typeArgMatched.get(i);\n        PsiTypeParameter[] typeParameters = aClass.getTypeParameters();\n        if (refTypeArgsLength != typeParameters.length) {\n          typeArgMatched.remove(i);\n        }\n      }\n      if (typeArgMatched.size() != 0) {\n        availableClasses = typeArgMatched;\n      }\n    }\n    classes = availableClasses.toArray(new PsiClass[availableClasses.size()]);\n    CodeInsightUtil.sortIdenticalShortNameClasses(classes);\n    String hintText = classes[0].getQualifiedName() + \"? \";\n    if (classes.length > 1) {\n      hintText += \"(multiple choices...) \";\n    }\n\n    hintText += KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(IdeActions.ACTION_SHOW_INTENTION_ACTIONS));\n\n    int offset1 = ref.getTextOffset();\n    int offset2 = ref.getTextRange().getEndOffset();\n    QuestionAction action = new AddImportAction(manager.getProject(), ref, classes, editor);\n\n    if (classes.length == 1 && CodeInsightSettings.getInstance().ADD_UNAMBIGIOUS_IMPORTS_ON_THE_FLY && !isCaretNearRef(editor,ref)) {\n      action.execute();\n      return false;\n    }\n    HintManager hintManager = HintManager.getInstance();\n    hintManager.showQuestionHint(editor, hintText, offset1, offset2, action);\n    return true;\n  }","id":3808,"modified_method":"public static boolean showAddImportHint(Editor editor, PsiJavaCodeReferenceElement ref) {\n    if (HintManager.getInstance().hasShownHintsThatWillHideByOtherHint()) return false;\n\n    PsiManager manager = ref.getManager();\n    if (manager == null) return false;\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    PsiShortNamesCache cache = manager.getShortNamesCache();\n    PsiElement refname = ref.getReferenceNameElement();\n    if (!(refname instanceof PsiIdentifier)) {\n      return false;\n    }\n    PsiElement refElement = ref.resolve();\n    if (refElement != null) {\n      return false;\n    }\n    String name = ref.getQualifiedName();\n    if (manager.getResolveHelper().resolveReferencedClass(name, ref) != null) return false;\n\n    GlobalSearchScope scope = ref.getResolveScope();\n    PsiClass[] classes = cache.getClassesByName(name, scope);\n    if (classes.length == 0) return false;\n\n    try {\n      Pattern pattern = Pattern.compile(DaemonCodeAnalyzerSettings.getInstance().NO_AUTO_IMPORT_PATTERN);\n      Matcher matcher = pattern.matcher(name);\n      if (matcher.matches()) return false;\n    }\n    catch (PatternSyntaxException e) {\n    }\n\n    List<PsiClass> availableClasses = new ArrayList<PsiClass>();\n    boolean isAnnotationReference = ref.getParent() instanceof PsiAnnotation;\n    for (PsiClass aClass : classes) {\n      if (aClass.getParent() instanceof PsiDeclarationStatement) continue;\n      PsiFile file = aClass.getContainingFile();\n      if (!(file instanceof PsiJavaFile) || ((PsiJavaFile)file).getPackageName().length() == 0) continue;\n      if (isAnnotationReference && !aClass.isAnnotationType()) continue;\n      if (!aClass.hasModifierProperty(PsiModifier.PUBLIC)) continue;\n      availableClasses.add(aClass);\n    }\n    if (availableClasses.size() == 0) return false;\n\n    int refTypeArgsLength = ref.getParameterList().getTypeArguments().length;\n    if (availableClasses.size() > 0 && refTypeArgsLength != 0) {\n      List<PsiClass> typeArgMatched = new ArrayList<PsiClass>(availableClasses);\n      // try to reduce suggestions based on type argument list\n      for (int i = typeArgMatched.size() - 1; i >= 0; i--) {\n        PsiClass aClass = typeArgMatched.get(i);\n        PsiTypeParameter[] typeParameters = aClass.getTypeParameters();\n        if (refTypeArgsLength != typeParameters.length) {\n          typeArgMatched.remove(i);\n        }\n      }\n      if (typeArgMatched.size() != 0) {\n        availableClasses = typeArgMatched;\n      }\n    }\n    classes = availableClasses.toArray(new PsiClass[availableClasses.size()]);\n    CodeInsightUtil.sortIdenticalShortNameClasses(classes);\n    String hintText = classes[0].getQualifiedName() + \"? \";\n    if (classes.length > 1) {\n      hintText += \"(multiple choices...) \";\n    }\n\n    hintText += KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(IdeActions.ACTION_SHOW_INTENTION_ACTIONS));\n\n    int offset1 = ref.getTextOffset();\n    int offset2 = ref.getTextRange().getEndOffset();\n    QuestionAction action = new AddImportAction(manager.getProject(), ref, classes, editor);\n\n    if (classes.length == 1\n        && CodeInsightSettings.getInstance().ADD_UNAMBIGIOUS_IMPORTS_ON_THE_FLY\n        && !isCaretNearRef(editor,ref)\n        && !(ref.getContainingFile() instanceof JspFile)) {\n      action.execute();\n      return false;\n    }\n    HintManager hintManager = HintManager.getInstance();\n    hintManager.showQuestionHint(editor, hintText, offset1, offset2, action);\n    return true;\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean fireListeners( final TransitionListener.Phases phase, final Predicate<TransitionListener<P>> pred, P parent ) {\n    if ( this.listeners.isEmpty( ) ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      for ( Entry<Integer, TransitionListener<P>> entry : this.listeners.entrySet( ) ) {\n        final TransitionListener<P> tl = entry.getValue( );\n        if ( LogLevels.TRACE ) {\n          EventRecord.here( Transition.class, EventType.TRANSITION_LISTENER, \"\" + parent.getName( ), this.toString( ), phase.toString( ),//\n                            entry.getKey( ).toString( ), tl.getClass( ).getName( ).replaceAll( \"^(\\\\w.)*\", \"\" ) ).trace( );\n        }\n        try {\n          if ( !pred.apply( entry.getValue( ) ) ) {\n            throw new TransitionListenerException( entry.getValue( ).getClass( ).getSimpleName( ) + \".\" + phase + \"( ) returned false.\" );\n          }\n        } catch ( Throwable t ) {\n          LOG.error( t, t );\n          return false;\n        }\n      }\n      return true;\n    }\n  }","id":3809,"modified_method":"private boolean fireListeners( final TransitionListener.Phases phase, final Predicate<TransitionListener<P>> pred, P parent ) {\n    for ( Entry<Integer, TransitionListener<P>> entry : this.listeners.entrySet( ) ) {\n      final TransitionListener<P> tl = entry.getValue( );\n      if ( LogLevels.TRACE ) {\n        EventRecord.here( Transition.class, EventType.TRANSITION_LISTENER, \"\" + parent.getName( ), this.toString( ), phase.toString( ),//\n                          entry.getKey( ).toString( ), tl.getClass( ).getName( ).replaceAll( \"^(\\\\w.)*\", \"\" ) ).trace( );\n      }\n      try {\n        if ( !pred.apply( entry.getValue( ) ) ) {\n          throw new TransitionListenerException( entry.getValue( ).getClass( ).getSimpleName( ) + \".\" + phase + \"( ) returned false.\" );\n        }\n      } catch ( Throwable t ) {\n        LOG.error( t, t );\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#before()\n   */\n  public boolean before( final P parent ) {\n    return this.fireListeners( Phases.before, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        return listener.before( parent );\n      }\n    }, parent );\n  }","id":3810,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#before()\n   */\n  public boolean before( final P parent ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      return this.fireListeners( Phases.before, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          return listener.before( parent );\n        }\n      }, parent );\n      try {\n        return this.action.before( parent );\n      } catch ( Throwable ex ) {\n        LOG.error( ex, ex );\n        return false;\n      }\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#after()\n   */\n  public void after( final P parent ) {\n    this.fireListeners( Phases.after, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.after( parent );\n        return true;\n      }\n    }, parent );\n  }","id":3811,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#after()\n   */\n  public void after( final P parent ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.after, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.after( parent );\n          return true;\n        }\n      }, parent );\n      this.action.after( parent );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#leave()\n   */\n  @Override\n  public void leave( final P parent, final Completion transitionCallback ) {\n    this.fireListeners( Phases.leave, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.leave( parent, transitionCallback );\n        return true;\n      }\n    }, parent );\n  }","id":3812,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#leave()\n   */\n  @Override\n  public void leave( final P parent, final Completion transitionCallback ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.leave, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.leave( parent, transitionCallback );\n          return true;\n        }\n      }, parent );\n      this.action.leave( parent, transitionCallback );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#enter()\n   */\n  public void enter( final P parent ) {\n    this.fireListeners( Phases.enter, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.enter( parent );\n        return true;\n      }\n    }, parent );\n  }","id":3813,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#enter()\n   */\n  public void enter( final P parent ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.enter, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.enter( parent );\n          return true;\n        }\n      }, parent );\n      this.action.enter( parent );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n      @Override\n      public void visitLambdaExpression(PsiLambdaExpression lambda) {\n        super.visitLambdaExpression(lambda);\n        PsiType type = lambda.getFunctionalInterfaceType();\n        if(type instanceof PsiClassType && ((PsiClassType)type).rawType().equalsToText(CommonClassNames.JAVA_UTIL_COMPARATOR)) {\n          PsiElement body = lambda.getBody();\n          if(body instanceof PsiMethodCallExpression) {\n            PsiMethodCallExpression methodCall = (PsiMethodCallExpression)body;\n            if(MethodUtils.isCompareToCall(methodCall)) {\n              PsiExpression left = methodCall.getMethodExpression().getQualifierExpression();\n              PsiExpression right = methodCall.getArgumentList().getExpressions()[0];\n              if(left instanceof PsiMethodCallExpression && right instanceof PsiMethodCallExpression) {\n                PsiMethodCallExpression leftCall = (PsiMethodCallExpression)left;\n                PsiMethodCallExpression rightCall = (PsiMethodCallExpression)right;\n                if(leftCall.getArgumentList().getExpressions().length == 0 &&\n                   rightCall.getArgumentList().getExpressions().length == 0) {\n                  PsiMethod leftMethod = leftCall.resolveMethod();\n                  PsiMethod rightMethod = rightCall.resolveMethod();\n                  if(leftMethod != null && rightMethod != null && leftMethod == rightMethod) {\n                    if (areLambdaParameters(lambda, leftCall.getMethodExpression().getQualifierExpression(),\n                                            rightCall.getMethodExpression().getQualifierExpression())) {\n                      //noinspection DialogTitleCapitalization\n                      holder.registerProblem(lambda, \"Can be replaced with Comparator.comparing\", new ReplaceWithComparatorFix());\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n  }","id":3814,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n      @SuppressWarnings(\"DialogTitleCapitalization\")\n      @Override\n      public void visitLambdaExpression(PsiLambdaExpression lambda) {\n        super.visitLambdaExpression(lambda);\n        PsiType type = lambda.getFunctionalInterfaceType();\n        if(type instanceof PsiClassType && ((PsiClassType)type).rawType().equalsToText(CommonClassNames.JAVA_UTIL_COMPARATOR)) {\n          PsiElement body = lambda.getBody();\n          if(body instanceof PsiMethodCallExpression) {\n            PsiMethodCallExpression methodCall = (PsiMethodCallExpression)body;\n            if(MethodUtils.isCompareToCall(methodCall)) {\n              PsiExpression left = methodCall.getMethodExpression().getQualifierExpression();\n              PsiExpression right = methodCall.getArgumentList().getExpressions()[0];\n              if(areEquivalent(lambda.getParameterList().getParameters(), left, right)) {\n                holder.registerProblem(lambda, \"Can be replaced with Comparator.comparing\", new ReplaceWithComparatorFix(\"comparing\"));\n              }\n            } else {\n              PsiMethod method = methodCall.resolveMethod();\n              if(method != null && method.getName().equals(\"compare\")) {\n                PsiExpression[] args = methodCall.getArgumentList().getExpressions();\n                PsiClass compareClass = method.getContainingClass();\n                if(args.length == 2 && compareClass != null) {\n                  String replacementMethodName;\n                  if(CommonClassNames.JAVA_LANG_DOUBLE.equals(compareClass.getQualifiedName())) {\n                    replacementMethodName = \"comparingDouble\";\n                  }\n                  else if(CommonClassNames.JAVA_LANG_INTEGER.equals(compareClass.getQualifiedName())) {\n                    replacementMethodName = \"comparingInt\";\n                  }\n                  else if(CommonClassNames.JAVA_LANG_LONG.equals(compareClass.getQualifiedName())) {\n                    replacementMethodName = \"comparingLong\";\n                  }\n                  else return;\n                  if(areEquivalent(lambda.getParameterList().getParameters(), args[0], args[1])) {\n                    holder.registerProblem(lambda, \"Can be replaced with Comparator.\" + replacementMethodName,\n                                           new ReplaceWithComparatorFix(replacementMethodName));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n  }","commit_id":"e2c7ca2fff2ccc4d51cf4ab01d403653f37efb5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean areLambdaParameters(PsiLambdaExpression lambda, PsiExpression left, PsiExpression right) {\n    PsiParameter[] parameters = lambda.getParameterList().getParameters();\n    return left instanceof PsiReferenceExpression &&\n           right instanceof PsiReferenceExpression &&\n           ((PsiReferenceExpression)left).resolve() == parameters[0] &&\n           ((PsiReferenceExpression)right).resolve() == parameters[1];\n  }","id":3815,"modified_method":"private static boolean areEquivalent(PsiParameter[] parameters, PsiExpression left, PsiExpression right) {\n    if(left == null && right == null) return true;\n    if(left instanceof PsiMethodCallExpression && right instanceof PsiMethodCallExpression) {\n      PsiMethodCallExpression leftCall = (PsiMethodCallExpression)left;\n      PsiMethodCallExpression rightCall = (PsiMethodCallExpression)right;\n      PsiMethod leftMethod = leftCall.resolveMethod();\n      PsiMethod rightMethod = rightCall.resolveMethod();\n      if(leftMethod == null || leftMethod != rightMethod) return false;\n      PsiExpression[] leftArgs = leftCall.getArgumentList().getExpressions();\n      PsiExpression[] rightArgs = rightCall.getArgumentList().getExpressions();\n      return leftArgs.length == rightArgs.length &&\n             areEquivalent(parameters, leftCall.getMethodExpression(), rightCall.getMethodExpression()) &&\n             !StreamEx.zip(leftArgs, rightArgs, (leftArg, rightArg) -> areEquivalent(parameters, leftArg, rightArg)).has(Boolean.FALSE);\n    }\n    if(left instanceof PsiReferenceExpression && right instanceof PsiReferenceExpression) {\n      PsiReferenceExpression leftRef = (PsiReferenceExpression)left;\n      PsiReferenceExpression rightRef = (PsiReferenceExpression)right;\n      PsiElement leftElement = leftRef.resolve();\n      PsiElement rightElement = rightRef.resolve();\n      if(leftElement instanceof PsiParameter) {\n        return leftElement == parameters[0] && rightElement == parameters[1];\n      }\n      if(leftElement != rightElement) return false;\n      PsiType[] leftTypes = leftRef.getTypeParameters();\n      PsiType[] rightTypes = leftRef.getTypeParameters();\n      return leftTypes.length == rightTypes.length && !StreamEx.zip(leftTypes, rightTypes, Objects::equals).has(Boolean.FALSE)\n        && areEquivalent(parameters, leftRef.getQualifierExpression(), rightRef.getQualifierExpression());\n    }\n    if(left instanceof PsiTypeCastExpression && right instanceof PsiTypeCastExpression) {\n      PsiTypeCastExpression leftCast = (PsiTypeCastExpression)left;\n      PsiTypeCastExpression rightCast = (PsiTypeCastExpression)right;\n      return leftCast.getCastType() == rightCast.getCastType() &&\n             areEquivalent(parameters, leftCast.getOperand(), rightCast.getOperand());\n    }\n    return false;\n  }","commit_id":"e2c7ca2fff2ccc4d51cf4ab01d403653f37efb5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      PsiElement element = descriptor.getStartElement();\n      if (!(element instanceof PsiLambdaExpression)) return;\n      PsiLambdaExpression lambda = (PsiLambdaExpression)element;\n      PsiElement body = lambda.getBody();\n      if (!(body instanceof PsiMethodCallExpression)) return;\n      PsiMethodCallExpression methodCall = (PsiMethodCallExpression)body;\n      if (!MethodUtils.isCompareToCall(methodCall)) return;\n      PsiExpression qualifier = methodCall.getMethodExpression().getQualifierExpression();\n      if (!(qualifier instanceof PsiMethodCallExpression)) return;\n      PsiMethodCallExpression call = (PsiMethodCallExpression)qualifier;\n      if (call.getArgumentList().getExpressions().length != 0) return;\n      PsiMethod method = call.resolveMethod();\n      if (method == null) return;\n      PsiClass methodClass = method.getContainingClass();\n      if (methodClass == null) return;\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(element)) return;\n      PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n      PsiExpression replacement =\n        factory.createExpressionFromText(\"java.util.Comparator.comparing(\" + methodClass.getQualifiedName() + \"::\" + method.getName() + \")\",\n                                         element);\n      PsiElement result = lambda.replace(replacement);\n      CodeStyleManager.getInstance(project).reformat(JavaCodeStyleManager.getInstance(project).shortenClassReferences(result));\n    }","id":3816,"modified_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      PsiElement element = descriptor.getStartElement();\n      if (!(element instanceof PsiLambdaExpression)) return;\n      PsiLambdaExpression lambda = (PsiLambdaExpression)element;\n      PsiElement body = lambda.getBody();\n      if (!(body instanceof PsiMethodCallExpression)) return;\n      PsiMethodCallExpression methodCall = (PsiMethodCallExpression)body;\n      PsiExpression keyExtractor = null;\n      String methodName = null;\n      if (MethodUtils.isCompareToCall(methodCall)) {\n        methodName = \"comparing\";\n        keyExtractor = methodCall.getMethodExpression().getQualifierExpression();\n      } else {\n        PsiMethod method = methodCall.resolveMethod();\n        if(method != null && method.getName().equals(\"compare\")) {\n          PsiClass containingClass = method.getContainingClass();\n          if(containingClass != null) {\n            String className = containingClass.getQualifiedName();\n            if(className != null) {\n              PsiExpression[] args = methodCall.getArgumentList().getExpressions();\n              if(args.length != 2) return;\n              keyExtractor = args[0];\n              switch (className) {\n                case CommonClassNames.JAVA_LANG_LONG:\n                  methodName = \"comparingLong\";\n                  break;\n                case CommonClassNames.JAVA_LANG_INTEGER:\n                  methodName = \"comparingInt\";\n                  break;\n                case CommonClassNames.JAVA_LANG_DOUBLE:\n                  methodName = \"comparingDouble\";\n                  break;\n                default:\n                  return;\n              }\n            }\n          }\n        }\n      }\n      if(methodName == null || keyExtractor == null) return;\n      PsiParameter parameter = lambda.getParameterList().getParameters()[0];\n      String parameterName = parameter.getName();\n      PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n      PsiExpression replacement = factory\n        .createExpressionFromText(\"java.util.Comparator.\" + methodName + \"(\" + parameterName + \" -> \" + keyExtractor.getText() + \")\",\n                                  element);\n      PsiElement result = lambda.replace(replacement);\n      normalizeLambda(((PsiMethodCallExpression)result).getArgumentList().getExpressions()[0], factory);\n      CodeStyleManager.getInstance(project).reformat(JavaCodeStyleManager.getInstance(project).shortenClassReferences(result));\n    }","commit_id":"e2c7ca2fff2ccc4d51cf4ab01d403653f37efb5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nls\n    @NotNull\n    @Override\n    public String getFamilyName() {\n      return \"Replace with Comparator.comparing\";\n    }","id":3817,"modified_method":"@Nls\n    @NotNull\n    @Override\n    public String getFamilyName() {\n      return \"Replace with Comparator.\" + myMethodName;\n    }","commit_id":"e2c7ca2fff2ccc4d51cf4ab01d403653f37efb5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSetGetMethodCall(PsiMethodCallExpression call) {\n    final PsiExpression[] params = call.getArgumentList().getExpressions();\n    if (params.length != 1) return false;\n    if (!(params[0] instanceof PsiMethodCallExpression)) return false;\n    final PsiMethodCallExpression call2 = (PsiMethodCallExpression)params[0];\n\n    //check expressions are simple properties\n    final PsiElement methodElement = call.getMethodExpression().resolve();\n    final PsiElement param = call2.getMethodExpression().resolve();\n    if (!(methodElement instanceof PsiMethod)\n        || !(param instanceof PsiMethod)\n        || !PropertyUtil.isSimplePropertySetter((PsiMethod)methodElement)\n        || !PropertyUtil.isSimplePropertyGetter((PsiMethod)param)) {\n      return false;\n    }\n    final PsiMethod setter1 = (PsiMethod)methodElement;\n    final PsiMethod getter2 = (PsiMethod)param;\n\n    //check types compatibility\n    if (!call.getArgumentList().getExpressionTypes()[0].equals(getter2.getReturnType())) return false;\n\n    //check both classes have getters/setters\n    final PsiMethod getter1 =\n      PropertyUtil.findPropertyGetter(setter1.getContainingClass(), PropertyUtil.getPropertyName(setter1), false, true);\n    if (getter1 == null) return false;\n\n    final PsiMethod setter2 =\n      PropertyUtil.findPropertyGetter(getter2.getContainingClass(), PropertyUtil.getPropertyName(getter2), false, true);\n    if (setter2 == null) return false;\n\n    return true;\n  }","id":3818,"modified_method":"private static boolean isSetGetMethodCall(PsiElement element) {\n    if (!(element instanceof PsiMethodCallExpression)) {\n      return false;\n    }\n    final PsiMethodCallExpression call1 = (PsiMethodCallExpression)element;\n    final PsiExpression[] arguments = call1.getArgumentList().getExpressions();\n    if (arguments.length != 1) {\n      return false;\n    }\n    final PsiExpression argument = arguments[0];\n    if (!(argument instanceof PsiMethodCallExpression)) {\n      return false;\n    }\n    final PsiMethodCallExpression call2 = (PsiMethodCallExpression)argument;\n    final PsiMethod setter = call1.resolveMethod();\n    final PsiMethod getter = call2.resolveMethod();\n    final PsiMethod get = PropertyUtils.getReversePropertyMethod(setter);\n    final PsiMethod set = PropertyUtils.getReversePropertyMethod(getter);\n    if (setter == null || getter == null || get == null || set == null) {\n      return false;\n    }\n\n    //check types compatibility\n    final PsiParameter[] parameters = setter.getParameterList().getParameters();\n    if (parameters.length != 1) {\n      return false;\n    }\n    final PsiParameter parameter = parameters[0];\n    return parameter.getType().equals(getter.getReturnType());\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean satisfiedBy(PsiElement element, @Nullable Editor editor) {\n      boolean underCorrectElement = element instanceof PsiMethodCallExpression && isSetGetMethodCall((PsiMethodCallExpression)element);\n      if (editor == null || !editor.getSelectionModel().hasSelection()) {\n        return underCorrectElement;\n      }\n\n      final List<PsiMethodCallExpression> list =\n        PsiSelectionSearcher.searchElementsInSelection(editor, element.getProject(), PsiMethodCallExpression.class, false);\n      for (PsiMethodCallExpression methodCallExpression : list) {\n        if (isSetGetMethodCall(methodCallExpression)) return true;\n      }\n\n      return underCorrectElement;\n    }","id":3819,"modified_method":"@Override\n    public boolean satisfiedBy(PsiElement element, @Nullable Editor editor) {\n      if (editor != null && editor.getSelectionModel().hasSelection()) {\n        final List<PsiMethodCallExpression> list =\n          PsiSelectionSearcher.searchElementsInSelection(editor, element.getProject(), PsiMethodCallExpression.class, false);\n        for (PsiMethodCallExpression methodCallExpression : list) {\n          if (isSetGetMethodCall(methodCallExpression)) {\n            return true;\n          }\n        }\n      }\n      return isSetGetMethodCall(element);\n    }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected PsiElementPredicate getElementPredicate() {\n    return PREDICATE;\n  }","id":3820,"modified_method":"@NotNull\n  protected PsiElementPredicate getElementPredicate() {\n    return new SetterCallPredicate();\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void processIntention(@NotNull PsiElement element) throws IncorrectOperationException {\n    final Editor editor = getEditorByElementIfItHasSelection(element);\n    if (editor == null) {\n      if (element instanceof PsiMethodCallExpression) {\n        flipCall((PsiMethodCallExpression)element);\n      }\n    }\n    else { // editor not null\n      final List<PsiMethodCallExpression> methodCalls =\n        PsiSelectionSearcher.searchElementsInSelection(editor, element.getProject(), PsiMethodCallExpression.class, false);\n      for (PsiMethodCallExpression call : methodCalls) {\n        flipCall(call);\n      }\n      editor.getSelectionModel().removeSelection();\n    }\n  }","id":3821,"modified_method":"protected void processIntention(@NotNull PsiElement element) throws IncorrectOperationException {\n    final Project project = element.getProject();\n    final Editor editor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n    if (editor != null) {\n      final List<PsiMethodCallExpression> methodCalls =\n        PsiSelectionSearcher.searchElementsInSelection(editor, project, PsiMethodCallExpression.class, false);\n      if (methodCalls.size() > 0) {\n        for (PsiMethodCallExpression call : methodCalls) {\n          flipCall(call);\n        }\n        editor.getSelectionModel().removeSelection();\n        return;\n      }\n    }\n    if (element instanceof PsiMethodCallExpression) {\n      flipCall((PsiMethodCallExpression)element);\n    }\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void flipCall(PsiMethodCallExpression call) {\n    PsiExpression qualifierExpression = call.getMethodExpression().getQualifierExpression();\n    if (qualifierExpression == null) return;\n    final String qualifier1 = qualifierExpression.getText();\n    if (qualifier1 == null || qualifier1.length() == 0) return;\n    final PsiMethodCallExpression param = (PsiMethodCallExpression)call.getArgumentList().getExpressions()[0];\n    qualifierExpression = param.getMethodExpression().getQualifierExpression();\n    if (qualifierExpression == null) return;\n    final String qualifier2 = qualifierExpression.getText();\n    final PsiMethod setter = call.resolveMethod();\n    final PsiMethod getter = param.resolveMethod();\n\n    if (getter == null || setter == null) return;\n\n    final PsiMethod get = PropertyUtil.findPropertyGetter(setter.getContainingClass(), PropertyUtil.getPropertyName(setter), false, true);\n    final PsiMethod set = PropertyUtil.findPropertySetter(getter.getContainingClass(), PropertyUtil.getPropertyName(getter), false, true);\n\n    if (get == null || set == null) return;\n\n    StringBuilder text = new StringBuilder();\n    text.append(qualifier2).append(\".\").append(set.getName())\n      .append(\"(\")\n      .append(qualifier1).append(\".\").append(get.getName()).append(\"()\")\n      .append(\")\");\n    final PsiExpression newExpression =\n      JavaPsiFacade.getElementFactory(call.getProject()).createExpressionFromText(text.toString(), call.getContext());\n    call.replace(newExpression);\n  }","id":3822,"modified_method":"private static void flipCall(PsiMethodCallExpression call) {\n    final PsiExpression qualifierExpression1 = call.getMethodExpression().getQualifierExpression();\n    if (qualifierExpression1 == null) {\n      return;\n    }\n    final PsiExpression[] arguments = call.getArgumentList().getExpressions();\n    if (arguments.length != 1) {\n      return;\n    }\n    final PsiExpression argument = arguments[0];\n    if (!(argument instanceof PsiMethodCallExpression)) {\n      return;\n    }\n    final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)argument;\n    final PsiExpression qualifierExpression2 = methodCallExpression.getMethodExpression().getQualifierExpression();\n    if (qualifierExpression2 == null) {\n      return;\n    }\n    final PsiMethod setter = call.resolveMethod();\n    final PsiMethod getter = methodCallExpression.resolveMethod();\n    final PsiMethod get = PropertyUtils.getReversePropertyMethod(setter);\n    final PsiMethod set = PropertyUtils.getReversePropertyMethod(getter);\n    if (get == null || set == null) {\n      return;\n    }\n    final String text =\n      qualifierExpression2.getText() + \".\" + set.getName() + \"(\" + qualifierExpression1.getText() + \".\" + get.getName() + \"())\";\n    final PsiExpression newExpression = JavaPsiFacade.getElementFactory(call.getProject()).createExpressionFromText(text, call);\n    call.replace(newExpression);\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiField getFieldOfGetter(PsiMethod method) {\n    final PsiExpression value = getGetterReturnExpression(method);\n    if (value == null) return null;\n    if (!(value instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)value;\n    final PsiExpression qualifier = reference.getQualifierExpression();\n    if (qualifier != null && !(qualifier instanceof PsiThisExpression) && !(qualifier instanceof PsiSuperExpression)) {\n      return null;\n    }\n    final PsiElement referent = reference.resolve();\n    if (referent == null) {\n      return null;\n    }\n    if (!(referent instanceof PsiField)) {\n      return null;\n    }\n    final PsiField field = (PsiField)referent;\n    final PsiType fieldType = field.getType();\n    final PsiType returnType = method.getReturnType();\n    if (returnType == null) {\n      return null;\n    }\n    if (!fieldType.equalsToText(returnType.getCanonicalText())) {\n      return null;\n    }\n    final PsiClass fieldContainingClass = field.getContainingClass();\n    final PsiClass methodContainingClass = method.getContainingClass();\n    if (InheritanceUtil.isInheritorOrSelf(methodContainingClass, fieldContainingClass, true)) {\n      return field;\n    }\n    else {\n      return null;\n    }\n  }","id":3823,"modified_method":"@Nullable\n  public static PsiField getFieldOfGetter(PsiMethod method) {\n    final PsiExpression value = getGetterReturnExpression(method);\n    if (value == null) return null;\n    if (!(value instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)value;\n    final PsiExpression qualifier = reference.getQualifierExpression();\n    if (qualifier instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)qualifier;\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiClass)) {\n        return null;\n      }\n    }\n    else if (qualifier != null && !(qualifier instanceof PsiThisExpression) && !(qualifier instanceof PsiSuperExpression)) {\n      return null;\n    }\n    final PsiElement referent = reference.resolve();\n    if (referent == null) {\n      return null;\n    }\n    if (!(referent instanceof PsiField)) {\n      return null;\n    }\n    final PsiField field = (PsiField)referent;\n    final PsiType fieldType = field.getType();\n    final PsiType returnType = method.getReturnType();\n    if (returnType == null) {\n      return null;\n    }\n    if (!fieldType.equalsToText(returnType.getCanonicalText())) {\n      return null;\n    }\n    final PsiClass fieldContainingClass = field.getContainingClass();\n    final PsiClass methodContainingClass = method.getContainingClass();\n    if (InheritanceUtil.isInheritorOrSelf(methodContainingClass, fieldContainingClass, true)) {\n      return field;\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiField getFieldOfSetter(PsiMethod method) {\n    if (method == null) {\n      return null;\n    }\n    final PsiParameterList parameterList = method.getParameterList();\n    if (parameterList.getParametersCount() != 1) {\n      return null;\n    }\n    @NonNls final String name = method.getName();\n    if (!name.startsWith(\"set\")) {\n      return null;\n    }\n    if (method.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {\n      return null;\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      return null;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length != 1) {\n      return null;\n    }\n    final PsiStatement statement = statements[0];\n    if (!(statement instanceof PsiExpressionStatement)) {\n      return null;\n    }\n    final PsiExpressionStatement possibleAssignmentStatement = (PsiExpressionStatement)statement;\n    final PsiExpression possibleAssignment = possibleAssignmentStatement.getExpression();\n    if (!(possibleAssignment instanceof PsiAssignmentExpression)) {\n      return null;\n    }\n    final PsiAssignmentExpression assignment = (PsiAssignmentExpression)possibleAssignment;\n    if (!JavaTokenType.EQ.equals(assignment.getOperationTokenType())) {\n      return null;\n    }\n    final PsiExpression lhs = assignment.getLExpression();\n    if (!(lhs instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)lhs;\n    final PsiExpression qualifier = reference.getQualifierExpression();\n    if (qualifier != null && !(qualifier instanceof PsiThisExpression) && !(qualifier instanceof PsiSuperExpression)) {\n      return null;\n    }\n    final PsiElement referent = reference.resolve();\n    if (referent == null) {\n      return null;\n    }\n    if (!(referent instanceof PsiField)) {\n      return null;\n    }\n    final PsiField field = (PsiField)referent;\n    final PsiClass fieldContainingClass = field.getContainingClass();\n    final PsiClass methodContainingClass = method.getContainingClass();\n    if (!InheritanceUtil.isInheritorOrSelf(methodContainingClass, fieldContainingClass, true)) {\n      return null;\n    }\n    final PsiExpression rhs = assignment.getRExpression();\n    if (!(rhs instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression rReference = (PsiReferenceExpression)rhs;\n    final PsiExpression rQualifier = rReference.getQualifierExpression();\n    if (rQualifier != null) {\n      return null;\n    }\n    final PsiElement rReferent = rReference.resolve();\n    if (rReferent == null) {\n      return null;\n    }\n    if (!(rReferent instanceof PsiParameter)) {\n      return null;\n    }\n    final PsiType fieldType = field.getType();\n    final PsiType parameterType = ((PsiVariable)rReferent).getType();\n    if (fieldType.equalsToText(parameterType.getCanonicalText())) {\n      return field;\n    }\n    else {\n      return null;\n    }\n  }","id":3824,"modified_method":"@Nullable\n  public static PsiField getFieldOfSetter(PsiMethod method) {\n    if (method == null) {\n      return null;\n    }\n    final PsiParameterList parameterList = method.getParameterList();\n    if (parameterList.getParametersCount() != 1) {\n      return null;\n    }\n    @NonNls final String name = method.getName();\n    if (!name.startsWith(\"set\")) {\n      return null;\n    }\n    if (method.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {\n      return null;\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      return null;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length != 1) {\n      return null;\n    }\n    final PsiStatement statement = statements[0];\n    if (!(statement instanceof PsiExpressionStatement)) {\n      return null;\n    }\n    final PsiExpressionStatement possibleAssignmentStatement = (PsiExpressionStatement)statement;\n    final PsiExpression possibleAssignment = possibleAssignmentStatement.getExpression();\n    if (!(possibleAssignment instanceof PsiAssignmentExpression)) {\n      return null;\n    }\n    final PsiAssignmentExpression assignment = (PsiAssignmentExpression)possibleAssignment;\n    if (!JavaTokenType.EQ.equals(assignment.getOperationTokenType())) {\n      return null;\n    }\n    final PsiExpression lhs = assignment.getLExpression();\n    if (!(lhs instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)lhs;\n    final PsiExpression qualifier = reference.getQualifierExpression();\n    if (qualifier instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)qualifier;\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiClass)) {\n        return null;\n      }\n    }\n    else if (qualifier != null && !(qualifier instanceof PsiThisExpression) && !(qualifier instanceof PsiSuperExpression)) {\n      return null;\n    }\n    final PsiElement referent = reference.resolve();\n    if (referent == null) {\n      return null;\n    }\n    if (!(referent instanceof PsiField)) {\n      return null;\n    }\n    final PsiField field = (PsiField)referent;\n    final PsiClass fieldContainingClass = field.getContainingClass();\n    final PsiClass methodContainingClass = method.getContainingClass();\n    if (!InheritanceUtil.isInheritorOrSelf(methodContainingClass, fieldContainingClass, true)) {\n      return null;\n    }\n    final PsiExpression rhs = assignment.getRExpression();\n    if (!(rhs instanceof PsiReferenceExpression)) {\n      return null;\n    }\n    final PsiReferenceExpression rReference = (PsiReferenceExpression)rhs;\n    final PsiExpression rQualifier = rReference.getQualifierExpression();\n    if (rQualifier != null) {\n      return null;\n    }\n    final PsiElement rReferent = rReference.resolve();\n    if (rReferent == null) {\n      return null;\n    }\n    if (!(rReferent instanceof PsiParameter)) {\n      return null;\n    }\n    final PsiType fieldType = field.getType();\n    final PsiType parameterType = ((PsiVariable)rReferent).getType();\n    if (fieldType.equalsToText(parameterType.getCanonicalText())) {\n      return field;\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Searches elements in selection\n   *\n   * @param editor          editor to get text selection\n   * @param project         Project\n   * @param filter          PsiElement filter, e.g. PsiMethodCallExpression.class\n   * @param dontStopOnFound if true, visitor will look inside found elements. if false, visitor will stop looking for elements in children of found element\n   * @param <T>             type based on PsiElement type\n   * @return elements in selection\n   */\n  @NotNull\n  public static <T extends PsiElement> List<T> searchElementsInSelection(Editor editor,\n                                                                         Project project,\n                                                                         final Class<T> filter,\n                                                                         final boolean dontStopOnFound) {\n    final TextRange selection = new TextRange(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd());\n\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null || file instanceof PsiCompiledElement) return Collections.emptyList();\n\n    final List<T> results = new ArrayList<T>();\n\n    final PsiElementVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement element) {\n        if (!selection.intersects(element.getTextRange())) return;\n\n        if (filter.isAssignableFrom(element.getClass())) {\n          results.add((T)element);\n          if (dontStopOnFound) {\n            super.visitElement(element);\n          }\n        }\n        else {\n          super.visitElement(element);\n        }\n      }\n    };\n\n    file.accept(visitor);\n    return results;\n  }","id":3825,"modified_method":"/**\n   * Searches elements in selection\n   *\n   * @param editor          editor to get text selection\n   * @param project         Project\n   * @param filter          PsiElement filter, e.g. PsiMethodCallExpression.class\n   * @param searchChildrenOfFound if true, visitor will look for matching elements in the children of a found element, otherwise will not look inside found element.\n   * @param <T>             type based on PsiElement type\n   * @return elements in selection\n   */\n  @NotNull\n  public static <T extends PsiElement> List<T> searchElementsInSelection(Editor editor,\n                                                                         Project project,\n                                                                         final Class<T> filter,\n                                                                         final boolean searchChildrenOfFound) {\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    if (!selectionModel.hasSelection()) {\n      return Collections.emptyList();\n    }\n    final TextRange selection = new TextRange(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd());\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null || file instanceof PsiCompiledElement) {\n      return Collections.emptyList();\n    }\n    final List<T> results = new ArrayList<T>();\n\n    final PsiElementVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement element) {\n        if (!selection.intersects(element.getTextRange())) {\n          return;\n        }\n        if (filter.isAssignableFrom(element.getClass())) {\n          results.add((T)element);\n          if (!searchChildrenOfFound) {\n            return;\n          }\n        }\n        super.visitElement(element);\n      }\n    };\n\n    file.accept(visitor);\n    return results;\n  }","commit_id":"4a306d5af03ead9b64f2966594d887e580a9de76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean doesFlatMapCallCollectionStream(PsiMethodCallExpression flatMapCall) {\n    PsiElement parameter = flatMapCall.getArgumentList().getExpressions()[0];\n    if (parameter instanceof PsiMethodReferenceExpression) {\n      PsiMethodReferenceExpression methodRef = (PsiMethodReferenceExpression)parameter;\n      PsiElement resolvedMethodRef = methodRef.resolve();\n      if (resolvedMethodRef instanceof PsiMethod && isCallOf((PsiMethod)resolvedMethodRef,\n                                                             CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n        return true;\n      }\n    }\n    else if (parameter instanceof PsiLambdaExpression) {\n      PsiExpression expression = extractLambdaReturnExpression((PsiLambdaExpression)parameter);\n      if (expression instanceof PsiMethodCallExpression) {\n        PsiMethod lambdaMethod = ((PsiMethodCallExpression)expression).resolveMethod();\n        if (isCallOf(lambdaMethod, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":3826,"modified_method":"boolean doesFlatMapCallCollectionStream(PsiMethodCallExpression flatMapCall) {\n    PsiExpression[] parameters = flatMapCall.getArgumentList().getExpressions();\n    if(parameters.length != 1) {\n      return false;\n    }\n    PsiElement parameter = parameters[0];\n    if (parameter instanceof PsiMethodReferenceExpression) {\n      PsiMethodReferenceExpression methodRef = (PsiMethodReferenceExpression)parameter;\n      PsiElement resolvedMethodRef = methodRef.resolve();\n      if (resolvedMethodRef instanceof PsiMethod && isCallOf((PsiMethod)resolvedMethodRef,\n                                                             CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n        return true;\n      }\n    }\n    else if (parameter instanceof PsiLambdaExpression) {\n      PsiExpression expression = extractLambdaReturnExpression((PsiLambdaExpression)parameter);\n      if (expression instanceof PsiMethodCallExpression) {\n        PsiMethod lambdaMethod = ((PsiMethodCallExpression)expression).resolveMethod();\n        if (isCallOf(lambdaMethod, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression methodCall) {\n        final PsiMethod method = methodCall.resolveMethod();\n        if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, COUNT_METHOD, 0)) {\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n            final StreamCountFix fix = new StreamCountFix();\n            holder.registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), fix);\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FLAT_MAP_METHOD, 1) &&\n                   doesFlatMapCallCollectionStream(qualifierCall)) {\n            FlatMapCountFix fix = new FlatMapCountFix();\n            holder.registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), fix);\n          }\n        }\n      }\n    };\n  }","id":3827,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression methodCall) {\n        final PsiMethod method = methodCall.resolveMethod();\n        if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, COUNT_METHOD, 0)) {\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n            final CountFix fix = new CountFix(false);\n            holder.registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), fix);\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FLAT_MAP_METHOD, 1) &&\n                   doesFlatMapCallCollectionStream(qualifierCall)) {\n            final CountFix fix = new CountFix(true);\n            holder.registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), fix);\n          }\n        }\n      }\n    };\n  }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    String getMessage() {\n      return myQualifierCall + \".stream() can be replaced with \" + ClassUtil.extractClassName(myClassName) + \".\" + myMethodName + \"()\";\n    }","id":3828,"modified_method":"@NotNull\n    public String getMessage() {\n      return myQualifierCall + \".stream() can be replaced with \" + ClassUtil.extractClassName(myClassName) + \".\" + myMethodName + \"()\";\n    }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nls\n    @NotNull\n    @Override\n    public String getFamilyName() {\n      return \"Replace Collection.stream().\" + myStreamMethod +\n             \"() with Collection.\" + myCollectionMethod + \"()\" +\n             (myChangeSemantics ? \" (may change semantics)\" : \"\");\n    }","id":3829,"modified_method":"@Nls\n    @NotNull\n    @Override\n    public String getName() {\n      return \"Replace Collection.stream().\" + myStreamMethod +\n             \"() with Collection.\" + myCollectionMethod + \"()\" +\n             (myChangeSemantics ? \" (may change semantics)\" : \"\");\n    }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nls\n    @NotNull\n    @Override\n    public String getName() {\n      return getFamilyName();\n    }","id":3830,"modified_method":"@Nls\n    @NotNull\n    @Override\n    public String getName() {\n      return \"Replace Stream.collect(\" + myCollector +\n             \"()) with Stream.\" + myStreamSequenceStripped +\n             (myChangeSemantics ? \" (may change semantics when result is null)\" : \"\");\n    }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    String getMessage() {\n      return \"Stream.collect(\" + myCollector +\n             \"()) can be replaced with Stream.\" + myStreamSequenceStripped + \"()\" +\n             (myChangeSemantics ? \" (may change semantics when result is null)\" : \"\");\n    }","id":3831,"modified_method":"@NotNull\n    public String getMessage() {\n      return \"Stream.collect(\" + myCollector +\n             \"()) can be replaced with Stream.\" + myStreamSequenceStripped +\n             (myChangeSemantics ? \" (may change semantics when result is null)\" : \"\");\n    }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression methodCall) {\n        final PsiMethod method = methodCall.resolveMethod();\n        if (isCallOf(method, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          ReplaceCollectionStreamFix fix = null;\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_ARRAYS, AS_LIST_METHOD, 1)) {\n            if (hasSingleArrayArgument(qualifierCall)) {\n              fix = new ArraysAsListSingleArrayFix();\n            }\n            else {\n              fix = new ReplaceWithStreamOfFix(\"Arrays.asList()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, SINGLETON_LIST_METHOD, 1)) {\n            if (!hasSingleArrayArgument(qualifierCall)) {\n              fix = new ReplaceSingletonWithStreamOfFix(\"Collections.singletonList()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, SINGLETON_METHOD, 1)) {\n            if (!hasSingleArrayArgument(qualifierCall)) {\n              fix = new ReplaceSingletonWithStreamOfFix(\"Collections.singleton()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, EMPTY_LIST_METHOD, 0)) {\n            fix = new ReplaceWithStreamEmptyFix(EMPTY_LIST_METHOD);\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, EMPTY_SET_METHOD, 0)) {\n            fix = new ReplaceWithStreamEmptyFix(EMPTY_SET_METHOD);\n          }\n          if (fix != null) {\n            holder.registerProblem(methodCall, null, fix.getMessage(), fix);\n          }\n        }\n        else if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, COLLECT_METHOD, 1)) {\n          PsiElement parameter = methodCall.getArgumentList().getExpressions()[0];\n          if(parameter instanceof PsiMethodCallExpression) {\n            PsiMethodCallExpression collectorCall = (PsiMethodCallExpression)parameter;\n            PsiMethod collectorMethod = collectorCall.resolveMethod();\n            ReplaceCollectorFix fix = null;\n            if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, COUNTING_COLLECTOR, 0)) {\n              fix = new ReplaceCollectorFix(COUNTING_COLLECTOR, \"count()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MIN_BY_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(MIN_BY_COLLECTOR, \"min({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MAX_BY_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(MAX_BY_COLLECTOR, \"max({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MAPPING_COLLECTOR, 2)) {\n              fix = new ReplaceCollectorFix(MAPPING_COLLECTOR, \"map({0}).collect({1})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"reduce({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 2)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"reduce({0}, {1})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 3)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"map({1}).reduce({0}, {2})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_INT_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_INT_COLLECTOR, \"mapToInt({0}).sum()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_LONG_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_LONG_COLLECTOR, \"mapToLong({0}).sum()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_DOUBLE_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_DOUBLE_COLLECTOR, \"mapToDouble({0}).sum()\", false);\n            }\n            if (fix != null &&\n                collectorCall.getArgumentList().getExpressions().length == collectorMethod.getParameterList().getParametersCount()) {\n              TextRange range = methodCall.getTextRange();\n              PsiElement nameElement = methodCall.getMethodExpression().getReferenceNameElement();\n              if(nameElement != null) {\n                range = new TextRange(nameElement.getTextOffset(), range.getEndOffset());\n              }\n              holder.registerProblem(methodCall, range.shiftRight(-methodCall.getTextOffset()), fix.getMessage(), fix);\n            }\n          }\n        }\n        else {\n          final String name;\n          if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FOR_EACH_METHOD, 1)) {\n            name = FOR_EACH_METHOD;\n          }\n          else if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FOR_EACH_ORDERED_METHOD, 1)) {\n            name = FOR_EACH_ORDERED_METHOD;\n          }\n          else {\n            return;\n          }\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n            final ReplaceStreamMethodFix fix = new ReplaceStreamMethodFix(name, FOR_EACH_METHOD, true);\n            holder.registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), fix);\n          }\n        }\n      }\n    };\n  }","id":3832,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {\n    if (!PsiUtil.isLanguageLevel8OrHigher(holder.getFile())) {\n      return PsiElementVisitor.EMPTY_VISITOR;\n    }\n\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression methodCall) {\n        final PsiMethod method = methodCall.resolveMethod();\n        if (isCallOf(method, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          ReplaceCollectionStreamFix fix = null;\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_ARRAYS, AS_LIST_METHOD, 1)) {\n            if (hasSingleArrayArgument(qualifierCall)) {\n              fix = new ArraysAsListSingleArrayFix();\n            }\n            else {\n              fix = new ReplaceWithStreamOfFix(\"Arrays.asList()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, SINGLETON_LIST_METHOD, 1)) {\n            if (!hasSingleArrayArgument(qualifierCall)) {\n              fix = new ReplaceSingletonWithStreamOfFix(\"Collections.singletonList()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, SINGLETON_METHOD, 1)) {\n            if (!hasSingleArrayArgument(qualifierCall)) {\n              fix = new ReplaceSingletonWithStreamOfFix(\"Collections.singleton()\");\n            }\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, EMPTY_LIST_METHOD, 0)) {\n            fix = new ReplaceWithStreamEmptyFix(EMPTY_LIST_METHOD);\n          }\n          else if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTIONS, EMPTY_SET_METHOD, 0)) {\n            fix = new ReplaceWithStreamEmptyFix(EMPTY_SET_METHOD);\n          }\n          if (fix != null) {\n            holder.registerProblem(methodCall, null, fix.getMessage(), new SimplifyCallChainFix(fix));\n          }\n        }\n        else if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, COLLECT_METHOD, 1)) {\n          PsiElement parameter = methodCall.getArgumentList().getExpressions()[0];\n          if(parameter instanceof PsiMethodCallExpression) {\n            PsiMethodCallExpression collectorCall = (PsiMethodCallExpression)parameter;\n            PsiMethod collectorMethod = collectorCall.resolveMethod();\n            ReplaceCollectorFix fix = null;\n            if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, COUNTING_COLLECTOR, 0)) {\n              fix = new ReplaceCollectorFix(COUNTING_COLLECTOR, \"count()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MIN_BY_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(MIN_BY_COLLECTOR, \"min({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MAX_BY_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(MAX_BY_COLLECTOR, \"max({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, MAPPING_COLLECTOR, 2)) {\n              fix = new ReplaceCollectorFix(MAPPING_COLLECTOR, \"map({0}).collect({1})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"reduce({0})\", true);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 2)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"reduce({0}, {1})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, REDUCING_COLLECTOR, 3)) {\n              fix = new ReplaceCollectorFix(REDUCING_COLLECTOR, \"map({1}).reduce({0}, {2})\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_INT_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_INT_COLLECTOR, \"mapToInt({0}).sum()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_LONG_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_LONG_COLLECTOR, \"mapToLong({0}).sum()\", false);\n            } else if(isCallOf(collectorMethod, CommonClassNames.JAVA_UTIL_STREAM_COLLECTORS, SUMMING_DOUBLE_COLLECTOR, 1)) {\n              fix = new ReplaceCollectorFix(SUMMING_DOUBLE_COLLECTOR, \"mapToDouble({0}).sum()\", false);\n            }\n            if (fix != null &&\n                collectorCall.getArgumentList().getExpressions().length == collectorMethod.getParameterList().getParametersCount()) {\n              TextRange range = methodCall.getTextRange();\n              PsiElement nameElement = methodCall.getMethodExpression().getReferenceNameElement();\n              if(nameElement != null) {\n                range = new TextRange(nameElement.getTextOffset(), range.getEndOffset());\n              }\n              holder.registerProblem(methodCall, range.shiftRight(-methodCall.getTextOffset()), fix.getMessage(),\n                                     new SimplifyCallChainFix(fix));\n            }\n          }\n        }\n        else {\n          final String name;\n          if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FOR_EACH_METHOD, 1)) {\n            name = FOR_EACH_METHOD;\n          }\n          else if (isCallOf(method, CommonClassNames.JAVA_UTIL_STREAM_STREAM, FOR_EACH_ORDERED_METHOD, 1)) {\n            name = FOR_EACH_ORDERED_METHOD;\n          }\n          else {\n            return;\n          }\n          final PsiMethodCallExpression qualifierCall = getQualifierMethodCall(methodCall);\n          if (qualifierCall == null) return;\n          final PsiMethod qualifier = qualifierCall.resolveMethod();\n          if (isCallOf(qualifier, CommonClassNames.JAVA_UTIL_COLLECTION, STREAM_METHOD, 0)) {\n            final ReplaceStreamMethodFix fix = new ReplaceStreamMethodFix(name, FOR_EACH_METHOD, true);\n            holder\n              .registerProblem(methodCall, getCallChainRange(methodCall, qualifierCall), fix.getMessage(), new SimplifyCallChainFix(fix));\n          }\n        }\n      }\n    };\n  }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    String getMessage() {\n      return \"Collection.stream().\" + myStreamMethod +\n             \"() can be replaced with Collection.\" + myCollectionMethod + \"()\" +\n             (myChangeSemantics ? \" (may change semantics)\" : \"\");\n    }","id":3833,"modified_method":"@NotNull\n    public String getMessage() {\n      return \"Collection.stream().\" + myStreamMethod +\n             \"() can be replaced with Collection.\" + myCollectionMethod + \"()\" +\n             (myChangeSemantics ? \" (may change semantics)\" : \"\");\n    }","commit_id":"a6b7eaef09d7a150350fd605c381ffe306e84ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean localRepoSync(CCNHandle handle, CCNNetworkObject<?> obj) throws IOException {\n\t\tboolean result;\n\t\t\n\t\tbyte[] digest = obj.getFirstDigest(); // This forces reading if not done already\n\t\tContentName name = obj.getVersionedName();\n\t\tLong segment = obj.firstSegmentNumber();\n\t\t\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"RepositoryControl.localRepoSync called for net obj name {0}\", name);\n\t\t}\n\n\t\t// Request preserving the dereferenced content of the stream first\n\t\tresult = internalRepoSync(handle, name, segment, digest);\n\t\t\n\t\t// Now also deal with each of the links dereferenced to get to the ultimate content\n\t\tLinkObject link = obj.getDereferencedLink();\n\t\twhile (null != link) {\n\t\t\t// Request preserving current link: note that all of these links have \n\t\t\t// been dereferenced already to get to the content, and so have been read\n\t\t\tdigest = link.getFirstDigest();\n\t\t\tname = link.getVersionedName(); // we need versioned name; link basename may or may not be\n\t\t\tsegment = link.firstSegmentNumber();\n\n\t\t\tif (!internalRepoSync(handle, name, segment, digest)) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\tlink = link.getDereferencedLink();\n\t\t}\t\n\t\t\n\t\t// Finally, we need to ask repository to preserve the signer key (and any links\n\t\t// we need to dereference to get to that (credentials)). We had to retrieve the\n\t\t// key to verify it; it should likely still be in our cache.\n\t\tPublicKeyObject signerKey = \n\t\t\thandle.keyManager().getPublicKeyObject(obj.getContentPublisher(), obj.getPublisherKeyLocator(), \n\t\t\t\t\t\t\t\t\t\t\t\t\tSystemConfiguration.FC_TIMEOUT);\n\t\t\n\t\tif (null != signerKey) {\n\t\t\t// This will traverse any links, and the signer credentials for the lot.\n\t\t\tif (!internalRepoSync(handle, signerKey.getVersionedName(), signerKey.firstSegmentNumber(), signerKey.getFirstDigest())) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}","id":3834,"modified_method":"public static boolean localRepoSync(CCNHandle handle, CCNNetworkObject<?> obj) throws IOException {\n\t\tboolean result;\n\t\t\n\t\tbyte[] digest = obj.getFirstDigest(); // This forces reading if not done already\n\t\tContentName name = obj.getVersionedName();\n\t\tLong segment = obj.firstSegmentNumber();\n\t\t\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"RepositoryControl.localRepoSync called for net obj name {0}\", name);\n\t\t}\n\n\t\t// Request preserving the dereferenced content of the stream first\n\t\tresult = internalRepoSync(handle, name, segment, digest);\n\t\t\n\t\t// Now also deal with each of the links dereferenced to get to the ultimate content\n\t\tLinkObject link = obj.getDereferencedLink();\n\t\twhile (null != link) {\n\t\t\t// Request preserving current link: note that all of these links have \n\t\t\t// been dereferenced already to get to the content, and so have been read\n\t\t\tdigest = link.getFirstDigest();\n\t\t\tname = link.getVersionedName(); // we need versioned name; link basename may or may not be\n\t\t\tsegment = link.firstSegmentNumber();\n\n\t\t\tif (!internalRepoSync(handle, name, segment, digest)) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\tlink = link.getDereferencedLink();\n\t\t}\t\n\t\t\n\t\t// Finally, we need to ask repository to preserve the signer key (and any links\n\t\t// we need to dereference to get to that (credentials)). We had to retrieve the\n\t\t// key to verify it; it should likely still be in our cache.\n\t\tPublicKeyObject signerKey = \n\t\t\thandle.keyManager().getPublicKeyObject(obj.getContentPublisher(), obj.getPublisherKeyLocator(), \n\t\t\t\t\t\t\t\t\t\t\t\t\tSystemConfiguration.FC_TIMEOUT);\n\t\t\n\t\tif (null != signerKey) {\n\t\t\tif (!signerKey.available()) {\n\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\tLog.info(\"Signer key {0} not available for syncing.\", signerKey.getBaseName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\tLog.info(\"localRepoSync: synchronizing signer key {0}.\", signerKey.getVersionedName());\n\t\t\t\t\tLog.info(\"localRepoSync: is signer key self-signed? \" + signerKey.isSelfSigned());\n\t\t\t\t}\n\t\t\t\n\t\t\t\t// This will traverse any links, and the signer credentials for the lot.\n\t\t\t\tif (!localRepoSync(handle, signerKey)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"Cannot retrieve signer key from locator {0}!\", obj.getPublisherKeyLocator());\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"2b520b3a7dd636d5003d8fa1c6eedd61b08266fe","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Request that a local repository preserve a copy\n\t * of the exact contents of a given stream opened for reading\n\t * with a given handle, and all links that were dereferenced\n\t * to read the stream.\n\t * \n\t * A local repository is one connected\n\t * directly to the same ccnd as the given handle; such a repository\n\t * is likely to be special in the sense that it may be available to local\n\t * applications even when there is no connectivity beyond the local \n\t * machine.  An application reading certain content that it did not originate\n\t * may have reason to need that content to be available reliably as connectivity changes\n\t * in the future. Since the application is not the source of the content, it need\n\t * only ask the local repository to be interested in it rather than creating an\n\t * output stream to write it. This method serves that purpose.\n\t * \n\t * This method is experimental and the way of addressing this problem \n\t * is likely to change in the future.\n\t * \n\t * This method may fail (IOException) if the local repository is not already\n\t * configured to support holding the data in question. For example, the \n\t * repository policy might not admit the namespace in question\n\t * and this method does not override such overall policy.\n\t * \n\t * There may be more than one local repository but this method does not \n\t * presently distinguish one if that is the case.  Any one local repository\n\t * that is available may be used, and at most one should be expected to respond to\n\t * the request. This method should verify that a confirmation is from an acceptable\n\t * local repository.\n\t * \n\t * If the repository already holds the content it may confirm immediately, otherwise the repository\n\t * will begin to retrieve and store the content but there is no guarantee that this is complete\n\t * upon return from this method. The return value indicates whether data is already confirmed.\n\t * \n\t * @param handle the handle\n\t * @param stream The stream for which the content should be preserved\n\t * @return boolean true iff confirmation received from repository\n\t * @throws IOException if no repository responds or another communication error occurs\n\t */\n\tpublic static boolean localRepoSync(CCNHandle handle, CCNAbstractInputStream stream) throws IOException {\n\t\tboolean result;\n\t\t\n\t\tbyte[] digest = stream.getFirstDigest(); // This forces reading if not done already\n\t\tContentName name = stream.getBaseName();\n\t\tLong segment = stream.firstSegmentNumber();\n\t\tLog.fine(\"RepositoryControl.localRepoSync called for name {0}\", name);\n\n\t\t// Request preserving the dereferenced content of the stream first\n\t\tresult = internalRepoSync(handle, name, segment, digest);\n\t\t\n\t\t// Now also deal with each of the links dereferenced to get to the ultimate content\n\t\tLinkObject link = stream.getDereferencedLink();\n\t\twhile (null != link) {\n\t\t\t// Request preserving current link: note that all of these links have \n\t\t\t// been dereferenced already to get to the content, and so have been read\n\t\t\tdigest = link.getFirstDigest();\n\t\t\tname = link.getVersionedName(); // we need versioned name; link basename may or may not be\n\t\t\tsegment = link.firstSegmentNumber();\n\n\t\t\tif (!internalRepoSync(handle, name, segment, digest)) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\tlink = link.getDereferencedLink();\n\t\t}\n\t\t\n\t\t// Finally, we need to ask repository to preserve the signer key (and any links\n\t\t// we need to dereference to get to that (credentials)). We had to retrieve the\n\t\t// key to verify it; it should likely still be in our cache.\n\t\tPublicKeyObject signerKey = \n\t\t\thandle.keyManager().getPublicKeyObject(stream.publisher(), stream.publisherKeyLocator(), \n\t\t\t\t\tSystemConfiguration.FC_TIMEOUT);\n\n\t\tif (null != signerKey) {\n\t\t\t// This will traverse any links, and the signer credentials for the lot.\n\t\t\tif (!internalRepoSync(handle, signerKey.getVersionedName(), signerKey.firstSegmentNumber(), signerKey.getFirstDigest())) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\n\n\t\treturn result;\n\t}","id":3835,"modified_method":"/**\n\t * Request that a local repository preserve a copy\n\t * of the exact contents of a given stream opened for reading\n\t * with a given handle, and all links that were dereferenced\n\t * to read the stream.\n\t * \n\t * A local repository is one connected\n\t * directly to the same ccnd as the given handle; such a repository\n\t * is likely to be special in the sense that it may be available to local\n\t * applications even when there is no connectivity beyond the local \n\t * machine.  An application reading certain content that it did not originate\n\t * may have reason to need that content to be available reliably as connectivity changes\n\t * in the future. Since the application is not the source of the content, it need\n\t * only ask the local repository to be interested in it rather than creating an\n\t * output stream to write it. This method serves that purpose.\n\t * \n\t * This method is experimental and the way of addressing this problem \n\t * is likely to change in the future.\n\t * \n\t * This method may fail (IOException) if the local repository is not already\n\t * configured to support holding the data in question. For example, the \n\t * repository policy might not admit the namespace in question\n\t * and this method does not override such overall policy.\n\t * \n\t * There may be more than one local repository but this method does not \n\t * presently distinguish one if that is the case.  Any one local repository\n\t * that is available may be used, and at most one should be expected to respond to\n\t * the request. This method should verify that a confirmation is from an acceptable\n\t * local repository.\n\t * \n\t * If the repository already holds the content it may confirm immediately, otherwise the repository\n\t * will begin to retrieve and store the content but there is no guarantee that this is complete\n\t * upon return from this method. The return value indicates whether data is already confirmed.\n\t * \n\t * @param handle the handle\n\t * @param stream The stream for which the content should be preserved\n\t * @return boolean true iff confirmation received from repository\n\t * @throws IOException if no repository responds or another communication error occurs\n\t */\n\tpublic static boolean localRepoSync(CCNHandle handle, CCNAbstractInputStream stream) throws IOException {\n\t\tboolean result;\n\t\t\n\t\tbyte[] digest = stream.getFirstDigest(); // This forces reading if not done already\n\t\tContentName name = stream.getBaseName();\n\t\tLong segment = stream.firstSegmentNumber();\n\n\t\tLog.info(\"RepositoryControl.localRepoSync called for name {0}\", name);\n\n\t\t// Request preserving the dereferenced content of the stream first\n\t\tresult = internalRepoSync(handle, name, segment, digest);\n\t\t\n\t\t// Now also deal with each of the links dereferenced to get to the ultimate content\n\t\tLinkObject link = stream.getDereferencedLink();\n\t\twhile (null != link) {\n\t\t\t// Request preserving current link: note that all of these links have \n\t\t\t// been dereferenced already to get to the content, and so have been read\n\t\t\tdigest = link.getFirstDigest();\n\t\t\tname = link.getVersionedName(); // we need versioned name; link basename may or may not be\n\t\t\tsegment = link.firstSegmentNumber();\n\n\t\t\tif (!internalRepoSync(handle, name, segment, digest)) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\tlink = link.getDereferencedLink();\n\t\t}\n\t\t\n\t\t// Finally, we need to ask repository to preserve the signer key (and any links\n\t\t// we need to dereference to get to that (credentials)). We had to retrieve the\n\t\t// key to verify it; it should likely still be in our cache.\n\t\tPublicKeyObject signerKey = \n\t\t\thandle.keyManager().getPublicKeyObject(stream.publisher(), stream.publisherKeyLocator(), \n\t\t\t\t\tSystemConfiguration.FC_TIMEOUT);\n\n\t\tif (null != signerKey) {\n\t\t\tif (!signerKey.available()) {\n\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\tLog.info(\"Signer key {0} not available for syncing.\", signerKey.getBaseName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\tLog.info(\"localRepoSync: synchronizing signer key {0}.\", signerKey.getVersionedName());\n\t\t\t\t\tLog.info(\"localRepoSync: is signer key self-signed? \" + signerKey.isSelfSigned());\n\t\t\t\t}\n\t\t\t\n\t\t\t\t// This will traverse any links, and the signer credentials for the lot.\n\t\t\t\tif (!localRepoSync(handle, signerKey)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"Cannot retrieve signer key from locator {0}!\", stream.publisherKeyLocator());\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"2b520b3a7dd636d5003d8fa1c6eedd61b08266fe","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Publish my identity (i.e. my public key) under a specified user name\n\t * @param userName the user name\n\t * @param myPublicKey my public key\n\t * @throws InvalidKeyException\n\t * @throws ContentEncodingException\n\t * @throws IOException\n\t * @throws ConfigurationException\n\t */\n\tpublic void publishMyIdentity(String userName, PublicKey myPublicKey) \n\t\t\tthrows InvalidKeyException, ContentEncodingException, IOException, ConfigurationException {\n\t\tLog.finest(\"publishing my identity\" + GroupAccessControlProfile.userNamespaceName(_userStorage, userName));\n\t\tpublishMyIdentity(GroupAccessControlProfile.userNamespaceName(_userStorage, userName), myPublicKey);\n\t}","id":3836,"modified_method":"/**\n\t * Publish my identity (i.e. my public key) under a specified user name\n\t * @param userName the user name\n\t * @param myPublicKey my public key\n\t * @throws InvalidKeyException\n\t * @throws ContentEncodingException\n\t * @throws IOException\n\t * @throws ConfigurationException\n\t */\n\tpublic void publishMyIdentity(String userName, PublicKey myPublicKey) \n\t\t\tthrows InvalidKeyException, ContentEncodingException, IOException, ConfigurationException {\n\t\tif (Log.isLoggable(Level.FINEST)) {\n\t\t\tLog.finest(\"publishing my identity {0}\", GroupAccessControlProfile.userNamespaceName(_userStorage, userName));\n\t\t}\n\t\tpublishMyIdentity(GroupAccessControlProfile.userNamespaceName(_userStorage, userName), myPublicKey);\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Read path:\n\t * Retrieve a specific node key from a given location, as specified by a\n\t * key it was used to wrap, and, if possible, find a key we can use to\n\t * unwrap the node key.\n\t * \n\t * Throw an exception if there is no node key block at the appropriate name.\n\t * @param nodeKeyName\n\t * @param nodeKeyIdentifier\n\t * @return the node key\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws AccessDeniedException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getSpecificNodeKey(ContentName nodeKeyName, byte [] nodeKeyIdentifier) \n\t\t\tthrows InvalidKeyException, AccessDeniedException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t\n\t\tif ((null == nodeKeyName) && (null == nodeKeyIdentifier)) {\n\t\t\tthrow new IllegalArgumentException(\"Node key name and identifier cannot both be null!\");\n\t\t}\n\t\t// We should know what node key to use (down to the version), but we have to find the specific\n\t\t// wrapped key copy we can decrypt. \n\t\tNodeKey nk = getNodeKeyByVersionedName(nodeKeyName, nodeKeyIdentifier);\n\t\tif (null == nk) {\n\t\t\tLog.warning(\"No decryptable node key available at \" + nodeKeyName + \", access denied.\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn nk;\n\t}","id":3837,"modified_method":"/**\n\t * Read path:\n\t * Retrieve a specific node key from a given location, as specified by a\n\t * key it was used to wrap, and, if possible, find a key we can use to\n\t * unwrap the node key.\n\t * \n\t * Throw an exception if there is no node key block at the appropriate name.\n\t * @param nodeKeyName\n\t * @param nodeKeyIdentifier\n\t * @return the node key\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws AccessDeniedException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getSpecificNodeKey(ContentName nodeKeyName, byte [] nodeKeyIdentifier) \n\t\t\tthrows InvalidKeyException, AccessDeniedException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t\n\t\tif ((null == nodeKeyName) && (null == nodeKeyIdentifier)) {\n\t\t\tthrow new IllegalArgumentException(\"Node key name and identifier cannot both be null!\");\n\t\t}\n\t\t// We should know what node key to use (down to the version), but we have to find the specific\n\t\t// wrapped key copy we can decrypt. \n\t\tNodeKey nk = getNodeKeyByVersionedName(nodeKeyName, nodeKeyIdentifier);\n\t\tif (null == nk) {\n\t\t\tLog.warning(\"No decryptable node key available at {0}, access denied.\", nodeKeyName);\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn nk;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get the latest key for a specified principal\n\t * TODO shortcut slightly -- the principal we have cached might not meet the\n\t * constraints of the link.\n\t * @param principal the principal\n\t * @return the public key object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic PublicKeyObject getLatestKeyForPrincipal(Link principal) throws ContentDecodingException, IOException {\n\t\tif (null == principal) {\n\t\t\tLog.info(\"Cannot retrieve key for empty principal.\");\n\t\t\treturn null;\n\t\t}\n\t\tPublicKeyObject pko = null;\n\t\tif (_groupManager.isGroup(principal)) {\n\t\t\tpko = _groupManager.getLatestPublicKeyForGroup(principal);\n\t\t} else {\n\t\t\tLog.info(\"Retrieving latest key for user: \" + principal.targetName());\n\t\t\tLinkAuthenticator targetAuth = principal.targetAuthenticator();\n\t\t\tif (null != targetAuth) {\n\t\t\t\tpko = new PublicKeyObject(principal.targetName(), targetAuth.publisher(), handle());\n\t\t\t}\n\t\t\telse pko = new PublicKeyObject(principal.targetName(), handle());\n\t\t}\n\t\treturn pko;\n\t}","id":3838,"modified_method":"/**\n\t * Get the latest key for a specified principal\n\t * TODO shortcut slightly -- the principal we have cached might not meet the\n\t * constraints of the link.\n\t * @param principal the principal\n\t * @return the public key object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic PublicKeyObject getLatestKeyForPrincipal(Link principal) throws ContentDecodingException, IOException {\n\t\tif (null == principal) {\n\t\t\tLog.info(\"Cannot retrieve key for empty principal.\");\n\t\t\treturn null;\n\t\t}\n\t\tPublicKeyObject pko = null;\n\t\tif (_groupManager.isGroup(principal)) {\n\t\t\tpko = _groupManager.getLatestPublicKeyForGroup(principal);\n\t\t} else {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"Retrieving latest key for user: \" + principal.targetName());\n\t\t\t}\n\t\t\tLinkAuthenticator targetAuth = principal.targetAuthenticator();\n\t\t\tif (null != targetAuth) {\n\t\t\t\tpko = new PublicKeyObject(principal.targetName(), targetAuth.publisher(), handle());\n\t\t\t}\n\t\t\telse pko = new PublicKeyObject(principal.targetName(), handle());\n\t\t}\n\t\treturn pko;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Write path:\n\t * Get the effective node key in force at this node, used to derive keys to \n\t * encrypt  content. Vertical chaining. Works if you ask for node which has\n\t * a node key.\n\t * TODO -- when called by writers, check to see if node key is dirty & update.\n\t * @param nodeName\n\t * @return\n\t * @throws AccessDeniedException \n\t * @throws ContentEncodingException \n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getEffectiveNodeKey(ContentName nodeName) \n\t\t\tthrows AccessDeniedException, InvalidKeyException, ContentEncodingException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t// Get the ancestor node key in force at this node.\n\t\tNodeKey nodeKey = findAncestorWithNodeKey(nodeName);\n\t\tif (null == nodeKey) {\n\t\t\tthrow new AccessDeniedException(\"Cannot retrieve node key for node: \" + nodeName + \".\");\n\t\t}\n\t\tLog.info(\"Found node key at \" + nodeKey.storedNodeKeyName());\n\t\tNodeKey effectiveNodeKey = nodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel()); \n\t\tLog.info(\"Computing effective node key for \" + nodeName + \" using stored node key \" + effectiveNodeKey.storedNodeKeyName());\n\t\treturn effectiveNodeKey;\n\t}","id":3839,"modified_method":"/**\n\t * Write path:\n\t * Get the effective node key in force at this node, used to derive keys to \n\t * encrypt  content. Vertical chaining. Works if you ask for node which has\n\t * a node key.\n\t * TODO -- when called by writers, check to see if node key is dirty & update.\n\t * @param nodeName\n\t * @return\n\t * @throws AccessDeniedException \n\t * @throws ContentEncodingException \n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getEffectiveNodeKey(ContentName nodeName) \n\t\t\tthrows AccessDeniedException, InvalidKeyException, ContentEncodingException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t// Get the ancestor node key in force at this node.\n\t\tNodeKey nodeKey = findAncestorWithNodeKey(nodeName);\n\t\tif (null == nodeKey) {\n\t\t\tthrow new AccessDeniedException(\"Cannot retrieve node key for node: \" + nodeName + \".\");\n\t\t}\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"Found node key at {0}\", nodeKey.storedNodeKeyName());\n\t\t}\n\t\tNodeKey effectiveNodeKey = nodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel());\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"Computing effective node key for {0} using stored node key {1}\", nodeName, effectiveNodeKey.storedNodeKeyName());\n\t\t}\n\t\treturn effectiveNodeKey;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Retrieves the latest version of an ACL effective at this node, either stored\n\t * here or at one of its ancestors.\n\t * @param nodeName the name of the node\n\t * @return the ACL object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic ACLObject getEffectiveACLObject(ContentName nodeName) throws ContentDecodingException, IOException {\n\t\t\n\t\t// Find the closest node that has a non-gone ACL\n\t\tACLObject aclo = findAncestorWithACL(nodeName, null);\n\t\tif (null != aclo) {\n\t\t\t// parallel find doesn't get us the latest version. Serial does,\n\t\t\t// but it's kind of an artifact.\n\t\t\taclo.update();\n\t\t} else {\n\t\t\tLog.info(\"No ACL found between node {0} and namespace root {1}. Returning root ACL.\",\n\t\t\t\t\tnodeName, getNamespaceRoot());\n\t\t\treturn getACLObjectForNode(getNamespaceRoot());\n\t\t}\n\t\treturn aclo;\n\t}","id":3840,"modified_method":"/**\n\t * Retrieves the latest version of an ACL effective at this node, either stored\n\t * here or at one of its ancestors.\n\t * @param nodeName the name of the node\n\t * @return the ACL object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic ACLObject getEffectiveACLObject(ContentName nodeName) throws ContentDecodingException, IOException {\n\t\t\n\t\t// Find the closest node that has a non-gone ACL\n\t\tACLObject aclo = findAncestorWithACL(nodeName, null);\n\t\tif (null != aclo) {\n\t\t\t// parallel find doesn't get us the latest version. Serial does,\n\t\t\t// but it's kind of an artifact.\n\t\t\taclo.update();\n\t\t} else {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"No ACL found between node {0} and namespace root {1}. Returning root ACL.\",\n\t\t\t\t\tnodeName, getNamespaceRoot());\n\t\t\t}\n\t\t\treturn getACLObjectForNode(getNamespaceRoot());\n\t\t}\n\t\treturn aclo;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Implement a parallel findAncestorWithACL; drop it in separately so we can \n\t * switch back and forth in testing.\n\t */\n\tprivate ACLObject findAncestorWithACLInParallel(ContentName dataNodeName, ContentName stopPoint) throws ContentDecodingException, IOException {\n\n\t\t// If dataNodeName is the root of this AccessControlManager, there can be no ACL between\n\t\t// dataNodeName (inclusive) and the root (exclusive), so return null.\n\t\tif (getNamespaceRoot().equals(dataNodeName)) return null;\n\t\t\n\t\tif (null == stopPoint)  {\n\t\t\tstopPoint = getNamespaceRoot();\n\t\t} else if (!getNamespaceRoot().isPrefixOf(stopPoint)) {\n\t\t\tLog.warning(\"findAncestorWithACLInParallel: Stopping point {0} must be an ancestor of the starting point {1}!\", \n\t\t\t\t\tstopPoint, dataNodeName);\n\t\t\tthrow new IOException(\"findAncestorWithACLInParallel: invalid search space: stopping point \" + stopPoint + \" must be an ancestor of the starting point \" +\n\t\t\t\t\tdataNodeName + \"!\");\n\t\t}\n\t\tLog.info(\"findAncestorWithACLInParallel: start point {0}, stop before {1}\", dataNodeName, stopPoint);\n\t\tint stopCount = stopPoint.count();\n\t\t\n\t\t// Pathfinder searches from start point to stop point inclusive, want exclusive, so hand\n\t\t// it one level down from stop point.\n\t\tPathfinder pathfinder = new Pathfinder(dataNodeName, dataNodeName.cut(stopCount+1), \n\t\t\t\tGroupAccessControlProfile.aclPostfix(), true, false, SystemConfiguration.MEDIUM_TIMEOUT,\n\t\t\t\tnull, handle());\n\t\t\n\t\tSearchResults searchResults = pathfinder.waitForResults();\n\t\tif (null != searchResults.first()) {\n\t\t\tLog.info(\"findAncestorWithACLInParallel: found \" + searchResults.first().name());\n\t\t\tACLObject aclo = new ACLObject(searchResults.first(), handle());\n\t\t\treturn aclo;\n\t\t}\n\t\treturn null;\n\t}","id":3841,"modified_method":"/**\n\t * Implement a parallel findAncestorWithACL; drop it in separately so we can \n\t * switch back and forth in testing.\n\t */\n\tprivate ACLObject findAncestorWithACLInParallel(ContentName dataNodeName, ContentName stopPoint) throws ContentDecodingException, IOException {\n\n\t\t// If dataNodeName is the root of this AccessControlManager, there can be no ACL between\n\t\t// dataNodeName (inclusive) and the root (exclusive), so return null.\n\t\tif (getNamespaceRoot().equals(dataNodeName)) return null;\n\t\t\n\t\tif (null == stopPoint)  {\n\t\t\tstopPoint = getNamespaceRoot();\n\t\t} else if (!getNamespaceRoot().isPrefixOf(stopPoint)) {\n\t\t\tLog.warning(\"findAncestorWithACLInParallel: Stopping point {0} must be an ancestor of the starting point {1}!\", \n\t\t\t\t\tstopPoint, dataNodeName);\n\t\t\tthrow new IOException(\"findAncestorWithACLInParallel: invalid search space: stopping point \" + stopPoint + \" must be an ancestor of the starting point \" +\n\t\t\t\t\tdataNodeName + \"!\");\n\t\t}\n\t\tLog.info(\"findAncestorWithACLInParallel: start point {0}, stop before {1}\", dataNodeName, stopPoint);\n\t\tint stopCount = stopPoint.count();\n\t\t\n\t\t// Pathfinder searches from start point to stop point inclusive, want exclusive, so hand\n\t\t// it one level down from stop point.\n\t\tPathfinder pathfinder = new Pathfinder(dataNodeName, dataNodeName.cut(stopCount+1), \n\t\t\t\tGroupAccessControlProfile.aclPostfix(), true, false, SystemConfiguration.MEDIUM_TIMEOUT,\n\t\t\t\tnull, handle());\n\t\t\n\t\tSearchResults searchResults = pathfinder.waitForResults();\n\t\tif (null != searchResults.first()) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"findAncestorWithACLInParallel: found {0}\", searchResults.first().name());\n\t\t\t}\n\t\t\tACLObject aclo = new ACLObject(searchResults.first(), handle());\n\t\t\treturn aclo;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Pulls the ACL for this node, if one exists, and modifies it to include\n\t * the following changes, then stores the result using setACL, updating\n\t * the node key if necessary in the process.\n\t * \n\t * @param nodeName the name of the node\n\t * @param ACLUpdates the updates to the ACL\n\t * @return the updated ACL\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic ACL updateACL(ContentName nodeName, ArrayList<ACL.ACLOperation> ACLUpdates) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\t\tACLObject currentACL = getACLObjectForNodeIfExists(nodeName);\n\t\tACL newACL = null;\n\t\t\n\t\tif (null != currentACL) {\n\t\t\tnewACL = currentACL.acl();\n\t\t} else {\n\t\t\tLog.info(\"Adding brand new ACL to node: \" + nodeName);\n\t\t\t//TODO: if no operations is specified, then a new empty ACL is created...\n\t\t\tnewACL = new ACL();\n\t\t}\n\t\t\n\t\tLinkedList<Link> newReaders = newACL.update(ACLUpdates);\n\t\t\n\t\tif ((null == newReaders) || (null == currentACL)) {\n\t\t\t// null newReaders means we revoked someone.\n\t\t\t// null currentACL means we're starting from scratch\n\t\t\t// Set the ACL and update the node key.\n\t\t\treturn setACL(nodeName, newACL);\n\t\t}\n\t\t\n\t\t// If we get back a list of new readers, it means all we have to do\n\t\t// is add key blocks for them, not update the node key. (And it means\n\t\t// we have a node key for this node.)\n\t\t// Wait to save the new ACL till we are sure we're allowed to do this.\n\t\tKeyDirectory keyDirectory = null;\n\t\ttry {\n\t\t\t// If we can't read the node key, we can't update. Get the effective node key.\n\t\t\t// Better be a node key here... and we'd better be allowed to read it.\n\t\t\tNodeKey latestNodeKey = getLatestNodeKeyForNode(nodeName);\n\t\t\tif (null == latestNodeKey) {\n\t\t\t\tLog.info(\"Cannot read the latest node key for \" + nodeName);\n\t\t\t\tthrow new AccessDeniedException(\"Cannot read the latest node key for \" + nodeName);\n\t\t\t}\n\t\t\t\n\t\t\tkeyDirectory = new KeyDirectory(this, latestNodeKey.storedNodeKeyName(), handle());\n\n\t\t\tfor (Link principal : newReaders) {\n\t\t\t\tPublicKeyObject latestKey = getLatestKeyForPrincipal(principal);\n\t\t\t\tif (!latestKey.available()) {\n\t\t\t\t\tlatestKey.waitForData(SystemConfiguration.getDefaultTimeout());\n\t\t\t\t}\n\t\t\t\tif (latestKey.available()) {\n\t\t\t\t\tLog.info(\"updateACL: Adding wrapped key block for reader: \" + latestKey.getVersionedName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tkeyDirectory.addWrappedKeyBlock(latestNodeKey.nodeKey(), latestKey.getVersionedName(), latestKey.publicKey());\n\t\t\t\t\t} catch (VersionMissingException e) {\n\t\t\t\t\t\tLog.warning(\"UNEXPECTED: latest key for prinicpal: \" + latestKey.getVersionedName() + \" has no version? Skipping.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Do we use an old key or give up?\n\t\t\t\t\tLog.info(\"updateACL: No key for \" + principal + \" found. Skipping.\");\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (null != keyDirectory) {\n\t\t\t\tkeyDirectory.stopEnumerating();\n\t\t\t}\n\t\t}\n\t\t// If we got here, we got the node key we were updating, so we are allowed\n\t\t// to at least read this stuff (though maybe not write it). Save the acl.\n\t\tcurrentACL.save(newACL);\n\t\treturn newACL;\n\t\t\n\t}","id":3842,"modified_method":"/**\n\t * Pulls the ACL for this node, if one exists, and modifies it to include\n\t * the following changes, then stores the result using setACL, updating\n\t * the node key if necessary in the process.\n\t * \n\t * @param nodeName the name of the node\n\t * @param ACLUpdates the updates to the ACL\n\t * @return the updated ACL\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic ACL updateACL(ContentName nodeName, ArrayList<ACL.ACLOperation> ACLUpdates) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\t\tACLObject currentACL = getACLObjectForNodeIfExists(nodeName);\n\t\tACL newACL = null;\n\t\t\n\t\tif (null != currentACL) {\n\t\t\tnewACL = currentACL.acl();\n\t\t} else {\n\t\t\tLog.info(\"Adding brand new ACL to node {0}\", nodeName);\n\t\t\t//TODO: if no operations is specified, then a new empty ACL is created...\n\t\t\tnewACL = new ACL();\n\t\t}\n\t\t\n\t\tLinkedList<Link> newReaders = newACL.update(ACLUpdates);\n\t\t\n\t\tif ((null == newReaders) || (null == currentACL)) {\n\t\t\t// null newReaders means we revoked someone.\n\t\t\t// null currentACL means we're starting from scratch\n\t\t\t// Set the ACL and update the node key.\n\t\t\treturn setACL(nodeName, newACL);\n\t\t}\n\t\t\n\t\t// If we get back a list of new readers, it means all we have to do\n\t\t// is add key blocks for them, not update the node key. (And it means\n\t\t// we have a node key for this node.)\n\t\t// Wait to save the new ACL till we are sure we're allowed to do this.\n\t\tKeyDirectory keyDirectory = null;\n\t\ttry {\n\t\t\t// If we can't read the node key, we can't update. Get the effective node key.\n\t\t\t// Better be a node key here... and we'd better be allowed to read it.\n\t\t\tNodeKey latestNodeKey = getLatestNodeKeyForNode(nodeName);\n\t\t\tif (null == latestNodeKey) {\n\t\t\t\tLog.info(\"Cannot read the latest node key for {0}\", nodeName);\n\t\t\t\tthrow new AccessDeniedException(\"Cannot read the latest node key for \" + nodeName);\n\t\t\t}\n\t\t\t\n\t\t\tkeyDirectory = new KeyDirectory(this, latestNodeKey.storedNodeKeyName(), handle());\n\n\t\t\tfor (Link principal : newReaders) {\n\t\t\t\tPublicKeyObject latestKey = getLatestKeyForPrincipal(principal);\n\t\t\t\tif (!latestKey.available()) {\n\t\t\t\t\tlatestKey.waitForData(SystemConfiguration.getDefaultTimeout());\n\t\t\t\t}\n\t\t\t\tif (latestKey.available()) {\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\t\tLog.info(\"updateACL: Adding wrapped key block for reader: \" + latestKey.getVersionedName());\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tkeyDirectory.addWrappedKeyBlock(latestNodeKey.nodeKey(), latestKey.getVersionedName(), latestKey.publicKey());\n\t\t\t\t\t} catch (VersionMissingException e) {\n\t\t\t\t\t\tLog.warning(\"UNEXPECTED: latest key for principal: \" + latestKey.getVersionedName() + \" has no version? Skipping.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Do we use an old key or give up?\n\t\t\t\t\tLog.info(\"updateACL: No key for {0} found. Skipping.\", principal);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (null != keyDirectory) {\n\t\t\t\tkeyDirectory.stopEnumerating();\n\t\t\t}\n\t\t}\n\t\t// If we got here, we got the node key we were updating, so we are allowed\n\t\t// to at least read this stuff (though maybe not write it). Save the acl.\n\t\tcurrentACL.save(newACL);\n\t\treturn newACL;\n\t\t\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Look for an ACL that is on dataNodeName or above, but below stopPoint. If stopPoint is\n\t * null, then take it to be the root for this AccessControlManager (which we assume to have\n\t * an ACL).\n\t * @param dataNodeName\n\t * @param stopPoint\n\t * @return\n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t */\n\tprivate ACLObject findAncestorWithACLSerial(ContentName dataNodeName, ContentName stopPoint) throws ContentDecodingException, IOException {\n\n\t\t// If dataNodeName is the root of this AccessControlManager, there can be no ACL between\n\t\t// dataNodeName (inclusive) and the root (exclusive), so return null.\n\t\tif (getNamespaceRoot().equals(dataNodeName)) return null;\n\t\t\n\t\tif (null == stopPoint)  {\n\t\t\tstopPoint = getNamespaceRoot();\n\t\t} else if (!getNamespaceRoot().isPrefixOf(stopPoint)) {\n\t\t\tLog.warning(\"findAncestorWithACL: Stopping point {0} must be an ancestor of the starting point {1}!\", \n\t\t\t\t\tstopPoint, dataNodeName);\n\t\t\tthrow new IOException(\"findAncestorWithACL: invalid search space: stopping point \" + stopPoint + \" must be an ancestor of the starting point \" +\n\t\t\t\t\tdataNodeName + \"!\");\n\t\t}\n\t\tLog.info(\"findAncestorWithACL: start point {0}, stop before {1}\", dataNodeName, stopPoint);\n\t\tint stopCount = stopPoint.count();\n\t\t\n\t\tACLObject ancestorACLObject = null;\n\t\tContentName parentName = dataNodeName;\n\t\tContentName nextParentName = null;\n\t\twhile (null == ancestorACLObject) {\n\t\t\tancestorACLObject = getACLObjectForNodeIfExists(parentName);\n\t\t\tif (null != ancestorACLObject) {\n\t\t\t\tif (ancestorACLObject.isGone()) {\n\t\t\t\t\tLog.info(\"Found an ACL object at \" + ancestorACLObject.getVersionedName() + \" but its GONE.\");\n\t\t\t\t\tancestorACLObject = null;\n\t\t\t\t} else {\n\t\t\t\t\t// got one\n\t\t\t\t\tLog.info(\"Found an ACL object at \" + ancestorACLObject.getVersionedName());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextParentName = parentName.parent();\n\t\t\tLog.info(\"findAncestorWithACL: no ACL object at node {0}, looking next at {1}\", parentName, nextParentName);\n\t\t\t// stop looking once we're above our namespace, or if we've already checked the top level\n\t\t\tif (parentName.count() == stopCount) {\n\t\t\t\tLog.info(\"findAncestorWithACL: giving up, next search point would be {0}, stop point is {1}, no ACL found\",\n\t\t\t\t\t\tparentName, stopPoint);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparentName = nextParentName;\n\t\t}\n\t\tif (null == ancestorACLObject) {\n\t\t\tLog.info(\n\t\t\t\t\t\"No ACL available in ancestor tree between {0} and {1} (not-inclusive)  out of namespace rooted at {2}.\",\n\t\t\t\t\tdataNodeName, stopPoint, getNamespaceRoot());\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(\"Found ACL for \" + dataNodeName + \" at ancestor :\" + ancestorACLObject.getVersionedName());\n\t\treturn ancestorACLObject;\n\t}","id":3843,"modified_method":"/**\n\t * Look for an ACL that is on dataNodeName or above, but below stopPoint. If stopPoint is\n\t * null, then take it to be the root for this AccessControlManager (which we assume to have\n\t * an ACL).\n\t * @param dataNodeName\n\t * @param stopPoint\n\t * @return\n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t */\n\tprivate ACLObject findAncestorWithACLSerial(ContentName dataNodeName, ContentName stopPoint) throws ContentDecodingException, IOException {\n\n\t\t// If dataNodeName is the root of this AccessControlManager, there can be no ACL between\n\t\t// dataNodeName (inclusive) and the root (exclusive), so return null.\n\t\tif (getNamespaceRoot().equals(dataNodeName)) return null;\n\t\t\n\t\tif (null == stopPoint)  {\n\t\t\tstopPoint = getNamespaceRoot();\n\t\t} else if (!getNamespaceRoot().isPrefixOf(stopPoint)) {\n\t\t\tLog.warning(\"findAncestorWithACL: Stopping point {0} must be an ancestor of the starting point {1}!\", \n\t\t\t\t\tstopPoint, dataNodeName);\n\t\t\tthrow new IOException(\"findAncestorWithACL: invalid search space: stopping point \" + stopPoint + \" must be an ancestor of the starting point \" +\n\t\t\t\t\tdataNodeName + \"!\");\n\t\t}\n\t\tLog.info(\"findAncestorWithACL: start point {0}, stop before {1}\", dataNodeName, stopPoint);\n\t\tint stopCount = stopPoint.count();\n\t\t\n\t\tACLObject ancestorACLObject = null;\n\t\tContentName parentName = dataNodeName;\n\t\tContentName nextParentName = null;\n\t\twhile (null == ancestorACLObject) {\n\t\t\tancestorACLObject = getACLObjectForNodeIfExists(parentName);\n\t\t\tif (null != ancestorACLObject) {\n\t\t\t\tif (ancestorACLObject.isGone()) {\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\t\tLog.info(\"Found an ACL object at {0} but its GONE.\", ancestorACLObject.getVersionedName());\n\t\t\t\t\t}\n\t\t\t\t\tancestorACLObject = null;\n\t\t\t\t} else {\n\t\t\t\t\t// got one\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\t\tLog.info(\"Found an ACL object at {0}\", ancestorACLObject.getVersionedName());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextParentName = parentName.parent();\n\t\t\tLog.info(\"findAncestorWithACL: no ACL object at node {0}, looking next at {1}\", parentName, nextParentName);\n\t\t\t// stop looking once we're above our namespace, or if we've already checked the top level\n\t\t\tif (parentName.count() == stopCount) {\n\t\t\t\tLog.info(\"findAncestorWithACL: giving up, next search point would be {0}, stop point is {1}, no ACL found\",\n\t\t\t\t\t\tparentName, stopPoint);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparentName = nextParentName;\n\t\t}\n\t\tif (null == ancestorACLObject) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\n\t\t\t\t\t\t\"No ACL available in ancestor tree between {0} and {1} (not-inclusive)  out of namespace rooted at {2}.\",\n\t\t\t\t\t\tdataNodeName, stopPoint, getNamespaceRoot());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"Found ACL for {0} at ancestor {1}: \", dataNodeName, ancestorACLObject.getVersionedName());\n\t\t}\n\t\treturn ancestorACLObject;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * We've looked for a node key we can decrypt at the expected node key location,\n\t * but no dice. See if a new ACL has been interposed granting us rights at a lower\n\t * portion of the tree.\n\t * @param dataNodeName\n\t * @param wrappingKeyName\n\t * @param wrappingKeyIdentifier\n\t * @return\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tprotected NodeKey getNodeKeyUsingInterposedACL(ContentName dataNodeName,\n\t\t\tContentName wrappingKeyName, byte[] wrappingKeyIdentifier) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\n\t\tContentName stopPoint = AccessControlProfile.accessRoot(wrappingKeyName);\n\t\tLog.info(\"getNodeKeyUsingInterposedACL: looking for an ACL above {0} but below {1}\",\n\t\t\t\tdataNodeName, stopPoint);\n\t\tACLObject nearestACL = findAncestorWithACL(dataNodeName, stopPoint);\n\t\t// TODO update to make sure non-gone....\n\t\tif (null == nearestACL) {\n\t\t\tLog.info(\"Node key: \" + wrappingKeyName + \" is the nearest ACL to \" + dataNodeName);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tNodeKey currentNodeKey = getLatestNodeKeyForNode(GroupAccessControlProfile.accessRoot(nearestACL.getVersionedName()));\n\t\t\n\t\t// We have retrieved the current node key at the node where the ACL was interposed.\n\t\t// But the data key is wrapped in the previous node key that was at this node prior to the ACL interposition.\n\t\t// So we need to retrieve the previous node key, which was wrapped with KeyDirectory.addPreviousKeyBlock \n\t\t// at the time the ACL was interposed.\n\t\tContentName previousKeyName = ContentName.fromNative(currentNodeKey.storedNodeKeyName(), GroupAccessControlProfile.PREVIOUS_KEY_NAME);\n\t\tLog.finer(\"getNodeKeyUsingInterposedACL: retrieving previous key at {0}\", previousKeyName);\n\t\tWrappedKeyObject wrappedPreviousNodeKey = new WrappedKeyObject(previousKeyName, _handle);\n\t\twrappedPreviousNodeKey.update();\n\t\tKey pnk = wrappedPreviousNodeKey.wrappedKey().unwrapKey(currentNodeKey.nodeKey());\n\t\tLog.finer(\"getNodeKeyUsingInterposedACL: returning previous node key for node {0}\", currentNodeKey.storedNodeKeyName());\n\t\tNodeKey previousNodeKey = new NodeKey(currentNodeKey.storedNodeKeyName(), pnk);\n\n\t\treturn previousNodeKey;\n\t}","id":3844,"modified_method":"/**\n\t * We've looked for a node key we can decrypt at the expected node key location,\n\t * but no dice. See if a new ACL has been interposed granting us rights at a lower\n\t * portion of the tree.\n\t * @param dataNodeName\n\t * @param wrappingKeyName\n\t * @param wrappingKeyIdentifier\n\t * @return\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tprotected NodeKey getNodeKeyUsingInterposedACL(ContentName dataNodeName,\n\t\t\tContentName wrappingKeyName, byte[] wrappingKeyIdentifier) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\n\t\tContentName stopPoint = AccessControlProfile.accessRoot(wrappingKeyName);\n\t\tLog.info(\"getNodeKeyUsingInterposedACL: looking for an ACL above {0} but below {1}\",\n\t\t\t\tdataNodeName, stopPoint);\n\t\tACLObject nearestACL = findAncestorWithACL(dataNodeName, stopPoint);\n\t\t// TODO update to make sure non-gone....\n\t\tif (null == nearestACL) {\n\t\t\tLog.info(\"Node key {0} is the nearest ACL to {1}\", wrappingKeyName , dataNodeName);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tNodeKey currentNodeKey = getLatestNodeKeyForNode(GroupAccessControlProfile.accessRoot(nearestACL.getVersionedName()));\n\t\t\n\t\t// We have retrieved the current node key at the node where the ACL was interposed.\n\t\t// But the data key is wrapped in the previous node key that was at this node prior to the ACL interposition.\n\t\t// So we need to retrieve the previous node key, which was wrapped with KeyDirectory.addPreviousKeyBlock \n\t\t// at the time the ACL was interposed.\n\t\tContentName previousKeyName = ContentName.fromNative(currentNodeKey.storedNodeKeyName(), GroupAccessControlProfile.PREVIOUS_KEY_NAME);\n\t\tLog.finer(\"getNodeKeyUsingInterposedACL: retrieving previous key at {0}\", previousKeyName);\n\t\tWrappedKeyObject wrappedPreviousNodeKey = new WrappedKeyObject(previousKeyName, _handle);\n\t\twrappedPreviousNodeKey.update();\n\t\tKey pnk = wrappedPreviousNodeKey.wrappedKey().unwrapKey(currentNodeKey.nodeKey());\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"getNodeKeyUsingInterposedACL: returning previous node key for node {0}\", currentNodeKey.storedNodeKeyName());\n\t\t}\n\t\tNodeKey previousNodeKey = new NodeKey(currentNodeKey.storedNodeKeyName(), pnk);\n\n\t\treturn previousNodeKey;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Make a new node key and encrypt it under the given ACL.\n\t * If there is a previous node key (oldEffectiveNodeKey not null), it is wrapped in the new node key.\n\t * Put all the blocks into the aggregating writer, but don't flush.\n\t * \n\t * @param nodeName\n\t * @param oldEffectiveNodeKey\n\t * @param effectiveACL\n\t * @return\n\t * @throws IOException \n\t * @throws ContentGoneException \n\t * @throws ContentNotReadyException \n\t * @throws ContentEncodingException \n\t * @throws InvalidKeyException \n\t */\n\tprotected NodeKey generateNewNodeKey(ContentName nodeName, NodeKey oldEffectiveNodeKey, ACL effectiveACL) \n\t\t\tthrows InvalidKeyException, ContentEncodingException, ContentNotReadyException, \n\t\t\t\t\tContentGoneException, IOException {\n\t\t// Get the name of the key directory; this is unversioned. Make a new version of it.\n\t\tContentName nodeKeyDirectoryName = VersioningProfile.addVersion(GroupAccessControlProfile.nodeKeyName(nodeName));\n\t\tLog.info(\"GenerateNewNodeKey: generating new node key \" + nodeKeyDirectoryName);\n\t\tLog.finer(\"GenerateNewNodeKey: for node {0} with old effective node key {1}\", nodeName, oldEffectiveNodeKey);\n\t\t\n\t\t// Now, generate the node key.\n\t\tif (effectiveACL.publiclyReadable()) {\n\t\t\t// TODO Put something here that will represent public; need to then make it so that key-reading code will do\n\t\t\t// the right thing when it encounters it.\n\t\t\tthrow new UnsupportedOperationException(\"Need to implement public node key representation!\");\n\t\t}\n\t\t\n\t\tbyte [] nodeKeyBytes = new byte[NodeKey.DEFAULT_NODE_KEY_LENGTH];\n\t\t_random.nextBytes(nodeKeyBytes);\n\t\tKey nodeKey = new SecretKeySpec(nodeKeyBytes, NodeKey.DEFAULT_NODE_KEY_ALGORITHM);\n\t\tLog.finer(\"GenerateNewNodeKey: for node {0} the new node key is {1}\", nodeName, DataUtils.printHexBytes(nodeKey.getEncoded()));\n\t\t\n\t\t// Now, wrap it under the keys listed in its ACL.\n\t\t\n\t\t// Make a key directory. If we give it a versioned name, it will start enumerating it, but won't block.\n\t\tKeyDirectory nodeKeyDirectory = null;\n\t\tNodeKey theNodeKey = null;\n\t\ttry {\n\t\t\tnodeKeyDirectory = new KeyDirectory(this, nodeKeyDirectoryName, handle());\n\t\t\ttheNodeKey = new NodeKey(nodeKeyDirectoryName, nodeKey);\n\t\t\t// Add a key block for every reader on the ACL. As managers and writers can read, they are all readers.\n\t\t\t// TODO -- pulling public keys here; could be slow; might want to manage concurrency over acl.\n\t\t\tfor (Link aclEntry : effectiveACL.contents()) {\n\t\t\t\tPublicKeyObject entryPublicKey = null;\n\t\t\t\tif (groupManager().isGroup(aclEntry)) {\n\t\t\t\t\tentryPublicKey = groupManager().getLatestPublicKeyForGroup(aclEntry);\n\t\t\t\t} else {\n\t\t\t\t\t// Calls update. Will get latest version if name unversioned.\n\t\t\t\t\tif (aclEntry.targetAuthenticator() != null) {\n\t\t\t\t\t\tentryPublicKey = new PublicKeyObject(aclEntry.targetName(), aclEntry.targetAuthenticator().publisher(), handle());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentryPublicKey = new PublicKeyObject(aclEntry.targetName(), handle());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentryPublicKey.waitForData(SystemConfiguration.getDefaultTimeout());\n\t\t\t\ttry {\n\t\t\t\t\tnodeKeyDirectory.addWrappedKeyBlock(nodeKey, entryPublicKey.getVersionedName(), entryPublicKey.publicKey());\n\t\t\t\t} catch (VersionMissingException ve) {\n\t\t\t\t\tLog.logException(\"Unexpected version missing exception for public key \" + entryPublicKey.getVersionedName(), ve);\n\t\t\t\t\tthrow new IOException(\"Unexpected version missing exception for public key \" + entryPublicKey.getVersionedName() + \": \" + ve);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add a superseded by block to the previous key. Two cases: old effective node key is at the same level\n\t\t\t// as us (we are superseding it entirely), or we are interposing a key (old key is above or below us).\n\t\t\t// OK, here are the options:\n\t\t\t// Replaced node key is a derived node key -- we are interposing an ACL\n\t\t\t// Replaced node key is a stored node key \n\t\t\t//\t -- we are updating that node key to a new version\n\t\t\t// \t\t\tNK/vn replaced by NK/vn+k -- new node key will be later version of previous node key\n\t\t\t//   -- we don't get called if we are deleting an ACL here -- no new node key is added.\n\t\t\tif (oldEffectiveNodeKey != null) {\n\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is not null.\");\n\t\t\t\tif (oldEffectiveNodeKey.isDerivedNodeKey()) {\n\t\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is derived node key.\");\n\t\t\t\t\t// Interposing an ACL. \n\t\t\t\t\t// Add a previous key block wrapping the previous key. There is nothing to link to.\n\t\t\t\t\tnodeKeyDirectory.addPreviousKeyBlock(oldEffectiveNodeKey.nodeKey(), nodeKeyDirectoryName, nodeKey);\n\t\t\t\t} else {\n\t\t\t\t\t// We're replacing a previous version of this key. New version should have a previous key\n\t\t\t\t\t// entry \n\t\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is not a derived node key.\");\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!VersioningProfile.isLaterVersionOf(nodeKeyDirectoryName, oldEffectiveNodeKey.storedNodeKeyName())) {\n\t\t\t\t\t\t\tLog.warning(\"GenerateNewNodeKey: Unexpected: replacing node key stored at \" + oldEffectiveNodeKey.storedNodeKeyName() + \" with new node key \" + \n\t\t\t\t\t\t\t\t\tnodeKeyDirectoryName + \" but latter is not later version of the former.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (VersionMissingException vex) {\n\t\t\t\t\t\tLog.warning(\"Very unexpected version missing exception when replacing node key : \" + vex);\n\t\t\t\t\t}\n\t\t\t\t\t// Add a previous key link to the old version of the key.\n\t\t\t\t\t// TODO do we need to add publisher?\n\t\t\t\t\tnodeKeyDirectory.waitForChildren();\n\t\t\t\t\tnodeKeyDirectory.addPreviousKeyLink(oldEffectiveNodeKey.storedNodeKeyName(), null);\n\t\t\t\t\t// OK, just add superseded-by block to the old directory.\n\t\t\t\t\tKeyDirectory.addSupersededByBlock(\n\t\t\t\t\t\t\toldEffectiveNodeKey.storedNodeKeyName(), oldEffectiveNodeKey.nodeKey(), \n\t\t\t\t\t\t\ttheNodeKey.storedNodeKeyName(), theNodeKey.storedNodeKeyID(), theNodeKey.nodeKey(), handle());\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (null != nodeKeyDirectory) {\n\t\t\t\tnodeKeyDirectory.stopEnumerating();\n\t\t\t}\n\t\t}\n\t\t// Return the key for use, along with its name.\n\t\treturn theNodeKey;\n\t}","id":3845,"modified_method":"/**\n\t * Make a new node key and encrypt it under the given ACL.\n\t * If there is a previous node key (oldEffectiveNodeKey not null), it is wrapped in the new node key.\n\t * Put all the blocks into the aggregating writer, but don't flush.\n\t * \n\t * @param nodeName\n\t * @param oldEffectiveNodeKey\n\t * @param effectiveACL\n\t * @return\n\t * @throws IOException \n\t * @throws ContentGoneException \n\t * @throws ContentNotReadyException \n\t * @throws ContentEncodingException \n\t * @throws InvalidKeyException \n\t */\n\tprotected NodeKey generateNewNodeKey(ContentName nodeName, NodeKey oldEffectiveNodeKey, ACL effectiveACL) \n\t\t\tthrows InvalidKeyException, ContentEncodingException, ContentNotReadyException, \n\t\t\t\t\tContentGoneException, IOException {\n\t\t// Get the name of the key directory; this is unversioned. Make a new version of it.\n\t\tContentName nodeKeyDirectoryName = VersioningProfile.addVersion(GroupAccessControlProfile.nodeKeyName(nodeName));\n\t\tLog.info(\"GenerateNewNodeKey: generating new node key {0}\", nodeKeyDirectoryName);\n\t\tLog.finer(\"GenerateNewNodeKey: for node {0} with old effective node key {1}\", nodeName, oldEffectiveNodeKey);\n\t\t\n\t\t// Now, generate the node key.\n\t\tif (effectiveACL.publiclyReadable()) {\n\t\t\t// TODO Put something here that will represent public; need to then make it so that key-reading code will do\n\t\t\t// the right thing when it encounters it.\n\t\t\tthrow new UnsupportedOperationException(\"Need to implement public node key representation!\");\n\t\t}\n\t\t\n\t\tbyte [] nodeKeyBytes = new byte[NodeKey.DEFAULT_NODE_KEY_LENGTH];\n\t\t_random.nextBytes(nodeKeyBytes);\n\t\tKey nodeKey = new SecretKeySpec(nodeKeyBytes, NodeKey.DEFAULT_NODE_KEY_ALGORITHM);\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"GenerateNewNodeKey: for node {0} the new node key is {1}\", nodeName, DataUtils.printHexBytes(nodeKey.getEncoded()));\n\t\t}\n\t\t\n\t\t// Now, wrap it under the keys listed in its ACL.\n\t\t\n\t\t// Make a key directory. If we give it a versioned name, it will start enumerating it, but won't block.\n\t\tKeyDirectory nodeKeyDirectory = null;\n\t\tNodeKey theNodeKey = null;\n\t\ttry {\n\t\t\tnodeKeyDirectory = new KeyDirectory(this, nodeKeyDirectoryName, handle());\n\t\t\ttheNodeKey = new NodeKey(nodeKeyDirectoryName, nodeKey);\n\t\t\t// Add a key block for every reader on the ACL. As managers and writers can read, they are all readers.\n\t\t\t// TODO -- pulling public keys here; could be slow; might want to manage concurrency over acl.\n\t\t\tfor (Link aclEntry : effectiveACL.contents()) {\n\t\t\t\tPublicKeyObject entryPublicKey = null;\n\t\t\t\tif (groupManager().isGroup(aclEntry)) {\n\t\t\t\t\tentryPublicKey = groupManager().getLatestPublicKeyForGroup(aclEntry);\n\t\t\t\t} else {\n\t\t\t\t\t// Calls update. Will get latest version if name unversioned.\n\t\t\t\t\tif (aclEntry.targetAuthenticator() != null) {\n\t\t\t\t\t\tentryPublicKey = new PublicKeyObject(aclEntry.targetName(), aclEntry.targetAuthenticator().publisher(), handle());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentryPublicKey = new PublicKeyObject(aclEntry.targetName(), handle());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentryPublicKey.waitForData(SystemConfiguration.getDefaultTimeout());\n\t\t\t\ttry {\n\t\t\t\t\tnodeKeyDirectory.addWrappedKeyBlock(nodeKey, entryPublicKey.getVersionedName(), entryPublicKey.publicKey());\n\t\t\t\t} catch (VersionMissingException ve) {\n\t\t\t\t\tLog.logException(\"Unexpected version missing exception for public key \" + entryPublicKey.getVersionedName(), ve);\n\t\t\t\t\tthrow new IOException(\"Unexpected version missing exception for public key \" + entryPublicKey.getVersionedName() + \": \" + ve);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add a superseded by block to the previous key. Two cases: old effective node key is at the same level\n\t\t\t// as us (we are superseding it entirely), or we are interposing a key (old key is above or below us).\n\t\t\t// OK, here are the options:\n\t\t\t// Replaced node key is a derived node key -- we are interposing an ACL\n\t\t\t// Replaced node key is a stored node key \n\t\t\t//\t -- we are updating that node key to a new version\n\t\t\t// \t\t\tNK/vn replaced by NK/vn+k -- new node key will be later version of previous node key\n\t\t\t//   -- we don't get called if we are deleting an ACL here -- no new node key is added.\n\t\t\tif (oldEffectiveNodeKey != null) {\n\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is not null.\");\n\t\t\t\tif (oldEffectiveNodeKey.isDerivedNodeKey()) {\n\t\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is derived node key.\");\n\t\t\t\t\t// Interposing an ACL. \n\t\t\t\t\t// Add a previous key block wrapping the previous key. There is nothing to link to.\n\t\t\t\t\tnodeKeyDirectory.addPreviousKeyBlock(oldEffectiveNodeKey.nodeKey(), nodeKeyDirectoryName, nodeKey);\n\t\t\t\t} else {\n\t\t\t\t\t// We're replacing a previous version of this key. New version should have a previous key\n\t\t\t\t\t// entry \n\t\t\t\t\tLog.finer(\"GenerateNewNodeKey: old effective node key is not a derived node key.\");\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!VersioningProfile.isLaterVersionOf(nodeKeyDirectoryName, oldEffectiveNodeKey.storedNodeKeyName())) {\n\t\t\t\t\t\t\tLog.warning(\"GenerateNewNodeKey: Unexpected: replacing node key stored at {0} with new node key {1}\" + \n\t\t\t\t\t\t\t\t\t\" but latter is not later version of the former.\", oldEffectiveNodeKey.storedNodeKeyName(), nodeKeyDirectoryName);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (VersionMissingException vex) {\n\t\t\t\t\t\tLog.warning(\"Very unexpected version missing exception when replacing node key : {0}\", vex);\n\t\t\t\t\t}\n\t\t\t\t\t// Add a previous key link to the old version of the key.\n\t\t\t\t\t// TODO do we need to add publisher?\n\t\t\t\t\tnodeKeyDirectory.waitForChildren();\n\t\t\t\t\tnodeKeyDirectory.addPreviousKeyLink(oldEffectiveNodeKey.storedNodeKeyName(), null);\n\t\t\t\t\t// OK, just add superseded-by block to the old directory.\n\t\t\t\t\tKeyDirectory.addSupersededByBlock(\n\t\t\t\t\t\t\toldEffectiveNodeKey.storedNodeKeyName(), oldEffectiveNodeKey.nodeKey(), \n\t\t\t\t\t\t\ttheNodeKey.storedNodeKeyName(), theNodeKey.storedNodeKeyID(), theNodeKey.nodeKey(), handle());\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (null != nodeKeyDirectory) {\n\t\t\t\tnodeKeyDirectory.stopEnumerating();\n\t\t\t}\n\t\t}\n\t\t// Return the key for use, along with its name.\n\t\treturn theNodeKey;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * \n\t * @param nodeName\n\t * @param wko\n\t * @return\n\t * @throws ContentNotReadyException\n\t * @throws ContentGoneException\n\t * @throws InvalidKeyException\n\t * @throws ContentEncodingException\n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getNodeKeyForObject(ContentName nodeName, WrappedKeyObject wko) \n\t\t\tthrows ContentNotReadyException, ContentGoneException, InvalidKeyException, ContentEncodingException,\n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t\n\t\t// First, we go and look for the node key where the data key suggests\n\t\t// it should be, and attempt to decrypt it from there.\n\t\tNodeKey nk = null;\n\t\ttry {\n\t\t\tLog.info(\"getNodeKeyForObject: trying to get specific node key at {0}\", wko.wrappedKey().wrappingKeyName());\n\t\t\tnk = getSpecificNodeKey(wko.wrappedKey().wrappingKeyName(), \n\t\t\t\t\t\t\t\t\t\twko.wrappedKey().wrappingKeyIdentifier());\n\t\t\tLog.info(\"getNodeKeyForObject: got specific node key {0} at {1}\", nk, wko.wrappedKey().wrappingKeyName());\n\t\t} catch (AccessDeniedException ex) {\n\t\t\t// ignore\n\t\t\tLog.info(\"getNodeKeyForObject: ignoring access denied exception as we're gong to try harder: \" + ex.getMessage());\n\t\t}\n\t\tif (null == nk) {\n\t\t\tLog.info(\"getNodeKeyForObject: trying to get node key using interposed ACL for {0}\", wko.wrappedKey().wrappingKeyName());\n\t\t\t// OK, we will have gotten an exception if the node key simply didn't exist\n\t\t\t// there, so this means that we don't have rights to read it there.\n\t\t\t// The only way we might have rights not visible from this link is if an\n\t\t\t// ACL has been interposed between where we are and the node key, and that\n\t\t\t// ACL does give us rights.\n\t\t\tnk = getNodeKeyUsingInterposedACL(nodeName, wko.wrappedKey().wrappingKeyName(), \n\t\t\t\t\twko.wrappedKey().wrappingKeyIdentifier());\n\t\t\tif (null == nk) {\n\t\t\t\t// Still can't find one we can read. Give up. Return null, and allow caller to throw the \n\t\t\t\t// access exception.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tLog.info(\"getNodeKeyForObject: retrieved stored node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), nk);\n\t\tNodeKey enk = nk.computeDescendantNodeKey(nodeName, nodeKeyLabel());\n\t\tLog.info(\"getNodeKeyForObject: computed effective node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), enk);\n\t\treturn enk;\n\t}","id":3846,"modified_method":"/**\n\t * \n\t * @param nodeName\n\t * @param wko\n\t * @return\n\t * @throws ContentNotReadyException\n\t * @throws ContentGoneException\n\t * @throws InvalidKeyException\n\t * @throws ContentEncodingException\n\t * @throws ContentDecodingException\n\t * @throws IOException\n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getNodeKeyForObject(ContentName nodeName, WrappedKeyObject wko) \n\t\t\tthrows ContentNotReadyException, ContentGoneException, InvalidKeyException, ContentEncodingException,\n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t\n\t\t// First, we go and look for the node key where the data key suggests\n\t\t// it should be, and attempt to decrypt it from there.\n\t\tNodeKey nk = null;\n\t\ttry {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getNodeKeyForObject: trying to get specific node key at {0}\", wko.wrappedKey().wrappingKeyName());\n\t\t\t}\n\t\t\tnk = getSpecificNodeKey(wko.wrappedKey().wrappingKeyName(), \n\t\t\t\t\t\t\t\t\t\twko.wrappedKey().wrappingKeyIdentifier());\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getNodeKeyForObject: got specific node key {0} at {1}\", nk, wko.wrappedKey().wrappingKeyName());\n\t\t\t}\n\t\t} catch (AccessDeniedException ex) {\n\t\t\t// ignore\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getNodeKeyForObject: ignoring access denied exception as we're gong to try harder: {0}\", ex.getMessage());\n\t\t\t}\n\t\t}\n\t\tif (null == nk) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getNodeKeyForObject: trying to get node key using interposed ACL for {0}\", wko.wrappedKey().wrappingKeyName());\n\t\t\t}\n\t\t\t// OK, we will have gotten an exception if the node key simply didn't exist\n\t\t\t// there, so this means that we don't have rights to read it there.\n\t\t\t// The only way we might have rights not visible from this link is if an\n\t\t\t// ACL has been interposed between where we are and the node key, and that\n\t\t\t// ACL does give us rights.\n\t\t\tnk = getNodeKeyUsingInterposedACL(nodeName, wko.wrappedKey().wrappingKeyName(), \n\t\t\t\t\twko.wrappedKey().wrappingKeyIdentifier());\n\t\t\tif (null == nk) {\n\t\t\t\t// Still can't find one we can read. Give up. Return null, and allow caller to throw the \n\t\t\t\t// access exception.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"getNodeKeyForObject: retrieved stored node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), nk);\n\t\t}\n\t\tNodeKey enk = nk.computeDescendantNodeKey(nodeName, nodeKeyLabel());\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"getNodeKeyForObject: computed effective node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), enk);\n\t\t}\n\t\treturn enk;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Do we need to update this node key?\n\t * First, we look to see whether or not we know the key is dirty -- i.e.\n\t * does it have a superseded block (if it's gone, it will also have a \n\t * superseded block). If not, we have to really check...\n\t * Basically, we look at all the entities this node key is encrypted for,\n\t * and determine whether any of them have a new version of their public\n\t * key. If so, the node key is dirty.\n\t * \n\t * The initial implementation of this will be simple and slow -- iterating through\n\t * groups and assuming the active object system will keep updating itself whenever\n\t * a new key appears. Eventually, we might want an index directory of all the\n\t * versions of keys, so that one name enumeration request might give us information\n\t * about whether keys have been updated. (Or some kind of aggregate versioning,\n\t * that tell us a) whether any groups have changed their versions, or b) just the\n\t * ones we care about have.) \n\t * \n\t * This can be called by anyone -- the data about whether a node key is dirty\n\t * is visible to anyone. Fixing a dirty node key requires access, though.\n\t * @param theNodeKeyName this might be the name of the node where the NK is stored,\n\t *    or the NK name itself.\n\t *    We assume this exists -- that there at some point has been a node key here.\n\t *    TODO ephemeral node key naming\n\t * @return\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic boolean nodeKeyIsDirty(ContentName theNodeKeyName) throws ContentDecodingException, IOException {\n\n\t\t// first, is this a node key name?\n\t\tif (!GroupAccessControlProfile.isNodeKeyName(theNodeKeyName)) {\n\t\t\t// assume it's a data node name.\n\t\t\ttheNodeKeyName = GroupAccessControlProfile.nodeKeyName(theNodeKeyName);\n\t\t}\n\t\t// get the requested version of this node key; or if unversioned, get the latest.\n\t\tKeyDirectory nodeKeyDirectory = null;\n\t\ttry {\n\t\t\tnodeKeyDirectory = new KeyDirectory(this, theNodeKeyName, handle());\n\t\t\tnodeKeyDirectory.waitForChildren();\n\n\t\t\tif (null == nodeKeyDirectory) {\n\t\t\t\tthrow new IOException(\"Cannot get node key directory for : \" + theNodeKeyName);\n\t\t\t}\n\t\t\tif (nodeKeyDirectory.hasSupersededBlock()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (PrincipalInfo principal : nodeKeyDirectory.getCopyOfPrincipals().values()) {\n\t\t\t\tif (principal.isGroup()) {\n\t\t\t\t\tGroup theGroup = groupManager().getGroup(principal.friendlyName());\n\t\t\t\t\tif (theGroup.publicKeyVersion().after(principal.versionTimestamp())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// DKS TODO -- for now, don't handle versioning of non-group keys\n\t\t\t\t\tLog.info(\"User key for \" + principal.friendlyName() + \", not checking version.\");\n\t\t\t\t\t// Technically, we're not handling versioning for user keys, but be nice. Start\n\t\t\t\t\t// by seeing if we have a link to the key in our user space.\n\t\t\t\t\t// If the principal isn't available in our enumerated list, have to go get its key\n\t\t\t\t\t// from the wrapped key object.\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t} finally {\n\t\t\tif (null != nodeKeyDirectory)\n\t\t\t\tnodeKeyDirectory.stopEnumerating();\n\t\t}\n\t}","id":3847,"modified_method":"/**\n\t * Do we need to update this node key?\n\t * First, we look to see whether or not we know the key is dirty -- i.e.\n\t * does it have a superseded block (if it's gone, it will also have a \n\t * superseded block). If not, we have to really check...\n\t * Basically, we look at all the entities this node key is encrypted for,\n\t * and determine whether any of them have a new version of their public\n\t * key. If so, the node key is dirty.\n\t * \n\t * The initial implementation of this will be simple and slow -- iterating through\n\t * groups and assuming the active object system will keep updating itself whenever\n\t * a new key appears. Eventually, we might want an index directory of all the\n\t * versions of keys, so that one name enumeration request might give us information\n\t * about whether keys have been updated. (Or some kind of aggregate versioning,\n\t * that tell us a) whether any groups have changed their versions, or b) just the\n\t * ones we care about have.) \n\t * \n\t * This can be called by anyone -- the data about whether a node key is dirty\n\t * is visible to anyone. Fixing a dirty node key requires access, though.\n\t * @param theNodeKeyName this might be the name of the node where the NK is stored,\n\t *    or the NK name itself.\n\t *    We assume this exists -- that there at some point has been a node key here.\n\t *    TODO ephemeral node key naming\n\t * @return\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic boolean nodeKeyIsDirty(ContentName theNodeKeyName) throws ContentDecodingException, IOException {\n\n\t\t// first, is this a node key name?\n\t\tif (!GroupAccessControlProfile.isNodeKeyName(theNodeKeyName)) {\n\t\t\t// assume it's a data node name.\n\t\t\ttheNodeKeyName = GroupAccessControlProfile.nodeKeyName(theNodeKeyName);\n\t\t}\n\t\t// get the requested version of this node key; or if unversioned, get the latest.\n\t\tKeyDirectory nodeKeyDirectory = null;\n\t\ttry {\n\t\t\tnodeKeyDirectory = new KeyDirectory(this, theNodeKeyName, handle());\n\t\t\tnodeKeyDirectory.waitForChildren();\n\n\t\t\tif (null == nodeKeyDirectory) {\n\t\t\t\tthrow new IOException(\"Cannot get node key directory for : \" + theNodeKeyName);\n\t\t\t}\n\t\t\tif (nodeKeyDirectory.hasSupersededBlock()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (PrincipalInfo principal : nodeKeyDirectory.getCopyOfPrincipals().values()) {\n\t\t\t\tif (principal.isGroup()) {\n\t\t\t\t\tGroup theGroup = groupManager().getGroup(principal.friendlyName());\n\t\t\t\t\tif (theGroup.publicKeyVersion().after(principal.versionTimestamp())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// DKS TODO -- for now, don't handle versioning of non-group keys\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\t\tLog.info(\"User key for {0}, not checking version.\", principal.friendlyName());\n\t\t\t\t\t}\n\t\t\t\t\t// Technically, we're not handling versioning for user keys, but be nice. Start\n\t\t\t\t\t// by seeing if we have a link to the key in our user space.\n\t\t\t\t\t// If the principal isn't available in our enumerated list, have to go get its key\n\t\t\t\t\t// from the wrapped key object.\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t} finally {\n\t\t\tif (null != nodeKeyDirectory)\n\t\t\t\tnodeKeyDirectory.stopEnumerating();\n\t\t}\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Try to pull an ACL for a specified node if it exists.\n\t * @param aclNodeName the name of the node\n\t * @return the ACL object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic ACLObject getACLObjectForNodeIfExists(ContentName aclNodeName) throws ContentDecodingException, IOException {\n\t\t\n\t\t// TODO really want to check simple existence here, but need to integrate with verifier\n\t\t// use. GLV too slow for negative results. Given that we need latest version, at least\n\t\t// use the segment we get, and don't pull it twice.\n\t\tContentName aclName = new ContentName(GroupAccessControlProfile.aclName(aclNodeName));\n\t\tContentObject aclNameList = VersioningProfile.getLatestVersion(aclName, \n\t\t\t\tnull, SystemConfiguration.MAX_TIMEOUT, handle().defaultVerifier(), handle()); \n\t\t\n\t\tif (null != aclNameList) {\n\t\t\tLog.info(\"Found latest version of acl for \" + aclNodeName + \" at \" + aclName + \" type: \" + aclNameList.signedInfo().getTypeName());\n\t\t\tACLObject aclo = new ACLObject(aclNameList, handle());\n\t\t\tif (aclo.isGone()) {\n\t\t\t\tLog.info(\"ACL object is GONE, returning anyway {0}\", aclo.getVersionedName());\n\t\t\t}\n\t\t\treturn aclo;\n\t\t}\n\t\tLog.info(\"No ACL found on node: \" + aclNodeName);\n\t\treturn null;\n\t}","id":3848,"modified_method":"/**\n\t * Try to pull an ACL for a specified node if it exists.\n\t * @param aclNodeName the name of the node\n\t * @return the ACL object\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t */\n\tpublic ACLObject getACLObjectForNodeIfExists(ContentName aclNodeName) throws ContentDecodingException, IOException {\n\t\t\n\t\t// TODO really want to check simple existence here, but need to integrate with verifier\n\t\t// use. GLV too slow for negative results. Given that we need latest version, at least\n\t\t// use the segment we get, and don't pull it twice.\n\t\tContentName aclName = new ContentName(GroupAccessControlProfile.aclName(aclNodeName));\n\t\tContentObject aclNameList = VersioningProfile.getLatestVersion(aclName, \n\t\t\t\tnull, SystemConfiguration.MAX_TIMEOUT, handle().defaultVerifier(), handle()); \n\t\t\n\t\tif (null != aclNameList) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"Found latest version of acl for {0} at {1} type: {2}\", \n\t\t\t\t\t\taclNodeName, aclName, aclNameList.signedInfo().getTypeName());\n\t\t\t}\n\t\t\tACLObject aclo = new ACLObject(aclNameList, handle());\n\t\t\tif (aclo.isGone()) {\n\t\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\t\tLog.info(\"ACL object is GONE, returning anyway {0}\", aclo.getVersionedName());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn aclo;\n\t\t}\n\t\tLog.info(\"No ACL found on node: \" + aclNodeName);\n\t\treturn null;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get the data key wrapping key if we happened to have cached a copy of the decryption key.\n\t * @param dataNodeName\n\t * @param wrappedDataKeyObject\n\t * @param cachedWrappingKey\n\t * @return\n\t * @throws ContentEncodingException \n\t * @throws InvalidKeyException \n\t */\n\t@Override \n\tpublic Key getDataKeyWrappingKey(ContentName dataNodeName, ContentName wrappingKeyName, Key cachedWrappingKey) throws InvalidKeyException, ContentEncodingException {\n\t\tNodeKey cachedWrappingKeyNK = new NodeKey(wrappingKeyName, cachedWrappingKey);\n\t\tLog.finer(\"getNodeKeyForObject: retrieved stored node key for node {0} label {1}: {2}\", dataNodeName, nodeKeyLabel(), cachedWrappingKeyNK);\n\t\tNodeKey enk = cachedWrappingKeyNK.computeDescendantNodeKey(dataNodeName, nodeKeyLabel());\n\t\tLog.finer(\"getNodeKeyForObject: computed effective node key for node {0} label {1}: {2}\", dataNodeName, nodeKeyLabel(), enk);\n\t\tif (null != enk) {\n\t\t\treturn enk.nodeKey();\n\t\t}\n\t\treturn null;\n\t}","id":3849,"modified_method":"/**\n\t * Get the data key wrapping key if we happened to have cached a copy of the decryption key.\n\t * @param dataNodeName\n\t * @param wrappedDataKeyObject\n\t * @param cachedWrappingKey\n\t * @return\n\t * @throws ContentEncodingException \n\t * @throws InvalidKeyException \n\t */\n\t@Override \n\tpublic Key getDataKeyWrappingKey(ContentName dataNodeName, ContentName wrappingKeyName, Key cachedWrappingKey) throws InvalidKeyException, ContentEncodingException {\n\t\tNodeKey cachedWrappingKeyNK = new NodeKey(wrappingKeyName, cachedWrappingKey);\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"getNodeKeyForObject: retrieved stored node key for node {0} label {1}: {2}\", dataNodeName, nodeKeyLabel(), cachedWrappingKeyNK);\n\t\t}\n\t\tNodeKey enk = cachedWrappingKeyNK.computeDescendantNodeKey(dataNodeName, nodeKeyLabel());\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"getNodeKeyForObject: computed effective node key for node {0} label {1}: {2}\", dataNodeName, nodeKeyLabel(), enk);\n\t\t}\n\t\tif (null != enk) {\n\t\t\treturn enk.nodeKey();\n\t\t}\n\t\treturn null;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Like #getEffectiveNodeKey(ContentName), except checks to see if node\n\t * key is dirty and updates it if necessary.\n\t * @param nodeName\n\t * @return\n\t * @throws AccessDeniedException\n\t * @throws IOException \n\t * @throws ContentGoneException \n\t * @throws ContentNotReadyException \n\t * @throws ContentEncodingException \n\t * @throws ContentDecodingException \n\t * @throws AccessDeniedException, InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getFreshEffectiveNodeKey(ContentName nodeName) \n\t\t\tthrows AccessDeniedException, InvalidKeyException, ContentDecodingException, \n\t\t\t\t\tContentEncodingException, ContentNotReadyException, ContentGoneException, IOException, NoSuchAlgorithmException {\n\t\tNodeKey nodeKey = findAncestorWithNodeKey(nodeName);\n\t\tif (null == nodeKey) {\n\t\t\tthrow new AccessDeniedException(\"Cannot retrieve node key for node: \" + nodeName + \".\");\n\t\t}\n\t\t// This should be the latest node key; i.e. not superseded.\n\t\tif (nodeKeyIsDirty(nodeKey.storedNodeKeyName())) {\n\t\t\tLog.info(\"getFreshEffectiveNodeKey: Found node key at \" + nodeKey.storedNodeKeyName() + \", updating.\");\n\t\t\tContentName nodeKeyNodeName = GroupAccessControlProfile.accessRoot(nodeKey.storedNodeKeyName());\n\t\t\tACLObject acl = getACLObjectForNode(nodeKeyNodeName);\n\t\t\tnodeKey = generateNewNodeKey(nodeKeyNodeName, nodeKey, acl.acl());\n\t\t} else {\n\t\t\tLog.info(\"getFreshEffectiveNodeKey: Found node key at \" + nodeKey.storedNodeKeyName());\n\t\t}\n\t\tLog.finer(\"getFreshEffectiveNodeKey: retrieved stored node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), nodeKey);\n\t\tNodeKey effectiveNodeKey = nodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel()); \n\t\tLog.finer(\"getFreshEffectiveNodeKey: computed effective node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), effectiveNodeKey);\n\t\tLog.info(\"getFreshEffectiveNodeKey: Computed effective node key for \" + nodeName + \" using stored node key \" + effectiveNodeKey.storedNodeKeyName());\n\t\treturn effectiveNodeKey;\n\t}","id":3850,"modified_method":"/**\n\t * Like #getEffectiveNodeKey(ContentName), except checks to see if node\n\t * key is dirty and updates it if necessary.\n\t * @param nodeName\n\t * @return\n\t * @throws AccessDeniedException\n\t * @throws IOException \n\t * @throws ContentGoneException \n\t * @throws ContentNotReadyException \n\t * @throws ContentEncodingException \n\t * @throws ContentDecodingException \n\t * @throws AccessDeniedException, InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic NodeKey getFreshEffectiveNodeKey(ContentName nodeName) \n\t\t\tthrows AccessDeniedException, InvalidKeyException, ContentDecodingException, \n\t\t\t\t\tContentEncodingException, ContentNotReadyException, ContentGoneException, IOException, NoSuchAlgorithmException {\n\t\tNodeKey nodeKey = findAncestorWithNodeKey(nodeName);\n\t\tif (null == nodeKey) {\n\t\t\tthrow new AccessDeniedException(\"Cannot retrieve node key for node: \" + nodeName + \".\");\n\t\t}\n\t\t// This should be the latest node key; i.e. not superseded.\n\t\tif (nodeKeyIsDirty(nodeKey.storedNodeKeyName())) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getFreshEffectiveNodeKey: Found node key at {0}, updating.\", nodeKey.storedNodeKeyName());\n\t\t\t}\n\t\t\tContentName nodeKeyNodeName = GroupAccessControlProfile.accessRoot(nodeKey.storedNodeKeyName());\n\t\t\tACLObject acl = getACLObjectForNode(nodeKeyNodeName);\n\t\t\tnodeKey = generateNewNodeKey(nodeKeyNodeName, nodeKey, acl.acl());\n\t\t} else {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"getFreshEffectiveNodeKey: Found node key at {0}\", nodeKey.storedNodeKeyName());\n\t\t\t}\n\t\t}\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"getFreshEffectiveNodeKey: retrieved stored node key for node {0} label {1}: {2}\", nodeName, nodeKeyLabel(), nodeKey);\n\t\t}\n\t\tNodeKey effectiveNodeKey = nodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel()); \n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"getFreshEffectiveNodeKey: computed effective node key for node {0} label {1}: {2} using stored node key {3}\"\n\t\t\t\t\t, nodeName, nodeKeyLabel(), effectiveNodeKey, effectiveNodeKey.storedNodeKeyName());\n\t\t}\n\t\treturn effectiveNodeKey;\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Delete the ACL at this node if one exists, returning control to the\n\t * next ACL upstream.\n\t * We simply add a supserseded by block at this node, wrapping this key in the key of the upstream\n\t * node. If we don't have read access at that node, throw AccessDeniedException.\n\t * Then we write a GONE block here for the ACL, and a new node key version with a superseded by block.\n\t * The superseded by block should probably be encrypted not with the ACL in force, but with the effective\n\t * node key of the parent -- that will be derivable from the appropriate ACL, and will have the right semantics\n\t * if a new ACL is interposed later. In the meantime, all the people with the newly in-force ancestor\n\t * ACL should be able to read this content.\n\t * @param nodeName\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic void deleteACL(ContentName nodeName) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\t\t\n\t\t// First, find ACL at this node if one exists.\n\t\tACLObject thisNodeACL = getACLObjectForNodeIfExists(nodeName);\n\t\tif (null == thisNodeACL) {\n\t\t\tLog.info(\"Asked to delete ACL for node \" + nodeName + \" that doesn't have one. Doing nothing.\");\n\t\t\treturn;\n\t\t} else if (thisNodeACL.isGone()) {\n\t\t\tLog.info(\"Asked to delete ACL for node \" + nodeName + \" that has already been deleted. Doing nothing.\");\n\t\t\treturn;\t\t\t\n\t\t}\n\t\tLog.info(\"Deleting ACL for node \" + nodeName + \" latest version: \" + thisNodeACL.getVersionedName());\n\t\t\n\t\t// We know we have an ACL at this node. So we know we have a node key at this\n\t\t// node. Get the latest version of this node key.\n\t\tNodeKey nk = getLatestNodeKeyForNode(nodeName);\n\t\t\n\t\t// Next, find the node key that would be in force here after this deletion. \n\t\t// Do that by getting the effective node key at the parent\n\t\tContentName parentName = nodeName.parent();\n\t\tNodeKey effectiveParentNodeKey = getEffectiveNodeKey(parentName);\n\t\t// And then deriving what the effective node key would be here, if\n\t\t// we inherited from the parent\n\t\tNodeKey ourEffectiveNodeKeyFromParent = \n\t\t\teffectiveParentNodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel()); \n\t\t\n\t\t// Generate a superseded block for this node, wrapping its key in the parent.\n\t\t// TODO want to wrap key in parent's effective key, but can't point to that -- no way to name an\n\t\t// effective node key... need one.\n\t\t\n\t\t// need to mangl stored key name into superseded block name, need to wrap\n\t\t// in ourEffNodeKeyFromParent, make sure stored key id points up to our ENKFP.storedKeyName()\n\t\tKeyDirectory.addSupersededByBlock(nk.storedNodeKeyName(), nk.nodeKey(), \n\t\t\t\tourEffectiveNodeKeyFromParent.storedNodeKeyName(), \n\t\t\t\tourEffectiveNodeKeyFromParent.storedNodeKeyID(),\n\t\t\t\teffectiveParentNodeKey.nodeKey(), handle());\n\t\t\n\t\t// Then mark the ACL as gone.\n\t\tthisNodeACL.saveAsGone();\n\t}","id":3851,"modified_method":"/**\n\t * Delete the ACL at this node if one exists, returning control to the\n\t * next ACL upstream.\n\t * We simply add a supserseded by block at this node, wrapping this key in the key of the upstream\n\t * node. If we don't have read access at that node, throw AccessDeniedException.\n\t * Then we write a GONE block here for the ACL, and a new node key version with a superseded by block.\n\t * The superseded by block should probably be encrypted not with the ACL in force, but with the effective\n\t * node key of the parent -- that will be derivable from the appropriate ACL, and will have the right semantics\n\t * if a new ACL is interposed later. In the meantime, all the people with the newly in-force ancestor\n\t * ACL should be able to read this content.\n\t * @param nodeName\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidKeyException \n\t * @throws NoSuchAlgorithmException \n\t */\n\tpublic void deleteACL(ContentName nodeName) \n\t\t\tthrows ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n\t\t\n\t\t// First, find ACL at this node if one exists.\n\t\tACLObject thisNodeACL = getACLObjectForNodeIfExists(nodeName);\n\t\tif (null == thisNodeACL) {\n\t\t\tLog.info(\"Asked to delete ACL for node {0} that doesn't have one. Doing nothing.\", nodeName);\n\t\t\treturn;\n\t\t} else if (thisNodeACL.isGone()) {\n\t\t\tLog.info(\"Asked to delete ACL for node {0} that has already been deleted. Doing nothing.\", nodeName);\n\t\t\treturn;\t\t\t\n\t\t}\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"Deleting ACL for node {0} latest version: {1}\",  nodeName,  thisNodeACL.getVersionedName());\n\t\t}\n\t\t\n\t\t// We know we have an ACL at this node. So we know we have a node key at this\n\t\t// node. Get the latest version of this node key.\n\t\tNodeKey nk = getLatestNodeKeyForNode(nodeName);\n\t\t\n\t\t// Next, find the node key that would be in force here after this deletion. \n\t\t// Do that by getting the effective node key at the parent\n\t\tContentName parentName = nodeName.parent();\n\t\tNodeKey effectiveParentNodeKey = getEffectiveNodeKey(parentName);\n\t\t// And then deriving what the effective node key would be here, if\n\t\t// we inherited from the parent\n\t\tNodeKey ourEffectiveNodeKeyFromParent = \n\t\t\teffectiveParentNodeKey.computeDescendantNodeKey(nodeName, nodeKeyLabel()); \n\t\t\n\t\t// Generate a superseded block for this node, wrapping its key in the parent.\n\t\t// TODO want to wrap key in parent's effective key, but can't point to that -- no way to name an\n\t\t// effective node key... need one.\n\t\t\n\t\t// need to mangl stored key name into superseded block name, need to wrap\n\t\t// in ourEffNodeKeyFromParent, make sure stored key id points up to our ENKFP.storedKeyName()\n\t\tKeyDirectory.addSupersededByBlock(nk.storedNodeKeyName(), nk.nodeKey(), \n\t\t\t\tourEffectiveNodeKeyFromParent.storedNodeKeyName(), \n\t\t\t\tourEffectiveNodeKeyFromParent.storedNodeKeyID(),\n\t\t\t\teffectiveParentNodeKey.nodeKey(), handle());\n\t\t\n\t\t// Then mark the ACL as gone.\n\t\tthisNodeACL.saveAsGone();\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get the ancestor node key in force at this node (if we can decrypt it),\n\t * including a key at this node itself. We use the fact that ACLs and\n\t * node keys are co-located; if you have one, you have the other.\n\t * @param nodeName the name of the node\n\t * @return null means while node keys exist, we can't decrypt any of them --\n\t *    we have no read access to this node (which implies no write access)\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidCipherTextException \n\t * @throws AccessDeniedException \n\t * @throws InvalidKeyException \n\t * @throws IOException if something is wrong (e.g. no node keys at all)\n\t * @throws NoSuchAlgorithmException \n\t */\n\tprotected NodeKey findAncestorWithNodeKey(ContentName nodeName) \n\t\t\tthrows InvalidKeyException, AccessDeniedException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t// climb up looking for node keys, then make sure that one isn't GONE\n\t\t// if it isn't, call read-side routine to figure out how to decrypt it\n\t\tACLObject effectiveACL = findAncestorWithACL(nodeName, null);\n\t\t\n\t\tif (null != effectiveACL) {\n\t\t\tLog.info(\"Got ACL named: \" + effectiveACL.getVersionedName() + \" attempting to retrieve node key from \" + AccessControlProfile.accessRoot(effectiveACL.getVersionedName()));\n\t\t} else {\n\t\t\t// We're not searching at the namespace root; because we assume we have\n\t\t\t// already made sure we have an ACL there. So if we get back NULL, we\n\t\t\t// go stratight to our namespace root.\n\t\t\tLog.info(\"No ACL found between node {0} and namespace root {1}, assume ACL is at namespace root.\",\n\t\t\t\t\tnodeName, getNamespaceRoot());\n\t\t}\n\t\treturn getLatestNodeKeyForNode(\n\t\t\t\t(null != effectiveACL) ? AccessControlProfile.accessRoot(effectiveACL.getBaseName()) : getNamespaceRoot());\n\t}","id":3852,"modified_method":"/**\n\t * Get the ancestor node key in force at this node (if we can decrypt it),\n\t * including a key at this node itself. We use the fact that ACLs and\n\t * node keys are co-located; if you have one, you have the other.\n\t * @param nodeName the name of the node\n\t * @return null means while node keys exist, we can't decrypt any of them --\n\t *    we have no read access to this node (which implies no write access)\n\t * @throws IOException \n\t * @throws ContentDecodingException \n\t * @throws InvalidCipherTextException \n\t * @throws AccessDeniedException \n\t * @throws InvalidKeyException \n\t * @throws IOException if something is wrong (e.g. no node keys at all)\n\t * @throws NoSuchAlgorithmException \n\t */\n\tprotected NodeKey findAncestorWithNodeKey(ContentName nodeName) \n\t\t\tthrows InvalidKeyException, AccessDeniedException, \n\t\t\t\t\tContentDecodingException, IOException, NoSuchAlgorithmException {\n\t\t// climb up looking for node keys, then make sure that one isn't GONE\n\t\t// if it isn't, call read-side routine to figure out how to decrypt it\n\t\tACLObject effectiveACL = findAncestorWithACL(nodeName, null);\n\t\t\n\t\tif (null != effectiveACL) {\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"Got ACL named: {0} attempting to retrieve node key from {1}\", \n\t\t\t\t\t\teffectiveACL.getVersionedName(), AccessControlProfile.accessRoot(effectiveACL.getVersionedName()));\n\t\t\t}\n\t\t} else {\n\t\t\t// We're not searching at the namespace root; because we assume we have\n\t\t\t// already made sure we have an ACL there. So if we get back NULL, we\n\t\t\t// go stratight to our namespace root.\n\t\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\t\tLog.info(\"No ACL found between node {0} and namespace root {1}, assume ACL is at namespace root.\",\n\t\t\t\t\t\tnodeName, getNamespaceRoot());\n\t\t\t}\n\t\t}\n\t\treturn getLatestNodeKeyForNode(\n\t\t\t\t(null != effectiveACL) ? AccessControlProfile.accessRoot(effectiveACL.getBaseName()) : getNamespaceRoot());\n\t}","commit_id":"c308de69b71afbf36f19145555c991e5040f83f4","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n\n        PrintWriter pw = response.getWriter();\n\n        String appRoot = (String) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        pw.println( \"<script src='\" + appRoot + \"/res/ui/bundles.js' language='JavaScript'><\/script>\" );\n\n        Util.startScript( pw );\n        pw.println( \"var bundleListData = \" );\n        JSONWriter jw = new JSONWriter( pw );\n        try\n        {\n            jw.object();\n            jw.key( \"startlevel\" );\n            jw.value( getStartLevel().getInitialBundleStartLevel() );\n\n            Bundle bundle = getBundle( request.getPathInfo() );\n            Bundle[] bundles = ( bundle != null ) ? new Bundle[]\n                { bundle } : this.getBundles();\n            boolean details = ( bundle != null );\n\n            if ( bundles != null && bundles.length > 0 )\n            {\n                Util.sort( bundles );\n\n                jw.key( \"bundles\" );\n\n                jw.array();\n\n                for ( int i = 0; i < bundles.length; i++ )\n                {\n                    bundleInfo( jw, bundles[i], details );\n                }\n\n                jw.endArray();\n\n            }\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n        pw.println( \";\" );\n        pw.println( \"render(bundleListData.startlevel, bundleListData.bundles);\" );\n        Util.endScript( pw );\n    }","id":3853,"modified_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n\n        PrintWriter pw = response.getWriter();\n\n        String appRoot = ( String ) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        pw.println( \"<script src='\" + appRoot + \"/res/ui/datatable.js' language='JavaScript'><\/script>\" );\n        pw.println( \"<script src='\" + appRoot + \"/res/ui/bundles.js' language='JavaScript'><\/script>\" );\n\n        Util.startScript( pw );\n        pw.println( \"var bundleListData = \" );\n        JSONWriter jw = new JSONWriter( pw );\n        try\n        {\n            jw.object();\n\n            jw.key( \"startLevel\" );\n            jw.value( getStartLevel().getInitialBundleStartLevel() );\n\n            jw.key( \"numActions\" );\n            jw.value( 4 );\n\n            Bundle bundle = getBundle( request.getPathInfo() );\n            Bundle[] bundles = ( bundle != null ) ? new Bundle[]\n                { bundle } : this.getBundles();\n            boolean details = ( bundle != null );\n\n            if ( bundles != null && bundles.length > 0 )\n            {\n                Util.sort( bundles );\n\n                jw.key( \"data\" );\n\n                jw.array();\n\n                for ( int i = 0; i < bundles.length; i++ )\n                {\n                    bundleInfo( jw, bundles[i], details );\n                }\n\n                jw.endArray();\n\n            }\n            else\n            {\n                jw.key( \"error\" );\n                jw.value( \"No Bundles installed currently\" );\n            }\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n        pw.println( \";\" );\n        pw.println( \"renderBundle( bundleListData );\" );\n        Util.endScript( pw );\n    }","commit_id":"1c33646932be35eae1a3723794c081b88920b6fa","url":"https://github.com/apache/felix"},{"original_method":"protected void doPost( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException\n    {\n        String action = req.getParameter( \"action\" );\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            getPackageAdmin().refreshPackages( null );\n        }\n\n        boolean success = false;\n        Bundle bundle = getBundle( req.getPathInfo() );\n        long bundleId = bundle.getBundleId();\n\n        if ( bundle != null )\n        {\n            if ( \"start\".equals( action ) )\n            {\n                // start bundle\n                success = true;\n                try\n                {\n                    bundle.start();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot start\", be );\n                }\n            }\n            else if ( \"stop\".equals( action ) )\n            {\n                // stop bundle\n                success = true;\n                try\n                {\n                    bundle.stop();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot stop\", be );\n                }\n            }\n            else if ( \"update\".equals( action ) )\n            {\n                // update bundle\n                success = true;\n            }\n            else if ( \"uninstall\".equals( action ) )\n            {\n                // uninstall bundle\n                success = true;\n                try\n                {\n                    bundle.uninstall();\n                    bundle = null; // bundle has gone !\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot uninstall\", be );\n                }\n            }\n        }\n\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            success = true;\n            getPackageAdmin().refreshPackages( null );\n\n            // refresh completely\n            bundle = null;\n            bundleId = -1;\n        }\n\n        if ( success )\n        {\n            // redirect or 200\n            resp.setStatus( HttpServletResponse.SC_OK );\n            JSONWriter jw = new JSONWriter( resp.getWriter() );\n            try\n            {\n                if ( bundle != null )\n                {\n                    bundleInfo( jw, bundle, true );\n                }\n                else if ( bundleId >= 0 )\n                {\n                    jw.object();\n                    jw.key( \"bundleId\" );\n                    jw.value( bundleId );\n                    jw.endObject();\n                }\n                else\n                {\n                    jw.object();\n                    jw.key( \"reload\" );\n                    jw.value( true );\n                    jw.endObject();\n                }\n            }\n            catch ( JSONException je )\n            {\n                throw new IOException( je.toString() );\n            }\n        }\n        else\n        {\n            super.doPost( req, resp );\n        }\n    }","id":3854,"modified_method":"protected void doPost( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException\n    {\n        String action = req.getParameter( \"action\" );\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            getPackageAdmin().refreshPackages( null );\n        }\n\n        boolean success = false;\n        Bundle bundle = getBundle( req.getPathInfo() );\n        long bundleId = bundle.getBundleId();\n\n        if ( bundle != null )\n        {\n            if ( action == null )\n            {\n                success = true;\n            }\n            else if ( \"start\".equals( action ) )\n            {\n                // start bundle\n                success = true;\n                try\n                {\n                    bundle.start();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot start\", be );\n                }\n            }\n            else if ( \"stop\".equals( action ) )\n            {\n                // stop bundle\n                success = true;\n                try\n                {\n                    bundle.stop();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot stop\", be );\n                }\n            }\n            else if ( \"update\".equals( action ) )\n            {\n                // update bundle\n                success = true;\n            }\n            else if ( \"uninstall\".equals( action ) )\n            {\n                // uninstall bundle\n                success = true;\n                try\n                {\n                    bundle.uninstall();\n                    bundle = null; // bundle has gone !\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot uninstall\", be );\n                }\n            }\n        }\n\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            success = true;\n            getPackageAdmin().refreshPackages( null );\n\n            // refresh completely\n            bundle = null;\n            bundleId = -1;\n        }\n\n        if ( success )\n        {\n            // redirect or 200\n            resp.setStatus( HttpServletResponse.SC_OK );\n            JSONWriter jw = new JSONWriter( resp.getWriter() );\n            try\n            {\n                if ( bundle != null )\n                {\n                    bundleInfo( jw, bundle, true );\n                }\n                else if ( bundleId >= 0 )\n                {\n                    jw.object();\n                    jw.key( \"bundleId\" );\n                    jw.value( bundleId );\n                    jw.endObject();\n                }\n                else\n                {\n                    jw.object();\n                    jw.key( \"reload\" );\n                    jw.value( true );\n                    jw.endObject();\n                }\n            }\n            catch ( JSONException je )\n            {\n                throw new IOException( je.toString() );\n            }\n        }\n        else\n        {\n            super.doPost( req, resp );\n        }\n    }","commit_id":"1c33646932be35eae1a3723794c081b88920b6fa","url":"https://github.com/apache/felix"},{"original_method":"private void bundleInfo( JSONWriter jw, Bundle bundle, boolean details ) throws JSONException\n    {\n        jw.object();\n        jw.key( \"bundleId\" );\n        jw.value( bundle.getBundleId() );\n        jw.key( \"name\" );\n        jw.value( Util.getName( bundle ) );\n        jw.key( \"state\" );\n        jw.value( toStateString( bundle.getState() ) );\n        jw.key( \"hasStart\" );\n        jw.value( hasStart( bundle ) );\n        jw.key( \"hasStop\" );\n        jw.value( hasStop( bundle ) );\n        jw.key( \"hasUpdate\" );\n        jw.value( hasUpdate( bundle ) );\n        jw.key( \"hasUninstall\" );\n        jw.value( hasUninstall( bundle ) );\n\n        if ( details )\n        {\n            bundleDetails( jw, bundle );\n        }\n\n        jw.endObject();\n    }","id":3855,"modified_method":"private void bundleInfo( JSONWriter jw, Bundle bundle, boolean details ) throws JSONException\n    {\n        jw.object();\n        jw.key( \"id\" );\n        jw.value( bundle.getBundleId() );\n        jw.key( \"name\" );\n        jw.value( Util.getName( bundle ) );\n        jw.key( \"state\" );\n        jw.value( toStateString( bundle.getState() ) );\n\n        jw.key( \"actions\" );\n        jw.array();\n\n        if ( bundle.getBundleId() == 0 )\n        {\n            jw.value( false );\n            jw.value( false );\n            jw.value( false );\n            jw.value( false );\n        }\n        else\n        {\n            action( jw, hasStart( bundle ), \"start\", \"Start\" );\n            action( jw, hasStop( bundle ), \"stop\", \"Stop\" );\n            action( jw, hasUpdate( bundle ), \"update\", \"Update\" );\n            action( jw, hasUninstall( bundle ), \"uninstall\", \"Uninstall\" );\n        }\n        jw.endArray();\n\n        if ( details )\n        {\n            bundleDetails( jw, bundle );\n        }\n\n        jw.endObject();\n    }","commit_id":"1c33646932be35eae1a3723794c081b88920b6fa","url":"https://github.com/apache/felix"},{"original_method":"private void component( PrintWriter pw, Component component )\n    {\n\n        pw.print( component.getId() );\n        pw.print( \"=[\" );\n        pw.print( component.getName() );\n        pw.println( \"]\" );\n\n        pw.println( \"  Bundle\" + component.getBundle().getSymbolicName() + \" (\" + component.getBundle().getBundleId()\n            + \")\" );\n        pw.println( \"  State=\" + ComponentRenderAction.toStateString( component.getState() ) );\n        pw.println( \"  DefaultState=\" + ( component.isDefaultEnabled() ? \"enabled\" : \"disabled\" ) );\n        pw.println( \"  Activation=\" + ( component.isImmediate() ? \"immediate\" : \"delayed\" ) );\n\n        listServices( pw, component );\n        listReferences( pw, component );\n        listProperties( pw, component );\n\n        pw.println();\n    }","id":3856,"modified_method":"private void component( PrintWriter pw, Component component )\n    {\n\n        pw.print( component.getId() );\n        pw.print( \"=[\" );\n        pw.print( component.getName() );\n        pw.println( \"]\" );\n\n        pw.println( \"  Bundle\" + component.getBundle().getSymbolicName() + \" (\" + component.getBundle().getBundleId()\n            + \")\" );\n        pw.println( \"  State=\" + ComponentsServlet.toStateString( component.getState() ) );\n        pw.println( \"  DefaultState=\" + ( component.isDefaultEnabled() ? \"enabled\" : \"disabled\" ) );\n        pw.println( \"  Activation=\" + ( component.isImmediate() ? \"immediate\" : \"delayed\" ) );\n\n        listServices( pw, component );\n        listReferences( pw, component );\n        listProperties( pw, component );\n\n        pw.println();\n    }","commit_id":"1c33646932be35eae1a3723794c081b88920b6fa","url":"https://github.com/apache/felix"},{"original_method":"protected int remoteDeploy(\n\t\t\tString url, URL urlObj, ActionRequest actionRequest,\n\t\t\tboolean failOnError)\n\t\tthrows Exception {\n\n\t\tint responseCode = HttpServletResponse.SC_OK;\n\n\t\tGetMethod getMethod = null;\n\n\t\tString deploymentContext = ParamUtil.getString(\n\t\t\tactionRequest, \"deploymentContext\");\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\turl);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tgetMethod = new GetMethod(url);\n\n\t\t\tString fileName = null;\n\n\t\t\tif (Validator.isNotNull(deploymentContext)) {\n\t\t\t\tfileName =\n\t\t\t\t\tBaseDeployer.DEPLOY_TO_PREFIX + deploymentContext + \".war\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileName = url.substring(url.lastIndexOf(CharPool.SLASH) + 1);\n\n\t\t\t\tint pos = fileName.lastIndexOf(CharPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tdeploymentContext = fileName.substring(0, pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPluginPackageUtil.registerPluginPackageInstallation(\n\t\t\t\tdeploymentContext);\n\n\t\t\tresponseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, \"errorConnectingToUrl\",\n\t\t\t\t\t\tnew Object[] {String.valueOf(responseCode)});\n\t\t\t\t}\n\n\t\t\t\treturn responseCode;\n\t\t\t}\n\n\t\t\tlong contentLength = getMethod.getResponseContentLength();\n\n\t\t\tString progressId = ParamUtil.getString(\n\t\t\t\tactionRequest, Constants.PROGRESS_ID);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\tactionRequest, getMethod.getResponseBodyAsStream(),\n\t\t\t\tcontentLength, progressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsKeys.AUTO_DEPLOY_DEPLOY_DIR,\n\t\t\t\tPropsValues.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString tmpFilePath =\n\t\t\t\tdeployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + fileName;\n\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Downloaded plugin from \" + urlObj + \" has \" +\n\t\t\t\t\t\t\tpis.getTotalRead() + \" bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination = deployDir + StringPool.SLASH + fileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, UploadException.class.getName());\n\t\t\t\t}\n\n\t\t\t\tresponseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException murle) {\n\t\t\tSessionErrors.add(actionRequest, \"invalidUrl\", murle);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tSessionErrors.add(actionRequest, \"errorConnectingToUrl\", ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (getMethod != null) {\n\t\t\t\tgetMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tPluginPackageUtil.endPluginPackageInstallation(deploymentContext);\n\t\t}\n\n\t\treturn responseCode;\n\t}","id":3857,"modified_method":"protected int remoteDeploy(\n\t\t\tString url, URL urlObj, ActionRequest actionRequest,\n\t\t\tboolean failOnError)\n\t\tthrows Exception {\n\n\t\tint responseCode = HttpServletResponse.SC_OK;\n\n\t\tGetMethod getMethod = null;\n\n\t\tString deploymentContext = ParamUtil.getString(\n\t\t\tactionRequest, \"deploymentContext\");\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\turl);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tgetMethod = new GetMethod(url);\n\n\t\t\tString fileName = null;\n\n\t\t\tif (Validator.isNotNull(deploymentContext)) {\n\t\t\t\tfileName =\n\t\t\t\t\tBaseDeployer.DEPLOY_TO_PREFIX + deploymentContext + \".war\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileName = url.substring(url.lastIndexOf(CharPool.SLASH) + 1);\n\n\t\t\t\tint pos = fileName.lastIndexOf(CharPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tdeploymentContext = fileName.substring(0, pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPluginPackageUtil.registerPluginPackageInstallation(\n\t\t\t\tdeploymentContext);\n\n\t\t\tresponseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, \"errorConnectingToUrl\",\n\t\t\t\t\t\tnew Object[] {String.valueOf(responseCode)});\n\t\t\t\t}\n\n\t\t\t\treturn responseCode;\n\t\t\t}\n\n\t\t\tlong contentLength = getMethod.getResponseContentLength();\n\n\t\t\tString progressId = ParamUtil.getString(\n\t\t\t\tactionRequest, Constants.PROGRESS_ID);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\tactionRequest, getMethod.getResponseBodyAsStream(),\n\t\t\t\tcontentLength, progressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsKeys.AUTO_DEPLOY_DEPLOY_DIR,\n\t\t\t\tPropsValues.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString tmpFilePath =\n\t\t\t\tdeployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + fileName;\n\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Downloaded plugin from \" + urlObj + \" has \" +\n\t\t\t\t\t\t\tpis.getTotalRead() + \" bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination = deployDir + StringPool.SLASH + fileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, UploadException.class.getName());\n\t\t\t\t}\n\n\t\t\t\tresponseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException murle) {\n\t\t\tSessionErrors.add(actionRequest, \"invalidUrl\", murle);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tSessionErrors.add(actionRequest, \"errorConnectingToUrl\", ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (getMethod != null) {\n\t\t\t\tgetMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tPluginPackageUtil.endPluginPackageInstallation(deploymentContext);\n\t\t}\n\n\t\treturn responseCode;\n\t}","commit_id":"f085bd2e7fc11e5ffc93d1ad2e5c78faf969b3ae","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void testDirectDownloadURL(String directDownloadURL)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\tdirectDownloadURL);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tGetMethod getFileMethod = new GetMethod(directDownloadURL);\n\n\t\t\tint responseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getFileMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t}\n\t}","id":3858,"modified_method":"protected void testDirectDownloadURL(String directDownloadURL)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\tdirectDownloadURL);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tGetMethod getFileMethod = new GetMethod(directDownloadURL);\n\n\t\t\tint responseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getFileMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t}\n\t}","commit_id":"f085bd2e7fc11e5ffc93d1ad2e5c78faf969b3ae","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object convert(String key) throws WebCacheException {\n\t\tSyndFeed feed = null;\n\n\t\ttry {\n\n\t\t\t// com.liferay.portal.kernel.util.HttpUtil will break the connection\n\t\t\t// if it spends more than 5 seconds looking up a location. However,\n\t\t\t// German umlauts do not get encoded correctly. This may be a bug\n\t\t\t// with commons-httpclient or with how FeedParser uses\n\t\t\t// java.io.Reader.\n\n\t\t\t// Use http://xml.newsisfree.com/feeds/29/629.xml and\n\t\t\t// http://test.domosoft.com/up/RSS to test if German umlauts show up\n\t\t\t// correctly.\n\n\t\t\t/*Reader reader = new StringReader(\n\t\t\t\tnew String(HttpUtil.URLtoByteArray(_url)));\n\n\t\t\tchannel = FeedParser.parse(builder, reader);*/\n\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\t_url);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\thttpImpl.proxifyState(httpClient.getState(), hostConfiguration);\n\n\t\t\tHttpClientParams httpClientParams = httpClient.getParams();\n\n\t\t\thttpClientParams.setConnectionManagerTimeout(\n\t\t\t\tPropsValues.RSS_CONNECTION_TIMEOUT);\n\t\t\thttpClientParams.setSoTimeout(PropsValues.RSS_CONNECTION_TIMEOUT);\n\n\t\t\tGetMethod getMethod = new GetMethod(_url);\n\n\t\t\thttpClient.executeMethod(hostConfiguration, getMethod);\n\n\t\t\tSyndFeedInput input = new SyndFeedInput();\n\n\t\t\tfeed = input.build(\n\t\t\t\tnew XmlReader(getMethod.getResponseBodyAsStream()));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(_url + \" \" + e.toString());\n\t\t}\n\n\t\treturn feed;\n\t}","id":3859,"modified_method":"public Object convert(String key) throws WebCacheException {\n\t\tSyndFeed feed = null;\n\n\t\ttry {\n\n\t\t\t// com.liferay.portal.kernel.util.HttpUtil will break the connection\n\t\t\t// if it spends more than 5 seconds looking up a location. However,\n\t\t\t// German umlauts do not get encoded correctly. This may be a bug\n\t\t\t// with commons-httpclient or with how FeedParser uses\n\t\t\t// java.io.Reader.\n\n\t\t\t// Use http://xml.newsisfree.com/feeds/29/629.xml and\n\t\t\t// http://test.domosoft.com/up/RSS to test if German umlauts show up\n\t\t\t// correctly.\n\n\t\t\t/*Reader reader = new StringReader(\n\t\t\t\tnew String(HttpUtil.URLtoByteArray(_url)));\n\n\t\t\tchannel = FeedParser.parse(builder, reader);*/\n\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\t_url);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\thttpImpl.proxifyState(httpClient.getState(), hostConfiguration);\n\n\t\t\tHttpClientParams httpClientParams = httpClient.getParams();\n\n\t\t\thttpClientParams.setConnectionManagerTimeout(\n\t\t\t\tPropsValues.RSS_CONNECTION_TIMEOUT);\n\t\t\thttpClientParams.setSoTimeout(PropsValues.RSS_CONNECTION_TIMEOUT);\n\n\t\t\tGetMethod getMethod = new GetMethod(_url);\n\n\t\t\thttpClient.executeMethod(hostConfiguration, getMethod);\n\n\t\t\tSyndFeedInput input = new SyndFeedInput();\n\n\t\t\tfeed = input.build(\n\t\t\t\tnew XmlReader(getMethod.getResponseBodyAsStream()));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(_url + \" \" + e.toString());\n\t\t}\n\n\t\treturn feed;\n\t}","commit_id":"70019864fcce7acc14932b6b8e718b6e5a3356ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTableStatistics() throws Exception {\n        System.out.println(\"\\n\\nTESTING TABLE STATS\\n\\n\\n\");\n        Client client  = getFullyConnectedClient();\n\n        ColumnInfo[] expectedSchema = new ColumnInfo[11];\n        expectedSchema[0] = new ColumnInfo(\"TIMESTAMP\", VoltType.BIGINT);\n        expectedSchema[1] = new ColumnInfo(\"HOST_ID\", VoltType.INTEGER);\n        expectedSchema[2] = new ColumnInfo(\"HOSTNAME\", VoltType.STRING);\n        expectedSchema[3] = new ColumnInfo(\"SITE_ID\", VoltType.INTEGER);\n        expectedSchema[4] = new ColumnInfo(\"PARTITION_ID\", VoltType.BIGINT);\n        expectedSchema[5] = new ColumnInfo(\"TABLE_NAME\", VoltType.STRING);\n        expectedSchema[6] = new ColumnInfo(\"TABLE_TYPE\", VoltType.STRING);\n        expectedSchema[7] = new ColumnInfo(\"TUPLE_COUNT\", VoltType.BIGINT);\n        expectedSchema[8] = new ColumnInfo(\"TUPLE_ALLOCATED_MEMORY\", VoltType.INTEGER);\n        expectedSchema[9] = new ColumnInfo(\"TUPLE_DATA_MEMORY\", VoltType.INTEGER);\n        expectedSchema[10] = new ColumnInfo(\"STRING_DATA_MEMORY\", VoltType.INTEGER);\n        VoltTable expectedTable = new VoltTable(expectedSchema);\n\n        VoltTable[] results = null;\n        // table\n        //\n        results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n        System.out.println(\"Test statistics table: \" + results[0].toString());\n        // one aggregate table returned\n        assertEquals(1, results.length);\n        validateSchema(results[0], expectedTable);\n        // with 10 rows per site. Can be two values depending on the test scenario of cluster vs. local.\n        assertEquals(HOSTS * SITES * 3, results[0].getRowCount());\n        // Validate that each site returns a result for each table\n        validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"WAREHOUSE\", true);\n        validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"NEW_ORDER\", true);\n        validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"ITEM\", true);\n    }","id":3860,"modified_method":"public void testTableStatistics() throws Exception {\n        System.out.println(\"\\n\\nTESTING TABLE STATS\\n\\n\\n\");\n        Client client  = getFullyConnectedClient();\n\n        ColumnInfo[] expectedSchema = new ColumnInfo[11];\n        expectedSchema[0] = new ColumnInfo(\"TIMESTAMP\", VoltType.BIGINT);\n        expectedSchema[1] = new ColumnInfo(\"HOST_ID\", VoltType.INTEGER);\n        expectedSchema[2] = new ColumnInfo(\"HOSTNAME\", VoltType.STRING);\n        expectedSchema[3] = new ColumnInfo(\"SITE_ID\", VoltType.INTEGER);\n        expectedSchema[4] = new ColumnInfo(\"PARTITION_ID\", VoltType.BIGINT);\n        expectedSchema[5] = new ColumnInfo(\"TABLE_NAME\", VoltType.STRING);\n        expectedSchema[6] = new ColumnInfo(\"TABLE_TYPE\", VoltType.STRING);\n        expectedSchema[7] = new ColumnInfo(\"TUPLE_COUNT\", VoltType.BIGINT);\n        expectedSchema[8] = new ColumnInfo(\"TUPLE_ALLOCATED_MEMORY\", VoltType.INTEGER);\n        expectedSchema[9] = new ColumnInfo(\"TUPLE_DATA_MEMORY\", VoltType.INTEGER);\n        expectedSchema[10] = new ColumnInfo(\"STRING_DATA_MEMORY\", VoltType.INTEGER);\n        VoltTable expectedTable = new VoltTable(expectedSchema);\n\n        VoltTable[] results = null;\n        boolean success = false;\n        long start = System.currentTimeMillis();\n        while (!success) {\n            if (System.currentTimeMillis() - start > 60000) fail(\"Took too long\");\n            success = true;\n            // table\n            //\n            results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n            System.out.println(\"Test statistics table: \" + results[0].toString());\n            // one aggregate table returned\n            assertEquals(1, results.length);\n            validateSchema(results[0], expectedTable);\n            // with 10 rows per site. Can be two values depending on the test scenario of cluster vs. local.\n            if (HOSTS * SITES * 3 != results[0].getRowCount()) {\n                success = false;\n            }\n            // Validate that each site returns a result for each table\n            if (success) {\n                success = validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"WAREHOUSE\", true);\n            }\n            if (success) {\n                success = validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"NEW_ORDER\", true);\n            }\n            if (success) {\n                validateRowSeenAtAllSites(results[0], \"TABLE_NAME\", \"ITEM\", true);\n            }\n            if (success) break;\n        }\n    }","commit_id":"f4cff7c56b912b030aed6f372bbb73221f218b3e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testIndexStatistics() throws Exception {\n        System.out.println(\"\\n\\nTESTING INDEX STATS\\n\\n\\n\");\n        Client client  = getFullyConnectedClient();\n\n        ColumnInfo[] expectedSchema = new ColumnInfo[12];\n        expectedSchema[0] = new ColumnInfo(\"TIMESTAMP\", VoltType.BIGINT);\n        expectedSchema[1] = new ColumnInfo(\"HOST_ID\", VoltType.INTEGER);\n        expectedSchema[2] = new ColumnInfo(\"HOSTNAME\", VoltType.STRING);\n        expectedSchema[3] = new ColumnInfo(\"SITE_ID\", VoltType.INTEGER);\n        expectedSchema[4] = new ColumnInfo(\"PARTITION_ID\", VoltType.BIGINT);\n        expectedSchema[5] = new ColumnInfo(\"INDEX_NAME\", VoltType.STRING);\n        expectedSchema[6] = new ColumnInfo(\"TABLE_NAME\", VoltType.STRING);\n        expectedSchema[7] = new ColumnInfo(\"INDEX_TYPE\", VoltType.STRING);\n        expectedSchema[8] = new ColumnInfo(\"IS_UNIQUE\", VoltType.TINYINT);\n        expectedSchema[9] = new ColumnInfo(\"IS_COUNTABLE\", VoltType.TINYINT);\n        expectedSchema[10] = new ColumnInfo(\"ENTRY_COUNT\", VoltType.BIGINT);\n        expectedSchema[11] = new ColumnInfo(\"MEMORY_ESTIMATE\", VoltType.INTEGER);\n        VoltTable expectedTable = new VoltTable(expectedSchema);\n\n        VoltTable[] results = null;\n\n        results = client.callProcedure(\"@Statistics\", \"index\", 0).getResults();\n        System.out.println(\"Index results: \" + results[0].toString());\n        assertEquals(1, results.length);\n        validateSchema(results[0], expectedTable);\n        validateRowSeenAtAllSites(results[0], \"INDEX_NAME\", \"SYS_IDX_W_PK_TREE_10018\", true);\n        validateRowSeenAtAllSites(results[0], \"INDEX_NAME\", \"SYS_IDX_I_PK_TREE_10020\", true);\n    }","id":3861,"modified_method":"public void testIndexStatistics() throws Exception {\n        System.out.println(\"\\n\\nTESTING INDEX STATS\\n\\n\\n\");\n        Client client  = getFullyConnectedClient();\n\n        ColumnInfo[] expectedSchema = new ColumnInfo[12];\n        expectedSchema[0] = new ColumnInfo(\"TIMESTAMP\", VoltType.BIGINT);\n        expectedSchema[1] = new ColumnInfo(\"HOST_ID\", VoltType.INTEGER);\n        expectedSchema[2] = new ColumnInfo(\"HOSTNAME\", VoltType.STRING);\n        expectedSchema[3] = new ColumnInfo(\"SITE_ID\", VoltType.INTEGER);\n        expectedSchema[4] = new ColumnInfo(\"PARTITION_ID\", VoltType.BIGINT);\n        expectedSchema[5] = new ColumnInfo(\"INDEX_NAME\", VoltType.STRING);\n        expectedSchema[6] = new ColumnInfo(\"TABLE_NAME\", VoltType.STRING);\n        expectedSchema[7] = new ColumnInfo(\"INDEX_TYPE\", VoltType.STRING);\n        expectedSchema[8] = new ColumnInfo(\"IS_UNIQUE\", VoltType.TINYINT);\n        expectedSchema[9] = new ColumnInfo(\"IS_COUNTABLE\", VoltType.TINYINT);\n        expectedSchema[10] = new ColumnInfo(\"ENTRY_COUNT\", VoltType.BIGINT);\n        expectedSchema[11] = new ColumnInfo(\"MEMORY_ESTIMATE\", VoltType.INTEGER);\n        VoltTable expectedTable = new VoltTable(expectedSchema);\n\n        VoltTable[] results = null;\n\n        boolean success = false;\n        long start = System.currentTimeMillis();\n        while (!success) {\n            if (System.currentTimeMillis() - start > 60000) fail(\"Took too long\");\n            success = true;\n            results = client.callProcedure(\"@Statistics\", \"index\", 0).getResults();\n            System.out.println(\"Index results: \" + results[0].toString());\n            assertEquals(1, results.length);\n            validateSchema(results[0], expectedTable);\n            if (success) {\n                success = validateRowSeenAtAllSites(results[0], \"INDEX_NAME\", \"SYS_IDX_W_PK_TREE_10018\", true);\n            }\n            if (success) {\n                success = validateRowSeenAtAllSites(results[0], \"INDEX_NAME\", \"SYS_IDX_I_PK_TREE_10020\", true);\n            }\n            if (success) break;\n        }\n    }","commit_id":"f4cff7c56b912b030aed6f372bbb73221f218b3e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void validateRowSeenAtAllSites(VoltTable result, String columnName, String rowId,\n            boolean enforceUnique)\n    {\n        result.resetRowPosition();\n        Set<Long> sitesSeen = new HashSet<Long>();\n        while (result.advanceRow()) {\n            String procName = result.getString(columnName);\n            if (procName.equalsIgnoreCase(rowId)) {\n                long hostId = result.getLong(\"HOST_ID\");\n                long thisSiteId = result.getLong(\"SITE_ID\");\n                thisSiteId |= hostId << 32;\n                if (enforceUnique) {\n                    assertFalse(\"SITE_ID: \" + thisSiteId + \" seen twice in table looking for \" + rowId +\n                            \" in column \" + columnName, sitesSeen.contains(thisSiteId));\n                }\n                sitesSeen.add(thisSiteId);\n            }\n        }\n        assertEquals(HOSTS * SITES, sitesSeen.size());\n    }","id":3862,"modified_method":"public boolean validateRowSeenAtAllSites(VoltTable result, String columnName, String rowId,\n            boolean enforceUnique)\n    {\n        result.resetRowPosition();\n        Set<Long> sitesSeen = new HashSet<Long>();\n        while (result.advanceRow()) {\n            String procName = result.getString(columnName);\n            if (procName.equalsIgnoreCase(rowId)) {\n                long hostId = result.getLong(\"HOST_ID\");\n                long thisSiteId = result.getLong(\"SITE_ID\");\n                thisSiteId |= hostId << 32;\n                if (enforceUnique) {\n                    assertFalse(\"SITE_ID: \" + thisSiteId + \" seen twice in table looking for \" + rowId +\n                            \" in column \" + columnName, sitesSeen.contains(thisSiteId));\n                }\n                sitesSeen.add(thisSiteId);\n            }\n        }\n        return (HOSTS * SITES) == sitesSeen.size();\n    }","commit_id":"f4cff7c56b912b030aed6f372bbb73221f218b3e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  public void setStringValue(String metricKey, int line, String value) {\n    Preconditions.checkNotNull(metricKey);\n    Preconditions.checkArgument(line > 0);\n    Preconditions.checkNotNull(value);\n\n    setValue(metricKey, line, value);\n  }","id":3863,"modified_method":"@Override\n  public void setStringValue(String metricKey, int line, String value) {\n    Preconditions.checkNotNull(metricKey);\n    checkLineRange(line);\n    Preconditions.checkNotNull(value);\n\n    setValue(metricKey, line, value);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Map loadData(String metricKey, Converter converter) {\n    // FIXME no way to load measure only by key\n    Measure measure = index.getMeasure(resource, new Metric(metricKey));\n    String data = measure != null ? measure.getData() : null;\n    if (data != null) {\n      return ImmutableMap.copyOf(KeyValueFormat.parse(data, KeyValueFormat.newIntegerConverter(), converter));\n    }\n    // no such measure\n    return ImmutableMap.of();\n  }","id":3864,"modified_method":"private Map loadData(String metricKey, Converter converter) {\n    Measure measure = measureCache.byMetric(inputFile.key(), metricKey);\n    String data = measure != null ? measure.getData() : null;\n    if (data != null) {\n      return ImmutableMap.copyOf(KeyValueFormat.parse(data, KeyValueFormat.newIntegerConverter(), converter));\n    }\n    // no such measure\n    return ImmutableMap.of();\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String getStringValue(String metricKey, int line) {\n    Preconditions.checkNotNull(metricKey);\n    Preconditions.checkArgument(line > 0);\n\n    Map lines = map.get(metricKey);\n    if (lines == null) {\n      // not in memory, so load\n      lines = loadData(metricKey, KeyValueFormat.newStringConverter());\n      map.put(metricKey, lines);\n    }\n    return (String) lines.get(line);\n  }","id":3865,"modified_method":"@Override\n  public String getStringValue(String metricKey, int line) {\n    Preconditions.checkNotNull(metricKey);\n    checkLineRange(line);\n\n    Map lines = map.get(metricKey);\n    if (lines == null) {\n      // not in memory, so load\n      lines = loadData(metricKey, KeyValueFormat.newStringConverter());\n      map.put(metricKey, lines);\n    }\n    return (String) lines.get(line);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void setIntValue(String metricKey, int line, int value) {\n    Preconditions.checkNotNull(metricKey);\n    Preconditions.checkArgument(line > 0);\n\n    setValue(metricKey, line, value);\n  }","id":3866,"modified_method":"@Override\n  public void setIntValue(String metricKey, int line, int value) {\n    Preconditions.checkNotNull(metricKey);\n    checkLineRange(line);\n\n    setValue(metricKey, line, value);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DefaultFileLinesContext(SonarIndex index, Resource resource) {\n    Preconditions.checkNotNull(index);\n    Preconditions.checkArgument(ResourceUtils.isFile(resource));\n    this.index = index;\n    this.resource = resource;\n  }","id":3867,"modified_method":"public DefaultFileLinesContext(SensorContext context, InputFile inputFile, MetricFinder metricFinder, MeasureCache measureCache) {\n    this.context = context;\n    this.inputFile = inputFile;\n    this.metricFinder = metricFinder;\n    this.measureCache = measureCache;\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public Integer getIntValue(String metricKey, int line) {\n    Preconditions.checkNotNull(metricKey);\n    Preconditions.checkArgument(line > 0);\n\n    Map lines = map.get(metricKey);\n    if (lines == null) {\n      // not in memory, so load\n      lines = loadData(metricKey, KeyValueFormat.newIntegerConverter());\n      map.put(metricKey, lines);\n    }\n    return (Integer) lines.get(line);\n  }","id":3868,"modified_method":"@Override\n  public Integer getIntValue(String metricKey, int line) {\n    Preconditions.checkNotNull(metricKey);\n    checkLineRange(line);\n\n    Map lines = map.get(metricKey);\n    if (lines == null) {\n      // not in memory, so load\n      lines = loadData(metricKey, KeyValueFormat.newIntegerConverter());\n      map.put(metricKey, lines);\n    }\n    return (Integer) lines.get(line);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void save() {\n    for (Map.Entry<String, Map<Integer, Object>> entry : map.entrySet()) {\n      String metricKey = entry.getKey();\n      Map<Integer, Object> lines = entry.getValue();\n      if (shouldSave(lines)) {\n        String data = KeyValueFormat.format(lines);\n        Measure measure = new Measure(metricKey)\n          .setPersistenceMode(PersistenceMode.DATABASE)\n          .setData(data);\n        index.addMeasure(resource, measure);\n        entry.setValue(ImmutableMap.copyOf(lines));\n      }\n    }\n  }","id":3869,"modified_method":"@Override\n  public void save() {\n    for (Map.Entry<String, Map<Integer, Object>> entry : map.entrySet()) {\n      String metricKey = entry.getKey();\n      Map<Integer, Object> lines = entry.getValue();\n      if (shouldSave(lines)) {\n        String data = KeyValueFormat.format(optimizeStorage(metricKey, lines));\n        context.newMeasure()\n          .on(inputFile)\n          .forMetric(metricFinder.findByKey(metricKey))\n          .withValue(data)\n          .save();\n        entry.setValue(ImmutableMap.copyOf(lines));\n      }\n    }\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public FileLinesContext createFor(InputFile inputFile) {\n    File sonarFile = File.create(inputFile.relativePath());\n    // Reload resource from index\n    sonarFile = index.getResource(sonarFile);\n    return new DefaultFileLinesContext(index, sonarFile);\n  }","id":3870,"modified_method":"@Override\n  public FileLinesContext createFor(InputFile inputFile) {\n    return new DefaultFileLinesContext(sensorContext, inputFile, metricFinder, measureCache);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public FileLinesContext createFor(Resource model) {\n    // Reload resource in case it use deprecated key\n    Resource resource = index.getResource(model);\n    return new DefaultFileLinesContext(index, resource);\n  }","id":3871,"modified_method":"@Override\n  public FileLinesContext createFor(Resource resource) {\n    Preconditions.checkArgument(ResourceUtils.isFile(resource));\n    // Reload resource in case it use deprecated key\n    File file = (File) index.getResource(resource);\n    if (file == null) {\n      throw new IllegalArgumentException(\"Unable to find resource \" + resource + \" in index.\");\n    }\n    return new DefaultFileLinesContext(sensorContext, (InputFile) scannerComponentCache.get(file).inputComponent(), metricFinder, measureCache);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DefaultFileLinesContextFactory(SonarIndex index) {\n    this.index = index;\n  }","id":3872,"modified_method":"public DefaultFileLinesContextFactory(SonarIndex index, SensorContext sensorContext, MetricFinder metricFinder, BatchComponentCache scannerComponentCache,\n    MeasureCache measureCache) {\n    this.index = index;\n    this.sensorContext = sensorContext;\n    this.metricFinder = metricFinder;\n    this.scannerComponentCache = scannerComponentCache;\n    this.measureCache = measureCache;\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    index = mock(SonarIndex.class);\n    resource = mock(Resource.class);\n    when(resource.getScope()).thenReturn(Scopes.FILE);\n    fileLineMeasures = new DefaultFileLinesContext(index, resource);\n  }","id":3873,"modified_method":"@Before\n  public void setUp() throws Exception {\n    sensorContextTester = SensorContextTester.create(temp.newFolder());\n    MetricFinder metricFinder = mock(MetricFinder.class);\n    org.sonar.api.batch.measure.Metric<String> hitsMetric = mock(org.sonar.api.batch.measure.Metric.class);\n    when(hitsMetric.valueType()).thenReturn(String.class);\n    when(hitsMetric.key()).thenReturn(HITS_METRIC_KEY);\n    when(metricFinder.<String>findByKey(HITS_METRIC_KEY)).thenReturn(hitsMetric);\n    org.sonar.api.batch.measure.Metric<String> authorMetric = mock(org.sonar.api.batch.measure.Metric.class);\n    when(authorMetric.valueType()).thenReturn(String.class);\n    when(authorMetric.key()).thenReturn(AUTHOR_METRIC_KEY);\n    when(metricFinder.<String>findByKey(AUTHOR_METRIC_KEY)).thenReturn(authorMetric);\n    org.sonar.api.batch.measure.Metric<String> branchesMetric = mock(org.sonar.api.batch.measure.Metric.class);\n    when(branchesMetric.valueType()).thenReturn(String.class);\n    when(branchesMetric.key()).thenReturn(BRANCHES_METRIC_KEY);\n    when(metricFinder.<String>findByKey(BRANCHES_METRIC_KEY)).thenReturn(branchesMetric);\n    when(metricFinder.<String>findByKey(CoreMetrics.NCLOC_DATA_KEY)).thenReturn(CoreMetrics.NCLOC_DATA);\n    when(metricFinder.<String>findByKey(CoreMetrics.EXECUTABLE_LINES_DATA_KEY)).thenReturn(CoreMetrics.EXECUTABLE_LINES_DATA);\n    when(metricFinder.<String>findByKey(CoreMetrics.COMMENT_LINES_DATA_KEY)).thenReturn(CoreMetrics.COMMENT_LINES_DATA);\n    measureCache = mock(MeasureCache.class);\n    fileLineMeasures = new DefaultFileLinesContext(sensorContextTester, new DefaultInputFile(\"foo\", \"src/foo.php\").initMetadata(\"Foo\\nbar\\nbiz\"), metricFinder,\n      measureCache);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldSave() {\n    fileLineMeasures.setIntValue(\"hits\", 1, 2);\n    fileLineMeasures.setIntValue(\"hits\", 3, 4);\n    fileLineMeasures.save();\n\n    assertThat(fileLineMeasures.toString()).isEqualTo(\"DefaultFileLinesContext{map={hits={1=2, 3=4}}}\");\n\n    ArgumentCaptor<Measure> measureCaptor = ArgumentCaptor.forClass(Measure.class);\n    verify(index).addMeasure(Matchers.eq(resource), measureCaptor.capture());\n    Measure measure = measureCaptor.getValue();\n    assertThat(measure.getMetricKey(), is(\"hits\"));\n    assertThat(measure.getPersistenceMode(), is(PersistenceMode.DATABASE));\n    assertThat(measure.getData(), is(\"1=2;3=4\"));\n  }","id":3874,"modified_method":"@Test\n  public void shouldSave() {\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 1, 2);\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 3, 0);\n    fileLineMeasures.save();\n\n    assertThat(fileLineMeasures.toString()).isEqualTo(\"DefaultFileLinesContext{map={hits={1=2, 3=0}}}\");\n\n    assertThat(sensorContextTester.measure(\"foo:src/foo.php\", HITS_METRIC_KEY).value()).isEqualTo(\"1=2;3=0\");\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = UnsupportedOperationException.class)\n  public void shouldNotModifyAfterSave() {\n    fileLineMeasures.setIntValue(\"hits\", 1, 2);\n    fileLineMeasures.save();\n    fileLineMeasures.save();\n    verify(index).addMeasure(Matchers.eq(resource), Matchers.any(Measure.class));\n    fileLineMeasures.setIntValue(\"hits\", 1, 2);\n  }","id":3875,"modified_method":"@Test(expected = UnsupportedOperationException.class)\n  public void shouldNotModifyAfterSave() {\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 1, 2);\n    fileLineMeasures.save();\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 1, 2);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = UnsupportedOperationException.class)\n  public void shouldNotModifyAfterLoad() {\n    when(index.getMeasure(Matchers.any(Resource.class), Matchers.any(Metric.class)))\n      .thenReturn(new Measure(\"author\").setData(\"1=simon;3=evgeny\"));\n\n    fileLineMeasures.getStringValue(\"author\", 1);\n    fileLineMeasures.setStringValue(\"author\", 1, \"evgeny\");\n  }","id":3876,"modified_method":"@Test(expected = UnsupportedOperationException.class)\n  public void shouldNotModifyAfterLoad() {\n    when(measureCache.byMetric(\"foo:src/foo.php\", AUTHOR_METRIC_KEY)).thenReturn(new Measure(AUTHOR_METRIC_KEY).setData(\"1=simon;3=evgeny\"));\n\n    fileLineMeasures.getStringValue(AUTHOR_METRIC_KEY, 1);\n    fileLineMeasures.setStringValue(AUTHOR_METRIC_KEY, 1, \"evgeny\");\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldLoadStringValues() {\n    when(index.getMeasure(Matchers.any(Resource.class), Matchers.any(Metric.class)))\n      .thenReturn(new Measure(\"author\").setData(\"1=simon;3=evgeny\"));\n\n    assertThat(fileLineMeasures.getStringValue(\"author\", 1), is(\"simon\"));\n    assertThat(fileLineMeasures.getStringValue(\"author\", 3), is(\"evgeny\"));\n    assertThat(\"no measure on line\", fileLineMeasures.getStringValue(\"author\", 5), nullValue());\n  }","id":3877,"modified_method":"@Test\n  public void shouldLoadStringValues() {\n    when(measureCache.byMetric(\"foo:src/foo.php\", AUTHOR_METRIC_KEY)).thenReturn(new Measure(AUTHOR_METRIC_KEY).setData(\"1=simon;3=evgeny\"));\n\n    assertThat(fileLineMeasures.getStringValue(AUTHOR_METRIC_KEY, 1), is(\"simon\"));\n    assertThat(fileLineMeasures.getStringValue(AUTHOR_METRIC_KEY, 3), is(\"evgeny\"));\n    assertThat(\"no measure on line\", fileLineMeasures.getStringValue(AUTHOR_METRIC_KEY, 2), nullValue());\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotFailIfNoMeasureInIndex() {\n    assertThat(fileLineMeasures.getIntValue(\"hits\", 1), nullValue());\n    assertThat(fileLineMeasures.getStringValue(\"author\", 1), nullValue());\n  }","id":3878,"modified_method":"@Test\n  public void shouldNotFailIfNoMeasureInIndex() {\n    assertThat(fileLineMeasures.getIntValue(HITS_METRIC_KEY, 1), nullValue());\n    assertThat(fileLineMeasures.getStringValue(AUTHOR_METRIC_KEY, 1), nullValue());\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldSaveSeveral() {\n    fileLineMeasures.setIntValue(\"hits\", 1, 2);\n    fileLineMeasures.setIntValue(\"hits\", 3, 4);\n    fileLineMeasures.setStringValue(\"author\", 1, \"simon\");\n    fileLineMeasures.setStringValue(\"author\", 3, \"evgeny\");\n    fileLineMeasures.save();\n    fileLineMeasures.setIntValue(\"branches\", 1, 2);\n    fileLineMeasures.setIntValue(\"branches\", 3, 4);\n    fileLineMeasures.save();\n\n    verify(index, times(3)).addMeasure(Matchers.eq(resource), Matchers.any(Measure.class));\n  }","id":3879,"modified_method":"@Test\n  public void shouldSaveSeveral() {\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 1, 2);\n    fileLineMeasures.setIntValue(HITS_METRIC_KEY, 3, 4);\n    fileLineMeasures.setStringValue(AUTHOR_METRIC_KEY, 1, \"simon\");\n    fileLineMeasures.setStringValue(AUTHOR_METRIC_KEY, 3, \"evgeny\");\n    fileLineMeasures.save();\n    fileLineMeasures.setIntValue(BRANCHES_METRIC_KEY, 1, 2);\n    fileLineMeasures.setIntValue(BRANCHES_METRIC_KEY, 3, 4);\n    fileLineMeasures.save();\n\n    assertThat(sensorContextTester.measure(\"foo:src/foo.php\", HITS_METRIC_KEY).value()).isEqualTo(\"1=2;3=4\");\n    assertThat(sensorContextTester.measure(\"foo:src/foo.php\", AUTHOR_METRIC_KEY).value()).isEqualTo(\"1=simon;3=evgeny\");\n    assertThat(sensorContextTester.measure(\"foo:src/foo.php\", BRANCHES_METRIC_KEY).value()).isEqualTo(\"1=2;3=4\");\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldLoadIntValues() {\n    when(index.getMeasure(Matchers.any(Resource.class), Matchers.any(Metric.class)))\n      .thenReturn(new Measure(\"hits\").setData(\"1=2;3=4\"));\n\n    assertThat(fileLineMeasures.getIntValue(\"hits\", 1), is(2));\n    assertThat(fileLineMeasures.getIntValue(\"hits\", 3), is(4));\n    assertThat(\"no measure on line\", fileLineMeasures.getIntValue(\"hits\", 5), nullValue());\n  }","id":3880,"modified_method":"@Test\n  public void shouldLoadIntValues() {\n    when(measureCache.byMetric(\"foo:src/foo.php\", HITS_METRIC_KEY)).thenReturn(new Measure(HITS_METRIC_KEY).setData(\"1=2;3=4\"));\n\n    assertThat(fileLineMeasures.getIntValue(HITS_METRIC_KEY, 1), is(2));\n    assertThat(fileLineMeasures.getIntValue(HITS_METRIC_KEY, 3), is(4));\n    assertThat(\"no measure on line\", fileLineMeasures.getIntValue(HITS_METRIC_KEY, 2), nullValue());\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public DefaultMeasure<G> forMetric(Metric<G> metric) {\n    Preconditions.checkState(metric != null, \"Metric already defined\");\n    Preconditions.checkNotNull(metric, \"metric should be non null\");\n    this.metric = metric;\n    return this;\n  }","id":3881,"modified_method":"@Override\n  public DefaultMeasure<G> forMetric(Metric<G> metric) {\n    Preconditions.checkState(this.metric == null, \"Metric already defined\");\n    Preconditions.checkNotNull(metric, \"metric should be non null\");\n    this.metric = metric;\n    return this;\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addCoreComponents() {\n    ProjectDefinition moduleDefinition = getComponentByType(DefaultProjectTree.class).getProjectDefinition(module);\n    add(\n      moduleDefinition,\n      module,\n      getComponentByType(BatchComponentCache.class).get(module).inputComponent(),\n      ModuleSettings.class);\n\n    // hack to initialize settings before ExtensionProviders\n    ModuleSettings moduleSettings = getComponentByType(ModuleSettings.class);\n    module.setSettings(moduleSettings);\n\n    if (getComponentByType(AnalysisMode.class).isIssues()) {\n      add(IssuesPhaseExecutor.class,\n        IssuesReports.class);\n    } else {\n      add(PublishPhaseExecutor.class);\n    }\n\n    add(\n      EventBus.class,\n      RuleFinderCompatibility.class,\n      PostJobsExecutor.class,\n      SensorsExecutor.class,\n      InitializersExecutor.class,\n      ProjectInitializer.class,\n\n      // file system\n      ModuleInputFileCache.class,\n      FileExclusions.class,\n      ExclusionFilters.class,\n      DeprecatedFileFilters.class,\n      InputFileBuilderFactory.class,\n      FileMetadata.class,\n      StatusDetectionFactory.class,\n      LanguageDetectionFactory.class,\n      FileIndexer.class,\n      ComponentIndexer.class,\n      LanguageVerifier.class,\n      FileSystemLogger.class,\n      DefaultModuleFileSystem.class,\n      ModuleFileSystemInitializer.class,\n      QProfileVerifier.class,\n\n      SensorOptimizer.class,\n      PostJobOptimizer.class,\n\n      DefaultPostJobContext.class,\n      DefaultSensorStorage.class,\n      DeprecatedSensorContext.class,\n      BatchExtensionDictionnary.class,\n      IssueFilters.class,\n      CoverageExclusions.class,\n\n      // rules\n      new RulesProfileProvider(),\n      CheckFactory.class,\n\n      // issues\n      IssuableFactory.class,\n      ModuleIssues.class,\n      org.sonar.api.issue.NoSonarFilter.class,\n\n      // issue exclusions\n      IssueInclusionPatternInitializer.class,\n      IssueExclusionPatternInitializer.class,\n      IssueExclusionsRegexpScanner.class,\n      IssueExclusionsLoader.class,\n      EnforceIssuesFilter.class,\n      IgnoreIssuesFilter.class,\n\n      // Perspectives\n      BatchPerspectives.class,\n      HighlightableBuilder.class,\n      SymbolizableBuilder.class);\n  }","id":3882,"modified_method":"private void addCoreComponents() {\n    ProjectDefinition moduleDefinition = getComponentByType(DefaultProjectTree.class).getProjectDefinition(module);\n    add(\n      moduleDefinition,\n      module,\n      getComponentByType(BatchComponentCache.class).get(module).inputComponent(),\n      ModuleSettings.class);\n\n    // hack to initialize settings before ExtensionProviders\n    ModuleSettings moduleSettings = getComponentByType(ModuleSettings.class);\n    module.setSettings(moduleSettings);\n\n    if (getComponentByType(AnalysisMode.class).isIssues()) {\n      add(IssuesPhaseExecutor.class,\n        IssuesReports.class);\n    } else {\n      add(PublishPhaseExecutor.class);\n    }\n\n    add(\n      EventBus.class,\n      RuleFinderCompatibility.class,\n      PostJobsExecutor.class,\n      SensorsExecutor.class,\n      InitializersExecutor.class,\n      ProjectInitializer.class,\n\n      // file system\n      ModuleInputFileCache.class,\n      FileExclusions.class,\n      ExclusionFilters.class,\n      DeprecatedFileFilters.class,\n      InputFileBuilderFactory.class,\n      FileMetadata.class,\n      StatusDetectionFactory.class,\n      LanguageDetectionFactory.class,\n      FileIndexer.class,\n      ComponentIndexer.class,\n      LanguageVerifier.class,\n      FileSystemLogger.class,\n      DefaultModuleFileSystem.class,\n      ModuleFileSystemInitializer.class,\n      QProfileVerifier.class,\n\n      SensorOptimizer.class,\n      PostJobOptimizer.class,\n\n      DefaultPostJobContext.class,\n      DefaultSensorStorage.class,\n      DeprecatedSensorContext.class,\n      BatchExtensionDictionnary.class,\n      IssueFilters.class,\n      CoverageExclusions.class,\n\n      // rules\n      new RulesProfileProvider(),\n      CheckFactory.class,\n\n      // issues\n      IssuableFactory.class,\n      ModuleIssues.class,\n      org.sonar.api.issue.NoSonarFilter.class,\n\n      // issue exclusions\n      IssueInclusionPatternInitializer.class,\n      IssueExclusionPatternInitializer.class,\n      IssueExclusionsRegexpScanner.class,\n      IssueExclusionsLoader.class,\n      EnforceIssuesFilter.class,\n      IgnoreIssuesFilter.class,\n\n      // Perspectives\n      BatchPerspectives.class,\n      HighlightableBuilder.class,\n      SymbolizableBuilder.class,\n\n      DefaultFileLinesContextFactory.class);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addBatchComponents() {\n    add(\n      props,\n      DefaultAnalysisMode.class,\n      ProjectReactorBuilder.class,\n      WorkDirectoryCleaner.class,\n      new MutableProjectReactorProvider(),\n      new ImmutableProjectReactorProvider(),\n      ProjectBuildersExecutor.class,\n      ProjectLock.class,\n      EventBus.class,\n      PhasesTimeProfiler.class,\n      ResourceTypes.class,\n      DefaultProjectTree.class,\n      ProjectReactorValidator.class,\n      new AnalysisWSLoaderProvider(),\n      CodeColorizers.class,\n      MetricProvider.class,\n      ProjectConfigurator.class,\n      DefaultIndex.class,\n      DefaultFileLinesContextFactory.class,\n      Caches.class,\n      BatchComponentCache.class,\n      DefaultIssueCallback.class,\n      new RulesProvider(),\n      new ProjectRepositoriesProvider(),\n      new ProjectPersistentCacheProvider(),\n\n      // temp\n      new AnalysisTempFolderProvider(),\n\n      // file system\n      InputPathCache.class,\n      PathResolver.class,\n\n      // rules\n      new ActiveRulesProvider(),\n      new QualityProfileProvider(),\n\n      // issues\n      IssueCache.class,\n      DefaultProjectIssues.class,\n      IssueTransition.class,\n\n      // metrics\n      DefaultMetricFinder.class,\n      DeprecatedMetricFinder.class,\n\n      // tests\n      TestPlanBuilder.class,\n      TestableBuilder.class,\n\n      // lang\n      Languages.class,\n      DefaultLanguagesRepository.class,\n\n      // Measures\n      MeasureCache.class,\n\n      ProjectSettings.class,\n\n      // Report\n      ScannerMetrics.class,\n      ReportPublisher.class,\n      AnalysisContextReportPublisher.class,\n      MetadataPublisher.class,\n      ActiveRulesPublisher.class,\n      ComponentsPublisher.class,\n      MeasuresPublisher.class,\n      CoveragePublisher.class,\n      SourcePublisher.class,\n      TestExecutionAndCoveragePublisher.class,\n\n      // Cpd\n      CpdExecutor.class,\n      SonarCpdBlockIndex.class,\n\n      ScanTaskObservers.class,\n      UserRepositoryLoader.class);\n\n    addIfMissing(DefaultRulesLoader.class, RulesLoader.class);\n    addIfMissing(DefaultActiveRulesLoader.class, ActiveRulesLoader.class);\n    addIfMissing(DefaultQualityProfileLoader.class, QualityProfileLoader.class);\n    addIfMissing(DefaultProjectRepositoriesLoader.class, ProjectRepositoriesLoader.class);\n  }","id":3883,"modified_method":"private void addBatchComponents() {\n    add(\n      props,\n      DefaultAnalysisMode.class,\n      ProjectReactorBuilder.class,\n      WorkDirectoryCleaner.class,\n      new MutableProjectReactorProvider(),\n      new ImmutableProjectReactorProvider(),\n      ProjectBuildersExecutor.class,\n      ProjectLock.class,\n      EventBus.class,\n      PhasesTimeProfiler.class,\n      ResourceTypes.class,\n      DefaultProjectTree.class,\n      ProjectReactorValidator.class,\n      new AnalysisWSLoaderProvider(),\n      CodeColorizers.class,\n      MetricProvider.class,\n      ProjectConfigurator.class,\n      DefaultIndex.class,\n      Caches.class,\n      BatchComponentCache.class,\n      DefaultIssueCallback.class,\n      new RulesProvider(),\n      new ProjectRepositoriesProvider(),\n      new ProjectPersistentCacheProvider(),\n\n      // temp\n      new AnalysisTempFolderProvider(),\n\n      // file system\n      InputPathCache.class,\n      PathResolver.class,\n\n      // rules\n      new ActiveRulesProvider(),\n      new QualityProfileProvider(),\n\n      // issues\n      IssueCache.class,\n      DefaultProjectIssues.class,\n      IssueTransition.class,\n\n      // metrics\n      DefaultMetricFinder.class,\n      DeprecatedMetricFinder.class,\n\n      // tests\n      TestPlanBuilder.class,\n      TestableBuilder.class,\n\n      // lang\n      Languages.class,\n      DefaultLanguagesRepository.class,\n\n      // Measures\n      MeasureCache.class,\n\n      ProjectSettings.class,\n\n      // Report\n      ScannerMetrics.class,\n      ReportPublisher.class,\n      AnalysisContextReportPublisher.class,\n      MetadataPublisher.class,\n      ActiveRulesPublisher.class,\n      ComponentsPublisher.class,\n      MeasuresPublisher.class,\n      CoveragePublisher.class,\n      SourcePublisher.class,\n      TestExecutionAndCoveragePublisher.class,\n\n      // Cpd\n      CpdExecutor.class,\n      SonarCpdBlockIndex.class,\n\n      ScanTaskObservers.class,\n      UserRepositoryLoader.class);\n\n    addIfMissing(DefaultRulesLoader.class, RulesLoader.class);\n    addIfMissing(DefaultActiveRulesLoader.class, ActiveRulesLoader.class);\n    addIfMissing(DefaultQualityProfileLoader.class, QualityProfileLoader.class);\n    addIfMissing(DefaultProjectRepositoriesLoader.class, ProjectRepositoriesLoader.class);\n  }","commit_id":"03a0d8af47f6fb3acd5156b133ffbfea9d1d1586","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Initializes context.\n     */\n    public MarshallerContextAdapter() {\n        try {\n            ClassLoader ldr = U.gridClassLoader();\n\n            Enumeration<URL> urls = ldr.getResources(CLS_NAMES_FILE);\n\n            while (urls.hasMoreElements())\n                processResource(urls.nextElement());\n\n            processResource(ldr.getResource(JDK_CLS_NAMES_FILE));\n        }\n        catch (IOException e) {\n            throw new IllegalStateException(\"Failed to initialize marshaller context.\", e);\n        }\n    }","id":3884,"modified_method":"/**\n     * Initializes context.\n     */\n    public MarshallerContextAdapter() {\n        try {\n            ClassLoader ldr = U.gridClassLoader();\n\n            Enumeration<URL> urls = ldr.getResources(CLS_NAMES_FILE);\n\n            boolean foundClsNames = false;\n\n            while (urls.hasMoreElements()) {\n                processResource(urls.nextElement());\n\n                foundClsNames = true;\n            }\n\n            if (!foundClsNames)\n                throw new IgniteException(\"Failed to load class names properties file packaged with ignite binaries \" +\n                    \"[file=\" + CLS_NAMES_FILE + \", ldr=\" + ldr + ']');\n\n            URL jdkClsNames = ldr.getResource(JDK_CLS_NAMES_FILE);\n\n            if (jdkClsNames == null)\n                throw new IgniteException(\"Failed to load class names properties file packaged with ignite binaries \" +\n                    \"[file=\" + JDK_CLS_NAMES_FILE + \", ldr=\" + ldr + ']');\n\n            processResource(jdkClsNames);\n\n            checkHasClassName(GridDhtPartitionFullMap.class.getName(), ldr, CLS_NAMES_FILE);\n            checkHasClassName(GridDhtPartitionMap.class.getName(), ldr, CLS_NAMES_FILE);\n            checkHasClassName(HashMap.class.getName(), ldr, JDK_CLS_NAMES_FILE);\n        }\n        catch (IOException e) {\n            throw new IllegalStateException(\"Failed to initialize marshaller context.\", e);\n        }\n    }","commit_id":"8467a3c36414192268b8d852715fc501f53b4772","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n\tpublic Time lastModifiedTime()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ServletContext context = ((WebApplication)Application.get()).getServletContext();\n\n\t\t\treturn Connections.getLastModified(context.getResource(url));\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tlog.warn(\"failed to retrieve last modified timestamp\", e);\n\t\t\treturn null;\n\t\t}\n\t}","id":3885,"modified_method":"@Override\n\tpublic Time lastModifiedTime()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ServletContext context = ((WebApplication)Application.get()).getServletContext();\n\t\t\tfinal URL resourceURL = context.getResource(url);\n\t\t\tif (resourceURL == null)\n\t\t\t{\n\t\t\t\tthrow new FileNotFoundException(\"Unable to find resource '\" + url +\n\t\t\t\t\t\"' in the serlvet context\");\n\t\t\t}\n\n\t\t\treturn Connections.getLastModified(resourceURL);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tlog.warn(\"failed to retrieve last modified timestamp\", e);\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"fadf81631d46341c95bec29816418c1647870890","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Optimized implementation: first checks if a range index is defined\n\t * on the nodes in the left argument. If that fails, check if we can use\n\t * the fulltext index to speed up the search. Otherwise, fall back to\n\t * {@link #nodeSetCompare(NodeSet, Sequence)}.\n\t */\n\tprotected Sequence quickNodeSetCompare(Sequence contextSequence) throws XPathException {\n\n\t\t/* TODO think about optimising fallback to NodeSetCompare() in the for loop!!!\n\t\t * At the moment when we fallback to NodeSetCompare() we are in effect throwing away any nodes\n\t\t * we have already processed in quickNodeSetCompare() and reprocessing all the nodes in NodeSetCompare().\n\t\t * Instead - Could we create a NodeCompare() (based on NodeSetCompare() code) to only compare a single node and then union the result?\n\t\t * - deliriumsky\n\t\t */\n\n\t\t/* TODO think about caching of results in this function...\n\t\t * also examine and check if correct (line near the end) -\n\t\t * \t boolean canCache = contextSequence instanceof NodeSet && (getRight().getDependencies() & Dependency.VARS) == 0 && (getLeft().getDependencies() & Dependency.VARS) == 0;\n\t\t *  - deliriumsky\n\t\t */\n\n\t\tif (context.getProfiler().isEnabled())\n\t\t\tcontext.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION CHOICE\", \"quickNodeSetCompare\");\n\n\t\t// if the context sequence hasn't changed we can return a cached result\n\t\tif(cached != null && cached.isValid(contextSequence)) {\n\t\t\tLOG.debug(\"Using cached results\");\n            if(context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Returned cached result\");\n\t\t\treturn(cached.getResult());\n\t\t}\n\n\t\t//get the NodeSet on the left\n\t\tNodeSet nodes = (NodeSet) getLeft().eval(contextSequence);\n\t\tif(!(nodes instanceof VirtualNodeSet) && nodes.isEmpty()) //nothing on the left, so nothing to do\n            return(Sequence.EMPTY_SEQUENCE);\n\n        //get the Sequence on the right\n\t\tSequence rightSeq = getRight().eval(contextSequence);\n\t\tif(rightSeq.isEmpty())\t//nothing on the right, so nothing to do\n            return(Sequence.EMPTY_SEQUENCE);\n\n\t\t//Holds the result\n\t\tNodeSet result = null;\n\n\t\t//get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n        \n        //See if we have a range index defined on the nodes in this sequence\n        //TODO : use isSubType ??? -pb\n\t\t//rememeber that Type.ITEM means... no index ;-)\n\t    if(indexType != Type.ITEM) {\n\t    \tif (LOG.isTraceEnabled())\n\t    \t\tLOG.trace(\"found an index of type: \" + Type.getTypeName(indexType));\n\n\t    \t//Get the documents from the node set\n\t\t\tDocumentSet docs = nodes.getDocumentSet();\n\n\t\t\t//Iterate through the right hand sequence\n\t\t\tfor (SequenceIterator itRightSeq = rightSeq.iterate(); itRightSeq.hasNext();) {\n\t\t\t\t//Get the index key\n\t\t\t\tItem key = itRightSeq.nextItem().atomize();\n\n\t\t\t\t//if key has truncation, convert it to string\n\t\t        if(truncation != Constants.TRUNC_NONE) {\n\t\t        \t//TODO : log this conversion ? -pb\n\t\t        \t//truncation is only possible on strings\n\t\t        \tkey = key.convertTo(Type.STRING);\n\t\t        }\n\t\t        //else if key is not the same type as the index\n                //TODO : use isSubType ??? -pb\n\t\t        else if (key.getType() != indexType) {\n\t\t        \t//try and convert the key to the index type\n\t            \ttry\t{\n\t            \t\tkey = key.convertTo(indexType);\n\t\t\t\t\t} catch(XPathException xpe)\t{\n\t            \t\t//TODO : rethrow the exception ? -pb\n\n\t\t\t        \t//Could not convert the key to a suitable type for the index, fallback to nodeSetCompare()\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (\" + xpe.getMessage() + \")\");\n\n\t\t                if (LOG.isTraceEnabled())\n\t\t                \tLOG.trace(\"Cannot convert key: \" + Type.getTypeName(key.getType()) + \" to required index type: \" + Type.getTypeName(indexType));\n\n\t\t\t            return nodeSetCompare(nodes, contextSequence);\n\t\t\t\t\t}\n\t\t        }\n\n\t\t        // If key implements org.exist.storage.Indexable, we can use the index\n\t\t        if (key instanceof Indexable) {\n\t\t        \tif (LOG.isTraceEnabled())\n\t\t        \t\tLOG.trace(\"Checking if range index can be used for key: \" + key.getStringValue());\n\n\t\t        \tif (Type.subTypeOf(key.getType(), indexType)) {\n\t\t\t        \tif(truncation == Constants.TRUNC_NONE) {\n\t\t\t        \t\tif (LOG.isTraceEnabled())\n\t\t\t        \t\t\tLOG.trace(\"Using range index for key: \" + key.getStringValue());\n\n\t\t\t        \t\t//key without truncation, find key\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() +\n\t\t                    \t\t\"' to find key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\n                            if (!checkForQNameIndex(contextSequence)) {\n                                LOG.trace(\"Cannot use QName index\");\n                                contextQName = null;\n                            }\n                            \n                            NodeSet ns = context.getBroker().getValueIndex().find(relation, docs, nodes, NodeSet.ANCESTOR, contextQName, (Indexable)key);\n\t\t                    hasUsedIndex = true;\n\n\t\t                    if (result == null)\n\t\t\t\t\t\t\t\tresult = ns;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult = result.union(ns);\n\n\t\t                } else {\n\t\t\t\t        \t//key with truncation, match key\n                            if (LOG.isTraceEnabled())\n                                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() +\n\t\t                    \t\t\"' to match key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\n                            if (LOG.isTraceEnabled())\n\t\t\t        \t\t\tLOG.trace(\"Using range index for key: \" + key.getStringValue());\n\n                            try {\n\t\t\t\t\t\t\t\tNodeSet ns = context.getBroker().getValueIndex().match(docs, nodes, NodeSet.ANCESTOR,\n                                        getRegexp(key.getStringValue()).toString(), null, DBBroker.MATCH_REGEXP);\n\t\t\t\t\t\t\t\thasUsedIndex = true;\n\n\t\t\t\t\t\t\t\tif (result == null)\n\t\t\t\t\t\t\t\t\tresult = ns;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tresult = result.union(ns);\n\n\t\t\t\t\t\t\t} catch (EXistException e) {\n\t\t\t\t\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t        } else {\n\t\t\t        \t//the datatype of our key does not\n\t\t\t        \t//implement org.exist.storage.Indexable or is not of the correct type\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (key is of type: \" +\n\t\t                    \t\tType.getTypeName(key.getType()) + \") whereas index is of type '\" + Type.getTypeName(indexType) + \"'\");\n\n\t\t                if (LOG.isTraceEnabled())\n\t\t                \tLOG.trace(\"Cannot use range index: key is of type: \" + Type.getTypeName(key.getType()) + \") whereas index is of type '\" +\n\t\t                \t\t\tType.getTypeName(indexType));\n\n\t\t                return(nodeSetCompare(nodes, contextSequence));\n\t\t\t        }\n\t\t        } else {\n\t\t        \t//the datatype of our key does not implement org.exist.storage.Indexable\n\t                if(context.getProfiler().isEnabled())\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (key is not an indexable type: \" +\n\t                    \t\tkey.getClass().getName());\n\n\t                return(nodeSetCompare(nodes, contextSequence));\n\n\t\t        }\n            }\n\t\t} else {\n\t    \tif (LOG.isTraceEnabled())\n\t    \t\tLOG.trace(\"No suitable index found for key: \" + rightSeq.getStringValue());\n\n\t    \t//no range index defined on the nodes in this sequence, so fallback to nodeSetCompare\n            if(context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (no index available)\");\n\n            return(nodeSetCompare(nodes, contextSequence));\n\t\t}\n\n\t\t// can this result be cached? Don't cache if the result depends on local variables.\n\t    boolean canCache = contextSequence instanceof NodeSet &&\n\t    \t!Dependency.dependsOnVar(getLeft()) &&\n\t    \t!Dependency.dependsOnVar(getRight());\n\n\t    if(canCache)\n\t\t\tcached = new CachedResult((NodeSet)contextSequence, result);\n\n\t\t//return the result of the range index lookup(s) :-)\n\t\treturn result;\n\t}","id":3886,"modified_method":"/**\n\t * Optimized implementation: first checks if a range index is defined\n\t * on the nodes in the left argument. If that fails, check if we can use\n\t * the fulltext index to speed up the search. Otherwise, fall back to\n\t * {@link #nodeSetCompare(NodeSet, Sequence)}.\n\t */\n\tprotected Sequence quickNodeSetCompare(Sequence contextSequence) throws XPathException {\n\n\t\t/* TODO think about optimising fallback to NodeSetCompare() in the for loop!!!\n\t\t * At the moment when we fallback to NodeSetCompare() we are in effect throwing away any nodes\n\t\t * we have already processed in quickNodeSetCompare() and reprocessing all the nodes in NodeSetCompare().\n\t\t * Instead - Could we create a NodeCompare() (based on NodeSetCompare() code) to only compare a single node and then union the result?\n\t\t * - deliriumsky\n\t\t */\n\n\t\t/* TODO think about caching of results in this function...\n\t\t * also examine and check if correct (line near the end) -\n\t\t * \t boolean canCache = contextSequence instanceof NodeSet && (getRight().getDependencies() & Dependency.VARS) == 0 && (getLeft().getDependencies() & Dependency.VARS) == 0;\n\t\t *  - deliriumsky\n\t\t */\n\n\t\tif (context.getProfiler().isEnabled())\n\t\t\tcontext.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION CHOICE\", \"quickNodeSetCompare\");\n\n\t\t//get the NodeSet on the left\n\t\tNodeSet nodes = (NodeSet) getLeft().eval(contextSequence);\n\t\t//nothing on the left, so nothing to do\n\t\tif(!(nodes instanceof VirtualNodeSet) && nodes.isEmpty()) {\n\t\t\t//Well, we might discuss this one ;-)\n\t\t\thasUsedIndex= true;\n            return Sequence.EMPTY_SEQUENCE;\n\t\t}\n\n        //get the Sequence on the right\n\t\tSequence rightSeq = getRight().eval(contextSequence);\n\t\t//nothing on the right, so nothing to do\n\t\tif(rightSeq.isEmpty()) {\n\t\t\t//Well, we might discuss this one ;-)\n\t\t\thasUsedIndex= true;\n            return Sequence.EMPTY_SEQUENCE;\n\t\t}\n\t\t\n\t\t//get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n        \n        //See if we have a range index defined on the nodes in this sequence\n        //TODO : use isSubType ??? -pb\n\t\t//rememeber that Type.ITEM means... no index ;-)\n\t    if(indexType != Type.ITEM) {\n\t    \tif (LOG.isTraceEnabled())\n\t    \t\tLOG.trace(\"found an index of type: \" + Type.getTypeName(indexType));\n\n\t    \t//Get the documents from the node set\n\t\t\tDocumentSet docs = nodes.getDocumentSet();\n\t\t\t\n\t        //Holds the result\n    \t\tNodeSet result = null;\n\n\t\t\t//Iterate through the right hand sequence\n\t\t\tfor (SequenceIterator itRightSeq = rightSeq.iterate(); itRightSeq.hasNext();) {\n\t\t\t\t//Get the index key\n\t\t\t\tItem key = itRightSeq.nextItem().atomize();\n\n\t\t\t\t//if key has truncation, convert it to string\n\t\t        if(truncation != Constants.TRUNC_NONE) {\n\t\t        \t//TODO : log this conversion ? -pb\n\t\t        \t//truncation is only possible on strings\n\t\t        \tkey = key.convertTo(Type.STRING);\n\t\t        }\n\t\t        //else if key is not the same type as the index\n                //TODO : use isSubType ??? -pb\n\t\t        else if (key.getType() != indexType) {\n\t\t        \t//try and convert the key to the index type\n\t            \ttry\t{\n\t            \t\tkey = key.convertTo(indexType);\n\t\t\t\t\t} catch(XPathException xpe)\t{\n\t            \t\t//TODO : rethrow the exception ? -pb\n\n\t\t\t        \t//Could not convert the key to a suitable type for the index, fallback to nodeSetCompare()\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (\" + xpe.getMessage() + \")\");\n\n\t\t                if (LOG.isTraceEnabled())\n\t\t                \tLOG.trace(\"Cannot convert key: \" + Type.getTypeName(key.getType()) + \" to required index type: \" + Type.getTypeName(indexType));\n\n\t\t\t            return nodeSetCompare(nodes, contextSequence);\n\t\t\t\t\t}\n\t\t        }\n\n\t\t        // If key implements org.exist.storage.Indexable, we can use the index\n\t\t        if (key instanceof Indexable) {\n\t\t        \tif (LOG.isTraceEnabled())\n\t\t        \t\tLOG.trace(\"Checking if range index can be used for key: \" + key.getStringValue());\n\n\t\t        \tif (Type.subTypeOf(key.getType(), indexType)) {\n\t\t\t        \tif(truncation == Constants.TRUNC_NONE) {\n\t\t\t        \t\tif (LOG.isTraceEnabled())\n\t\t\t        \t\t\tLOG.trace(\"Using range index for key: \" + key.getStringValue());\n\n\t\t\t        \t\t//key without truncation, find key\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() +\n\t\t                    \t\t\"' to find key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\n                            if (!checkForQNameIndex(contextSequence)) {\n                                LOG.trace(\"Cannot use QName index\");\n                                contextQName = null;\n                            }\n                            \n                            NodeSet ns = context.getBroker().getValueIndex().find(relation, docs, nodes, NodeSet.ANCESTOR, contextQName, (Indexable)key);\n\t\t                    hasUsedIndex = true;\n\n\t\t                    if (result == null)\n\t\t\t\t\t\t\t\tresult = ns;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult = result.union(ns);\n\n\t\t                } else {\n\t\t\t\t        \t//key with truncation, match key\n                            if (LOG.isTraceEnabled())\n                                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() +\n\t\t                    \t\t\"' to match key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\n                            if (LOG.isTraceEnabled())\n\t\t\t        \t\t\tLOG.trace(\"Using range index for key: \" + key.getStringValue());\n\n                            try {\n\t\t\t\t\t\t\t\tNodeSet ns = context.getBroker().getValueIndex().match(docs, nodes, NodeSet.ANCESTOR,\n                                        getRegexp(key.getStringValue()).toString(), null, DBBroker.MATCH_REGEXP);\n\t\t\t\t\t\t\t\thasUsedIndex = true;\n\n\t\t\t\t\t\t\t\tif (result == null)\n\t\t\t\t\t\t\t\t\tresult = ns;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tresult = result.union(ns);\n\n\t\t\t\t\t\t\t} catch (EXistException e) {\n\t\t\t\t\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t        } else {\n\t\t\t        \t//the datatype of our key does not\n\t\t\t        \t//implement org.exist.storage.Indexable or is not of the correct type\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (key is of type: \" +\n\t\t                    \t\tType.getTypeName(key.getType()) + \") whereas index is of type '\" + Type.getTypeName(indexType) + \"'\");\n\n\t\t                if (LOG.isTraceEnabled())\n\t\t                \tLOG.trace(\"Cannot use range index: key is of type: \" + Type.getTypeName(key.getType()) + \") whereas index is of type '\" +\n\t\t                \t\t\tType.getTypeName(indexType));\n\n\t\t                return nodeSetCompare(nodes, contextSequence);\n\t\t\t        }\t\t        \t\n\t\t        } else {\n\t\t        \t//our key does not implement org.exist.storage.Indexable\n\t                if(context.getProfiler().isEnabled())\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (key is not an indexable type: \" +\n\t                    \t\tkey.getClass().getName());\n\n\t                if (LOG.isTraceEnabled())\n\t                \tLOG.trace(\"Cannot use key which is of type '\"  + key.getClass().getName());\n\n\t                return nodeSetCompare(nodes, contextSequence);\n\n\t\t        }\n            }\n        \treturn result;\n\t\t} else {\n\t    \tif (LOG.isTraceEnabled())\n\t    \t\tLOG.trace(\"No suitable index found for key: \" + rightSeq.getStringValue());\n\n\t    \t//no range index defined on the nodes in this sequence, so fallback to nodeSetCompare\n            if(context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (no index available)\");\n\n            return nodeSetCompare(nodes, contextSequence);\n\t\t}\n\t}","commit_id":"4a51b5c849ceec88ef7103940df291a2b8cdf652","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n\n        // if we were optimizing and the preselect did not return anything,\n        // we won't have any matches and can return\n        if (preselectResult != null && preselectResult.isEmpty())\n            return Sequence.EMPTY_SEQUENCE;\n\n        Sequence result;\n\n        if (contextStep == null || preselectResult == null) {\n            /*\n             * If we are inside a predicate and one of the arguments is a node set,\n             * we try to speed up the query by returning nodes from the context set.\n             * This works only inside a predicate. The node set will always be the left\n             * operand.\n             */\n            if (inPredicate && !invalidNodeEvaluation &&\n                    !Dependency.dependsOn(this, Dependency.CONTEXT_ITEM) &&\n                    Type.subTypeOf(getLeft().returnsType(), Type.NODE)) {\n\n                if(contextItem != null)\n                    contextSequence = contextItem.toSequence();\n\n                if ((!Dependency.dependsOn(rightOpDeps, Dependency.CONTEXT_ITEM))) {\n                    result = quickNodeSetCompare(contextSequence);\n                } else {\n                    result = nodeSetCompare(contextSequence);\n                }\n            } else {\n                result = genericCompare(contextSequence, contextItem);\n            }\n        } else {\n            contextStep.setPreloadNodeSets(true);\n            contextStep.setPreloadedData(preselectResult.getDocumentSet(), preselectResult);\n\n            result = getLeft().eval(contextSequence).toNodeSet();\n        }\n\n        if (context.getProfiler().isEnabled())\n            context.getProfiler().end(this, \"\", result);\n\n        return result;\n\t}","id":3887,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n\n        Sequence result;\n\n        // if the context sequence hasn't changed we can return a cached result\n\t\tif (cached != null && cached.isValid(contextSequence)) {\n\t\t\tLOG.debug(\"Using cached results\");\n            if(context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Returned cached result\");\n\t\t\tresult = cached.getResult();\n\t\t\n\t\t} else {\n\n\t\t\t// if we were optimizing and the preselect did not return anything,\n\t        // we won't have any matches and can return\n\t        if (preselectResult != null && preselectResult.isEmpty())\n\t            result = Sequence.EMPTY_SEQUENCE;\n\t        \n\t        else {\n\t\t        if (contextStep == null || preselectResult == null) {\n\t\t            /*\n\t\t             * If we are inside a predicate and one of the arguments is a node set,\n\t\t             * we try to speed up the query by returning nodes from the context set.\n\t\t             * This works only inside a predicate. The node set will always be the left\n\t\t             * operand.\n\t\t             */\n\t\t            if (inPredicate && !invalidNodeEvaluation &&\n\t\t                    !Dependency.dependsOn(this, Dependency.CONTEXT_ITEM) &&\n\t\t                    Type.subTypeOf(getLeft().returnsType(), Type.NODE)) {\n\t\t\n\t\t                if(contextItem != null)\n\t\t                    contextSequence = contextItem.toSequence();\n\t\t\n\t\t                if ((!Dependency.dependsOn(rightOpDeps, Dependency.CONTEXT_ITEM))) {\n\t\t                    result = quickNodeSetCompare(contextSequence);\n\t\t                } else {\n\t\t                    result = nodeSetCompare(contextSequence);\n\t\t                }\n\t\t            } else {\n\t\t                result = genericCompare(contextSequence, contextItem);\n\t\t            }\n\t\t        } else {\n\t\t            contextStep.setPreloadNodeSets(true);\n\t\t            contextStep.setPreloadedData(preselectResult.getDocumentSet(), preselectResult);\n\t\t\n\t\t            result = getLeft().eval(contextSequence).toNodeSet();\n\t\t \n\t\t        }\n\t\t    }\n\t        \n\t\t\t// can this result be cached? Don't cache if the result depends on local variables.\n\t\t    boolean canCache = contextSequence instanceof NodeSet &&\n\t\t    \t!Dependency.dependsOn(getLeft(), Dependency.CONTEXT_ITEM) &&\n\t\t    \t!Dependency.dependsOn(getRight(), Dependency.CONTEXT_ITEM) &&\n\t\t    \t!Dependency.dependsOnVar(getLeft()) &&\n\t\t    \t!Dependency.dependsOnVar(getRight());\n\n\t\t    if(canCache)\n\t\t\t\tcached = new CachedResult((NodeSet)contextSequence, result);\n\n\t\t}\n\t\t\n        if (context.getProfiler().isEnabled())\n            context.getProfiler().end(this, \"\", result);\n\n        return result;\n\t}","commit_id":"4a51b5c849ceec88ef7103940df291a2b8cdf652","url":"https://github.com/eXist-db/exist"},{"original_method":"protected Object getContent(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tString minifierType = ParamUtil.getString(request, \"minifierType\");\n\t\tString minifierBundleId = ParamUtil.getString(\n\t\t\trequest, \"minifierBundleId\");\n\t\tString minifierBundleDir = ParamUtil.getString(\n\t\t\trequest, \"minifierBundleDir\");\n\n\t\tif (Validator.isNull(minifierType) ||\n\t\t\tValidator.isNotNull(minifierBundleId) ||\n\t\t\tValidator.isNotNull(minifierBundleDir)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString requestURI = request.getRequestURI();\n\n\t\tString resourcePath = requestURI;\n\n\t\tString contextPath = request.getContextPath();\n\n\t\tif (!contextPath.equals(StringPool.SLASH)) {\n\t\t\tresourcePath = resourcePath.substring(contextPath.length());\n\t\t}\n\n\t\tURL resourceURL = _servletContext.getResource(resourcePath);\n\n\t\tif (resourceURL == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tURLConnection urlConnection = resourceURL.openConnection();\n\n\t\tString cacheCommonFileName = getCacheFileName(request);\n\n\t\tFile cacheContentTypeFile = new File(\n\t\t\t_tempDir, cacheCommonFileName + \"_E_CONTENT_TYPE\");\n\t\tFile cacheDataFile = new File(\n\t\t\t_tempDir, cacheCommonFileName + \"_E_DATA\");\n\n\t\tif (cacheDataFile.exists() &&\n\t\t\t(cacheDataFile.lastModified() >= urlConnection.getLastModified())) {\n\n\t\t\tif (cacheContentTypeFile.exists()) {\n\t\t\t\tString contentType = FileUtil.read(cacheContentTypeFile);\n\n\t\t\t\tresponse.setContentType(contentType);\n\t\t\t}\n\n\t\t\treturn cacheDataFile;\n\t\t}\n\n\t\tString content = null;\n\n\t\tif (resourcePath.endsWith(_CSS_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying CSS \" + resourcePath);\n\t\t\t}\n\n\t\t\tcontent = getCssContent(\n\t\t\t\trequest, response, resourceURL, resourcePath);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_CSS);\n\n\t\t\tFileUtil.write(cacheContentTypeFile, ContentTypes.TEXT_CSS);\n\t\t}\n\t\telse if (resourcePath.endsWith(_JAVASCRIPT_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying JavaScript \" + resourcePath);\n\t\t\t}\n\n\t\t\tcontent = getJavaScriptContent(resourceURL);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\tFileUtil.write(cacheContentTypeFile, ContentTypes.TEXT_JAVASCRIPT);\n\t\t}\n\t\telse if (resourcePath.endsWith(_JSP_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying JSP \" + resourcePath);\n\t\t\t}\n\n\t\t\tBufferCacheServletResponse bufferCacheServletResponse =\n\t\t\t\tnew BufferCacheServletResponse(response);\n\n\t\t\tprocessFilter(\n\t\t\t\tAggregateFilter.class, request, bufferCacheServletResponse,\n\t\t\t\tfilterChain);\n\n\t\t\tbufferCacheServletResponse.finishResponse();\n\n\t\t\tcontent = bufferCacheServletResponse.getString();\n\n\t\t\tif (minifierType.equals(\"css\")) {\n\t\t\t\tcontent = getCssContent(\n\t\t\t\t\trequest, response, resourcePath, content);\n\t\t\t}\n\t\t\telse if (minifierType.equals(\"js\")) {\n\t\t\t\tcontent = getJavaScriptContent(content);\n\t\t\t}\n\n\t\t\tFileUtil.write(\n\t\t\t\tcacheContentTypeFile,\n\t\t\t\tbufferCacheServletResponse.getContentType());\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tFileUtil.write(cacheDataFile, content);\n\n\t\treturn content;\n\t}","id":3888,"modified_method":"protected Object getContent(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tString minifierType = ParamUtil.getString(request, \"minifierType\");\n\t\tString minifierBundleId = ParamUtil.getString(\n\t\t\trequest, \"minifierBundleId\");\n\t\tString minifierBundleDirName = ParamUtil.getString(\n\t\t\trequest, \"minifierBundleDir\");\n\n\t\tif (Validator.isNull(minifierType) ||\n\t\t\tValidator.isNotNull(minifierBundleId) ||\n\t\t\tValidator.isNotNull(minifierBundleDirName)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString requestURI = request.getRequestURI();\n\n\t\tString resourcePath = requestURI;\n\n\t\tString contextPath = request.getContextPath();\n\n\t\tif (!contextPath.equals(StringPool.SLASH)) {\n\t\t\tresourcePath = resourcePath.substring(contextPath.length());\n\t\t}\n\n\t\tURL resourceURL = _servletContext.getResource(resourcePath);\n\n\t\tif (resourceURL == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tURLConnection urlConnection = resourceURL.openConnection();\n\n\t\tString cacheCommonFileName = getCacheFileName(request);\n\n\t\tFile cacheContentTypeFile = new File(\n\t\t\t_tempDir, cacheCommonFileName + \"_E_CONTENT_TYPE\");\n\t\tFile cacheDataFile = new File(\n\t\t\t_tempDir, cacheCommonFileName + \"_E_DATA\");\n\n\t\tif (cacheDataFile.exists() &&\n\t\t\t(cacheDataFile.lastModified() >= urlConnection.getLastModified())) {\n\n\t\t\tif (cacheContentTypeFile.exists()) {\n\t\t\t\tString contentType = FileUtil.read(cacheContentTypeFile);\n\n\t\t\t\tresponse.setContentType(contentType);\n\t\t\t}\n\n\t\t\treturn cacheDataFile;\n\t\t}\n\n\t\tString content = null;\n\n\t\tif (resourcePath.endsWith(_CSS_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying CSS \" + resourcePath);\n\t\t\t}\n\n\t\t\tcontent = getCssContent(\n\t\t\t\trequest, response, resourceURL, resourcePath);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_CSS);\n\n\t\t\tFileUtil.write(cacheContentTypeFile, ContentTypes.TEXT_CSS);\n\t\t}\n\t\telse if (resourcePath.endsWith(_JAVASCRIPT_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying JavaScript \" + resourcePath);\n\t\t\t}\n\n\t\t\tcontent = getJavaScriptContent(resourceURL);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\tFileUtil.write(cacheContentTypeFile, ContentTypes.TEXT_JAVASCRIPT);\n\t\t}\n\t\telse if (resourcePath.endsWith(_JSP_EXTENSION)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Minifying JSP \" + resourcePath);\n\t\t\t}\n\n\t\t\tBufferCacheServletResponse bufferCacheServletResponse =\n\t\t\t\tnew BufferCacheServletResponse(response);\n\n\t\t\tprocessFilter(\n\t\t\t\tAggregateFilter.class, request, bufferCacheServletResponse,\n\t\t\t\tfilterChain);\n\n\t\t\tbufferCacheServletResponse.finishResponse();\n\n\t\t\tcontent = bufferCacheServletResponse.getString();\n\n\t\t\tif (minifierType.equals(\"css\")) {\n\t\t\t\tcontent = getCssContent(\n\t\t\t\t\trequest, response, resourcePath, content);\n\t\t\t}\n\t\t\telse if (minifierType.equals(\"js\")) {\n\t\t\t\tcontent = getJavaScriptContent(content);\n\t\t\t}\n\n\t\t\tFileUtil.write(\n\t\t\t\tcacheContentTypeFile,\n\t\t\t\tbufferCacheServletResponse.getContentType());\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tFileUtil.write(cacheDataFile, content);\n\n\t\treturn content;\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object getBundleContent(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tString minifierType = ParamUtil.getString(request, \"minifierType\");\n\t\tString bundleId = ParamUtil.getString(\n\t\t\trequest, \"bundleId\",\n\t\t\tParamUtil.getString(request, \"minifierBundleId\"));\n\n\t\tif (Validator.isNull(minifierType) ||\n\t\t\tValidator.isNull(bundleId) ||\n\t\t\t!ArrayUtil.contains(PropsValues.JAVASCRIPT_BUNDLE_IDS, bundleId)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString bundleDir = PropsUtil.get(\n\t\t\tPropsKeys.JAVASCRIPT_BUNDLE_DIR, new Filter(bundleId));\n\n\t\tURL bundleDirURL = _servletContext.getResource(bundleDir);\n\n\t\tif (bundleDirURL == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString cacheFileName = getCacheFileName(request);\n\n\t\tString[] fileNames = JavaScriptBundleUtil.getFileNames(bundleId);\n\n\t\tFile cacheFile = new File(_tempDir, cacheFileName);\n\n\t\tif (_limitedFilesCache != null) {\n\t\t\t_limitedFilesCache.put(cacheFileName);\n\t\t}\n\n\t\tif (cacheFile.exists()) {\n\t\t\tboolean staleCache = false;\n\n\t\t\tfor (String fileName : fileNames) {\n\t\t\t\tURL resourceURL = _servletContext.getResource(\n\t\t\t\t\tbundleDir.concat(StringPool.SLASH).concat(fileName));\n\n\t\t\t\tif (resourceURL == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tURLConnection urlConnection = resourceURL.openConnection();\n\n\t\t\t\tif (urlConnection.getLastModified() >\n\t\t\t\t\t\tcacheFile.lastModified()) {\n\n\t\t\t\t\tstaleCache = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!staleCache) {\n\t\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\t\treturn cacheFile;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Aggregating JavaScript bundle \" + bundleId);\n\t\t}\n\n\t\tString content = null;\n\n\t\tif (fileNames.length == 0) {\n\t\t\tcontent = StringPool.BLANK;\n\t\t}\n\t\telse {\n\t\t\tAggregateContext aggregateContext = new ServletAggregateContext(\n\t\t\t\t_servletContext, StringPool.SLASH);\n\n\t\t\taggregateContext.pushPath(bundleDir);\n\n\t\t\tcontent = aggregateJavaScript(aggregateContext, fileNames);\n\t\t}\n\n\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\tFileUtil.write(cacheFile, content);\n\n\t\treturn content;\n\t}","id":3889,"modified_method":"protected Object getBundleContent(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tString minifierType = ParamUtil.getString(request, \"minifierType\");\n\t\tString bundleId = ParamUtil.getString(\n\t\t\trequest, \"bundleId\",\n\t\t\tParamUtil.getString(request, \"minifierBundleId\"));\n\n\t\tif (Validator.isNull(minifierType) ||\n\t\t\tValidator.isNull(bundleId) ||\n\t\t\t!ArrayUtil.contains(PropsValues.JAVASCRIPT_BUNDLE_IDS, bundleId)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString bundleDirName = PropsUtil.get(\n\t\t\tPropsKeys.JAVASCRIPT_BUNDLE_DIR, new Filter(bundleId));\n\n\t\tURL bundleDirURL = _servletContext.getResource(bundleDirName);\n\n\t\tif (bundleDirURL == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString cacheFileName = getCacheFileName(request);\n\n\t\tString[] fileNames = JavaScriptBundleUtil.getFileNames(bundleId);\n\n\t\tFile cacheFile = new File(_tempDir, cacheFileName);\n\n\t\tif (_limitedFilesCache != null) {\n\t\t\t_limitedFilesCache.put(cacheFileName);\n\t\t}\n\n\t\tif (cacheFile.exists()) {\n\t\t\tboolean staleCache = false;\n\n\t\t\tfor (String fileName : fileNames) {\n\t\t\t\tURL resourceURL = _servletContext.getResource(\n\t\t\t\t\tbundleDirName.concat(StringPool.SLASH).concat(fileName));\n\n\t\t\t\tif (resourceURL == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tURLConnection urlConnection = resourceURL.openConnection();\n\n\t\t\t\tif (urlConnection.getLastModified() >\n\t\t\t\t\t\tcacheFile.lastModified()) {\n\n\t\t\t\t\tstaleCache = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!staleCache) {\n\t\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\t\treturn cacheFile;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Aggregating JavaScript bundle \" + bundleId);\n\t\t}\n\n\t\tString content = null;\n\n\t\tif (fileNames.length == 0) {\n\t\t\tcontent = StringPool.BLANK;\n\t\t}\n\t\telse {\n\t\t\tAggregateContext aggregateContext = new ServletAggregateContext(\n\t\t\t\t_servletContext, StringPool.SLASH);\n\n\t\t\taggregateContext.pushPath(bundleDirName);\n\n\t\t\tcontent = aggregateJavaScript(aggregateContext, fileNames);\n\t\t}\n\n\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\tFileUtil.write(cacheFile, content);\n\n\t\treturn content;\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @see DynamicCSSUtil#propagateQueryString(String, String)\n\t */\n\tpublic static String aggregateCss(\n\t\t\tAggregateContext aggregateContext, String content)\n\t\tthrows IOException {\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tint pos = 0;\n\n\t\twhile (true) {\n\t\t\tint commentX = content.indexOf(_CSS_COMMENT_BEGIN, pos);\n\t\t\tint commentY = content.indexOf(\n\t\t\t\t_CSS_COMMENT_END, commentX + _CSS_COMMENT_BEGIN.length());\n\n\t\t\tint importX = content.indexOf(_CSS_IMPORT_BEGIN, pos);\n\t\t\tint importY = content.indexOf(\n\t\t\t\t_CSS_IMPORT_END, importX + _CSS_IMPORT_BEGIN.length());\n\n\t\t\tif ((importX == -1) || (importY == -1)) {\n\t\t\t\tsb.append(content.substring(pos));\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((commentX != -1) && (commentY != -1) &&\n\t\t\t\t\t (commentX < importX) && (commentY > importX)) {\n\n\t\t\t\tcommentY += _CSS_COMMENT_END.length();\n\n\t\t\t\tsb.append(content.substring(pos, commentY));\n\n\t\t\t\tpos = commentY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(content.substring(pos, importX));\n\n\t\t\t\tString mediaQuery = StringPool.BLANK;\n\n\t\t\t\tint mediaQueryImportX = content.indexOf(\n\t\t\t\t\tCharPool.CLOSE_PARENTHESIS,\n\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length());\n\t\t\t\tint mediaQueryImportY = content.indexOf(\n\t\t\t\t\tCharPool.SEMICOLON, importX + _CSS_IMPORT_BEGIN.length());\n\n\t\t\t\tString importFileName = null;\n\n\t\t\t\tif (importY != mediaQueryImportX) {\n\t\t\t\t\tmediaQuery = content.substring(\n\t\t\t\t\t\tmediaQueryImportX + 1, mediaQueryImportY);\n\n\t\t\t\t\timportFileName = content.substring(\n\t\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length(),\n\t\t\t\t\t\tmediaQueryImportX);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportFileName = content.substring(\n\t\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length(), importY);\n\t\t\t\t}\n\n\t\t\t\tString importContent = aggregateContext.getContent(\n\t\t\t\t\timportFileName);\n\n\t\t\t\tif (importContent == null) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"File \" +\n\t\t\t\t\t\t\t\taggregateContext.getFullPath(importFileName) +\n\t\t\t\t\t\t\t\t\t\" does not exist\");\n\t\t\t\t\t}\n\n\t\t\t\t\timportContent = StringPool.BLANK;\n\t\t\t\t}\n\n\t\t\t\tString importDir = StringPool.BLANK;\n\n\t\t\t\tint slashPos = importFileName.lastIndexOf(CharPool.SLASH);\n\n\t\t\t\tif (slashPos != -1) {\n\t\t\t\t\timportDir = importFileName.substring(0, slashPos + 1);\n\t\t\t\t}\n\n\t\t\t\taggregateContext.pushPath(importDir);\n\n\t\t\t\timportContent = aggregateCss(aggregateContext, importContent);\n\n\t\t\t\tif (Validator.isNotNull(importDir)) {\n\t\t\t\t\taggregateContext.popPath();\n\t\t\t\t}\n\n\t\t\t\t// LEP-7540\n\n\t\t\t\tStringBundler baseURL = new StringBundler(3);\n\n\t\t\t\tbaseURL.append(\"@portal_ctx@\");\n\t\t\t\tbaseURL.append(\n\t\t\t\t\taggregateContext.getResourcePath(StringPool.BLANK));\n\t\t\t\tbaseURL.append(importDir);\n\n\t\t\t\timportContent = updateCssRelativeUrls(\n\t\t\t\t\timportContent, baseURL.toString());\n\n\t\t\t\tif (Validator.isNotNull(mediaQuery)) {\n\t\t\t\t\tsb.append(_CSS_MEDIA_QUERY);\n\t\t\t\t\tsb.append(CharPool.SPACE);\n\t\t\t\t\tsb.append(mediaQuery);\n\t\t\t\t\tsb.append(CharPool.OPEN_CURLY_BRACE);\n\t\t\t\t\tsb.append(importContent);\n\t\t\t\t\tsb.append(CharPool.CLOSE_CURLY_BRACE);\n\n\t\t\t\t\tpos = mediaQueryImportY + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsb.append(importContent);\n\n\t\t\t\t\tpos = importY + _CSS_IMPORT_END.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":3890,"modified_method":"/**\n\t * @see DynamicCSSUtil#propagateQueryString(String, String)\n\t */\n\tpublic static String aggregateCss(\n\t\t\tAggregateContext aggregateContext, String content)\n\t\tthrows IOException {\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tint pos = 0;\n\n\t\twhile (true) {\n\t\t\tint commentX = content.indexOf(_CSS_COMMENT_BEGIN, pos);\n\t\t\tint commentY = content.indexOf(\n\t\t\t\t_CSS_COMMENT_END, commentX + _CSS_COMMENT_BEGIN.length());\n\n\t\t\tint importX = content.indexOf(_CSS_IMPORT_BEGIN, pos);\n\t\t\tint importY = content.indexOf(\n\t\t\t\t_CSS_IMPORT_END, importX + _CSS_IMPORT_BEGIN.length());\n\n\t\t\tif ((importX == -1) || (importY == -1)) {\n\t\t\t\tsb.append(content.substring(pos));\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((commentX != -1) && (commentY != -1) &&\n\t\t\t\t\t (commentX < importX) && (commentY > importX)) {\n\n\t\t\t\tcommentY += _CSS_COMMENT_END.length();\n\n\t\t\t\tsb.append(content.substring(pos, commentY));\n\n\t\t\t\tpos = commentY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(content.substring(pos, importX));\n\n\t\t\t\tString mediaQuery = StringPool.BLANK;\n\n\t\t\t\tint mediaQueryImportX = content.indexOf(\n\t\t\t\t\tCharPool.CLOSE_PARENTHESIS,\n\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length());\n\t\t\t\tint mediaQueryImportY = content.indexOf(\n\t\t\t\t\tCharPool.SEMICOLON, importX + _CSS_IMPORT_BEGIN.length());\n\n\t\t\t\tString importFileName = null;\n\n\t\t\t\tif (importY != mediaQueryImportX) {\n\t\t\t\t\tmediaQuery = content.substring(\n\t\t\t\t\t\tmediaQueryImportX + 1, mediaQueryImportY);\n\n\t\t\t\t\timportFileName = content.substring(\n\t\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length(),\n\t\t\t\t\t\tmediaQueryImportX);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportFileName = content.substring(\n\t\t\t\t\t\timportX + _CSS_IMPORT_BEGIN.length(), importY);\n\t\t\t\t}\n\n\t\t\t\tString importContent = aggregateContext.getContent(\n\t\t\t\t\timportFileName);\n\n\t\t\t\tif (importContent == null) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"File \" +\n\t\t\t\t\t\t\t\taggregateContext.getFullPath(importFileName) +\n\t\t\t\t\t\t\t\t\t\" does not exist\");\n\t\t\t\t\t}\n\n\t\t\t\t\timportContent = StringPool.BLANK;\n\t\t\t\t}\n\n\t\t\t\tString importDirName = StringPool.BLANK;\n\n\t\t\t\tint slashPos = importFileName.lastIndexOf(CharPool.SLASH);\n\n\t\t\t\tif (slashPos != -1) {\n\t\t\t\t\timportDirName = importFileName.substring(0, slashPos + 1);\n\t\t\t\t}\n\n\t\t\t\taggregateContext.pushPath(importDirName);\n\n\t\t\t\timportContent = aggregateCss(aggregateContext, importContent);\n\n\t\t\t\tif (Validator.isNotNull(importDirName)) {\n\t\t\t\t\taggregateContext.popPath();\n\t\t\t\t}\n\n\t\t\t\t// LEP-7540\n\n\t\t\t\tString baseURL = _BASE_URL;\n\n\t\t\t\tbaseURL = baseURL.concat(\n\t\t\t\t\taggregateContext.getResourcePath(StringPool.BLANK));\n\t\t\t\tbaseURL = baseURL.concat(importDirName);\n\n\t\t\t\timportContent = updateCssRelativeUrls(importContent, baseURL);\n\n\t\t\t\tif (Validator.isNotNull(mediaQuery)) {\n\t\t\t\t\tsb.append(_CSS_MEDIA_QUERY);\n\t\t\t\t\tsb.append(CharPool.SPACE);\n\t\t\t\t\tsb.append(mediaQuery);\n\t\t\t\t\tsb.append(CharPool.OPEN_CURLY_BRACE);\n\t\t\t\t\tsb.append(importContent);\n\t\t\t\t\tsb.append(CharPool.CLOSE_CURLY_BRACE);\n\n\t\t\t\t\tpos = mediaQueryImportY + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsb.append(importContent);\n\n\t\t\t\t\tpos = importY + _CSS_IMPORT_END.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void main(String[] args) {\n\t\tMap<String, String> arguments = ArgumentsUtil.parseArguments(args);\n\n\t\tList<String> dirNames = new ArrayList<String>();\n\n\t\tString docroot = arguments.get(\"docroot\");\n\t\tString dirName = arguments.get(\"sass.dir\");\n\n\t\tif (Validator.isNotNull(dirName)) {\n\t\t\tdirNames.add(dirName);\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0;; i++ ) {\n\t\t\t\tdirName = arguments.get(\"sass.dir.\" + i);\n\n\t\t\t\tif (Validator.isNotNull(dirName)) {\n\t\t\t\t\tdirNames.add(dirName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tnew SassToCssBuilder(docroot, dirNames);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":3891,"modified_method":"public static void main(String[] args) {\n\t\tMap<String, String> arguments = ArgumentsUtil.parseArguments(args);\n\n\t\tString docrootDirName = arguments.get(\"saas.docroot.dir\");\n\n\t\tList<String> dirNames = new ArrayList<String>();\n\n\t\tString dirName = arguments.get(\"sass.dir\");\n\n\t\tif (Validator.isNotNull(dirName)) {\n\t\t\tdirNames.add(dirName);\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0;; i++ ) {\n\t\t\t\tdirName = arguments.get(\"sass.dir.\" + i);\n\n\t\t\t\tif (Validator.isNotNull(dirName)) {\n\t\t\t\t\tdirNames.add(dirName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tnew SassToCssBuilder(docrootDirName, dirNames);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _parseSassFile(String docroot, String resourcePath)\n\t\tthrows Exception {\n\n\t\tString filePath = docroot.concat(resourcePath);\n\n\t\tFile file = new File(filePath);\n\t\tFile cacheFile = getCacheFile(filePath);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"content\", _getContent(docroot, resourcePath));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\t_rubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\tString parsedContent = unsyncByteArrayOutputStream.toString();\n\n\t\tFileUtil.write(cacheFile, parsedContent);\n\n\t\tcacheFile.setLastModified(file.lastModified());\n\t}","id":3892,"modified_method":"private void _parseSassFile(String docrootDirName, String resourcePath)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(resourcePath);\n\n\t\tFile file = new File(filePath);\n\t\tFile cacheFile = getCacheFile(filePath);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"content\", _getContent(docrootDirName, resourcePath));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\t_rubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\tString parsedContent = unsyncByteArrayOutputStream.toString();\n\n\t\tFileUtil.write(cacheFile, parsedContent);\n\n\t\tcacheFile.setLastModified(file.lastModified());\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _parseSassDirectory(String docroot, String dirName)\n\t\tthrows Exception {\n\n\t\tDirectoryScanner directoryScanner = new DirectoryScanner();\n\n\t\tString dir = docroot.concat(dirName);\n\n\t\tdirectoryScanner.setBasedir(dir);\n\t\tdirectoryScanner.setExcludes(\n\t\t\tnew String[] {\n\t\t\t\t\"**\\\\_diffs\\\\**\", \"**\\\\.sass-cache*\\\\**\",\n\t\t\t\t\"**\\\\.sass_cache_*\\\\**\", \"**\\\\_sass_cache_*\\\\**\",\n\t\t\t\t\"**\\\\_styled\\\\**\", \"**\\\\_unstyled\\\\**\"\n\t\t\t});\n\t\tdirectoryScanner.setIncludes(new String[] {\"**\\\\*.css\"});\n\n\t\tdirectoryScanner.scan();\n\n\t\tString[] fileNames = directoryScanner.getIncludedFiles();\n\n\t\tif (!_isModified(dir, fileNames)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(dirName, fileName);\n\n\t\t\ttry {\n\t\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\t\t_parseSassFile(docroot, fileName);\n\n\t\t\t\tlong end = System.currentTimeMillis();\n\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"Parsed \" + fileName + \" in \" + (end - start) + \" ms\");\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tSystem.out.println(\"Unable to parse \" + fileName);\n\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":3893,"modified_method":"private void _parseSassDirectory(String docrootDirName, String dirName)\n\t\tthrows Exception {\n\n\t\tDirectoryScanner directoryScanner = new DirectoryScanner();\n\n\t\tString basedir = docrootDirName.concat(dirName);\n\n\t\tdirectoryScanner.setBasedir(basedir);\n\n\t\tdirectoryScanner.setExcludes(\n\t\t\tnew String[] {\n\t\t\t\t\"**\\\\_diffs\\\\**\", \"**\\\\.sass-cache*\\\\**\",\n\t\t\t\t\"**\\\\.sass_cache_*\\\\**\", \"**\\\\_sass_cache_*\\\\**\",\n\t\t\t\t\"**\\\\_styled\\\\**\", \"**\\\\_unstyled\\\\**\"\n\t\t\t});\n\t\tdirectoryScanner.setIncludes(new String[] {\"**\\\\*.css\"});\n\n\t\tdirectoryScanner.scan();\n\n\t\tString[] fileNames = directoryScanner.getIncludedFiles();\n\n\t\tif (!_isModified(basedir, fileNames)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(dirName, fileName);\n\n\t\t\ttry {\n\t\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\t\t_parseSassFile(docrootDirName, fileName);\n\n\t\t\t\tlong end = System.currentTimeMillis();\n\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"Parsed \" + fileName + \" in \" + (end - start) + \" ms\");\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tSystem.out.println(\"Unable to parse \" + fileName);\n\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean _isModified(String dir, String[] fileNames)\n\t\tthrows Exception {\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(dir, fileName);\n\n\t\t\tFile file = new File(fileName);\n\t\t\tFile cacheFile = getCacheFile(fileName);\n\n\t\t\tif (file.lastModified() != cacheFile.lastModified()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":3894,"modified_method":"private boolean _isModified(String dirName, String[] fileNames)\n\t\tthrows Exception {\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(dirName, fileName);\n\n\t\t\tFile file = new File(fileName);\n\t\t\tFile cacheFile = getCacheFile(fileName);\n\n\t\t\tif (file.lastModified() != cacheFile.lastModified()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SassToCssBuilder(String docroot, List<String> dirNames)\n\t\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tfor (String dirName : dirNames) {\n\n\t\t\t// Create a new Ruby executor as a workaround for a bug with Ruby\n\t\t\t// that breaks \"ant build-css\" when it parses too many CSS files\n\n\t\t\t_rubyExecutor = new RubyExecutor();\n\n\t\t\t_rubyExecutor.setExecuteInSeparateThread(false);\n\n\t\t\t_parseSassDirectory(docroot, dirName);\n\t\t}\n\t}","id":3895,"modified_method":"public SassToCssBuilder(String docrootDirName, List<String> dirNames)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tfor (String dirName : dirNames) {\n\n\t\t\t// Create a new Ruby executor as a workaround for a bug with Ruby\n\t\t\t// that breaks \"ant build-css\" when it parses too many CSS files\n\n\t\t\t_rubyExecutor = new RubyExecutor();\n\n\t\t\t_rubyExecutor.setExecuteInSeparateThread(false);\n\n\t\t\t_parseSassDirectory(docrootDirName, dirName);\n\t\t}\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _getContent(String docroot, String resourcePath)\n\t\tthrows Exception {\n\n\t\tString filePath = docroot.concat(resourcePath);\n\n\t\tFile file = new File(filePath);\n\n\t\tString content = FileUtil.read(file);\n\n\t\tcontent = AggregateFilter.aggregateCss(\n\t\t\tnew FileAggregateContext(docroot, resourcePath), content);\n\n\t\treturn parseStaticTokens(content);\n\t}","id":3896,"modified_method":"private String _getContent(String docrootDirName, String resourcePath)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(resourcePath);\n\n\t\tFile file = new File(filePath);\n\n\t\tString content = FileUtil.read(file);\n\n\t\tcontent = AggregateFilter.aggregateCss(\n\t\t\tnew FileAggregateContext(docrootDirName, resourcePath), content);\n\n\t\treturn parseStaticTokens(content);\n\t}","commit_id":"e6d5fc726ea972095d9ba1cf12f856553b37b49f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getGlobalScript() throws IOException {\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (int i = 0; i < globalFiles.length; i++) {\n\t\t\tInputStream is = getPortletContext().getResourceAsStream(\n\t\t\t\tglobalFiles[i]);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Global file \" + globalFiles[i] + \" does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tsb.append(new String(FileUtil.getBytes(is)));\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":3897,"modified_method":"protected String getGlobalScript() throws IOException {\n\t\tif (globalFiles.length == 0) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t\t\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (int i = 0; i < globalFiles.length; i++) {\n\t\t\tInputStream is = getPortletContext().getResourceAsStream(\n\t\t\t\tglobalFiles[i]);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Global file \" + globalFiles[i] + \" does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tsb.append(new String(FileUtil.getBytes(is)));\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"68096ef771778d0bf80f62b14ed7072c48440739","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getGlobalScript() throws IOException {\n\t\tif (globalScript != null) {\n\t\t\treturn globalScript;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (String globalFile : globalFiles) {\n\t\t\tInputStream is = getPortletContext().getResourceAsStream(\n\t\t\t\tglobalFile);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Global file \" + globalFile + \" does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tString script = new String(FileUtil.getBytes(is));\n\n\t\t\t\t\tsb.append(script);\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\n\t\tglobalScript = sb.toString();\n\n\t\treturn globalScript;\n\t}","id":3898,"modified_method":"protected String getGlobalScript() throws IOException {\n\t\tif (globalScript != null) {\n\t\t\treturn globalScript;\n\t\t}\n\t\t\n\t\tif (globalFiles.length == 0) {\n\t\t\tglobalScript = StringPool.BLANK;\n\n\t\t\treturn globalScript;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (String globalFile : globalFiles) {\n\t\t\tInputStream is = getPortletContext().getResourceAsStream(\n\t\t\t\tglobalFile);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Global file \" + globalFile + \" does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tString script = new String(FileUtil.getBytes(is));\n\n\t\t\t\t\tsb.append(script);\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\n\t\tglobalScript = sb.toString();\n\n\t\treturn globalScript;\n\t}","commit_id":"68096ef771778d0bf80f62b14ed7072c48440739","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String format(String phoneNumber) {\n\t\tif (phoneNumber == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (phoneNumber.length() > 10) {\n\t\t\tStringBundler sb = new StringBundler(8);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(phoneNumber.substring(0, 3));\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(phoneNumber.substring(3, 6));\n\t\t\tsb.append(StringPool.DASH);\n\t\t\tsb.append(phoneNumber.substring(6, 10));\n\t\t\tsb.append(\" x\");\n\t\t\tsb.append(phoneNumber.substring(10));\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse if (phoneNumber.length() == 10) {\n\t\t\tStringBundler sb = new StringBundler(6);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(phoneNumber.substring(0, 3));\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(phoneNumber.substring(3, 6));\n\t\t\tsb.append(StringPool.DASH);\n\t\t\tsb.append(phoneNumber.substring(6));\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse if (phoneNumber.length() == 7) {\n\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\tsb.append(phoneNumber.substring(0, 3));\n\t\t\tsb.append(StringPool.DASH);\n\t\t\tsb.append(phoneNumber.substring(3));\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse {\n\t\t\treturn phoneNumber;\n\t\t}\n\t}","id":3899,"modified_method":"public String format(String phoneNumber) {\n\t\tif (phoneNumber == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (phoneNumber.length() > 10) {\n\t\t\tStringBundler sb = new StringBundler(8);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(phoneNumber.substring(0, 3));\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(phoneNumber.substring(3, 6));\n\t\t\tsb.append(StringPool.DASH);\n\t\t\tsb.append(phoneNumber.substring(6, 10));\n\t\t\tsb.append(\" x\");\n\t\t\tsb.append(phoneNumber.substring(10));\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse if (phoneNumber.length() == 10) {\n\t\t\tStringBundler sb = new StringBundler(6);\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(phoneNumber.substring(0, 3));\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(phoneNumber.substring(3, 6));\n\t\t\tsb.append(StringPool.DASH);\n\t\t\tsb.append(phoneNumber.substring(6));\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse if (phoneNumber.length() == 7) {\n\t\t\treturn \n\t\t\t\tphoneNumber.substring(0, 3).concat(\n\t\t\t\tStringPool.DASH).concat(phoneNumber.substring(3));\n\t\t}\n\t\telse {\n\t\t\treturn phoneNumber;\n\t\t}\n\t}","commit_id":"68096ef771778d0bf80f62b14ed7072c48440739","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getRequestURI() {\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(getContextPath());\n\t\tsb.append(_pathInfo);\n\n\t\tif (getQueryString().trim().length() > 0) {\n\t\t\tsb.append(StringPool.QUESTION);\n\t\t\tsb.append(getQueryString());\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":3900,"modified_method":"public String getRequestURI() {\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(getContextPath());\n\t\tsb.append(_pathInfo);\n\n\t\tif (getQueryString().trim().length() > 0) {\n\t\t\tsb.append(StringPool.QUESTION);\n\t\t\tsb.append(getQueryString());\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"68096ef771778d0bf80f62b14ed7072c48440739","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void invokeApplication(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)renderRequest.getAttribute(\n\t\t\t\tPortletServlet.PORTLET_SERVLET_REQUEST);\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)renderRequest.getAttribute(\n\t\t\t\tPortletServlet.PORTLET_SERVLET_RESPONSE);\n\n\t\tString portletName = getPortletConfig().getPortletName();\n\n\t\tString friendlyURL = (String)request.getAttribute(\"FRIENDLY_URL\");\n\n\t\tint pos = friendlyURL.indexOf(_MAPPING);\n\n\t\tStringBundler contextPath = new StringBundler(3);\n\n\t\tcontextPath.append(friendlyURL.substring(0, pos + _MAPPING.length()));\n\t\tcontextPath.append(StringPool.SLASH);\n\t\tcontextPath.append(portletName);\n\n\t\tpos = friendlyURL.indexOf(portletName);\n\n\t\tString pathInfo = friendlyURL.substring(pos + portletName.length());\n\n\t\tMap<String, String[]> params = new HashMap<String, String[]>(\n\t\t\trequest.getParameterMap());\n\n\t\tparams.remove(_APP_URL);\n\n\t\tString queryString = HttpUtil.parameterMapToString(params, false);\n\n\t\tString appUrl = ParamUtil.getString(\n\t\t\trenderRequest, _APP_URL, StringPool.SLASH);\n\n\t\tif (_connector.equals(CONNECTOR_IFRAME)) {\n\t\t\trequest.setAttribute(\n\t\t\t\t_APP_URL, renderRequest.getContextPath() + appUrl);\n\n\t\t\tString iframeExtraHeight = GetterUtil.getString(\n\t\t\t\tgetPortletConfig().getInitParameter(\n\t\t\t\t\t\"wai.connector.iframe.height.extra\"),\n\t\t\t\t\"40\");\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\t\"wai.connector.iframe.height.extra\", iframeExtraHeight);\n\n\t\t\tforward(request, response, _JSP_IFRAME);\n\t\t}\n\t\telse if (_connector.equals(CONNECTOR_INCLUDE)) {\n\t\t\tHttpServletRequest waiRequest = new WAIHttpServletRequest(\n\t\t\t\trequest, contextPath.toString(), pathInfo, queryString, params);\n\n\t\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\n\t\t\t\tappUrl);\n\n\t\t\ttry {\n\t\t\t\trequestDispatcher.forward(waiRequest, response);\n\t\t\t}\n\t\t\tcatch (ServletException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\t}","id":3901,"modified_method":"protected void invokeApplication(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)renderRequest.getAttribute(\n\t\t\t\tPortletServlet.PORTLET_SERVLET_REQUEST);\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)renderRequest.getAttribute(\n\t\t\t\tPortletServlet.PORTLET_SERVLET_RESPONSE);\n\n\t\tString portletName = getPortletConfig().getPortletName();\n\n\t\tString friendlyURL = (String)request.getAttribute(\"FRIENDLY_URL\");\n\n\t\tint pos = friendlyURL.indexOf(_MAPPING);\n\n\t\tString contextPath =\n\t\t\tfriendlyURL.substring(0, pos + _MAPPING.length()).concat(\n\t\t\tStringPool.SLASH).concat(portletName);\n\n\t\tpos = friendlyURL.indexOf(portletName);\n\n\t\tString pathInfo = friendlyURL.substring(pos + portletName.length());\n\n\t\tMap<String, String[]> params = new HashMap<String, String[]>(\n\t\t\trequest.getParameterMap());\n\n\t\tparams.remove(_APP_URL);\n\n\t\tString queryString = HttpUtil.parameterMapToString(params, false);\n\n\t\tString appUrl = ParamUtil.getString(\n\t\t\trenderRequest, _APP_URL, StringPool.SLASH);\n\n\t\tif (_connector.equals(CONNECTOR_IFRAME)) {\n\t\t\trequest.setAttribute(\n\t\t\t\t_APP_URL, renderRequest.getContextPath() + appUrl);\n\n\t\t\tString iframeExtraHeight = GetterUtil.getString(\n\t\t\t\tgetPortletConfig().getInitParameter(\n\t\t\t\t\t\"wai.connector.iframe.height.extra\"),\n\t\t\t\t\"40\");\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\t\"wai.connector.iframe.height.extra\", iframeExtraHeight);\n\n\t\t\tforward(request, response, _JSP_IFRAME);\n\t\t}\n\t\telse if (_connector.equals(CONNECTOR_INCLUDE)) {\n\t\t\tHttpServletRequest waiRequest = new WAIHttpServletRequest(\n\t\t\t\trequest, contextPath, pathInfo, queryString, params);\n\n\t\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\n\t\t\t\tappUrl);\n\n\t\t\ttry {\n\t\t\t\trequestDispatcher.forward(waiRequest, response);\n\t\t\t}\n\t\t\tcatch (ServletException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\t}","commit_id":"68096ef771778d0bf80f62b14ed7072c48440739","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getDisplayURL(\n\t\t\tString portalURL, String mainPath, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isDefaultUser()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString profileFriendlyURL = getProfileFriendlyURL();\n\n\t\tif (Validator.isNotNull(profileFriendlyURL)) {\n\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\tsb.append(portalURL);\n\t\t\tsb.append(PortalUtil.getPathContext());\n\t\t\tsb.append(profileFriendlyURL);\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tGroup group = getGroup();\n\n\t\tint publicLayoutsPageCount = group.getPublicLayoutsPageCount();\n\n\t\tif (publicLayoutsPageCount > 0) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(portalURL);\n\t\t\tsb.append(mainPath);\n\t\t\tsb.append(\"/my_sites/view?groupId=\");\n\t\t\tsb.append(group.getGroupId());\n\n\t\t\tif (privateLayout) {\n\t\t\t\tsb.append(\"&privateLayout=1\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"&privateLayout=0\");\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","id":3902,"modified_method":"public String getDisplayURL(\n\t\t\tString portalURL, String mainPath, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isDefaultUser()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString profileFriendlyURL = getProfileFriendlyURL();\n\n\t\tif (Validator.isNotNull(profileFriendlyURL)) {\n\t\t\treturn portalURL.concat(PortalUtil.getPathContext()).concat(\n\t\t\t\tprofileFriendlyURL);\n\t\t}\n\n\t\tGroup group = getGroup();\n\n\t\tint publicLayoutsPageCount = group.getPublicLayoutsPageCount();\n\n\t\tif (publicLayoutsPageCount > 0) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(portalURL);\n\t\t\tsb.append(mainPath);\n\t\t\tsb.append(\"/my_sites/view?groupId=\");\n\t\t\tsb.append(group.getGroupId());\n\n\t\t\tif (privateLayout) {\n\t\t\t\tsb.append(\"&privateLayout=1\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"&privateLayout=0\");\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"be8ada74ceb969872f71b70cf0bc0e425bd35179","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String encodeFieldName(String name) {\n\t\tStringBundler sb = new StringBundler(3);\n\n\t\tsb.append(_FIELD_NAMESPACE);\n\t\tsb.append(StringPool.FORWARD_SLASH);\n\t\tsb.append(name);\n\n\t\treturn sb.toString();\n\t}","id":3903,"modified_method":"protected String encodeFieldName(String name) {\n\t\treturn _FIELD_NAMESPACE.concat(StringPool.FORWARD_SLASH).concat(name);\n\t}","commit_id":"d42346134e6baceebb073c9b409a7ac0501baf03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  public static String stem(String str) {\n    // check for zero length\n    if (str.length() > 0) {\n      // all characters must be letters\n      char[] c = str.toCharArray();\n      StringBuffer result = new StringBuffer();\n      StringBuffer buf = new StringBuffer(str.length());\n      for (char character : c) {\n        if (!Character.isLetter(character) && !Character.isDigit(character)) return null;\n        if (Character.isLetter(character)){\n          buf.append(character);\n        } else {\n          result.append(buf.toString());\n          result.append(character);\n          buf = new StringBuffer(str.length());\n        }\n      }\n      if (buf.length() > 0){\n        result.append(stemString(buf.toString()));\n      }\n      return result.toString();\n    }\n    else {\n      return null;\n    }\n  }","id":3904,"modified_method":"@Nullable\n  public static String stem(String str) {\n    // check for zero length\n    final int strLen = str.length();\n    if (strLen > 0) {\n      final StringBuilder result = StringBuilderSpinAllocator.alloc();\n      try {\n        int lastDigit = -1;\n        for (int i = 0; i < strLen; ++i) {\n          char c = str.charAt(i);\n          result.append(c);\n          if(Character.isDigit(c)) {\n            lastDigit = i;\n          }\n          else if(!Character.isLetter(c)){\n            return null;\n          }\n        }\n        ++lastDigit;\n        if( lastDigit > 0 && lastDigit < strLen) {\n          return result.replace(lastDigit, strLen, stemString(result.substring(lastDigit))).toString();\n        }\n        return stemString(str);                \n      }\n      finally {\n        StringBuilderSpinAllocator.dispose(result);\n      }\n    }\n    return null;\n  }","commit_id":"1eecf9a56b240e98bd90bdd379498d1c9f59dff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void readPostcodes(List<PostCode> postcodes, ResultMatcher<MapObject> resultMatcher, StringMatcher nameMatcher) throws IOException{\n\t\twhile(true){\n\t\t\tint t = codedIS.readTag();\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\n\t\t\tswitch (tag) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase OsmandOdb.PostcodesIndex.POSTCODES_FIELD_NUMBER :\n\t\t\t\tint offset = codedIS.getTotalBytesRead();\n\t\t\t\tint length = codedIS.readRawVarint32();\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\n\t\t\t\tfinal PostCode postCode = readPostcode(null, offset, null, false, null);\n\t\t\t\t// support getEnName??\n\t\t\t\tif (nameMatcher == null || nameMatcher.matches(postCode.getName())) {\n\t\t\t\t\tif (resultMatcher == null || resultMatcher.publish(postCode)) {\n\t\t\t\t\t\tpostcodes.add(postCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcodedIS.popLimit(oldLimit);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tskipUnknownField(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","id":3905,"modified_method":"protected void readPostcodes(List<PostCode> postcodes, ResultMatcher<MapObject> resultMatcher, StringMatcher nameMatcher) throws IOException{\n\t\twhile(true){\n\t\t\tint t = codedIS.readTag();\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\n\t\t\tswitch (tag) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase OsmandOdb.PostcodesIndex.POSTCODES_FIELD_NUMBER :\n\t\t\t\tint offset = codedIS.getTotalBytesRead();\n\t\t\t\tint length = codedIS.readRawVarint32();\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\n\t\t\t\tfinal PostCode postCode = readPostcode(null, offset, null, false, null);\n\t\t\t\t// support getEnName??\n\t\t\t\tif (nameMatcher == null || nameMatcher.matches(postCode.getName())) {\n\t\t\t\t\tif (resultMatcher == null || resultMatcher.publish(postCode)) {\n\t\t\t\t\t\tpostcodes.add(postCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcodedIS.popLimit(oldLimit);\n\t\t\t\tif(resultMatcher != null && resultMatcher.isCancelled()){\n\t\t\t\t\tcodedIS.skipRawBytes(codedIS.getBytesUntilLimit());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tskipUnknownField(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void readCities(List<City> cities, ResultMatcher<MapObject> resultMatcher, StringMatcher matcher, boolean useEn) throws IOException {\n\t\twhile(true){\n\t\t\tint t = codedIS.readTag();\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\n\t\t\tswitch (tag) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase OsmandOdb.CitiesIndex.CITIES_FIELD_NUMBER :\n\t\t\t\tint offset = codedIS.getTotalBytesRead();\n\t\t\t\tint length = codedIS.readRawVarint32();\n\t\t\t\t\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\n\t\t\t\tCity c = readCity(null, offset, false, null, matcher, useEn);\n\t\t\t\tif(c != null){\n\t\t\t\t\tif (resultMatcher == null || resultMatcher.publish(c)) {\n\t\t\t\t\t\tcities.add(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcodedIS.popLimit(oldLimit);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tskipUnknownField(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","id":3906,"modified_method":"protected void readCities(List<City> cities, ResultMatcher<MapObject> resultMatcher, StringMatcher matcher, boolean useEn) throws IOException {\n\t\twhile(true){\n\t\t\tint t = codedIS.readTag();\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\n\t\t\tswitch (tag) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase OsmandOdb.CitiesIndex.CITIES_FIELD_NUMBER :\n\t\t\t\tint offset = codedIS.getTotalBytesRead();\n\t\t\t\tint length = codedIS.readRawVarint32();\n\t\t\t\t\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\n\t\t\t\tCity c = readCity(null, offset, false, null, matcher, useEn);\n\t\t\t\tif(c != null){\n\t\t\t\t\tif (resultMatcher == null || resultMatcher.publish(c)) {\n\t\t\t\t\t\tcities.add(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcodedIS.popLimit(oldLimit);\n\t\t\t\tif(resultMatcher != null && resultMatcher.isCancelled()){\n\t\t\t\t\tcodedIS.skipRawBytes(codedIS.getBytesUntilLimit());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tskipUnknownField(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Checks if string starts with another string\n\t * \n\t * @param collator\n\t * @param searchIn\n\t * @param theStart\n\t * @return true if searchIn starts with token\n\t */\n\tpublic static boolean cstartsWith(Collator collator, String searchIn, String theStart) {\n\t\t// simulate starts with for collator\n\t\treturn collator.equals(\n\t\t\t\tsearchIn.substring(0,\n\t\t\t\t\t\tMath.min(searchIn.length(), theStart.length())), theStart);\n\t}","id":3907,"modified_method":"/**\n\t * Checks if string starts with another string.\n\t * Special check try to find as well in the middle of name\n\t * \n\t * @param collator\n\t * @param searchIn\n\t * @param theStart\n\t * @return true if searchIn starts with token\n\t */\n\tpublic static boolean cstartsWith(Collator collator, String searchIn, String theStart, \n\t\t\tboolean checkBeginning, boolean checkSpaces) {\n\t\tint startLength = theStart.length();\n\t\tint searchInLength = searchIn.length();\n\t\tif (startLength == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (startLength > searchInLength) {\n\t\t\treturn false;\n\t\t}\n\t\t// simulate starts with for collator\n\t\tif (checkBeginning) {\n\t\t\tboolean starts = collator.equals(searchIn.substring(0, startLength), theStart);\n\t\t\tif (starts) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (checkSpaces) {\n\t\t\tfor (int i = 1; i <= searchInLength - startLength; i++) {\n\t\t\t\tif (Character.isSpace(searchIn.charAt(i - 1)) && !Character.isSpace(searchIn.charAt(i))) {\n\t\t\t\t\tif (collator.equals(searchIn.substring(i, i + startLength), theStart)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Check if part contains in base\n\t *\n\t * @param collator Collator to use\n\t * @param part String to search\n\t * @param base String where to search\n\t * @return true if part is contained in base\n\t */\n\tpublic static boolean ccontains(Collator collator, String part, String base) {\n\t\tint pos = 0;\n\t\tif (part.length() > 3) {\n\t\t\t// improve searching by searching first 3 characters\n\t\t\tpos = cindexOf(collator, pos, part.substring(0, 3), base);\n\t\t\tif (pos == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tpos = cindexOf(collator, pos, part, base);\n\t\tif (pos == -1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":3908,"modified_method":"/**\n\t * Check if part contains in base\n\t *\n\t * @param collator Collator to use\n\t * @param part String to search\n\t * @param base String where to search\n\t * @return true if part is contained in base\n\t */\n\tpublic static boolean ccontains(Collator collator, String base, String part) {\n\t\tint pos = 0;\n\t\tif (part.length() > 3) {\n\t\t\t// improve searching by searching first 3 characters\n\t\t\tpos = cindexOf(collator, pos, part.substring(0, 3), base);\n\t\t\tif (pos == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tpos = cindexOf(collator, pos, part, base);\n\t\tif (pos == -1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public CollatorStringMatcher(Collator collator) {\n\t\tthis.collator = collator;\n\t}","id":3909,"modified_method":"public CollatorStringMatcher(Collator collator, String part, StringMatcherMode mode) {\n\t\tthis.collator = collator;\n\t\tthis.part = part;\n\t\tthis.mode = mode;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<Street> fillWithSuggestedStreets(MapObject o, ResultMatcher<Street> resultMatcher, String... names) {\n\t\tassert o instanceof PostCode || o instanceof City;\n\t\tCity city = (City) (o instanceof City ? o : null); \n\t\tPostCode post = (PostCode) (o instanceof PostCode ? o : null);\n\t\tList<Street> streetsToFill = new ArrayList<Street>();\t\n\t\tif(names.length == 0){\n\t\t\tpreloadStreets(o, resultMatcher);\n\t\t\tstreetsToFill.addAll(post == null ? city.getStreets() : post.getStreets());\n\t\t\treturn streetsToFill;\n\t\t}\n\t\tpreloadStreets(o, null);\n\t\tint ind = 0;\n\t\tCollection<Street> streets = post == null ? city.getStreets() : post.getStreets() ;\n\t\tIterator<Street> iterator = streets.iterator();\n\t\twhile(iterator.hasNext()) {\n\t\t\tStreet s = iterator.next();\n\t\t\tString sName = useEnglishNames ? s.getEnName() : s.getName(); // lower case not needed, collator ensures that\n\t\t\tfor (String name : names) {\n\t\t\t\tif (cstartsWith(collator, sName, name)) {\n\t\t\t\t\tstreetsToFill.add(ind, s);\n\t\t\t\t\tind++;\n\t\t\t\t} else if (ccontains(collator, name, sName) || ccontains(collator, sName, name)) {\n\t\t\t\t\tstreetsToFill.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn streetsToFill;\n\t}","id":3910,"modified_method":"@Override\n\tpublic List<Street> fillWithSuggestedStreets(MapObject o, ResultMatcher<Street> resultMatcher, String... names) {\n\t\tassert o instanceof PostCode || o instanceof City;\n\t\tCity city = (City) (o instanceof City ? o : null); \n\t\tPostCode post = (PostCode) (o instanceof PostCode ? o : null);\n\t\tList<Street> streetsToFill = new ArrayList<Street>();\t\n\t\tif(names.length == 0){\n\t\t\tpreloadStreets(o, resultMatcher);\n\t\t\tstreetsToFill.addAll(post == null ? city.getStreets() : post.getStreets());\n\t\t\treturn streetsToFill;\n\t\t}\n\t\tpreloadStreets(o, null);\n\t\t\n\t\tCollection<Street> streets = post == null ? city.getStreets() : post.getStreets();\n\t\t\n\t\t// 1st step loading by starts with\n\t\tfor (StringMatcherMode mode : streetsCheckMode) {\n\t\t\tfor (Street s : streets) {\n\t\t\t\tif (resultMatcher.isCancelled()) {\n\t\t\t\t\treturn streetsToFill;\n\t\t\t\t}\n\t\t\t\tString sName = s.getName(useEnglishNames); // lower case not needed, collator ensures that\n\t\t\t\tfor (String name : names) {\n\t\t\t\t\tboolean match = CollatorStringMatcher.cmatches(collator, sName, name, mode);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tresultMatcher.publish(s);\n\t\t\t\t\t\tstreetsToFill.add(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn streetsToFill;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<MapObject> fillWithSuggestedCities(String name, ResultMatcher<MapObject> resultMatcher, LatLon currentLocation) {\n\t\tList<MapObject> citiesToFill = new ArrayList<MapObject>();\n\t\tif (cities.isEmpty()) {\n\t\t\tpreloadCities(resultMatcher);\n\t\t\tcitiesToFill.addAll(cities.values());\n\t\t\treturn citiesToFill;\n\t\t} else {\n\t\t\tpreloadCities(null);\n\t\t}\n\t\ttry {\n\t\t\t// essentially index is created that cities towns are first in cities map\n\t\t\tint ind = 0;\n\t\t\tif (name.length() >= 2 && Algoritms.containsDigit(name)) {\n\t\t\t\t// also try to identify postcodes\n\t\t\t\tString uName = name.toUpperCase();\n\t\t\t\tfor (PostCode code : file.getPostcodes(region, resultMatcher, new ContainsStringMatcher(uName, collator))) {\n\t\t\t\t\tif (cstartsWith(collator, code.getName(), uName)) {\n\t\t\t\t\t\tcitiesToFill.add(ind++, code);\n\t\t\t\t\t} else if (ccontains(collator, code.getName(), uName)) {\n\t\t\t\t\t\tcitiesToFill.add(code);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (name.length() < 3) {\n\t\t\t\tif (name.length() == 0) {\n\t\t\t\t\tcitiesToFill.addAll(cities.values());\n\t\t\t\t} else {\n\t\t\t\t\tname = name.toLowerCase();\n\t\t\t\t\tfor (City c : cities.values()) {\n\t\t\t\t\t\tString cName = useEnglishNames ? c.getEnName() : c.getName(); //lower case not needed, collator ensures that\n\t\t\t\t\t\tif (cstartsWith(collator, cName, name)) {\n\t\t\t\t\t\t\tif (resultMatcher.publish(c)) {\n\t\t\t\t\t\t\t\tcitiesToFill.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\tfor (City c : cities.values()) {\n\t\t\t\t\tString cName = useEnglishNames ? c.getEnName() : c.getName(); //lower case not needed, collator ensures that\n\t\t\t\t\tif (cstartsWith(collator,cName,name)) {\n\t\t\t\t\t\tif (resultMatcher.publish(c)) {\n\t\t\t\t\t\t\tcitiesToFill.add(ind, c);\n\t\t\t\t\t\t\tind++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ccontains(collator,name,cName)) {\n\t\t\t\t\t\tif (resultMatcher.publish(c)) {\n\t\t\t\t\t\t\tcitiesToFill.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint initialsize = citiesToFill.size();\n\t\t\t\t\n\t\t\t\tfor(City c : file.getVillages(region, resultMatcher, new ContainsStringMatcher(name,collator), useEnglishNames )){\n\t\t\t\t\tString cName = c.getName(useEnglishNames); //lower case not needed, collator ensures that\n\t\t\t\t\tif (cstartsWith(collator,cName,name)) {\n\t\t\t\t\t\tcitiesToFill.add(ind, c);\n\t\t\t\t\t\tind++;\n\t\t\t\t\t} else if (ccontains(collator,name, cName)) {\n\t\t\t\t\t\tcitiesToFill.add(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlog.debug(\"Loaded citites \" + (citiesToFill.size() - initialsize)); //$NON-NLS-1$\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Disk operation failed\" , e); //$NON-NLS-1$\n\t\t}\n\t\treturn citiesToFill;\n\t\t\n\t}","id":3911,"modified_method":"@Override\n\tpublic List<MapObject> fillWithSuggestedCities(String name, ResultMatcher<MapObject> resultMatcher, LatLon currentLocation) {\n\t\tList<MapObject> citiesToFill = new ArrayList<MapObject>();\n\t\tif (cities.isEmpty()) {\n\t\t\tpreloadCities(resultMatcher);\n\t\t\tcitiesToFill.addAll(cities.values());\n\t\t\treturn citiesToFill;\n\t\t}\n\n\t\tpreloadCities(null);\n\t\tif (name.length() == 0) {\n\t\t\tcitiesToFill.addAll(cities.values());\n\t\t\treturn citiesToFill;\n\t\t}\n\t\ttry {\n\t\t\t// essentially index is created that cities towns are first in cities map\n\t\t\tif (name.length() >= 2 && Algoritms.containsDigit(name)) {\n\t\t\t\t// also try to identify postcodes\n\t\t\t\tString uName = name.toUpperCase();\n\t\t\t\tfor (PostCode code : file.getPostcodes(region, resultMatcher, new CollatorStringMatcher(collator, uName,\n\t\t\t\t\t\tStringMatcherMode.CHECK_CONTAINS))) {\n\t\t\t\t\tcitiesToFill.add(code);\n\t\t\t\t\tif (resultMatcher.isCancelled()) {\n\t\t\t\t\t\treturn citiesToFill;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tname = name.toLowerCase();\n\t\t\tfor (City c : cities.values()) {\n\t\t\t\tString cName = c.getName(useEnglishNames); // lower case not needed, collator ensures that\n\t\t\t\tif (cmatches(collator, cName, name, StringMatcherMode.CHECK_STARTS_FROM_SPACE)) {\n\t\t\t\t\tif (resultMatcher.publish(c)) {\n\t\t\t\t\t\tcitiesToFill.add(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resultMatcher.isCancelled()) {\n\t\t\t\t\treturn citiesToFill;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint initialsize = citiesToFill.size();\n\t\t\tif (name.length() >= 3) {\n\t\t\t\tfor (City c : file.getVillages(region, resultMatcher, new CollatorStringMatcher(collator, name,\n\t\t\t\t\t\tStringMatcherMode.CHECK_STARTS_FROM_SPACE), useEnglishNames)) {\n\t\t\t\t\tcitiesToFill.add(c);\n\t\t\t\t\tif (resultMatcher.isCancelled()) {\n\t\t\t\t\t\treturn citiesToFill;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.debug(\"Loaded citites \" + (citiesToFill.size() - initialsize)); //$NON-NLS-1$\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Disk operation failed\", e); //$NON-NLS-1$\n\t\t}\n\t\treturn citiesToFill;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<Building> fillWithSuggestedBuildings(PostCode postcode, Street street, String name, ResultMatcher<Building> resultMatcher) {\n\t\tList<Building> buildingsToFill = new ArrayList<Building>();\n\t\tif (name.length() == 0) {\n\t\t\tpreloadBuildings(street, resultMatcher);\n\t\t\tbuildingsToFill.addAll(street.getBuildings());\n\t\t\treturn buildingsToFill;\n\t\t}\n\t\tpreloadBuildings(street, null);\n\t\tname = name.toLowerCase();\n\t\tint ind = 0;\n\t\tfor (Building building : street.getBuildings()) {\n\t\t\tString bName = useEnglishNames ? building.getEnName() : building.getName(); //lower case not needed, collator ensures that\n\t\t\tif (cstartsWith(collator,bName,name)) { \n\t\t\t\tbuildingsToFill.add(ind, building);\n\t\t\t\tind++;\n\t\t\t} else if (ccontains(collator,name,bName)) {\n\t\t\t\tbuildingsToFill.add(building);\n\t\t\t}\n\t\t}\n\t\treturn buildingsToFill;\n\t}","id":3912,"modified_method":"@Override\n\tpublic List<Building> fillWithSuggestedBuildings(PostCode postcode, Street street, String name, ResultMatcher<Building> resultMatcher) {\n\t\tList<Building> buildingsToFill = new ArrayList<Building>();\n\t\tif (name.length() == 0) {\n\t\t\tpreloadBuildings(street, resultMatcher);\n\t\t\tbuildingsToFill.addAll(street.getBuildings());\n\t\t\treturn buildingsToFill;\n\t\t}\n\t\tpreloadBuildings(street, null);\n\t\tname = name.toLowerCase();\n\t\tfor (Building building : street.getBuildings()) {\n\t\t\tif(resultMatcher.isCancelled()){\n\t\t\t\treturn buildingsToFill;\n\t\t\t}\n\t\t\tString bName = useEnglishNames ? building.getEnName() : building.getName(); //lower case not needed, collator ensures that\n\t\t\tif (cmatches(collator, bName, name, StringMatcherMode.CHECK_ONLY_STARTS_WITH)) {\n\t\t\t\tresultMatcher.publish(building);\n\t\t\t\tbuildingsToFill.add(building);\n\t\t\t}\n\t\t}\n\t\treturn buildingsToFill;\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<Building> getObjects(String filter, final SearchByNameTask task) {\n\t\tif(street != null){\n\t\t\treturn region.fillWithSuggestedBuildings(postcode, street, filter, new ResultMatcher<Building>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(Building object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn new ArrayList<Building>();\n\t}","id":3913,"modified_method":"@Override\n\tpublic List<Building> getObjects(String filter, final SearchByNameTask task) {\n\t\tif(street != null){\n\t\t\treturn region.fillWithSuggestedBuildings(postcode, street, filter, new ResultMatcher<Building>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(Building object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\treturn task.isCancelled();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn new ArrayList<Building>();\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_building);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tresetText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets_buildings);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\tif(postcode != null){\n\t\t\t\t\t\tstreet = region.getStreetByName(postcode, settings.getLastSearchedStreet());\n\t\t\t\t\t} else if(city != null){\n\t\t\t\t\t\tstreet = region.getStreetByName(city, settings.getLastSearchedStreet());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","id":3914,"modified_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_building);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tupdateSearchText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets_buildings);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\tif(postcode != null){\n\t\t\t\t\t\tstreet = region.getStreetByName(postcode, settings.getLastSearchedStreet());\n\t\t\t\t\t} else if(city != null){\n\t\t\t\t\t\tstreet = region.getStreetByName(city, settings.getLastSearchedStreet());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(street != null){\n\t\t\t\t\t// preload here to avoid concurrent modification\n\t\t\t\t\tregion.fillWithSuggestedBuildings(postcode, street, \"\", null);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tprotected void onPostExecute(List<T> result) {\n\t\t\tif (!isCancelled() && result != null) {\n\t\t\t\t((NamesAdapter) getListAdapter()).setNotifyOnChange(false);\n\t\t\t\t((NamesAdapter) getListAdapter()).clear();\n\t\t\t\tfor (T o : result) {\n\t\t\t\t\t((NamesAdapter) getListAdapter()).add(o);\n\t\t\t\t}\n\t\t\t\t((NamesAdapter) getListAdapter()).notifyDataSetChanged();\n\t\t\t}\n\t\t\tif (!isCancelled()) {\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t}\n\t\t}","id":3915,"modified_method":"@Override\n\t\tprotected void onPostExecute(List<T> result) {\n\t\t\tSystem.out.println(\"Search \" + filter + \" finished in \" + (System.currentTimeMillis() - startTime));\n\t\t\tif (!isCancelled() && result != null) {\n\t\t\t\t((NamesAdapter) getListAdapter()).setNotifyOnChange(false);\n\t\t\t\t((NamesAdapter) getListAdapter()).clear();\n\t\t\t\tfor (T o : result) {\n\t\t\t\t\t((NamesAdapter) getListAdapter()).add(o);\n\t\t\t\t}\n\t\t\t\t((NamesAdapter) getListAdapter()).notifyDataSetChanged();\n\t\t\t}\n\t\t\tif (!isCancelled()) {\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t}\n\t\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setText(final String filter) {\n\t\tif(isFilterableByDefault()){\n\t\t\t((NamesAdapter) getListAdapter()).getFilter().filter(filter);\n\t\t\treturn;\n\t\t}\n\t\t((NamesAdapter) getListAdapter()).clear();\n\t\tStatus status = searchTask.getStatus();\n\t\tif(status == Status.FINISHED){\n\t\t\tsearchTask = new SearchByNameTask();\n\t\t} else if(status == Status.RUNNING){\n\t\t\tsearchTask.cancel(true);\n\t\t\t// TODO improve\n\t\t\tsearchTask = new SearchByNameTask();\n\t\t}\n\t\tsearchTask.execute(filter);\n\t}","id":3916,"modified_method":"public void setText(final String filter) {\n\t\tif (isFilterableByDefault()) {\n\t\t\t((NamesAdapter) getListAdapter()).getFilter().filter(filter);\n\t\t\treturn;\n\t\t}\n\t\t((NamesAdapter) getListAdapter()).clear();\n\t\tStatus status = searchTask.getStatus();\n\t\tif (status != Status.FINISHED) {\n\t\t\tsearchTask.cancel(true);\n\t\t}\n\t\tsearchTask = new SearchByNameTask();\n\t\tsearchTask.execute(filter);\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tprotected List<T> doInBackground(String... params) {\n\t\t\tif(params == null || params.length == 0){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString filter = params[0];\n\t\t\treturn getObjects(filter, this);\n\t\t}","id":3917,"modified_method":"@Override\n\t\tprotected List<T> doInBackground(String... params) {\n\t\t\tif(params == null || params.length == 0){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter = params[0];\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t\treturn getObjects(filter, this);\n\t\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsettings = OsmandSettings.getOsmandSettings(this);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\t\n\t\tsetContentView(R.layout.search_by_name);\n\t\tNamesAdapter namesAdapter = new NamesAdapter(new ArrayList<T>()); //$NON-NLS-1$\n\t\tsetListAdapter(namesAdapter);\n\t\tprogress = (ProgressBar) findViewById(R.id.ProgressBar);\n\t\tsearchText = (EditText) findViewById(R.id.SearchText);\n\t\tsearchText.addTextChangedListener(new TextWatcher(){\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(initializeTask.getStatus() == Status.FINISHED){\n\t\t\t\t\tsetText(s.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tsearchText.requestFocus();\n\t\t\n\t\tprogress.setVisibility(View.INVISIBLE);\n\t\tfindViewById(R.id.ResetButton).setOnClickListener(new View.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tresetText();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);\n\t\t\n\t\tinitializeTask = getInitializeTask();\n\t\tif(initializeTask != null){\n\t\t\tinitializeTask.execute();\n\t\t}\n\t}","id":3918,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsettings = OsmandSettings.getOsmandSettings(this);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tsetContentView(R.layout.search_by_name);\n\t\tinitializeTask = getInitializeTask();\n\t\tNamesAdapter namesAdapter = new NamesAdapter(new ArrayList<T>()); //$NON-NLS-1$\n\t\tsetListAdapter(namesAdapter);\n\t\t\n\t\t\n\t\tprogress = (ProgressBar) findViewById(R.id.ProgressBar);\n\t\tsearchText = (EditText) findViewById(R.id.SearchText);\n\t\tsearchText.addTextChangedListener(new TextWatcher(){\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(initializeTask == null || initializeTask.getStatus() == Status.FINISHED){\n\t\t\t\t\tsetText(s.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t});\n\t\tsearchText.requestFocus();\n\t\t\n\t\tprogress.setVisibility(View.INVISIBLE);\n\t\tfindViewById(R.id.ResetButton).setOnClickListener(new View.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsearchText.setText(\"\");\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);\n\t\tif(initializeTask != null){\n\t\t\tinitializeTask.execute();\n\t\t}\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_city);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tresetText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_cities);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","id":3919,"modified_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, MapObject, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_city);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tupdateSearchText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_cities);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onProgressUpdate(MapObject... values) {\n\t\t\t\tif (hasWindowFocus()) {\n\t\t\t\t\tfor (MapObject t : values) {\n\t\t\t\t\t\t((NamesAdapter) getListAdapter()).add(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\t// preload cities\n\t\t\t\t\tregion.fillWithSuggestedCities(\"\", new ResultMatcher<MapObject>() {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean publish(MapObject object) {\n\t\t\t\t\t\t\tpublishProgress(object);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, locationToSearch);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<MapObject> getObjects(String filter, final SearchByNameTask task) {\n\t\tif(region != null){\n\t\t\tregion.fillWithSuggestedCities(filter, new ResultMatcher<MapObject>() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(MapObject object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, locationToSearch);\n\t\t}\n\t\treturn new ArrayList<MapObject>();\n\t}","id":3920,"modified_method":"@Override\n\tpublic List<MapObject> getObjects(String filter, final SearchByNameTask task) {\n\t\tif(region != null){\n\t\t\treturn region.fillWithSuggestedCities(filter, new ResultMatcher<MapObject>() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(MapObject object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\treturn task.isCancelled();\n\t\t\t\t}\n\t\t\t}, locationToSearch);\n\t\t}\n\t\treturn new ArrayList<MapObject>();\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t((TextView)findViewById(R.id.Label)).setText(R.string.choose_available_region);\n\t\tif(((OsmandApplication)getApplication()).getResourceManager().getAddressRepositories().isEmpty()){\n\t\t\tToast.makeText(this, R.string.none_region_found, Toast.LENGTH_LONG).show();\n\t\t}\n\t}","id":3921,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t((TextView)findViewById(R.id.Label)).setText(R.string.choose_available_region);\n\t\tif(((OsmandApplication)getApplication()).getResourceManager().getAddressRepositories().isEmpty()){\n\t\t\tToast.makeText(this, R.string.none_region_found, Toast.LENGTH_LONG).show();\n\t\t}\n\t\tNamesAdapter namesAdapter = new NamesAdapter(getObjects(\"\", null)); //$NON-NLS-1$\n\t\tsetListAdapter(namesAdapter);\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_street);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tresetText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\tif(postcode != null){\n\t\t\t\t\t\tstreet1 = region.getStreetByName(postcode, (settings.getLastSearchedStreet()));\n\t\t\t\t\t\tif(street1 != null){\n\t\t\t\t\t\t\tcity = street1.getCity();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(city != null){\n\t\t\t\t\t\tstreet1 = region.getStreetByName(city, (settings.getLastSearchedStreet()));\n\t\t\t\t\t}\n\t\t\t\t\tif(city != null){\n\t\t\t\t\t\tList<Street> t = new ArrayList<Street>();\n\t\t\t\t\t\tregion.fillWithSuggestedStreetsIntersectStreets(city, street1, t);\n\t\t\t\t\t\tinitialList = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","id":3922,"modified_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_street);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tupdateSearchText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\tif(postcode != null){\n\t\t\t\t\t\tstreet1 = region.getStreetByName(postcode, (settings.getLastSearchedStreet()));\n\t\t\t\t\t\tif(street1 != null){\n\t\t\t\t\t\t\tcity = street1.getCity();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(city != null){\n\t\t\t\t\t\tstreet1 = region.getStreetByName(city, (settings.getLastSearchedStreet()));\n\t\t\t\t\t}\n\t\t\t\t\tif(city != null && street1 != null){\n\t\t\t\t\t\tList<Street> t = new ArrayList<Street>();\n\t\t\t\t\t\tregion.fillWithSuggestedStreetsIntersectStreets(city, street1, t);\n\t\t\t\t\t\tinitialList = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Void, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_street);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tresetText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tif (postcode == null) {\n\t\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","id":3923,"modified_method":"@Override\n\tpublic AsyncTask<Object, ?, ?> getInitializeTask() {\n\t\treturn new AsyncTask<Object, Street, Void>(){\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.incremental_search_street);\n\t\t\t\tprogress.setVisibility(View.INVISIBLE);\n\t\t\t\tupdateSearchText();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t\t((TextView)findViewById(R.id.Label)).setText(R.string.loading_streets);\n\t\t\t\tprogress.setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected Void doInBackground(Object... params) {\n\t\t\t\tregion = ((OsmandApplication)getApplication()).getResourceManager().getRegionRepository(settings.getLastSearchedRegion());\n\t\t\t\tif(region != null){\n\t\t\t\t\tpostcode = region.getPostcode(settings.getLastSearchedPostcode());\n\t\t\t\t\tif (postcode == null) {\n\t\t\t\t\t\tcity = region.getCityById(settings.getLastSearchedCity());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// preload here to avoid concurrent modification\n\t\t\t\tregion.fillWithSuggestedStreets(postcode == null ? city : postcode, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic List<Street> getObjects(String filter, final SearchByNameTask task) {\n\t\tif (city != null || postcode != null) {\n\t\t\treturn region.fillWithSuggestedStreets(postcode == null ? city : postcode, new ResultMatcher<Street>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(Street object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, filter);\n\t\t}\n\t\treturn new ArrayList<Street>();\n\t}","id":3924,"modified_method":"@Override\n\tpublic List<Street> getObjects(String filter, final SearchByNameTask task) {\n\t\tif (city != null || postcode != null) {\n\t\t\treturn region.fillWithSuggestedStreets(postcode == null ? city : postcode, new ResultMatcher<Street>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean publish(Street object) {\n\t\t\t\t\ttask.progress(object);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\treturn task.isCancelled();\n\t\t\t\t}\n\t\t\t}, filter);\n\t\t}\n\t\treturn new ArrayList<Street>();\n\t}","commit_id":"4d56ca74de2e7e564eb4f312f4382e995e35c45e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void processPropertiesFromGetterSetter(SimpleGroovyMethodDoc currentMethodDoc) {\n        String methodName = currentMethodDoc.name();\n        SimpleGroovyClassDoc classDoc = getCurrentClassDoc();\n        GroovyMethodDoc methods[] = classDoc.methods();\n\n        String setOrGet = methodName.substring(0, Math.min(methodName.length(), 3));\n        if (setOrGet.equals(\"set\") || setOrGet.equals(\"get\") || setOrGet.startsWith(\"is\")) {\n\n            //find expected method name\n            String expectedMethodName = null ;\n            if (setOrGet.equals(\"set\") && (currentMethodDoc.parameters().length >= 1 && !currentMethodDoc.parameters()[0].typeName().equals(\"boolean\"))) {\n                expectedMethodName = \"get\" + methodName.substring(3);\n            } else if (setOrGet.equals(\"get\") && !currentMethodDoc.returnType().typeName().equals(\"boolean\")) {\n                expectedMethodName = \"set\" + methodName.substring(3);\n            } else if (setOrGet.startsWith(\"is\")) {\n                expectedMethodName = \"set\" + methodName.substring(2);\n            } else {\n                expectedMethodName = \"is\" + methodName.substring(3);\n            }\n\n            for (GroovyMethodDoc methodDoc : methods) {\n                if (methodDoc.name().equals(expectedMethodName)) {\n\n                    //extract the field name\n                    String fieldName = null;\n                    if (expectedMethodName.startsWith(\"set\") && methodName.startsWith(\"is\")) {\n                        fieldName = methodName.substring(2);\n                    } else {\n                        fieldName = methodName.substring(3);\n                    }\n\n                    fieldName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);\n                    SimpleGroovyFieldDoc currentFieldDoc = new SimpleGroovyFieldDoc(fieldName, classDoc);\n\n                    //find the type of the field; if it's a setter, need to get the type of the params\n                    if(expectedMethodName.startsWith(\"set\") && methodDoc.parameters().length >= 1) {\n                        String typeName = methodDoc.parameters()[0].typeName();\n                        currentFieldDoc.setType(new SimpleGroovyType(typeName));\n                    } else {\n                        //if it's not setter, get the type info of the return type of the get* method\n                        currentFieldDoc.setType(methodDoc.returnType());\n                    }\n\n                    if (methodDoc.isPublic() && currentMethodDoc.isPublic()) {\n                        classDoc.addProperty(currentFieldDoc);\n                        break;\n                    }\n                }\n            }\n        }\n    }","id":3925,"modified_method":"private void processPropertiesFromGetterSetter(SimpleGroovyMethodDoc currentMethodDoc) {\n        String methodName = currentMethodDoc.name();\n        int len = methodName.length();\n        String prefix = null;\n        String propName = null;\n        if (len > 3 && methodName.startsWith(\"get\")) {\n            prefix = \"get\";\n            propName = methodName.substring(3);\n        } else if (len > 3 && methodName.startsWith(\"set\")) {\n            prefix = \"set\";\n            propName = methodName.substring(3);\n        } else if (len > 2 && methodName.startsWith(\"is\")) {\n            prefix = \"is\";\n            propName = methodName.substring(2);\n        } else {\n            // Not a (get/set/is) method that contains a property name\n            return;\n        }\n\n        SimpleGroovyClassDoc classDoc = getCurrentClassDoc();\n        // TODO: not sure why but groovy.ui.view.BasicContentPane#buildOutputArea classDoc is null\n        if (classDoc == null) {\n            return;\n        }\n        GroovyMethodDoc methods[] = classDoc.methods();\n\n        //find expected method name\n        String expectedMethodName = null;\n        if (\"set\".equals(prefix) && (currentMethodDoc.parameters().length >= 1 && !currentMethodDoc.parameters()[0].typeName().equals(\"boolean\"))) {\n            expectedMethodName = \"get\" + propName;\n        } else if (\"get\".equals(prefix) && !currentMethodDoc.returnType().typeName().equals(\"boolean\")) {\n            expectedMethodName = \"set\" + propName;\n        } else if (\"is\".equals(prefix)) {\n            expectedMethodName = \"set\" + propName;\n        } else {\n            expectedMethodName = \"is\" + propName;\n        }\n\n        for (GroovyMethodDoc methodDoc : methods) {\n            if (methodDoc.name().equals(expectedMethodName)) {\n\n                //extract the field name\n                String fieldName = propName.substring(0, 1).toLowerCase() + propName.substring(1);\n                SimpleGroovyFieldDoc currentFieldDoc = new SimpleGroovyFieldDoc(fieldName, classDoc);\n\n                //find the type of the field; if it's a setter, need to get the type of the params\n                if(expectedMethodName.startsWith(\"set\") && methodDoc.parameters().length >= 1) {\n                    String typeName = methodDoc.parameters()[0].typeName();\n                    currentFieldDoc.setType(new SimpleGroovyType(typeName));\n                } else {\n                    //if it's not setter, get the type info of the return type of the get* method\n                    currentFieldDoc.setType(methodDoc.returnType());\n                }\n\n                if (methodDoc.isPublic() && currentMethodDoc.isPublic()) {\n                    classDoc.addProperty(currentFieldDoc);\n                    break;\n                }\n            }\n        }\n    }","commit_id":"2e7c69dc4d185dc790b7d15857235458ef3eb7a6","url":"https://github.com/apache/groovy"},{"original_method":"/** Adds the specified rotation to the current rotation. */\r\n\tpublic void rotateBy (float amountInDegrees) {\r\n\t\trotation += amountInDegrees;\r\n\t\tif (amountInDegrees != 0)\r\n\t\t\trotationChanged();\r\n\t}","id":3926,"modified_method":"/** Adds the specified rotation to the current rotation. */\r\n\tpublic void rotateBy (float amountInDegrees) {\r\n\t\tif (amountInDegrees != 0) {\r\n\t\t\trotation += amountInDegrees;\r\n\t\t\trotationChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets the width and height. */\r\n\tpublic void setSize (float width, float height) {\r\n\t\tfloat oldWidth = this.width;\r\n\t\tfloat oldHeight = this.height;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tif (width != oldWidth || height != oldHeight) sizeChanged();\r\n\t}","id":3927,"modified_method":"/** Sets the width and height. */\r\n\tpublic void setSize (float width, float height) {\r\n\t\tif (this.width != width || this.height != height) {\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setRotation (float degrees) {\r\n\t\tfloat oldRotation = this.rotation;\r\n\t\tthis.rotation = degrees;\r\n\t\tif (degrees != oldRotation) rotationChanged();\r\n\t}","id":3928,"modified_method":"public void setRotation (float degrees) {\r\n\t\tif (this.rotation != degrees) {\r\n\t\t\tthis.rotation = degrees;\r\n\t\t\trotationChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setWidth (float width) {\r\n\t\tfloat oldWidth = this.width;\r\n\t\tthis.width = width;\r\n\t\tif (width != oldWidth) sizeChanged();\r\n\t}","id":3929,"modified_method":"public void setWidth (float width) {\r\n\t\tif (this.width != width) {\r\n\t\t\tthis.width = width;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Adds the specified size to the current size. */\r\n\tpublic void sizeBy (float width, float height) {\r\n\t\tthis.width += width;\r\n\t\tthis.height += height;\r\n\t\tsizeChanged();\r\n\t}","id":3930,"modified_method":"/** Adds the specified size to the current size. */\r\n\tpublic void sizeBy (float width, float height) {\r\n\t\tif (width != 0 || height != 0) {\r\n\t\t\tthis.width += width;\r\n\t\t\tthis.height += height;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Adds the specified size to the current size. */\r\n\tpublic void sizeBy (float size) {\r\n\t\twidth += size;\r\n\t\theight += size;\r\n\t\tsizeChanged();\r\n\t}","id":3931,"modified_method":"/** Adds the specified size to the current size. */\r\n\tpublic void sizeBy (float size) {\r\n\t\tif (size != 0) {\r\n\t\t\twidth += size;\r\n\t\t\theight += size;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setHeight (float height) {\r\n\t\tfloat oldHeight = this.height;\r\n\t\tthis.height = height;\r\n\t\tif (height != oldHeight) sizeChanged();\r\n\t}","id":3932,"modified_method":"public void setHeight (float height) {\r\n\t\tif (this.height != height) {\r\n\t\t\tthis.height = height;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"790e49358ff3abb261c1d3881cbff76ae8621e1b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setY (float y) {\r\n\t\tthis.y = y;\r\n\t}","id":3933,"modified_method":"public void setY (float y) {\r\n\t\tif (this.y != y) {\r\n\t\t\tthis.y = y;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Set position of Actor centered on x, y */\r\n\tpublic void setCenterPosition (float x, float y) {\r\n\t\tthis.x = x - width / 2;\r\n\t\tthis.y = y - height / 2;\r\n\t}","id":3934,"modified_method":"/** Set position of Actor centered on x, y */\r\n\tpublic void setCenterPosition (float x, float y) {\r\n\t\tfloat newX = x - width / 2;\r\n\t\tfloat newY = y - height / 2;\r\n\t\tif (this.x != newX || this.y != newY) {\r\n\t\t\tthis.x = newX;\r\n\t\t\tthis.y = newY;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setX (float x) {\r\n\t\tthis.x = x;\r\n\t}","id":3935,"modified_method":"public void setX (float x) {\r\n\t\tif (this.x != x) {\r\n\t\t\tthis.x = x;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Add x and y to current position */\r\n\tpublic void moveBy (float x, float y) {\r\n\t\tthis.x += x;\r\n\t\tthis.y += y;\r\n\t}","id":3936,"modified_method":"/** Add x and y to current position */\r\n\tpublic void moveBy (float x, float y) {\r\n\t\tif (x != 0 || y != 0) {\r\n\t\t\tthis.x += x;\r\n\t\t\tthis.y += y;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Set position of Actor to x, y (using bottom left corner of Actor) */\r\n\tpublic void setPosition (float x, float y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}","id":3937,"modified_method":"/** Set position of Actor to x, y (using bottom left corner of Actor) */\r\n\tpublic void setPosition (float x, float y) {\r\n\t\tif (this.x != x || this.y != y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Set bounds the x, y, width, and height. */\r\n\tpublic void setBounds (float x, float y, float width, float height) {\r\n\t\tfloat oldWidth = this.width;\r\n\t\tfloat oldHeight = this.height;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tif (width != oldWidth || height != oldHeight) sizeChanged();\r\n\t}","id":3938,"modified_method":"/** Set bounds the x, y, width, and height. */\r\n\tpublic void setBounds (float x, float y, float width, float height) {\r\n\t\tif (this.x != x || this.y != y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tpositionChanged();\r\n\t\t}\r\n\t\tif (this.width != width || this.height != height) {\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\t\t\tsizeChanged();\r\n\t\t}\r\n\t}","commit_id":"e4551915f6d96b6d54c700829f2848bfa4187043","url":"https://github.com/libgdx/libgdx"},{"original_method":"public synchronized IndexWriter getWriter(String companyId, boolean create)\n\t\tthrows IOException {\n\n\t\tIndexWriterData writerData = (IndexWriterData)_lookup.get(companyId);\n\n\t\tif (writerData == null) {\n\t\t\tIndexWriter writer = new IndexWriter(\n\t\t\t\tLuceneUtil.getLuceneDir(companyId), LuceneUtil.getAnalyzer(),\n\t\t\t\tcreate);\n\n\t\t\twriterData = new IndexWriterData(companyId, writer, 0);\n\n\t\t\t_lookup.put(companyId, writerData);\n\t\t}\n\n\t\twriterData.setCount(writerData.getCount() + 1);\n\n\t\treturn writerData.getWriter();\n\t}","id":3939,"modified_method":"public IndexWriter getWriter(String companyId, boolean create)\n\t\tthrows IOException {\n\n\t\tboolean hasError = false;\n\t\tboolean newWriter = false;\n\n\t\ttry {\n\n\t\t\t// If others need an exclusive lock, then wait to acquire lock\n\t\t\t// before proceeding. This prevents starvation.\n\n\t\t\tif (_needExclusiveLock > 0) {\n\t\t\t\tacquireLock(companyId, false);\n\t\t\t\treleaseLock(companyId);\n\t\t\t}\n\n\t\t\tsynchronized(this) {\n\t\t\t\tIndexWriterData writerData =\n\t\t\t\t\t(IndexWriterData)_writerLookup.get(companyId);\n\n\t\t\t\tif (writerData == null) {\n\t\t\t\t\tacquireLock(companyId, false);\n\n\t\t\t\t\tIndexWriter writer = new IndexWriter(\n\t\t\t\t\t\tLuceneUtil.getLuceneDir(companyId),\n\t\t\t\t\t\tLuceneUtil.getAnalyzer(), create);\n\n\t\t\t\t\twriterData = new IndexWriterData(companyId, writer, 0);\n\n\t\t\t\t\t_writerLookup.put(companyId, writerData);\n\t\t\t\t}\n\n\t\t\t\twriterData.setCount(writerData.getCount() + 1);\n\n\t\t\t\treturn writerData.getWriter();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thasError = true;\n\n\t\t\t_log.error(e, e);\n\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\tif (hasError && newWriter) {\n\t\t\t\ttry {\n\t\t\t\t\treleaseLock(companyId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void write(IndexWriter writer) throws IOException {\n\t\twriter.optimize();\n\n\t\tsynchronized(this) {\n\t\t\tIterator itr = _lookup.values().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tIndexWriterData writerData = (IndexWriterData)itr.next();\n\n\t\t\t\tif (writerData.getWriter() == writer) {\n\t\t\t\t\tif (writerData.getCount() > 0) {\n\t\t\t\t\t\twriterData.setCount(writerData.getCount() - 1);\n\n\t\t\t\t\t\tif (writerData.getCount() == 0) {\n\t\t\t\t\t\t\t_lookup.remove(writerData.getCompanyId());\n\n\t\t\t\t\t\t\twriter.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":3940,"modified_method":"public void write(IndexWriter writer) throws IOException {\n\t\tboolean writerFound = false;\n\n\t\tsynchronized(this) {\n\t\t\tif (!_writerLookup.isEmpty()) {\n\n\t\t\t\tIterator itr = _writerLookup.values().iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tIndexWriterData writerData = (IndexWriterData)itr.next();\n\n\t\t\t\t\tif (writerData.getWriter() == writer) {\n\t\t\t\t\t\twriterFound = true;\n\n\t\t\t\t\t\tdecrement(writerData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!writerFound) {\n\t\t\ttry {\n\t\t\t\twriter.optimize();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\twriter.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPage(\n\t\t\tString companyId, long groupId, String nodeId, String title,\n\t\t\tString content)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tcontent = Html.stripHtml(content);\n\n\t\t\tdeletePage(companyId, nodeId, title);\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"nodeId\", nodeId));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3941,"modified_method":"public static void addPage(\n\t\t\tString companyId, long groupId, String nodeId, String title,\n\t\t\tString content)\n\tthrows IOException {\n\n\t\tcontent = Html.stripHtml(content);\n\n\t\tdeletePage(companyId, nodeId, title);\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"nodeId\", nodeId));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deletePages(String companyId, String nodeId)\n\t\tthrows IOException, ParseException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tBooleanQuery booleanQuery = new BooleanQuery();\n\n\t\t\tLuceneUtil.addRequiredTerm(\n\t\t\t\tbooleanQuery, LuceneFields.PORTLET_ID, PORTLET_ID);\n\n\t\t\tLuceneUtil.addRequiredTerm(booleanQuery, \"nodeId\", nodeId);\n\n\t\t\tSearcher searcher = LuceneUtil.getSearcher(companyId);\n\n\t\t\tHits hits = searcher.search(booleanQuery);\n\n\t\t\tif (hits.length() > 0) {\n\t\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\t\tfor (int i = 0; i < hits.length(); i++) {\n\t\t\t\t\tDocument doc = hits.doc(i);\n\n\t\t\t\t\tField field = doc.getField(LuceneFields.UID);\n\n\t\t\t\t\treader.deleteDocuments(\n\t\t\t\t\t\tnew Term(LuceneFields.UID, field.stringValue()));\n\t\t\t\t}\n\n\t\t\t\treader.close();\n\t\t\t}\n\t\t}\n\t}","id":3942,"modified_method":"public static void deletePages(String companyId, String nodeId)\n\t\tthrows IOException, ParseException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tBooleanQuery booleanQuery = new BooleanQuery();\n\n\t\t\tLuceneUtil.addRequiredTerm(\n\t\t\t\tbooleanQuery, LuceneFields.PORTLET_ID, PORTLET_ID);\n\n\t\t\tLuceneUtil.addRequiredTerm(booleanQuery, \"nodeId\", nodeId);\n\n\t\t\tSearcher searcher = LuceneUtil.getSearcher(companyId);\n\n\t\t\tHits hits = searcher.search(booleanQuery);\n\n\t\t\tif (hits.length() > 0) {\n\t\t\t\tIndexReader reader = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tLuceneUtil.acquireLock(companyId);\n\n\t\t\t\t\treader = LuceneUtil.getReader(companyId);\n\n\t\t\t\t\tfor (int i = 0; i < hits.length(); i++) {\n\t\t\t\t\t\tDocument doc = hits.doc(i);\n\n\t\t\t\t\t\tField field = doc.getField(LuceneFields.UID);\n\n\t\t\t\t\t\treader.deleteDocuments(\n\t\t\t\t\t\t\tnew Term(LuceneFields.UID, field.stringValue()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (reader != null) {\n\t\t\t\t\t\treader.close();\n\t\t\t\t\t}\n\n\t\t\t\t\tLuceneUtil.releaseLock(companyId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deletePage(String companyId, String nodeId, String title)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3943,"modified_method":"public static void deletePage(String companyId, String nodeId, String title)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addEntry(\n\t\t\tString companyId, long groupId, String userId, long categoryId,\n\t\t\tlong entryId, String title, String content)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tcontent = Html.stripHtml(content);\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, entryId)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.USER_ID, userId));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"categoryId\", categoryId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"entryId\", entryId));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3944,"modified_method":"public static void addEntry(\n\t\t\tString companyId, long groupId, String userId, long categoryId,\n\t\t\tlong entryId, String title, String content)\n\t\tthrows IOException {\n\n\t\tcontent = Html.stripHtml(content);\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, entryId)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.USER_ID, userId));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"categoryId\", categoryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"entryId\", entryId));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteEntry(String companyId, long entryId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, entryId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3945,"modified_method":"public static void deleteEntry(String companyId, long entryId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, entryId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteProductEntry(String companyId, long productEntryId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3946,"modified_method":"public static void deleteProductEntry(String companyId, long productEntryId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addProductEntry(\n\t\t\tString companyId, long groupId, String userId, String userName,\n\t\t\tlong productEntryId, String name, String type,\n\t\t\tString shortDescription, String longDescription, String pageURL,\n\t\t\tString repoGroupId, String repoArtifactId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tshortDescription = Html.stripHtml(shortDescription);\n\t\t\tlongDescription = Html.stripHtml(longDescription);\n\n\t\t\tString content =\n\t\t\t\tuserId + \" \" + userName + \" \" + type + \" \" + shortDescription +\n\t\t\t\t\t\" \" + longDescription + \" \" + pageURL + repoGroupId + \" \" +\n\t\t\t\t\t\trepoArtifactId;\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.USER_ID, userId));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, name));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"productEntryId\", productEntryId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"repoGroupId\", repoGroupId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"repoArtifactId\", repoArtifactId));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3947,"modified_method":"public static void addProductEntry(\n\t\t\tString companyId, long groupId, String userId, String userName,\n\t\t\tlong productEntryId, String name, String type,\n\t\t\tString shortDescription, String longDescription, String pageURL,\n\t\t\tString repoGroupId, String repoArtifactId)\n\t\tthrows IOException {\n\n\t\tshortDescription = Html.stripHtml(shortDescription);\n\t\tlongDescription = Html.stripHtml(longDescription);\n\n\t\tString content =\n\t\t\tuserId + \" \" + userName + \" \" + type + \" \" + shortDescription +\n\t\t\t\t\" \" + longDescription + \" \" + pageURL + repoGroupId + \" \" +\n\t\t\t\t\trepoArtifactId;\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.USER_ID, userId));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, name));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"productEntryId\", productEntryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\t\tdoc.add(LuceneFields.getKeyword(\"repoGroupId\", repoGroupId));\n\t\tdoc.add(LuceneFields.getKeyword(\"repoArtifactId\", repoArtifactId));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteArticle(String companyId, String articleId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, articleId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3948,"modified_method":"public static void deleteArticle(String companyId, String articleId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, articleId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addArticle(\n\t\t\tString companyId, long groupId, String articleId, double version,\n\t\t\tString title, String description, String content, String type,\n\t\t\tDate displayDate)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tif ((content != null) && (content.indexOf(\"<root>\") != -1) &&\n\t\t\t\t(content.indexOf(\"<dynamic-content>\") != -1)) {\n\n\t\t\t\tcontent = StringUtil.replace(\n\t\t\t\t\tcontent, \"<![CDATA[\", StringPool.BLANK);\n\t\t\t\tcontent = StringUtil.replace(content, \"]]>\", StringPool.BLANK);\n\t\t\t}\n\n\t\t\tcontent = Html.stripHtml(content);\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, articleId)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\t\t\tdoc.add(LuceneFields.getText(\n\t\t\t\tLuceneFields.DESCRIPTION, description));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"articleId\", articleId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\"version\", Double.toString(version)));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\t\t\tdoc.add(LuceneFields.getDate(\"displayDate\", displayDate));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3949,"modified_method":"public static void addArticle(\n\t\t\tString companyId, long groupId, String articleId, double version,\n\t\t\tString title, String description, String content, String type,\n\t\t\tDate displayDate)\n\t\tthrows IOException {\n\n\t\tif ((content != null) && (content.indexOf(\"<root>\") != -1) &&\n\t\t\t(content.indexOf(\"<dynamic-content>\") != -1)) {\n\n\t\t\tcontent = StringUtil.replace(\n\t\t\t\tcontent, \"<![CDATA[\", StringPool.BLANK);\n\t\t\tcontent = StringUtil.replace(content, \"]]>\", StringPool.BLANK);\n\t\t}\n\n\t\tcontent = Html.stripHtml(content);\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, articleId)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.DESCRIPTION, description));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"articleId\", articleId));\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\"version\", Double.toString(version)));\n\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\t\tdoc.add(LuceneFields.getDate(\"displayDate\", displayDate));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFile(\n\t\t\tString companyId, String portletId, String repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3950,"modified_method":"public static void deleteFile(\n\t\t\tString companyId, String portletId, String repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addFile(\n\t\t\tString companyId, String portletId, Long groupId,\n\t\t\tString repositoryId, String fileName)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Indexing document \" + companyId + \" \" + portletId + \" \" +\n\t\t\t\t\t\tgroupId + \" \" + repositoryId + \" \" + fileName);\n\t\t\t}\n\n\t\t\tString fileExt = StringPool.BLANK;\n\n\t\t\tint fileExtVersionPos = fileName.indexOf(DLServiceImpl.VERSION);\n\n\t\t\tif (fileExtVersionPos != -1) {\n\t\t\t\tint fileExtPos = fileName.lastIndexOf(\n\t\t\t\t\tStringPool.PERIOD, fileExtVersionPos);\n\n\t\t\t\tif (fileExtPos != -1) {\n\t\t\t\t\tfileExt = fileName.substring(fileExtPos, fileExtVersionPos);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint fileExtPos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\t\tif (fileExtPos != -1) {\n\t\t\t\t\tfileExt = fileName.substring(fileExtPos, fileName.length());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInputStream is = null;\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\t\tNode contentNode = DLUtil.getFileContentNode(\n\t\t\t\t\tsession, companyId, repositoryId, fileName, 0);\n\n\t\t\t\tis = contentNode.getProperty(JCRConstants.JCR_DATA).getStream();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (session != null) {\n\t\t\t\t\tsession.logout();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" +\n\t\t\t\t\t\t\tgroupId + \" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, portletId));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\t\tdoc.add(LuceneFields.getFile(LuceneFields.CONTENT, is, fileExt));\n\n\t\t\tif (portletId.equals(PortletKeys.DOCUMENT_LIBRARY)) {\n\t\t\t\ttry {\n\t\t\t\t\tDLFileEntry fileEntry = null;\n\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfileEntry =\n\t\t\t\t\t\t\t\tDLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\t\t\t\t\t\trepositoryId, fileName);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchFileEntryException nsfe) {\n\n\t\t\t\t\t\t\t// Indexing is spawned off to a queue. Try to get\n\t\t\t\t\t\t\t// the file entry object after waiting for 1 second\n\t\t\t\t\t\t\t// to fix a possible race condition.\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\t\tsm.append(fileEntry.getTitle());\n\t\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t\t\tsm.append(fileEntry.getDescription());\n\t\t\t\t\tsm.append(StringPool.SPACE);\n\n\t\t\t\t\tProperties extraSettingsProps =\n\t\t\t\t\t\tfileEntry.getExtraSettingsProperties();\n\n\t\t\t\t\tIterator itr =\n\t\t\t\t\t\t(Iterator)extraSettingsProps.entrySet().iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\t\t\t\tString value = GetterUtil.getString(\n\t\t\t\t\t\t\t(String)entry.getValue());\n\n\t\t\t\t\t\tsm.append(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tdoc.add(LuceneFields.getText(LuceneFields.PROPERTIES, sm));\n\t\t\t\t}\n\t\t\t\tcatch (PortalException pe) {\n\t\t\t\t\tthrow new IOException(pe.getMessage());\n\t\t\t\t}\n\t\t\t\tcatch (SystemException se) {\n\t\t\t\t\tthrow new IOException(se.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"repositoryId\", repositoryId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"path\", fileName));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\t\" indexed successfully\");\n\t\t\t}\n\t\t}\n\t}","id":3951,"modified_method":"public static void addFile(\n\t\t\tString companyId, String portletId, Long groupId,\n\t\t\tString repositoryId, String fileName)\n\t\tthrows IOException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Indexing document \" + companyId + \" \" + portletId + \" \" +\n\t\t\t\t\tgroupId + \" \" + repositoryId + \" \" + fileName);\n\t\t}\n\n\t\tString fileExt = StringPool.BLANK;\n\n\t\tint fileExtVersionPos = fileName.indexOf(DLServiceImpl.VERSION);\n\n\t\tif (fileExtVersionPos != -1) {\n\t\t\tint fileExtPos = fileName.lastIndexOf(\n\t\t\t\tStringPool.PERIOD, fileExtVersionPos);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileExtVersionPos);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint fileExtPos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileName.length());\n\t\t\t}\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = DLUtil.getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, 0);\n\n\t\t\tis = contentNode.getProperty(JCRConstants.JCR_DATA).getStream();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, portletId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getFile(LuceneFields.CONTENT, is, fileExt));\n\n\t\tif (portletId.equals(PortletKeys.DOCUMENT_LIBRARY)) {\n\t\t\ttry {\n\t\t\t\tDLFileEntry fileEntry = null;\n\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\t\t\t\trepositoryId, fileName);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileEntryException nsfe) {\n\n\t\t\t\t\t\t// Indexing is spawned off to a queue. Try to get\n\t\t\t\t\t\t// the file entry object after waiting for 1 second\n\t\t\t\t\t\t// to fix a possible race condition.\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tsm.append(fileEntry.getTitle());\n\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t\tsm.append(fileEntry.getDescription());\n\t\t\t\tsm.append(StringPool.SPACE);\n\n\t\t\t\tProperties extraSettingsProps =\n\t\t\t\t\tfileEntry.getExtraSettingsProperties();\n\n\t\t\t\tIterator itr =\n\t\t\t\t\t(Iterator)extraSettingsProps.entrySet().iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\t\t\tString value = GetterUtil.getString(\n\t\t\t\t\t\t(String)entry.getValue());\n\n\t\t\t\t\tsm.append(value);\n\t\t\t\t}\n\n\t\t\t\tdoc.add(LuceneFields.getText(LuceneFields.PROPERTIES, sm));\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tthrow new IOException(pe.getMessage());\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new IOException(se.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"repositoryId\", repositoryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"path\", fileName));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\" indexed successfully\");\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addMessage(\n\t\t\tString companyId, Long groupId, String userName,\n\t\t\tString categoryId, String threadId, String messageId, String title,\n\t\t\tString content)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tcontent = Html.stripHtml(content);\n\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(companyId);\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, messageId)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.USER_NAME, userName));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"categoryId\", categoryId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"threadId\", threadId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"messageId\", messageId));\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3952,"modified_method":"public static void addMessage(\n\t\t\tString companyId, Long groupId, String userName,\n\t\t\tString categoryId, String threadId, String messageId, String title,\n\t\t\tString content)\n\tthrows IOException {\n\n\t\tcontent = Html.stripHtml(content);\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, messageId)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.USER_NAME, userName));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, title));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"categoryId\", categoryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"threadId\", threadId));\n\t\tdoc.add(LuceneFields.getKeyword(\"messageId\", messageId));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteMessages(String companyId, String threadId)\n\t\tthrows IOException, ParseException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tBooleanQuery booleanQuery = new BooleanQuery();\n\n\t\t\tLuceneUtil.addRequiredTerm(\n\t\t\t\tbooleanQuery, LuceneFields.PORTLET_ID, PORTLET_ID);\n\n\t\t\tLuceneUtil.addRequiredTerm(booleanQuery, \"threadId\", threadId);\n\n\t\t\tSearcher searcher = LuceneUtil.getSearcher(companyId);\n\n\t\t\tHits hits = searcher.search(booleanQuery);\n\n\t\t\tif (hits.length() > 0) {\n\t\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\t\tfor (int i = 0; i < hits.length(); i++) {\n\t\t\t\t\tDocument doc = hits.doc(i);\n\n\t\t\t\t\tField field = doc.getField(LuceneFields.UID);\n\n\t\t\t\t\treader.deleteDocuments(\n\t\t\t\t\t\tnew Term(LuceneFields.UID, field.stringValue()));\n\t\t\t\t}\n\n\t\t\t\treader.close();\n\t\t\t}\n\t\t}\n\t}","id":3953,"modified_method":"public static void deleteMessages(String companyId, String threadId)\n\t\tthrows IOException, ParseException {\n\n\t\tBooleanQuery booleanQuery = new BooleanQuery();\n\n\t\tLuceneUtil.addRequiredTerm(\n\t\t\tbooleanQuery, LuceneFields.PORTLET_ID, PORTLET_ID);\n\n\t\tLuceneUtil.addRequiredTerm(booleanQuery, \"threadId\", threadId);\n\n\t\tSearcher searcher = LuceneUtil.getSearcher(companyId);\n\n\t\tHits hits = searcher.search(booleanQuery);\n\n\t\tif (hits.length() > 0) {\n\t\t\tIndexReader reader = null;\n\n\t\t\ttry {\n\t\t\t\tLuceneUtil.acquireLock(companyId);\n\n\t\t\t\treader = LuceneUtil.getReader(companyId);\n\n\t\t\t\tfor (int i = 0; i < hits.length(); i++) {\n\t\t\t\t\tDocument doc = hits.doc(i);\n\n\t\t\t\t\tField field = doc.getField(LuceneFields.UID);\n\n\t\t\t\t\treader.deleteDocuments(\n\t\t\t\t\t\tnew Term(LuceneFields.UID, field.stringValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\n\t\t\t\tLuceneUtil.releaseLock(companyId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteMessage(String companyId, String messageId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, messageId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3954,"modified_method":"public static void deleteMessage(String companyId, String messageId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, messageId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removePluginPackage(\n\t\tString moduleId, String repositoryURL)\n\t\tthrows IOException {\n\n\t\tString pluginId = repositoryURL + StringPool.SLASH + moduleId;\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(CompanyImpl.SYSTEM);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, pluginId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":3955,"modified_method":"public static void removePluginPackage(\n\t\t\tString moduleId, String repositoryURL)\n\t\tthrows IOException {\n\n\t\tString pluginId = repositoryURL + StringPool.SLASH + moduleId;\n\n\t\tsynchronized (PluginPackageIndexer.class) {\n\t\t\tIndexReader reader = null;\n\n\t\t\ttry {\n\t\t\t\treader = LuceneUtil.getReader(CompanyImpl.SYSTEM);\n\n\t\t\t\treader.deleteDocuments(\n\t\t\t\t\tnew Term(\n\t\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, pluginId)));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPluginPackage(\n\t\t\tString moduleId, String name, String version,\n\t\t\tString author, List types, List tags, List licenses,\n\t\t\tList liferayVersions, String shortDescription,\n\t\t\tString longDescription, String changeLog, String pageURL,\n\t\t\tString repositoryURL, String status, String installedVersion)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tModuleId moduleIdObj = ModuleId.getInstance(moduleId);\n\n\t\t\tshortDescription = Html.stripHtml(shortDescription);\n\t\t\tlongDescription = Html.stripHtml(longDescription);\n\n\t\t\tString content =\n\t\t\t\tname + \" \" + author + \" \" + shortDescription + \" \" +\n\t\t\t\t\tlongDescription;\n\n\t\t\tString pluginId = repositoryURL + StringPool.SLASH + moduleId;\n\n\t\t\tIndexWriter writer = _getWriter();\n\n\t\t\tDocument doc = new Document();\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, pluginId)));\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, name));\n\t\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"moduleId\", moduleId));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\"groupId\", moduleIdObj.getGroupId()));\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\t\"artifactId\", moduleIdObj.getArtifactId()));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"moduleId\", moduleId));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"version\", version));\n\t\t\tdoc.add(LuceneFields.getKeyword(\n\t\t\t\t\"shortDescription\", shortDescription));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"changeLog\", changeLog));\n\t\t\tdoc.add(LuceneFields.getKeyword(\"repositoryURL\", repositoryURL));\n\n\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\tIterator itr = types.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tString type = (String)itr.next();\n\n\t\t\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\n\t\t\t\tsm.append(type);\n\n\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\tsm.append(StringPool.COMMA + StringPool.SPACE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"types\", sm.toString()));\n\n\t\t\tsm = new StringMaker();\n\n\t\t\titr = tags.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tString tag = (String)itr.next();\n\n\t\t\t\tdoc.add(LuceneFields.getKeyword(\"tag\", tag));\n\n\t\t\t\tsm.append(tag);\n\n\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\tsm.append(StringPool.COMMA + StringPool.SPACE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"tags\", sm.toString()));\n\n\t\t\tboolean osiLicense = false;\n\n\t\t\titr = licenses.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tLicense license = (License)itr.next();\n\n\t\t\t\tdoc.add(LuceneFields.getKeyword(\"license\", license.getName()));\n\n\t\t\t\tif (license.isOsiApproved()) {\n\t\t\t\t\tosiLicense = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\t\"osi-approved-license\", String.valueOf(osiLicense)));\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"status\", status));\n\n\t\t\tif (installedVersion != null) {\n\t\t\t\tdoc.add(\n\t\t\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\t\t\"installedVersion\", installedVersion));\n\t\t\t}\n\n\t\t\twriter.addDocument(doc);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t}","id":3956,"modified_method":"public static void addPluginPackage(\n\t\t\tString moduleId, String name, String version,\n\t\t\tString author, List types, List tags, List licenses,\n\t\t\tList liferayVersions, String shortDescription,\n\t\t\tString longDescription, String changeLog, String pageURL,\n\t\t\tString repositoryURL, String status, String installedVersion)\n\t\tthrows IOException {\n\n\t\tModuleId moduleIdObj = ModuleId.getInstance(moduleId);\n\n\t\tshortDescription = Html.stripHtml(shortDescription);\n\t\tlongDescription = Html.stripHtml(longDescription);\n\n\t\tString content =\n\t\t\tname + \" \" + author + \" \" + shortDescription + \" \" +\n\t\t\t\tlongDescription;\n\n\t\tString pluginId = repositoryURL + StringPool.SLASH + moduleId;\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, pluginId)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, PORTLET_ID));\n\n\t\tdoc.add(LuceneFields.getText(LuceneFields.TITLE, name));\n\t\tdoc.add(LuceneFields.getText(LuceneFields.CONTENT, content));\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"moduleId\", moduleId));\n\t\tdoc.add(LuceneFields.getKeyword(\"groupId\", moduleIdObj.getGroupId()));\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\"artifactId\", moduleIdObj.getArtifactId()));\n\t\tdoc.add(LuceneFields.getKeyword(\"moduleId\", moduleId));\n\t\tdoc.add(LuceneFields.getKeyword(\"version\", version));\n\t\tdoc.add(LuceneFields.getKeyword(\"shortDescription\", shortDescription));\n\t\tdoc.add(LuceneFields.getKeyword(\"changeLog\", changeLog));\n\t\tdoc.add(LuceneFields.getKeyword(\"repositoryURL\", repositoryURL));\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tIterator itr = types.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tString type = (String)itr.next();\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"type\", type));\n\n\t\t\tsm.append(type);\n\n\t\t\tif (itr.hasNext()) {\n\t\t\t\tsm.append(StringPool.COMMA);\n\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(LuceneFields.getKeyword(\"types\", sm.toString()));\n\n\t\tsm = new StringMaker();\n\n\t\titr = tags.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tString tag = (String)itr.next();\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"tag\", tag));\n\n\t\t\tsm.append(tag);\n\n\t\t\tif (itr.hasNext()) {\n\t\t\t\tsm.append(StringPool.COMMA);\n\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(LuceneFields.getKeyword(\"tags\", sm.toString()));\n\n\t\tboolean osiLicense = false;\n\n\t\titr = licenses.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tLicense license = (License)itr.next();\n\n\t\t\tdoc.add(LuceneFields.getKeyword(\"license\", license.getName()));\n\n\t\t\tif (license.isOsiApproved()) {\n\t\t\t\tosiLicense = true;\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\t\"osi-approved-license\", String.valueOf(osiLicense)));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"status\", status));\n\n\t\tif (installedVersion != null) {\n\t\t\tdoc.add(\n\t\t\t\tLuceneFields.getKeyword(\"installedVersion\", installedVersion));\n\t\t}\n\n\t\tsynchronized (PluginPackageIndexer.class) {\n\t\t\tIndexWriter writer = null;\n\n\t\t\ttry {\n\t\t\t\twriter = _getWriter();\n\n\t\t\t\twriter.addDocument(doc);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\tLuceneUtil.write(writer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (m_ignoreStaticMethods) {\n        final PsiMethod aMethod =\n          PsiTreeUtil.getParentOfType(variable,\n                                      PsiMethod.class);\n        if (aMethod == null) {\n          return;\n        }\n        if (aMethod.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          registerVariableError(variable);\n        }\n      }\n    }","id":3957,"modified_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (m_ignoreStaticMethods) {\n        final PsiMember member = PsiTreeUtil.getParentOfType(variable, PsiMethod.class, PsiClassInitializer.class);\n        if (member != null && member.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldNames(variable);\n      if (aClass == null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String buildErrorString(Object... infos) {\n    return InspectionGadgetsBundle.message(\n      \"local.variable.hides.member.variable.problem.descriptor\");\n  }","id":3958,"modified_method":"@NotNull\n  public String buildErrorString(Object... infos) {\n    final PsiClass aClass = (PsiClass)infos[0];\n    return InspectionGadgetsBundle.message(\"local.variable.hides.member.variable.problem.descriptor\", aClass.getName());\n  }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      if (!(variable.getDeclarationScope() instanceof PsiCatchSection)) {\n        return;\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          registerVariableError(variable);\n        }\n      }\n    }","id":3959,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiCatchSection) && !(declarationScope instanceof PsiForeachStatement)) {\n        return;\n      }\n      if (m_ignoreStaticMethods) {\n        final PsiMember member = PsiTreeUtil.getParentOfType(variable, PsiMethod.class, PsiClassInitializer.class);\n        if (member != null && member.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldNames(variable);\n      if (aClass == null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String buildErrorString(Object... infos) {\n    return InspectionGadgetsBundle.message(\n      \"parameter.hides.member.variable.problem.descriptor\");\n  }","id":3960,"modified_method":"@NotNull\n  public String buildErrorString(Object... infos) {\n    final PsiClass aClass = (PsiClass)infos[0];\n    return InspectionGadgetsBundle.message(\"parameter.hides.member.variable.problem.descriptor\", aClass.getName());\n  }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      if (variable.getDeclarationScope() instanceof PsiCatchSection) {\n        return;\n      }\n      final PsiMethod method =\n        PsiTreeUtil.getParentOfType(variable,\n                                    PsiMethod.class);\n      if (method == null) {\n        return;\n      }\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters) {\n        final String methodName = method.getName();\n        final PsiType returnType = method.getReturnType();\n        if (methodName.startsWith(HardcodedMethodConstants.SET) &&\n            PsiType.VOID.equals(returnType)) {\n          return;\n        }\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          if (m_ignoreStaticMethodParametersHidingInstanceFields &&\n              !field.hasModifierProperty(PsiModifier.STATIC) &&\n              method.hasModifierProperty(PsiModifier.STATIC)) {\n            continue;\n          }\n          registerVariableError(variable);\n        }\n      }\n    }","id":3961,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)declarationScope;\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass != null && containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters) {\n        final String methodName = method.getName();\n        final PsiType returnType = method.getReturnType();\n        if (methodName.startsWith(HardcodedMethodConstants.SET) && PsiType.VOID.equals(returnType)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldName(variable, method);\n      if (aClass ==  null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":3962,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"9f699f9717bd9e99b1a0bc8a29b55289c97b8279","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":3963,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"7ca5ad548f4feeb10e467cd90d3253b5aa51cd41","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":3964,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"0d2b5c4503f6626a80407dda96195a4ec7b8fe8d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method builds a complete menu navigation with entries of all branches \n     * from the specified folder.<p>\n     * \n     * @param curNav the List of current navigation elements\n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @param prefix the prefix to generate the unique menu node id.\n     * @param currentDepth the depth of the current submenu\n     * @return the HTML to generate menu entries\n     */\n    public StringBuffer getMenuNavigation(List curNav, String styleClass, String prefix, int currentDepth) {\n\n        StringBuffer result = new StringBuffer(64);\n        String showItemProperty;\n\n        int navSize = curNav.size();\n        if (navSize > 0) {\n            // at least one navigation entry present, create menu\n            Map subNav = new HashMap();\n            boolean entryPresent = false;\n            // loop through all nav entries\n            for (int i = 0; i < navSize; i++) {\n                CmsJspNavElement ne = (CmsJspNavElement)curNav.get(i);\n                String resName = ne.getResourceName();\n                showItemProperty = property(PROPERTY_HEADNAV_USE, resName, getHeadNavItemDefaultStringValue());\n                boolean showEntry = Boolean.valueOf(showItemProperty).booleanValue();\n                if (showEntry) {\n                    entryPresent = true;\n                    List navEntries = new ArrayList();\n                    // check if entry is folder and depth smaller than maximum depth -> if so, get the navigation from this folder as well\n                    if (ne.isFolderLink() && currentDepth < getMenuDepth()) {\n                        navEntries = getNavigation().getNavigationForFolder(resName);\n                    }\n                    result.append(\" <a class=\\\"\");\n                    result.append(\"mI\");\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(resName));\n                    result.append(\"\\\"\");\n                    if (ne.isFolderLink() && hasSubMenuEntries(navEntries)) {\n                        // sub menu(s) present, create special entry\n                        result.append(\" onmouseover=\\\"menuItemMouseover(event, '\");\n                        result.append(prefix);\n                        result.append(\"_\");\n                        result.append(resName.hashCode());\n                        result.append(\"');\\\">\");\n                        result.append(\"<span class=\\\"mIText\\\">\");\n                        result.append(ne.getNavText());\n                        result.append(\"<\/span><span class=\\\"mIArrow\\\">&#9654;<\/span><\/a>\");\n                        // add current entry to temporary Map to create the sub menus\n                        subNav.put(resName, navEntries);\n                    } else {\n                        // no sub menu present, create common menu entry\n                        result.append(\">\");\n                        result.append(ne.getNavText());\n                        result.append(\"<\/a>\");\n                    }\n                }\n            }\n            result.append(\"<\/div>\\n\");\n\n            StringBuffer openTag = new StringBuffer(8);\n            if (\"menu0\".equals(prefix) && showAccessibleVersion()) {\n                // create div that is displayed for accessible version\n                CmsMessages messages = new CmsMessages(\n                    CmsTemplateBean.MESSAGE_BUNDLE,\n                    getRequestContext().getLocale());\n                openTag.append(\"<div style=\\\"visibility: hidden; display:none;\\\">\");\n                openTag.append(\"<h3>\").append(messages.key(\"headline.accessible.nav.headline\")).append(\"<\/h3>\");\n                openTag.append(\"<p>\").append(messages.key(\"headline.accessible.nav.text\")).append(\"<\/p>\");\n                openTag.append(\"<\/div>\");\n            }\n            if (entryPresent) {\n                openTag.append(\"<div class=\\\"\");\n                openTag.append(styleClass);\n                openTag.append(\"\\\" id=\\\"\");\n                openTag.append(prefix);\n                openTag.append(\"\\\" onmouseover=\\\"menuMouseover(event);\\\">\");\n            } else {\n                openTag.append(\"<div style=\\\"visibility: hidden;\\\" id=\\\"\");\n                openTag.append(prefix);\n                openTag.append(\"\\\">\");\n            }\n            result.insert(0, openTag);\n\n            // add the sub menus recursively from temporary Map\n            Iterator i = subNav.keySet().iterator();\n            while (i.hasNext()) {\n                String resName = (String)i.next();\n                List navEntries = (List)subNav.get(resName);\n                result.append(getMenuNavigation(\n                    navEntries,\n                    styleClass,\n                    prefix + \"_\" + resName.hashCode(),\n                    currentDepth + 1));\n            }\n        }\n        return result;\n    }","id":3965,"modified_method":"/**\n     * This method builds a complete menu navigation with entries of all branches \n     * from the specified folder.<p>\n     * \n     * @param curNav the List of current navigation elements\n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @param prefix the prefix to generate the unique menu node id.\n     * @param currentDepth the depth of the current submenu\n     * @param menuIndexes String representing the menu indexes in the manual XML configuration, if null, no manual configuration is used\n     * @return the HTML to generate menu entries\n     */\n    public StringBuffer getMenuNavigation(List curNav, String styleClass, String prefix, int currentDepth, String menuIndexes) {\n\n        StringBuffer result = new StringBuffer(64);\n        String showItemProperty;\n\n        int navSize = curNav.size();\n        if (navSize > 0) {\n            // at least one navigation entry present, create menu\n            Map subNav = new HashMap();\n            Map subIndex = new HashMap();\n            boolean entryPresent = false;\n            boolean manualConfig = CmsStringUtil.isNotEmpty(menuIndexes);\n            // loop through all nav entries\n            for (int i = 0; i < navSize; i++) {\n                CmsJspNavElement ne = (CmsJspNavElement)curNav.get(i);\n                String resName = ne.getResourceName();\n                String link = resName;\n                if (link.startsWith(\"/\")) {\n                    link = link(link);\n                }\n                showItemProperty = property(PROPERTY_HEADNAV_USE, resName, getHeadNavItemDefaultStringValue());\n                boolean showEntry = manualConfig || Boolean.valueOf(showItemProperty).booleanValue();\n                if (showEntry) {\n                    entryPresent = true;\n                    List navEntries = new ArrayList();\n                    // check if is depth smaller than maximum depth -> if so, get the navigation from this folder as well\n                    if (currentDepth < getMenuDepth()) {\n                        if (manualConfig) {\n                            // manual configuration, get nav entries from XML configuration file\n                            navEntries = getHeadNavItemsFromConfig(currentDepth + 1, menuIndexes + String.valueOf(i));\n                        } else if (ne.isFolderLink()) {\n                            // entry is folder, get sub navigation\n                            navEntries = getNavigation().getNavigationForFolder(resName);\n                        }\n                        \n                    }\n                    \n                    String target = ne.getInfo();\n                    if (CmsStringUtil.isEmpty(target)) {\n                        target = \"_self\";\n                    }\n                    result.append(\" <a class=\\\"mI\\\" href=\\\"\");\n                    result.append(link);\n                    result.append(\"\\\"\");\n                    result.append(\"\\\" target=\\\"\");\n                    result.append(target);\n                    result.append(\"\\\"\");\n                    if ((ne.isFolderLink() && hasSubMenuEntries(navEntries)) || (manualConfig && navEntries.size() > 0)) {\n                        // sub menu(s) present, create special entry\n                        result.append(\" onmouseover=\\\"menuItemMouseover(event, '\");\n                        result.append(prefix);\n                        result.append(\"_\");\n                        result.append(resName.hashCode());\n                        result.append(\"');\\\">\");\n                        result.append(\"<span class=\\\"mIText\\\">\");\n                        result.append(ne.getNavText());\n                        result.append(\"<\/span><span class=\\\"mIArrow\\\">&#9654;<\/span><\/a>\");\n                        // add current entry to temporary Map to create the sub menus\n                        subNav.put(resName, navEntries);\n                        if (manualConfig) {\n                            // for manual configuration, additional information for the xpath is needed for the sub menus\n                            subIndex.put(resName, menuIndexes + String.valueOf(i));\n                        }\n                    } else {\n                        // no sub menu present, create common menu entry\n                        result.append(\">\");\n                        result.append(ne.getNavText());\n                        result.append(\"<\/a>\");\n                    }\n                }\n            }\n            result.append(\"<\/div>\\n\");\n\n            StringBuffer openTag = new StringBuffer(8);\n            if (\"menu0\".equals(prefix) && showAccessibleVersion()) {\n                // create div that is displayed for accessible version\n                CmsMessages messages = new CmsMessages(\n                    CmsTemplateBean.MESSAGE_BUNDLE,\n                    getRequestContext().getLocale());\n                openTag.append(\"<div style=\\\"visibility: hidden; display:none;\\\">\");\n                openTag.append(\"<h3>\").append(messages.key(\"headline.accessible.nav.headline\")).append(\"<\/h3>\");\n                openTag.append(\"<p>\").append(messages.key(\"headline.accessible.nav.text\")).append(\"<\/p>\");\n                openTag.append(\"<\/div>\");\n            }\n            if (entryPresent) {\n                openTag.append(\"<div class=\\\"\");\n                openTag.append(styleClass);\n                openTag.append(\"\\\" id=\\\"\");\n                openTag.append(prefix);\n                openTag.append(\"\\\" onmouseover=\\\"menuMouseover(event);\\\">\");\n            } else {\n                openTag.append(\"<div style=\\\"visibility: hidden;\\\" id=\\\"\");\n                openTag.append(prefix);\n                openTag.append(\"\\\">\");\n            }\n            result.insert(0, openTag);\n\n            // add the sub menus recursively from temporary Map\n            Iterator i = subNav.keySet().iterator();\n            while (i.hasNext()) {\n                String resName = (String)i.next();\n                List navEntries = (List)subNav.get(resName);\n                String newIndex = menuIndexes;\n                if (manualConfig) {\n                    // get the xpath information to build the submenus from the XML configuration\n                    newIndex = (String)subIndex.get(resName);\n                }\n                result.append(getMenuNavigation(\n                    navEntries,\n                    styleClass,\n                    prefix + \"_\" + resName.hashCode(),\n                    currentDepth + 1,\n                    newIndex));\n            }\n        }\n        return result;\n    }","commit_id":"f6b029bf132e4b2f69ed7460186565e2fb999cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n\n        boolean firstItem = true;\n        StringBuffer result = new StringBuffer(1024);\n        result.append(\"<div class=\\\"\");\n        result.append(styleLink);\n        result.append(\"\\\">\\n\");\n        result.append(\"\\t<!-- Start Topnavigation -->\\n\");\n\n        List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n        boolean showHomeLink = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.show\", \"true\")).booleanValue();\n        if (showHomeLink && !showHeadNavImages()) {\n            // create the \"home\" link at first position\n            boolean onlyIndex = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.onlyindex\", \"false\")).booleanValue();\n            String url = getStartFolder();\n            String target = \"_self\";\n            if ((onlyIndex && isDefaultFile(getStartFolder(), getRequestContext().getUri())) || (! onlyIndex)) {\n                // settings only valid for start page of microsite or for all subpages\n                url = getConfigurationValue(\"headnav.homelink/link.url\", getStartFolder());\n                homeLabel = getConfigurationValue(\"headnav.homelink/link.text\", homeLabel);\n                target = getConfigurationValue(\"headnav.homelink/link.target\", \"_self\");\n            }\n            \n            if (url.startsWith(\"/\")) {\n                // internal link\n                url = link(url);\n            }\n            homeLabel = homeLabel.toUpperCase();\n\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(url);\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\" target=\\\"\");\n            result.append(target);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            firstItem = false;\n        } else {\n            // create a table to allow vertical alignment of images\n            result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\"><tr>\");\n        }\n\n        int count = -1;\n        String showItemProperty;\n        for (int i = 0; i < navElements.size(); i++) {\n            CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n            showItemProperty = property(\n                PROPERTY_HEADNAV_USE,\n                nav.getResourceName(),\n                getHeadNavItemDefaultStringValue());\n            boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n            if (nav.isFolderLink() && showItem) {\n                // create an entry for every folder\n                count++;\n                String navText = CmsEncoder.escapeXml(nav.getNavText().toUpperCase());\n                if (showHeadNavImages()) {\n                    // build row with images\n                    result.append(\"<td style= \\\"vertical-align: middle\\\">\");\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    result.append(\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(\"<img src=\\\"\");\n                    result.append(link(nav.getNavImage()));\n                    result.append(\"\\\" border=\\\"0\\\" alt=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\">\");\n                    result.append(\"<\/a><\/td>\\n\");\n                } else {\n                    // build row with text links\n                    if (!firstItem) {\n                        result.append(\"<span class=\\\"\");\n                        result.append(styleSeparator);\n                        result.append(\"\\\">|<\/span>\\n\");\n                    }\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    if (getHeadNavMarkCurrent() && getRequestContext().getUri().startsWith(nav.getResourceName())) {\n                        // mark currently active top folder with bold font\n                        result.append(\" style=\\\"font-weight: bold;\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");\n                }\n                firstItem = false;\n            }\n        }\n\n        if (showHeadNavImages()) {\n            // close table\n            result.append(\"<\/tr><\/table>\");\n        }\n\n        result.append(\"\\t<!-- End Topnavigation -->\\n\");\n        result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","id":3966,"modified_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n\n        boolean firstItem = true;\n        StringBuffer result = new StringBuffer(1024);\n        result.append(\"<div class=\\\"\");\n        result.append(styleLink);\n        result.append(\"\\\">\\n\");\n        result.append(\"\\t<!-- Start Topnavigation -->\\n\");\n        \n        boolean showHomeLink = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.show\", \"true\")).booleanValue();\n        if (showHomeLink && !showHeadNavImages()) {\n            // create the \"home\" link at first position\n            boolean onlyIndex = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.onlyindex\", \"false\")).booleanValue();\n            String url = getStartFolder();\n            String target = \"_self\";\n            if ((onlyIndex && isDefaultFile(getStartFolder(), getRequestContext().getUri())) || (! onlyIndex)) {\n                // settings only valid for start page of microsite or for all subpages\n                url = getConfigurationValue(\"headnav.homelink/link.url\", getStartFolder());\n                homeLabel = getConfigurationValue(\"headnav.homelink/link.text\", homeLabel);\n                target = getConfigurationValue(\"headnav.homelink/link.target\", \"_self\");\n            }\n            \n            if (url.startsWith(\"/\")) {\n                // internal link\n                url = link(url);\n            }\n            homeLabel = homeLabel.toUpperCase();\n\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(url);\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\" target=\\\"\");\n            result.append(target);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            firstItem = false;\n        } else {\n            // create a table to allow vertical alignment of images\n            result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\"><tr>\");\n        }\n\n        int count = -1;\n        String showItemProperty;\n        \n        // check if head navigation has to be created manually from config file\n        boolean manualHeadConfig = isHeadNavManual();\n        \n        List navElements = new ArrayList();\n        if (manualHeadConfig) {\n            // manual configuration, get List of nav items from config file\n            navElements = getHeadNavItemsFromConfig(0, \"0\");\n        } else {\n            // automatic, get folder navigation\n            navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n        }\n        for (int i = 0; i < navElements.size(); i++) {\n            CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n            String link = nav.getResourceName();\n            if (link.startsWith(\"/\")) {\n                link = link(link);\n            }\n            showItemProperty = property(\n                PROPERTY_HEADNAV_USE,\n                nav.getResourceName(),\n                getHeadNavItemDefaultStringValue());\n            boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n            if (manualHeadConfig || (nav.isFolderLink() && showItem)) {\n                // create an entry for every folder\n                count++;\n                String navText = CmsEncoder.escapeXml(nav.getNavText().toUpperCase());\n                String target = nav.getInfo();\n                if (CmsStringUtil.isEmpty(target)) {\n                    target = \"_self\";\n                }\n                if (showHeadNavImages()) {\n                    // build row with images\n                    result.append(\"<td style= \\\"vertical-align: middle\\\">\");\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    result.append(\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link);\n                    result.append(\"\\\" target=\\\"\");\n                    result.append(target);\n                    result.append(\"\\\">\");\n                    result.append(\"<img src=\\\"\");\n                    result.append(link(nav.getNavImage()));\n                    result.append(\"\\\" border=\\\"0\\\" alt=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\">\");\n                    result.append(\"<\/a><\/td>\\n\");\n                } else {\n                    // build row with text links\n                    if (!firstItem) {\n                        result.append(\"<span class=\\\"\");\n                        result.append(styleSeparator);\n                        result.append(\"\\\">|<\/span>\\n\");\n                    }\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    if (getHeadNavMarkCurrent() && getRequestContext().getUri().startsWith(nav.getResourceName())) {\n                        // mark currently active top folder with bold font\n                        result.append(\" style=\\\"font-weight: bold;\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link);\n                    result.append(\"\\\" target=\\\"\");\n                    result.append(target);\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");\n                }\n                firstItem = false;\n            }\n        }\n\n        if (showHeadNavImages()) {\n            // close table\n            result.append(\"<\/tr><\/table>\");\n        }\n\n        result.append(\"\\t<!-- End Topnavigation -->\\n\");\n        result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","commit_id":"f6b029bf132e4b2f69ed7460186565e2fb999cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n\n        CmsTemplateParts parts = null;\n        boolean cacheNavEnabled = !getRequestContext().currentProject().isOnlineProject();\n        String cacheKey = null;\n        if (cacheNavEnabled) {\n            // cache naviagtion in offline project to avoid performance issues\n            parts = CmsTemplateParts.getInstance(this);\n            // create unique cache key with: site, head nav folder, area folder, menu depth, show submenus flag\n            StringBuffer key = new StringBuffer(8);\n            key.append(getRequestContext().getSiteRoot());\n            key.append(\"_\");\n            key.append(getHeadNavFolder().hashCode());\n            key.append(\"_\");\n            key.append(getStartFolder().hashCode());\n            key.append(\"_\");\n            key.append(getMenuDepth());\n            key.append(\"_\");\n            key.append(showMenus());\n            key.append(\"_\");\n            key.append(showAccessibleVersion());\n            key.append(\"_\");\n            key.append(getLocale());\n            cacheKey = key.toString();\n            String cachedNav = (String)parts.getPart(cacheKey);\n            if (CmsStringUtil.isNotEmpty(cachedNav)) {\n                // found previously cached navigation menu structure, return it\n                return cachedNav;\n            }\n        }\n\n        StringBuffer result = new StringBuffer(4096);\n\n        if (showMenus()) {\n            // only create navigation if the template is configured to show it\n            List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n\n            int count = -1;\n            String showItemProperty;\n            for (int i = 0; i < navElements.size(); i++) {\n                CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n                showItemProperty = property(\n                    PROPERTY_HEADNAV_USE,\n                    foldernav.getResourceName(),\n                    getHeadNavItemDefaultStringValue());\n                boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n                if (foldernav.isFolderLink() && showItem) {\n                    // create a menu entry for every found folder\n                    count++;\n                    String subfolder = foldernav.getResourceName();\n\n                    // get all navigation elements of the sub folder\n                    List subNav = getNavigation().getNavigationForFolder(subfolder);\n                    result.append(getMenuNavigation(subNav, styleClass, \"menu\" + count, 1));\n                }\n            }\n\n            if (cacheNavEnabled) {\n                // cache the generated navigation submenu output\n                parts.setPart(cacheKey, result.toString());\n            }\n        }\n        return result.toString();\n    }","id":3967,"modified_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n\n        CmsTemplateParts parts = null;\n        boolean cacheNavEnabled = !getRequestContext().currentProject().isOnlineProject();\n        String cacheKey = null;\n        if (cacheNavEnabled) {\n            // cache naviagtion in offline project to avoid performance issues\n            parts = CmsTemplateParts.getInstance(this);\n            // create unique cache key with: site, head nav folder, area folder, menu depth, show submenus flag\n            StringBuffer key = new StringBuffer(8);\n            key.append(getRequestContext().getSiteRoot());\n            key.append(\"_\");\n            key.append(getHeadNavFolder().hashCode());\n            key.append(\"_\");\n            key.append(getStartFolder().hashCode());\n            key.append(\"_\");\n            key.append(getMenuDepth());\n            key.append(\"_\");\n            key.append(showMenus());\n            key.append(\"_\");\n            key.append(showAccessibleVersion());\n            key.append(\"_\");\n            key.append(getLocale());\n            if (isHeadNavManual()) {\n                // for manual head nav configuration, append config path to cache key\n                key.append(\"_\");\n                key.append(getConfigPath().hashCode());\n            }\n            cacheKey = key.toString();\n            String cachedNav = (String)parts.getPart(cacheKey);\n            if (CmsStringUtil.isNotEmpty(cachedNav)) {\n                // found previously cached navigation menu structure, return it\n                return cachedNav;\n            }\n        }\n\n        StringBuffer result = new StringBuffer(4096);\n\n        if (showMenus()) {\n            // only create navigation if the template is configured to show it\n            \n            // check if head navigation has to be created manually from config file\n            boolean manualHeadConfig = isHeadNavManual();\n            \n            List navElements = new ArrayList();\n            if (manualHeadConfig) {\n                // manual configuration, get List of nav items from config file\n                navElements = getHeadNavItemsFromConfig(0, \"0\");\n            } else {\n                // automatic, get folder navigation\n                navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n            }\n\n            int count = -1;\n            String showItemProperty;\n            for (int i = 0; i < navElements.size(); i++) {\n                CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n                showItemProperty = property(\n                    PROPERTY_HEADNAV_USE,\n                    foldernav.getResourceName(),\n                    getHeadNavItemDefaultStringValue());\n                boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n                if (manualHeadConfig || (foldernav.isFolderLink() && showItem)) {\n                    // create a menu entry for every found folder\n                    count++;\n                    String subfolder = foldernav.getResourceName();\n                    \n                    List subNav = new ArrayList();\n                    String menuIndexes = null;\n                    if (manualHeadConfig) {\n                        menuIndexes = String.valueOf(i);\n                        subNav = getHeadNavItemsFromConfig(1, menuIndexes);\n                    } else {\n                        // get all navigation elements of the sub folder\n                        subNav = getNavigation().getNavigationForFolder(subfolder);\n                    }\n                    result.append(getMenuNavigation(subNav, styleClass, \"menu\" + count, 1, menuIndexes));\n                }\n            }\n\n            if (cacheNavEnabled) {\n                // cache the generated navigation submenu output\n                parts.setPart(cacheKey, result.toString());\n            }\n        }\n        return result.toString();\n    }","commit_id":"f6b029bf132e4b2f69ed7460186565e2fb999cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\r\n\tpublic void failed (Throwable t) {\r\n\t\ttextButton.setDisabled(false);\r\n\t\ttextButton.setTouchable(Touchable.enabled);\r\n\t\ttextButtonTxt.setDisabled(false);\r\n\t\ttextButtonTxt.setTouchable(Touchable.enabled);\r\n\t\tstatusLabel.setText(\"Failed to perform the HTTP Request: \" + t.getMessage());\r\n\t\tt.printStackTrace();\r\n\t}","id":3968,"modified_method":"@Override\r\n\tpublic void failed (Throwable t) {\r\n\t\tsetButtonDisabled(false);\r\n\t\tstatusLabel.setText(\"Failed to perform the HTTP Request: \" + t.getMessage());\r\n\t\tt.printStackTrace();\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create () {\r\n\t\tbatch = new SpriteBatch();\r\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\r\n\t\tfont = new BitmapFont();\r\n\t\tstage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);\r\n\t\tGdx.input.setInputProcessor(stage);\r\n\r\n\t\t{\r\n\t\t\tstatusLabel = new Label(\"\", skin);\r\n\t\t\tstatusLabel.setWrap(true);\r\n\t\t\tstatusLabel.setWidth(Gdx.graphics.getWidth() * 0.96f);\r\n\t\t\tstatusLabel.setAlignment(Align.center);\r\n\t\t\tstatusLabel.setPosition(Gdx.graphics.getWidth() * 0.5f - statusLabel.getWidth() * 0.5f, 30f);\r\n\t\t\tstatusLabel.setColor(Color.CYAN);\r\n\t\t\tstage.addActor(statusLabel);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tClickListener clickListener = new ClickListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void clicked (InputEvent event, float x, float y) {\r\n\t\t\t\t\tsuper.clicked(event, x, y);\r\n\r\n\t\t\t\t\tdoImageDownload = event.getListenerActor() == textButton;\r\n\r\n\t\t\t\t\ttextButton.setDisabled(true);\r\n\t\t\t\t\ttextButton.setTouchable(Touchable.disabled);\r\n\r\n\t\t\t\t\ttextButtonTxt.setDisabled(true);\r\n\t\t\t\t\ttextButtonTxt.setTouchable(Touchable.disabled);\r\n\r\n\t\t\t\t\tif (texture != null) texture.dispose();\r\n\t\t\t\t\ttexture = null;\r\n\t\t\t\t\ttext = null;\r\n\r\n\t\t\t\t\tHttpRequest httpRequest = new HttpRequest(Net.HttpMethods.GET);\r\n\t\t\t\t\tif (doImageDownload)\r\n\t\t\t\t\t\thttpRequest.setUrl(\"http://i.imgur.com/vxomF.jpg\");\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\thttpRequest.setUrl(\"http://www.apache.org/licenses/LICENSE-2.0.txt\");\r\n\r\n\t\t\t\t\tGdx.net.sendHttpRequest(httpRequest, NetAPITest.this);\r\n\r\n\t\t\t\t\tstatusLabel.setText(\"Downloading data from \" + httpRequest.getUrl());\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\ttextButton = new TextButton(\"Download image\", skin);\r\n\t\t\ttextButton.setPosition(Gdx.graphics.getWidth() * 0.5f - textButton.getWidth(), 60f);\r\n\t\t\ttextButton.addListener(clickListener);\r\n\t\t\tstage.addActor(textButton);\r\n\r\n\t\t\ttextButtonTxt = new TextButton(\"Download text\", skin);\r\n\t\t\ttextButtonTxt.setPosition(Gdx.graphics.getWidth() * 0.5f, 60f);\r\n\t\t\ttextButtonTxt.addListener(clickListener);\r\n\t\t\tstage.addActor(textButtonTxt);\r\n\t\t}\r\n\r\n\t}","id":3969,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\tbatch = new SpriteBatch();\r\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\r\n\t\tfont = new BitmapFont();\r\n\t\tstage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);\r\n\t\tGdx.input.setInputProcessor(stage);\r\n\r\n\t\t{\r\n\t\t\tstatusLabel = new Label(\"\", skin);\r\n\t\t\tstatusLabel.setWrap(true);\r\n\t\t\tstatusLabel.setWidth(Gdx.graphics.getWidth() * 0.96f);\r\n\t\t\tstatusLabel.setAlignment(Align.center);\r\n\t\t\tstatusLabel.setPosition(Gdx.graphics.getWidth() * 0.5f - statusLabel.getWidth() * 0.5f, 30f);\r\n\t\t\tstatusLabel.setColor(Color.CYAN);\r\n\t\t\tstage.addActor(statusLabel);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tClickListener clickListener = new ClickListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void clicked (InputEvent event, float x, float y) {\r\n\t\t\t\t\tsuper.clicked(event, x, y);\r\n\r\n\t\t\t\t\tclickedButton = event.getListenerActor();\r\n\t\t\t\t\tsetButtonDisabled(true);\r\n\t\t\t\t\tif (texture != null) texture.dispose();\r\n\t\t\t\t\ttexture = null;\r\n\t\t\t\t\ttext = null;\r\n\r\n\t\t\t\t\tString url;\r\n\t\t\t\t\tString httpMethod = Net.HttpMethods.GET;\r\n\t\t\t\t\tString requestContent = null;\r\n\t\t\t\t\tif (clickedButton == btnDownloadImage)\r\n\t\t\t\t\t\turl = \"http://i.imgur.com/vxomF.jpg\";\r\n\t\t\t\t\telse if (clickedButton == btnDownloadText)\r\n\t\t\t\t\t\turl = \"http://www.apache.org/licenses/LICENSE-2.0.txt\";\r\n\t\t\t\t\telse if (clickedButton == btnDownloadError)\r\n\t\t\t\t\t\turl = \"http://www.badlogicgames.com/doesnotexist\";\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\turl = \"http://posttestserver.com/post.php?dump\";\r\n\t\t\t\t\t\thttpMethod = Net.HttpMethods.POST;\r\n\t\t\t\t\t\trequestContent = \"name1=value1&name2=value2\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tHttpRequest httpRequest = new HttpRequest(httpMethod);\r\n\t\t\t\t\thttpRequest.setUrl(url);\r\n\t\t\t\t\thttpRequest.setContent(requestContent);\r\n\t\t\t\t\tGdx.net.sendHttpRequest(httpRequest, NetAPITest.this);\r\n\r\n\t\t\t\t\tstatusLabel.setText(\"Downloading data from \" + httpRequest.getUrl());\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tbtnDownloadImage = new TextButton(\"GET Image\", skin);\r\n\t\t\tbtnDownloadImage.setPosition(Gdx.graphics.getWidth() * 0.5f - btnDownloadImage.getWidth() * 1.5f, 60f);\r\n\t\t\tbtnDownloadImage.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadImage);\r\n\r\n\t\t\tbtnDownloadText = new TextButton(\"GET Text\", skin);\r\n\t\t\tbtnDownloadText.setPosition(btnDownloadImage.getX() + btnDownloadImage.getWidth() + 10, 60f);\r\n\t\t\tbtnDownloadText.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadText);\r\n\r\n\t\t\tbtnDownloadError = new TextButton(\"GET Error\", skin);\r\n\t\t\tbtnDownloadError.setPosition(btnDownloadText.getX() + btnDownloadText.getWidth() + 10, 60f);\r\n\t\t\tbtnDownloadError.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadError);\r\n\r\n\t\t\tbtnPost = new TextButton(\"POST\", skin);\r\n\t\t\tbtnPost.setPosition(btnDownloadError.getX() + btnDownloadError.getWidth() + 10, 60f);\r\n\t\t\tbtnPost.addListener(clickListener);\r\n\t\t\tstage.addActor(btnPost);\r\n\t\t}\r\n\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void handleHttpResponse (HttpResponse httpResponse) {\r\n\r\n\t\tfinal int statusCode = httpResponse.getStatus().getStatusCode();\r\n\t\t// We are not in main thread right now so we need to post to main thread for ui updates\r\n\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run () {\r\n\t\t\t\tstatusLabel.setText(\"HTTP Request status: \" + statusCode);\r\n\t\t\t\ttextButton.setDisabled(false);\r\n\t\t\t\ttextButton.setTouchable(Touchable.enabled);\r\n\t\t\t\ttextButtonTxt.setDisabled(false);\r\n\t\t\t\ttextButtonTxt.setTouchable(Touchable.enabled);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (statusCode != 200) {\r\n\t\t\tGdx.app.log(\"NetAPITest\", \"An error ocurred since statusCode is not OK\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (doImageDownload) {\r\n\t\t\tfinal byte[] rawImageBytes = httpResponse.getResult();\r\n\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\tTexture.setEnforcePotImages(false);\r\n\t\t\t\t\tPixmap pixmap = new Pixmap(rawImageBytes, 0, rawImageBytes.length);\r\n\t\t\t\t\ttexture = new Texture(pixmap);\r\n\t\t\t\t\tTexture.setEnforcePotImages(true);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tfinal String newText = httpResponse.getResultAsString();\r\n\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\ttext = newText;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}","id":3970,"modified_method":"@Override\r\n\tpublic void handleHttpResponse (HttpResponse httpResponse) {\r\n\r\n\t\tfinal int statusCode = httpResponse.getStatus().getStatusCode();\r\n\t\t// We are not in main thread right now so we need to post to main thread for ui updates\r\n\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run () {\r\n\t\t\t\tstatusLabel.setText(\"HTTP Request status: \" + statusCode);\r\n\t\t\t\tsetButtonDisabled(false);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (statusCode != 200) {\r\n\t\t\tGdx.app.log(\"NetAPITest\", \"An error ocurred since statusCode is not OK\");\r\n\t\t\tsetText(httpResponse);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (clickedButton == btnDownloadImage) {\r\n\t\t\tfinal byte[] rawImageBytes = httpResponse.getResult();\r\n\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\tTexture.setEnforcePotImages(false);\r\n\t\t\t\t\tPixmap pixmap = new Pixmap(rawImageBytes, 0, rawImageBytes.length);\r\n\t\t\t\t\ttexture = new Texture(pixmap);\r\n\t\t\t\t\tTexture.setEnforcePotImages(true);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tsetText(httpResponse);\r\n\t\t}\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic byte[] getResult () {\r\n\t\t\ttry {\r\n\t\t\t\treturn StreamUtils.copyStreamToByteArray(inputStream, connection.getContentLength());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn StreamUtils.EMPTY_BYTES;\r\n\t\t\t}\r\n\t\t}","id":3971,"modified_method":"@Override\r\n\t\tpublic byte[] getResult () {\r\n\t\t\ttry {\r\n\t\t\t\treturn StreamUtils.copyStreamToByteArray(getInputStream(), connection.getContentLength());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn StreamUtils.EMPTY_BYTES;\r\n\t\t\t}\r\n\t\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public HttpClientResponse (HttpURLConnection connection) throws IOException {\r\n\t\t\tthis.connection = connection;\r\n\t\t\ttry {\r\n\t\t\t\tthis.inputStream = connection.getInputStream();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthis.inputStream = connection.getErrorStream();\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\t\t\t\tthis.status = new HttpStatus(connection.getResponseCode());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthis.status = new HttpStatus(-1);\r\n\t\t\t}\r\n\t\t}","id":3972,"modified_method":"public HttpClientResponse (HttpURLConnection connection) throws IOException {\r\n\t\t\tthis.connection = connection;\r\n\t\t\ttry {\r\n\t\t\t\tthis.status = new HttpStatus(connection.getResponseCode());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthis.status = new HttpStatus(-1);\r\n\t\t\t}\r\n\t\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void sendHttpRequest (final HttpRequest httpRequest, final HttpResponseListener httpResponseListener) {\r\n\t\tif (httpRequest.getUrl() == null) {\r\n\t\t\thttpResponseListener.failed(new GdxRuntimeException(\"can't process a HTTP request without URL set\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tfinal String method = httpRequest.getMethod();\r\n\r\n\t\t\tURL url;\r\n\r\n\t\t\tif (method.equalsIgnoreCase(HttpMethods.GET)) {\r\n\t\t\t\tString queryString = \"\";\r\n\t\t\t\tString value = httpRequest.getContent();\r\n\t\t\t\tif (value != null && !\"\".equals(value)) queryString = \"?\" + value;\r\n\t\t\t\turl = new URL(httpRequest.getUrl() + queryString);\r\n\t\t\t} else {\r\n\t\t\t\turl = new URL(httpRequest.getUrl());\r\n\t\t\t}\r\n\r\n\t\t\tfinal HttpURLConnection connection = (HttpURLConnection)url.openConnection();\r\n\t\t\t// should be enabled to upload data.\r\n\t\t\tfinal boolean doingOutPut = method.equalsIgnoreCase(HttpMethods.POST) || method.equalsIgnoreCase(HttpMethods.PUT);\r\n\t\t\tconnection.setDoOutput(doingOutPut);\r\n\t\t\tconnection.setDoInput(true);\r\n\t\t\tconnection.setRequestMethod(method);\r\n\r\n\t\t\t// Headers get set regardless of the method\r\n\t\t\tfor (Map.Entry<String, String> header : httpRequest.getHeaders().entrySet())\r\n\t\t\t\tconnection.addRequestProperty(header.getKey(), header.getValue());\r\n\r\n\t\t\t// Set Timeouts\r\n\t\t\tconnection.setConnectTimeout(httpRequest.getTimeOut());\r\n\t\t\tconnection.setReadTimeout(httpRequest.getTimeOut());\r\n\r\n\t\t\texecutorService.submit(new Runnable() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\t// Set the content for POST and PUT (GET has the information embedded in the URL)\r\n\t\t\t\t\t\tif (doingOutPut) {\r\n\t\t\t\t\t\t\t// we probably need to use the content as stream here instead of using it as a string.\r\n\t\t\t\t\t\t\tString contentAsString = httpRequest.getContent();\r\n\t\t\t\t\t\t\tInputStream contentAsStream = httpRequest.getContentStream();\r\n\r\n\t\t\t\t\t\t\tOutputStream outputStream = connection.getOutputStream();\r\n\t\t\t\t\t\t\tif (contentAsString != null) {\r\n\t\t\t\t\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(outputStream);\r\n\t\t\t\t\t\t\t\twriter.write(contentAsString);\r\n\t\t\t\t\t\t\t\twriter.flush();\r\n\t\t\t\t\t\t\t\twriter.close();\r\n\t\t\t\t\t\t\t} else if (contentAsStream != null) {\r\n\t\t\t\t\t\t\t\tStreamUtils.copyStream(contentAsStream, outputStream);\r\n\t\t\t\t\t\t\t\toutputStream.flush();\r\n\t\t\t\t\t\t\t\toutputStream.close();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconnection.connect();\r\n\r\n\t\t\t\t\t\tfinal HttpClientResponse clientResponse = new HttpClientResponse(connection);\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\thttpResponseListener.handleHttpResponse(clientResponse);\r\n\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\tconnection.disconnect();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (final Exception e) {\r\n\t\t\t\t\t\tconnection.disconnect();\r\n\t\t\t\t\t\thttpResponseListener.failed(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\thttpResponseListener.failed(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}","id":3973,"modified_method":"public void sendHttpRequest (final HttpRequest httpRequest, final HttpResponseListener httpResponseListener) {\r\n\t\tif (httpRequest.getUrl() == null) {\r\n\t\t\thttpResponseListener.failed(new GdxRuntimeException(\"can't process a HTTP request without URL set\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tfinal String method = httpRequest.getMethod();\r\n\t\t\tURL url;\r\n\r\n\t\t\tif (method.equalsIgnoreCase(HttpMethods.GET)) {\r\n\t\t\t\tString queryString = \"\";\r\n\t\t\t\tString value = httpRequest.getContent();\r\n\t\t\t\tif (value != null && !\"\".equals(value)) queryString = \"?\" + value;\r\n\t\t\t\turl = new URL(httpRequest.getUrl() + queryString);\r\n\t\t\t} else {\r\n\t\t\t\turl = new URL(httpRequest.getUrl());\r\n\t\t\t}\r\n\r\n\t\t\tfinal HttpURLConnection connection = (HttpURLConnection)url.openConnection();\r\n\t\t\t// should be enabled to upload data.\r\n\t\t\tfinal boolean doingOutPut = method.equalsIgnoreCase(HttpMethods.POST) || method.equalsIgnoreCase(HttpMethods.PUT);\r\n\t\t\tconnection.setDoOutput(doingOutPut);\r\n\t\t\tconnection.setDoInput(true);\r\n\t\t\tconnection.setRequestMethod(method);\r\n\r\n\t\t\t// Headers get set regardless of the method\r\n\t\t\tfor (Map.Entry<String, String> header : httpRequest.getHeaders().entrySet())\r\n\t\t\t\tconnection.addRequestProperty(header.getKey(), header.getValue());\r\n\r\n\t\t\t// Set Timeouts\r\n\t\t\tconnection.setConnectTimeout(httpRequest.getTimeOut());\r\n\t\t\tconnection.setReadTimeout(httpRequest.getTimeOut());\r\n\r\n\t\t\texecutorService.submit(new Runnable() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// Set the content for POST and PUT (GET has the information embedded in the URL)\r\n\t\t\t\t\t\tif (doingOutPut) {\r\n\t\t\t\t\t\t\t// we probably need to use the content as stream here instead of using it as a string.\r\n\t\t\t\t\t\t\tString contentAsString = httpRequest.getContent();\r\n\t\t\t\t\t\t\tif (contentAsString != null) {\r\n\t\t\t\t\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\twriter.write(contentAsString);\r\n\t\t\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\t\t\tStreamUtils.closeQuietly(writer);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tInputStream contentAsStream = httpRequest.getContentStream();\r\n\t\t\t\t\t\t\t\tif (contentAsStream != null) {\r\n\t\t\t\t\t\t\t\t\tOutputStream os = connection.getOutputStream();\r\n\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\tStreamUtils.copyStream(contentAsStream, os);\r\n\t\t\t\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\t\t\t\tStreamUtils.closeQuietly(os);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconnection.connect();\r\n\r\n\t\t\t\t\t\tfinal HttpClientResponse clientResponse = new HttpClientResponse(connection);\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\thttpResponseListener.handleHttpResponse(clientResponse);\r\n\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\tconnection.disconnect();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (final Exception e) {\r\n\t\t\t\t\t\tconnection.disconnect();\r\n\t\t\t\t\t\thttpResponseListener.failed(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\thttpResponseListener.failed(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic InputStream getResultAsStream () {\r\n\t\t\treturn inputStream;\r\n\t\t}","id":3974,"modified_method":"@Override\r\n\t\tpublic InputStream getResultAsStream () {\r\n\t\t\treturn getInputStream();\r\n\t\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic String getResultAsString () {\r\n\t\t\ttry {\r\n\t\t\t\treturn StreamUtils.copyStreamToString(inputStream, connection.getContentLength());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t}","id":3975,"modified_method":"@Override\r\n\t\tpublic String getResultAsString () {\r\n\t\t\ttry {\r\n\t\t\t\treturn StreamUtils.copyStreamToString(getInputStream(), connection.getContentLength());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Copy the data from an {@link InputStream} to an {@link OutputStream}.\r\n\t * @throws IOException */\r\n\tpublic static void copyStream (InputStream input, OutputStream output, int bufferSize) throws IOException {\r\n\t\tbyte[] buffer = new byte[bufferSize];\r\n\t\tint bytesRead;\r\n\t\twhile ((bytesRead = input.read(buffer)) != -1) {\r\n\t\t\toutput.write(buffer, 0, bytesRead);\r\n\t\t}\r\n\t}","id":3976,"modified_method":"/** Copy the data from an {@link InputStream} to an {@link OutputStream}.\r\n\t * @throws IOException */\r\n\tpublic static void copyStream (InputStream input, OutputStream output, int bufferSize) throws IOException {\r\n\t\ttry {\r\n\t\t\tbyte[] buffer = new byte[bufferSize];\r\n\t\t\tint bytesRead;\r\n\t\t\twhile ((bytesRead = input.read(buffer)) != -1) {\r\n\t\t\t\toutput.write(buffer, 0, bytesRead);\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tcloseQuietly(input);\r\n\t\t}\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void createHUD() {\n\t\thud = new Stage();\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\n\t\tmodelsWindow = new CollapsableWindow(\"Models\", skin);\n\t\tfinal List list = new List(models, skin);\n\t\tlist.addListener(new ClickListener() {\n\t\t\t@Override\n\t\t\tpublic void clicked (InputEvent event, float x, float y) {\n\t\t\t\tif (!modelsWindow.isCollapsed() && getTapCount() == 2) {\n\t\t\t\t\tonModelClicked(list.getSelection());\n\t\t\t\t\tmodelsWindow.collapse();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tmodelsWindow.row();\n\t\tmodelsWindow.add(list);\n\t\tmodelsWindow.pack();\n\t\tmodelsWindow.pack();\n\t\tmodelsWindow.setY(Gdx.graphics.getHeight()-modelsWindow.getHeight());\n\t\tmodelsWindow.collapse();\n\t\thud.addActor(modelsWindow);\n\t\tfpsLabel = new Label(\"FPS: 999\", skin);\n\t\thud.addActor(fpsLabel);\n\t}","id":3977,"modified_method":"protected void createHUD() {\n\t\thud = new Stage(PREF_HUDWIDTH, PREF_HUDHEIGHT, true);\n\t\thudWidth = hud.getWidth();\n\t\thudHeight = hud.getHeight();\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\n\n\t\tfinal List modelsList = new List(models, skin);\n\t\tmodelsList.addListener(new ClickListener() {\n\t\t\t@Override\n\t\t\tpublic void clicked (InputEvent event, float x, float y) {\n\t\t\t\tif (!modelsWindow.isCollapsed() && getTapCount() == 2) {\n\t\t\t\t\tonModelClicked(modelsList.getSelection());\n\t\t\t\t\tmodelsWindow.collapse();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tmodelsWindow = addListWindow(\"Models\", modelsList, 0, -1);\n\t\t\n\t\tfpsLabel = new Label(\"FPS: 999\", skin);\n\t\thud.addActor(fpsLabel);\n\t\tgridCheckBox = new CheckBox(\"Show grid\", skin);\n\t\tgridCheckBox.setChecked(showAxes);\n\t\tgridCheckBox.addListener(new ChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void changed (ChangeEvent event, Actor actor) {\n\t\t\t\tshowAxes = gridCheckBox.isChecked();\n\t\t\t}\n\t\t});\n\t\tgridCheckBox.setPosition(hudWidth - gridCheckBox.getWidth(), 0);\n\t\thud.addActor(gridCheckBox);\n\t\t\n\t\trotateCheckBox = new CheckBox(\"Rotate\", skin);\n\t\trotateCheckBox.setChecked(true);\n\t\trotateCheckBox.setPosition(hudWidth - rotateCheckBox.getWidth(), gridCheckBox.getHeight());\n\t\thud.addActor(rotateCheckBox);\n\t\t\n\t\tmoveCheckBox = new CheckBox(\"Move\", skin);\n\t\tmoveCheckBox.setChecked(false);\n\t\tmoveCheckBox.setPosition(hudWidth - moveCheckBox.getWidth(), rotateCheckBox.getTop());\n\t\thud.addActor(moveCheckBox);\n\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void render () {\n\t\tsuper.render();\n\t\t\n\t\tstringBuilder.setLength(0);\n\t\tgetStatus(stringBuilder);\n\t\tfpsLabel.setText(stringBuilder);\n\t\thud.act(Gdx.graphics.getDeltaTime());\n\t\thud.draw();\n\t}","id":3978,"modified_method":"@Override\n\tpublic void render () {\n\t\ttransform.idt();\n\t\tif (rotateCheckBox.isChecked())\n\t\t\ttransform.rotate(Vector3.Y, rotation = (rotation + rotationSpeed * Gdx.graphics.getRawDeltaTime()) % 360);\n\t\tif (moveCheckBox.isChecked()) {\n\t\t\tmovement = (movement + moveSpeed * Gdx.graphics.getRawDeltaTime()) % 1f;\n\t\t\tfinal float sm = MathUtils.sin(movement * MathUtils.PI2);\n\t\t\tfinal float cm = MathUtils.cos(movement * MathUtils.PI2);\n\t\t\ttransform.trn(0, moveRadius * cm, moveRadius * sm);\n\t\t}\n\t\t\n\t\tsuper.render();\n\t\t\n\t\tstringBuilder.setLength(0);\n\t\tgetStatus(stringBuilder);\n\t\tfpsLabel.setText(stringBuilder);\n\t\thud.act(Gdx.graphics.getDeltaTime());\n\t\thud.draw();\n\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void collapse() {\n\t\t\tif (collapsed) return;\n\t\t\texpandHeight = getHeight();\n\t\t\tsetHeight(collapseHeight);\n\t\t\tsetY(getY()+expandHeight-collapseHeight);\n\t\t\tcollapsed = true;\n\t\t}","id":3979,"modified_method":"public void collapse() {\n\t\t\tif (collapsed) return;\n\t\t\texpandHeight = getHeight();\n\t\t\tsetHeight(collapseHeight);\n\t\t\tsetY(getY()+expandHeight-collapseHeight);\n\t\t\tcollapsed = true;\n\t\t\tif (getStage() != null)\n\t\t\t\tgetStage().setScrollFocus(null);\n\t\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void render () {\n\t\tif (loading && assets.update()) {\n\t\t\tloading = false;\n\t\t\tonLoaded();\n\t\t}\n\t\t\n\t\tinputController.update();\n\t\t\n\t\tGdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n\n\t\tmodelBatch.begin(cam);\n\t\tif (showAxes)\n\t\t\tmodelBatch.render(axesInstance);\n\t\trender(modelBatch, instances);\n\t\tmodelBatch.end();\n\t}","id":3980,"modified_method":"@Override\n\tpublic void render () {\n\t\tif (loading && assets.update()) {\n\t\t\tloading = false;\n\t\t\tonLoaded();\n\t\t}\n\t\t\n\t\tinputController.update();\n\t\t\n\t\tGdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n\n\t\trender(instances);\n\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void create () {\n\t\tif (assets == null)\n\t\t\tassets = new AssetManager();\n\t\t\n\t\tmodelBatch = new ModelBatch();\n\t\t\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\n\t\tcam.position.set(10f, 10f, 10f);\n\t\tcam.lookAt(0,0,0);\n\t\tcam.near = 0.1f;\n\t\tcam.far = 300f;\n\t\tcam.update();\n\t\t\n\t\tcreateAxes();\n\n\t\tGdx.input.setInputProcessor(inputController = new CameraInputController(cam));\n\t}","id":3981,"modified_method":"@Override\n\tpublic void create () {\n\t\tif (assets == null)\n\t\t\tassets = new AssetManager();\n\t\t\n\t\tmodelBatch = new ModelBatch();\n\t\t\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\n\t\tcam.position.set(10f, 10f, 10f);\n\t\tcam.lookAt(0,0,0);\n\t\tcam.near = 0.1f;\n\t\tcam.far = 1000f;\n\t\tcam.update();\n\t\t\n\t\tcreateAxes();\n\n\t\tGdx.input.setInputProcessor(inputController = new CameraInputController(cam));\n\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected Void receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                LOOP:\n                while (true) {\n                    byte command = unmarshaller.readByte();\n                    switch (command) {\n                        case ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT:{\n                            expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_LOCATION);\n                            String[] location = unmarshal(unmarshaller, String[].class);\n                            expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_OPERATION);\n                            ModelNode node = unmarshal(unmarshaller, ModelNode.class);\n                            handler.handleResultFragment(location, node);\n                            break;\n                        }\n                        case ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION:{\n                            handler.handleCancellation();\n                            break LOOP;\n                        }\n                        case ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE:{\n                            expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_OPERATION);\n                            ModelNode node = unmarshal(unmarshaller, ModelNode.class);\n                            handler.handleResultComplete(node);\n                            break LOOP;\n                        }\n                        case ModelControllerClientProtocol.PARAM_REQUEST_ID:{\n                            result.setAsynchronousId(unmarshaller.readInt());\n                            break;\n                        }\n                        default:{\n                            throw new IllegalStateException(\"Unknown response code \" + command);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                handler.handleException(e);\n            } finally {\n                safeFinish(unmarshaller);\n            }\n            return null;\n        }","id":3982,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected Void receiveResponse(InputStream input) throws IOException {\n            try {\n                LOOP:\n                while (true) {\n                    int command = input.read();\n                    switch (command) {\n                        case ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT:{\n                            expectHeader(input, ModelControllerClientProtocol.PARAM_LOCATION);\n                            int length = StreamUtils.readInt(input);\n                            String[] location = new String[length];\n                            for (int i = 0 ; i < length ; i++) {\n                                location[i] = StreamUtils.readUTFZBytes(input);\n                            }\n                            expectHeader(input, ModelControllerClientProtocol.PARAM_OPERATION);\n                            ModelNode node = readNode(input);\n                            handler.handleResultFragment(location, node);\n                            break;\n                        }\n                        case ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION:{\n                            handler.handleCancellation();\n                            break LOOP;\n                        }\n                        case ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE:{\n                            expectHeader(input, ModelControllerClientProtocol.PARAM_OPERATION);\n                            ModelNode node = readNode(input);\n                            handler.handleResultComplete(node);\n                            break LOOP;\n                        }\n                        case ModelControllerClientProtocol.PARAM_REQUEST_ID:{\n                            result.setAsynchronousId(StreamUtils.readInt(input));\n                            break;\n                        }\n                        default:{\n                            throw new IllegalStateException(\"Unknown response code \" + command);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                handler.handleException(e);\n            }\n            return null;\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            try {\n                marshaller.start(createByteOutput(output));\n                marshaller.writeByte(ModelControllerClientProtocol.PARAM_REQUEST_ID);\n                marshaller.writeInt(asynchronousId);\n                marshaller.finish();\n            }\n            finally {\n                safeFinish(marshaller);\n            }\n        }","id":3983,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            output.write(ModelControllerClientProtocol.PARAM_REQUEST_ID);\n            StreamUtils.writeInt(output, asynchronousId);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            try {\n                marshaller.start(createByteOutput(output));\n                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                marshaller.writeObject(operation);\n                marshaller.finish();\n            } catch (Exception e) {\n                handler.handleException(e);\n            } finally {\n                safeFinish(marshaller);\n            }\n        }","id":3984,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            output.write(ModelControllerClientProtocol.PARAM_OPERATION);\n            operation.writeExternal(output);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            try {\n                marshaller.start(createByteOutput(output));\n                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                marshaller.writeObject(operation);\n                marshaller.finish();\n            }\n            finally {\n                safeFinish(marshaller);\n            }\n        }","id":3985,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            output.write(ModelControllerClientProtocol.PARAM_OPERATION);\n            operation.writeExternal(output);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected ModelNode receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_OPERATION);\n                ModelNode result = unmarshal(unmarshaller, ModelNode.class);\n                unmarshaller.finish();\n                return result;\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","id":3986,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected ModelNode receiveResponse(InputStream input) throws IOException {\n            expectHeader(input, ModelControllerClientProtocol.PARAM_OPERATION);\n            return readNode(input);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n\n            final Marshaller marshaller = getMarshaller();\n            try {\n                final ByteOutput output = createByteOutput(outputStream);\n                marshaller.start(output);\n\n                final CountDownLatch completeLatch = new CountDownLatch(1);\n                final IOExceptionHolder holder = new IOExceptionHolder();\n                Cancellable result = modelController.execute(operation, new ResultHandler() {\n                    @Override\n                    public void handleResultFragment(String[] location, ModelNode result) {\n                        try {\n                            synchronized (marshaller) {\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT);\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_LOCATION);\n                                marshaller.writeObject(location);\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                                marshaller.writeObject(result);\n                                marshaller.flush();\n                            }\n                        } catch (IOException e) {\n                            handleIOException(e);\n                        }\n                    }\n\n                    @Override\n                    public void handleResultComplete(ModelNode compensatingOperation) {\n                        try {\n                            asynchOperations.remove(asynchronousRequestId);\n                            synchronized (marshaller) {\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE);\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                                marshaller.writeObject(compensatingOperation);\n                                marshaller.flush();\n                            }\n                            completeLatch.countDown();\n                        } catch (IOException e) {\n                            handleIOException(e);\n                        }\n                    }\n\n                    public void handleFailed(final ModelNode failureDescription) {\n                        try {\n                            asynchOperations.remove(asynchronousRequestId);\n                            synchronized (marshaller) {\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FAILED);\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                                marshaller.writeObject(failureDescription);\n                                marshaller.flush();\n                            }\n                            completeLatch.countDown();\n                        } catch (IOException e) {\n                            handleIOException(e);\n                        }\n                    }\n\n                    @Override\n                    public void handleCancellation() {\n                        try {\n                            asynchOperations.remove(asynchronousRequestId);\n                            synchronized (marshaller) {\n                                marshaller.writeByte(ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION);\n                                marshaller.flush();\n                            }\n                            completeLatch.countDown();\n                        } catch (IOException e) {\n                            handleIOException(e);\n                        }\n                    }\n\n                    private void handleIOException(IOException e) {\n                        asynchOperations.remove(asynchronousRequestId);\n                        holder.setException(e);\n                        completeLatch.countDown();\n                    }\n                });\n\n                if (completeLatch.getCount() == 0) {\n                    //It was handled synchronously or has completed by now\n\n//                    synchronized (marshaller) {\n//                        marshaller.writeByte(ModelControllerClientProtocol.RTN_REQUEST_ID);\n//                        marshaller.writeInt(-1);\n//                    }\n                } else {\n                    //It was handled asynchronously\n                    asynchOperations.put(Integer.valueOf(asynchronousRequestId), result);\n                    synchronized (marshaller) {\n                        marshaller.writeByte(ModelControllerClientProtocol.PARAM_REQUEST_ID);\n                        marshaller.writeInt(asynchronousRequestId);\n                        marshaller.flush();\n                    }\n\n                    while (true) {\n                        try {\n                            completeLatch.await();\n                            break;\n                        } catch (InterruptedException e) {\n                        }\n                    }\n\n                    if (holder.getException() != null) {\n                        throw holder.getException();\n                    }\n                }\n\n                marshaller.finish();\n            }\n            finally {\n                safeFinish(marshaller);\n            }\n        }","id":3987,"modified_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n            final CountDownLatch completeLatch = new CountDownLatch(1);\n            final IOExceptionHolder holder = new IOExceptionHolder();\n            Cancellable result = modelController.execute(operation, new ResultHandler() {\n                @Override\n                public void handleResultFragment(String[] location, ModelNode result) {\n                    try {\n                        synchronized (outputStream) {\n                            outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT);\n                            outputStream.write(ModelControllerClientProtocol.PARAM_LOCATION);\n                            StreamUtils.writeInt(outputStream, location.length);\n                            for (String loc : location) {\n                                StreamUtils.writeUTFZBytes(outputStream, loc);\n                            }\n                            outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);\n                            result.writeExternal(outputStream);\n                            outputStream.flush();\n                        }\n                    } catch (IOException e) {\n                        handleIOException(e);\n                    }\n                }\n\n                @Override\n                public void handleResultComplete(ModelNode compensatingOperation) {\n                    try {\n                        asynchOperations.remove(asynchronousRequestId);\n                        synchronized (outputStream) {\n                            outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE);\n                            outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);\n                            compensatingOperation.writeExternal(outputStream);\n                            //outputStream.flush();\n                        }\n                        completeLatch.countDown();\n                    } catch (IOException e) {\n                        handleIOException(e);\n                    }\n                }\n\n                public void handleFailed(final ModelNode failureDescription) {\n                    try {\n                        asynchOperations.remove(asynchronousRequestId);\n                        synchronized (outputStream) {\n                            outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FAILED);\n                            outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);\n                            failureDescription.writeExternal(outputStream);\n                            //outputStream.flush();\n                        }\n                        completeLatch.countDown();\n                    } catch (IOException e) {\n                        handleIOException(e);\n                    }\n                }\n\n                @Override\n                public void handleCancellation() {\n                    try {\n                        asynchOperations.remove(asynchronousRequestId);\n                        synchronized (outputStream) {\n                            outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION);\n                            //outputStream.flush();\n                        }\n                        completeLatch.countDown();\n                    } catch (IOException e) {\n                        handleIOException(e);\n                    }\n                }\n\n                private void handleIOException(IOException e) {\n                    asynchOperations.remove(asynchronousRequestId);\n                    holder.setException(e);\n                    completeLatch.countDown();\n                }\n            });\n\n            if (completeLatch.getCount() == 0) {\n                //It was handled synchronously or has completed by now\n            } else {\n                //It was handled asynchronously\n                asynchOperations.put(Integer.valueOf(asynchronousRequestId), result);\n                synchronized (outputStream) {\n                    outputStream.write(ModelControllerClientProtocol.PARAM_REQUEST_ID);\n                    StreamUtils.writeInt(outputStream, asynchronousRequestId);\n                    outputStream.flush();\n                }\n\n                while (true) {\n                    try {\n                        completeLatch.await();\n                        break;\n                    } catch (InterruptedException e) {\n                    }\n                }\n\n                if (holder.getException() != null) {\n                    throw holder.getException();\n                }\n            }\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(inputStream));\n            try {\n                expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_OPERATION);\n                operation = unmarshal(unmarshaller, ModelNode.class);\n                unmarshaller.finish();\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","id":3988,"modified_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n            expectHeader(inputStream, ModelControllerClientProtocol.PARAM_OPERATION);\n            operation = readNode(inputStream);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n            ModelNode result = null;\n            try {\n                result = modelController.execute(operation);\n            } catch (OperationFailedException e) {\n                throw new IOException(e);\n            }\n            final Marshaller marshaller = getMarshaller();\n            try {\n                marshaller.start(createByteOutput(outputStream));\n                marshaller.writeByte(ModelControllerClientProtocol.PARAM_OPERATION);\n                marshaller.writeObject(result);\n                marshaller.finish();\n            }\n            finally {\n                safeFinish(marshaller);\n            }\n        }","id":3989,"modified_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n            ModelNode result = null;\n            try {\n                result = modelController.execute(operation);\n            } catch (OperationFailedException e) {\n                throw new IOException(e);\n            }\n            outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);\n            result.writeExternal(outputStream);\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(inputStream));\n            int operationId = 0;\n            try {\n                expectHeader(unmarshaller, ModelControllerClientProtocol.PARAM_REQUEST_ID);\n                operationId = unmarshaller.readInt();\n                unmarshaller.finish();\n            } finally {\n                safeFinish(unmarshaller);\n            }\n\n            Cancellable operation = asynchOperations.get(Integer.valueOf(operationId));\n            if (operation != null) {\n                operation.cancel();\n            }\n        }","id":3990,"modified_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n\n            expectHeader(inputStream, ModelControllerClientProtocol.PARAM_REQUEST_ID);\n            int operationId = StreamUtils.readInt(inputStream);\n\n            Cancellable operation = asynchOperations.get(Integer.valueOf(operationId));\n            if (operation != null) {\n                operation.cancel();\n            }\n        }","commit_id":"d8f37987c955b4baed8264642b98b0e1aa884b7e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public double metric(String name, long owningBucketOrd) {\n        switch(InternalExtendedStats.Metrics.resolve(name)) {\n            case count: return valuesSource == null ? 0 : counts.get(owningBucketOrd);\n            case sum: return valuesSource == null ? 0 : sums.get(owningBucketOrd);\n            case min: return valuesSource == null ? Double.POSITIVE_INFINITY : mins.get(owningBucketOrd);\n            case max: return valuesSource == null ? Double.NEGATIVE_INFINITY : maxes.get(owningBucketOrd);\n            case avg: return valuesSource == null ? Double.NaN : sums.get(owningBucketOrd) / counts.get(owningBucketOrd);\n            case sum_of_squares: return valuesSource == null ? 0 : sumOfSqrs.get(owningBucketOrd);\n            case variance: return valuesSource == null ? Double.NaN : variance(owningBucketOrd);\n            case std_deviation: return valuesSource == null ? Double.NaN : Math.sqrt(variance(owningBucketOrd));\n            default:\n                throw new ElasticsearchIllegalArgumentException(\"Unknown value [\" + name + \"] in common stats aggregation\");\n        }\n    }","id":3991,"modified_method":"@Override\n    public double metric(String name, long owningBucketOrd) {\n        switch(InternalExtendedStats.Metrics.resolve(name)) {\n            case count: return valuesSource == null ? 0 : counts.get(owningBucketOrd);\n            case sum: return valuesSource == null ? 0 : sums.get(owningBucketOrd);\n            case min: return valuesSource == null ? Double.POSITIVE_INFINITY : mins.get(owningBucketOrd);\n            case max: return valuesSource == null ? Double.NEGATIVE_INFINITY : maxes.get(owningBucketOrd);\n            case avg: return valuesSource == null ? Double.NaN : sums.get(owningBucketOrd) / counts.get(owningBucketOrd);\n            case sum_of_squares: return valuesSource == null ? 0 : sumOfSqrs.get(owningBucketOrd);\n            case variance: return valuesSource == null ? Double.NaN : variance(owningBucketOrd);\n            case std_deviation: return valuesSource == null ? Double.NaN : Math.sqrt(variance(owningBucketOrd));\n            case std_upper:\n                if (valuesSource == null) { return Double.NaN; }\n                return (sums.get(owningBucketOrd) / counts.get(owningBucketOrd)) + (Math.sqrt(variance(owningBucketOrd)) * this.sigma);\n            case std_lower:\n                if (valuesSource == null) { return Double.NaN; }\n                return (sums.get(owningBucketOrd) / counts.get(owningBucketOrd)) - (Math.sqrt(variance(owningBucketOrd)) * this.sigma);\n            default:\n                throw new ElasticsearchIllegalArgumentException(\"Unknown value [\" + name + \"] in common stats aggregation\");\n        }\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ExtendedStatsAggregator(String name, ValuesSource.Numeric valuesSource,\n            @Nullable ValueFormatter formatter, AggregationContext context, Aggregator parent, Map<String, Object> metaData) throws IOException {\n        super(name, context, parent, metaData);\n        this.valuesSource = valuesSource;\n        this.formatter = formatter;\n        if (valuesSource != null) {\n            counts = bigArrays.newLongArray(1, true);\n            sums = bigArrays.newDoubleArray(1, true);\n            mins = bigArrays.newDoubleArray(1, false);\n            mins.fill(0, mins.size(), Double.POSITIVE_INFINITY);\n            maxes = bigArrays.newDoubleArray(1, false);\n            maxes.fill(0, maxes.size(), Double.NEGATIVE_INFINITY);\n            sumOfSqrs = bigArrays.newDoubleArray(1, true);\n        }\n    }","id":3992,"modified_method":"public ExtendedStatsAggregator(String name, ValuesSource.Numeric valuesSource,\n                                   @Nullable ValueFormatter formatter, AggregationContext context,\n                                   Aggregator parent, double sigma, Map<String, Object> metaData) throws IOException {\n        super(name, context, parent, metaData);\n        this.valuesSource = valuesSource;\n        this.formatter = formatter;\n        if (valuesSource != null) {\n            counts = bigArrays.newLongArray(1, true);\n            sums = bigArrays.newDoubleArray(1, true);\n            mins = bigArrays.newDoubleArray(1, false);\n            mins.fill(0, mins.size(), Double.POSITIVE_INFINITY);\n            maxes = bigArrays.newDoubleArray(1, false);\n            maxes.fill(0, maxes.size(), Double.NEGATIVE_INFINITY);\n            sumOfSqrs = bigArrays.newDoubleArray(1, true);\n            this.sigma = sigma;\n        }\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Factory(String name, ValuesSourceConfig<ValuesSource.Numeric> valuesSourceConfig) {\n            super(name, InternalExtendedStats.TYPE.name(), valuesSourceConfig);\n        }","id":3993,"modified_method":"public Factory(String name, ValuesSourceConfig<ValuesSource.Numeric> valuesSourceConfig, double sigma) {\n            super(name, InternalExtendedStats.TYPE.name(), valuesSourceConfig);\n\n            this.sigma = sigma;\n        }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        protected Aggregator doCreateInternal(ValuesSource.Numeric valuesSource, AggregationContext aggregationContext, Aggregator parent, boolean collectsFromSingleBucket, Map<String, Object> metaData) throws IOException {\n            return new ExtendedStatsAggregator(name, valuesSource, config.formatter(), aggregationContext, parent,\n                    metaData);\n        }","id":3994,"modified_method":"@Override\n        protected Aggregator doCreateInternal(ValuesSource.Numeric valuesSource, AggregationContext aggregationContext, Aggregator parent, boolean collectsFromSingleBucket, Map<String, Object> metaData) throws IOException {\n            return new ExtendedStatsAggregator(name, valuesSource, config.formatter(), aggregationContext, parent, sigma, metaData);\n        }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        protected Aggregator createUnmapped(AggregationContext aggregationContext, Aggregator parent, Map<String, Object> metaData) throws IOException {\n            return new ExtendedStatsAggregator(name, null, config.formatter(), aggregationContext, parent, metaData);\n        }","id":3995,"modified_method":"@Override\n        protected Aggregator createUnmapped(AggregationContext aggregationContext, Aggregator parent, Map<String, Object> metaData) throws IOException {\n            return new ExtendedStatsAggregator(name, null, config.formatter(), aggregationContext, parent, sigma, metaData);\n        }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public InternalAggregation buildEmptyAggregation() {\n        return new InternalExtendedStats(name, 0, 0d, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, formatter, metaData());\n    }","id":3996,"modified_method":"@Override\n    public InternalAggregation buildEmptyAggregation() {\n        return new InternalExtendedStats(name, 0, 0d, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, 0d, formatter, metaData());\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n        if (valuesSource == null) {\n            return new InternalExtendedStats(name, 0, 0d, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, formatter, metaData());\n        }\n        assert owningBucketOrdinal < counts.size();\n        return new InternalExtendedStats(name, counts.get(owningBucketOrdinal), sums.get(owningBucketOrdinal),\n                mins.get(owningBucketOrdinal), maxes.get(owningBucketOrdinal), sumOfSqrs.get(owningBucketOrdinal), formatter, metaData());\n    }","id":3997,"modified_method":"@Override\n    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n        if (valuesSource == null) {\n            return new InternalExtendedStats(name, 0, 0d, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, 0d, formatter, metaData());\n        }\n        assert owningBucketOrdinal < counts.size();\n        return new InternalExtendedStats(name, counts.get(owningBucketOrdinal), sums.get(owningBucketOrdinal),\n                mins.get(owningBucketOrdinal), maxes.get(owningBucketOrdinal), sumOfSqrs.get(owningBucketOrdinal), sigma, formatter, metaData());\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected AggregatorFactory createFactory(String aggregationName, ValuesSourceConfig<ValuesSource.Numeric> config) {\n        return new ExtendedStatsAggregator.Factory(aggregationName, config);\n    }","id":3998,"modified_method":"protected AggregatorFactory createFactory(String aggregationName, ValuesSourceConfig<ValuesSource.Numeric> config, double sigma) {\n        return new ExtendedStatsAggregator.Factory(aggregationName, config, sigma);\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testScript_MultiValued_WithParams() throws Exception {\n        SearchResponse searchResponse = client().prepareSearch(\"idx\")\n                .setQuery(matchAllQuery())\n                .addAggregation(extendedStats(\"stats\").script(\"[ doc['value'].value, doc['value'].value - dec ]\").param(\"dec\", 1))\n                .execute().actionGet();\n\n        assertThat(searchResponse.getHits().getTotalHits(), equalTo(10l));\n\n        ExtendedStats stats = searchResponse.getAggregations().get(\"stats\");\n        assertThat(stats, notNullValue());\n        assertThat(stats.getName(), equalTo(\"stats\"));\n        assertThat(stats.getAvg(), equalTo((double) (1+2+3+4+5+6+7+8+9+10+0+1+2+3+4+5+6+7+8+9) / 20));\n        assertThat(stats.getMin(), equalTo(0.0));\n        assertThat(stats.getMax(), equalTo(10.0));\n        assertThat(stats.getSum(), equalTo((double) 1+2+3+4+5+6+7+8+9+10+0+1+2+3+4+5+6+7+8+9));\n        assertThat(stats.getCount(), equalTo(20l));\n        assertThat(stats.getSumOfSquares(), equalTo((double) 1+4+9+16+25+36+49+64+81+100+0+1+4+9+16+25+36+49+64+81));\n        assertThat(stats.getVariance(), equalTo(variance(1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8 ,9)));\n        assertThat(stats.getStdDeviation(), equalTo(stdDev(1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8 ,9)));\n    }","id":3999,"modified_method":"@Test\n    public void testScript_MultiValued_WithParams() throws Exception {\n        double sigma = randomDouble() * randomIntBetween(1, 10);\n        SearchResponse searchResponse = client().prepareSearch(\"idx\")\n                .setQuery(matchAllQuery())\n                .addAggregation(extendedStats(\"stats\").script(\"[ doc['value'].value, doc['value'].value - dec ]\").param(\"dec\", 1).sigma(sigma))\n                .execute().actionGet();\n\n        assertThat(searchResponse.getHits().getTotalHits(), equalTo(10l));\n\n        ExtendedStats stats = searchResponse.getAggregations().get(\"stats\");\n        assertThat(stats, notNullValue());\n        assertThat(stats.getName(), equalTo(\"stats\"));\n        assertThat(stats.getAvg(), equalTo((double) (1+2+3+4+5+6+7+8+9+10+0+1+2+3+4+5+6+7+8+9) / 20));\n        assertThat(stats.getMin(), equalTo(0.0));\n        assertThat(stats.getMax(), equalTo(10.0));\n        assertThat(stats.getSum(), equalTo((double) 1+2+3+4+5+6+7+8+9+10+0+1+2+3+4+5+6+7+8+9));\n        assertThat(stats.getCount(), equalTo(20l));\n        assertThat(stats.getSumOfSquares(), equalTo((double) 1+4+9+16+25+36+49+64+81+100+0+1+4+9+16+25+36+49+64+81));\n        assertThat(stats.getVariance(), equalTo(variance(1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8 ,9)));\n        assertThat(stats.getStdDeviation(), equalTo(stdDev(1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8 ,9)));\n        checkUpperLowerBounds(stats, sigma);\n    }","commit_id":"a4eb1d55051b4b6671938ae1213a205c106438d0","url":"https://github.com/elastic/elasticsearch"}]